#RequireAdmin
#pragma compile(Icon, "Images\MyBot.ico")
#pragma compile(FileDescription, Clash of Clans Bot - A Free Clash of Clans bot - https://mybot.run)
#pragma compile(ProductName, My Bot)
#pragma compile(ProductVersion, 6.2.2)
#pragma compile(FileVersion, 6.2.2)
#pragma compile(LegalCopyright, Â© https://mybot.run)
#pragma compile(Out, MyBot.run.exe)  ; Required
#AutoIt3Wrapper_UseX64=7n
#AutoIt3Wrapper_Run_Au3Stripper=y
#Au3Stripper_Parameters=/mo /rsln
Global Const $WC_ANIMATE = 'SysAnimate32'
Global Const $WC_BUTTON = 'Button'
Global Const $WC_COMBOBOX = 'ComboBox'
Global Const $WC_COMBOBOXEX = 'ComboBoxEx32'
Global Const $WC_DATETIMEPICK = 'SysDateTimePick32'
Global Const $WC_EDIT = 'Edit'
Global Const $WC_HEADER = 'SysHeader32'
Global Const $WC_HOTKEY = 'msctls_hotkey32'
Global Const $WC_IPADDRESS = 'SysIPAddress32'
Global Const $WC_LINK = 'SysLink'
Global Const $WC_LISTBOX = 'ListBox'
Global Const $WC_LISTVIEW = 'SysListView32'
Global Const $WC_MONTHCAL = 'SysMonthCal32'
Global Const $WC_NATIVEFONTCTL = 'NativeFontCtl'
Global Const $WC_PAGESCROLLER = 'SysPager'
Global Const $WC_PROGRESS = 'msctls_progress32'
Global Const $WC_REBAR = 'ReBarWindow32'
Global Const $WC_SCROLLBAR = 'ScrollBar'
Global Const $WC_STATIC = 'Static'
Global Const $WC_STATUSBAR = 'msctls_statusbar32'
Global Const $WC_TABCONTROL = 'SysTabControl32'
Global Const $WC_TOOLBAR = 'ToolbarWindow32'
Global Const $WC_TOOLTIPS = 'tooltips_class32'
Global Const $WC_TRACKBAR = 'msctls_trackbar32'
Global Const $WC_TREEVIEW = 'SysTreeView32'
Global Const $WC_UPDOWN = 'msctls_updown32'
Global Const $WS_OVERLAPPED = 0
Global Const $WS_TILED = $WS_OVERLAPPED
Global Const $WS_MAXIMIZEBOX = 0x00010000
Global Const $WS_MINIMIZEBOX = 0x00020000
Global Const $WS_TABSTOP = 0x00010000
Global Const $WS_GROUP = 0x00020000
Global Const $WS_SIZEBOX = 0x00040000
Global Const $WS_THICKFRAME = $WS_SIZEBOX
Global Const $WS_SYSMENU = 0x00080000
Global Const $WS_HSCROLL = 0x00100000
Global Const $WS_VSCROLL = 0x00200000
Global Const $WS_DLGFRAME = 0x00400000
Global Const $WS_BORDER = 0x00800000
Global Const $WS_CAPTION = 0x00C00000
Global Const $WS_OVERLAPPEDWINDOW = BitOR($WS_CAPTION, $WS_MAXIMIZEBOX, $WS_MINIMIZEBOX, $WS_OVERLAPPED, $WS_SYSMENU, $WS_THICKFRAME)
Global Const $WS_TILEDWINDOW = $WS_OVERLAPPEDWINDOW
Global Const $WS_MAXIMIZE = 0x01000000
Global Const $WS_CLIPCHILDREN = 0x02000000
Global Const $WS_CLIPSIBLINGS = 0x04000000
Global Const $WS_DISABLED = 0x08000000
Global Const $WS_VISIBLE = 0x10000000
Global Const $WS_MINIMIZE = 0x20000000
Global Const $WS_ICONIC = $WS_MINIMIZE
Global Const $WS_CHILD = 0x40000000
Global Const $WS_CHILDWINDOW = $WS_CHILD
Global Const $WS_POPUP = 0x80000000
Global Const $WS_POPUPWINDOW = 0x80880000
Global Const $DS_3DLOOK = 0x0004
Global Const $DS_ABSALIGN = 0x0001
Global Const $DS_CENTER = 0x0800
Global Const $DS_CENTERMOUSE = 0x1000
Global Const $DS_CONTEXTHELP = 0x2000
Global Const $DS_CONTROL = 0x0400
Global Const $DS_FIXEDSYS = 0x0008
Global Const $DS_LOCALEDIT = 0x0020
Global Const $DS_MODALFRAME = 0x0080
Global Const $DS_NOFAILCREATE = 0x0010
Global Const $DS_NOIDLEMSG = 0x0100
Global Const $DS_SETFONT = 0x0040
Global Const $DS_SETFOREGROUND = 0x0200
Global Const $DS_SHELLFONT = BitOR($DS_FIXEDSYS, $DS_SETFONT)
Global Const $DS_SYSMODAL = 0x0002
Global Const $WS_EX_ACCEPTFILES = 0x00000010
Global Const $WS_EX_APPWINDOW = 0x00040000
Global Const $WS_EX_COMPOSITED = 0x02000000
Global Const $WS_EX_CONTROLPARENT = 0x10000
Global Const $WS_EX_CLIENTEDGE = 0x00000200
Global Const $WS_EX_CONTEXTHELP = 0x00000400
Global Const $WS_EX_DLGMODALFRAME = 0x00000001
Global Const $WS_EX_LAYERED = 0x00080000
Global Const $WS_EX_LAYOUTRTL = 0x400000
Global Const $WS_EX_LEFT = 0x00000000
Global Const $WS_EX_LEFTSCROLLBAR = 0x00004000
Global Const $WS_EX_LTRREADING = 0x00000000
Global Const $WS_EX_MDICHILD = 0x00000040
Global Const $WS_EX_NOACTIVATE = 0x08000000
Global Const $WS_EX_NOINHERITLAYOUT = 0x00100000
Global Const $WS_EX_NOPARENTNOTIFY = 0x00000004
Global Const $WS_EX_RIGHT = 0x00001000
Global Const $WS_EX_RIGHTSCROLLBAR = 0x00000000
Global Const $WS_EX_RTLREADING = 0x2000
Global Const $WS_EX_STATICEDGE = 0x00020000
Global Const $WS_EX_TOOLWINDOW = 0x00000080
Global Const $WS_EX_TOPMOST = 0x00000008
Global Const $WS_EX_TRANSPARENT = 0x00000020
Global Const $WS_EX_WINDOWEDGE = 0x00000100
Global Const $WS_EX_OVERLAPPEDWINDOW = BitOR($WS_EX_CLIENTEDGE, $WS_EX_WINDOWEDGE)
Global Const $WS_EX_PALETTEWINDOW = BitOR($WS_EX_TOOLWINDOW, $WS_EX_TOPMOST, $WS_EX_WINDOWEDGE)
Global Const $WM_NULL = 0x0000
Global Const $WM_CREATE = 0x0001
Global Const $WM_DESTROY = 0x0002
Global Const $WM_MOVE = 0x0003
Global Const $WM_SIZEWAIT = 0x0004
Global Const $WM_SIZE = 0x0005
Global Const $WM_ACTIVATE = 0x0006
Global Const $WM_SETFOCUS = 0x0007
Global Const $WM_KILLFOCUS = 0x0008
Global Const $WM_SETVISIBLE = 0x0009
Global Const $WM_ENABLE = 0x000A
Global Const $WM_SETREDRAW = 0x000B
Global Const $WM_SETTEXT = 0x000C
Global Const $WM_GETTEXT = 0x000D
Global Const $WM_GETTEXTLENGTH = 0x000E
Global Const $WM_PAINT = 0x000F
Global Const $WM_CLOSE = 0x0010
Global Const $WM_QUERYENDSESSION = 0x0011
Global Const $WM_QUIT = 0x0012
Global Const $WM_ERASEBKGND = 0x0014
Global Const $WM_QUERYOPEN = 0x0013
Global Const $WM_SYSCOLORCHANGE = 0x0015
Global Const $WM_ENDSESSION = 0x0016
Global Const $WM_SYSTEMERROR = 0x0017
Global Const $WM_SHOWWINDOW = 0x0018
Global Const $WM_CTLCOLOR = 0x0019
Global Const $WM_SETTINGCHANGE = 0x001A
Global Const $WM_WININICHANGE = 0x001A
Global Const $WM_DEVMODECHANGE = 0x001B
Global Const $WM_ACTIVATEAPP = 0x001C
Global Const $WM_FONTCHANGE = 0x001D
Global Const $WM_TIMECHANGE = 0x001E
Global Const $WM_CANCELMODE = 0x001F
Global Const $WM_SETCURSOR = 0x0020
Global Const $WM_MOUSEACTIVATE = 0x0021
Global Const $WM_CHILDACTIVATE = 0x0022
Global Const $WM_QUEUESYNC = 0x0023
Global Const $WM_GETMINMAXINFO = 0x0024
Global Const $WM_LOGOFF = 0x0025
Global Const $WM_PAINTICON = 0x0026
Global Const $WM_ICONERASEBKGND = 0x0027
Global Const $WM_NEXTDLGCTL = 0x0028
Global Const $WM_ALTTABACTIVE = 0x0029
Global Const $WM_SPOOLERSTATUS = 0x002A
Global Const $WM_DRAWITEM = 0x002B
Global Const $WM_MEASUREITEM = 0x002C
Global Const $WM_DELETEITEM = 0x002D
Global Const $WM_VKEYTOITEM = 0x002E
Global Const $WM_CHARTOITEM = 0x002F
Global Const $WM_SETFONT = 0x0030
Global Const $WM_GETFONT = 0x0031
Global Const $WM_SETHOTKEY = 0x0032
Global Const $WM_GETHOTKEY = 0x0033
Global Const $WM_FILESYSCHANGE = 0x0034
Global Const $WM_ISACTIVEICON = 0x0035
Global Const $WM_QUERYPARKICON = 0x0036
Global Const $WM_QUERYDRAGICON = 0x0037
Global Const $WM_WINHELP = 0x0038
Global Const $WM_COMPAREITEM = 0x0039
Global Const $WM_FULLSCREEN = 0x003A
Global Const $WM_CLIENTSHUTDOWN = 0x003B
Global Const $WM_DDEMLEVENT = 0x003C
Global Const $WM_GETOBJECT = 0x003D
Global Const $WM_CALCSCROLL = 0x003F
Global Const $WM_TESTING = 0x0040
Global Const $WM_COMPACTING = 0x0041
Global Const $WM_OTHERWINDOWCREATED = 0x0042
Global Const $WM_OTHERWINDOWDESTROYED = 0x0043
Global Const $WM_COMMNOTIFY = 0x0044
Global Const $WM_MEDIASTATUSCHANGE = 0x0045
Global Const $WM_WINDOWPOSCHANGING = 0x0046
Global Const $WM_WINDOWPOSCHANGED = 0x0047
Global Const $WM_POWER = 0x0048
Global Const $WM_COPYGLOBALDATA = 0x0049
Global Const $WM_COPYDATA = 0x004A
Global Const $WM_CANCELJOURNAL = 0x004B
Global Const $WM_LOGONNOTIFY = 0x004C
Global Const $WM_KEYF1 = 0x004D
Global Const $WM_NOTIFY = 0x004E
Global Const $WM_ACCESS_WINDOW = 0x004F
Global Const $WM_INPUTLANGCHANGEREQUEST = 0x0050
Global Const $WM_INPUTLANGCHANGE = 0x0051
Global Const $WM_TCARD = 0x0052
Global Const $WM_HELP = 0x0053
Global Const $WM_USERCHANGED = 0x0054
Global Const $WM_NOTIFYFORMAT = 0x0055
Global Const $WM_QM_ACTIVATE = 0x0060
Global Const $WM_HOOK_DO_CALLBACK = 0x0061
Global Const $WM_SYSCOPYDATA = 0x0062
Global Const $WM_FINALDESTROY = 0x0070
Global Const $WM_MEASUREITEM_CLIENTDATA = 0x0071
Global Const $WM_CONTEXTMENU = 0x007B
Global Const $WM_STYLECHANGING = 0x007C
Global Const $WM_STYLECHANGED = 0x007D
Global Const $WM_DISPLAYCHANGE = 0x007E
Global Const $WM_GETICON = 0x007F
Global Const $WM_SETICON = 0x0080
Global Const $WM_NCCREATE = 0x0081
Global Const $WM_NCDESTROY = 0x0082
Global Const $WM_NCCALCSIZE = 0x0083
Global Const $WM_NCHITTEST = 0x0084
Global Const $WM_NCPAINT = 0x0085
Global Const $WM_NCACTIVATE = 0x0086
Global Const $WM_GETDLGCODE = 0x0087
Global Const $WM_SYNCPAINT = 0x0088
Global Const $WM_SYNCTASK = 0x0089
Global Const $WM_KLUDGEMINRECT = 0x008B
Global Const $WM_LPKDRAWSWITCHWND = 0x008C
Global Const $WM_UAHDESTROYWINDOW = 0x0090
Global Const $WM_UAHDRAWMENU = 0x0091
Global Const $WM_UAHDRAWMENUITEM = 0x0092
Global Const $WM_UAHINITMENU = 0x0093
Global Const $WM_UAHMEASUREMENUITEM = 0x0094
Global Const $WM_UAHNCPAINTMENUPOPUP = 0x0095
Global Const $WM_NCMOUSEMOVE = 0x00A0
Global Const $WM_NCLBUTTONDOWN = 0x00A1
Global Const $WM_NCLBUTTONUP = 0x00A2
Global Const $WM_NCLBUTTONDBLCLK = 0x00A3
Global Const $WM_NCRBUTTONDOWN = 0x00A4
Global Const $WM_NCRBUTTONUP = 0x00A5
Global Const $WM_NCRBUTTONDBLCLK = 0x00A6
Global Const $WM_NCMBUTTONDOWN = 0x00A7
Global Const $WM_NCMBUTTONUP = 0x00A8
Global Const $WM_NCMBUTTONDBLCLK = 0x00A9
Global Const $WM_NCXBUTTONDOWN = 0x00AB
Global Const $WM_NCXBUTTONUP = 0x00AC
Global Const $WM_NCXBUTTONDBLCLK = 0x00AD
Global Const $WM_NCUAHDRAWCAPTION = 0x00AE
Global Const $WM_NCUAHDRAWFRAME = 0x00AF
Global Const $WM_INPUT_DEVICE_CHANGE = 0x00FE
Global Const $WM_INPUT = 0x00FF
Global Const $WM_KEYDOWN = 0x0100
Global Const $WM_KEYFIRST = 0x0100
Global Const $WM_KEYUP = 0x0101
Global Const $WM_CHAR = 0x0102
Global Const $WM_DEADCHAR = 0x0103
Global Const $WM_SYSKEYDOWN = 0x0104
Global Const $WM_SYSKEYUP = 0x0105
Global Const $WM_SYSCHAR = 0x0106
Global Const $WM_SYSDEADCHAR = 0x0107
Global Const $WM_YOMICHAR = 0x0108
Global Const $WM_KEYLAST = 0x0109
Global Const $WM_UNICHAR = 0x0109
Global Const $WM_CONVERTREQUEST = 0x010A
Global Const $WM_CONVERTRESULT = 0x010B
Global Const $WM_IM_INFO = 0x010C
Global Const $WM_IME_STARTCOMPOSITION = 0x010D
Global Const $WM_IME_ENDCOMPOSITION = 0x010E
Global Const $WM_IME_COMPOSITION = 0x010F
Global Const $WM_IME_KEYLAST = 0x010F
Global Const $WM_INITDIALOG = 0x0110
Global Const $WM_COMMAND = 0x0111
Global Const $WM_SYSCOMMAND = 0x0112
Global Const $WM_TIMER = 0x0113
Global Const $WM_HSCROLL = 0x0114
Global Const $WM_VSCROLL = 0x0115
Global Const $WM_INITMENU = 0x0116
Global Const $WM_INITMENUPOPUP = 0x0117
Global Const $WM_SYSTIMER = 0x0118
Global Const $WM_GESTURE = 0x0119
Global Const $WM_GESTURENOTIFY = 0x011A
Global Const $WM_GESTUREINPUT = 0x011B
Global Const $WM_GESTURENOTIFIED = 0x011C
Global Const $WM_MENUSELECT = 0x011F
Global Const $WM_MENUCHAR = 0x0120
Global Const $WM_ENTERIDLE = 0x0121
Global Const $WM_MENURBUTTONUP = 0x0122
Global Const $WM_MENUDRAG = 0x0123
Global Const $WM_MENUGETOBJECT = 0x0124
Global Const $WM_UNINITMENUPOPUP = 0x0125
Global Const $WM_MENUCOMMAND = 0x0126
Global Const $WM_CHANGEUISTATE = 0x0127
Global Const $WM_UPDATEUISTATE = 0x0128
Global Const $WM_QUERYUISTATE = 0x0129
Global Const $WM_LBTRACKPOINT = 0x0131
Global Const $WM_CTLCOLORMSGBOX = 0x0132
Global Const $WM_CTLCOLOREDIT = 0x0133
Global Const $WM_CTLCOLORLISTBOX = 0x0134
Global Const $WM_CTLCOLORBTN = 0x0135
Global Const $WM_CTLCOLORDLG = 0x0136
Global Const $WM_CTLCOLORSCROLLBAR = 0x0137
Global Const $WM_CTLCOLORSTATIC = 0x0138
Global Const $MN_GETHMENU = 0x01E1
Global Const $WM_PARENTNOTIFY = 0x0210
Global Const $WM_ENTERMENULOOP = 0x0211
Global Const $WM_EXITMENULOOP = 0x0212
Global Const $WM_NEXTMENU = 0x0213
Global Const $WM_SIZING = 0x0214
Global Const $WM_CAPTURECHANGED = 0x0215
Global Const $WM_MOVING = 0x0216
Global Const $WM_POWERBROADCAST = 0x0218
Global Const $WM_DEVICECHANGE = 0x0219
Global Const $WM_MDICREATE = 0x0220
Global Const $WM_MDIDESTROY = 0x0221
Global Const $WM_MDIACTIVATE = 0x0222
Global Const $WM_MDIRESTORE = 0x0223
Global Const $WM_MDINEXT = 0x0224
Global Const $WM_MDIMAXIMIZE = 0x0225
Global Const $WM_MDITILE = 0x0226
Global Const $WM_MDICASCADE = 0x0227
Global Const $WM_MDIICONARRANGE = 0x0228
Global Const $WM_MDIGETACTIVE = 0x0229
Global Const $WM_DROPOBJECT = 0x022A
Global Const $WM_QUERYDROPOBJECT = 0x022B
Global Const $WM_BEGINDRAG = 0x022C
Global Const $WM_DRAGLOOP = 0x022D
Global Const $WM_DRAGSELECT = 0x022E
Global Const $WM_DRAGMOVE = 0x022F
Global Const $WM_MDISETMENU = 0x0230
Global Const $WM_ENTERSIZEMOVE = 0x0231
Global Const $WM_EXITSIZEMOVE = 0x0232
Global Const $WM_DROPFILES = 0x0233
Global Const $WM_MDIREFRESHMENU = 0x0234
Global Const $WM_TOUCH = 0x0240
Global Const $WM_IME_SETCONTEXT = 0x0281
Global Const $WM_IME_NOTIFY = 0x0282
Global Const $WM_IME_CONTROL = 0x0283
Global Const $WM_IME_COMPOSITIONFULL = 0x0284
Global Const $WM_IME_SELECT = 0x0285
Global Const $WM_IME_CHAR = 0x0286
Global Const $WM_IME_SYSTEM = 0x0287
Global Const $WM_IME_REQUEST = 0x0288
Global Const $WM_IME_KEYDOWN = 0x0290
Global Const $WM_IME_KEYUP = 0x0291
Global Const $WM_NCMOUSEHOVER = 0x02A0
Global Const $WM_MOUSEHOVER = 0x02A1
Global Const $WM_NCMOUSELEAVE = 0x02A2
Global Const $WM_MOUSELEAVE = 0x02A3
Global Const $WM_WTSSESSION_CHANGE = 0x02B1
Global Const $WM_TABLET_FIRST = 0x02C0
Global Const $WM_TABLET_LAST = 0x02DF
Global Const $WM_CUT = 0x0300
Global Const $WM_COPY = 0x0301
Global Const $WM_PASTE = 0x0302
Global Const $WM_CLEAR = 0x0303
Global Const $WM_UNDO = 0x0304
Global Const $WM_PALETTEISCHANGING = 0x0310
Global Const $WM_HOTKEY = 0x0312
Global Const $WM_PALETTECHANGED = 0x0311
Global Const $WM_SYSMENU = 0x0313
Global Const $WM_HOOKMSG = 0x0314
Global Const $WM_EXITPROCESS = 0x0315
Global Const $WM_WAKETHREAD = 0x0316
Global Const $WM_PRINT = 0x0317
Global Const $WM_PRINTCLIENT = 0x0318
Global Const $WM_APPCOMMAND = 0x0319
Global Const $WM_QUERYNEWPALETTE = 0x030F
Global Const $WM_THEMECHANGED = 0x031A
Global Const $WM_UAHINIT = 0x031B
Global Const $WM_DESKTOPNOTIFY = 0x031C
Global Const $WM_CLIPBOARDUPDATE = 0x031D
Global Const $WM_DWMCOMPOSITIONCHANGED = 0x031E
Global Const $WM_DWMNCRENDERINGCHANGED = 0x031F
Global Const $WM_DWMCOLORIZATIONCOLORCHANGED = 0x0320
Global Const $WM_DWMWINDOWMAXIMIZEDCHANGE = 0x0321
Global Const $WM_DWMEXILEFRAME = 0x0322
Global Const $WM_DWMSENDICONICTHUMBNAIL = 0x0323
Global Const $WM_MAGNIFICATION_STARTED = 0x0324
Global Const $WM_MAGNIFICATION_ENDED = 0x0325
Global Const $WM_DWMSENDICONICLIVEPREVIEWBITMAP = 0x0326
Global Const $WM_DWMTHUMBNAILSIZECHANGED = 0x0327
Global Const $WM_MAGNIFICATION_OUTPUT = 0x0328
Global Const $WM_MEASURECONTROL = 0x0330
Global Const $WM_GETACTIONTEXT = 0x0331
Global Const $WM_FORWARDKEYDOWN = 0x0333
Global Const $WM_FORWARDKEYUP = 0x0334
Global Const $WM_GETTITLEBARINFOEX = 0x033F
Global Const $WM_NOTIFYWOW = 0x0340
Global Const $WM_HANDHELDFIRST = 0x0358
Global Const $WM_HANDHELDLAST = 0x035F
Global Const $WM_AFXFIRST = 0x0360
Global Const $WM_AFXLAST = 0x037F
Global Const $WM_PENWINFIRST = 0x0380
Global Const $WM_PENWINLAST = 0x038F
Global Const $WM_DDE_INITIATE = 0x03E0
Global Const $WM_DDE_TERMINATE = 0x03E1
Global Const $WM_DDE_ADVISE = 0x03E2
Global Const $WM_DDE_UNADVISE = 0x03E3
Global Const $WM_DDE_ACK = 0x03E4
Global Const $WM_DDE_DATA = 0x03E5
Global Const $WM_DDE_REQUEST = 0x03E6
Global Const $WM_DDE_POKE = 0x03E7
Global Const $WM_DDE_EXECUTE = 0x03E8
Global Const $WM_DBNOTIFICATION = 0x03FD
Global Const $WM_NETCONNECT = 0x03FE
Global Const $WM_HIBERNATE = 0x03FF
Global Const $WM_USER = 0x0400
Global Const $WM_APP = 0x8000
Global Const $NM_FIRST = 0
Global Const $NM_OUTOFMEMORY = $NM_FIRST - 1
Global Const $NM_CLICK = $NM_FIRST - 2
Global Const $NM_DBLCLK = $NM_FIRST - 3
Global Const $NM_RETURN = $NM_FIRST - 4
Global Const $NM_RCLICK = $NM_FIRST - 5
Global Const $NM_RDBLCLK = $NM_FIRST - 6
Global Const $NM_SETFOCUS = $NM_FIRST - 7
Global Const $NM_KILLFOCUS = $NM_FIRST - 8
Global Const $NM_CUSTOMDRAW = $NM_FIRST - 12
Global Const $NM_HOVER = $NM_FIRST - 13
Global Const $NM_NCHITTEST = $NM_FIRST - 14
Global Const $NM_KEYDOWN = $NM_FIRST - 15
Global Const $NM_RELEASEDCAPTURE = $NM_FIRST - 16
Global Const $NM_SETCURSOR = $NM_FIRST - 17
Global Const $NM_CHAR = $NM_FIRST - 18
Global Const $NM_TOOLTIPSCREATED = $NM_FIRST - 19
Global Const $NM_LDOWN = $NM_FIRST - 20
Global Const $NM_RDOWN = $NM_FIRST - 21
Global Const $NM_THEMECHANGED = $NM_FIRST - 22
Global Const $WM_MOUSEFIRST = 0x0200
Global Const $WM_MOUSEMOVE = 0x0200
Global Const $WM_LBUTTONDOWN = 0x0201
Global Const $WM_LBUTTONUP = 0x0202
Global Const $WM_LBUTTONDBLCLK = 0x0203
Global Const $WM_RBUTTONDOWN = 0x0204
Global Const $WM_RBUTTONUP = 0x0205
Global Const $WM_RBUTTONDBLCLK = 0x0206
Global Const $WM_MBUTTONDOWN = 0x0207
Global Const $WM_MBUTTONUP = 0x0208
Global Const $WM_MBUTTONDBLCLK = 0x0209
Global Const $WM_MOUSEWHEEL = 0x020A
Global Const $WM_XBUTTONDOWN = 0x020B
Global Const $WM_XBUTTONUP = 0x020C
Global Const $WM_XBUTTONDBLCLK = 0x020D
Global Const $WM_MOUSEHWHEEL = 0x020E
Global Const $PS_SOLID = 0
Global Const $PS_DASH = 1
Global Const $PS_DOT = 2
Global Const $PS_DASHDOT = 3
Global Const $PS_DASHDOTDOT = 4
Global Const $PS_NULL = 5
Global Const $PS_INSIDEFRAME = 6
Global Const $PS_USERSTYLE = 7
Global Const $PS_ALTERNATE = 8
Global Const $PS_ENDCAP_ROUND = 0x00000000
Global Const $PS_ENDCAP_SQUARE = 0x00000100
Global Const $PS_ENDCAP_FLAT = 0x00000200
Global Const $PS_JOIN_BEVEL = 0x00001000
Global Const $PS_JOIN_MITER = 0x00002000
Global Const $PS_JOIN_ROUND = 0x00000000
Global Const $PS_GEOMETRIC = 0x00010000
Global Const $PS_COSMETIC = 0x00000000
Global Const $LWA_ALPHA = 0x2
Global Const $LWA_COLORKEY = 0x1
Global Const $RGN_AND = 1
Global Const $RGN_OR = 2
Global Const $RGN_XOR = 3
Global Const $RGN_DIFF = 4
Global Const $RGN_COPY = 5
Global Const $ERRORREGION = 0
Global Const $NULLREGION = 1
Global Const $SIMPLEREGION = 2
Global Const $COMPLEXREGION = 3
Global Const $TRANSPARENT = 1
Global Const $OPAQUE = 2
Global Const $CCM_FIRST = 0x2000
Global Const $CCM_GETUNICODEFORMAT = ($CCM_FIRST + 6)
Global Const $CCM_SETUNICODEFORMAT = ($CCM_FIRST + 5)
Global Const $CCM_SETBKCOLOR = $CCM_FIRST + 1
Global Const $CCM_SETCOLORSCHEME = $CCM_FIRST + 2
Global Const $CCM_GETCOLORSCHEME = $CCM_FIRST + 3
Global Const $CCM_GETDROPTARGET = $CCM_FIRST + 4
Global Const $CCM_SETWINDOWTHEME = $CCM_FIRST + 11
Global Const $GA_PARENT = 1
Global Const $GA_ROOT = 2
Global Const $GA_ROOTOWNER = 3
Global Const $SM_CXSCREEN = 0
Global Const $SM_CYSCREEN = 1
Global Const $SM_CXVSCROLL = 2
Global Const $SM_CYHSCROLL = 3
Global Const $SM_CYCAPTION = 4
Global Const $SM_CXBORDER = 5
Global Const $SM_CYBORDER = 6
Global Const $SM_CXDLGFRAME = 7
Global Const $SM_CYDLGFRAME = 8
Global Const $SM_CYVTHUMB = 9
Global Const $SM_CXHTHUMB = 10
Global Const $SM_CXICON = 11
Global Const $SM_CYICON = 12
Global Const $SM_CXCURSOR = 13
Global Const $SM_CYCURSOR = 14
Global Const $SM_CYMENU = 15
Global Const $SM_CXFULLSCREEN = 16
Global Const $SM_CYFULLSCREEN = 17
Global Const $SM_CYKANJIWINDOW = 18
Global Const $SM_MOUSEPRESENT = 19
Global Const $SM_CYVSCROLL = 20
Global Const $SM_CXHSCROLL = 21
Global Const $SM_DEBUG = 22
Global Const $SM_SWAPBUTTON = 23
Global Const $SM_RESERVED1 = 24
Global Const $SM_RESERVED2 = 25
Global Const $SM_RESERVED3 = 26
Global Const $SM_RESERVED4 = 27
Global Const $SM_CXMIN = 28
Global Const $SM_CYMIN = 29
Global Const $SM_CXSIZE = 30
Global Const $SM_CYSIZE = 31
Global Const $SM_CXFRAME = 32
Global Const $SM_CYFRAME = 33
Global Const $SM_CXMINTRACK = 34
Global Const $SM_CYMINTRACK = 35
Global Const $SM_CXDOUBLECLK = 36
Global Const $SM_CYDOUBLECLK = 37
Global Const $SM_CXICONSPACING = 38
Global Const $SM_CYICONSPACING = 39
Global Const $SM_MENUDROPALIGNMENT = 40
Global Const $SM_PENWINDOWS = 41
Global Const $SM_DBCSENABLED = 42
Global Const $SM_CMOUSEBUTTONS = 43
Global Const $SM_SECURE = 44
Global Const $SM_CXEDGE = 45
Global Const $SM_CYEDGE = 46
Global Const $SM_CXMINSPACING = 47
Global Const $SM_CYMINSPACING = 48
Global Const $SM_CXSMICON = 49
Global Const $SM_CYSMICON = 50
Global Const $SM_CYSMCAPTION = 51
Global Const $SM_CXSMSIZE = 52
Global Const $SM_CYSMSIZE = 53
Global Const $SM_CXMENUSIZE = 54
Global Const $SM_CYMENUSIZE = 55
Global Const $SM_ARRANGE = 56
Global Const $SM_CXMINIMIZED = 57
Global Const $SM_CYMINIMIZED = 58
Global Const $SM_CXMAXTRACK = 59
Global Const $SM_CYMAXTRACK = 60
Global Const $SM_CXMAXIMIZED = 61
Global Const $SM_CYMAXIMIZED = 62
Global Const $SM_NETWORK = 63
Global Const $SM_CLEANBOOT = 67
Global Const $SM_CXDRAG = 68
Global Const $SM_CYDRAG = 69
Global Const $SM_SHOWSOUNDS = 70
Global Const $SM_CXMENUCHECK = 71
Global Const $SM_CYMENUCHECK = 72
Global Const $SM_SLOWMACHINE = 73
Global Const $SM_MIDEASTENABLED = 74
Global Const $SM_MOUSEWHEELPRESENT = 75
Global Const $SM_XVIRTUALSCREEN = 76
Global Const $SM_YVIRTUALSCREEN = 77
Global Const $SM_CXVIRTUALSCREEN = 78
Global Const $SM_CYVIRTUALSCREEN = 79
Global Const $SM_CMONITORS = 80
Global Const $SM_SAMEDISPLAYFORMAT = 81
Global Const $SM_IMMENABLED = 82
Global Const $SM_CXFOCUSBORDER = 83
Global Const $SM_CYFOCUSBORDER = 84
Global Const $SM_TABLETPC = 86
Global Const $SM_MEDIACENTER = 87
Global Const $SM_STARTER = 88
Global Const $SM_SERVERR2 = 89
Global Const $SM_CMETRICS = 90
Global Const $SM_REMOTESESSION = 0x1000
Global Const $SM_SHUTTINGDOWN = 0x2000
Global Const $SM_REMOTECONTROL = 0x2001
Global Const $SM_CARETBLINKINGENABLED = 0x2002
Global Const $BLACKNESS = 0x00000042
Global Const $CAPTUREBLT = 0X40000000
Global Const $DSTINVERT = 0x00550009
Global Const $MERGECOPY = 0x00C000CA
Global Const $MERGEPAINT = 0x00BB0226
Global Const $NOMIRRORBITMAP = 0X80000000
Global Const $NOTSRCCOPY = 0x00330008
Global Const $NOTSRCERASE = 0x001100A6
Global Const $PATCOPY = 0x00F00021
Global Const $PATINVERT = 0x005A0049
Global Const $PATPAINT = 0x00FB0A09
Global Const $SRCAND = 0x008800C6
Global Const $SRCCOPY = 0x00CC0020
Global Const $SRCERASE = 0x00440328
Global Const $SRCINVERT = 0x00660046
Global Const $SRCPAINT = 0x00EE0086
Global Const $WHITENESS = 0x00FF0062
Global Const $DT_BOTTOM = 0x8
Global Const $DT_CALCRECT = 0x400
Global Const $DT_CENTER = 0x1
Global Const $DT_EDITCONTROL = 0x2000
Global Const $DT_END_ELLIPSIS = 0x8000
Global Const $DT_EXPANDTABS = 0x40
Global Const $DT_EXTERNALLEADING = 0x200
Global Const $DT_HIDEPREFIX = 0x100000
Global Const $DT_INTERNAL = 0x1000
Global Const $DT_LEFT = 0x0
Global Const $DT_MODIFYSTRING = 0x10000
Global Const $DT_NOCLIP = 0x100
Global Const $DT_NOFULLWIDTHCHARBREAK = 0x80000
Global Const $DT_NOPREFIX = 0x800
Global Const $DT_PATH_ELLIPSIS = 0x4000
Global Const $DT_PREFIXONLY = 0x200000
Global Const $DT_RIGHT = 0x2
Global Const $DT_RTLREADING = 0x20000
Global Const $DT_SINGLELINE = 0x20
Global Const $DT_TABSTOP = 0x80
Global Const $DT_TOP = 0x0
Global Const $DT_VCENTER = 0x4
Global Const $DT_WORDBREAK = 0x10
Global Const $DT_WORD_ELLIPSIS = 0x40000
Global Const $RDW_ERASE = 0x0004
Global Const $RDW_FRAME = 0x0400
Global Const $RDW_INTERNALPAINT = 0x0002
Global Const $RDW_INVALIDATE = 0x0001
Global Const $RDW_NOERASE = 0x0020
Global Const $RDW_NOFRAME = 0x0800
Global Const $RDW_NOINTERNALPAINT = 0x0010
Global Const $RDW_VALIDATE = 0x0008
Global Const $RDW_ERASENOW = 0x0200
Global Const $RDW_UPDATENOW = 0x0100
Global Const $RDW_ALLCHILDREN = 0x0080
Global Const $RDW_NOCHILDREN = 0x0040
Global Const $WM_RENDERFORMAT = 0x0305
Global Const $WM_RENDERALLFORMATS = 0x0306
Global Const $WM_DESTROYCLIPBOARD = 0x0307
Global Const $WM_DRAWCLIPBOARD = 0x0308
Global Const $WM_PAINTCLIPBOARD = 0x0309
Global Const $WM_VSCROLLCLIPBOARD = 0x030A
Global Const $WM_SIZECLIPBOARD = 0x030B
Global Const $WM_ASKCBFORMATNAME = 0x030C
Global Const $WM_CHANGECBCHAIN = 0x030D
Global Const $WM_HSCROLLCLIPBOARD = 0x030E
Global Const $HTERROR = -2
Global Const $HTTRANSPARENT = -1
Global Const $HTNOWHERE = 0
Global Const $HTCLIENT = 1
Global Const $HTCAPTION = 2
Global Const $HTSYSMENU = 3
Global Const $HTGROWBOX = 4
Global Const $HTSIZE = $HTGROWBOX
Global Const $HTMENU = 5
Global Const $HTHSCROLL = 6
Global Const $HTVSCROLL = 7
Global Const $HTMINBUTTON = 8
Global Const $HTMAXBUTTON = 9
Global Const $HTLEFT = 10
Global Const $HTRIGHT = 11
Global Const $HTTOP = 12
Global Const $HTTOPLEFT = 13
Global Const $HTTOPRIGHT = 14
Global Const $HTBOTTOM = 15
Global Const $HTBOTTOMLEFT = 16
Global Const $HTBOTTOMRIGHT = 17
Global Const $HTBORDER = 18
Global Const $HTREDUCE = $HTMINBUTTON
Global Const $HTZOOM = $HTMAXBUTTON
Global Const $HTSIZEFIRST = $HTLEFT
Global Const $HTSIZELAST = $HTBOTTOMRIGHT
Global Const $HTOBJECT = 19
Global Const $HTCLOSE = 20
Global Const $HTHELP = 21
Global Const $COLOR_SCROLLBAR = 0
Global Const $COLOR_BACKGROUND = 1
Global Const $COLOR_ACTIVECAPTION = 2
Global Const $COLOR_INACTIVECAPTION = 3
Global Const $COLOR_MENU = 4
Global Const $COLOR_WINDOW = 5
Global Const $COLOR_WINDOWFRAME = 6
Global Const $COLOR_MENUTEXT = 7
Global Const $COLOR_WINDOWTEXT = 8
Global Const $COLOR_CAPTIONTEXT = 9
Global Const $COLOR_ACTIVEBORDER = 10
Global Const $COLOR_INACTIVEBORDER = 11
Global Const $COLOR_APPWORKSPACE = 12
Global Const $COLOR_HIGHLIGHT = 13
Global Const $COLOR_HIGHLIGHTTEXT = 14
Global Const $COLOR_BTNFACE = 15
Global Const $COLOR_BTNSHADOW = 16
Global Const $COLOR_GRAYTEXT = 17
Global Const $COLOR_BTNTEXT = 18
Global Const $COLOR_INACTIVECAPTIONTEXT = 19
Global Const $COLOR_BTNHIGHLIGHT = 20
Global Const $COLOR_3DDKSHADOW = 21
Global Const $COLOR_3DLIGHT = 22
Global Const $COLOR_INFOTEXT = 23
Global Const $COLOR_INFOBK = 24
Global Const $COLOR_HOTLIGHT = 26
Global Const $COLOR_GRADIENTACTIVECAPTION = 27
Global Const $COLOR_GRADIENTINACTIVECAPTION = 28
Global Const $COLOR_MENUHILIGHT = 29
Global Const $COLOR_MENUBAR = 30
Global Const $COLOR_DESKTOP = 1
Global Const $COLOR_3DFACE = 15
Global Const $COLOR_3DSHADOW = 16
Global Const $COLOR_3DHIGHLIGHT = 20
Global Const $COLOR_3DHILIGHT = 20
Global Const $COLOR_BTNHILIGHT = 20
Global Const $HINST_COMMCTRL = -1
Global Const $IDB_STD_SMALL_COLOR = 0
Global Const $IDB_STD_LARGE_COLOR = 1
Global Const $IDB_VIEW_SMALL_COLOR = 4
Global Const $IDB_VIEW_LARGE_COLOR = 5
Global Const $IDB_HIST_SMALL_COLOR = 8
Global Const $IDB_HIST_LARGE_COLOR = 9
Global Const $STARTF_FORCEOFFFEEDBACK = 0x80
Global Const $STARTF_FORCEONFEEDBACK = 0x40
Global Const $STARTF_PREVENTPINNING = 0x00002000
Global Const $STARTF_RUNFULLSCREEN = 0x20
Global Const $STARTF_TITLEISAPPID = 0x00001000
Global Const $STARTF_TITLEISLINKNAME = 0x00000800
Global Const $STARTF_USECOUNTCHARS = 0x8
Global Const $STARTF_USEFILLATTRIBUTE = 0x10
Global Const $STARTF_USEHOTKEY = 0x200
Global Const $STARTF_USEPOSITION = 0x4
Global Const $STARTF_USESHOWWINDOW = 0x1
Global Const $STARTF_USESIZE = 0x2
Global Const $STARTF_USESTDHANDLES = 0x100
Global Const $CDDS_PREPAINT = 0x00000001
Global Const $CDDS_POSTPAINT = 0x00000002
Global Const $CDDS_PREERASE = 0x00000003
Global Const $CDDS_POSTERASE = 0x00000004
Global Const $CDDS_ITEM = 0x00010000
Global Const $CDDS_ITEMPREPAINT = 0x00010001
Global Const $CDDS_ITEMPOSTPAINT = 0x00010002
Global Const $CDDS_ITEMPREERASE = 0x00010003
Global Const $CDDS_ITEMPOSTERASE = 0x00010004
Global Const $CDDS_SUBITEM = 0x00020000
Global Const $CDIS_SELECTED = 0x0001
Global Const $CDIS_GRAYED = 0x0002
Global Const $CDIS_DISABLED = 0x0004
Global Const $CDIS_CHECKED = 0x0008
Global Const $CDIS_FOCUS = 0x0010
Global Const $CDIS_DEFAULT = 0x0020
Global Const $CDIS_HOT = 0x0040
Global Const $CDIS_MARKED = 0x0080
Global Const $CDIS_INDETERMINATE = 0x0100
Global Const $CDIS_SHOWKEYBOARDCUES = 0x0200
Global Const $CDIS_NEARHOT = 0x0400
Global Const $CDIS_OTHERSIDEHOT = 0x0800
Global Const $CDIS_DROPHILITED = 0x1000
Global Const $CDRF_DODEFAULT = 0x00000000
Global Const $CDRF_NEWFONT = 0x00000002
Global Const $CDRF_SKIPDEFAULT = 0x00000004
Global Const $CDRF_NOTIFYPOSTPAINT = 0x00000010
Global Const $CDRF_NOTIFYITEMDRAW = 0x00000020
Global Const $CDRF_NOTIFYSUBITEMDRAW = 0x00000020
Global Const $CDRF_NOTIFYPOSTERASE = 0x00000040
Global Const $CDRF_DOERASE = 0x00000008
Global Const $CDRF_SKIPPOSTPAINT = 0x00000100
Global Const $GUI_SS_DEFAULT_GUI = BitOR($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU)
Global Const $OPT_COORDSRELATIVE = 0
Global Const $OPT_COORDSABSOLUTE = 1
Global Const $OPT_COORDSCLIENT = 2
Global Const $OPT_ERRORSILENT = 0
Global Const $OPT_ERRORFATAL = 1
Global Const $OPT_CAPSNOSTORE = 0
Global Const $OPT_CAPSSTORE = 1
Global Const $OPT_MATCHSTART = 1
Global Const $OPT_MATCHANY = 2
Global Const $OPT_MATCHEXACT = 3
Global Const $OPT_MATCHADVANCED = 4
Global Const $CCS_TOP = 0x01
Global Const $CCS_NOMOVEY = 0x02
Global Const $CCS_BOTTOM = 0x03
Global Const $CCS_NORESIZE = 0x04
Global Const $CCS_NOPARENTALIGN = 0x08
Global Const $CCS_NOHILITE = 0x10
Global Const $CCS_ADJUSTABLE = 0x20
Global Const $CCS_NODIVIDER = 0x40
Global Const $CCS_VERT = 0x0080
Global Const $CCS_LEFT = 0x0081
Global Const $CCS_NOMOVEX = 0x0082
Global Const $CCS_RIGHT = 0x0083
Global Const $DT_DRIVETYPE = 1
Global Const $DT_SSDSTATUS = 2
Global Const $DT_BUSTYPE = 3
Global Const $PROXY_IE = 0
Global Const $PROXY_NONE = 1
Global Const $PROXY_SPECIFIED = 2
Global Const $OBJID_WINDOW = 0x00000000
Global Const $OBJID_TITLEBAR = 0xFFFFFFFE
Global Const $OBJID_SIZEGRIP = 0xFFFFFFF9
Global Const $OBJID_CARET = 0xFFFFFFF8
Global Const $OBJID_CURSOR = 0xFFFFFFF7
Global Const $OBJID_ALERT = 0xFFFFFFF6
Global Const $OBJID_SOUND = 0xFFFFFFF5
Global Const $DLG_CENTERONTOP = 0
Global Const $DLG_NOTITLE = 1
Global Const $DLG_NOTONTOP = 2
Global Const $DLG_TEXTLEFT = 4
Global Const $DLG_TEXTRIGHT = 8
Global Const $DLG_MOVEABLE = 16
Global Const $DLG_TEXTVCENTER = 32
Global Const $IDC_UNKNOWN = 0
Global Const $IDC_APPSTARTING = 1
Global Const $IDC_ARROW = 2
Global Const $IDC_CROSS = 3
Global Const $IDC_HAND = 32649
Global Const $IDC_HELP = 4
Global Const $IDC_IBEAM = 5
Global Const $IDC_ICON = 6
Global Const $IDC_NO = 7
Global Const $IDC_SIZE = 8
Global Const $IDC_SIZEALL = 9
Global Const $IDC_SIZENESW = 10
Global Const $IDC_SIZENS = 11
Global Const $IDC_SIZENWSE = 12
Global Const $IDC_SIZEWE = 13
Global Const $IDC_UPARROW = 14
Global Const $IDC_WAIT = 15
Global Const $IDI_APPLICATION = 32512
Global Const $IDI_ASTERISK = 32516
Global Const $IDI_EXCLAMATION = 32515
Global Const $IDI_HAND = 32513
Global Const $IDI_QUESTION = 32514
Global Const $IDI_WINLOGO = 32517
Global Const $IDI_SHIELD = 32518
Global Const $IDI_ERROR = $IDI_HAND
Global Const $IDI_INFORMATION = $IDI_ASTERISK
Global Const $IDI_WARNING = $IDI_EXCLAMATION
Global Const $SD_LOGOFF = 0
Global Const $SD_SHUTDOWN = 1
Global Const $SD_REBOOT = 2
Global Const $SD_FORCE = 4
Global Const $SD_POWERDOWN = 8
Global Const $SD_FORCEHUNG = 16
Global Const $SD_STANDBY = 32
Global Const $SD_HIBERNATE = 64
Global Const $STDIN_CHILD = 1
Global Const $STDOUT_CHILD = 2
Global Const $STDERR_CHILD = 4
Global Const $STDERR_MERGED = 8
Global Const $STDIO_INHERIT_PARENT = 0x10
Global Const $RUN_CREATE_NEW_CONSOLE = 0x00010000
Global Const $UBOUND_DIMENSIONS = 0
Global Const $UBOUND_ROWS = 1
Global Const $UBOUND_COLUMNS = 2
Global Const $MOUSEEVENTF_ABSOLUTE = 0x8000
Global Const $MOUSEEVENTF_MOVE = 0x0001
Global Const $MOUSEEVENTF_LEFTDOWN = 0x0002
Global Const $MOUSEEVENTF_LEFTUP = 0x0004
Global Const $MOUSEEVENTF_RIGHTDOWN = 0x0008
Global Const $MOUSEEVENTF_RIGHTUP = 0x0010
Global Const $MOUSEEVENTF_MIDDLEDOWN = 0x0020
Global Const $MOUSEEVENTF_MIDDLEUP = 0x0040
Global Const $MOUSEEVENTF_WHEEL = 0x0800
Global Const $MOUSEEVENTF_XDOWN = 0x0080
Global Const $MOUSEEVENTF_XUP = 0x0100
Global Const $REG_NONE = 0
Global Const $REG_SZ = 1
Global Const $REG_EXPAND_SZ = 2
Global Const $REG_BINARY = 3
Global Const $REG_DWORD = 4
Global Const $REG_DWORD_LITTLE_ENDIAN = 4
Global Const $REG_DWORD_BIG_ENDIAN = 5
Global Const $REG_LINK = 6
Global Const $REG_MULTI_SZ = 7
Global Const $REG_RESOURCE_LIST = 8
Global Const $REG_FULL_RESOURCE_DESCRIPTOR = 9
Global Const $REG_RESOURCE_REQUIREMENTS_LIST = 10
Global Const $REG_QWORD = 11
Global Const $REG_QWORD_LITTLE_ENDIAN = 11
Global Const $HWND_BOTTOM = 1
Global Const $HWND_NOTOPMOST = -2
Global Const $HWND_TOP = 0
Global Const $HWND_TOPMOST = -1
Global Const $SWP_NOSIZE = 0x0001
Global Const $SWP_NOMOVE = 0x0002
Global Const $SWP_NOZORDER = 0x0004
Global Const $SWP_NOREDRAW = 0x0008
Global Const $SWP_NOACTIVATE = 0x0010
Global Const $SWP_FRAMECHANGED = 0x0020
Global Const $SWP_DRAWFRAME = 0x0020
Global Const $SWP_SHOWWINDOW = 0x0040
Global Const $SWP_HIDEWINDOW = 0x0080
Global Const $SWP_NOCOPYBITS = 0x0100
Global Const $SWP_NOOWNERZORDER = 0x0200
Global Const $SWP_NOREPOSITION = 0x0200
Global Const $SWP_NOSENDCHANGING = 0x0400
Global Const $SWP_DEFERERASE = 0x2000
Global Const $SWP_ASYNCWINDOWPOS = 0x4000
Global Const $KEYWORD_DEFAULT = 1
Global Const $KEYWORD_NULL = 2
Global Const $DECLARED_LOCAL = -1
Global Const $DECLARED_UNKNOWN = 0
Global Const $DECLARED_GLOBAL = 1
Global Const $ASSIGN_CREATE = 0
Global Const $ASSIGN_FORCELOCAL = 1
Global Const $ASSIGN_FORCEGLOBAL = 2
Global Const $ASSIGN_EXISTFAIL = 4
Global Const $BI_ENABLE = 0
Global Const $BI_DISABLE = 1
Global Const $BREAK_ENABLE = 1
Global Const $BREAK_DISABLE = 0
Global Const $CDTRAY_OPEN = "open"
Global Const $CDTRAY_CLOSED = "closed"
Global Const $SEND_DEFAULT = 0
Global Const $SEND_RAW = 1
Global Const $DIR_DEFAULT = 0
Global Const $DIR_EXTENDED= 1
Global Const $DIR_NORECURSE = 2
Global Const $DIR_REMOVE= 1
Global Const $DT_ALL = "ALL"
Global Const $DT_CDROM = "CDROM"
Global Const $DT_REMOVABLE = "REMOVABLE"
Global Const $DT_FIXED = "FIXED"
Global Const $DT_NETWORK = "NETWORK"
Global Const $DT_RAMDISK = "RAMDISK"
Global Const $DT_UNKNOWN = "UNKNOWN"
Global Const $DT_UNDEFINED = 1
Global Const $DT_FAT = "FAT"
Global Const $DT_FAT32 = "FAT32"
Global Const $DT_EXFAT = "exFAT"
Global Const $DT_NTFS = "NTFS"
Global Const $DT_NWFS = "NWFS"
Global Const $DT_CDFS = "CDFS"
Global Const $DT_UDF = "UDF"
Global Const $DMA_DEFAULT = 0
Global Const $DMA_PERSISTENT = 1
Global Const $DMA_AUTHENTICATION = 8
Global Const $DS_UNKNOWN = "UNKNOWN"
Global Const $DS_READY = "READY"
Global Const $DS_NOTREADY = "NOTREADY"
Global Const $DS_INVALID = "INVALID"
Global Const $MOUSE_CLICK_LEFT = "left"
Global Const $MOUSE_CLICK_RIGHT = "right"
Global Const $MOUSE_CLICK_MIDDLE = "middle"
Global Const $MOUSE_CLICK_MAIN = "main"
Global Const $MOUSE_CLICK_MENU = "menu"
Global Const $MOUSE_CLICK_PRIMARY = "primary"
Global Const $MOUSE_CLICK_SECONDARY = "secondary"
Global Const $MOUSE_WHEEL_UP = "up"
Global Const $MOUSE_WHEEL_DOWN = "down"
Global Const $NUMBER_AUTO = 0
Global Const $NUMBER_32BIT = 1
Global Const $NUMBER_64BIT = 2
Global Const $NUMBER_DOUBLE = 3
Global Const $OBJ_NAME = 1
Global Const $OBJ_STRING = 2
Global Const $OBJ_PROGID = 3
Global Const $OBJ_FILE = 4
Global Const $OBJ_MODULE = 5
Global Const $OBJ_CLSID = 6
Global Const $OBJ_IID = 7
Global Const $EXITCLOSE_NORMAL = 0
Global Const $EXITCLOSE_BYEXIT = 1
Global Const $EXITCLOSE_BYCLICK = 2
Global Const $EXITCLOSE_BYLOGOFF = 3
Global Const $EXITCLOSE_BYSUTDOWN = 4
Global Const $PROCESS_STATS_MEMORY = 0
Global Const $PROCESS_STATS_IO = 1
Global Const $PROCESS_LOW = 0
Global Const $PROCESS_BELOWNORMAL = 1
Global Const $PROCESS_NORMAL = 2
Global Const $PROCESS_ABOVENORMAL = 3
Global Const $PROCESS_HIGH = 4
Global Const $PROCESS_REALTIME = 5
Global Const $RUN_LOGON_NOPROFILE = 0
Global Const $RUN_LOGON_PROFILE = 1
Global Const $RUN_LOGON_NETWORK = 2
Global Const $RUN_LOGON_INHERIT = 4
Global Const $SOUND_NOWAIT = 0
Global Const $SOUND_WAIT = 1
Global Const $SHEX_OPEN = "open"
Global Const $SHEX_EDIT = "edit"
Global Const $SHEX_PRINT = "print"
Global Const $SHEX_PROPERTIES = "properties"
Global Const $TCP_DATA_DEFAULT = 0
Global Const $TCP_DATA_BINARY = 1
Global Const $UDP_OPEN_DEFAULT = 0
Global Const $UDP_OPEN_BROADCAST = 1
Global Const $UDP_DATA_DEFAULT = 0
Global Const $UDP_DATA_BINARY = 1
Global Const $UDP_DATA_ARRAY = 2
Global Const $TIP_NOICON = 0
Global Const $TIP_INFOICON = 1
Global Const $TIP_WARNINGICON = 2
Global Const $TIP_ERRORICON = 3
Global Const $TIP_BALLOON = 1
Global Const $TIP_CENTER = 2
Global Const $TIP_FORCEVISIBLE = 4
Global Const $WINDOWS_NOONTOP = 0
Global Const $WINDOWS_ONTOP = 1
Global Const $FC_NOOVERWRITE = 0
Global Const $FC_OVERWRITE = 1
Global Const $FC_CREATEPATH = 8
Global Const $FT_MODIFIED = 0
Global Const $FT_CREATED = 1
Global Const $FT_ACCESSED = 2
Global Const $FT_ARRAY = 0
Global Const $FT_STRING = 1
Global Const $FSF_CREATEBUTTON = 1
Global Const $FSF_NEWDIALOG = 2
Global Const $FSF_EDITCONTROL = 4
Global Const $FT_NONRECURSIVE = 0
Global Const $FT_RECURSIVE = 1
Global Const $FO_READ = 0
Global Const $FO_APPEND = 1
Global Const $FO_OVERWRITE = 2
Global Const $FO_CREATEPATH = 8
Global Const $FO_BINARY = 16
Global Const $FO_UNICODE = 32
Global Const $FO_UTF16_LE = 32
Global Const $FO_UTF16_BE = 64
Global Const $FO_UTF8 = 128
Global Const $FO_UTF8_NOBOM = 256
Global Const $FO_ANSI = 512
Global Const $FO_UTF16_LE_NOBOM = 1024
Global Const $FO_UTF16_BE_NOBOM = 2048
Global Const $FO_UTF8_FULL = 16384
Global Const $FO_FULLFILE_DETECT = 16384
Global Const $EOF = -1
Global Const $FD_FILEMUSTEXIST = 1
Global Const $FD_PATHMUSTEXIST = 2
Global Const $FD_MULTISELECT = 4
Global Const $FD_PROMPTCREATENEW = 8
Global Const $FD_PROMPTOVERWRITE = 16
Global Const $CREATE_NEW = 1
Global Const $CREATE_ALWAYS = 2
Global Const $OPEN_EXISTING = 3
Global Const $OPEN_ALWAYS = 4
Global Const $TRUNCATE_EXISTING = 5
Global Const $INVALID_SET_FILE_POINTER = -1
Global Const $FILE_BEGIN = 0
Global Const $FILE_CURRENT = 1
Global Const $FILE_END = 2
Global Const $FILE_ATTRIBUTE_READONLY = 0x00000001
Global Const $FILE_ATTRIBUTE_HIDDEN = 0x00000002
Global Const $FILE_ATTRIBUTE_SYSTEM = 0x00000004
Global Const $FILE_ATTRIBUTE_DIRECTORY = 0x00000010
Global Const $FILE_ATTRIBUTE_ARCHIVE = 0x00000020
Global Const $FILE_ATTRIBUTE_DEVICE = 0x00000040
Global Const $FILE_ATTRIBUTE_NORMAL = 0x00000080
Global Const $FILE_ATTRIBUTE_TEMPORARY = 0x00000100
Global Const $FILE_ATTRIBUTE_SPARSE_FILE = 0x00000200
Global Const $FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400
Global Const $FILE_ATTRIBUTE_COMPRESSED = 0x00000800
Global Const $FILE_ATTRIBUTE_OFFLINE = 0x00001000
Global Const $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000
Global Const $FILE_ATTRIBUTE_ENCRYPTED = 0x00004000
Global Const $FILE_SHARE_READ = 0x00000001
Global Const $FILE_SHARE_WRITE = 0x00000002
Global Const $FILE_SHARE_DELETE = 0x00000004
Global Const $FILE_SHARE_READWRITE = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE)
Global Const $FILE_SHARE_ANY = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE, $FILE_SHARE_DELETE)
Global Const $GENERIC_ALL = 0x10000000
Global Const $GENERIC_EXECUTE = 0x20000000
Global Const $GENERIC_WRITE = 0x40000000
Global Const $GENERIC_READ = 0x80000000
Global Const $GENERIC_READWRITE = BitOR($GENERIC_READ, $GENERIC_WRITE)
Global Const $FILE_ENCODING_UTF16LE = 32
Global Const $FE_ENTIRE_UTF8 = 1
Global Const $FE_PARTIALFIRST_UTF8 = 2
Global Const $FN_FULLPATH = 0
Global Const $FN_RELATIVEPATH = 1
Global Const $FV_COMMENTS = "Comments"
Global Const $FV_COMPANYNAME = "CompanyName"
Global Const $FV_FILEDESCRIPTION = "FileDescription"
Global Const $FV_FILEVERSION = "FileVersion"
Global Const $FV_INTERNALNAME = "InternalName"
Global Const $FV_LEGALCOPYRIGHT = "LegalCopyright"
Global Const $FV_LEGALTRADEMARKS = "LegalTrademarks"
Global Const $FV_ORIGINALFILENAME = "OriginalFilename"
Global Const $FV_PRODUCTNAME = "ProductName"
Global Const $FV_PRODUCTVERSION = "ProductVersion"
Global Const $FV_PRIVATEBUILD = "PrivateBuild"
Global Const $FV_SPECIALBUILD = "SpecialBuild"
Global Const $FRTA_NOCOUNT = 0
Global Const $FRTA_COUNT = 1
Global Const $FRTA_INTARRAYS = 2
Global Const $FRTA_ENTIRESPLIT = 4
Global Const $FLTA_FILESFOLDERS = 0
Global Const $FLTA_FILES = 1
Global Const $FLTA_FOLDERS = 2
Global Const $FLTAR_FILESFOLDERS = 0
Global Const $FLTAR_FILES = 1
Global Const $FLTAR_FOLDERS = 2
Global Const $FLTAR_NOHIDDEN = 4
Global Const $FLTAR_NOSYSTEM = 8
Global Const $FLTAR_NOLINK = 16
Global Const $FLTAR_NORECUR = 0
Global Const $FLTAR_RECUR = 1
Global Const $FLTAR_NOSORT = 0
Global Const $FLTAR_SORT = 1
Global Const $FLTAR_FASTSORT = 2
Global Const $FLTAR_NOPATH = 0
Global Const $FLTAR_RELPATH = 1
Global Const $FLTAR_FULLPATH = 2
Global Const $MB_OK = 0
Global Const $MB_OKCANCEL = 1
Global Const $MB_ABORTRETRYIGNORE = 2
Global Const $MB_YESNOCANCEL = 3
Global Const $MB_YESNO = 4
Global Const $MB_RETRYCANCEL = 5
Global Const $MB_CANCELTRYCONTINUE = 6
Global Const $MB_HELP = 0x4000
Global Const $MB_ICONSTOP = 16
Global Const $MB_ICONERROR = 16
Global Const $MB_ICONHAND = 16
Global Const $MB_ICONQUESTION = 32
Global Const $MB_ICONEXCLAMATION = 48
Global Const $MB_ICONWARNING = 48
Global Const $MB_ICONINFORMATION = 64
Global Const $MB_ICONASTERISK = 64
Global Const $MB_USERICON = 0x00000080
Global Const $MB_DEFBUTTON1 = 0
Global Const $MB_DEFBUTTON2 = 256
Global Const $MB_DEFBUTTON3 = 512
Global Const $MB_DEFBUTTON4 = 768
Global Const $MB_APPLMODAL = 0
Global Const $MB_SYSTEMMODAL = 4096
Global Const $MB_TASKMODAL = 8192
Global Const $MB_DEFAULT_DESKTOP_ONLY = 0x00020000
Global Const $MB_RIGHT = 0x00080000
Global Const $MB_RTLREADING = 0x00100000
Global Const $MB_SETFOREGROUND = 0x00010000
Global Const $MB_TOPMOST = 0x00040000
Global Const $MB_SERVICE_NOTIFICATION = 0x00200000
Global Const $MB_RIGHTJUSTIFIED = $MB_RIGHT
Global Const $IDTIMEOUT = -1
Global Const $IDOK = 1
Global Const $IDCANCEL = 2
Global Const $IDABORT = 3
Global Const $IDRETRY = 4
Global Const $IDIGNORE = 5
Global Const $IDYES = 6
Global Const $IDNO = 7
Global Const $IDCLOSE = 8
Global Const $IDHELP = 9
Global Const $IDTRYAGAIN = 10
Global Const $IDCONTINUE = 11
Global Const $SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege"
Global Const $SE_AUDIT_NAME = "SeAuditPrivilege"
Global Const $SE_BACKUP_NAME = "SeBackupPrivilege"
Global Const $SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege"
Global Const $SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege"
Global Const $SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege"
Global Const $SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege"
Global Const $SE_CREATE_SYMBOLIC_LINK_NAME = 'SeCreateSymbolicLinkPrivilege'
Global Const $SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege"
Global Const $SE_DEBUG_NAME = "SeDebugPrivilege"
Global Const $SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege"
Global Const $SE_IMPERSONATE_NAME = "SeImpersonatePrivilege"
Global Const $SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege"
Global Const $SE_INC_WORKING_SET_NAME = 'SeIncreaseWorkingSetPrivilege'
Global Const $SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege"
Global Const $SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege"
Global Const $SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege"
Global Const $SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege"
Global Const $SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege"
Global Const $SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege"
Global Const $SE_RELABEL_NAME = 'SeRelabelPrivilege'
Global Const $SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"
Global Const $SE_RESTORE_NAME = "SeRestorePrivilege"
Global Const $SE_SECURITY_NAME = "SeSecurityPrivilege"
Global Const $SE_SHUTDOWN_NAME = "SeShutdownPrivilege"
Global Const $SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege"
Global Const $SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege"
Global Const $SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege"
Global Const $SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege"
Global Const $SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege"
Global Const $SE_TCB_NAME = "SeTcbPrivilege"
Global Const $SE_TIME_ZONE_NAME = 'SeTimeZonePrivilege'
Global Const $SE_TRUSTED_CREDMAN_ACCESS_NAME = 'SeTrustedCredManAccessPrivilege'
Global Const $SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
Global Const $SE_UNDOCK_NAME = "SeUndockPrivilege"
Global Const $SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001
Global Const $SE_PRIVILEGE_ENABLED = 0x00000002
Global Const $SE_PRIVILEGE_REMOVED = 0x00000004
Global Const $SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000
Global Const $SE_GROUP_MANDATORY = 0x00000001
Global Const $SE_GROUP_ENABLED_BY_DEFAULT = 0x00000002
Global Const $SE_GROUP_ENABLED = 0x00000004
Global Const $SE_GROUP_OWNER = 0x00000008
Global Const $SE_GROUP_USE_FOR_DENY_ONLY = 0x00000010
Global Const $SE_GROUP_INTEGRITY = 0x00000020
Global Const $SE_GROUP_INTEGRITY_ENABLED = 0x00000040
Global Const $SE_GROUP_RESOURCE = 0x20000000
Global Const $SE_GROUP_LOGON_ID = 0xC0000000
Global Enum $TOKENPRIMARY = 1, $TOKENIMPERSONATION
Global Enum $SECURITYANONYMOUS = 0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
Global Enum $TOKENUSER = 1, $TOKENGROUPS, $TOKENPRIVILEGES, $TOKENOWNER, $TOKENPRIMARYGROUP, $TOKENDEFAULTDACL, $TOKENSOURCE, $TOKENTYPE, $TOKENIMPERSONATIONLEVEL, $TOKENSTATISTICS, $TOKENRESTRICTEDSIDS, $TOKENSESSIONID, $TOKENGROUPSANDPRIVILEGES, $TOKENSESSIONREFERENCE, $TOKENSANDBOXINERT, $TOKENAUDITPOLICY, $TOKENORIGIN, $TOKENELEVATIONTYPE, $TOKENLINKEDTOKEN, $TOKENELEVATION, $TOKENHASRESTRICTIONS, $TOKENACCESSINFORMATION, $TOKENVIRTUALIZATIONALLOWED, $TOKENVIRTUALIZATIONENABLED, $TOKENINTEGRITYLEVEL, $TOKENUIACCESS, $TOKENMANDATORYPOLICY, $TOKENLOGONSID
Global Const $TOKEN_ASSIGN_PRIMARY = 0x00000001
Global Const $TOKEN_DUPLICATE = 0x00000002
Global Const $TOKEN_IMPERSONATE = 0x00000004
Global Const $TOKEN_QUERY = 0x00000008
Global Const $TOKEN_QUERY_SOURCE = 0x00000010
Global Const $TOKEN_ADJUST_PRIVILEGES = 0x00000020
Global Const $TOKEN_ADJUST_GROUPS = 0x00000040
Global Const $TOKEN_ADJUST_DEFAULT = 0x00000080
Global Const $TOKEN_ADJUST_SESSIONID = 0x00000100
Global Const $TOKEN_ALL_ACCESS = 0x000F01FF
Global Const $TOKEN_READ = 0x00020008
Global Const $TOKEN_WRITE = 0x000200E0
Global Const $TOKEN_EXECUTE = 0x00020000
Global Const $TOKEN_HAS_TRAVERSE_PRIVILEGE = 0x00000001
Global Const $TOKEN_HAS_BACKUP_PRIVILEGE = 0x00000002
Global Const $TOKEN_HAS_RESTORE_PRIVILEGE = 0x00000004
Global Const $TOKEN_HAS_ADMIN_GROUP = 0x00000008
Global Const $TOKEN_IS_RESTRICTED = 0x00000010
Global Const $TOKEN_SESSION_NOT_REFERENCED = 0x00000020
Global Const $TOKEN_SANDBOX_INERT = 0x00000040
Global Const $TOKEN_HAS_IMPERSONATE_PRIVILEGE = 0x00000080
Global Const $RIGHTS_DELETE = 0x00010000
Global Const $READ_CONTROL = 0x00020000
Global Const $WRITE_DAC = 0x00040000
Global Const $WRITE_OWNER = 0x00080000
Global Const $SYNCHRONIZE = 0x00100000
Global Const $ACCESS_SYSTEM_SECURITY = 0x01000000
Global Const $STANDARD_RIGHTS_REQUIRED = 0x000f0000
Global Const $STANDARD_RIGHTS_READ = $READ_CONTROL
Global Const $STANDARD_RIGHTS_WRITE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_EXECUTE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_ALL = 0x001F0000
Global Const $SPECIFIC_RIGHTS_ALL = 0x0000FFFF
Global Enum $NOT_USED_ACCESS = 0, $GRANT_ACCESS, $SET_ACCESS, $DENY_ACCESS, $REVOKE_ACCESS, $SET_AUDIT_SUCCESS, $SET_AUDIT_FAILURE
Global Enum $TRUSTEE_IS_UNKNOWN = 0, $TRUSTEE_IS_USER, $TRUSTEE_IS_GROUP, $TRUSTEE_IS_DOMAIN, $TRUSTEE_IS_ALIAS, $TRUSTEE_IS_WELL_KNOWN_GROUP, $TRUSTEE_IS_DELETED, $TRUSTEE_IS_INVALID, $TRUSTEE_IS_COMPUTER
Global Const $LOGON_WITH_PROFILE = 0x00000001
Global Const $LOGON_NETCREDENTIALS_ONLY = 0x00000002
Global Enum $SIDTYPEUSER = 1, $SIDTYPEGROUP, $SIDTYPEDOMAIN, $SIDTYPEALIAS, $SIDTYPEWELLKNOWNGROUP, $SIDTYPEDELETEDACCOUNT, $SIDTYPEINVALID, $SIDTYPEUNKNOWN, $SIDTYPECOMPUTER, $SIDTYPELABEL
Global Const $SID_ADMINISTRATORS = "S-1-5-32-544"
Global Const $SID_USERS = "S-1-5-32-545"
Global Const $SID_GUESTS = "S-1-5-32-546"
Global Const $SID_ACCOUNT_OPERATORS = "S-1-5-32-548"
Global Const $SID_SERVER_OPERATORS = "S-1-5-32-549"
Global Const $SID_PRINT_OPERATORS = "S-1-5-32-550"
Global Const $SID_BACKUP_OPERATORS = "S-1-5-32-551"
Global Const $SID_REPLICATOR = "S-1-5-32-552"
Global Const $SID_OWNER = "S-1-3-0"
Global Const $SID_EVERYONE = "S-1-1-0"
Global Const $SID_NETWORK = "S-1-5-2"
Global Const $SID_INTERACTIVE = "S-1-5-4"
Global Const $SID_SYSTEM = "S-1-5-18"
Global Const $SID_AUTHENTICATED_USERS = "S-1-5-11"
Global Const $SID_SCHANNEL_AUTHENTICATION = "S-1-5-64-14"
Global Const $SID_DIGEST_AUTHENTICATION = "S-1-5-64-21"
Global Const $SID_NT_SERVICE = "S-1-5-80"
Global Const $SID_UNTRUSTED_MANDATORY_LEVEL = "S-1-16-0"
Global Const $SID_LOW_MANDATORY_LEVEL = "S-1-16-4096"
Global Const $SID_MEDIUM_MANDATORY_LEVEL = "S-1-16-8192"
Global Const $SID_MEDIUM_PLUS_MANDATORY_LEVEL = "S-1-16-8448"
Global Const $SID_HIGH_MANDATORY_LEVEL = "S-1-16-12288"
Global Const $SID_SYSTEM_MANDATORY_LEVEL = "S-1-16-16384"
Global Const $SID_PROTECTED_PROCESS_MANDATORY_LEVEL = "S-1-16-20480"
Global Const $SID_SECURE_PROCESS_MANDATORY_LEVEL = "S-1-16-28672"
Global Const $SID_ALL_SERVICES = "S-1-5-80-0"
Func _WinAPI_GetLastError(Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $aResult = DllCall("kernel32.dll", "dword", "GetLastError")
Return SetError($_iCurrentError, $_iCurrentExtended, $aResult[0])
EndFunc
Func _WinAPI_SetLastError($iErrorCode, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
DllCall("kernel32.dll", "none", "SetLastError", "dword", $iErrorCode)
Return SetError($_iCurrentError, $_iCurrentExtended, Null)
EndFunc
Func __COMErrorFormating($oCOMError, $sPrefix = @TAB)
Local Const $STR_STRIPTRAILING = 2
Local $sError = "COM Error encountered in " & @ScriptName & " (" & $oCOMError.Scriptline & ") :" & @CRLF &  $sPrefix & "Number        " & @TAB & "= 0x" & Hex($oCOMError.Number, 8) & " (" & $oCOMError.Number & ")" & @CRLF &  $sPrefix & "WinDescription" & @TAB & "= " & StringStripWS($oCOMError.WinDescription, $STR_STRIPTRAILING) & @CRLF &  $sPrefix & "Description   " & @TAB & "= " & StringStripWS($oCOMError.Description, $STR_STRIPTRAILING) & @CRLF &  $sPrefix & "Source        " & @TAB & "= " & $oCOMError.Source & @CRLF &  $sPrefix & "HelpFile      " & @TAB & "= " & $oCOMError.HelpFile & @CRLF &  $sPrefix & "HelpContext   " & @TAB & "= " & $oCOMError.HelpContext & @CRLF &  $sPrefix & "LastDllError  " & @TAB & "= " & $oCOMError.LastDllError & @CRLF &  $sPrefix & "Retcode       " & @TAB & "= 0x" & Hex($oCOMError.retcode)
Return $sError
EndFunc
Func _Security__AdjustTokenPrivileges($hToken, $bDisableAll, $tNewState, $iBufferLen, $tPrevState = 0, $pRequired = 0)
Local $aCall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $hToken, "bool", $bDisableAll, "struct*", $tNewState, "dword", $iBufferLen, "struct*", $tPrevState, "struct*", $pRequired)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__CreateProcessWithToken($hToken, $iLogonFlags, $sCommandLine, $iCreationFlags, $sCurDir, $tSTARTUPINFO, $tPROCESS_INFORMATION)
Local $aCall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $hToken, "dword", $iLogonFlags, "ptr", 0, "wstr", $sCommandLine, "dword", $iCreationFlags, "struct*", 0, "wstr", $sCurDir, "struct*", $tSTARTUPINFO, "struct*", $tPROCESS_INFORMATION)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
Return True
EndFunc
Func _Security__DuplicateTokenEx($hExistingToken, $iDesiredAccess, $iImpersonationLevel, $iTokenType)
Local $aCall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $hExistingToken, "dword", $iDesiredAccess, "struct*", 0, "int", $iImpersonationLevel, "int", $iTokenType, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[6]
EndFunc
Func _Security__GetAccountSid($sAccount, $sSystem = "")
Local $aAcct = _Security__LookupAccountName($sAccount, $sSystem)
If @error Then Return SetError(@error, @extended, 0)
If IsArray($aAcct) Then Return _Security__StringSidToSid($aAcct[0])
Return ''
EndFunc
Func _Security__GetLengthSid($pSID)
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, @extended, 0)
Local $aCall = DllCall("advapi32.dll", "dword", "GetLengthSid", "struct*", $pSID)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _Security__GetTokenInformation($hToken, $iClass)
Local $aCall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $hToken, "int", $iClass, "struct*", 0, "dword", 0, "dword*", 0)
If @error Or Not $aCall[5] Then Return SetError(@error + 10, @extended, 0)
Local $iLen = $aCall[5]
Local $tBuffer = DllStructCreate("byte[" & $iLen & "]")
$aCall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $hToken, "int", $iClass, "struct*", $tBuffer, "dword", DllStructGetSize($tBuffer), "dword*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $tBuffer
EndFunc
Func _Security__ImpersonateSelf($iLevel = $SECURITYIMPERSONATION)
Local $aCall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $iLevel)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__IsValidSid($pSID)
Local $aCall = DllCall("advapi32.dll", "bool", "IsValidSid", "struct*", $pSID)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__LookupAccountName($sAccount, $sSystem = "")
Local $tData = DllStructCreate("byte SID[256]")
Local $aCall = DllCall("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $sSystem, "wstr", $sAccount, "struct*", $tData, "dword*", DllStructGetSize($tData), "wstr", "", "dword*", DllStructGetSize($tData), "int*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Local $aAcct[3]
$aAcct[0] = _Security__SidToStringSid(DllStructGetPtr($tData, "SID"))
$aAcct[1] = $aCall[5]
$aAcct[2] = $aCall[7]
Return $aAcct
EndFunc
Func _Security__LookupAccountSid($vSID, $sSystem = "")
Local $pSID, $aAcct[3]
If IsString($vSID) Then
$pSID = _Security__StringSidToSid($vSID)
Else
$pSID = $vSID
EndIf
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, @extended, 0)
Local $sTypeSystem = "ptr"
If $sSystem Then $sTypeSystem = "wstr"
Local $aCall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", $sTypeSystem, $sSystem, "struct*", $pSID, "wstr", "", "dword*", 65536, "wstr", "", "dword*", 65536, "int*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Local $aAcct[3]
$aAcct[0] = $aCall[3]
$aAcct[1] = $aCall[5]
$aAcct[2] = $aCall[7]
Return $aAcct
EndFunc
Func _Security__LookupPrivilegeValue($sSystem, $sName)
Local $aCall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $sSystem, "wstr", $sName, "int64*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenProcessToken($hProcess, $iAccess)
Local $aCall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hProcess, "dword", $iAccess, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenThreadToken($iAccess, $hThread = 0, $bOpenAsSelf = False)
If $hThread = 0 Then
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error + 10, @extended, 0)
$hThread = $aResult[0]
EndIf
Local $aCall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hThread, "dword", $iAccess, "bool", $bOpenAsSelf, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[4]
EndFunc
Func _Security__OpenThreadTokenEx($iAccess, $hThread = 0, $bOpenAsSelf = False)
Local $hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then
Local Const $ERROR_NO_TOKEN = 1008
If _WinAPI_GetLastError() <> $ERROR_NO_TOKEN Then Return SetError(20, _WinAPI_GetLastError(), 0)
If Not _Security__ImpersonateSelf() Then Return SetError(@error + 10, _WinAPI_GetLastError(), 0)
$hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then Return SetError(@error, _WinAPI_GetLastError(), 0)
EndIf
Return $hToken
EndFunc
Func _Security__SetPrivilege($hToken, $sPrivilege, $bEnable)
Local $iLUID = _Security__LookupPrivilegeValue("", $sPrivilege)
If $iLUID = 0 Then Return SetError(@error + 10, @extended, False)
Local Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Local $tCurrState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iCurrState = DllStructGetSize($tCurrState)
Local $tPrevState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iPrevState = DllStructGetSize($tPrevState)
Local $tRequired = DllStructCreate("int Data")
DllStructSetData($tCurrState, "Count", 1)
DllStructSetData($tCurrState, "LUID", $iLUID)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tCurrState, $iCurrState, $tPrevState, $tRequired) Then Return SetError(2, @error, False)
DllStructSetData($tPrevState, "Count", 1)
DllStructSetData($tPrevState, "LUID", $iLUID)
Local $iAttributes = DllStructGetData($tPrevState, "Attributes")
If $bEnable Then
$iAttributes = BitOR($iAttributes, $SE_PRIVILEGE_ENABLED)
Else
$iAttributes = BitAND($iAttributes, BitNOT($SE_PRIVILEGE_ENABLED))
EndIf
DllStructSetData($tPrevState, "Attributes", $iAttributes)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tPrevState, $iPrevState, $tCurrState, $tRequired) Then  Return SetError(3, @error, False)
Return True
EndFunc
Func _Security__SetTokenInformation($hToken, $iTokenInformation, $vTokenInformation, $iTokenInformationLength)
Local $aCall = DllCall("advapi32.dll", "bool", "SetTokenInformation", "handle", $hToken, "int", $iTokenInformation, "struct*", $vTokenInformation, "dword", $iTokenInformationLength)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
Return True
EndFunc
Func _Security__SidToStringSid($pSID)
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, 0, "")
Local $aCall = DllCall("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $pSID, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, "")
Local $pStringSid = $aCall[2]
Local $aLen = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $pStringSid)
Local $sSID = DllStructGetData(DllStructCreate("wchar Text[" & $aLen[0] + 1 & "]", $pStringSid), "Text")
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pStringSid)
Return $sSID
EndFunc
Func _Security__SidTypeStr($iType)
Switch $iType
Case $SIDTYPEUSER
Return "User"
Case $SIDTYPEGROUP
Return "Group"
Case $SIDTYPEDOMAIN
Return "Domain"
Case $SIDTYPEALIAS
Return "Alias"
Case $SIDTYPEWELLKNOWNGROUP
Return "Well Known Group"
Case $SIDTYPEDELETEDACCOUNT
Return "Deleted Account"
Case $SIDTYPEINVALID
Return "Invalid"
Case $SIDTYPEUNKNOWN
Return "Unknown Type"
Case $SIDTYPECOMPUTER
Return "Computer"
Case $SIDTYPELABEL
Return "A mandatory integrity label SID"
Case Else
Return "Unknown SID Type"
EndSwitch
EndFunc
Func _Security__StringSidToSid($sSID)
Local $aCall = DllCall("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $sSID, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Local $pSID = $aCall[2]
Local $tBuffer = DllStructCreate("byte Data[" & _Security__GetLengthSid($pSID) & "]", $pSID)
Local $tSID = DllStructCreate("byte Data[" & DllStructGetSize($tBuffer) & "]")
DllStructSetData($tSID, "Data", DllStructGetData($tBuffer, "Data"))
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pSID)
Return $tSID
EndFunc
Func _SendMessage($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aResult = DllCall("user32.dll", $sReturnType, "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aResult[$iReturn]
Return $aResult
EndFunc
Func _SendMessageA($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aResult = DllCall("user32.dll", $sReturnType, "SendMessageA", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aResult[$iReturn]
Return $aResult
EndFunc
Global Const $STR_NOCASESENSE = 0
Global Const $STR_CASESENSE = 1
Global Const $STR_NOCASESENSEBASIC = 2
Global Const $STR_STRIPLEADING = 1
Global Const $STR_STRIPTRAILING = 2
Global Const $STR_STRIPSPACES = 4
Global Const $STR_STRIPALL = 8
Global Const $STR_CHRSPLIT = 0
Global Const $STR_ENTIRESPLIT = 1
Global Const $STR_NOCOUNT = 2
Global Const $STR_REGEXPMATCH = 0
Global Const $STR_REGEXPARRAYMATCH = 1
Global Const $STR_REGEXPARRAYFULLMATCH = 2
Global Const $STR_REGEXPARRAYGLOBALMATCH = 3
Global Const $STR_REGEXPARRAYGLOBALFULLMATCH = 4
Global Const $STR_ENDISSTART = 0
Global Const $STR_ENDNOTSTART = 1
Global Const $SB_ANSI = 1
Global Const $SB_UTF16LE = 2
Global Const $SB_UTF16BE = 3
Global Const $SB_UTF8 = 4
Global Const $SE_UTF16 = 0
Global Const $SE_ANSI = 1
Global Const $SE_UTF8 = 2
Global Const $STR_UTF16 = 0
Global Const $STR_UCS2 = 1
Global Const $tagPOINT = "struct;long X;long Y;endstruct"
Global Const $tagRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagSIZE = "struct;long X;long Y;endstruct"
Global Const $tagMARGINS = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $tagFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagTIME_ZONE_INFORMATION = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $tagNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $tagCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" &  "int Indent;lparam Param"
Global Const $tagNMCBEDRAGBEGIN = $tagNMHDR & ";int ItemID;wchar szText[260]"
Global Const $tagNMCBEENDEDIT = $tagNMHDR & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $tagNMCOMBOBOXEX = $tagNMHDR & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" &  "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $tagDTPRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" &  "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" &  "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $tagNMDATETIMECHANGE = $tagNMHDR & ";dword Flag;" & $tagSYSTEMTIME
Global Const $tagNMDATETIMEFORMAT = $tagNMHDR & ";ptr Format;" & $tagSYSTEMTIME & ";ptr pDisplay;wchar Display[64]"
Global Const $tagNMDATETIMEFORMATQUERY = $tagNMHDR & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $tagNMDATETIMEKEYDOWN = $tagNMHDR & ";int VirtKey;ptr Format;" & $tagSYSTEMTIME
Global Const $tagNMDATETIMESTRING = $tagNMHDR & ";ptr UserString;" & $tagSYSTEMTIME & ";dword Flags"
Global Const $tagEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" &  "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" &  "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $tagGDIP_EFFECTPARAMS_Blur = "float Radius; bool ExpandEdge"
Global Const $tagGDIP_EFFECTPARAMS_BrightnessContrast = "int BrightnessLevel; int ContrastLevel"
Global Const $tagGDIP_EFFECTPARAMS_ColorBalance = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $tagGDIP_EFFECTPARAMS_ColorCurve = "int Adjustment; int Channel; int AdjustValue"
Global Const $tagGDIP_EFFECTPARAMS_ColorLUT = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $tagGDIP_EFFECTPARAMS_HueSaturationLightness = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $tagGDIP_EFFECTPARAMS_Levels = "int Highlight; int Midtone; int Shadow"
Global Const $tagGDIP_EFFECTPARAMS_RedEyeCorrection = "uint NumberOfAreas; ptr Areas"
Global Const $tagGDIP_EFFECTPARAMS_Sharpen = "float Radius; float Amount"
Global Const $tagGDIP_EFFECTPARAMS_Tint = "int Hue; int Amount"
Global Const $tagGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $tagGDIPCOLORMATRIX = "float m[25]"
Global Const $tagGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $tagGDIPENCODERPARAMS = "uint Count;" & $tagGDIPENCODERPARAM
Global Const $tagGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $tagGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $tagGDIPSTARTUPOUTPUT = "ptr HookProc;ptr UnhookProc"
Global Const $tagGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" &  "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $tagGDIPPENCODERPARAMS = "uint Count;byte Params[1]"
Global Const $tagHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $tagNMHDDISPINFO = $tagNMHDR & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $tagNMHDFILTERBTNCLICK = $tagNMHDR & ";int Item;" & $tagRECT
Global Const $tagNMHEADER = $tagNMHDR & ";int Item;int Button;ptr pItem"
Global Const $tagGETIPAddress = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $tagNMIPADDRESS = $tagNMHDR & ";int Field;int Value"
Global Const $tagLVFINDINFO = "struct;uint Flags;ptr Text;lparam Param;" & $tagPOINT & ";uint Direction;endstruct"
Global Const $tagLVHITTESTINFO = $tagPOINT & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $tagLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" &  "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $tagNMLISTVIEW = $tagNMHDR & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" &  "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $tagNMLVCUSTOMDRAW = "struct;" & $tagNMHDR & ";dword dwDrawStage;handle hdc;" & $tagRECT &  ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" &  ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" &  "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $tagNMLVDISPINFO = $tagNMHDR & ";" & $tagLVITEM
Global Const $tagNMLVFINDITEM = $tagNMHDR & ";int Start;" & $tagLVFINDINFO
Global Const $tagNMLVGETINFOTIP = $tagNMHDR & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $tagNMITEMACTIVATE = $tagNMHDR & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" &  $tagPOINT & ";lparam lParam;uint KeyFlags"
Global Const $tagNMLVKEYDOWN = "align 1;" & $tagNMHDR & ";word VKey;uint Flags"
Global Const $tagNMLVSCROLL = $tagNMHDR & ";int DX;int DY"
Global Const $tagMCHITTESTINFO = "uint Size;" & $tagPOINT & ";uint Hit;" & $tagSYSTEMTIME &  ";" & $tagRECT & ";int iOffset;int iRow;int iCol"
Global Const $tagMCMONTHRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds;short Span"
Global Const $tagMCRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $tagMCSELRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds"
Global Const $tagNMDAYSTATE = $tagNMHDR & ";" & $tagSYSTEMTIME & ";int DayState;ptr pDayState"
Global Const $tagNMSELCHANGE = $tagNMHDR &  ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" &  "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $tagNMOBJECTNOTIFY = $tagNMHDR & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $tagNMTCKEYDOWN = "align 1;" & $tagNMHDR & ";word VKey;uint Flags"
Global Const $tagTVITEM = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" &  "int Children;lparam Param;endstruct"
Global Const $tagTVITEMEX = "struct;" & $tagTVITEM & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $tagNMTREEVIEW = $tagNMHDR & ";uint Action;" &  "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" &  "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" &  "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" &  "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" &  "struct;long PointX;long PointY;endstruct"
Global Const $tagNMTVCUSTOMDRAW = "struct;" & $tagNMHDR & ";dword DrawStage;handle HDC;" & $tagRECT &  ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" &  ";dword ClrText;dword ClrTextBk;int Level"
Global Const $tagNMTVDISPINFO = $tagNMHDR & ";" & $tagTVITEM
Global Const $tagNMTVGETINFOTIP = $tagNMHDR & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $tagNMTVITEMCHANGE = $tagNMHDR & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $tagTVHITTESTINFO = $tagPOINT & ";uint Flags;handle Item"
Global Const $tagNMTVKEYDOWN = "align 1;" & $tagNMHDR & ";word VKey;uint Flags"
Global Const $tagNMMOUSE = $tagNMHDR & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $tagPOINT & ";lparam HitInfo"
Global Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $tagIMAGEINFO = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $tagRECT
Global Const $tagMENUINFO = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $tagMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" &  "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" &  "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" &  "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") ? "" : ";" & $tagRECT & ";uint uChevronState")
Global Const $tagNMREBARAUTOBREAK = $tagNMHDR & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $tagNMRBAUTOSIZE = $tagNMHDR & ";bool fChanged;" &  "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" &  "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $tagNMREBAR = $tagNMHDR & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $tagNMREBARCHEVRON = $tagNMHDR & ";uint uBand;uint wID;lparam lParam;" & $tagRECT & ";lparam lParamNM"
Global Const $tagNMREBARCHILDSIZE = $tagNMHDR & ";uint uBand;uint wID;" &  "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" &  "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $tagCOLORSCHEME = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $tagNMTOOLBAR = $tagNMHDR & ";int iItem;" &  "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" &  ";int cchText;ptr pszText;" & $tagRECT
Global Const $tagNMTBHOTITEM = $tagNMHDR & ";int idOld;int idNew;dword dwFlags"
Global Const $tagTBBUTTON = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $tagTBBUTTONINFO = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $tagNETRESOURCE = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $tagOVERLAPPED = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $tagOPENFILENAME = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" &  "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" &  "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" &  "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $tagBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" &  "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagBITMAPINFO = $tagBITMAPINFOHEADER & ";dword biRGBQuad[1]"
Global Const $tagBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagWINDOWPLACEMENT = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $tagWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagSCROLLINFO = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $tagSCROLLBARINFO = "dword cbSize;" & $tagRECT & ";int dxyLineButton;int xyThumbTop;" &  "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $tagLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" &  "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagKBDLLHOOKSTRUCT = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $tagPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" &  "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" &  "handle StdOutput;handle StdError"
Global Const $tagSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagWIN32_FIND_DATA = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $tagTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" &  "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" &  "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" &  "byte tmPitchAndFamily;byte tmCharSet"
Global Const $HGDI_ERROR = Ptr(-1)
Global Const $INVALID_HANDLE_VALUE = Ptr(-1)
Global Const $CLR_INVALID = -1
Global Const $NULL_BRUSH = 5
Global Const $NULL_PEN = 8
Global Const $BLACK_BRUSH = 4
Global Const $DKGRAY_BRUSH = 3
Global Const $DC_BRUSH = 18
Global Const $GRAY_BRUSH = 2
Global Const $HOLLOW_BRUSH = $NULL_BRUSH
Global Const $LTGRAY_BRUSH = 1
Global Const $WHITE_BRUSH = 0
Global Const $BLACK_PEN = 7
Global Const $DC_PEN = 19
Global Const $WHITE_PEN = 6
Global Const $ANSI_FIXED_FONT = 11
Global Const $ANSI_VAR_FONT = 12
Global Const $DEVICE_DEFAULT_FONT = 14
Global Const $DEFAULT_GUI_FONT = 17
Global Const $OEM_FIXED_FONT = 10
Global Const $SYSTEM_FONT = 13
Global Const $SYSTEM_FIXED_FONT = 16
Global Const $DEFAULT_PALETTE = 15
Global Const $MB_PRECOMPOSED = 0x01
Global Const $MB_COMPOSITE = 0x02
Global Const $MB_USEGLYPHCHARS = 0x04
Global Const $ULW_ALPHA = 0x02
Global Const $ULW_COLORKEY = 0x01
Global Const $ULW_OPAQUE = 0x04
Global Const $ULW_EX_NORESIZE = 0x08
Global Const $WH_CALLWNDPROC = 4
Global Const $WH_CALLWNDPROCRET = 12
Global Const $WH_CBT = 5
Global Const $WH_DEBUG = 9
Global Const $WH_FOREGROUNDIDLE = 11
Global Const $WH_GETMESSAGE = 3
Global Const $WH_JOURNALPLAYBACK = 1
Global Const $WH_JOURNALRECORD = 0
Global Const $WH_KEYBOARD = 2
Global Const $WH_KEYBOARD_LL = 13
Global Const $WH_MOUSE = 7
Global Const $WH_MOUSE_LL = 14
Global Const $WH_MSGFILTER = -1
Global Const $WH_SHELL = 10
Global Const $WH_SYSMSGFILTER = 6
Global Const $WPF_ASYNCWINDOWPLACEMENT = 0x04
Global Const $WPF_RESTORETOMAXIMIZED = 0x02
Global Const $WPF_SETMINPOSITION = 0x01
Global Const $KF_EXTENDED = 0x0100
Global Const $KF_ALTDOWN = 0x2000
Global Const $KF_UP = 0x8000
Global Const $LLKHF_EXTENDED = BitShift($KF_EXTENDED, 8)
Global Const $LLKHF_INJECTED = 0x10
Global Const $LLKHF_ALTDOWN = BitShift($KF_ALTDOWN, 8)
Global Const $LLKHF_UP = BitShift($KF_UP, 8)
Global Const $OFN_ALLOWMULTISELECT = 0x00000200
Global Const $OFN_CREATEPROMPT = 0x00002000
Global Const $OFN_DONTADDTORECENT = 0x02000000
Global Const $OFN_ENABLEHOOK = 0x00000020
Global Const $OFN_ENABLEINCLUDENOTIFY = 0x00400000
Global Const $OFN_ENABLESIZING = 0x00800000
Global Const $OFN_ENABLETEMPLATE = 0x00000040
Global Const $OFN_ENABLETEMPLATEHANDLE = 0x00000080
Global Const $OFN_EXPLORER = 0x00080000
Global Const $OFN_EXTENSIONDIFFERENT = 0x00000400
Global Const $OFN_FILEMUSTEXIST = 0x00001000
Global Const $OFN_FORCESHOWHIDDEN = 0x10000000
Global Const $OFN_HIDEREADONLY = 0x00000004
Global Const $OFN_LONGNAMES = 0x00200000
Global Const $OFN_NOCHANGEDIR = 0x00000008
Global Const $OFN_NODEREFERENCELINKS = 0x00100000
Global Const $OFN_NOLONGNAMES = 0x00040000
Global Const $OFN_NONETWORKBUTTON = 0x00020000
Global Const $OFN_NOREADONLYRETURN = 0x00008000
Global Const $OFN_NOTESTFILECREATE = 0x00010000
Global Const $OFN_NOVALIDATE = 0x00000100
Global Const $OFN_OVERWRITEPROMPT = 0x00000002
Global Const $OFN_PATHMUSTEXIST = 0x00000800
Global Const $OFN_READONLY = 0x00000001
Global Const $OFN_SHAREAWARE = 0x00004000
Global Const $OFN_SHOWHELP = 0x00000010
Global Const $OFN_EX_NOPLACESBAR = 0x00000001
Global Const $TMPF_FIXED_PITCH = 0x01
Global Const $TMPF_VECTOR = 0x02
Global Const $TMPF_TRUETYPE = 0x04
Global Const $TMPF_DEVICE = 0x08
Global Const $DUPLICATE_CLOSE_SOURCE = 0x00000001
Global Const $DUPLICATE_SAME_ACCESS = 0x00000002
Global Const $DI_MASK = 0x0001
Global Const $DI_IMAGE = 0x0002
Global Const $DI_NORMAL = 0x0003
Global Const $DI_COMPAT = 0x0004
Global Const $DI_DEFAULTSIZE = 0x0008
Global Const $DI_NOMIRROR = 0x0010
Global Const $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 0x00000001
Global Const $DISPLAY_DEVICE_MULTI_DRIVER = 0x00000002
Global Const $DISPLAY_DEVICE_PRIMARY_DEVICE = 0x00000004
Global Const $DISPLAY_DEVICE_MIRRORING_DRIVER = 0x00000008
Global Const $DISPLAY_DEVICE_VGA_COMPATIBLE = 0x00000010
Global Const $DISPLAY_DEVICE_REMOVABLE = 0x00000020
Global Const $DISPLAY_DEVICE_DISCONNECT = 0x02000000
Global Const $DISPLAY_DEVICE_REMOTE = 0x04000000
Global Const $DISPLAY_DEVICE_MODESPRUNED = 0x08000000
Global Const $FLASHW_CAPTION = 0x00000001
Global Const $FLASHW_TRAY = 0x00000002
Global Const $FLASHW_TIMER = 0x00000004
Global Const $FLASHW_TIMERNOFG = 0x0000000C
Global Const $FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100
Global Const $FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200
Global Const $FORMAT_MESSAGE_FROM_STRING = 0x00000400
Global Const $FORMAT_MESSAGE_FROM_HMODULE = 0x00000800
Global Const $FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
Global Const $FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000
Global Const $GW_HWNDFIRST = 0
Global Const $GW_HWNDLAST = 1
Global Const $GW_HWNDNEXT = 2
Global Const $GW_HWNDPREV = 3
Global Const $GW_OWNER = 4
Global Const $GW_CHILD = 5
Global Const $GW_ENABLEDPOPUP = 6
Global Const $GWL_WNDPROC = 0xFFFFFFFC
Global Const $GWL_HINSTANCE = 0xFFFFFFFA
Global Const $GWL_HWNDPARENT = 0xFFFFFFF8
Global Const $GWL_ID = 0xFFFFFFF4
Global Const $GWL_STYLE = 0xFFFFFFF0
Global Const $GWL_EXSTYLE = 0xFFFFFFEC
Global Const $GWL_USERDATA = 0xFFFFFFEB
Global Const $STD_CUT = 0
Global Const $STD_COPY = 1
Global Const $STD_PASTE = 2
Global Const $STD_UNDO = 3
Global Const $STD_REDOW = 4
Global Const $STD_DELETE = 5
Global Const $STD_FILENEW = 6
Global Const $STD_FILEOPEN = 7
Global Const $STD_FILESAVE = 8
Global Const $STD_PRINTPRE = 9
Global Const $STD_PROPERTIES = 10
Global Const $STD_HELP = 11
Global Const $STD_FIND = 12
Global Const $STD_REPLACE = 13
Global Const $STD_PRINT = 14
Global Const $IMAGE_BITMAP = 0
Global Const $IMAGE_ICON = 1
Global Const $IMAGE_CURSOR = 2
Global Const $IMAGE_ENHMETAFILE = 3
Global Const $KB_SENDSPECIAL = 0
Global Const $KB_SENDRAW = 1
Global Const $KB_CAPSOFF = 0
Global Const $KB_CAPSON = 1
Global Const $DONT_RESOLVE_DLL_REFERENCES = 0x01
Global Const $LOAD_LIBRARY_AS_DATAFILE = 0x02
Global Const $LOAD_WITH_ALTERED_SEARCH_PATH = 0x08
Global Const $LOAD_IGNORE_CODE_AUTHZ_LEVEL = 0x00000010
Global Const $LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 0x00000040
Global Const $LOAD_LIBRARY_AS_IMAGE_RESOURCE = 0x00000020
Global Const $LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 0x00000200
Global Const $LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x00001000
Global Const $LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 0x00000100
Global Const $LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
Global Const $LOAD_LIBRARY_SEARCH_USER_DIRS = 0x00000400
Global Const $S_OK = 0x00000000
Global Const $E_ABORT = 0x80004004
Global Const $E_ACCESSDENIED = 0x80070005
Global Const $E_FAIL = 0x80004005
Global Const $E_HANDLE = 0x80070006
Global Const $E_INVALIDARG = 0x80070057
Global Const $E_NOINTERFACE = 0x80004002
Global Const $E_NOTIMPL = 0x80004001
Global Const $E_OUTOFMEMORY = 0x8007000E
Global Const $E_POINTER = 0x80004003
Global Const $E_UNEXPECTED = 0x8000FFFF
Global Const $LR_DEFAULTCOLOR = 0x0000
Global Const $LR_MONOCHROME = 0x0001
Global Const $LR_COLOR = 0x0002
Global Const $LR_COPYRETURNORG = 0x0004
Global Const $LR_COPYDELETEORG = 0x0008
Global Const $LR_LOADFROMFILE = 0x0010
Global Const $LR_LOADTRANSPARENT = 0x0020
Global Const $LR_DEFAULTSIZE = 0x0040
Global Const $LR_VGACOLOR = 0x0080
Global Const $LR_LOADMAP3DCOLORS = 0x1000
Global Const $LR_CREATEDIBSECTION = 0x2000
Global Const $LR_COPYFROMRESOURCE = 0x4000
Global Const $LR_SHARED = 0x8000
Global Const $OBM_TRTYPE = 32732
Global Const $OBM_LFARROWI = 32734
Global Const $OBM_RGARROWI = 32735
Global Const $OBM_DNARROWI = 32736
Global Const $OBM_UPARROWI = 32737
Global Const $OBM_COMBO = 32738
Global Const $OBM_MNARROW = 32739
Global Const $OBM_LFARROWD = 32740
Global Const $OBM_RGARROWD = 32741
Global Const $OBM_DNARROWD = 32742
Global Const $OBM_UPARROWD = 32743
Global Const $OBM_RESTORED = 32744
Global Const $OBM_ZOOMD = 32745
Global Const $OBM_REDUCED = 32746
Global Const $OBM_RESTORE = 32747
Global Const $OBM_ZOOM = 32748
Global Const $OBM_REDUCE = 32749
Global Const $OBM_LFARROW = 32750
Global Const $OBM_RGARROW = 32751
Global Const $OBM_DNARROW = 32752
Global Const $OBM_UPARROW = 32753
Global Const $OBM_CLOSE = 32754
Global Const $OBM_OLD_RESTORE = 32755
Global Const $OBM_OLD_ZOOM = 32756
Global Const $OBM_OLD_REDUCE = 32757
Global Const $OBM_BTNCORNERS = 32758
Global Const $OBM_CHECKBOXES = 32759
Global Const $OBM_CHECK = 32760
Global Const $OBM_BTSIZE = 32761
Global Const $OBM_OLD_LFARROW = 32762
Global Const $OBM_OLD_RGARROW = 32763
Global Const $OBM_OLD_DNARROW = 32764
Global Const $OBM_OLD_UPARROW = 32765
Global Const $OBM_SIZE = 32766
Global Const $OBM_OLD_CLOSE = 32767
Global Const $OIC_SAMPLE = 32512
Global Const $OIC_HAND = 32513
Global Const $OIC_QUES = 32514
Global Const $OIC_BANG = 32515
Global Const $OIC_NOTE = 32516
Global Const $OIC_WINLOGO = 32517
Global Const $OIC_WARNING = $OIC_BANG
Global Const $OIC_ERROR = $OIC_HAND
Global Const $OIC_INFORMATION = $OIC_NOTE
Global $__g_aInProcess_WinAPI[64][2] = [[0, 0]]
Global $__g_aWinList_WinAPI[64][2] = [[0, 0]]
Global Const $__WINAPICONSTANT_WM_SETFONT = 0x0030
Global Const $__WINAPICONSTANT_FW_NORMAL = 400
Global Const $__WINAPICONSTANT_DEFAULT_CHARSET = 1
Global Const $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_DEFAULT_QUALITY = 0
Global Const $__WINAPICONSTANT_LOGPIXELSX = 88
Global Const $__WINAPICONSTANT_LOGPIXELSY = 90
Global Const $tagCURSORINFO = "dword Size;dword Flags;handle hCursor;" & $tagPOINT
Global Const $tagDISPLAY_DEVICE = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
Global Const $tagFLASHWINFO = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
Global Const $tagICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Global Const $tagMEMORYSTATUSEX = "dword Length;dword MemoryLoad;" &  "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" &  "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
Func _WinAPI_AttachConsole($iPID = -1)
Local $aResult = DllCall("kernel32.dll", "bool", "AttachConsole", "dword", $iPID)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_AttachThreadInput($iAttach, $iAttachTo, $bAttach)
Local $aResult = DllCall("user32.dll", "bool", "AttachThreadInput", "dword", $iAttach, "dword", $iAttachTo, "bool", $bAttach)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_Beep($iFreq = 500, $iDuration = 1000)
Local $aResult = DllCall("kernel32.dll", "bool", "Beep", "dword", $iFreq, "dword", $iDuration)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_BitBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $iROP)
Local $aResult = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hDestDC, "int", $iXDest, "int", $iYDest, "int", $iWidth,  "int", $iHeight, "handle", $hSrcDC, "int", $iXSrc, "int", $iYSrc, "dword", $iROP)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CallNextHookEx($hHook, $iCode, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hHook, "int", $iCode, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_CallWindowProc($pPrevWndFunc, $hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pPrevWndFunc, "hwnd", $hWnd, "uint", $iMsg,  "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_ClientToScreen($hWnd, ByRef $tPoint)
Local $aRet = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hWnd, "struct*", $tPoint)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_CloseHandle($hObject)
Local $aResult = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CombineRgn($hRgnDest, $hRgnSrc1, $hRgnSrc2, $iCombineMode)
Local $aResult = DllCall("gdi32.dll", "int", "CombineRgn", "handle", $hRgnDest, "handle", $hRgnSrc1, "handle", $hRgnSrc2,  "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CommDlgExtendedError()
Local Const $CDERR_DIALOGFAILURE = 0xFFFF
Local Const $CDERR_FINDRESFAILURE = 0x06
Local Const $CDERR_INITIALIZATION = 0x02
Local Const $CDERR_LOADRESFAILURE = 0x07
Local Const $CDERR_LOADSTRFAILURE = 0x05
Local Const $CDERR_LOCKRESFAILURE = 0x08
Local Const $CDERR_MEMALLOCFAILURE = 0x09
Local Const $CDERR_MEMLOCKFAILURE = 0x0A
Local Const $CDERR_NOHINSTANCE = 0x04
Local Const $CDERR_NOHOOK = 0x0B
Local Const $CDERR_NOTEMPLATE = 0x03
Local Const $CDERR_REGISTERMSGFAIL = 0x0C
Local Const $CDERR_STRUCTSIZE = 0x01
Local Const $FNERR_BUFFERTOOSMALL = 0x3003
Local Const $FNERR_INVALIDFILENAME = 0x3002
Local Const $FNERR_SUBCLASSFAILURE = 0x3001
Local $aResult = DllCall("comdlg32.dll", "dword", "CommDlgExtendedError")
If Not @error Then
Switch $aResult[0]
Case $CDERR_DIALOGFAILURE
Return SetError($aResult[0], 0, "The dialog box could not be created." & @LF &  "The common dialog box function's call to the DialogBox function failed." & @LF &  "For example, this error occurs if the common dialog box call specifies an invalid window handle.")
Case $CDERR_FINDRESFAILURE
Return SetError($aResult[0], 0, "The common dialog box function failed to find a specified resource.")
Case $CDERR_INITIALIZATION
Return SetError($aResult[0], 0, "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available.")
Case $CDERR_LOADRESFAILURE
Return SetError($aResult[0], 0, "The common dialog box function failed to load a specified resource.")
Case $CDERR_LOADSTRFAILURE
Return SetError($aResult[0], 0, "The common dialog box function failed to load a specified string.")
Case $CDERR_LOCKRESFAILURE
Return SetError($aResult[0], 0, "The common dialog box function failed to lock a specified resource.")
Case $CDERR_MEMALLOCFAILURE
Return SetError($aResult[0], 0, "The common dialog box function was unable to allocate memory for internal structures.")
Case $CDERR_MEMLOCKFAILURE
Return SetError($aResult[0], 0, "The common dialog box function was unable to lock the memory associated with a handle.")
Case $CDERR_NOHINSTANCE
Return SetError($aResult[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF &  "but you failed to provide a corresponding instance handle.")
Case $CDERR_NOHOOK
Return SetError($aResult[0], 0, "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF &  "but you failed to provide a pointer to a corresponding hook procedure.")
Case $CDERR_NOTEMPLATE
Return SetError($aResult[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF &  "but you failed to provide a corresponding template.")
Case $CDERR_REGISTERMSGFAIL
Return SetError($aResult[0], 0, "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.")
Case $CDERR_STRUCTSIZE
Return SetError($aResult[0], 0, "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid")
Case $FNERR_BUFFERTOOSMALL
Return SetError($aResult[0], 0, "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF &  "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name.")
Case $FNERR_INVALIDFILENAME
Return SetError($aResult[0], 0, "A file name is invalid.")
Case $FNERR_SUBCLASSFAILURE
Return SetError($aResult[0], 0, "An attempt to subclass a list box failed because sufficient memory was not available.")
EndSwitch
EndIf
Return SetError(@error, @extended, '0x' & Hex($aResult[0]))
EndFunc
Func _WinAPI_CopyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateBitmap($iWidth, $iHeight, $iPlanes = 1, $iBitsPerPel = 1, $pBits = 0)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateBitmap", "int", $iWidth, "int", $iHeight, "uint", $iPlanes,  "uint", $iBitsPerPel, "struct*", $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hDC, "int", $iWidth, "int", $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleDC($hDC)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateEvent($tAttributes = 0, $bManualReset = True, $bInitialState = True, $sName = "")
Local $sNameType = "wstr"
If $sName = "" Then
$sName = 0
$sNameType = "ptr"
EndIf
Local $aResult = DllCall("kernel32.dll", "handle", "CreateEventW", "struct*", $tAttributes, "bool", $bManualReset,  "bool", $bInitialState, $sNameType, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFile($sFileName, $iCreation, $iAccess = 4, $iShare = 0, $iAttributes = 0, $tSecurity = 0)
Local $iDA = 0, $iSM = 0, $iCD = 0, $iFA = 0
If BitAND($iAccess, 1) <> 0 Then $iDA = BitOR($iDA, $GENERIC_EXECUTE)
If BitAND($iAccess, 2) <> 0 Then $iDA = BitOR($iDA, $GENERIC_READ)
If BitAND($iAccess, 4) <> 0 Then $iDA = BitOR($iDA, $GENERIC_WRITE)
If BitAND($iShare, 1) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_DELETE)
If BitAND($iShare, 2) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_READ)
If BitAND($iShare, 4) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_WRITE)
Switch $iCreation
Case 0
$iCD = $CREATE_NEW
Case 1
$iCD = $CREATE_ALWAYS
Case 2
$iCD = $OPEN_EXISTING
Case 3
$iCD = $OPEN_ALWAYS
Case 4
$iCD = $TRUNCATE_EXISTING
EndSwitch
If BitAND($iAttributes, 1) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_ARCHIVE)
If BitAND($iAttributes, 2) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_HIDDEN)
If BitAND($iAttributes, 4) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_READONLY)
If BitAND($iAttributes, 8) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_SYSTEM)
Local $aResult = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sFileName, "dword", $iDA, "dword", $iSM,  "struct*", $tSecurity, "dword", $iCD, "dword", $iFA, "ptr", 0)
If @error Or ($aResult[0] = $INVALID_HANDLE_VALUE) Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFont($iHeight, $iWidth, $iEscape = 0, $iOrientn = 0, $iWeight = $__WINAPICONSTANT_FW_NORMAL, $bItalic = False, $bUnderline = False, $bStrikeout = False, $iCharset = $__WINAPICONSTANT_DEFAULT_CHARSET, $iOutputPrec = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $iClipPrec = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $iQuality = $__WINAPICONSTANT_DEFAULT_QUALITY, $iPitch = 0, $sFace = 'Arial')
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iHeight, "int", $iWidth, "int", $iEscape,  "int", $iOrientn, "int", $iWeight, "dword", $bItalic, "dword", $bUnderline, "dword", $bStrikeout,  "dword", $iCharset, "dword", $iOutputPrec, "dword", $iClipPrec, "dword", $iQuality, "dword", $iPitch, "wstr", $sFace)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFontIndirect($tLogFont)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tLogFont)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreatePen($iPenStyle, $iWidth, $iColor)
Local $aResult = DllCall("gdi32.dll", "handle", "CreatePen", "int", $iPenStyle, "int", $iWidth, "INT", $iColor)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateProcess($sAppName, $sCommand, $tSecurity, $tThread, $bInherit, $iFlags, $pEnviron, $sDir, $tStartupInfo, $tProcess)
Local $tCommand = 0
Local $sAppNameType = "wstr", $sDirType = "wstr"
If $sAppName = "" Then
$sAppNameType = "ptr"
$sAppName = 0
EndIf
If $sCommand <> "" Then
$tCommand = DllStructCreate("wchar Text[" & 260 + 1 & "]")
DllStructSetData($tCommand, "Text", $sCommand)
EndIf
If $sDir = "" Then
$sDirType = "ptr"
$sDir = 0
EndIf
Local $aResult = DllCall("kernel32.dll", "bool", "CreateProcessW", $sAppNameType, $sAppName, "struct*", $tCommand,  "struct*", $tSecurity, "struct*", $tThread, "bool", $bInherit, "dword", $iFlags, "struct*", $pEnviron, $sDirType, $sDir,  "struct*", $tStartupInfo, "struct*", $tProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateRectRgn($iLeftRect, $iTopRect, $iRightRect, $iBottomRect)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", $iLeftRect, "int", $iTopRect, "int", $iRightRect,  "int", $iBottomRect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateRoundRectRgn($iLeftRect, $iTopRect, $iRightRect, $iBottomRect, $iWidthEllipse, $iHeightEllipse)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $iLeftRect, "int", $iTopRect,  "int", $iRightRect, "int", $iBottomRect, "int", $iWidthEllipse, "int", $iHeightEllipse)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateSolidBitmap($hWnd, $iColor, $iWidth, $iHeight, $bRGB = 1)
Local $hDC = _WinAPI_GetDC($hWnd)
Local $hDestDC = _WinAPI_CreateCompatibleDC($hDC)
Local $hBitmap = _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $hOld = _WinAPI_SelectObject($hDestDC, $hBitmap)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, 0)
DllStructSetData($tRECT, 2, 0)
DllStructSetData($tRECT, 3, $iWidth)
DllStructSetData($tRECT, 4, $iHeight)
If $bRGB Then
$iColor = BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndIf
Local $hBrush = _WinAPI_CreateSolidBrush($iColor)
If Not _WinAPI_FillRect($hDestDC, $tRECT, $hBrush) Then
_WinAPI_DeleteObject($hBitmap)
$hBitmap = 0
EndIf
_WinAPI_DeleteObject($hBrush)
_WinAPI_ReleaseDC($hWnd, $hDC)
_WinAPI_SelectObject($hDestDC, $hOld)
_WinAPI_DeleteDC($hDestDC)
If Not $hBitmap Then Return SetError(1, 0, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateSolidBrush($iColor)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateSolidBrush", "INT", $iColor)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateWindowEx($iExStyle, $sClass, $sName, $iStyle, $iX, $iY, $iWidth, $iHeight, $hParent, $hMenu = 0, $hInstance = 0, $pParam = 0)
If $hInstance = 0 Then $hInstance = _WinAPI_GetModuleHandle("")
Local $aResult = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iExStyle, "wstr", $sClass, "wstr", $sName,  "dword", $iStyle, "int", $iX, "int", $iY, "int", $iWidth, "int", $iHeight, "hwnd", $hParent, "handle", $hMenu,  "handle", $hInstance, "struct*", $pParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DefWindowProc($hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "DefWindowProc", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam,  "lparam", $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteDC($hDC)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteObject($hObject)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawEdge($hDC, $tRECT, $iEdgeType, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "DrawEdge", "handle", $hDC, "struct*", $tRECT, "uint", $iEdgeType,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawFrameControl($hDC, $tRECT, $iType, $iState)
Local $aResult = DllCall("user32.dll", "bool", "DrawFrameControl", "handle", $hDC, "struct*", $tRECT, "uint", $iType,  "uint", $iState)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIcon($hDC, $iX, $iY, $hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIconEx($hDC, $iX, $iY, $hIcon, $iWidth = 0, $iHeight = 0, $iStep = 0, $hBrush = 0, $iFlags = 3)
Local $iOptions
Switch $iFlags
Case 1
$iOptions = $DI_MASK
Case 2
$iOptions = $DI_IMAGE
Case 3
$iOptions = $DI_NORMAL
Case 4
$iOptions = $DI_COMPAT
Case 5
$iOptions = $DI_DEFAULTSIZE
Case Else
$iOptions = $DI_NOMIRROR
EndSwitch
Local $aResult = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon,  "int", $iWidth, "int", $iHeight, "uint", $iStep, "handle", $hBrush, "uint", $iOptions)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawLine($hDC, $iX1, $iY1, $iX2, $iY2)
_WinAPI_MoveTo($hDC, $iX1, $iY1)
If @error Then Return SetError(@error, @extended, False)
_WinAPI_LineTo($hDC, $iX2, $iY2)
If @error Then Return SetError(@error + 10, @extended, False)
Return True
EndFunc
Func _WinAPI_DrawText($hDC, $sText, ByRef $tRECT, $iFlags)
Local $aResult = DllCall("user32.dll", "int", "DrawTextW", "handle", $hDC, "wstr", $sText, "int", -1, "struct*", $tRECT,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DuplicateHandle($hSourceProcessHandle, $hSourceHandle, $hTargetProcessHandle, $iDesiredAccess, $iInheritHandle, $iOptions)
Local $aResult = DllCall("kernel32.dll", "bool", "DuplicateHandle",  "handle", $hSourceProcessHandle,  "handle", $hSourceHandle,  "handle", $hTargetProcessHandle,  "handle*", 0,  "dword", $iDesiredAccess,  "bool", $iInheritHandle,  "dword", $iOptions)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, 0)
Return $aResult[4]
EndFunc
Func _WinAPI_EnableWindow($hWnd, $bEnable = True)
Local $aResult = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hWnd, "bool", $bEnable)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_EnumDisplayDevices($sDevice, $iDevNum)
Local $tName = 0, $iFlags = 0, $aDevice[5]
If $sDevice <> "" Then
$tName = DllStructCreate("wchar Text[" & StringLen($sDevice) + 1 & "]")
DllStructSetData($tName, "Text", $sDevice)
EndIf
Local $tDevice = DllStructCreate($tagDISPLAY_DEVICE)
Local $iDevice = DllStructGetSize($tDevice)
DllStructSetData($tDevice, "Size", $iDevice)
Local $aRet = DllCall("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $tName, "dword", $iDevNum, "struct*", $tDevice, "dword", 1)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $iN = DllStructGetData($tDevice, "Flags")
If BitAND($iN, $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) <> 0 Then $iFlags = BitOR($iFlags, 1)
If BitAND($iN, $DISPLAY_DEVICE_PRIMARY_DEVICE) <> 0 Then $iFlags = BitOR($iFlags, 2)
If BitAND($iN, $DISPLAY_DEVICE_MIRRORING_DRIVER) <> 0 Then $iFlags = BitOR($iFlags, 4)
If BitAND($iN, $DISPLAY_DEVICE_VGA_COMPATIBLE) <> 0 Then $iFlags = BitOR($iFlags, 8)
If BitAND($iN, $DISPLAY_DEVICE_REMOVABLE) <> 0 Then $iFlags = BitOR($iFlags, 16)
If BitAND($iN, $DISPLAY_DEVICE_MODESPRUNED) <> 0 Then $iFlags = BitOR($iFlags, 32)
$aDevice[0] = True
$aDevice[1] = DllStructGetData($tDevice, "Name")
$aDevice[2] = DllStructGetData($tDevice, "String")
$aDevice[3] = $iFlags
$aDevice[4] = DllStructGetData($tDevice, "ID")
Return $aDevice
EndFunc
Func _WinAPI_EnumWindows($bVisible = True, $hWnd = Default)
__WinAPI_EnumWindowsInit()
If $hWnd = Default Then $hWnd = _WinAPI_GetDesktopWindow()
__WinAPI_EnumWindowsChild($hWnd, $bVisible)
Return $__g_aWinList_WinAPI
EndFunc
Func __WinAPI_EnumWindowsAdd($hWnd, $sClass = "")
If $sClass = "" Then $sClass = _WinAPI_GetClassName($hWnd)
$__g_aWinList_WinAPI[0][0] += 1
Local $iCount = $__g_aWinList_WinAPI[0][0]
If $iCount >= $__g_aWinList_WinAPI[0][1] Then
ReDim $__g_aWinList_WinAPI[$iCount + 64][2]
$__g_aWinList_WinAPI[0][1] += 64
EndIf
$__g_aWinList_WinAPI[$iCount][0] = $hWnd
$__g_aWinList_WinAPI[$iCount][1] = $sClass
EndFunc
Func __WinAPI_EnumWindowsChild($hWnd, $bVisible = True)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_CHILD)
While $hWnd <> 0
If (Not $bVisible) Or _WinAPI_IsWindowVisible($hWnd) Then
__WinAPI_EnumWindowsAdd($hWnd)
__WinAPI_EnumWindowsChild($hWnd, $bVisible)
EndIf
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
EndFunc
Func __WinAPI_EnumWindowsInit()
ReDim $__g_aWinList_WinAPI[64][2]
$__g_aWinList_WinAPI[0][0] = 0
$__g_aWinList_WinAPI[0][1] = 64
EndFunc
Func _WinAPI_EnumWindowsPopup()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
Local $sClass
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then
$sClass = _WinAPI_GetClassName($hWnd)
If $sClass = "#32768" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "ToolbarWindow32" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "ToolTips_Class32" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "BaseBar" Then
__WinAPI_EnumWindowsChild($hWnd)
EndIf
EndIf
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_EnumWindowsTop()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then __WinAPI_EnumWindowsAdd($hWnd)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_ExpandEnvironmentStrings($sString)
Local $aResult = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $sString, "wstr", "", "dword", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
Return $aResult[2]
EndFunc
Func _WinAPI_ExtractIconEx($sFilePath, $iIndex, $paLarge, $paSmall, $iIcons)
Local $aResult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sFilePath, "int", $iIndex, "struct*", $paLarge,  "struct*", $paSmall, "uint", $iIcons)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FatalAppExit($sMessage)
DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $sMessage)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_FillRect($hDC, $tRECT, $hBrush)
Local $aResult
If IsPtr($hBrush) Then
$aResult = DllCall("user32.dll", "int", "FillRect", "handle", $hDC, "struct*", $tRECT, "handle", $hBrush)
Else
$aResult = DllCall("user32.dll", "int", "FillRect", "handle", $hDC, "struct*", $tRECT, "dword_ptr", $hBrush)
EndIf
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FindExecutable($sFileName, $sDirectory = "")
Local $aResult = DllCall("shell32.dll", "INT", "FindExecutableW", "wstr", $sFileName, "wstr", $sDirectory, "wstr", "")
If @error Then Return SetError(@error, @extended, '')
If $aResult[0] <= 32 Then Return SetError(10, $aResult[0], '')
Return SetExtended($aResult[0], $aResult[3])
EndFunc
Func _WinAPI_FindWindow($sClassName, $sWindowName)
Local $aResult = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sClassName, "wstr", $sWindowName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FlashWindow($hWnd, $bInvert = True)
Local $aResult = DllCall("user32.dll", "bool", "FlashWindow", "hwnd", $hWnd, "bool", $bInvert)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FlashWindowEx($hWnd, $iFlags = 3, $iCount = 3, $iTimeout = 0)
Local $tFlash = DllStructCreate($tagFLASHWINFO)
Local $iFlash = DllStructGetSize($tFlash)
Local $iMode = 0
If BitAND($iFlags, 1) <> 0 Then $iMode = BitOR($iMode, $FLASHW_CAPTION)
If BitAND($iFlags, 2) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TRAY)
If BitAND($iFlags, 4) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TIMER)
If BitAND($iFlags, 8) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TIMERNOFG)
DllStructSetData($tFlash, "Size", $iFlash)
DllStructSetData($tFlash, "hWnd", $hWnd)
DllStructSetData($tFlash, "Flags", $iMode)
DllStructSetData($tFlash, "Count", $iCount)
DllStructSetData($tFlash, "Timeout", $iTimeout)
Local $aResult = DllCall("user32.dll", "bool", "FlashWindowEx", "struct*", $tFlash)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FloatToInt($nFloat)
Local $tFloat = DllStructCreate("float")
Local $tInt = DllStructCreate("int", DllStructGetPtr($tFloat))
DllStructSetData($tFloat, 1, $nFloat)
Return DllStructGetData($tInt, 1)
EndFunc
Func _WinAPI_FlushFileBuffers($hFile)
Local $aResult = DllCall("kernel32.dll", "bool", "FlushFileBuffers", "handle", $hFile)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FormatMessage($iFlags, $pSource, $iMessageID, $iLanguageID, ByRef $pBuffer, $iSize, $vArguments)
Local $sBufferType = "struct*"
If IsString($pBuffer) Then $sBufferType = "wstr"
Local $aResult = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", $iFlags, "struct*", $pSource, "dword", $iMessageID,  "dword", $iLanguageID, $sBufferType, $pBuffer, "dword", $iSize, "ptr", $vArguments)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
If $sBufferType = "wstr" Then $pBuffer = $aResult[5]
Return $aResult[0]
EndFunc
Func _WinAPI_FrameRect($hDC, $tRECT, $hBrush)
Local $aResult = DllCall("user32.dll", "int", "FrameRect", "handle", $hDC, "struct*", $tRECT, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FreeLibrary($hModule)
Local $aResult = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hModule)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetAncestor($hWnd, $iFlags = 1)
Local $aResult = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hWnd, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetAsyncKeyState($iKey)
Local $aResult = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", $iKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetBkMode($hDC)
Local $aResult = DllCall("gdi32.dll", "int", "GetBkMode", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClassName($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, '')
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_GetClientHeight($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetClientWidth($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_GetClientRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentProcessID()
Local $aResult = DllCall("kernel32.dll", "dword", "GetCurrentProcessId")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentThread()
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentThreadId()
Local $aResult = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCursorInfo()
Local $tCursor = DllStructCreate($tagCURSORINFO)
Local $iCursor = DllStructGetSize($tCursor)
DllStructSetData($tCursor, "Size", $iCursor)
Local $aRet = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tCursor)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aCursor[5]
$aCursor[0] = True
$aCursor[1] = DllStructGetData($tCursor, "Flags") <> 0
$aCursor[2] = DllStructGetData($tCursor, "hCursor")
$aCursor[3] = DllStructGetData($tCursor, "X")
$aCursor[4] = DllStructGetData($tCursor, "Y")
Return $aCursor
EndFunc
Func _WinAPI_GetDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDesktopWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDeviceCaps($hDC, $iIndex)
Local $aResult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDIBits($hDC, $hBitmap, $iStartScan, $iScanLines, $pBits, $tBI, $iUsage)
Local $aResult = DllCall("gdi32.dll", "int", "GetDIBits", "handle", $hDC, "handle", $hBitmap, "uint", $iStartScan,  "uint", $iScanLines, "struct*", $pBits, "struct*", $tBI, "uint", $iUsage)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDlgCtrlID($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDlgItem($hWnd, $iItemID)
Local $aResult = DllCall("user32.dll", "hwnd", "GetDlgItem", "hwnd", $hWnd, "int", $iItemID)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetFileSizeEx($hFile)
Local $aResult = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hFile, "int64*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, -1)
Return $aResult[2]
EndFunc
Func _WinAPI_GetFocus()
Local $aResult = DllCall("user32.dll", "hwnd", "GetFocus")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetForegroundWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetGuiResources($iFlag = 0, $hProcess = -1)
If $hProcess = -1 Then $hProcess = _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hProcess, "dword", $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetIconInfo($hIcon)
Local $tInfo = DllStructCreate($tagICONINFO)
Local $aRet = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hIcon, "struct*", $tInfo)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aIcon[6]
$aIcon[0] = True
$aIcon[1] = DllStructGetData($tInfo, "Icon") <> 0
$aIcon[2] = DllStructGetData($tInfo, "XHotSpot")
$aIcon[3] = DllStructGetData($tInfo, "YHotSpot")
$aIcon[4] = DllStructGetData($tInfo, "hMask")
$aIcon[5] = DllStructGetData($tInfo, "hColor")
Return $aIcon
EndFunc
Func _WinAPI_GetLastErrorMessage()
Local $iLastError = _WinAPI_GetLastError()
Local $tBufferPtr = DllStructCreate("ptr")
Local $nCount = _WinAPI_FormatMessage(BitOR($FORMAT_MESSAGE_ALLOCATE_BUFFER, $FORMAT_MESSAGE_FROM_SYSTEM),  0, $iLastError, 0, $tBufferPtr, 0, 0)
If @error Then Return SetError(@error, 0, "")
Local $sText = ""
Local $pBuffer = DllStructGetData($tBufferPtr, 1)
If $pBuffer Then
If $nCount > 0 Then
Local $tBuffer = DllStructCreate("wchar[" & ($nCount + 1) & "]", $pBuffer)
$sText = DllStructGetData($tBuffer, 1)
If StringRight($sText, 2) = @CRLF Then $sText = StringTrimRight($sText, 2)
EndIf
_WinAPI_LocalFree($pBuffer)
EndIf
Return $sText
EndFunc
Func _WinAPI_GetLayeredWindowAttributes($hWnd, ByRef $iTransColor, ByRef $iTransGUI, $bColorRef = False)
$iTransColor = -1
$iTransGUI = -1
Local $aResult = DllCall("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $hWnd, "INT*", $iTransColor,  "byte*", $iTransGUI, "dword*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, 0)
If Not $bColorRef Then
$aResult[2] = Int(BinaryMid($aResult[2], 3, 1) & BinaryMid($aResult[2], 2, 1) & BinaryMid($aResult[2], 1, 1))
EndIf
$iTransColor = $aResult[2]
$iTransGUI = $aResult[3]
Return $aResult[4]
EndFunc
Func _WinAPI_GetModuleHandle($sModuleName)
Local $sModuleNameType = "wstr"
If $sModuleName = "" Then
$sModuleName = 0
$sModuleNameType = "ptr"
EndIf
Local $aResult = DllCall("kernel32.dll", "handle", "GetModuleHandleW", $sModuleNameType, $sModuleName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetMousePos($bToClient = False, $hWnd = 0)
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
If $bToClient And Not _WinAPI_ScreenToClient($hWnd, $tPoint) Then Return SetError(@error + 20, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_GetMousePosX($bToClient = False, $hWnd = 0)
Local $tPoint = _WinAPI_GetMousePos($bToClient, $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPoint, "X")
EndFunc
Func _WinAPI_GetMousePosY($bToClient = False, $hWnd = 0)
Local $tPoint = _WinAPI_GetMousePos($bToClient, $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_GetObject($hObject, $iSize, $pObject)
Local $aResult = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hObject, "int", $iSize, "struct*", $pObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetOpenFileName($sTitle = "", $sFilter = "All files (*.*)", $sInitalDir = ".", $sDefaultFile = "", $sDefaultExt = "", $iFilterIndex = 1, $iFlags = 0, $iFlagsEx = 0, $hWndOwner = 0)
Local $iPathLen = 4096
Local $iNulls = 0
Local $tOFN = DllStructCreate($tagOPENFILENAME)
Local $aFiles[1] = [0]
Local $iFlag = $iFlags
Local $asFLines = StringSplit($sFilter, "|")
Local $asFilter[$asFLines[0] * 2 + 1]
Local $iStart, $iFinal, $tagFilter
$asFilter[0] = $asFLines[0] * 2
For $i = 1 To $asFLines[0]
$iStart = StringInStr($asFLines[$i], "(", 0, 1)
$iFinal = StringInStr($asFLines[$i], ")", 0, -1)
$asFilter[$i * 2 - 1] = StringStripWS(StringLeft($asFLines[$i], $iStart - 1), $STR_STRIPLEADING + $STR_STRIPTRAILING)
$asFilter[$i * 2] = StringStripWS(StringTrimRight(StringTrimLeft($asFLines[$i], $iStart), StringLen($asFLines[$i]) - $iFinal + 1), $STR_STRIPLEADING + $STR_STRIPTRAILING)
$tagFilter &= "wchar[" & StringLen($asFilter[$i * 2 - 1]) + 1 & "];wchar[" & StringLen($asFilter[$i * 2]) + 1 & "];"
Next
Local $tTitle = DllStructCreate("wchar Title[" & StringLen($sTitle) + 1 & "]")
Local $tInitialDir = DllStructCreate("wchar InitDir[" & StringLen($sInitalDir) + 1 & "]")
Local $tFilter = DllStructCreate($tagFilter & "wchar")
Local $tPath = DllStructCreate("wchar Path[" & $iPathLen & "]")
Local $tExtn = DllStructCreate("wchar Extension[" & StringLen($sDefaultExt) + 1 & "]")
For $i = 1 To $asFilter[0]
DllStructSetData($tFilter, $i, $asFilter[$i])
Next
DllStructSetData($tTitle, "Title", $sTitle)
DllStructSetData($tInitialDir, "InitDir", $sInitalDir)
DllStructSetData($tPath, "Path", $sDefaultFile)
DllStructSetData($tExtn, "Extension", $sDefaultExt)
DllStructSetData($tOFN, "StructSize", DllStructGetSize($tOFN))
DllStructSetData($tOFN, "hwndOwner", $hWndOwner)
DllStructSetData($tOFN, "lpstrFilter", DllStructGetPtr($tFilter))
DllStructSetData($tOFN, "nFilterIndex", $iFilterIndex)
DllStructSetData($tOFN, "lpstrFile", DllStructGetPtr($tPath))
DllStructSetData($tOFN, "nMaxFile", $iPathLen)
DllStructSetData($tOFN, "lpstrInitialDir", DllStructGetPtr($tInitialDir))
DllStructSetData($tOFN, "lpstrTitle", DllStructGetPtr($tTitle))
DllStructSetData($tOFN, "Flags", $iFlag)
DllStructSetData($tOFN, "lpstrDefExt", DllStructGetPtr($tExtn))
DllStructSetData($tOFN, "FlagsEx", $iFlagsEx)
Local $aRes = DllCall("comdlg32.dll", "bool", "GetOpenFileNameW", "struct*", $tOFN)
If @error Or Not $aRes[0] Then Return SetError(@error + 10, @extended, $aFiles)
If BitAND($iFlags, $OFN_ALLOWMULTISELECT) = $OFN_ALLOWMULTISELECT And BitAND($iFlags, $OFN_EXPLORER) = $OFN_EXPLORER Then
For $x = 1 To $iPathLen
If DllStructGetData($tPath, "Path", $x) = Chr(0) Then
DllStructSetData($tPath, "Path", "|", $x)
$iNulls += 1
Else
$iNulls = 0
EndIf
If $iNulls = 2 Then ExitLoop
Next
DllStructSetData($tPath, "Path", Chr(0), $x - 1)
$aFiles = StringSplit(DllStructGetData($tPath, "Path"), "|")
If $aFiles[0] = 1 Then Return __WinAPI_ParseFileDialogPath(DllStructGetData($tPath, "Path"))
Return StringSplit(DllStructGetData($tPath, "Path"), "|")
ElseIf BitAND($iFlags, $OFN_ALLOWMULTISELECT) = $OFN_ALLOWMULTISELECT Then
$aFiles = StringSplit(DllStructGetData($tPath, "Path"), " ")
If $aFiles[0] = 1 Then Return __WinAPI_ParseFileDialogPath(DllStructGetData($tPath, "Path"))
Return StringSplit(StringReplace(DllStructGetData($tPath, "Path"), " ", "|"), "|")
Else
Return __WinAPI_ParseFileDialogPath(DllStructGetData($tPath, "Path"))
EndIf
EndFunc
Func _WinAPI_GetOverlappedResult($hFile, $tOverlapped, ByRef $iBytes, $bWait = False)
Local $aResult = DllCall("kernel32.dll", "bool", "GetOverlappedResult", "handle", $hFile, "struct*", $tOverlapped, "dword*", 0,  "bool", $bWait)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, False)
$iBytes = $aResult[3]
Return $aResult[0]
EndFunc
Func _WinAPI_GetParent($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetProcAddress($hModule, $vName)
Local $sType = "str"
If IsNumber($vName) Then $sType = "word"
Local $aResult = DllCall("kernel32.dll", "ptr", "GetProcAddress", "handle", $hModule, $sType, $vName)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetProcessAffinityMask($hProcess)
Local $aResult = DllCall("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $hProcess, "dword_ptr*", 0, "dword_ptr*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Local $aMask[3]
$aMask[0] = True
$aMask[1] = $aResult[2]
$aMask[2] = $aResult[3]
Return $aMask
EndFunc
Func _WinAPI_GetSaveFileName($sTitle = "", $sFilter = "All files (*.*)", $sInitalDir = ".", $sDefaultFile = "", $sDefaultExt = "", $iFilterIndex = 1, $iFlags = 0, $iFlagsEx = 0, $hWndOwner = 0)
Local $iPathLen = 4096
Local $tOFN = DllStructCreate($tagOPENFILENAME)
Local $aFiles[1] = [0]
Local $iFlag = $iFlags
Local $asFLines = StringSplit($sFilter, "|")
Local $asFilter[$asFLines[0] * 2 + 1]
Local $iStart, $iFinal, $tagFilter
$asFilter[0] = $asFLines[0] * 2
For $i = 1 To $asFLines[0]
$iStart = StringInStr($asFLines[$i], "(", 0, 1)
$iFinal = StringInStr($asFLines[$i], ")", 0, -1)
$asFilter[$i * 2 - 1] = StringStripWS(StringLeft($asFLines[$i], $iStart - 1), $STR_STRIPLEADING + $STR_STRIPTRAILING)
$asFilter[$i * 2] = StringStripWS(StringTrimRight(StringTrimLeft($asFLines[$i], $iStart), StringLen($asFLines[$i]) - $iFinal + 1), $STR_STRIPLEADING + $STR_STRIPTRAILING)
$tagFilter &= "wchar[" & StringLen($asFilter[$i * 2 - 1]) + 1 & "];wchar[" & StringLen($asFilter[$i * 2]) + 1 & "];"
Next
Local $tTitle = DllStructCreate("wchar Title[" & StringLen($sTitle) + 1 & "]")
Local $tInitialDir = DllStructCreate("wchar InitDir[" & StringLen($sInitalDir) + 1 & "]")
Local $tFilter = DllStructCreate($tagFilter & "wchar")
Local $tPath = DllStructCreate("wchar Path[" & $iPathLen & "]")
Local $tExtn = DllStructCreate("wchar Extension[" & StringLen($sDefaultExt) + 1 & "]")
For $i = 1 To $asFilter[0]
DllStructSetData($tFilter, $i, $asFilter[$i])
Next
DllStructSetData($tTitle, "Title", $sTitle)
DllStructSetData($tInitialDir, "InitDir", $sInitalDir)
DllStructSetData($tPath, "Path", $sDefaultFile)
DllStructSetData($tExtn, "Extension", $sDefaultExt)
DllStructSetData($tOFN, "StructSize", DllStructGetSize($tOFN))
DllStructSetData($tOFN, "hwndOwner", $hWndOwner)
DllStructSetData($tOFN, "lpstrFilter", DllStructGetPtr($tFilter))
DllStructSetData($tOFN, "nFilterIndex", $iFilterIndex)
DllStructSetData($tOFN, "lpstrFile", DllStructGetPtr($tPath))
DllStructSetData($tOFN, "nMaxFile", $iPathLen)
DllStructSetData($tOFN, "lpstrInitialDir", DllStructGetPtr($tInitialDir))
DllStructSetData($tOFN, "lpstrTitle", DllStructGetPtr($tTitle))
DllStructSetData($tOFN, "Flags", $iFlag)
DllStructSetData($tOFN, "lpstrDefExt", DllStructGetPtr($tExtn))
DllStructSetData($tOFN, "FlagsEx", $iFlagsEx)
Local $aRes = DllCall("comdlg32.dll", "bool", "GetSaveFileNameW", "struct*", $tOFN)
If @error Or Not $aRes[0] Then Return SetError(@error + 10, @extended, $aFiles)
Return __WinAPI_ParseFileDialogPath(DllStructGetData($tPath, "Path"))
EndFunc
Func _WinAPI_GetStockObject($iObject)
Local $aResult = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetStdHandle($iStdHandle)
If $iStdHandle < 0 Or $iStdHandle > 2 Then Return SetError(2, 0, -1)
Local Const $aHandle[3] = [-10, -11, -12]
Local $aResult = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $aHandle[$iStdHandle])
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSysColor($iIndex)
Local $aResult = DllCall("user32.dll", "INT", "GetSysColor", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSysColorBrush($iIndex)
Local $aResult = DllCall("user32.dll", "handle", "GetSysColorBrush", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSystemMetrics($iIndex)
Local $aResult = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetTextExtentPoint32($hDC, $sText)
Local $tSize = DllStructCreate($tagSIZE)
Local $iSize = StringLen($sText)
Local $aRet = DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $sText, "int", $iSize, "struct*", $tSize)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSize
EndFunc
Func _WinAPI_GetTextMetrics($hDC)
Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetTextMetricsW', 'handle', $hDC, 'struct*', $tTEXTMETRIC)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tTEXTMETRIC
EndFunc
Func _WinAPI_GetWindow($hWnd, $iCmd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hWnd, "uint", $iCmd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowHeight($hWnd)
Local $tRECT = _WinAPI_GetWindowRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetWindowLong($hWnd, $iIndex)
Local $sFuncName = "GetWindowLongW"
If @AutoItX64 Then $sFuncName = "GetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowPlacement($hWnd)
Local $tWindowPlacement = DllStructCreate($tagWINDOWPLACEMENT)
DllStructSetData($tWindowPlacement, "length", DllStructGetSize($tWindowPlacement))
Local $aRet = DllCall("user32.dll", "bool", "GetWindowPlacement", "hwnd", $hWnd, "struct*", $tWindowPlacement)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWindowPlacement
EndFunc
Func _WinAPI_GetWindowRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall("user32.dll", "bool", "GetWindowRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetWindowRgn($hWnd, $hRgn)
Local $aResult = DllCall("user32.dll", "int", "GetWindowRgn", "hwnd", $hWnd, "handle", $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowText($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetWindowTextW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_GetWindowThreadProcessId($hWnd, ByRef $iPID)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error, @extended, 0)
$iPID = $aResult[2]
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowWidth($hWnd)
Local $tRECT = _WinAPI_GetWindowRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_GetXYFromPoint(ByRef $tPoint, ByRef $iX, ByRef $iY)
$iX = DllStructGetData($tPoint, "X")
$iY = DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_GlobalMemoryStatus()
Local $tMem = DllStructCreate($tagMEMORYSTATUSEX)
DllStructSetData($tMem, 1, DllStructGetSize($tMem))
Local $aRet = DllCall("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $tMem)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aMem[7]
$aMem[0] = DllStructGetData($tMem, 2)
$aMem[1] = DllStructGetData($tMem, 3)
$aMem[2] = DllStructGetData($tMem, 4)
$aMem[3] = DllStructGetData($tMem, 5)
$aMem[4] = DllStructGetData($tMem, 6)
$aMem[5] = DllStructGetData($tMem, 7)
$aMem[6] = DllStructGetData($tMem, 8)
Return $aMem
EndFunc
Func _WinAPI_GUIDFromString($sGUID)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_GUIDFromStringEx($sGUID, $tGUID)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $tGUID
EndFunc
Func _WinAPI_GUIDFromStringEx($sGUID, $tGUID)
Local $aResult = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sGUID, "struct*", $tGUID)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_HiWord($iLong)
Return BitShift($iLong, 16)
EndFunc
Func _WinAPI_InProcess($hWnd, ByRef $hLastWnd)
If $hWnd = $hLastWnd Then Return True
For $iI = $__g_aInProcess_WinAPI[0][0] To 1 Step -1
If $hWnd = $__g_aInProcess_WinAPI[$iI][0] Then
If $__g_aInProcess_WinAPI[$iI][1] Then
$hLastWnd = $hWnd
Return True
Else
Return False
EndIf
EndIf
Next
Local $iPID
_WinAPI_GetWindowThreadProcessId($hWnd, $iPID)
Local $iCount = $__g_aInProcess_WinAPI[0][0] + 1
If $iCount >= 64 Then $iCount = 1
$__g_aInProcess_WinAPI[0][0] = $iCount
$__g_aInProcess_WinAPI[$iCount][0] = $hWnd
$__g_aInProcess_WinAPI[$iCount][1] = ($iPID = @AutoItPID)
Return $__g_aInProcess_WinAPI[$iCount][1]
EndFunc
Func _WinAPI_IntToFloat($iInt)
Local $tInt = DllStructCreate("int")
Local $tFloat = DllStructCreate("float", DllStructGetPtr($tInt))
DllStructSetData($tInt, 1, $iInt)
Return DllStructGetData($tFloat, 1)
EndFunc
Func _WinAPI_IsClassName($hWnd, $sClassName)
Local $sSeparator = Opt("GUIDataSeparatorChar")
Local $aClassName = StringSplit($sClassName, $sSeparator)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sClassCheck = _WinAPI_GetClassName($hWnd)
For $x = 1 To UBound($aClassName) - 1
If StringUpper(StringMid($sClassCheck, 1, StringLen($aClassName[$x]))) = StringUpper($aClassName[$x]) Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_IsWindowVisible($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_InvalidateRect($hWnd, $tRECT = 0, $bErase = True)
Local $aResult = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hWnd, "struct*", $tRECT, "bool", $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_LineTo($hDC, $iX, $iY)
Local $aResult = DllCall("gdi32.dll", "bool", "LineTo", "handle", $hDC, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadBitmap($hInstance, $sBitmap)
Local $sBitmapType = "int"
If IsString($sBitmap) Then $sBitmapType = "wstr"
Local $aResult = DllCall("user32.dll", "handle", "LoadBitmapW", "handle", $hInstance, $sBitmapType, $sBitmap)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadImage($hInstance, $sImage, $iType, $iXDesired, $iYDesired, $iLoad)
Local $aResult, $sImageType = "int"
If IsString($sImage) Then $sImageType = "wstr"
$aResult = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hInstance, $sImageType, $sImage, "uint", $iType,  "int", $iXDesired, "int", $iYDesired, "uint", $iLoad)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadLibrary($sFileName)
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sFileName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadLibraryEx($sFileName, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sFileName, "ptr", 0, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadShell32Icon($iIconID)
Local $tIcons = DllStructCreate("ptr Data")
Local $iIcons = _WinAPI_ExtractIconEx("shell32.dll", $iIconID, 0, $tIcons, 1)
If @error Then Return SetError(@error, @extended, 0)
If $iIcons <= 0 Then Return SetError(10, 0, 0)
Return DllStructGetData($tIcons, "Data")
EndFunc
Func _WinAPI_LoadString($hInstance, $iStringID)
Local $aResult = DllCall("user32.dll", "int", "LoadStringW", "handle", $hInstance, "uint", $iStringID, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
Return SetExtended($aResult[0], $aResult[3])
EndFunc
Func _WinAPI_LocalFree($hMemory)
Local $aResult = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_LoWord($iLong)
Return BitAND($iLong, 0xFFFF)
EndFunc
Func _WinAPI_MAKELANGID($iLngIDPrimary, $iLngIDSub)
Return BitOR(BitShift($iLngIDSub, -10), $iLngIDPrimary)
EndFunc
Func _WinAPI_MAKELCID($iLngID, $iSortID)
Return BitOR(BitShift($iSortID, -16), $iLngID)
EndFunc
Func _WinAPI_MakeLong($iLo, $iHi)
Return BitOR(BitShift($iHi, -16), BitAND($iLo, 0xFFFF))
EndFunc
Func _WinAPI_MakeQWord($iLoDWORD, $iHiDWORD)
Local $tInt64 = DllStructCreate("uint64")
Local $tDwords = DllStructCreate("dword;dword", DllStructGetPtr($tInt64))
DllStructSetData($tDwords, 1, $iLoDWORD)
DllStructSetData($tDwords, 2, $iHiDWORD)
Return DllStructGetData($tInt64, 1)
EndFunc
Func _WinAPI_MessageBeep($iType = 1)
Local $iSound
Switch $iType
Case 1
$iSound = 0
Case 2
$iSound = 16
Case 3
$iSound = 32
Case 4
$iSound = 48
Case 5
$iSound = 64
Case Else
$iSound = -1
EndSwitch
Local $aResult = DllCall("user32.dll", "bool", "MessageBeep", "uint", $iSound)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_MsgBox($iFlags, $sTitle, $sText)
BlockInput(0)
MsgBox($iFlags, $sTitle, $sText & "      ")
EndFunc
Func _WinAPI_Mouse_Event($iFlags, $iX = 0, $iY = 0, $iData = 0, $iExtraInfo = 0)
DllCall("user32.dll", "none", "mouse_event", "dword", $iFlags, "dword", $iX, "dword", $iY, "dword", $iData,  "ulong_ptr", $iExtraInfo)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_MoveTo($hDC, $iX, $iY)
Local $aResult = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hDC, "int", $iX, "int", $iY, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_MoveWindow($hWnd, $iX, $iY, $iWidth, $iHeight, $bRepaint = True)
Local $aResult = DllCall("user32.dll", "bool", "MoveWindow", "hwnd", $hWnd, "int", $iX, "int", $iY, "int", $iWidth,  "int", $iHeight, "bool", $bRepaint)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_MulDiv($iNumber, $iNumerator, $iDenominator)
Local $aResult = DllCall("kernel32.dll", "int", "MulDiv", "int", $iNumber, "int", $iNumerator, "int", $iDenominator)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_MultiByteToWideChar($vText, $iCodePage = 0, $iFlags = 0, $bRetString = False)
Local $sTextType = "str"
If Not IsString($vText) Then $sTextType = "struct*"
Local $aResult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags,  $sTextType, $vText, "int", -1, "ptr", 0, "int", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Local $iOut = $aResult[0]
Local $tOut = DllStructCreate("wchar[" & $iOut & "]")
$aResult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags, $sTextType, $vText,  "int", -1, "struct*", $tOut, "int", $iOut)
If @error Or Not $aResult[0] Then Return SetError(@error + 20, @extended, 0)
If $bRetString Then Return DllStructGetData($tOut, 1)
Return $tOut
EndFunc
Func _WinAPI_MultiByteToWideCharEx($sText, $pText, $iCodePage = 0, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags, "STR", $sText,  "int", -1, "struct*", $pText, "int", (StringLen($sText) + 1) * 2)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
_WinAPI_CloseHandle($hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Func __WinAPI_ParseFileDialogPath($sPath)
Local $aFiles[3]
$aFiles[0] = 2
Local $sTemp = StringMid($sPath, 1, StringInStr($sPath, "\", 0, -1) - 1)
$aFiles[1] = $sTemp
$aFiles[2] = StringMid($sPath, StringInStr($sPath, "\", 0, -1) + 1)
Return $aFiles
EndFunc
Func _WinAPI_PathFindOnPath(Const $sFilePath, $aExtraPaths = "", Const $sPathDelimiter = @LF)
Local $iExtraCount = 0
If IsString($aExtraPaths) Then
If StringLen($aExtraPaths) Then
$aExtraPaths = StringSplit($aExtraPaths, $sPathDelimiter, $STR_ENTIRESPLIT + $STR_NOCOUNT)
$iExtraCount = UBound($aExtraPaths, $UBOUND_ROWS)
EndIf
ElseIf IsArray($aExtraPaths) Then
$iExtraCount = UBound($aExtraPaths)
EndIf
Local $tPaths, $tPathPtrs
If $iExtraCount Then
Local $tagStruct = ""
For $path In $aExtraPaths
$tagStruct &= "wchar[" & StringLen($path) + 1 & "];"
Next
$tPaths = DllStructCreate($tagStruct)
$tPathPtrs = DllStructCreate("ptr[" & $iExtraCount + 1 & "]")
For $i = 1 To $iExtraCount
DllStructSetData($tPaths, $i, $aExtraPaths[$i - 1])
DllStructSetData($tPathPtrs, 1, DllStructGetPtr($tPaths, $i), $i)
Next
DllStructSetData($tPathPtrs, 1, Ptr(0), $iExtraCount + 1)
EndIf
Local $aResult = DllCall("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $sFilePath, "struct*", $tPathPtrs)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, $sFilePath)
Return $aResult[1]
EndFunc
Func _WinAPI_PointFromRect(ByRef $tRECT, $bCenter = True)
Local $iX1 = DllStructGetData($tRECT, "Left")
Local $iY1 = DllStructGetData($tRECT, "Top")
Local $iX2 = DllStructGetData($tRECT, "Right")
Local $iY2 = DllStructGetData($tRECT, "Bottom")
If $bCenter Then
$iX1 = $iX1 + (($iX2 - $iX1) / 2)
$iY1 = $iY1 + (($iY2 - $iY1) / 2)
EndIf
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iX1)
DllStructSetData($tPoint, "Y", $iY1)
Return $tPoint
EndFunc
Func _WinAPI_PostMessage($hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam,  "lparam", $lParam)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_PrimaryLangId($iLngID)
Return BitAND($iLngID, 0x3FF)
EndFunc
Func _WinAPI_PtInRect(ByRef $tRECT, ByRef $tPoint)
Local $aResult = DllCall("user32.dll", "bool", "PtInRect", "struct*", $tRECT, "struct", $tPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ReadFile($hFile, $pBuffer, $iToRead, ByRef $iRead, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToRead,  "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aResult[4]
Return $aResult[0]
EndFunc
Func _WinAPI_ReadProcessMemory($hProcess, $pBaseAddress, $pBuffer, $iSize, ByRef $iRead)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hProcess,  "ptr", $pBaseAddress, "struct*", $pBuffer, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aResult[5]
Return $aResult[0]
EndFunc
Func _WinAPI_RectIsEmpty(ByRef $tRECT)
Return (DllStructGetData($tRECT, "Left") = 0) And (DllStructGetData($tRECT, "Top") = 0) And  (DllStructGetData($tRECT, "Right") = 0) And (DllStructGetData($tRECT, "Bottom") = 0)
EndFunc
Func _WinAPI_RedrawWindow($hWnd, $tRECT = 0, $hRegion = 0, $iFlags = 5)
Local $aResult = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hWnd, "struct*", $tRECT, "handle", $hRegion,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RegisterWindowMessage($sMessage)
Local $aResult = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $sMessage)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_ReleaseCapture()
Local $aResult = DllCall("user32.dll", "bool", "ReleaseCapture")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ReleaseDC($hWnd, $hDC)
Local $aResult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ScreenToClient($hWnd, ByRef $tPoint)
Local $aResult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SelectObject($hDC, $hGDIObj)
Local $aResult = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hGDIObj)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetBkColor($hDC, $iColor)
Local $aResult = DllCall("gdi32.dll", "INT", "SetBkColor", "handle", $hDC, "INT", $iColor)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_SetBkMode($hDC, $iBkMode)
Local $aResult = DllCall("gdi32.dll", "int", "SetBkMode", "handle", $hDC, "int", $iBkMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetCapture($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "SetCapture", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetCursor($hCursor)
Local $aResult = DllCall("user32.dll", "handle", "SetCursor", "handle", $hCursor)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetDefaultPrinter($sPrinter)
Local $aResult = DllCall("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $sPrinter)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetDIBits($hDC, $hBitmap, $iStartScan, $iScanLines, $pBits, $tBMI, $iColorUse = 0)
Local $aResult = DllCall("gdi32.dll", "int", "SetDIBits", "handle", $hDC, "handle", $hBitmap, "uint", $iStartScan,  "uint", $iScanLines, "struct*", $pBits, "struct*", $tBMI, "INT", $iColorUse)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetEndOfFile($hFile)
Local $aResult = DllCall("kernel32.dll", "bool", "SetEndOfFile", "handle", $hFile)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetEvent($hEvent)
Local $aResult = DllCall("kernel32.dll", "bool", "SetEvent", "handle", $hEvent)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFilePointer($hFile, $iPos, $iMethod = 0)
Local $aResult = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hFile, "long", $iPos, "ptr", 0, "long", $iMethod)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFocus($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFont($hWnd, $hFont, $bRedraw = True)
_SendMessage($hWnd, $__WINAPICONSTANT_WM_SETFONT, $hFont, $bRedraw, 0, "hwnd")
EndFunc
Func _WinAPI_SetHandleInformation($hObject, $iMask, $iFlags)
Local $aResult = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hObject, "dword", $iMask, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetLayeredWindowAttributes($hWnd, $iTransColor, $iTransGUI = 255, $iFlags = 0x03, $bColorRef = False)
If $iFlags = Default Or $iFlags = "" Or $iFlags < 0 Then $iFlags = 0x03
If Not $bColorRef Then
$iTransColor = Int(BinaryMid($iTransColor, 3, 1) & BinaryMid($iTransColor, 2, 1) & BinaryMid($iTransColor, 1, 1))
EndIf
Local $aResult = DllCall("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $hWnd, "INT", $iTransColor,  "byte", $iTransGUI, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetParent($hWndChild, $hWndParent)
Local $aResult = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hWndChild, "hwnd", $hWndParent)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetProcessAffinityMask($hProcess, $iMask)
Local $aResult = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hProcess, "ulong_ptr", $iMask)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetSysColors($vElements, $vColors)
Local $bIsEArray = IsArray($vElements), $bIsCArray = IsArray($vColors)
Local $iElementNum
If Not $bIsCArray And Not $bIsEArray Then
$iElementNum = 1
ElseIf $bIsCArray Or $bIsEArray Then
If Not $bIsCArray Or Not $bIsEArray Then Return SetError(-1, -1, False)
If UBound($vElements) <> UBound($vColors) Then Return SetError(-1, -1, False)
$iElementNum = UBound($vElements)
EndIf
Local $tElements = DllStructCreate("int Element[" & $iElementNum & "]")
Local $tColors = DllStructCreate("INT NewColor[" & $iElementNum & "]")
If Not $bIsEArray Then
DllStructSetData($tElements, "Element", $vElements, 1)
Else
For $x = 0 To $iElementNum - 1
DllStructSetData($tElements, "Element", $vElements[$x], $x + 1)
Next
EndIf
If Not $bIsCArray Then
DllStructSetData($tColors, "NewColor", $vColors, 1)
Else
For $x = 0 To $iElementNum - 1
DllStructSetData($tColors, "NewColor", $vColors[$x], $x + 1)
Next
EndIf
Local $aResult = DllCall("user32.dll", "bool", "SetSysColors", "int", $iElementNum, "struct*", $tElements, "struct*", $tColors)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetTextColor($hDC, $iColor)
Local $aResult = DllCall("gdi32.dll", "INT", "SetTextColor", "handle", $hDC, "INT", $iColor)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowLong($hWnd, $iIndex, $iValue)
_WinAPI_SetLastError(0)
Local $sFuncName = "SetWindowLongW"
If @AutoItX64 Then $sFuncName = "SetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex, "long_ptr", $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowPlacement($hWnd, $tWindowPlacement)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowPlacement", "hwnd", $hWnd, "struct*", $tWindowPlacement)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowPos($hWnd, $hAfter, $iX, $iY, $iCX, $iCY, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hWnd, "hwnd", $hAfter, "int", $iX, "int", $iY,  "int", $iCX, "int", $iCY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowRgn($hWnd, $hRgn, $bRedraw = True)
Local $aResult = DllCall("user32.dll", "int", "SetWindowRgn", "hwnd", $hWnd, "handle", $hRgn, "bool", $bRedraw)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowsHookEx($iHook, $pProc, $hDll, $iThreadId = 0)
Local $aResult = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $iHook, "ptr", $pProc, "handle", $hDll,  "dword", $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowText($hWnd, $sText)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hWnd, "wstr", $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShowCursor($bShow)
Local $aResult = DllCall("user32.dll", "int", "ShowCursor", "bool", $bShow)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_ShowError($sText, $bExit = True)
_WinAPI_MsgBox($MB_SYSTEMMODAL, "Error", $sText)
If $bExit Then Exit
EndFunc
Func _WinAPI_ShowMsg($sText)
_WinAPI_MsgBox($MB_SYSTEMMODAL, "Information", $sText)
EndFunc
Func _WinAPI_ShowWindow($hWnd, $iCmdShow = 5)
Local $aResult = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hWnd, "int", $iCmdShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_StringFromGUID($tGUID)
Local $aResult = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tGUID, "wstr", "", "int", 40)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, "")
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_StringLenA(Const ByRef $tString)
Local $aResult = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $tString)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_StringLenW(Const ByRef $tString)
Local $aResult = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $tString)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SubLangId($iLngID)
Return BitShift($iLngID, 10)
EndFunc
Func _WinAPI_SystemParametersInfo($iAction, $iParam = 0, $vParam = 0, $iWinIni = 0)
Local $aResult = DllCall("user32.dll", "bool", "SystemParametersInfoW", "uint", $iAction, "uint", $iParam, "struct*", $vParam,  "uint", $iWinIni)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_TwipsPerPixelX()
Local $hDC, $iTwipsPerPixelX
$hDC = _WinAPI_GetDC(0)
$iTwipsPerPixelX = 1440 / _WinAPI_GetDeviceCaps($hDC, $__WINAPICONSTANT_LOGPIXELSX)
_WinAPI_ReleaseDC(0, $hDC)
Return $iTwipsPerPixelX
EndFunc
Func _WinAPI_TwipsPerPixelY()
Local $hDC, $iTwipsPerPixelY
$hDC = _WinAPI_GetDC(0)
$iTwipsPerPixelY = 1440 / _WinAPI_GetDeviceCaps($hDC, $__WINAPICONSTANT_LOGPIXELSY)
_WinAPI_ReleaseDC(0, $hDC)
Return $iTwipsPerPixelY
EndFunc
Func _WinAPI_UnhookWindowsHookEx($hHook)
Local $aResult = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hHook)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateLayeredWindow($hWnd, $hDestDC, $tPTDest, $tSize, $hSrcDC, $tPTSrce, $iRGB, $tBlend, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hWnd, "handle", $hDestDC, "struct*", $tPTDest,  "struct*", $tSize, "handle", $hSrcDC, "struct*", $tPTSrce, "dword", $iRGB, "struct*", $tBlend, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForInputIdle($hProcess, $iTimeout = -1)
Local $aResult = DllCall("user32.dll", "dword", "WaitForInputIdle", "handle", $hProcess, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForMultipleObjects($iCount, $paHandles, $bWaitAll = False, $iTimeout = -1)
Local $aResult = DllCall("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $iCount, "struct*", $paHandles, "bool", $bWaitAll, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForSingleObject($hHandle, $iTimeout = -1)
Local $aResult = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hHandle, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_WideCharToMultiByte($vUnicode, $iCodePage = 0, $bRetString = True)
Local $sUnicodeType = "wstr"
If Not IsString($vUnicode) Then $sUnicodeType = "struct*"
Local $aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1,  "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 20, @extended, "")
Local $tMultiByte = DllStructCreate("char[" & $aResult[0] & "]")
$aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode,  "int", -1, "struct*", $tMultiByte, "int", $aResult[0], "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
If $bRetString Then Return DllStructGetData($tMultiByte, 1)
Return $tMultiByte
EndFunc
Func _WinAPI_WindowFromPoint(ByRef $tPoint)
Local $aResult = DllCall("user32.dll", "hwnd", "WindowFromPoint", "struct", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_WriteConsole($hConsole, $sText)
Local $aResult = DllCall("kernel32.dll", "bool", "WriteConsoleW", "handle", $hConsole, "wstr", $sText,  "dword", StringLen($sText), "dword*", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_WriteFile($hFile, $pBuffer, $iToWrite, ByRef $iWritten, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToWrite,  "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aResult[4]
Return $aResult[0]
EndFunc
Func _WinAPI_WriteProcessMemory($hProcess, $pBaseAddress, $pBuffer, $iSize, ByRef $iWritten, $sBuffer = "ptr")
Local $aResult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hProcess, "ptr", $pBaseAddress,  $sBuffer, $pBuffer, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aResult[5]
Return $aResult[0]
EndFunc
Global Const $PROCESS_TERMINATE = 0x00000001
Global Const $PROCESS_CREATE_THREAD = 0x00000002
Global Const $PROCESS_SET_SESSIONID = 0x00000004
Global Const $PROCESS_VM_OPERATION = 0x00000008
Global Const $PROCESS_VM_READ = 0x00000010
Global Const $PROCESS_VM_WRITE = 0x00000020
Global Const $PROCESS_DUP_HANDLE = 0x00000040
Global Const $PROCESS_CREATE_PROCESS = 0x00000080
Global Const $PROCESS_SET_QUOTA = 0x00000100
Global Const $PROCESS_SET_INFORMATION = 0x00000200
Global Const $PROCESS_QUERY_INFORMATION = 0x00000400
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
Global Const $PROCESS_SUSPEND_RESUME = 0x00000800
Global Const $PROCESS_ALL_ACCESS = 0x001F0FFF
Func _ProcessGetName($iPID)
Local $aProcessList = ProcessList()
If Not @error Then
For $i = 1 To $aProcessList[0][0]
If $aProcessList[$i][1] = $iPID Then
Return $aProcessList[$i][0]
EndIf
Next
EndIf
Return SetError(1, 0, "")
EndFunc
Func _ProcessGetPriority($vProcess)
Local $iError = 0, $iExtended = 0, $iReturn = -1
Local $iPID = ProcessExists($vProcess)
If Not $iPID Then Return SetError(1, 0, -1)
Local $hDLL = DllOpen('kernel32.dll')
Do
Local $aProcessHandle = DllCall($hDLL, 'handle', 'OpenProcess', 'dword', $PROCESS_QUERY_INFORMATION, 'bool', False, 'dword', $iPID)
If @error Then
$iError = @error + 10
$iExtended = @extended
ExitLoop
EndIf
If Not $aProcessHandle[0] Then ExitLoop
Local $aPriority = DllCall($hDLL, 'dword', 'GetPriorityClass', 'handle', $aProcessHandle[0])
If @error Then
$iError = @error
$iExtended = @extended
EndIf
DllCall($hDLL, 'bool', 'CloseHandle', 'handle', $aProcessHandle[0])
If $iError Then ExitLoop
Switch $aPriority[0]
Case 0x00000040
$iReturn = 0
Case 0x00004000
$iReturn = 1
Case 0x00000020
$iReturn = 2
Case 0x00008000
$iReturn = 3
Case 0x00000080
$iReturn = 4
Case 0x00000100
$iReturn = 5
Case Else
$iError = 1
$iExtended = $aPriority[0]
$iReturn = -1
EndSwitch
Until True
DllClose($hDLL)
Return SetError($iError, $iExtended, $iReturn)
EndFunc
Func _RunDos($sCommand)
Local $nResult = RunWait(@ComSpec & " /C " & $sCommand, "", @SW_HIDE)
Return SetError(@error, @extended, $nResult)
EndFunc
Global $iBotProcessPriority = _ProcessGetPriority(@AutoItPID)
ProcessSetPriority(@AutoItPID, $PROCESS_ABOVENORMAL)
Global $iBotLaunchTime = 0
Global $hBotLaunchTime = TimerInit()
Global $sBotVersion = "v6.2.2"
;~ Global $sModversion = "v3.3.1"
Global $sModSupportUrl = "https://mybot.run/forums/index.php?/topic/24893-mybotrun-dococ-v322-oct-sc-update/"
Global $sBotTitle = "My Bot " & $sBotVersion & "   RK MOD v 2.0 " & $sModversion & " "
Global Const $iDelaySleep = 100
Global Const $iDelayWaitForPopup = 1500
Global Const $iDelayRespond = 5
Global Const $iDelayRunBot1 = 1000
Global Const $iDelayRunBot2 = 800
Global Const $iDelayRunBot3 = 200
Global Const $iDelayRunBot4 = 1500
Global Const $iDelayRunBot5 = 500
Global Const $iDelayRunBot6 = 100
Global Const $iDelayIdle1 = 200
Global Const $iDelayIdle2 = 1500
Global Const $iDelaySmartWait = 500
Global Const $iDelayAttackMain1 = 1000
Global Const $iDelayAttackMain2 = 1500
Global Const $iDelayAlgorithmTH1 = 100
Global Const $iDelayAlgorithmTH2 = 1000
Global Const $iDelayAlgorithmTH3 = 200
Global Const $iDelayAttackTHGrid1 = 500
Global Const $iDelayAttackTHGrid2min = 30
Global Const $iDelayAttackTHGrid2max = 60
Global Const $iDelayAttackTHGrid3min = 40
Global Const $iDelayAttackTHGrid3max = 100
Global Const $iDelayAttackTHGrid4 = 300
Global Const $iDelayAttackTHGrid5 = 100
Global Const $iDelayAttackTHGrid6 = 500
Global Const $iDelayAttackTHNormal1 = 1000
Global Const $iDelayAttackTHXtreme1 = 1000
Global Const $iDelayAttackTHGbarch1 = 1000
Global Const $iDelayALLDropheroes1 = 1000
Global Const $iDelayALLDropheroes2 = 100
Global Const $iDelayCastSpell1 = 10
Global Const $iDelayalgorithm_AllTroops1 = 2000
Global Const $iDelayalgorithm_AllTroops2 = 1000
Global Const $iDelayalgorithm_AllTroops3 = $iDelayWaitForPopup
Global Const $iDelayalgorithm_AllTroops4 = 100
Global Const $iDelayalgorithm_AllTroops5 = 500
Global Const $iDelayBarch1 = 100
Global Const $iDelayBarch2 = 500
Global Const $iDelayBarch3 = 1000
Global Const $iDelayAttackReport1 = 500
Global Const $iDelayAttackReport2 = 150
Global Const $iDelaydropCC1 = 500
Global Const $iDelaydropCC2 = 500
Global Const $iDelaydropHeroes1 = 300
Global Const $iDelaydropHeroes2 = 500
Global Const $iDelayGoldElixirChange1 = 500
Global Const $iDelayGoldElixirChange2 = 1000
Global Const $iDelayGoldElixirChangeEBO1 = 500
Global Const $iDelayGoldElixirChangeEBO2 = 1000
Global Const $iDelayPrepareAttack1 = 250
Global Const $iDelayDropOnPixel1 = 50
Global Const $iDelayDropOnPixel2 = 250
Global Const $iDelayDropTroop1 = 100
Global Const $iDelayDropTroop2 = 300
Global Const $iDelayReturnHomeSurrender = $iDelayWaitForPopup
Global Const $iDelayReturnHome1 = 1000
Global Const $iDelayReturnHome2 = 1500
Global Const $iDelayReturnHome3 = 2500
Global Const $iDelayReturnHome4 = 2000
Global Const $iDelayReturnHome5 = 200
Global Const $iDelayDropOnEdge1 = 100
Global Const $iDelayDropOnEdge2 = 300
Global Const $iDelayDropOnEdge3 = 50
Global Const $iDelayDropOnEdge4 = 250
Global Const $iDelayLaunchTroop21 = 100
Global Const $iDelayLaunchTroop22 = 1000
Global Const $iDelayLaunchTroop23 = 300
Global Const $iDelayOldDropTroop1 = 100
Global Const $iDelayOldDropTroop2 = 50
Global Const $iDelayUnbreakable1 = 1000
Global Const $iDelayUnbreakable2 = 2000
Global Const $iDelayUnbreakable3 = 3000
Global Const $iDelayUnbreakable4 = 5000
Global Const $iDelayUnbreakable5 = 15000
Global Const $iDelayUnbreakable6 = 30000
Global Const $iDelayUnbreakable7 = 100
Global Const $iDelayUnbreakable8 = 50
Global Const $iDelaycheckDarkElix1 = 500
Global Const $iDelaycheckDarkElix2 = 1000
Global Const $iDelayCheckTombs1 = 500
Global Const $iDelayCheckTombs2 = 2000
Global Const $iDelayCheckWall1 = 500
Global Const $iDelayCheckWall2 = 1000
Global Const $iDelayCheckWall3 = 250
Global Const $iDelaycheckMainScreen1 = 1000
Global Const $iDelaycheckMainScreen2 = 20000
Global Const $iDelaycheckObstacles1 = 1000
Global Const $iDelaycheckObstacles2 = 2000 + 1700
Global Const $iDelaycheckObstacles3 = 5000
Global Const $iDelaycheckObstacles4 = 120000
Global Const $iDelaycheckObstacles5 = 500
Global Const $iDelaycheckObstacles6 = 300000
Global Const $iDelaycheckObstacles7 = 600000
Global Const $iDelaycheckObstacles8 = 900000
Global Const $iDelaycheckObstacles9 = 1200000
Global Const $iDelaycheckObstacles10 = 1800000
Global Const $iDelayisGemOpen1 = 350
Global Const $iDelaywaitMainScreen1 = 2000
Global Const $iDelaywaitMainScreen2 = 20000
Global Const $iDelaywaitMainScreen3 = 15000
Global Const $iDelaywaitMainScreen4 = 4000
Global Const $iDelayZoomOut1 = 1500
Global Const $iDelayZoomOut2 = 200
Global Const $iDelayZoomOut3 = 1000
Global Const $iDelayBlockInput1 = 10
Global Const $iDelayCheckVersionHTML1 = 250
Global Const $iDelayTogglePause1 = 100
Global Const $iDelayTogglePause2 = 250
Global Const $iDelayTrainClick1 = 3000
Global Const $iDelayWindowsArrange1 = 500
Global Const $iDelayBuildingInfo1 = 1500
Global Const $iDelayGetResources1 = 250
Global Const $iDelayGetResources2 = 500
Global Const $iDelayGetResources3 = 150
Global Const $iDelayGetResources4 = 300
Global Const $iDelayGetResources5 = 2000
Global Const $iDelayPrepareSearch1 = 1000
Global Const $iDelayPrepareSearch2 = 2000
Global Const $iDelayPrepareSearch3 = 500
Global Const $iDelayPrepareSearch4 = 200
Global Const $iDelayPrepareSearch5 = 20000
Global Const $iDelayPrepareSearch6 = 15000
Global Const $iDelayPrepareSearch7 = 50
Global Const $iDelayVillageSearch1 = 1000
Global Const $iDelayVillageSearch2 = 100
Global Const $iDelayVillageSearch3 = 500
Global Const $iDelayVillageSearch4 = 300
Global Const $iDelayVillageSearch5 = 2000
Global Const $iDelayBarracksStatus1 = 50
Global Const $iDelayBarracksStatus2 = 100
Global Const $iDelayBoostBarracks1 = 1000
Global Const $iDelayBoostBarracks2 = 2000
Global Const $iDelayBoostBarracks3 = 500
Global Const $iDelayBoostBarracks4 = 600
Global Const $iDelayBoostBarracks5 = 200
Global Const $iDelayBoostSpellFactory1 = 1000
Global Const $iDelayBoostSpellFactory2 = 2000
Global Const $iDelayBoostSpellFactory3 = 500
Global Const $iDelayBoostSpellFactory4 = 600
Global Const $iDelayBoostHeroes1 = 1000
Global Const $iDelayBoostHeroes2 = 2000
Global Const $iDelayBoostHeroes3 = 500
Global Const $iDelayBoostHeroes4 = 600
Global Const $iDelayBotCommand1 = 500
Global Const $iDelayBotDetectFirstTime1 = 1000
Global Const $iDelayBotDetectFirstTime2 = 50
Global Const $iDelayBotDetectFirstTime3 = 100
Global Const $iDelaycheckArmyCamp1 = 100
Global Const $iDelaycheckArmyCamp2 = 1000
Global Const $iDelaycheckArmyCamp3 = 2000
Global Const $iDelaycheckArmyCamp4 = 500
Global Const $iDelaycheckArmyCamp5 = 250
Global Const $iDelaycheckArmyCamp6 = 10
Global Const $iDelayCheckFullArmy1 = 100
Global Const $iDelayCheckFullArmy2 = 200
Global Const $iDelayCheckFullArmy3 = 500
Global Const $iDelayCollect1 = 100
Global Const $iDelayCollect2 = 250
Global Const $iDelayCollect3 = 500
Global Const $iDelayDonateCC1 = 200
Global Const $iDelayDonateCC2 = 250
Global Const $iDelayDonateCC3 = 50
Global Const $iDelayDonateCC4 = 1250
Global Const $iDelayDonateTroopType1 = 250
Global Const $iDelayDonateWindow1 = 250
Global Const $iDelayDropTrophy1 = 1000
Global Const $iDelayDropTrophy2 = 2000
Global Const $iDelayDropTrophy3 = 1500
Global Const $iDelayDropTrophy4 = 250
Global Const $iDelayDropSuperXP1 = 500
Global Const $iDelayDropSuperXP2 = 1000
Global Const $iDelayDropSuperXP3 = 250
Global Const $iDelayPrepareSearchSuperXP = 500
Global Const $iDelayGetTownHallLevel1 = 1000
Global Const $iDelayGetTownHallLevel2 = 1500
Global Const $iDelayGetTownHallLevel3 = 200
Global Const $iDelayLaboratory1 = 750
Global Const $iDelayLaboratory2 = 200
Global Const $iDelayLaboratory3 = 1000
Global Const $iDelayLaboratory4 = 200
Global Const $iDelayLabUpgrade1 = 1000
Global Const $iDelayLabUpgrade2 = 200
Global Const $iDelayLabUpgrade3 = 200
Global Const $iDelayLocateBarrack1 = 1000
Global Const $iDelayLocateBarrack2 = 2000
Global Const $iDelayLocateBarrack3 = 100
Global Const $iDelayLocateTownHall1 = 1000
Global Const $iDelayCheckUpgrades1 = 1000
Global Const $iDelayUpgradeValue1 = 200
Global Const $iDelayUpgradeValue2 = 800
Global Const $iDelayUpgradeValue3 = 750
Global Const $iDelayUpgradeValue4 = 1000
Global Const $iDelayDebugImageSave1 = 200
Global Const $iDelayProfileReport1 = 500
Global Const $iDelayProfileReport2 = 1000
Global Const $iDelayProfileReport3 = 200
Global Const $iDelayReportPushBullet1 = 500
Global Const $iDelayPushMsg1 = 500
Global Const $iDelayPushMsg2 = 1000
Global Const $iDelayReArm1 = 500
Global Const $iDelayReArm2 = 1500
Global Const $iDelayReArm3 = 700
Global Const $iDelayReArm4 = 200
Global Const $iDelayReplayShare1 = 250
Global Const $iDelayReplayShare2 = 500
Global Const $iDelayReplayShare3 = 1000
Global Const $iDelayReplayShare4 = 2000
Global Const $iDelayRequestCC1 = 500
Global Const $iDelaymakerequest1 = 500
Global Const $iDelaymakerequest2 = 1500
Global Const $iDelayCreateSpell1 = 600
Global Const $iDelayCreateSpell2 = 1000
Global Const $iDelayCreateSpell3 = 250
Global Const $iDelayTrain1 = 100
Global Const $iDelayTrain2 = 500
Global Const $iDelayTrain3 = 1000
Global Const $iDelayTrain4 = 200
Global Const $iDelayTrain5 = 250
Global Const $iDelayTrain6 = 20
Global Const $iDelayTrain7 = 5
Global Const $iDelayTrain8 = 5000
Global Const $iDelayIsTrainPage1 = 100
Global Const $iDelayUpgradeBuilding1 = 200
Global Const $iDelayUpgradeBuilding2 = 500
Global Const $iDelayUpgradeBuilding3 = 700
Global Const $iDelayUpgradeNormal1 = 700
Global Const $iDelayUpgradeNormal2 = 200
Global Const $iDelayUpgradeNormal3 = 750
Global Const $iDelayUpgradeHero1 = 800
Global Const $iDelayUpgradeHero2 = 500
Global Const $iDelayUpgradeHero3 = 1000
Global Const $iDelayUpgradeWall1 = 500
Global Const $iDelayUpgradeWallGold1 = 600
Global Const $iDelayUpgradeWallGold2 = 1000
Global Const $iDelayUpgradeWallGold3 = 500
Global Const $iDelayUpgradeWallElixir1 = 600
Global Const $iDelayUpgradeWallElixir2 = 1000
Global Const $iDelayUpgradeWallElixir3 = 500
Global Const $iDelayVillageReport1 = 500
Global Const $iDelayDropLSpell1 = 250
Global Const $iDelayTrainMoveBtn1 = 250
Global Const $iDelayWaitnOpenCoC500 = 500
Global Const $iDelayWaitnOpenCoC1000 = 1000
Global Const $iDelayWaitnOpenCoC10000 = 10000
Global Const $iDelayWaitnOpenCoC25000 = 25000
Global Const $iDelaySWHTSearchLimit1 = 200
Global Const $iDelaySearchLimit1 = 200
Global Const $iDelaySearchLimit2 = 1000
Global Const $iDelayClanLevel1 = 100
Global Const $iDelayImageType1 = 100
Global Const $iSpecialClick1 = 200
Global Const $iSpecialClick2 = 100
Global Const $iDelayAttackCSV1 = $iDelayVillageSearch5
Global Const $iDelayAttackCSV2 = $iDelayVillageSearch4
Global Const $iDelayAttackCSV3 = 10
Global Const $iPersonalShield1 = 1000
Global Const $iPersonalShield2 = 500
Global Const $iPersonalShield3 = 100
Global Const $iDelayStarBonus100 = 100
Global Const $iDelayStarBonus500 = 500
Global Const $iDelayAttackDisable100 = 100
Global Const $iDelayAttackDisable500 = 500
Global Const $iDelayAttackDisable1000 = 1000
Global Const $iDelayWaitAttack = 120000
Global Const $iDelayWaitAttack1 = 60000
Global Const $iDelayWaitAttack2 = 300000
Global Const $MATH_ISNOTDIVISIBLE = 1
Global Const $MATH_ISDIVISIBLE = 2
Global Const $MATH_DEGREES = 57.2957795130823
Func _Degree($iRadians)
Return IsNumber($iRadians) ? $iRadians * $MATH_DEGREES : SetError(1, 0, "")
EndFunc
Func _MathCheckDiv($iNum1, $iNum2 = 2)
If Not (IsInt($iNum1) And IsInt($iNum2)) Then
Return SetError(1, 0, -1)
EndIf
Return (Mod($iNum1, $iNum2) = 0) ? $MATH_ISDIVISIBLE : $MATH_ISNOTDIVISIBLE
EndFunc
Func _Max($iNum1, $iNum2)
If Not IsNumber($iNum1) Then Return SetError(1, 0, 0)
If Not IsNumber($iNum2) Then Return SetError(2, 0, 0)
Return ($iNum1 > $iNum2) ? $iNum1 : $iNum2
EndFunc
Func _Min($iNum1, $iNum2)
If Not IsNumber($iNum1) Then Return SetError(1, 0, 0)
If Not IsNumber($iNum2) Then Return SetError(2, 0, 0)
Return ($iNum1 > $iNum2) ? $iNum2 : $iNum1
EndFunc
Func _Radian($iDegrees)
Return Number($iDegrees) ? $iDegrees / $MATH_DEGREES : SetError(1, 0, "")
EndFunc
Global Const $BS_GROUPBOX = 0x0007
Global Const $BS_BOTTOM = 0x0800
Global Const $BS_CENTER = 0x0300
Global Const $BS_DEFPUSHBUTTON = 0x0001
Global Const $BS_LEFT = 0x0100
Global Const $BS_MULTILINE = 0x2000
Global Const $BS_PUSHBOX = 0x000A
Global Const $BS_PUSHLIKE = 0x1000
Global Const $BS_RIGHT = 0x0200
Global Const $BS_RIGHTBUTTON = 0x0020
Global Const $BS_TOP = 0x0400
Global Const $BS_VCENTER = 0x0C00
Global Const $BS_FLAT = 0x8000
Global Const $BS_ICON = 0x0040
Global Const $BS_BITMAP = 0x0080
Global Const $BS_NOTIFY = 0x4000
Global Const $BS_SPLITBUTTON = 0x0000000C
Global Const $BS_DEFSPLITBUTTON = 0x0000000D
Global Const $BS_COMMANDLINK = 0x0000000E
Global Const $BS_DEFCOMMANDLINK = 0x0000000F
Global Const $BCSIF_GLYPH = 0x0001
Global Const $BCSIF_IMAGE = 0x0002
Global Const $BCSIF_STYLE = 0x0004
Global Const $BCSIF_SIZE = 0x0008
Global Const $BCSS_NOSPLIT = 0x0001
Global Const $BCSS_STRETCH = 0x0002
Global Const $BCSS_ALIGNLEFT = 0x0004
Global Const $BCSS_IMAGE = 0x0008
Global Const $BUTTON_IMAGELIST_ALIGN_LEFT = 0
Global Const $BUTTON_IMAGELIST_ALIGN_RIGHT = 1
Global Const $BUTTON_IMAGELIST_ALIGN_TOP = 2
Global Const $BUTTON_IMAGELIST_ALIGN_BOTTOM = 3
Global Const $BUTTON_IMAGELIST_ALIGN_CENTER = 4
Global Const $BS_3STATE = 0x0005
Global Const $BS_AUTO3STATE = 0x0006
Global Const $BS_AUTOCHECKBOX = 0x0003
Global Const $BS_CHECKBOX = 0x0002
Global Const $BS_RADIOBUTTON = 0x4
Global Const $BS_AUTORADIOBUTTON = 0x0009
Global Const $BS_OWNERDRAW = 0xB
Global Const $GUI_SS_DEFAULT_BUTTON = 0
Global Const $GUI_SS_DEFAULT_CHECKBOX = 0
Global Const $GUI_SS_DEFAULT_GROUP = 0
Global Const $GUI_SS_DEFAULT_RADIO = 0
Global Const $BCM_FIRST = 0x1600
Global Const $BCM_GETIDEALSIZE = ($BCM_FIRST + 0x0001)
Global Const $BCM_GETIMAGELIST = ($BCM_FIRST + 0x0003)
Global Const $BCM_GETNOTE = ($BCM_FIRST + 0x000A)
Global Const $BCM_GETNOTELENGTH = ($BCM_FIRST + 0x000B)
Global Const $BCM_GETSPLITINFO = ($BCM_FIRST + 0x0008)
Global Const $BCM_GETTEXTMARGIN = ($BCM_FIRST + 0x0005)
Global Const $BCM_SETDROPDOWNSTATE = ($BCM_FIRST + 0x0006)
Global Const $BCM_SETIMAGELIST = ($BCM_FIRST + 0x0002)
Global Const $BCM_SETNOTE = ($BCM_FIRST + 0x0009)
Global Const $BCM_SETSHIELD = ($BCM_FIRST + 0x000C)
Global Const $BCM_SETSPLITINFO = ($BCM_FIRST + 0x0007)
Global Const $BCM_SETTEXTMARGIN = ($BCM_FIRST + 0x0004)
Global Const $BM_CLICK = 0xF5
Global Const $BM_GETCHECK = 0xF0
Global Const $BM_GETIMAGE = 0xF6
Global Const $BM_GETSTATE = 0xF2
Global Const $BM_SETCHECK = 0xF1
Global Const $BM_SETDONTCLICK = 0xF8
Global Const $BM_SETIMAGE = 0xF7
Global Const $BM_SETSTATE = 0xF3
Global Const $BM_SETSTYLE = 0xF4
Global Const $BCN_FIRST = -1250
Global Const $BCN_DROPDOWN = ($BCN_FIRST + 0x0002)
Global Const $BCN_HOTITEMCHANGE = ($BCN_FIRST + 0x0001)
Global Const $BN_CLICKED = 0
Global Const $BN_PAINT = 1
Global Const $BN_HILITE = 2
Global Const $BN_UNHILITE = 3
Global Const $BN_DISABLE = 4
Global Const $BN_DOUBLECLICKED = 5
Global Const $BN_SETFOCUS = 6
Global Const $BN_KILLFOCUS = 7
Global Const $BN_PUSHED = $BN_HILITE
Global Const $BN_UNPUSHED = $BN_UNHILITE
Global Const $BN_DBLCLK = $BN_DOUBLECLICKED
Global Const $BST_CHECKED = 0x1
Global Const $BST_INDETERMINATE = 0x2
Global Const $BST_UNCHECKED = 0x0
Global Const $BST_FOCUS = 0x8
Global Const $BST_PUSHED = 0x4
Global Const $BST_DONTCLICK = 0x000080
Global Const $CB_ERR = -1
Global Const $CB_ERRATTRIBUTE = -3
Global Const $CB_ERRREQUIRED = -4
Global Const $CB_ERRSPACE = -2
Global Const $CB_OKAY = 0
Global Const $STATE_SYSTEM_INVISIBLE = 0x8000
Global Const $STATE_SYSTEM_PRESSED = 0x8
Global Const $CBS_AUTOHSCROLL = 0x40
Global Const $CBS_DISABLENOSCROLL = 0x800
Global Const $CBS_DROPDOWN = 0x2
Global Const $CBS_DROPDOWNLIST = 0x3
Global Const $CBS_HASSTRINGS = 0x200
Global Const $CBS_LOWERCASE = 0x4000
Global Const $CBS_NOINTEGRALHEIGHT = 0x400
Global Const $CBS_OEMCONVERT = 0x80
Global Const $CBS_OWNERDRAWFIXED = 0x10
Global Const $CBS_OWNERDRAWVARIABLE = 0x20
Global Const $CBS_SIMPLE = 0x1
Global Const $CBS_SORT = 0x100
Global Const $CBS_UPPERCASE = 0x2000
Global Const $CBM_FIRST = 0x1700
Global Const $CB_ADDSTRING = 0x143
Global Const $CB_DELETESTRING = 0x144
Global Const $CB_DIR = 0x145
Global Const $CB_FINDSTRING = 0x14C
Global Const $CB_FINDSTRINGEXACT = 0x158
Global Const $CB_GETCOMBOBOXINFO = 0x164
Global Const $CB_GETCOUNT = 0x146
Global Const $CB_GETCUEBANNER = ($CBM_FIRST + 4)
Global Const $CB_GETCURSEL = 0x147
Global Const $CB_GETDROPPEDCONTROLRECT = 0x152
Global Const $CB_GETDROPPEDSTATE = 0x157
Global Const $CB_GETDROPPEDWIDTH = 0X15f
Global Const $CB_GETEDITSEL = 0x140
Global Const $CB_GETEXTENDEDUI = 0x156
Global Const $CB_GETHORIZONTALEXTENT = 0x15d
Global Const $CB_GETITEMDATA = 0x150
Global Const $CB_GETITEMHEIGHT = 0x154
Global Const $CB_GETLBTEXT = 0x148
Global Const $CB_GETLBTEXTLEN = 0x149
Global Const $CB_GETLOCALE = 0x15A
Global Const $CB_GETMINVISIBLE = 0x1702
Global Const $CB_GETTOPINDEX = 0x15b
Global Const $CB_INITSTORAGE = 0x161
Global Const $CB_LIMITTEXT = 0x141
Global Const $CB_RESETCONTENT = 0x14B
Global Const $CB_INSERTSTRING = 0x14A
Global Const $CB_SELECTSTRING = 0x14D
Global Const $CB_SETCUEBANNER = ($CBM_FIRST + 3)
Global Const $CB_SETCURSEL = 0x14E
Global Const $CB_SETDROPPEDWIDTH = 0x160
Global Const $CB_SETEDITSEL = 0x142
Global Const $CB_SETEXTENDEDUI = 0x155
Global Const $CB_SETHORIZONTALEXTENT = 0x15e
Global Const $CB_SETITEMDATA = 0x151
Global Const $CB_SETITEMHEIGHT = 0x153
Global Const $CB_SETLOCALE = 0x159
Global Const $CB_SETMINVISIBLE = 0x1701
Global Const $CB_SETTOPINDEX = 0x15c
Global Const $CB_SHOWDROPDOWN = 0x14F
Global Const $CBN_CLOSEUP = 8
Global Const $CBN_DBLCLK = 2
Global Const $CBN_DROPDOWN = 7
Global Const $CBN_EDITCHANGE = 5
Global Const $CBN_EDITUPDATE = 6
Global Const $CBN_ERRSPACE = (-1)
Global Const $CBN_KILLFOCUS = 4
Global Const $CBN_SELCHANGE = 1
Global Const $CBN_SELENDCANCEL = 10
Global Const $CBN_SELENDOK = 9
Global Const $CBN_SETFOCUS = 3
Global Const $CBES_EX_CASESENSITIVE = 0x10
Global Const $CBES_EX_NOEDITIMAGE = 0x1
Global Const $CBES_EX_NOEDITIMAGEINDENT = 0x2
Global Const $CBES_EX_NOSIZELIMIT = 0x8
Global Const $__COMBOBOXCONSTANT_WM_USER = 0X400
Global Const $CBEM_DELETEITEM = $CB_DELETESTRING
Global Const $CBEM_GETCOMBOCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 6)
Global Const $CBEM_GETEDITCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 7)
Global Const $CBEM_GETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
Global Const $CBEM_GETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
Global Const $CBEM_GETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 3)
Global Const $CBEM_GETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 4)
Global Const $CBEM_GETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 13)
Global Const $CBEM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $CBEM_HASEDITCHANGED = ($__COMBOBOXCONSTANT_WM_USER + 10)
Global Const $CBEM_INSERTITEMA = ($__COMBOBOXCONSTANT_WM_USER + 1)
Global Const $CBEM_INSERTITEMW = ($__COMBOBOXCONSTANT_WM_USER + 11)
Global Const $CBEM_SETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 8)
Global Const $CBEM_SETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 14)
Global Const $CBEM_SETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 2)
Global Const $CBEM_SETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 5)
Global Const $CBEM_SETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 12)
Global Const $CBEM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $CBEM_SETWINDOWTHEME = 0x2000 + 11
Global Const $CBEN_FIRST = (-800)
Global Const $CBEN_LAST = (-830)
Global Const $CBEN_BEGINEDIT = ($CBEN_FIRST - 4)
Global Const $CBEN_DELETEITEM = ($CBEN_FIRST - 2)
Global Const $CBEN_DRAGBEGINA = ($CBEN_FIRST - 8)
Global Const $CBEN_DRAGBEGINW = ($CBEN_FIRST - 9)
Global Const $CBEN_ENDEDITA = ($CBEN_FIRST - 5)
Global Const $CBEN_ENDEDITW = ($CBEN_FIRST - 6)
Global Const $CBEN_GETDISPINFO = ($CBEN_FIRST - 0)
Global Const $CBEN_GETDISPINFOA = ($CBEN_FIRST - 0)
Global Const $CBEN_GETDISPINFOW = ($CBEN_FIRST - 7)
Global Const $CBEN_INSERTITEM = ($CBEN_FIRST - 1)
Global Const $CBEIF_DI_SETITEM = 0x10000000
Global Const $CBEIF_IMAGE = 0x2
Global Const $CBEIF_INDENT = 0x10
Global Const $CBEIF_LPARAM = 0x20
Global Const $CBEIF_OVERLAY = 0x8
Global Const $CBEIF_SELECTEDIMAGE = 0x4
Global Const $CBEIF_TEXT = 0x1
Global Const $GUI_SS_DEFAULT_COMBO = 0x00200042
Global Const $ES_LEFT = 0
Global Const $ES_CENTER = 1
Global Const $ES_RIGHT = 2
Global Const $ES_MULTILINE = 4
Global Const $ES_UPPERCASE = 8
Global Const $ES_LOWERCASE = 16
Global Const $ES_PASSWORD = 32
Global Const $ES_AUTOVSCROLL = 64
Global Const $ES_AUTOHSCROLL = 128
Global Const $ES_NOHIDESEL = 256
Global Const $ES_OEMCONVERT = 1024
Global Const $ES_READONLY = 2048
Global Const $ES_WANTRETURN = 4096
Global Const $ES_NUMBER = 8192
Global Const $EC_ERR = -1
Global Const $ECM_FIRST = 0X1500
Global Const $EM_CANUNDO = 0xC6
Global Const $EM_CHARFROMPOS = 0xD7
Global Const $EM_EMPTYUNDOBUFFER = 0xCD
Global Const $EM_FMTLINES = 0xC8
Global Const $EM_GETCUEBANNER = ($ECM_FIRST + 2)
Global Const $EM_GETFIRSTVISIBLELINE = 0xCE
Global Const $EM_GETHANDLE = 0xBD
Global Const $EM_GETIMESTATUS = 0xD9
Global Const $EM_GETLIMITTEXT = 0xD5
Global Const $EM_GETLINE = 0xC4
Global Const $EM_GETLINECOUNT = 0xBA
Global Const $EM_GETMARGINS = 0xD4
Global Const $EM_GETMODIFY = 0xB8
Global Const $EM_GETPASSWORDCHAR = 0xD2
Global Const $EM_GETRECT = 0xB2
Global Const $EM_GETSEL = 0xB0
Global Const $EM_GETTHUMB = 0xBE
Global Const $EM_GETWORDBREAKPROC = 0xD1
Global Const $EM_HIDEBALLOONTIP = ($ECM_FIRST + 4)
Global Const $EM_LIMITTEXT = 0xC5
Global Const $EM_LINEFROMCHAR = 0xC9
Global Const $EM_LINEINDEX = 0xBB
Global Const $EM_LINELENGTH = 0xC1
Global Const $EM_LINESCROLL = 0xB6
Global Const $EM_POSFROMCHAR = 0xD6
Global Const $EM_REPLACESEL = 0xC2
Global Const $EM_SCROLL = 0xB5
Global Const $EM_SCROLLCARET = 0x00B7
Global Const $EM_SETCUEBANNER = ($ECM_FIRST + 1)
Global Const $EM_SETHANDLE = 0xBC
Global Const $EM_SETIMESTATUS = 0xD8
Global Const $EM_SETLIMITTEXT = $EM_LIMITTEXT
Global Const $EM_SETMARGINS = 0xD3
Global Const $EM_SETMODIFY = 0xB9
Global Const $EM_SETPASSWORDCHAR = 0xCC
Global Const $EM_SETREADONLY = 0xCF
Global Const $EM_SETRECT = 0xB3
Global Const $EM_SETRECTNP = 0xB4
Global Const $EM_SETSEL = 0xB1
Global Const $EM_SETTABSTOPS = 0xCB
Global Const $EM_SETWORDBREAKPROC = 0xD0
Global Const $EM_SHOWBALLOONTIP = ($ECM_FIRST + 3)
Global Const $EM_UNDO = 0xC7
Global Const $EC_LEFTMARGIN = 0x1
Global Const $EC_RIGHTMARGIN = 0x2
Global Const $EC_USEFONTINFO = 0xFFFF
Global Const $EMSIS_COMPOSITIONSTRING = 0x1
Global Const $EIMES_GETCOMPSTRATONCE = 0x1
Global Const $EIMES_CANCELCOMPSTRINFOCUS = 0x2
Global Const $EIMES_COMPLETECOMPSTRKILLFOCUS = 0x4
Global Const $EN_ALIGN_LTR_EC = 0x700
Global Const $EN_ALIGN_RTL_EC = 0x701
Global Const $EN_CHANGE = 0x300
Global Const $EN_ERRSPACE = 0x500
Global Const $EN_HSCROLL = 0X601
Global Const $EN_KILLFOCUS = 0x200
Global Const $EN_MAXTEXT = 0x501
Global Const $EN_SETFOCUS = 0x100
Global Const $EN_UPDATE = 0x400
Global Const $EN_VSCROLL = 0x602
Global Const $GUI_SS_DEFAULT_EDIT = 0x003010c0
Global Const $GUI_SS_DEFAULT_INPUT = 0x00000080
Global Const $GUI_EVENT_SINGLE = 0
Global Const $GUI_EVENT_ARRAY = 1
Global Const $GUI_EVENT_NONE = 0
Global Const $GUI_EVENT_CLOSE = -3
Global Const $GUI_EVENT_MINIMIZE = -4
Global Const $GUI_EVENT_RESTORE = -5
Global Const $GUI_EVENT_MAXIMIZE = -6
Global Const $GUI_EVENT_PRIMARYDOWN = -7
Global Const $GUI_EVENT_PRIMARYUP = -8
Global Const $GUI_EVENT_SECONDARYDOWN = -9
Global Const $GUI_EVENT_SECONDARYUP = -10
Global Const $GUI_EVENT_MOUSEMOVE = -11
Global Const $GUI_EVENT_RESIZED = -12
Global Const $GUI_EVENT_DROPPED = -13
Global Const $GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $GUI_AVISTOP = 0
Global Const $GUI_AVISTART = 1
Global Const $GUI_AVICLOSE = 2
Global Const $GUI_CHECKED = 1
Global Const $GUI_INDETERMINATE = 2
Global Const $GUI_UNCHECKED = 4
Global Const $GUI_DROPACCEPTED = 8
Global Const $GUI_NODROPACCEPTED = 4096
Global Const $GUI_ACCEPTFILES = $GUI_DROPACCEPTED
Global Const $GUI_SHOW = 16
Global Const $GUI_HIDE = 32
Global Const $GUI_ENABLE = 64
Global Const $GUI_DISABLE = 128
Global Const $GUI_FOCUS = 256
Global Const $GUI_NOFOCUS = 8192
Global Const $GUI_DEFBUTTON = 512
Global Const $GUI_EXPAND = 1024
Global Const $GUI_ONTOP = 2048
Global Const $GUI_FONTNORMAL = 0
Global Const $GUI_FONTITALIC = 2
Global Const $GUI_FONTUNDER = 4
Global Const $GUI_FONTSTRIKE = 8
Global Const $GUI_DOCKAUTO = 0x0001
Global Const $GUI_DOCKLEFT = 0x0002
Global Const $GUI_DOCKRIGHT = 0x0004
Global Const $GUI_DOCKHCENTER = 0x0008
Global Const $GUI_DOCKTOP = 0x0020
Global Const $GUI_DOCKBOTTOM = 0x0040
Global Const $GUI_DOCKVCENTER = 0x0080
Global Const $GUI_DOCKWIDTH = 0x0100
Global Const $GUI_DOCKHEIGHT = 0x0200
Global Const $GUI_DOCKSIZE = 0x0300
Global Const $GUI_DOCKMENUBAR = 0x0220
Global Const $GUI_DOCKSTATEBAR = 0x0240
Global Const $GUI_DOCKALL = 0x0322
Global Const $GUI_DOCKBORDERS = 0x0066
Global Const $GUI_GR_CLOSE = 1
Global Const $GUI_GR_LINE = 2
Global Const $GUI_GR_BEZIER = 4
Global Const $GUI_GR_MOVE = 6
Global Const $GUI_GR_COLOR = 8
Global Const $GUI_GR_RECT = 10
Global Const $GUI_GR_ELLIPSE = 12
Global Const $GUI_GR_PIE = 14
Global Const $GUI_GR_DOT = 16
Global Const $GUI_GR_PIXEL = 18
Global Const $GUI_GR_HINT = 20
Global Const $GUI_GR_REFRESH = 22
Global Const $GUI_GR_PENSIZE = 24
Global Const $GUI_GR_NOBKCOLOR = -2
Global Const $GUI_BKCOLOR_DEFAULT = -1
Global Const $GUI_BKCOLOR_TRANSPARENT = -2
Global Const $GUI_BKCOLOR_LV_ALTERNATE = 0xFE000000
Global Const $GUI_READ_DEFAULT = 0
Global Const $GUI_READ_EXTENDED = 1
Global Const $GUI_CURSOR_NOOVERRIDE = 0
Global Const $GUI_CURSOR_OVERRIDE = 1
Global Const $GUI_WS_EX_PARENTDRAG = 0x00100000
Global Const $_UDF_GlobalIDs_OFFSET = 2
Global Const $_UDF_GlobalID_MAX_WIN = 16
Global Const $_UDF_STARTID = 10000
Global Const $_UDF_GlobalID_MAX_IDS = 55535
Global Const $__UDFGUICONSTANT_WS_TABSTOP = 0x00010000
Global Const $__UDFGUICONSTANT_WS_VISIBLE = 0x10000000
Global Const $__UDFGUICONSTANT_WS_CHILD = 0x40000000
Global $__g_aUDF_GlobalIDs_Used[$_UDF_GlobalID_MAX_WIN][$_UDF_GlobalID_MAX_IDS + $_UDF_GlobalIDs_OFFSET + 1]
Func __UDF_GetNextGlobalID($hWnd)
Local $nCtrlID, $iUsedIndex = -1, $bAllUsed = True
If Not WinExists($hWnd) Then Return SetError(-1, -1, 0)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] <> 0 Then
If Not WinExists($__g_aUDF_GlobalIDs_Used[$iIndex][0]) Then
For $x = 0 To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Next
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
EndIf
EndIf
Next
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
If $iUsedIndex = -1 Then
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = 0 Then
$__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
EndIf
If $iUsedIndex = -1 And $bAllUsed Then Return SetError(16, 0, 0)
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] = $_UDF_STARTID + $_UDF_GlobalID_MAX_IDS Then
For $iIDIndex = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = 0 Then
$nCtrlID = ($iIDIndex - $_UDF_GlobalIDs_OFFSET) + 10000
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = $nCtrlID
Return $nCtrlID
EndIf
Next
Return SetError(-1, $_UDF_GlobalID_MAX_IDS, 0)
EndIf
$nCtrlID = $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1]
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] += 1
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][($nCtrlID - 10000) + $_UDF_GlobalIDs_OFFSET] = $nCtrlID
Return $nCtrlID
EndFunc
Func __UDF_FreeGlobalID($hWnd, $iGlobalID)
If $iGlobalID - $_UDF_STARTID < 0 Or $iGlobalID - $_UDF_STARTID > $_UDF_GlobalID_MAX_IDS Then Return SetError(-1, 0, False)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
For $x = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][$x] = $iGlobalID Then
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Return True
EndIf
Next
Return SetError(-3, 0, False)
EndIf
Next
Return SetError(-2, 0, False)
EndFunc
Global $__g_hButtonLastWnd
Global Const $tagBUTTON_IMAGELIST = "ptr ImageList;" & $tagRECT & ";uint Align"
Global Const $tagBUTTON_SPLITINFO = "uint mask;handle himlGlyph;uint uSplitStyle;" & $tagSIZE
Global Const $__BUTTONCONSTANT_ClassName = "Button"
Global Const $__BUTTONCONSTANT_GWL_STYLE = 0xFFFFFFF0
Global Const $__BUTTONCONSTANT_WM_SETFONT = 0x0030
Global Const $__BUTTONCONSTANT_DEFAULT_GUI_FONT = 17
Func _GUICtrlButton_Click($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_CLICK)
EndFunc
Func _GUICtrlButton_Create($hWnd, $sText, $iX, $iY, $iWidth, $iHeight, $iStyle = -1, $iExStyle = -1)
If Not IsHWnd($hWnd) Then
Return SetError(1, 0, 0)
EndIf
If Not IsString($sText) Then
Return SetError(2, 0, 0)
EndIf
Local $iForcedStyle = BitOR($__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_CHILD, $BS_NOTIFY)
If $iStyle = -1 Then
$iStyle = $iForcedStyle
Else
$iStyle = BitOR($iStyle, $iForcedStyle)
EndIf
If $iExStyle = -1 Then $iExStyle = 0
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hButton = _WinAPI_CreateWindowEx($iExStyle, $__BUTTONCONSTANT_ClassName, $sText, $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hButton, $__BUTTONCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__BUTTONCONSTANT_DEFAULT_GUI_FONT), True)
Return $hButton
EndFunc
Func _GUICtrlButton_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hButtonLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlButton_Enable($hWnd, $bEnable = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_EnableWindow($hWnd, $bEnable) = $bEnable
EndFunc
Func _GUICtrlButton_GetCheck($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BM_GETCHECK)
EndFunc
Func _GUICtrlButton_GetFocus($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_GetFocus() = $hWnd
EndFunc
Func _GUICtrlButton_GetIdealSize($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tSize = DllStructCreate($tagSIZE), $aSize[2]
Local $iRet = _SendMessage($hWnd, $BCM_GETIDEALSIZE, 0, $tSize, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(-1, -1, $aSize)
$aSize[0] = DllStructGetData($tSize, "X")
$aSize[1] = DllStructGetData($tSize, "Y")
Return $aSize
EndFunc
Func _GUICtrlButton_GetImage($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iRet = _SendMessage($hWnd, $BM_GETIMAGE, 0, 0, 0, "wparam", "lparam", "hwnd")
If $iRet <> 0x00000000 Then Return $iRet
$iRet = _SendMessage($hWnd, $BM_GETIMAGE, 1, 0, 0, "wparam", "lparam", "hwnd")
If $iRet = 0x00000000 Then Return 0
Return $iRet
EndFunc
Func _GUICtrlButton_GetImageList($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tBUTTON_IMAGELIST = DllStructCreate($tagBUTTON_IMAGELIST), $aImageList[6]
If Not _SendMessage($hWnd, $BCM_GETIMAGELIST, 0, $tBUTTON_IMAGELIST, 0, "wparam", "struct*") Then Return SetError(-1, -1, $aImageList)
$aImageList[0] = DllStructGetData($tBUTTON_IMAGELIST, "ImageList")
$aImageList[1] = DllStructGetData($tBUTTON_IMAGELIST, "Left")
$aImageList[2] = DllStructGetData($tBUTTON_IMAGELIST, "Right")
$aImageList[3] = DllStructGetData($tBUTTON_IMAGELIST, "Top")
$aImageList[4] = DllStructGetData($tBUTTON_IMAGELIST, "Bottom")
$aImageList[5] = DllStructGetData($tBUTTON_IMAGELIST, "Align")
Return $aImageList
EndFunc
Func _GUICtrlButton_GetNote($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLen = _GUICtrlButton_GetNoteLength($hWnd) + 1
Local $tNote = DllStructCreate("wchar Note[" & $iLen & "]")
Local $tLen = DllStructCreate("dword")
DllStructSetData($tLen, 1, $iLen)
If Not _SendMessage($hWnd, $BCM_GETNOTE, $tLen, $tNote, 0, "struct*", "struct*") Then Return SetError(-1, 0, "")
Return _WinAPI_WideCharToMultiByte($tNote)
EndFunc
Func _GUICtrlButton_GetNoteLength($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BCM_GETNOTELENGTH)
EndFunc
Func _GUICtrlButton_GetSplitInfo($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tSplitInfo = DllStructCreate($tagBUTTON_SPLITINFO), $aInfo[4]
DllStructSetData($tSplitInfo, "mask", BitOR($BCSIF_GLYPH, $BCSIF_IMAGE, $BCSIF_SIZE, $BCSIF_STYLE))
If Not _SendMessage($hWnd, $BCM_GETSPLITINFO, 0, $tSplitInfo, 0, "wparam", "struct*") Then Return SetError(-1, 0, $aInfo)
$aInfo[0] = DllStructGetData($tSplitInfo, "himlGlyph")
$aInfo[1] = DllStructGetData($tSplitInfo, "uSplitStyle")
$aInfo[2] = DllStructGetData($tSplitInfo, "X")
$aInfo[3] = DllStructGetData($tSplitInfo, "Y")
Return $aInfo
EndFunc
Func _GUICtrlButton_GetState($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BM_GETSTATE)
EndFunc
Func _GUICtrlButton_GetText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_GetWindowText($hWnd)
Return ""
EndFunc
Func _GUICtrlButton_GetTextMargin($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT), $aRect[4]
If Not _SendMessage($hWnd, $BCM_GETTEXTMARGIN, 0, $tRECT, 0, "wparam", "struct*") Then Return SetError(-1, -1, $aRect)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlButton_SetCheck($hWnd, $iState = $BST_CHECKED)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_SETCHECK, $iState)
EndFunc
Func _GUICtrlButton_SetDontClick($hWnd, $bState = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_SETDONTCLICK, $bState)
EndFunc
Func _GUICtrlButton_SetDropDownState($hWnd, $bState = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BCM_SETDROPDOWNSTATE, $bState) <> 0
EndFunc
Func _GUICtrlButton_SetFocus($hWnd, $bFocus = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then
If $bFocus Then
Return _WinAPI_SetFocus($hWnd) <> 0
Else
Return _WinAPI_SetFocus(_WinAPI_GetParent($hWnd)) <> 0
EndIf
EndIf
EndFunc
Func _GUICtrlButton_SetImage($hWnd, $sImageFile, $iIconID = -1, $bLarge = False)
Local $hImage, $hPrevImage
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If StringUpper(StringMid($sImageFile, StringLen($sImageFile) - 2)) = "BMP" Then
If BitAND(_WinAPI_GetWindowLong($hWnd, $__BUTTONCONSTANT_GWL_STYLE), $BS_BITMAP) = $BS_BITMAP Then
$hImage = _WinAPI_LoadImage(0, $sImageFile, 0, 0, 0, BitOR($LR_LOADFROMFILE, $LR_CREATEDIBSECTION))
If Not $hImage Then Return SetError(-1, -1, False)
$hPrevImage = _SendMessage($hWnd, $BM_SETIMAGE, 0, $hImage)
If $hPrevImage Then
If Not _WinAPI_DeleteObject($hPrevImage) Then _WinAPI_DestroyIcon($hPrevImage)
EndIf
_WinAPI_UpdateWindow($hWnd)
Return True
EndIf
Else
If $iIconID = -1 Then
$hImage = _WinAPI_LoadImage(0, $sImageFile, 1, 0, 0, BitOR($LR_LOADFROMFILE, $LR_CREATEDIBSECTION))
If Not $hImage Then Return SetError(-1, -1, False)
$hPrevImage = _SendMessage($hWnd, $BM_SETIMAGE, 1, $hImage)
If $hPrevImage Then
If Not _WinAPI_DeleteObject($hPrevImage) Then _WinAPI_DestroyIcon($hPrevImage)
EndIf
_WinAPI_UpdateWindow($hWnd)
Return True
Else
Local $tIcon = DllStructCreate("handle Handle")
Local $iRet
If $bLarge Then
$iRet = _WinAPI_ExtractIconEx($sImageFile, $iIconID, $tIcon, 0, 1)
Else
$iRet = _WinAPI_ExtractIconEx($sImageFile, $iIconID, 0, $tIcon, 1)
EndIf
If Not $iRet Then Return SetError(-1, -1, False)
$hPrevImage = _SendMessage($hWnd, $BM_SETIMAGE, 1, DllStructGetData($tIcon, "Handle"))
If $hPrevImage Then
If Not _WinAPI_DeleteObject($hPrevImage) Then _WinAPI_DestroyIcon($hPrevImage)
EndIf
_WinAPI_UpdateWindow($hWnd)
Return True
EndIf
EndIf
Return False
EndFunc
Func _GUICtrlButton_SetImageList($hWnd, $hImage, $iAlign = 0, $iLeft = 1, $iTop = 1, $iRight = 1, $iBottom = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $iAlign < 0 Or $iAlign > 4 Then $iAlign = 0
Local $tBUTTON_IMAGELIST = DllStructCreate($tagBUTTON_IMAGELIST)
DllStructSetData($tBUTTON_IMAGELIST, "ImageList", $hImage)
DllStructSetData($tBUTTON_IMAGELIST, "Left", $iLeft)
DllStructSetData($tBUTTON_IMAGELIST, "Top", $iTop)
DllStructSetData($tBUTTON_IMAGELIST, "Right", $iRight)
DllStructSetData($tBUTTON_IMAGELIST, "Bottom", $iBottom)
DllStructSetData($tBUTTON_IMAGELIST, "Align", $iAlign)
Local $bEnabled = _GUICtrlButton_Enable($hWnd, False)
Local $iRet = _SendMessage($hWnd, $BCM_SETIMAGELIST, 0, $tBUTTON_IMAGELIST, 0, "wparam", "struct*") <> 0
_GUICtrlButton_Enable($hWnd)
If Not $bEnabled Then _GUICtrlButton_Enable($hWnd, False)
Return $iRet
EndFunc
Func _GUICtrlButton_SetNote($hWnd, $sNote)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tNote = _WinAPI_MultiByteToWideChar($sNote)
Return _SendMessage($hWnd, $BCM_SETNOTE, 0, $tNote, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlButton_SetShield($hWnd, $bRequired = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BCM_SETSHIELD, 0, $bRequired) = 1
EndFunc
Func _GUICtrlButton_SetSize($hWnd, $iWidth, $iHeight)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return SetError(-1, -1, False)
Local $hParent = _WinAPI_GetParent($hWnd)
If Not $hParent Then Return SetError(-1, -1, False)
Local $aPos = WinGetPos($hWnd)
If Not IsArray($aPos) Then Return SetError(-1, -1, False)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
If Not _WinAPI_ScreenToClient($hParent, $tPoint) Then Return SetError(-1, -1, False)
Local $iRet = WinMove($hWnd, "", DllStructGetData($tPoint, "X"), DllStructGetData($tPoint, "Y"), $iWidth, $iHeight)
Return SetError($iRet - 1, $iRet - 1, $iRet <> 0)
EndFunc
Func _GUICtrlButton_SetSplitInfo($hWnd, $hImlGlyph = -1, $iSplitStyle = $BCSS_ALIGNLEFT, $iWidth = 0, $iHeight = 0)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tSplitInfo = DllStructCreate($tagBUTTON_SPLITINFO), $iMask = 0
If $hImlGlyph <> -1 Then
$iMask = BitOR($iMask, $BCSIF_GLYPH)
DllStructSetData($tSplitInfo, "himlGlyph", $hImlGlyph)
EndIf
$iMask = BitOR($iMask, $BCSIF_STYLE)
If BitAND($iSplitStyle, $BCSS_IMAGE) = $BCSS_IMAGE Then $iMask = BitOR($iMask, $BCSIF_IMAGE)
DllStructSetData($tSplitInfo, "uSplitStyle", $iSplitStyle)
If $iWidth > 0 Or $iHeight > 0 Then
$iMask = BitOR($iMask, $BCSIF_SIZE)
DllStructSetData($tSplitInfo, "X", $iWidth)
DllStructSetData($tSplitInfo, "Y", $iHeight)
EndIf
DllStructSetData($tSplitInfo, "mask", $iMask)
Return _SendMessage($hWnd, $BCM_SETSPLITINFO, 0, $tSplitInfo, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlButton_SetState($hWnd, $bHighlighted = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_SETSTATE, $bHighlighted)
EndFunc
Func _GUICtrlButton_SetStyle($hWnd, $iStyle)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_SETSTYLE, $iStyle, True)
_WinAPI_UpdateWindow($hWnd)
EndFunc
Func _GUICtrlButton_SetText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_SetWindowText($hWnd, $sText)
EndFunc
Func _GUICtrlButton_SetTextMargin($hWnd, $iLeft = 1, $iTop = 1, $iRight = 1, $iBottom = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
Return _SendMessage($hWnd, $BCM_SETTEXTMARGIN, 0, $tRECT, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlButton_Show($hWnd, $bShow = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then
If $bShow Then
Return _WinAPI_ShowWindow($hWnd, @SW_SHOW)
Else
Return _WinAPI_ShowWindow($hWnd, @SW_HIDE)
EndIf
EndIf
EndFunc
Global Const $COLOR_AQUA = 0x00FFFF
Global Const $COLOR_BLACK = 0x000000
Global Const $COLOR_BLUE = 0x0000FF
Global Const $COLOR_CREAM = 0xFFFBF0
Global Const $COLOR_FUCHSIA = 0xFF00FF
Global Const $COLOR_GRAY = 0x808080
Global Const $COLOR_GREEN = 0x008000
Global Const $COLOR_LIME = 0x00FF00
Global Const $COLOR_MAROON = 0x8B1C62
Global Const $COLOR_MEDBLUE = 0x0002C4
Global Const $COLOR_MEDGRAY = 0xA0A0A4
Global Const $COLOR_MONEYGREEN = 0xC0DCC0
Global Const $COLOR_NAVY = 0x000080
Global Const $COLOR_OLIVE = 0x808000
Global Const $COLOR_PURPLE = 0x800080
Global Const $COLOR_RED = 0xFF0000
Global Const $COLOR_SILVER = 0xC0C0C0
Global Const $COLOR_SKYBLUE = 0xA6CAF0
Global Const $COLOR_TEAL = 0x008080
Global Const $COLOR_WHITE = 0xFFFFFF
Global Const $COLOR_YELLOW = 0xFFFF00
Global Const $CLR_NONE = 0xFFFFFFFF
Global Const $CLR_DEFAULT = 0xFF000000
Global Const $CLR_AQUA = 0xFFFF00
Global Const $CLR_BLACK = 0x000000
Global Const $CLR_BLUE = 0xFF0000
Global Const $CLR_CREAM = 0xF0FBFF
Global Const $CLR_FUCHSIA = 0xFF00FF
Global Const $CLR_GRAY = 0x808080
Global Const $CLR_GREEN = 0x008000
Global Const $CLR_LIME = 0x00FF00
Global Const $CLR_MAROON = 0x621C8B
Global Const $CLR_MEDBLUE = 0xC40200
Global Const $CLR_MEDGRAY = 0xA4A0A0
Global Const $CLR_MONEYGREEN = 0xC0DCC0
Global Const $CLR_NAVY = 0x800000
Global Const $CLR_OLIVE = 0x008080
Global Const $CLR_PURPLE = 0x800080
Global Const $CLR_RED = 0x0000FF
Global Const $CLR_SILVER = 0xC0C0C0
Global Const $CLR_SKYBLUE = 0xF0CAA6
Global Const $CLR_TEAL = 0x808000
Global Const $CLR_WHITE = 0xFFFFFF
Global Const $CLR_YELLOW = 0x00FFFF
Global Const $CC_ANYCOLOR = 0x0100
Global Const $CC_FULLOPEN = 0x0002
Global Const $CC_RGBINIT = 0x0001
Global Const $ILC_MASK = 0x00000001
Global Const $ILC_COLOR = 0x00000000
Global Const $ILC_COLORDDB = 0x000000FE
Global Const $ILC_COLOR4 = 0x00000004
Global Const $ILC_COLOR8 = 0x00000008
Global Const $ILC_COLOR16 = 0x00000010
Global Const $ILC_COLOR24 = 0x00000018
Global Const $ILC_COLOR32 = 0x00000020
Global Const $ILC_PALETTE = 0x00000800
Global Const $ILC_MIRROR = 0x00002000
Global Const $ILC_PERITEMMIRROR = 0x00008000
Global Const $ILCF_MOVE = 0x0
Global Const $ILCF_SWAP = 0x1
Global Const $ILD_NORMAL = 0x00000000
Global Const $ILD_TRANSPARENT = 0x00000001
Global Const $ILD_BLEND25 = 0x00000002
Global Const $ILD_BLEND50 = 0x00000004
Global Const $ILD_MASK = 0x00000010
Global Const $ILD_IMAGE = 0x00000020
Global Const $ILD_ROP = 0x00000040
Global Const $ILD_OVERLAYMASK = 0x00000F00
Global Const $ILS_NORMAL = 0x00000000
Global Const $ILS_GLOW = 0x00000001
Global Const $ILS_SHADOW = 0x00000002
Global Const $ILS_SATURATE = 0x00000004
Global Const $ILS_ALPHA = 0x00000008
Global Const $__IMAGELISTCONSTANT_IMAGE_BITMAP = 0
Func _GUIImageList_Add($hWnd, $hImage, $hMask = 0)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_Add", "handle", $hWnd, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_AddMasked($hWnd, $hImage, $iMask = 0)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_AddMasked", "handle", $hWnd, "handle", $hImage, "dword", $iMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_AddBitmap($hWnd, $sImage, $sMask = "")
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Local $hImage = _WinAPI_LoadImage(0, $sImage, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hImage = 0 Then Return SetError(_WinAPI_GetLastError(), 1, -1)
Local $hMask = 0
If $sMask <> "" Then
$hMask = _WinAPI_LoadImage(0, $sMask, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hMask = 0 Then Return SetError(_WinAPI_GetLastError(), 2, -1)
EndIf
Local $iRet = _GUIImageList_Add($hWnd, $hImage, $hMask)
_WinAPI_DeleteObject($hImage)
If $hMask <> 0 Then _WinAPI_DeleteObject($hMask)
Return $iRet
EndFunc
Func _GUIImageList_AddIcon($hWnd, $sFilePath, $iIndex = 0, $bLarge = False)
Local $iRet, $tIcon = DllStructCreate("handle Handle")
If $bLarge Then
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, $tIcon, 0, 1)
Else
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, 0, $tIcon, 1)
EndIf
If $iRet <= 0 Then Return SetError(-1, $iRet, -1)
Local $hIcon = DllStructGetData($tIcon, "Handle")
$iRet = _GUIImageList_ReplaceIcon($hWnd, -1, $hIcon)
_WinAPI_DestroyIcon($hIcon)
If $iRet = -1 Then Return SetError(-2, $iRet, -1)
Return $iRet
EndFunc
Func _GUIImageList_BeginDrag($hWnd, $iTrack, $iXHotSpot, $iYHotSpot)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_BeginDrag", "handle", $hWnd, "int", $iTrack, "int", $iXHotSpot, "int", $iYHotSpot)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Copy($hWnd, $iSource, $iDestination)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hWnd, "int", $iDestination, "handle", $hWnd, "int", $iSource, "uint", $ILCF_MOVE)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Create($iCX = 16, $iCY = 16, $iColor = 4, $iOptions = 0, $iInitial = 4, $iGrow = 4)
Local Const $aColor[7] = [$ILC_COLOR, $ILC_COLOR4, $ILC_COLOR8, $ILC_COLOR16, $ILC_COLOR24, $ILC_COLOR32, $ILC_COLORDDB]
Local $iFlags = 0
If BitAND($iOptions, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MASK)
If BitAND($iOptions, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MIRROR)
If BitAND($iOptions, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILC_PERITEMMIRROR)
$iFlags = BitOR($iFlags, $aColor[$iColor])
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", $iCX, "int", $iCY, "uint", $iFlags, "int", $iInitial, "int", $iGrow)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_Destroy($hWnd)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DestroyIcon($hIcon)
Return _WinAPI_DestroyIcon($hIcon)
EndFunc
Func _GUIImageList_DragEnter($hWnd, $iX, $iY)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragEnter", "hwnd", $hWnd, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DragLeave($hWnd)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragLeave", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DragMove($iX, $iY)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragMove", "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DragShowNolock($bShow)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragShowNolock", "bool", $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Draw($hWnd, $iIndex, $hDC, $iX, $iY, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DrawEx($hWnd, $iIndex, $hDC, $iX, $iY, $iDX = 0, $iDY = 0, $iRGBBk = 0xFFFFFFFF, $iRGBFg = 0xFFFFFFFF, $iStyle = 0)
If $iDX = -1 Then $iDX = 0
If $iDY = -1 Then $iDY = 0
If $iRGBBk = -1 Then $iRGBBk = 0xFFFFFFFF
If $iRGBFg = -1 Then $iRGBFg = 0xFFFFFFFF
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DrawEx", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY,  "int", $iDX, "int", $iDY, "dword", $iRGBBk, "dword", $iRGBFg, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Duplicate($hWnd)
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Duplicate", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_EndDrag()
DllCall("comctl32.dll", "none", "ImageList_EndDrag")
If @error Then Return SetError(@error, @extended)
EndFunc
Func _GUIImageList_GetBkColor($hWnd)
Local $aResult = DllCall("comctl32.dll", "dword", "ImageList_GetBkColor", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_GetIcon($hWnd, $iIndex, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hWnd, "int", $iIndex, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_GetIconHeight($hWnd)
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Return $aSize[1]
EndFunc
Func _GUIImageList_GetIconSize($hWnd)
Local $aSize[2]
Local $tPoint = _GUIImageList_GetIconSizeEx($hWnd)
$aSize[0] = DllStructGetData($tPoint, "X")
$aSize[1] = DllStructGetData($tPoint, "Y")
Return $aSize
EndFunc
Func _GUIImageList_GetIconSizeEx($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $pPointX = DllStructGetPtr($tPoint, "X")
Local $pPointY = DllStructGetPtr($tPoint, "Y")
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_GetIconSize", "hwnd", $hWnd, "struct*", $pPointX, "struct*", $pPointY)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tPoint)
EndFunc
Func _GUIImageList_GetIconWidth($hWnd)
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Return $aSize[0]
EndFunc
Func _GUIImageList_GetImageCount($hWnd)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_GetImageCount", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_GetImageInfoEx($hWnd, $iIndex)
Local $tImage = DllStructCreate($tagIMAGEINFO)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_GetImageInfo", "handle", $hWnd, "int", $iIndex, "struct*", $tImage)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tImage)
EndFunc
Func _GUIImageList_Merge($hWnd1, $iIndex1, $hWnd2, $iIndex2, $iDX, $iDY)
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Merge", "handle", $hWnd1, "int", $iIndex1,  "handle", $hWnd2, "int", $iIndex2, "int", $iDX, "int", $iDY)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_Remove($hWnd, $iIndex = -1)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Remove", "handle", $hWnd, "int", $iIndex)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Replace($hWnd, $iIndex, $hImage, $hMask = 0)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Replace", "handle", $hWnd, "int", $iIndex, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_ReplaceIcon($hWnd, $iIndex, $hIcon)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hWnd, "int", $iIndex, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_SetBkColor($hWnd, $iClrBk)
Local $aResult = DllCall("comctl32.dll", "dword", "ImageList_SetBkColor", "handle", $hWnd, "dword", $iClrBk)
If @error Then Return SetError(@error, @extended, $CLR_NONE)
Return $aResult[0]
EndFunc
Func _GUIImageList_SetDragCursorImage($hWnd, $iDrag, $iDXHotSpot, $iDYHotSpot)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetDragCursorImage", "handle", $hWnd, "int", $iDrag, "int", $iDXHotSpot, "int", $iDYHotSpot)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_SetIconSize($hWnd, $iCX, $iCY)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetIconSize", "handle", $hWnd, "int", $iCX, "int", $iCY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_SetImageCount($hWnd, $iNewCount)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetImageCount", "handle", $hWnd, "uint", $iNewCount)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_SetOverlayImage($hWnd, $iImage, $iOverlay)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $hWnd, "int", $iImage, "int", $iOverlay)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Swap($hWnd, $iSource, $iDestination)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hWnd, "int", $iDestination, "handle", $hWnd, "int", $iSource, "uint", $ILCF_SWAP)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Global Const $GMEM_FIXED = 0x0000
Global Const $GMEM_MOVEABLE = 0x0002
Global Const $GMEM_NOCOMPACT = 0x0010
Global Const $GMEM_NODISCARD = 0x0020
Global Const $GMEM_ZEROINIT = 0x0040
Global Const $GMEM_MODIFY = 0x0080
Global Const $GMEM_DISCARDABLE = 0x0100
Global Const $GMEM_NOT_BANKED = 0x1000
Global Const $GMEM_SHARE = 0x2000
Global Const $GMEM_DDESHARE = 0x2000
Global Const $GMEM_NOTIFY = 0x4000
Global Const $GMEM_LOWER = 0x1000
Global Const $GMEM_VALID_FLAGS = 0x7F72
Global Const $GMEM_INVALID_HANDLE = 0x8000
Global Const $GPTR = BitOR($GMEM_FIXED, $GMEM_ZEROINIT)
Global Const $GHND = BitOR($GMEM_MOVEABLE, $GMEM_ZEROINIT)
Global Const $MEM_COMMIT = 0x00001000
Global Const $MEM_RESERVE = 0x00002000
Global Const $MEM_TOP_DOWN = 0x00100000
Global Const $MEM_SHARED = 0x08000000
Global Const $PAGE_NOACCESS = 0x00000001
Global Const $PAGE_READONLY = 0x00000002
Global Const $PAGE_READWRITE = 0x00000004
Global Const $PAGE_EXECUTE = 0x00000010
Global Const $PAGE_EXECUTE_READ = 0x00000020
Global Const $PAGE_EXECUTE_READWRITE = 0x00000040
Global Const $PAGE_EXECUTE_WRITECOPY = 0x00000080
Global Const $PAGE_GUARD = 0x00000100
Global Const $PAGE_NOCACHE = 0x00000200
Global Const $PAGE_WRITECOMBINE = 0x00000400
Global Const $PAGE_WRITECOPY = 0x00000008
Global Const $MEM_DECOMMIT = 0x00004000
Global Const $MEM_RELEASE = 0x00008000
Global Const $tagMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
Func _MemFree(ByRef $tMemMap)
Local $pMemory = DllStructGetData($tMemMap, "Mem")
Local $hProcess = DllStructGetData($tMemMap, "hProc")
Local $bResult = _MemVirtualFreeEx($hProcess, $pMemory, 0, $MEM_RELEASE)
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $bResult
EndFunc
Func _MemGlobalAlloc($iBytes, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iFlags, "ulong_ptr", $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalFree($hMemory)
Local $aResult = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemGlobalLock($hMemory)
Local $aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalSize($hMemory)
Local $aResult = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalUnlock($hMemory)
Local $aResult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemInit($hWnd, $iSize, ByRef $tMemMap)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $iProcessID = $aResult[2]
If $iProcessID = 0 Then Return SetError(1, 0, 0)
Local $iAccess = BitOR($PROCESS_VM_OPERATION, $PROCESS_VM_READ, $PROCESS_VM_WRITE)
Local $hProcess = __Mem_OpenProcess($iAccess, False, $iProcessID, True)
Local $iAlloc = BitOR($MEM_RESERVE, $MEM_COMMIT)
Local $pMemory = _MemVirtualAllocEx($hProcess, 0, $iSize, $iAlloc, $PAGE_READWRITE)
If $pMemory = 0 Then Return SetError(2, 0, 0)
$tMemMap = DllStructCreate($tagMEMMAP)
DllStructSetData($tMemMap, "hProc", $hProcess)
DllStructSetData($tMemMap, "Size", $iSize)
DllStructSetData($tMemMap, "Mem", $pMemory)
Return $pMemory
EndFunc
Func _MemMoveMemory($pSource, $pDest, $iLength)
DllCall("kernel32.dll", "none", "RtlMoveMemory", "struct*", $pDest, "struct*", $pSource, "ulong_ptr", $iLength)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _MemRead(ByRef $tMemMap, $pSrce, $pDest, $iSize)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"),  "ptr", $pSrce, "struct*", $pDest, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemWrite(ByRef $tMemMap, $pSrce, $pDest = 0, $iSize = 0, $sSrce = "struct*")
If $pDest = 0 Then $pDest = DllStructGetData($tMemMap, "Mem")
If $iSize = 0 Then $iSize = DllStructGetData($tMemMap, "Size")
Local $aResult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"),  "ptr", $pDest, $sSrce, $pSrce, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualAlloc($pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualAllocEx($hProcess, $pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualFree($pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualFreeEx($hProcess, $pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func __Mem_OpenProcess($iAccess, $bInherit, $iProcessID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iProcessID)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return 0
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 20, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iLastError = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iProcessID)
$iError = @error
$iLastError = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 30
$iLastError = @extended
EndIf
Else
$iError = @error + 40
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iLastError, $iRet)
EndFunc
Global Const $SBARS_SIZEGRIP = 0x100
Global Const $SBT_TOOLTIPS = 0x800
Global Const $SBARS_TOOLTIPS = 0x800
Global Const $SBT_SUNKEN = 0x0
Global Const $SBT_NOBORDERS = 0x100
Global Const $SBT_POPOUT = 0x200
Global Const $SBT_RTLREADING = 0x400
Global Const $SBT_NOTABPARSING = 0x800
Global Const $SBT_OWNERDRAW = 0x1000
Global Const $__STATUSBARCONSTANT_WM_USER = 0X400
Global Const $SB_GETBORDERS = ($__STATUSBARCONSTANT_WM_USER + 7)
Global Const $SB_GETICON = ($__STATUSBARCONSTANT_WM_USER + 20)
Global Const $SB_GETPARTS = ($__STATUSBARCONSTANT_WM_USER + 6)
Global Const $SB_GETRECT = ($__STATUSBARCONSTANT_WM_USER + 10)
Global Const $SB_GETTEXTA = ($__STATUSBARCONSTANT_WM_USER + 2)
Global Const $SB_GETTEXTW = ($__STATUSBARCONSTANT_WM_USER + 13)
Global Const $SB_GETTEXT = $SB_GETTEXTA
Global Const $SB_GETTEXTLENGTHA = ($__STATUSBARCONSTANT_WM_USER + 3)
Global Const $SB_GETTEXTLENGTHW = ($__STATUSBARCONSTANT_WM_USER + 12)
Global Const $SB_GETTEXTLENGTH = $SB_GETTEXTLENGTHA
Global Const $SB_GETTIPTEXTA = ($__STATUSBARCONSTANT_WM_USER + 18)
Global Const $SB_GETTIPTEXTW = ($__STATUSBARCONSTANT_WM_USER + 19)
Global Const $SB_GETUNICODEFORMAT = 0x2000 + 6
Global Const $SB_ISSIMPLE = ($__STATUSBARCONSTANT_WM_USER + 14)
Global Const $SB_SETBKCOLOR = 0x2000 + 1
Global Const $SB_SETICON = ($__STATUSBARCONSTANT_WM_USER + 15)
Global Const $SB_SETMINHEIGHT = ($__STATUSBARCONSTANT_WM_USER + 8)
Global Const $SB_SETPARTS = ($__STATUSBARCONSTANT_WM_USER + 4)
Global Const $SB_SETTEXTA = ($__STATUSBARCONSTANT_WM_USER + 1)
Global Const $SB_SETTEXTW = ($__STATUSBARCONSTANT_WM_USER + 11)
Global Const $SB_SETTEXT = $SB_SETTEXTA
Global Const $SB_SETTIPTEXTA = ($__STATUSBARCONSTANT_WM_USER + 16)
Global Const $SB_SETTIPTEXTW = ($__STATUSBARCONSTANT_WM_USER + 17)
Global Const $SB_SETUNICODEFORMAT = 0x2000 + 5
Global Const $SB_SIMPLE = ($__STATUSBARCONSTANT_WM_USER + 9)
Global Const $SB_SIMPLEID = 0xff
Global Const $SBN_FIRST = -880
Global Const $SBN_SIMPLEMODECHANGE = $SBN_FIRST - 0
Global $__g_hSBLastWnd
Global Const $__STATUSBARCONSTANT_ClassName = "msctls_statusbar32"
Global Const $__STATUSBARCONSTANT_WM_SIZE = 0x05
Global Const $__STATUSBARCONSTANT_CLR_DEFAULT = 0xFF000000
Global Const $tagBORDERS = "int BX;int BY;int RX"
Func _GUICtrlStatusBar_Create($hWnd, $vPartEdge = -1, $vPartText = "", $iStyles = -1, $iExStyles = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
Local $iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If $iStyles = -1 Then $iStyles = 0x00000000
If $iExStyles = -1 Then $iExStyles = 0x00000000
Local $aPartWidth[1], $aPartText[1]
If @NumParams > 1 Then
If IsArray($vPartEdge) Then
$aPartWidth = $vPartEdge
Else
$aPartWidth[0] = $vPartEdge
EndIf
If @NumParams = 2 Then
ReDim $aPartText[UBound($aPartWidth)]
Else
If IsArray($vPartText) Then
$aPartText = $vPartText
Else
$aPartText[0] = $vPartText
EndIf
If UBound($aPartWidth) <> UBound($aPartText) Then
Local $iLast
If UBound($aPartWidth) > UBound($aPartText) Then
$iLast = UBound($aPartText)
ReDim $aPartText[UBound($aPartWidth)]
Else
$iLast = UBound($aPartWidth)
ReDim $aPartWidth[UBound($aPartText)]
For $x = $iLast To UBound($aPartWidth) - 1
$aPartWidth[$x] = $aPartWidth[$x - 1] + 75
Next
$aPartWidth[UBound($aPartText) - 1] = -1
EndIf
EndIf
EndIf
If Not IsHWnd($hWnd) Then $hWnd = HWnd($hWnd)
If @NumParams > 3 Then $iStyle = BitOR($iStyle, $iStyles)
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hWndSBar = _WinAPI_CreateWindowEx($iExStyles, $__STATUSBARCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
If @error Then Return SetError(@error, @extended, 0)
If @NumParams > 1 Then
_GUICtrlStatusBar_SetParts($hWndSBar, UBound($aPartWidth), $aPartWidth)
For $x = 0 To UBound($aPartText) - 1
_GUICtrlStatusBar_SetText($hWndSBar, $aPartText[$x], $x)
Next
EndIf
Return $hWndSBar
EndFunc
Func _GUICtrlStatusBar_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__STATUSBARCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlStatusBar_EmbedControl($hWnd, $iPart, $hControl, $iFit = 4)
Local $aRect = _GUICtrlStatusBar_GetRect($hWnd, $iPart)
Local $iBarX = $aRect[0]
Local $iBarY = $aRect[1]
Local $iBarW = $aRect[2] - $iBarX
Local $iBarH = $aRect[3] - $iBarY
Local $iConX = $iBarX
Local $iConY = $iBarY
Local $iConW = _WinAPI_GetWindowWidth($hControl)
Local $iConH = _WinAPI_GetWindowHeight($hControl)
If $iConW > $iBarW Then $iConW = $iBarW
If $iConH > $iBarH Then $iConH = $iBarH
Local $iPadX = ($iBarW - $iConW) / 2
Local $iPadY = ($iBarH - $iConH) / 2
If $iPadX < 0 Then $iPadX = 0
If $iPadY < 0 Then $iPadY = 0
If BitAND($iFit, 1) = 1 Then $iConX = $iBarX + $iPadX
If BitAND($iFit, 2) = 2 Then $iConY = $iBarY + $iPadY
If BitAND($iFit, 4) = 4 Then
$iPadX = _GUICtrlStatusBar_GetBordersRect($hWnd)
$iPadY = _GUICtrlStatusBar_GetBordersVert($hWnd)
$iConX = $iBarX
If _GUICtrlStatusBar_IsSimple($hWnd) Then $iConX += $iPadX
$iConY = $iBarY + $iPadY
$iConW = $iBarW - ($iPadX * 2)
$iConH = $iBarH - ($iPadY * 2)
EndIf
_WinAPI_SetParent($hControl, $hWnd)
_WinAPI_MoveWindow($hControl, $iConX, $iConY, $iConW, $iConH)
EndFunc
Func _GUICtrlStatusBar_GetBorders($hWnd)
Local $tBorders = DllStructCreate($tagBORDERS)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$iRet = _SendMessage($hWnd, $SB_GETBORDERS, 0, $tBorders, 0, "wparam", "struct*")
Else
Local $iSize = DllStructGetSize($tBorders)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
$iRet = _SendMessage($hWnd, $SB_GETBORDERS, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBorders, $iSize)
_MemFree($tMemMap)
EndIf
Local $aBorders[3]
If $iRet = 0 Then Return SetError(-1, -1, $aBorders)
$aBorders[0] = DllStructGetData($tBorders, "BX")
$aBorders[1] = DllStructGetData($tBorders, "BY")
$aBorders[2] = DllStructGetData($tBorders, "RX")
Return $aBorders
EndFunc
Func _GUICtrlStatusBar_GetBordersHorz($hWnd)
Local $aBorders = _GUICtrlStatusBar_GetBorders($hWnd)
Return SetError(@error, @extended, $aBorders[0])
EndFunc
Func _GUICtrlStatusBar_GetBordersRect($hWnd)
Local $aBorders = _GUICtrlStatusBar_GetBorders($hWnd)
Return SetError(@error, @extended, $aBorders[2])
EndFunc
Func _GUICtrlStatusBar_GetBordersVert($hWnd)
Local $aBorders = _GUICtrlStatusBar_GetBorders($hWnd)
Return SetError(@error, @extended, $aBorders[1])
EndFunc
Func _GUICtrlStatusBar_GetCount($hWnd)
Return _SendMessage($hWnd, $SB_GETPARTS)
EndFunc
Func _GUICtrlStatusBar_GetHeight($hWnd)
Local $tRECT = _GUICtrlStatusBar_GetRectEx($hWnd, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top") - (_GUICtrlStatusBar_GetBordersVert($hWnd) * 2)
EndFunc
Func _GUICtrlStatusBar_GetIcon($hWnd, $iIndex = 0)
Return _SendMessage($hWnd, $SB_GETICON, $iIndex, 0, 0, "wparam", "lparam", "handle")
EndFunc
Func _GUICtrlStatusBar_GetParts($hWnd)
Local $iCount = _GUICtrlStatusBar_GetCount($hWnd)
Local $tParts = DllStructCreate("int[" & $iCount & "]")
Local $aParts[$iCount + 1]
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$aParts[0] = _SendMessage($hWnd, $SB_GETPARTS, $iCount, $tParts, 0, "wparam", "struct*")
Else
Local $iParts = DllStructGetSize($tParts)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iParts, $tMemMap)
$aParts[0] = _SendMessage($hWnd, $SB_GETPARTS, $iCount, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tParts, $iParts)
_MemFree($tMemMap)
EndIf
For $iI = 1 To $iCount
$aParts[$iI] = DllStructGetData($tParts, 1, $iI)
Next
Return $aParts
EndFunc
Func _GUICtrlStatusBar_GetRect($hWnd, $iPart)
Local $tRECT = _GUICtrlStatusBar_GetRectEx($hWnd, $iPart)
If @error Then Return SetError(@error, 0, 0)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlStatusBar_GetRectEx($hWnd, $iPart)
Local $tRECT = DllStructCreate($tagRECT)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$iRet = _SendMessage($hWnd, $SB_GETRECT, $iPart, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
$iRet = _SendMessage($hWnd, $SB_GETRECT, $iPart, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Return SetError($iRet = 0, 0, $tRECT)
EndFunc
Func _GUICtrlStatusBar_GetText($hWnd, $iPart)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $iBuffer = _GUICtrlStatusBar_GetTextLength($hWnd, $iPart) + 1
If $iBuffer = 1 Then Return SetError(1, 0, "")
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_GETTEXTW, $iPart, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
If $bUnicode Then
_SendMessage($hWnd, $SB_GETTEXTW, $iPart, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $SB_GETTEXT, $iPart, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlStatusBar_GetTextFlags($hWnd, $iPart)
If _GUICtrlStatusBar_GetUnicodeFormat($hWnd) Then
Return _SendMessage($hWnd, $SB_GETTEXTLENGTHW, $iPart)
Else
Return _SendMessage($hWnd, $SB_GETTEXTLENGTH, $iPart)
EndIf
EndFunc
Func _GUICtrlStatusBar_GetTextLength($hWnd, $iPart)
Return _WinAPI_LoWord(_GUICtrlStatusBar_GetTextFlags($hWnd, $iPart))
EndFunc
Func _GUICtrlStatusBar_GetTextLengthEx($hWnd, $iPart)
Return _WinAPI_HiWord(_GUICtrlStatusBar_GetTextFlags($hWnd, $iPart))
EndFunc
Func _GUICtrlStatusBar_GetTipText($hWnd, $iPart)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_GETTIPTEXTW, _WinAPI_MakeLong($iPart, 4096), $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, 4096, $tMemMap)
If $bUnicode Then
_SendMessage($hWnd, $SB_GETTIPTEXTW, _WinAPI_MakeLong($iPart, 4096), $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $SB_GETTIPTEXTA, _WinAPI_MakeLong($iPart, 4096), $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, 4096)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Return _SendMessage($hWnd, $SB_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlStatusBar_GetWidth($hWnd, $iPart)
Local $tRECT = _GUICtrlStatusBar_GetRectEx($hWnd, $iPart)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left") - (_GUICtrlStatusBar_GetBordersHorz($hWnd) * 2)
EndFunc
Func _GUICtrlStatusBar_IsSimple($hWnd)
Return _SendMessage($hWnd, $SB_ISSIMPLE) <> 0
EndFunc
Func _GUICtrlStatusBar_Resize($hWnd)
_SendMessage($hWnd, $__STATUSBARCONSTANT_WM_SIZE)
EndFunc
Func _GUICtrlStatusBar_SetBkColor($hWnd, $iColor)
$iColor = _SendMessage($hWnd, $SB_SETBKCOLOR, 0, $iColor)
If $iColor = $__STATUSBARCONSTANT_CLR_DEFAULT Then Return '0x' & Hex($__STATUSBARCONSTANT_CLR_DEFAULT)
Return $iColor
EndFunc
Func _GUICtrlStatusBar_SetIcon($hWnd, $iPart, $hIcon = -1, $sIconFile = "")
If $hIcon = -1 Then Return _SendMessage($hWnd, $SB_SETICON, $iPart, $hIcon, 0, "wparam", "handle") <> 0
If StringLen($sIconFile) <= 0 Then Return _SendMessage($hWnd, $SB_SETICON, $iPart, $hIcon) <> 0
Local $tIcon = DllStructCreate("handle")
Local $vResult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sIconFile, "int", $hIcon, "ptr", 0, "struct*", $tIcon, "uint", 1)
If @error Then Return SetError(@error, @extended, False)
$vResult = $vResult[0]
If $vResult > 0 Then $vResult = _SendMessage($hWnd, $SB_SETICON, $iPart, DllStructGetData($tIcon, 1), 0, "wparam", "handle")
DllCall("user32.dll", "bool", "DestroyIcon", "handle", DllStructGetData($tIcon, 1))
Return $vResult
EndFunc
Func _GUICtrlStatusBar_SetMinHeight($hWnd, $iMinHeight)
_SendMessage($hWnd, $SB_SETMINHEIGHT, $iMinHeight)
_GUICtrlStatusBar_Resize($hWnd)
EndFunc
Func _GUICtrlStatusBar_SetParts($hWnd, $aParts = -1, $aPartWidth = 25)
Local $tParts, $iParts = 1
If IsArray($aParts) <> 0 Then
$aParts[UBound($aParts) - 1] = -1
$iParts = UBound($aParts)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $aParts[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf IsArray($aPartWidth) <> 0 Then
$iParts = UBound($aPartWidth)
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 0 To $iParts - 2
DllStructSetData($tParts, 1, $aPartWidth[$x], $x + 1)
Next
DllStructSetData($tParts, 1, -1, $iParts)
ElseIf $aParts > 1 Then
$iParts = $aParts
$tParts = DllStructCreate("int[" & $iParts & "]")
For $x = 1 To $iParts - 1
DllStructSetData($tParts, 1, $aPartWidth * $x, $x)
Next
DllStructSetData($tParts, 1, -1, $iParts)
Else
$tParts = DllStructCreate("int")
DllStructSetData($tParts, $iParts, -1)
EndIf
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $tParts, 0, "wparam", "struct*")
Else
Local $iSize = DllStructGetSize($tParts)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tParts)
_SendMessage($hWnd, $SB_SETPARTS, $iParts, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
_GUICtrlStatusBar_Resize($hWnd)
Return True
EndFunc
Func _GUICtrlStatusBar_SetSimple($hWnd, $bSimple = True)
_SendMessage($hWnd, $SB_SIMPLE, $bSimple)
EndFunc
Func _GUICtrlStatusBar_SetText($hWnd, $sText = "", $iPart = 0, $iUFlag = 0)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tText
If $bUnicode Then
$tText = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tText = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tText, "Text", $sText)
If _GUICtrlStatusBar_IsSimple($hWnd) Then $iPart = $SB_SIMPLEID
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $tText, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tText)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $SB_SETTEXTW, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $SB_SETTEXT, BitOR($iPart, $iUFlag), $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlStatusBar_SetTipText($hWnd, $iPart, $sText)
Local $bUnicode = _GUICtrlStatusBar_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tText
If $bUnicode Then
$tText = DllStructCreate("wchar TipText[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tText = DllStructCreate("char TipText[" & $iBuffer & "]")
EndIf
DllStructSetData($tText, "TipText", $sText)
If _WinAPI_InProcess($hWnd, $__g_hSBLastWnd) Then
_SendMessage($hWnd, $SB_SETTIPTEXTW, $iPart, $tText, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tText, $pMemory, $iBuffer)
If $bUnicode Then
_SendMessage($hWnd, $SB_SETTIPTEXTW, $iPart, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $SB_SETTIPTEXTA, $iPart, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUICtrlStatusBar_SetUnicodeFormat($hWnd, $bUnicode = True)
Return _SendMessage($hWnd, $SB_SETUNICODEFORMAT, $bUnicode)
EndFunc
Func _GUICtrlStatusBar_ShowHide($hWnd, $iState)
If $iState <> @SW_HIDE And $iState <> @SW_SHOW Then Return SetError(1, 1, False)
Return _WinAPI_ShowWindow($hWnd, $iState)
EndFunc
Global Const $TTF_IDISHWND = 0x00000001
Global Const $TTF_CENTERTIP = 0x00000002
Global Const $TTF_RTLREADING = 0x00000004
Global Const $TTF_SUBCLASS = 0x00000010
Global Const $TTF_TRACK = 0x00000020
Global Const $TTF_ABSOLUTE = 0x00000080
Global Const $TTF_TRANSPARENT = 0x00000100
Global Const $TTF_PARSELINKS = 0x00001000
Global Const $TTF_DI_SETITEM = 0x00008000
Global Const $__TOOLTIPCONSTANTS_WM_USER = 0X400
Global Const $TTM_ACTIVATE = $__TOOLTIPCONSTANTS_WM_USER + 1
Global Const $TTM_SETDELAYTIME = $__TOOLTIPCONSTANTS_WM_USER + 3
Global Const $TTM_ADDTOOL = $__TOOLTIPCONSTANTS_WM_USER + 4
Global Const $TTM_DELTOOL = $__TOOLTIPCONSTANTS_WM_USER + 5
Global Const $TTM_NEWTOOLRECT = $__TOOLTIPCONSTANTS_WM_USER + 6
Global Const $TTM_GETTOOLINFO = $__TOOLTIPCONSTANTS_WM_USER + 8
Global Const $TTM_SETTOOLINFO = $__TOOLTIPCONSTANTS_WM_USER + 9
Global Const $TTM_HITTEST = $__TOOLTIPCONSTANTS_WM_USER + 10
Global Const $TTM_GETTEXT = $__TOOLTIPCONSTANTS_WM_USER + 11
Global Const $TTM_UPDATETIPTEXT = $__TOOLTIPCONSTANTS_WM_USER + 12
Global Const $TTM_GETTOOLCOUNT = $__TOOLTIPCONSTANTS_WM_USER + 13
Global Const $TTM_ENUMTOOLS = $__TOOLTIPCONSTANTS_WM_USER + 14
Global Const $TTM_GETCURRENTTOOL = $__TOOLTIPCONSTANTS_WM_USER + 15
Global Const $TTM_WINDOWFROMPOINT = $__TOOLTIPCONSTANTS_WM_USER + 16
Global Const $TTM_TRACKACTIVATE = $__TOOLTIPCONSTANTS_WM_USER + 17
Global Const $TTM_TRACKPOSITION = $__TOOLTIPCONSTANTS_WM_USER + 18
Global Const $TTM_SETTIPBKCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 19
Global Const $TTM_SETTIPTEXTCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 20
Global Const $TTM_GETDELAYTIME = $__TOOLTIPCONSTANTS_WM_USER + 21
Global Const $TTM_GETTIPBKCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 22
Global Const $TTM_GETTIPTEXTCOLOR = $__TOOLTIPCONSTANTS_WM_USER + 23
Global Const $TTM_SETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 24
Global Const $TTM_GETMAXTIPWIDTH = $__TOOLTIPCONSTANTS_WM_USER + 25
Global Const $TTM_SETMARGIN = $__TOOLTIPCONSTANTS_WM_USER + 26
Global Const $TTM_GETMARGIN = $__TOOLTIPCONSTANTS_WM_USER + 27
Global Const $TTM_POP = $__TOOLTIPCONSTANTS_WM_USER + 28
Global Const $TTM_UPDATE = $__TOOLTIPCONSTANTS_WM_USER + 29
Global Const $TTM_GETBUBBLESIZE = $__TOOLTIPCONSTANTS_WM_USER + 30
Global Const $TTM_ADJUSTRECT = $__TOOLTIPCONSTANTS_WM_USER + 31
Global Const $TTM_SETTITLE = $__TOOLTIPCONSTANTS_WM_USER + 32
Global Const $TTM_SETTITLEW = $__TOOLTIPCONSTANTS_WM_USER + 33
Global Const $TTM_POPUP = $__TOOLTIPCONSTANTS_WM_USER + 34
Global Const $TTM_GETTITLE = $__TOOLTIPCONSTANTS_WM_USER + 35
Global Const $TTM_ADDTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 50
Global Const $TTM_DELTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 51
Global Const $TTM_NEWTOOLRECTW = $__TOOLTIPCONSTANTS_WM_USER + 52
Global Const $TTM_GETTOOLINFOW = $__TOOLTIPCONSTANTS_WM_USER + 53
Global Const $TTM_SETTOOLINFOW = $__TOOLTIPCONSTANTS_WM_USER + 54
Global Const $TTM_HITTESTW = $__TOOLTIPCONSTANTS_WM_USER + 55
Global Const $TTM_GETTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 56
Global Const $TTM_UPDATETIPTEXTW = $__TOOLTIPCONSTANTS_WM_USER + 57
Global Const $TTM_ENUMTOOLSW = $__TOOLTIPCONSTANTS_WM_USER + 58
Global Const $TTM_GETCURRENTTOOLW = $__TOOLTIPCONSTANTS_WM_USER + 59
Global Const $TTM_SETWINDOWTHEME = 0x2000 + 11
Global Const $TTN_FIRST = -520
Global Const $TTN_GETDISPINFO = $TTN_FIRST - 0
Global Const $TTN_SHOW = $TTN_FIRST - 1
Global Const $TTN_POP = $TTN_FIRST - 2
Global Const $TTN_LINKCLICK = $TTN_FIRST - 3
Global Const $TTN_GETDISPINFOW = $TTN_FIRST - 10
Global Const $TTS_ALWAYSTIP = 0x00000001
Global Const $TTS_NOPREFIX = 0x00000002
Global Const $TTS_NOANIMATE = 0x00000010
Global Const $TTS_NOFADE = 0x00000020
Global Const $TTS_BALLOON = 0x00000040
Global Const $TTS_CLOSE = 0x00000080
Global Const $TTS_USEVISUALSTYLE = 0x00000100
Global Const $TTDT_AUTOMATIC = 0
Global Const $TTDT_RESHOW = 1
Global Const $TTDT_AUTOPOP = 2
Global Const $TTDT_INITIAL = 3
Global Enum $TTI_NONE, $TTI_INFO, $TTI_WARNING, $TTI_ERROR, $TTI_INFO_LARGE, $TTI_WARNING_LARGE, $TTI_ERROR_LARGE
Global $__g_hEditLastWnd
Global Const $__EDITCONSTANT_ClassName = "Edit"
Global Const $__EDITCONSTANT_GUI_CHECKED = 1
Global Const $__EDITCONSTANT_GUI_HIDE = 32
Global Const $__EDITCONSTANT_GUI_EVENT_CLOSE = -3
Global Const $__EDITCONSTANT_GUI_ENABLE = 64
Global Const $__EDITCONSTANT_GUI_DISABLE = 128
Global Const $__EDITCONSTANT_SS_CENTER = 1
Global Const $__EDITCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__EDITCONSTANT_WS_CAPTION = 0x00C00000
Global Const $__EDITCONSTANT_WS_POPUP = 0x80000000
Global Const $__EDITCONSTANT_WS_SYSMENU = 0x00080000
Global Const $__EDITCONSTANT_WS_MINIMIZEBOX = 0x00020000
Global Const $__EDITCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__EDITCONSTANT_WM_SETFONT = 0x0030
Global Const $__EDITCONSTANT_WM_GETTEXTLENGTH = 0x000E
Global Const $__EDITCONSTANT_WM_GETTEXT = 0x000D
Global Const $__EDITCONSTANT_WM_SETTEXT = 0x000C
Global Const $__EDITCONSTANT_SB_LINEUP = 0
Global Const $__EDITCONSTANT_SB_LINEDOWN = 1
Global Const $__EDITCONSTANT_SB_PAGEDOWN = 3
Global Const $__EDITCONSTANT_SB_PAGEUP = 2
Global Const $__EDITCONSTANT_SB_SCROLLCARET = 4
Global Const $__tagEDITBALLOONTIP = "dword Size;ptr Title;ptr Text;int Icon"
Func _GUICtrlEdit_AppendText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLength = _GUICtrlEdit_GetTextLen($hWnd)
_GUICtrlEdit_SetSel($hWnd, $iLength, $iLength)
_SendMessage($hWnd, $EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlEdit_CanUndo($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_CANUNDO) <> 0
EndFunc
Func _GUICtrlEdit_CharFromPos($hWnd, $iX, $iY)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aReturn[2]
Local $iRet = _SendMessage($hWnd, $EM_CHARFROMPOS, 0, _WinAPI_MakeLong($iX, $iY))
$aReturn[0] = _WinAPI_LoWord($iRet)
$aReturn[1] = _WinAPI_HiWord($iRet)
Return $aReturn
EndFunc
Func _GUICtrlEdit_Create($hWnd, $sText, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x003010C4, $iExStyle = 0x00000200)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = 0x003010C4
If $iExStyle = -1 Then $iExStyle = 0x00000200
If BitAND($iStyle, $ES_READONLY) = $ES_READONLY Then
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $iStyle)
Else
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_TABSTOP, $iStyle)
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hEdit = _WinAPI_CreateWindowEx($iExStyle, $__EDITCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hEdit, $__EDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__EDITCONSTANT_DEFAULT_GUI_FONT), True)
_GUICtrlEdit_SetText($hEdit, $sText)
_GUICtrlEdit_SetLimitText($hEdit, 0)
Return $hEdit
EndFunc
Func _GUICtrlEdit_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__EDITCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hEditLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlEdit_EmptyUndoBuffer($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_EMPTYUNDOBUFFER)
EndFunc
Func _GUICtrlEdit_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlEdit_FmtLines($hWnd, $bSoftBreak = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_FMTLINES, $bSoftBreak)
EndFunc
Func _GUICtrlEdit_Find($hWnd, $bReplace = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iPos = 0, $iCase, $iOccurance = 0, $iReplacements = 0
Local $aPartsRightEdge[3] = [125, 225, -1]
Local $iOldMode = Opt("GUIOnEventMode", 0)
Local $aSel = _GUICtrlEdit_GetSel($hWnd)
Local $sText = _GUICtrlEdit_GetText($hWnd)
Local $hGuiSearch = GUICreate("Find", 349, 177, -1, -1, BitOR($__UDFGUICONSTANT_WS_CHILD, $__EDITCONSTANT_WS_MINIMIZEBOX, $__EDITCONSTANT_WS_CAPTION, $__EDITCONSTANT_WS_POPUP, $__EDITCONSTANT_WS_SYSMENU))
Local $idStatusBar1 = _GUICtrlStatusBar_Create($hGuiSearch, $aPartsRightEdge)
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: ")
GUISetIcon(@SystemDir & "\shell32.dll", 22, $hGuiSearch)
GUICtrlCreateLabel("Find what:", 9, 10, 53, 16, $__EDITCONSTANT_SS_CENTER)
Local $idInputSearch = GUICtrlCreateInput("", 80, 8, 257, 21)
Local $idLblReplace = GUICtrlCreateLabel("Replace with:", 9, 42, 69, 17, $__EDITCONSTANT_SS_CENTER)
Local $idInputReplace = GUICtrlCreateInput("", 80, 40, 257, 21)
Local $idChkWholeOnly = GUICtrlCreateCheckbox("Match whole word only", 9, 72, 145, 17)
Local $idChkMatchCase = GUICtrlCreateCheckbox("Match case", 9, 96, 145, 17)
Local $idBtnFindNext = GUICtrlCreateButton("Find Next", 168, 72, 161, 21, 0)
Local $idBtnReplace = GUICtrlCreateButton("Replace", 168, 96, 161, 21, 0)
Local $idBtnClose = GUICtrlCreateButton("Close", 104, 130, 161, 21, 0)
If (IsArray($aSel) And $aSel <> $EC_ERR) Then
GUICtrlSetData($idInputSearch, StringMid($sText, $aSel[0] + 1, $aSel[1] - $aSel[0]))
If $aSel[0] <> $aSel[1] Then
$iPos = $aSel[0]
If BitAND(GUICtrlRead($idChkMatchCase), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iCase = 1
$iOccurance = 1
Local $iTPose
While 1
$iTPose = StringInStr($sText, GUICtrlRead($idInputSearch), $iCase, $iOccurance)
If Not $iTPose Then
$iOccurance = 0
ExitLoop
ElseIf $iTPose = $iPos + 1 Then
ExitLoop
EndIf
$iOccurance += 1
WEnd
EndIf
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
EndIf
If $bReplace = False Then
GUICtrlSetState($idLblReplace, $__EDITCONSTANT_GUI_HIDE)
GUICtrlSetState($idInputReplace, $__EDITCONSTANT_GUI_HIDE)
GUICtrlSetState($idBtnReplace, $__EDITCONSTANT_GUI_HIDE)
Else
_GUICtrlStatusBar_SetText($idStatusBar1, "Replacements: " & $iReplacements, 1)
_GUICtrlStatusBar_SetText($idStatusBar1, "With: ", 2)
EndIf
GUISetState(@SW_SHOW)
Local $iMsgFind
While 1
$iMsgFind = GUIGetMsg()
Select
Case $iMsgFind = $__EDITCONSTANT_GUI_EVENT_CLOSE Or $iMsgFind = $idBtnClose
ExitLoop
Case $iMsgFind = $idBtnFindNext
GUICtrlSetState($idBtnFindNext, $__EDITCONSTANT_GUI_DISABLE)
GUICtrlSetCursor($idBtnFindNext, 15)
Sleep(100)
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
If $bReplace = True Then
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
_GUICtrlStatusBar_SetText($idStatusBar1, "With: " & GUICtrlRead($idInputReplace), 2)
EndIf
__GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, $iPos, $iOccurance, $iReplacements)
Sleep(100)
GUICtrlSetState($idBtnFindNext, $__EDITCONSTANT_GUI_ENABLE)
GUICtrlSetCursor($idBtnFindNext, 2)
Case $iMsgFind = $idBtnReplace
GUICtrlSetState($idBtnReplace, $__EDITCONSTANT_GUI_DISABLE)
GUICtrlSetCursor($idBtnReplace, 15)
Sleep(100)
_GUICtrlStatusBar_SetText($idStatusBar1, "Find: " & GUICtrlRead($idInputSearch))
_GUICtrlStatusBar_SetText($idStatusBar1, "With: " & GUICtrlRead($idInputReplace), 2)
If $iPos Then
_GUICtrlEdit_ReplaceSel($hWnd, GUICtrlRead($idInputReplace))
$iReplacements += 1
$iOccurance -= 1
_GUICtrlStatusBar_SetText($idStatusBar1, "Replacements: " & $iReplacements, 1)
EndIf
__GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, $iPos, $iOccurance, $iReplacements)
Sleep(100)
GUICtrlSetState($idBtnReplace, $__EDITCONSTANT_GUI_ENABLE)
GUICtrlSetCursor($idBtnReplace, 2)
EndSelect
WEnd
GUIDelete($hGuiSearch)
Opt("GUIOnEventMode", $iOldMode)
EndFunc
Func _GUICtrlEdit_GetCueBanner($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = DllStructCreate("wchar[4096]")
If _SendMessage($hWnd, $EM_GETCUEBANNER, $tText, 4096, 0, "struct*") <> 1 Then Return SetError(-1, 0, "")
Return _WinAPI_WideCharToMultiByte($tText)
EndFunc
Func __GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, ByRef $iPos, ByRef $iOccurance, ByRef $iReplacements)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iCase = 0, $iWhole = 0
Local $bExact = False
Local $sFind = GUICtrlRead($idInputSearch)
Local $sText = _GUICtrlEdit_GetText($hWnd)
If BitAND(GUICtrlRead($idChkMatchCase), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iCase = 1
If BitAND(GUICtrlRead($idChkWholeOnly), $__EDITCONSTANT_GUI_CHECKED) = $__EDITCONSTANT_GUI_CHECKED Then $iWhole = 1
If $sFind <> "" Then
$iOccurance += 1
$iPos = StringInStr($sText, $sFind, $iCase, $iOccurance)
If $iWhole And $iPos Then
Local $s_Compare2 = StringMid($sText, $iPos + StringLen($sFind), 1)
If $iPos = 1 Then
If ($iPos + StringLen($sFind)) - 1 = StringLen($sText) Or  ($s_Compare2 = " " Or $s_Compare2 = @LF Or $s_Compare2 = @CR Or  $s_Compare2 = @CRLF Or $s_Compare2 = @TAB) Then $bExact = True
Else
Local $s_Compare1 = StringMid($sText, $iPos - 1, 1)
If ($iPos + StringLen($sFind)) - 1 = StringLen($sText) Then
If ($s_Compare1 = " " Or $s_Compare1 = @LF Or $s_Compare1 = @CR Or  $s_Compare1 = @CRLF Or $s_Compare1 = @TAB) Then $bExact = True
Else
If ($s_Compare1 = " " Or $s_Compare1 = @LF Or $s_Compare1 = @CR Or  $s_Compare1 = @CRLF Or $s_Compare1 = @TAB) And  ($s_Compare2 = " " Or $s_Compare2 = @LF Or $s_Compare2 = @CR Or  $s_Compare2 = @CRLF Or $s_Compare2 = @TAB) Then $bExact = True
EndIf
EndIf
If $bExact = False Then
__GUICtrlEdit_FindText($hWnd, $idInputSearch, $idChkMatchCase, $idChkWholeOnly, $iPos, $iOccurance, $iReplacements)
Else
_GUICtrlEdit_SetSel($hWnd, $iPos - 1, ($iPos + StringLen($sFind)) - 1)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
EndIf
ElseIf $iWhole And Not $iPos Then
$iOccurance = 0
MsgBox($MB_SYSTEMMODAL, "Find", "Reached End of document, Can not find the string '" & $sFind & "'")
ElseIf Not $iWhole Then
If Not $iPos Then
$iOccurance = 1
_GUICtrlEdit_SetSel($hWnd, -1, 0)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
$iPos = StringInStr($sText, $sFind, $iCase, $iOccurance)
If Not $iPos Then
$iOccurance = 0
MsgBox($MB_SYSTEMMODAL, "Find", "Reached End of document, Can not find the string  '" & $sFind & "'")
Else
_GUICtrlEdit_SetSel($hWnd, $iPos - 1, ($iPos + StringLen($sFind)) - 1)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
EndIf
Else
_GUICtrlEdit_SetSel($hWnd, $iPos - 1, ($iPos + StringLen($sFind)) - 1)
_GUICtrlEdit_Scroll($hWnd, $__EDITCONSTANT_SB_SCROLLCARET)
EndIf
EndIf
EndIf
EndFunc
Func _GUICtrlEdit_GetFirstVisibleLine($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETFIRSTVISIBLELINE)
EndFunc
Func _GUICtrlEdit_GetHandle($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return Ptr(_SendMessage($hWnd, $EM_GETHANDLE))
EndFunc
Func _GUICtrlEdit_GetIMEStatus($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETIMESTATUS, $EMSIS_COMPOSITIONSTRING)
EndFunc
Func _GUICtrlEdit_GetLimitText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETLIMITTEXT)
EndFunc
Func _GUICtrlEdit_GetLine($hWnd, $iLine)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLength = _GUICtrlEdit_LineLength($hWnd, $iLine)
If $iLength = 0 Then Return ""
Local $tBuffer = DllStructCreate("short Len;wchar Text[" & $iLength & "]")
DllStructSetData($tBuffer, "Len", $iLength + 1)
Local $iRet = _SendMessage($hWnd, $EM_GETLINE, $iLine, $tBuffer, 0, "wparam", "struct*")
If $iRet = 0 Then Return SetError($EC_ERR, $EC_ERR, "")
Local $tText = DllStructCreate("wchar Text[" & $iLength & "]", DllStructGetPtr($tBuffer))
Return DllStructGetData($tText, "Text")
EndFunc
Func _GUICtrlEdit_GetLineCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETLINECOUNT)
EndFunc
Func _GUICtrlEdit_GetMargins($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aMargins[2]
Local $iMargins = _SendMessage($hWnd, $EM_GETMARGINS)
$aMargins[0] = _WinAPI_LoWord($iMargins)
$aMargins[1] = _WinAPI_HiWord($iMargins)
Return $aMargins
EndFunc
Func _GUICtrlEdit_GetModify($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETMODIFY) <> 0
EndFunc
Func _GUICtrlEdit_GetPasswordChar($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETPASSWORDCHAR)
EndFunc
Func _GUICtrlEdit_GetRECT($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aRect[4]
Local $tRECT = _GUICtrlEdit_GetRECTEx($hWnd)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlEdit_GetRECTEx($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $EM_GETRECT, 0, $tRECT, 0, "wparam", "struct*")
Return $tRECT
EndFunc
Func _GUICtrlEdit_GetSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aSel[2]
Local $tStart = DllStructCreate("uint Start")
Local $tEnd = DllStructCreate("uint End")
_SendMessage($hWnd, $EM_GETSEL, $tStart, $tEnd, 0, "struct*", "struct*")
$aSel[0] = DllStructGetData($tStart, "Start")
$aSel[1] = DllStructGetData($tEnd, "End")
Return $aSel
EndFunc
Func _GUICtrlEdit_GetText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iTextLen = _GUICtrlEdit_GetTextLen($hWnd) + 1
Local $tText = DllStructCreate("wchar Text[" & $iTextLen & "]")
_SendMessage($hWnd, $__EDITCONSTANT_WM_GETTEXT, $iTextLen, $tText, 0, "wparam", "struct*")
Return DllStructGetData($tText, "Text")
EndFunc
Func _GUICtrlEdit_GetTextLen($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__EDITCONSTANT_WM_GETTEXTLENGTH)
EndFunc
Func _GUICtrlEdit_GetThumb($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETTHUMB)
EndFunc
Func _GUICtrlEdit_GetWordBreakProc($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_GETWORDBREAKPROC)
EndFunc
Func _GUICtrlEdit_HideBalloonTip($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_HIDEBALLOONTIP) <> 0
EndFunc
Func _GUICtrlEdit_InsertText($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $iIndex = -1 Then
_GUICtrlEdit_AppendText($hWnd, $sText)
Else
_GUICtrlEdit_SetSel($hWnd, $iIndex, $iIndex)
_SendMessage($hWnd, $EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndIf
EndFunc
Func _GUICtrlEdit_LineFromChar($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_LINEFROMCHAR, $iIndex)
EndFunc
Func _GUICtrlEdit_LineIndex($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_LINEINDEX, $iIndex)
EndFunc
Func _GUICtrlEdit_LineLength($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iCharIndex = _GUICtrlEdit_LineIndex($hWnd, $iIndex)
Return _SendMessage($hWnd, $EM_LINELENGTH, $iCharIndex)
EndFunc
Func _GUICtrlEdit_LineScroll($hWnd, $iHoriz, $iVert)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_LINESCROLL, $iHoriz, $iVert) <> 0
EndFunc
Func _GUICtrlEdit_PosFromChar($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aCoord[2]
Local $iRet = _SendMessage($hWnd, $EM_POSFROMCHAR, $iIndex)
$aCoord[0] = _WinAPI_LoWord($iRet)
$aCoord[1] = _WinAPI_HiWord($iRet)
Return $aCoord
EndFunc
Func _GUICtrlEdit_ReplaceSel($hWnd, $sText, $bUndo = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_REPLACESEL, $bUndo, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_Scroll($hWnd, $iDirection)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If BitAND($iDirection, $__EDITCONSTANT_SB_LINEDOWN) <> $__EDITCONSTANT_SB_LINEDOWN And  BitAND($iDirection, $__EDITCONSTANT_SB_LINEUP) <> $__EDITCONSTANT_SB_LINEUP And  BitAND($iDirection, $__EDITCONSTANT_SB_PAGEDOWN) <> $__EDITCONSTANT_SB_PAGEDOWN And  BitAND($iDirection, $__EDITCONSTANT_SB_PAGEUP) <> $__EDITCONSTANT_SB_PAGEUP And  BitAND($iDirection, $__EDITCONSTANT_SB_SCROLLCARET) <> $__EDITCONSTANT_SB_SCROLLCARET Then Return 0
If $iDirection == $__EDITCONSTANT_SB_SCROLLCARET Then
Return _SendMessage($hWnd, $EM_SCROLLCARET)
Else
Return _SendMessage($hWnd, $EM_SCROLL, $iDirection)
EndIf
EndFunc
Func _GUICtrlEdit_SetCueBanner($hWnd, $sText, $bOnFocus = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = _WinAPI_MultiByteToWideChar($sText)
Return _SendMessage($hWnd, $EM_SETCUEBANNER, $bOnFocus, $tText, 0, "wparam", "struct*") = 1
EndFunc
Func _GUICtrlEdit_SetHandle($hWnd, $hMemory)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETHANDLE, $hMemory, 0, 0, "handle")
EndFunc
Func _GUICtrlEdit_SetIMEStatus($hWnd, $iComposition)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_SETIMESTATUS, $EMSIS_COMPOSITIONSTRING, $iComposition)
EndFunc
Func _GUICtrlEdit_SetLimitText($hWnd, $iLimit)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETLIMITTEXT, $iLimit)
EndFunc
Func _GUICtrlEdit_SetMargins($hWnd, $iMargin = 0x1, $iLeft = 0xFFFF, $iRight = 0xFFFF)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETMARGINS, $iMargin, _WinAPI_MakeLong($iLeft, $iRight))
EndFunc
Func _GUICtrlEdit_SetModify($hWnd, $bModified)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETMODIFY, $bModified)
EndFunc
Func _GUICtrlEdit_SetPasswordChar($hWnd, $sDisplayChar = "0")
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
$sDisplayChar = StringLeft($sDisplayChar, 1)
If Asc($sDisplayChar) = 48 Then
_SendMessage($hWnd, $EM_SETPASSWORDCHAR)
Else
_SendMessage($hWnd, $EM_SETPASSWORDCHAR, Asc($sDisplayChar))
EndIf
EndFunc
Func _GUICtrlEdit_SetReadOnly($hWnd, $bReadOnly)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_SETREADONLY, $bReadOnly) <> 0
EndFunc
Func _GUICtrlEdit_SetRECT($hWnd, $aRect)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $aRect[0])
DllStructSetData($tRECT, "Top", $aRect[1])
DllStructSetData($tRECT, "Right", $aRect[2])
DllStructSetData($tRECT, "Bottom", $aRect[3])
_GUICtrlEdit_SetRECTEx($hWnd, $tRECT)
EndFunc
Func _GUICtrlEdit_SetRECTEx($hWnd, $tRECT)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETRECT, 0, $tRECT, 0, "wparam", "struct*")
EndFunc
Func _GUICtrlEdit_SetRECTNP($hWnd, $aRect)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $aRect[0])
DllStructSetData($tRECT, "Top", $aRect[1])
DllStructSetData($tRECT, "Right", $aRect[2])
DllStructSetData($tRECT, "Bottom", $aRect[3])
_GUICtrlEdit_SetRectNPEx($hWnd, $tRECT)
EndFunc
Func _GUICtrlEdit_SetRectNPEx($hWnd, $tRECT)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETRECTNP, 0, $tRECT, 0, "wparam", "struct*")
EndFunc
Func _GUICtrlEdit_SetSel($hWnd, $iStart, $iEnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETSEL, $iStart, $iEnd)
EndFunc
Func _GUICtrlEdit_SetTabStops($hWnd, $aTabStops)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If Not IsArray($aTabStops) Then Return SetError(-1, -1, False)
Local $sTabStops = ""
Local $iNumTabStops = UBound($aTabStops)
For $x = 0 To $iNumTabStops - 1
$sTabStops &= "int;"
Next
$sTabStops = StringTrimRight($sTabStops, 1)
Local $tTabStops = DllStructCreate($sTabStops)
For $x = 0 To $iNumTabStops - 1
DllStructSetData($tTabStops, $x + 1, $aTabStops[$x])
Next
Local $iRet = _SendMessage($hWnd, $EM_SETTABSTOPS, $iNumTabStops, $tTabStops, 0, "wparam", "struct*") <> 0
_WinAPI_InvalidateRect($hWnd)
Return $iRet
EndFunc
Func _GUICtrlEdit_SetText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $__EDITCONSTANT_WM_SETTEXT, 0, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlEdit_SetWordBreakProc($hWnd, $iAddressFunc)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $EM_SETWORDBREAKPROC, 0, $iAddressFunc)
EndFunc
Func _GUICtrlEdit_ShowBalloonTip($hWnd, $sTitle, $sText, $iIcon)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tTitle = _WinAPI_MultiByteToWideChar($sTitle)
Local $tText = _WinAPI_MultiByteToWideChar($sText)
Local $tTT = DllStructCreate($__tagEDITBALLOONTIP)
DllStructSetData($tTT, "Size", DllStructGetSize($tTT))
DllStructSetData($tTT, "Title", DllStructGetPtr($tTitle))
DllStructSetData($tTT, "Text", DllStructGetPtr($tText))
DllStructSetData($tTT, "Icon", $iIcon)
Return _SendMessage($hWnd, $EM_SHOWBALLOONTIP, 0, $tTT, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlEdit_Undo($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $EM_UNDO) <> 0
EndFunc
Global Const $DDL_ARCHIVE = 0x00000020
Global Const $DDL_DIRECTORY = 0x00000010
Global Const $DDL_DRIVES = 0x00004000
Global Const $DDL_EXCLUSIVE = 0x00008000
Global Const $DDL_HIDDEN = 0x00000002
Global Const $DDL_READONLY = 0x00000001
Global Const $DDL_READWRITE = 0x00000000
Global Const $DDL_SYSTEM = 0x00000004
Global $__g_hCBLastWnd
Global Const $__COMBOBOXCONSTANT_ClassName = "ComboBox"
Global Const $__COMBOBOXCONSTANT_EM_GETLINE = 0xC4
Global Const $__COMBOBOXCONSTANT_EM_LINEINDEX = 0xBB
Global Const $__COMBOBOXCONSTANT_EM_LINELENGTH = 0xC1
Global Const $__COMBOBOXCONSTANT_EM_REPLACESEL = 0xC2
Global Const $__COMBOBOXCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__COMBOBOXCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $tagCOMBOBOXINFO = "dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" &  "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList"
Func _GUICtrlComboBox_AddDir($hWnd, $sFilePath, $iAttributes = 0, $bBrackets = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If BitAND($iAttributes, $DDL_DRIVES) = $DDL_DRIVES And Not $bBrackets Then
Local $sText
Local $hGui_no_brackets = GUICreate("no brackets")
Local $idCombo_no_brackets = GUICtrlCreateCombo("", 240, 40, 120, 120)
Local $iRet = GUICtrlSendMsg($idCombo_no_brackets, $CB_DIR, $iAttributes, $sFilePath)
For $i = 0 To _GUICtrlComboBox_GetCount($idCombo_no_brackets) - 1
_GUICtrlComboBox_GetLBText($idCombo_no_brackets, $i, $sText)
$sText = StringReplace(StringReplace(StringReplace($sText, "[", ""), "]", ":"), "-", "")
_GUICtrlComboBox_InsertString($hWnd, $sText)
Next
GUIDelete($hGui_no_brackets)
Return $iRet
Else
Return _SendMessage($hWnd, $CB_DIR, $iAttributes, $sFilePath, 0, "wparam", "wstr")
EndIf
EndFunc
Func _GUICtrlComboBox_AddString($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_ADDSTRING, 0, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_AutoComplete($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If Not __GUICtrlComboBox_IsPressed('08') And Not __GUICtrlComboBox_IsPressed("2E") Then
Local $sEditText = _GUICtrlComboBox_GetEditText($hWnd)
If StringLen($sEditText) Then
Local $sInputText
Local $iRet = _GUICtrlComboBox_FindString($hWnd, $sEditText)
If ($iRet <> $CB_ERR) Then
_GUICtrlComboBox_GetLBText($hWnd, $iRet, $sInputText)
_GUICtrlComboBox_SetEditText($hWnd, $sInputText)
_GUICtrlComboBox_SetEditSel($hWnd, StringLen($sEditText), StringLen($sInputText))
EndIf
EndIf
EndIf
EndFunc
Func _GUICtrlComboBox_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__COMBOBOXCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlComboBox_Create($hWnd, $sText, $iX, $iY, $iWidth = 100, $iHeight = 120, $iStyle = 0x00200042, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
Local $aText, $sDelimiter = Opt("GUIDataSeparatorChar")
If $iWidth = -1 Then $iWidth = 100
If $iHeight = -1 Then $iHeight = 120
Local Const $WS_VSCROLL = 0x00200000
If $iStyle = -1 Then $iStyle = BitOR($WS_VSCROLL, $CBS_AUTOHSCROLL, $CBS_DROPDOWN)
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hCombo = _WinAPI_CreateWindowEx($iExStyle, $__COMBOBOXCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hCombo, _WinAPI_GetStockObject($__COMBOBOXCONSTANT_DEFAULT_GUI_FONT))
If StringLen($sText) Then
$aText = StringSplit($sText, $sDelimiter)
For $x = 1 To $aText[0]
_GUICtrlComboBox_AddString($hCombo, $aText[$x])
Next
EndIf
Return $hCombo
EndFunc
Func _GUICtrlComboBox_DeleteString($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_DELETESTRING, $iIndex)
EndFunc
Func _GUICtrlComboBox_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__COMBOBOXCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hCBLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlComboBox_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__COMBOBOXCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlComboBox_FindString($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_FINDSTRING, $iIndex, $sText, 0, "int", "wstr")
EndFunc
Func _GUICtrlComboBox_FindStringExact($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_FINDSTRINGEXACT, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_GetComboBoxInfo($hWnd, ByRef $tInfo)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
$tInfo = DllStructCreate($tagCOMBOBOXINFO)
Local $iInfo = DllStructGetSize($tInfo)
DllStructSetData($tInfo, "Size", $iInfo)
Return _SendMessage($hWnd, $CB_GETCOMBOBOXINFO, 0, $tInfo, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlComboBox_GetCount($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCOUNT)
EndFunc
Func _GUICtrlComboBox_GetCueBanner($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = DllStructCreate("wchar[4096]")
If _SendMessage($hWnd, $CB_GETCUEBANNER, $tText, 4096, 0, "struct*") <> 1 Then Return SetError(-1, 0, "")
Return _WinAPI_WideCharToMultiByte($tText)
EndFunc
Func _GUICtrlComboBox_GetCurSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETCURSEL)
EndFunc
Func _GUICtrlComboBox_GetDroppedControlRect($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aRect[4]
Local $tRECT = _GUICtrlComboBox_GetDroppedControlRectEx($hWnd)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlComboBox_GetDroppedControlRectEx($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $CB_GETDROPPEDCONTROLRECT, 0, $tRECT, 0, "wparam", "struct*")
Return $tRECT
EndFunc
Func _GUICtrlComboBox_GetDroppedState($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETDROPPEDSTATE) <> 0
EndFunc
Func _GUICtrlComboBox_GetDroppedWidth($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETDROPPEDWIDTH)
EndFunc
Func _GUICtrlComboBox_GetEditSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tStart = DllStructCreate("dword Start")
Local $tEnd = DllStructCreate("dword End")
Local $iRet = _SendMessage($hWnd, $CB_GETEDITSEL, $tStart, $tEnd, 0, "struct*", "struct*")
If $iRet = 0 Then Return SetError($CB_ERR, $CB_ERR, $CB_ERR)
Local $aSel[2]
$aSel[0] = DllStructGetData($tStart, "Start")
$aSel[1] = DllStructGetData($tEnd, "End")
Return $aSel
EndFunc
Func _GUICtrlComboBox_GetEditText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tInfo
If _GUICtrlComboBox_GetComboBoxInfo($hWnd, $tInfo) Then
Local $hEdit = DllStructGetData($tInfo, "hEdit")
Local $iLine = 0
Local $iIndex = _SendMessage($hEdit, $__COMBOBOXCONSTANT_EM_LINEINDEX, $iLine)
Local $iLength = _SendMessage($hEdit, $__COMBOBOXCONSTANT_EM_LINELENGTH, $iIndex)
If $iLength = 0 Then Return ""
Local $tBuffer = DllStructCreate("short Len;wchar Text[" & $iLength & "]")
DllStructSetData($tBuffer, "Len", $iLength)
Local $iRet = _SendMessage($hEdit, $__COMBOBOXCONSTANT_EM_GETLINE, $iLine, $tBuffer, 0, "wparam", "struct*")
If $iRet = 0 Then Return SetError(-1, -1, "")
Local $tText = DllStructCreate("wchar Text[" & $iLength & "]", DllStructGetPtr($tBuffer))
Return DllStructGetData($tText, "Text")
Else
Return SetError(-1, -1, "")
EndIf
EndFunc
Func _GUICtrlComboBox_GetExtendedUI($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETEXTENDEDUI) <> 0
EndFunc
Func _GUICtrlComboBox_GetHorizontalExtent($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETHORIZONTALEXTENT)
EndFunc
Func _GUICtrlComboBox_GetItemHeight($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETITEMHEIGHT, $iIndex)
EndFunc
Func _GUICtrlComboBox_GetLBText($hWnd, $iIndex, ByRef $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLen = _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
Local $tBuffer = DllStructCreate("wchar Text[" & $iLen + 1 & "]")
Local $iRet = _SendMessage($hWnd, $CB_GETLBTEXT, $iIndex, $tBuffer, 0, "wparam", "struct*")
If ($iRet == $CB_ERR) Then Return SetError($CB_ERR, $CB_ERR, $CB_ERR)
$sText = DllStructGetData($tBuffer, "Text")
Return $iRet
EndFunc
Func _GUICtrlComboBox_GetLBTextLen($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETLBTEXTLEN, $iIndex)
EndFunc
Func _GUICtrlComboBox_GetList($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Local $sResult = "", $sItem
For $i = 0 To _GUICtrlComboBox_GetCount($hWnd) - 1
_GUICtrlComboBox_GetLBText($hWnd, $i, $sItem)
$sResult &= $sItem & $sDelimiter
Next
Return StringTrimRight($sResult, StringLen($sDelimiter))
EndFunc
Func _GUICtrlComboBox_GetListArray($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sDelimiter = Opt("GUIDataSeparatorChar")
Return StringSplit(_GUICtrlComboBox_GetList($hWnd), $sDelimiter)
EndFunc
Func _GUICtrlComboBox_GetLocale($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETLOCALE)
EndFunc
Func _GUICtrlComboBox_GetLocaleCountry($hWnd)
Return _WinAPI_HiWord(_GUICtrlComboBox_GetLocale($hWnd))
EndFunc
Func _GUICtrlComboBox_GetLocaleLang($hWnd)
Return _WinAPI_LoWord(_GUICtrlComboBox_GetLocale($hWnd))
EndFunc
Func _GUICtrlComboBox_GetLocalePrimLang($hWnd)
Return _WinAPI_PrimaryLangId(_GUICtrlComboBox_GetLocaleLang($hWnd))
EndFunc
Func _GUICtrlComboBox_GetLocaleSubLang($hWnd)
Return _WinAPI_SubLangId(_GUICtrlComboBox_GetLocaleLang($hWnd))
EndFunc
Func _GUICtrlComboBox_GetMinVisible($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETMINVISIBLE)
EndFunc
Func _GUICtrlComboBox_GetTopIndex($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_GETTOPINDEX)
EndFunc
Func _GUICtrlComboBox_InitStorage($hWnd, $iNum, $iBytes)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_INITSTORAGE, $iNum, $iBytes)
EndFunc
Func _GUICtrlComboBox_InsertString($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_INSERTSTRING, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_LimitText($hWnd, $iLimit = 0)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_LIMITTEXT, $iLimit)
EndFunc
Func _GUICtrlComboBox_ReplaceEditSel($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tInfo
If _GUICtrlComboBox_GetComboBoxInfo($hWnd, $tInfo) Then
Local $hEdit = DllStructGetData($tInfo, "hEdit")
_SendMessage($hEdit, $__COMBOBOXCONSTANT_EM_REPLACESEL, True, $sText, 0, "wparam", "wstr")
EndIf
EndFunc
Func _GUICtrlComboBox_ResetContent($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_RESETCONTENT)
EndFunc
Func _GUICtrlComboBox_SelectString($hWnd, $sText, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SELECTSTRING, $iIndex, $sText, 0, "wparam", "wstr")
EndFunc
Func _GUICtrlComboBox_SetCueBanner($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tText = _WinAPI_MultiByteToWideChar($sText)
Return _SendMessage($hWnd, $CB_SETCUEBANNER, 0, $tText, 0, "wparam", "struct*") = 1
EndFunc
Func _GUICtrlComboBox_SetCurSel($hWnd, $iIndex = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETCURSEL, $iIndex)
EndFunc
Func _GUICtrlComboBox_SetDroppedWidth($hWnd, $iWidth)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETDROPPEDWIDTH, $iWidth)
EndFunc
Func _GUICtrlComboBox_SetEditSel($hWnd, $iStart, $iStop)
If Not HWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETEDITSEL, 0, _WinAPI_MakeLong($iStart, $iStop)) <> -1
EndFunc
Func _GUICtrlComboBox_SetEditText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_GUICtrlComboBox_SetEditSel($hWnd, 0, -1)
_GUICtrlComboBox_ReplaceEditSel($hWnd, $sText)
EndFunc
Func _GUICtrlComboBox_SetExtendedUI($hWnd, $bExtended = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETEXTENDEDUI, $bExtended) = 0
EndFunc
Func _GUICtrlComboBox_SetHorizontalExtent($hWnd, $iWidth)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_SETHORIZONTALEXTENT, $iWidth)
EndFunc
Func _GUICtrlComboBox_SetItemHeight($hWnd, $iHeight, $iComponent = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETITEMHEIGHT, $iComponent, $iHeight)
EndFunc
Func _GUICtrlComboBox_SetLocale($hWnd, $iLocal)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETLOCALE, $iLocal)
EndFunc
Func _GUICtrlComboBox_SetMinVisible($hWnd, $iMinimum)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETMINVISIBLE, $iMinimum) <> 0
EndFunc
Func _GUICtrlComboBox_SetTopIndex($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $CB_SETTOPINDEX, $iIndex) = 0
EndFunc
Func _GUICtrlComboBox_ShowDropDown($hWnd, $bShow = False)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $CB_SHOWDROPDOWN, $bShow)
EndFunc
Func __GUICtrlComboBox_IsPressed($sHexKey, $vDLL = 'user32.dll')
Local $a_R = DllCall($vDLL, "short", "GetAsyncKeyState", "int", '0x' & $sHexKey)
If @error Then Return SetError(@error, @extended, False)
Return BitAND($a_R[0], 0x8000) <> 0
EndFunc
Global Const $TBCD_CHANNEL = 0x3
Global Const $TBCD_THUMB = 0x2
Global Const $TBCD_TICS = 0x1
Global Const $__SLIDERCONSTANT_WM_USER = 0x400
Global Const $TBM_CLEARSEL = $__SLIDERCONSTANT_WM_USER + 19
Global Const $TBM_CLEARTICS = $__SLIDERCONSTANT_WM_USER + 9
Global Const $TBM_GETBUDDY = $__SLIDERCONSTANT_WM_USER + 33
Global Const $TBM_GETCHANNELRECT = $__SLIDERCONSTANT_WM_USER + 26
Global Const $TBM_GETLINESIZE = $__SLIDERCONSTANT_WM_USER + 24
Global Const $TBM_GETNUMTICS = $__SLIDERCONSTANT_WM_USER + 16
Global Const $TBM_GETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 22
Global Const $TBM_GETPOS = $__SLIDERCONSTANT_WM_USER
Global Const $TBM_GETPTICS = $__SLIDERCONSTANT_WM_USER + 14
Global Const $TBM_GETSELEND = $__SLIDERCONSTANT_WM_USER + 18
Global Const $TBM_GETSELSTART = $__SLIDERCONSTANT_WM_USER + 17
Global Const $TBM_GETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 2
Global Const $TBM_GETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 1
Global Const $TBM_GETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 28
Global Const $TBM_GETTHUMBRECT = $__SLIDERCONSTANT_WM_USER + 25
Global Const $TBM_GETTIC = $__SLIDERCONSTANT_WM_USER + 3
Global Const $TBM_GETTICPOS = $__SLIDERCONSTANT_WM_USER + 15
Global Const $TBM_GETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 30
Global Const $TBM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $TBM_SETBUDDY = $__SLIDERCONSTANT_WM_USER + 32
Global Const $TBM_SETLINESIZE = $__SLIDERCONSTANT_WM_USER + 23
Global Const $TBM_SETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 21
Global Const $TBM_SETPOS = $__SLIDERCONSTANT_WM_USER + 5
Global Const $TBM_SETRANGE = $__SLIDERCONSTANT_WM_USER + 6
Global Const $TBM_SETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 8
Global Const $TBM_SETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 7
Global Const $TBM_SETSEL = $__SLIDERCONSTANT_WM_USER + 10
Global Const $TBM_SETSELEND = $__SLIDERCONSTANT_WM_USER + 12
Global Const $TBM_SETSELSTART = $__SLIDERCONSTANT_WM_USER + 11
Global Const $TBM_SETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 27
Global Const $TBM_SETTIC = $__SLIDERCONSTANT_WM_USER + 4
Global Const $TBM_SETTICFREQ = $__SLIDERCONSTANT_WM_USER + 20
Global Const $TBM_SETTIPSIDE = $__SLIDERCONSTANT_WM_USER + 31
Global Const $TBM_SETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 29
Global Const $TBM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $TBTS_BOTTOM = 2
Global Const $TBTS_LEFT = 1
Global Const $TBTS_RIGHT = 3
Global Const $TBTS_TOP = 0
Global Const $TBS_AUTOTICKS = 0x0001
Global Const $TBS_BOTH = 0x0008
Global Const $TBS_BOTTOM = 0x0000
Global Const $TBS_DOWNISLEFT = 0x0400
Global Const $TBS_ENABLESELRANGE = 0x20
Global Const $TBS_FIXEDLENGTH = 0x40
Global Const $TBS_HORZ = 0x0000
Global Const $TBS_LEFT = 0x0004
Global Const $TBS_NOTHUMB = 0x0080
Global Const $TBS_NOTICKS = 0x0010
Global Const $TBS_REVERSED = 0x200
Global Const $TBS_RIGHT = 0x0000
Global Const $TBS_TOP = 0x0004
Global Const $TBS_TOOLTIPS = 0x100
Global Const $TBS_VERT = 0x0002
Global Const $GUI_SS_DEFAULT_SLIDER = $TBS_AUTOTICKS
Global $__g_hSLastWnd
Global Const $__SLIDERCONSTANT_ClassName = "msctls_trackbar32"
Func _GUICtrlSlider_ClearSel($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_CLEARSEL, True)
EndFunc
Func _GUICtrlSlider_ClearTics($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_CLEARTICS, True)
EndFunc
Func _GUICtrlSlider_Create($hWnd, $iX, $iY, $iWidth = 100, $iHeight = 20, $iStyle = $TBS_AUTOTICKS, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If $iWidth = -1 Then $iWidth = 100
If $iHeight = -1 Then $iHeight = 20
If $iStyle = -1 Then $iStyle = $TBS_AUTOTICKS
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hSlider = _WinAPI_CreateWindowEx($iExStyle, $__SLIDERCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hSlider, $TBM_SETRANGE, True, _WinAPI_MakeLong(0, 100))
_GUICtrlSlider_SetTicFreq($hSlider, 5)
Return $hSlider
EndFunc
Func _GUICtrlSlider_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__SLIDERCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hSLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlSlider_GetBuddy($hWnd, $bLocation)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETBUDDY, $bLocation, 0, 0, "wparam", "lparam", "hwnd")
EndFunc
Func _GUICtrlSlider_GetChannelRect($hWnd)
Local $tRECT = _GUICtrlSlider_GetChannelRectEx($hWnd)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlSlider_GetChannelRectEx($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $TBM_GETCHANNELRECT, 0, $tRECT, 0, "wparam", "struct*")
Return $tRECT
EndFunc
Func _GUICtrlSlider_GetLineSize($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETLINESIZE)
EndFunc
Func _GUICtrlSlider_GetLogicalTics($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iArraySize = _GUICtrlSlider_GetNumTics($hWnd) - 2
Local $aTics[$iArraySize]
Local $pArray = _SendMessage($hWnd, $TBM_GETPTICS)
If @error Then Return SetError(@error, @extended, $aTics)
Local $tArray = DllStructCreate("dword[" & $iArraySize & "]", $pArray)
For $x = 1 To $iArraySize
$aTics[$x - 1] = _GUICtrlSlider_GetTicPos($hWnd, DllStructGetData($tArray, 1, $x))
Next
Return $aTics
EndFunc
Func _GUICtrlSlider_GetNumTics($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETNUMTICS)
EndFunc
Func _GUICtrlSlider_GetPageSize($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETPAGESIZE)
EndFunc
Func _GUICtrlSlider_GetPos($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETPOS)
EndFunc
Func _GUICtrlSlider_GetRange($hWnd)
Local $aMinMax[2]
$aMinMax[0] = _GUICtrlSlider_GetRangeMin($hWnd)
$aMinMax[1] = _GUICtrlSlider_GetRangeMax($hWnd)
Return $aMinMax
EndFunc
Func _GUICtrlSlider_GetRangeMax($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETRANGEMAX)
EndFunc
Func _GUICtrlSlider_GetRangeMin($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETRANGEMIN)
EndFunc
Func _GUICtrlSlider_GetSel($hWnd)
Local $aSelStartEnd[2]
$aSelStartEnd[0] = _GUICtrlSlider_GetSelStart($hWnd)
$aSelStartEnd[1] = _GUICtrlSlider_GetSelEnd($hWnd)
Return $aSelStartEnd
EndFunc
Func _GUICtrlSlider_GetSelEnd($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETSELEND)
EndFunc
Func _GUICtrlSlider_GetSelStart($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETSELSTART)
EndFunc
Func _GUICtrlSlider_GetThumbLength($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETTHUMBLENGTH)
EndFunc
Func _GUICtrlSlider_GetThumbRect($hWnd)
Local $tRECT = _GUICtrlSlider_GetThumbRectEx($hWnd)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlSlider_GetThumbRectEx($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $TBM_GETTHUMBRECT, 0, $tRECT, 0, "wparam", "struct*")
Return $tRECT
EndFunc
Func _GUICtrlSlider_GetTic($hWnd, $iTic)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETTIC, $iTic)
EndFunc
Func _GUICtrlSlider_GetTicPos($hWnd, $iTic)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETTICPOS, $iTic)
EndFunc
Func _GUICtrlSlider_GetToolTips($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETTOOLTIPS, 0, 0, 0, "wparam", "lparam", "hwnd")
EndFunc
Func _GUICtrlSlider_GetUnicodeFormat($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlSlider_SetBuddy($hWnd, $bLocation, $hBuddy)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If Not IsHWnd($hBuddy) Then $hBuddy = GUICtrlGetHandle($hBuddy)
Return _SendMessage($hWnd, $TBM_SETBUDDY, $bLocation, $hBuddy, 0, "wparam", "hwnd", "hwnd")
EndFunc
Func _GUICtrlSlider_SetLineSize($hWnd, $iLineSize)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_SETLINESIZE, 0, $iLineSize)
EndFunc
Func _GUICtrlSlider_SetPageSize($hWnd, $iPageSize)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_SETPAGESIZE, 0, $iPageSize)
EndFunc
Func _GUICtrlSlider_SetPos($hWnd, $iPosition)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETPOS, True, $iPosition)
EndFunc
Func _GUICtrlSlider_SetRange($hWnd, $iMinimum, $iMaximum)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETRANGE, True, _WinAPI_MakeLong($iMinimum, $iMaximum))
EndFunc
Func _GUICtrlSlider_SetRangeMax($hWnd, $iMaximum)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETRANGEMAX, True, $iMaximum)
EndFunc
Func _GUICtrlSlider_SetRangeMin($hWnd, $iMinimum)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETRANGEMIN, True, $iMinimum)
EndFunc
Func _GUICtrlSlider_SetSel($hWnd, $iMinimum, $iMaximum)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETSEL, True, _WinAPI_MakeLong($iMinimum, $iMaximum))
EndFunc
Func _GUICtrlSlider_SetSelEnd($hWnd, $iMaximum)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETSELEND, True, $iMaximum)
EndFunc
Func _GUICtrlSlider_SetSelStart($hWnd, $iMinimum)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETSELSTART, True, $iMinimum)
EndFunc
Func _GUICtrlSlider_SetThumbLength($hWnd, $iLength)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTHUMBLENGTH, $iLength)
EndFunc
Func _GUICtrlSlider_SetTic($hWnd, $iPosition)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTIC, 0, $iPosition)
EndFunc
Func _GUICtrlSlider_SetTicFreq($hWnd, $iFreg)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTICFREQ, $iFreg)
EndFunc
Func _GUICtrlSlider_SetTipSide($hWnd, $iLocation)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTIPSIDE, $iLocation)
EndFunc
Func _GUICtrlSlider_SetToolTips($hWnd, $hWndTT)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $TBM_SETTOOLTIPS, $hWndTT, 0, 0, "hwnd")
EndFunc
Func _GUICtrlSlider_SetUnicodeFormat($hWnd, $bUnicode)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $TBM_SETUNICODEFORMAT, $bUnicode) <> 0
EndFunc
Global Const $TBIF_IMAGE = 0x00000001
Global Const $TBIF_TEXT = 0x00000002
Global Const $TBIF_STATE = 0x00000004
Global Const $TBIF_STYLE = 0x00000008
Global Const $TBIF_LPARAM = 0x00000010
Global Const $TBIF_COMMAND = 0x00000020
Global Const $TBIF_SIZE = 0x00000040
Global Const $TBIF_BYINDEX = 0x80000000
Global Const $TBMF_PAD = 0x00000001
Global Const $TBMF_BARPAD = 0x00000002
Global Const $TBMF_BUTTONSPACING = 0x00000004
Global Const $TBSTATE_CHECKED = 0x00000001
Global Const $TBSTATE_PRESSED = 0x00000002
Global Const $TBSTATE_ENABLED = 0x00000004
Global Const $TBSTATE_HIDDEN = 0x00000008
Global Const $TBSTATE_INDETERMINATE = 0x00000010
Global Const $TBSTATE_WRAP = 0x00000020
Global Const $TBSTATE_ELLIPSES = 0x00000040
Global Const $TBSTATE_MARKED = 0x00000080
Global Const $__TOOLBARCONSTANTS_WM_USER = 0X400
Global Const $TB_ENABLEBUTTON = $__TOOLBARCONSTANTS_WM_USER + 1
Global Const $TB_CHECKBUTTON = $__TOOLBARCONSTANTS_WM_USER + 2
Global Const $TB_PRESSBUTTON = $__TOOLBARCONSTANTS_WM_USER + 3
Global Const $TB_HIDEBUTTON = $__TOOLBARCONSTANTS_WM_USER + 4
Global Const $TB_INDETERMINATE = $__TOOLBARCONSTANTS_WM_USER + 5
Global Const $TB_MARKBUTTON = $__TOOLBARCONSTANTS_WM_USER + 6
Global Const $TB_ISBUTTONENABLED = $__TOOLBARCONSTANTS_WM_USER + 9
Global Const $TB_ISBUTTONCHECKED = $__TOOLBARCONSTANTS_WM_USER + 10
Global Const $TB_ISBUTTONPRESSED = $__TOOLBARCONSTANTS_WM_USER + 11
Global Const $TB_ISBUTTONHIDDEN = $__TOOLBARCONSTANTS_WM_USER + 12
Global Const $TB_ISBUTTONINDETERMINATE = $__TOOLBARCONSTANTS_WM_USER + 13
Global Const $TB_ISBUTTONHIGHLIGHTED = $__TOOLBARCONSTANTS_WM_USER + 14
Global Const $TB_SETSTATE = $__TOOLBARCONSTANTS_WM_USER + 17
Global Const $TB_GETSTATE = $__TOOLBARCONSTANTS_WM_USER + 18
Global Const $TB_ADDBITMAP = $__TOOLBARCONSTANTS_WM_USER + 19
Global Const $TB_ADDBUTTONSA = $__TOOLBARCONSTANTS_WM_USER + 20
Global Const $TB_INSERTBUTTONA = $__TOOLBARCONSTANTS_WM_USER + 21
Global Const $TB_DELETEBUTTON = $__TOOLBARCONSTANTS_WM_USER + 22
Global Const $TB_GETBUTTON = $__TOOLBARCONSTANTS_WM_USER + 23
Global Const $TB_BUTTONCOUNT = $__TOOLBARCONSTANTS_WM_USER + 24
Global Const $TB_COMMANDTOINDEX = $__TOOLBARCONSTANTS_WM_USER + 25
Global Const $TB_SAVERESTOREA = $__TOOLBARCONSTANTS_WM_USER + 26
Global Const $TB_SAVERESTOREW = $__TOOLBARCONSTANTS_WM_USER + 76
Global Const $TB_CUSTOMIZE = $__TOOLBARCONSTANTS_WM_USER + 27
Global Const $TB_ADDSTRINGA = $__TOOLBARCONSTANTS_WM_USER + 28
Global Const $TB_ADDSTRINGW = $__TOOLBARCONSTANTS_WM_USER + 77
Global Const $TB_GETITEMRECT = $__TOOLBARCONSTANTS_WM_USER + 29
Global Const $TB_BUTTONSTRUCTSIZE = $__TOOLBARCONSTANTS_WM_USER + 30
Global Const $TB_SETBUTTONSIZE = $__TOOLBARCONSTANTS_WM_USER + 31
Global Const $TB_SETBITMAPSIZE = $__TOOLBARCONSTANTS_WM_USER + 32
Global Const $TB_AUTOSIZE = $__TOOLBARCONSTANTS_WM_USER + 33
Global Const $TB_GETTOOLTIPS = $__TOOLBARCONSTANTS_WM_USER + 35
Global Const $TB_SETTOOLTIPS = $__TOOLBARCONSTANTS_WM_USER + 36
Global Const $TB_SETPARENT = $__TOOLBARCONSTANTS_WM_USER + 37
Global Const $TB_SETROWS = $__TOOLBARCONSTANTS_WM_USER + 39
Global Const $TB_GETROWS = $__TOOLBARCONSTANTS_WM_USER + 40
Global Const $TB_GETBITMAPFLAGS = $__TOOLBARCONSTANTS_WM_USER + 41
Global Const $TB_SETCMDID = $__TOOLBARCONSTANTS_WM_USER + 42
Global Const $TB_CHANGEBITMAP = $__TOOLBARCONSTANTS_WM_USER + 43
Global Const $TB_GETBITMAP = $__TOOLBARCONSTANTS_WM_USER + 44
Global Const $TB_GETBUTTONTEXTA = $__TOOLBARCONSTANTS_WM_USER + 45
Global Const $TB_GETBUTTONTEXTW = $__TOOLBARCONSTANTS_WM_USER + 75
Global Const $TB_REPLACEBITMAP = $__TOOLBARCONSTANTS_WM_USER + 46
Global Const $TB_SETINDENT = $__TOOLBARCONSTANTS_WM_USER + 47
Global Const $TB_SETIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 48
Global Const $TB_GETIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 49
Global Const $TB_LOADIMAGES = $__TOOLBARCONSTANTS_WM_USER + 50
Global Const $TB_GETRECT = $__TOOLBARCONSTANTS_WM_USER + 51
Global Const $TB_SETHOTIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 52
Global Const $TB_GETHOTIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 53
Global Const $TB_SETDISABLEDIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 54
Global Const $TB_GETDISABLEDIMAGELIST = $__TOOLBARCONSTANTS_WM_USER + 55
Global Const $TB_SETSTYLE = $__TOOLBARCONSTANTS_WM_USER + 56
Global Const $TB_GETSTYLE = $__TOOLBARCONSTANTS_WM_USER + 57
Global Const $TB_GETBUTTONSIZE = $__TOOLBARCONSTANTS_WM_USER + 58
Global Const $TB_SETBUTTONWIDTH = $__TOOLBARCONSTANTS_WM_USER + 59
Global Const $TB_SETMAXTEXTROWS = $__TOOLBARCONSTANTS_WM_USER + 60
Global Const $TB_GETTEXTROWS = $__TOOLBARCONSTANTS_WM_USER + 61
Global Const $TB_GETOBJECT = $__TOOLBARCONSTANTS_WM_USER + 62
Global Const $TB_GETBUTTONINFOW = $__TOOLBARCONSTANTS_WM_USER + 63
Global Const $TB_SETBUTTONINFOW = $__TOOLBARCONSTANTS_WM_USER + 64
Global Const $TB_GETBUTTONINFOA = $__TOOLBARCONSTANTS_WM_USER + 65
Global Const $TB_SETBUTTONINFOA = $__TOOLBARCONSTANTS_WM_USER + 66
Global Const $TB_INSERTBUTTONW = $__TOOLBARCONSTANTS_WM_USER + 67
Global Const $TB_ADDBUTTONSW = $__TOOLBARCONSTANTS_WM_USER + 68
Global Const $TB_HITTEST = $__TOOLBARCONSTANTS_WM_USER + 69
Global Const $TB_SETDRAWTEXTFLAGS = $__TOOLBARCONSTANTS_WM_USER + 70
Global Const $TB_GETHOTITEM = $__TOOLBARCONSTANTS_WM_USER + 71
Global Const $TB_SETHOTITEM = $__TOOLBARCONSTANTS_WM_USER + 72
Global Const $TB_SETANCHORHIGHLIGHT = $__TOOLBARCONSTANTS_WM_USER + 73
Global Const $TB_GETANCHORHIGHLIGHT = $__TOOLBARCONSTANTS_WM_USER + 74
Global Const $TB_MAPACCELERATOR = $__TOOLBARCONSTANTS_WM_USER + 78
Global Const $TB_GETINSERTMARK = $__TOOLBARCONSTANTS_WM_USER + 79
Global Const $TB_SETINSERTMARK = $__TOOLBARCONSTANTS_WM_USER + 80
Global Const $TB_INSERTMARKHITTEST = $__TOOLBARCONSTANTS_WM_USER + 81
Global Const $TB_MOVEBUTTON = $__TOOLBARCONSTANTS_WM_USER + 82
Global Const $TB_GETMAXSIZE = $__TOOLBARCONSTANTS_WM_USER + 83
Global Const $TB_SETEXTENDEDSTYLE = $__TOOLBARCONSTANTS_WM_USER + 84
Global Const $TB_GETEXTENDEDSTYLE = $__TOOLBARCONSTANTS_WM_USER + 85
Global Const $TB_GETPADDING = $__TOOLBARCONSTANTS_WM_USER + 86
Global Const $TB_SETPADDING = $__TOOLBARCONSTANTS_WM_USER + 87
Global Const $TB_SETINSERTMARKCOLOR = $__TOOLBARCONSTANTS_WM_USER + 88
Global Const $TB_GETINSERTMARKCOLOR = $__TOOLBARCONSTANTS_WM_USER + 89
Global Const $TB_MAPACCELERATORW = $__TOOLBARCONSTANTS_WM_USER + 90
Global Const $TB_GETSTRINGW = $__TOOLBARCONSTANTS_WM_USER + 91
Global Const $TB_GETSTRINGA = $__TOOLBARCONSTANTS_WM_USER + 92
Global Const $TB_GETMETRICS = $__TOOLBARCONSTANTS_WM_USER + 101
Global Const $TB_SETMETRICS = $__TOOLBARCONSTANTS_WM_USER + 102
Global Const $TB_GETCOLORSCHEME = 0x2000 + 3
Global Const $TB_SETCOLORSCHEME = 0x2000 + 2
Global Const $TB_SETUNICODEFORMAT = 0x2000 + 5
Global Const $TB_GETUNICODEFORMAT = 0x2000 + 6
Global Const $TB_SETWINDOWTHEME = 0x2000 + 11
Global Const $TBN_FIRST = -700
Global Const $TBN_GETBUTTONINFOA = $TBN_FIRST - 0
Global Const $TBN_BEGINDRAG = $TBN_FIRST - 1
Global Const $TBN_ENDDRAG = $TBN_FIRST - 2
Global Const $TBN_BEGINADJUST = $TBN_FIRST - 3
Global Const $TBN_ENDADJUST = $TBN_FIRST - 4
Global Const $TBN_RESET = $TBN_FIRST - 5
Global Const $TBN_QUERYINSERT = $TBN_FIRST - 6
Global Const $TBN_QUERYDELETE = $TBN_FIRST - 7
Global Const $TBN_TOOLBARCHANGE = $TBN_FIRST - 8
Global Const $TBN_CUSTHELP = $TBN_FIRST - 9
Global Const $TBN_DROPDOWN = $TBN_FIRST - 10
Global Const $TBN_GETOBJECT = $TBN_FIRST - 12
Global Const $TBN_HOTITEMCHANGE = $TBN_FIRST - 13
Global Const $TBN_DRAGOUT = $TBN_FIRST - 14
Global Const $TBN_DELETINGBUTTON = $TBN_FIRST - 15
Global Const $TBN_GETDISPINFOA = $TBN_FIRST - 16
Global Const $TBN_GETDISPINFOW = $TBN_FIRST - 17
Global Const $TBN_GETINFOTIPA = $TBN_FIRST - 18
Global Const $TBN_GETINFOTIPW = $TBN_FIRST - 19
Global Const $TBN_GETBUTTONINFOW = $TBN_FIRST - 20
Global Const $TBN_RESTORE = $TBN_FIRST - 21
Global Const $TBN_SAVE = $TBN_FIRST - 22
Global Const $TBN_INITCUSTOMIZE = $TBN_FIRST - 23
Global Const $HICF_ACCELERATOR = 0x4
Global Const $HICF_ARROWKEYS = 0x2
Global Const $HICF_DUPACCEL = 0x8
Global Const $HICF_ENTERING = 0x10
Global Const $HICF_LEAVING = 0x20
Global Const $HICF_LMOUSE = 0x80
Global Const $HICF_MOUSE = 0x1
Global Const $HICF_OTHER = 0x0
Global Const $HICF_RESELECT = 0x40
Global Const $HICF_TOGGLEDROPDOWN = 0x100
Global Const $BTNS_BUTTON = 0x00000000
Global Const $BTNS_SEP = 0x00000001
Global Const $BTNS_CHECK = 0x00000002
Global Const $BTNS_GROUP = 0x00000004
Global Const $BTNS_CHECKGROUP = 0x00000006
Global Const $BTNS_DROPDOWN = 0x00000008
Global Const $BTNS_AUTOSIZE = 0x00000010
Global Const $BTNS_NOPREFIX = 0x00000020
Global Const $BTNS_SHOWTEXT = 0x00000040
Global Const $BTNS_WHOLEDROPDOWN = 0x00000080
Global Const $TBSTYLE_TOOLTIPS = 0x00000100
Global Const $TBSTYLE_WRAPABLE = 0x00000200
Global Const $TBSTYLE_ALTDRAG = 0x00000400
Global Const $TBSTYLE_FLAT = 0x00000800
Global Const $TBSTYLE_LIST = 0x00001000
Global Const $TBSTYLE_CUSTOMERASE = 0x00002000
Global Const $TBSTYLE_REGISTERDROP = 0x00004000
Global Const $TBSTYLE_TRANSPARENT = 0x00008000
Global Const $TBSTYLE_EX_DRAWDDARROWS = 0x00000001
Global Const $TBSTYLE_EX_MIXEDBUTTONS = 0x00000008
Global Const $TBSTYLE_EX_HIDECLIPPEDBUTTONS = 0x00000010
Global Const $TBSTYLE_EX_DOUBLEBUFFER = 0x00000080
Global $__g_hTBLastWnd
Global Const $__TOOLBARCONSTANT_ClassName = "ToolbarWindow32"
Global Const $__TOOLBARCONSTANT_WS_CLIPSIBLINGS = 0x04000000
Global Const $__TOOLBARCONSTANT_HINST_COMMCTRL = -1
Global Const $tagTBADDBITMAP = "handle hInst;uint_ptr ID"
Global Const $tagTBINSERTMARK = "int Button;dword Flags"
Global Const $tagTBMETRICS = "uint Size;dword Mask;int XPad;int YPad;int XBarPad;int YBarPad;int XSpacing;int YSpacing"
Func _GUICtrlToolbar_AddBitmap($hWnd, $iButtons, $hInst, $iID)
Local $tBitmap = DllStructCreate($tagTBADDBITMAP)
DllStructSetData($tBitmap, "hInst", $hInst)
DllStructSetData($tBitmap, "ID", $iID)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_ADDBITMAP, $iButtons, $tBitmap, 0, "wparam", "struct*")
Else
Local $iBitmap = DllStructGetSize($tBitmap)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBitmap, $tMemMap)
_MemWrite($tMemMap, $tBitmap, $pMemory, $iBitmap)
$iRet = _SendMessage($hWnd, $TB_ADDBITMAP, $iButtons, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func _GUICtrlToolbar_AddButton($hWnd, $iID, $iImage, $iString = 0, $iStyle = 0, $iState = 4, $iParam = 0)
Local $bUnicode = _GUICtrlToolbar_GetUnicodeFormat($hWnd)
Local $tButton = DllStructCreate($tagTBBUTTON)
DllStructSetData($tButton, "Bitmap", $iImage)
DllStructSetData($tButton, "Command", $iID)
DllStructSetData($tButton, "State", $iState)
DllStructSetData($tButton, "Style", $iStyle)
DllStructSetData($tButton, "Param", $iParam)
DllStructSetData($tButton, "String", $iString)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_ADDBUTTONSW, 1, $tButton, 0, "wparam", "struct*")
Else
Local $iButton = DllStructGetSize($tButton)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iButton, $tMemMap)
_MemWrite($tMemMap, $tButton, $pMemory, $iButton)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TB_ADDBUTTONSW, 1, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $TB_ADDBUTTONSA, 1, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
__GUICtrlToolbar_AutoSize($hWnd)
Return $iRet <> 0
EndFunc
Func _GUICtrlToolbar_AddButtonSep($hWnd, $iWidth = 6)
_GUICtrlToolbar_AddButton($hWnd, 0, $iWidth, 0, $BTNS_SEP)
EndFunc
Func _GUICtrlToolbar_AddString($hWnd, $sString)
Local $bUnicode = _GUICtrlToolbar_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sString) + 2
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sString)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_ADDSTRINGW, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer, $pMemory, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TB_ADDSTRINGW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $TB_ADDSTRINGA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func __GUICtrlToolbar_AutoSize($hWnd)
_SendMessage($hWnd, $TB_AUTOSIZE)
EndFunc
Func _GUICtrlToolbar_ButtonCount($hWnd)
Return _SendMessage($hWnd, $TB_BUTTONCOUNT)
EndFunc
Func __GUICtrlToolbar_ButtonStructSize($hWnd)
Local $tButton = DllStructCreate($tagTBBUTTON)
_SendMessage($hWnd, $TB_BUTTONSTRUCTSIZE, DllStructGetSize($tButton), 0, 0, "wparam", "ptr")
EndFunc
Func _GUICtrlToolbar_CheckButton($hWnd, $iCommandID, $bCheck = True)
Return _SendMessage($hWnd, $TB_CHECKBUTTON, $iCommandID, $bCheck) <> 0
EndFunc
Func _GUICtrlToolbar_ClickAccel($hWnd, $sAccelKey, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
Local $iID = _GUICtrlToolbar_MapAccelerator($hWnd, $sAccelKey)
_GUICtrlToolbar_ClickButton($hWnd, $iID, $sButton, $bMove, $iClicks, $iSpeed)
EndFunc
Func _GUICtrlToolbar_ClickButton($hWnd, $iCommandID, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
Local $tRECT = _GUICtrlToolbar_GetButtonRectEx($hWnd, $iCommandID)
Local $tPoint = _WinAPI_PointFromRect($tRECT)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
Local $iX, $iY
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
If Not $bMove Then
Local $aPos = MouseGetPos()
_WinAPI_ShowCursor(False)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
MouseMove($aPos[0], $aPos[1], 0)
_WinAPI_ShowCursor(True)
Else
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
EndIf
Opt("MouseCoordMode", $iMode)
EndFunc
Func _GUICtrlToolbar_ClickIndex($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
Local $iCommandID = _GUICtrlToolbar_IndexToCommand($hWnd, $iIndex)
_GUICtrlToolbar_ClickButton($hWnd, $iCommandID, $sButton, $bMove, $iClicks, $iSpeed)
EndFunc
Func _GUICtrlToolbar_CommandToIndex($hWnd, $iCommandID)
Return _SendMessage($hWnd, $TB_COMMANDTOINDEX, $iCommandID)
EndFunc
Func _GUICtrlToolbar_Create($hWnd, $iStyle = 0x00000800, $iExStyle = 0x00000000)
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__TOOLBARCONSTANT_WS_CLIPSIBLINGS, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hTool = _WinAPI_CreateWindowEx($iExStyle, $__TOOLBARCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
__GUICtrlToolbar_ButtonStructSize($hTool)
Return $hTool
EndFunc
Func _GUICtrlToolbar_Customize($hWnd)
_SendMessage($hWnd, $TB_CUSTOMIZE)
EndFunc
Func _GUICtrlToolbar_DeleteButton($hWnd, $iCommandID)
Local $iIndex = _GUICtrlToolbar_CommandToIndex($hWnd, $iCommandID)
If $iIndex = -1 Then Return SetError(-1, 0, False)
Return _SendMessage($hWnd, $TB_DELETEBUTTON, $iIndex) <> 0
EndFunc
Func _GUICtrlToolbar_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__TOOLBARCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlToolbar_EnableButton($hWnd, $iCommandID, $bEnable = True)
Return _SendMessage($hWnd, $TB_ENABLEBUTTON, $iCommandID, $bEnable) <> 0
EndFunc
Func _GUICtrlToolbar_FindToolbar($hWnd, $sText)
Local $iCommandID, $hToolbar
If Not _WinAPI_IsWindow($hWnd) Then
$hWnd = WinGetHandle($hWnd)
If @error Then Return SetError(-1, -1, 0)
EndIf
Local $aWinList = _WinAPI_EnumWindows(True, $hWnd)
For $iI = 1 To $aWinList[0][0]
If $aWinList[$iI][1] = $__TOOLBARCONSTANT_ClassName Then
$hToolbar = $aWinList[$iI][0]
For $iJ = 0 To _GUICtrlToolbar_ButtonCount($hToolbar) - 1
$iCommandID = _GUICtrlToolbar_IndexToCommand($hToolbar, $iJ)
If _GUICtrlToolbar_GetButtonText($hToolbar, $iCommandID) = $sText Then Return $hToolbar
Next
EndIf
Next
Return SetError(-2, -2, 0)
EndFunc
Func _GUICtrlToolbar_GetAnchorHighlight($hWnd)
Return _SendMessage($hWnd, $TB_GETANCHORHIGHLIGHT) <> 0
EndFunc
Func _GUICtrlToolbar_GetBitmapFlags($hWnd)
Return _SendMessage($hWnd, $TB_GETBITMAPFLAGS)
EndFunc
Func _GUICtrlToolbar_GetButtonBitmap($hWnd, $iCommandID)
Return _SendMessage($hWnd, $TB_GETBITMAP, $iCommandID)
EndFunc
Func _GUICtrlToolbar_GetButtonInfo($hWnd, $iCommandID)
Local $aButton[5]
Local $tButton = _GUICtrlToolbar_GetButtonInfoEx($hWnd, $iCommandID)
$aButton[0] = DllStructGetData($tButton, "Image")
$aButton[1] = DllStructGetData($tButton, "State")
$aButton[2] = DllStructGetData($tButton, "Style")
$aButton[3] = DllStructGetData($tButton, "CX")
$aButton[4] = DllStructGetData($tButton, "Param")
Return $aButton
EndFunc
Func _GUICtrlToolbar_GetButtonInfoEx($hWnd, $iCommandID)
Local $bUnicode = _GUICtrlToolbar_GetUnicodeFormat($hWnd)
Local $tButton = DllStructCreate($tagTBBUTTONINFO)
Local $iButton = DllStructGetSize($tButton)
Local $iMask = BitOR($TBIF_IMAGE, $TBIF_STATE, $TBIF_STYLE, $TBIF_LPARAM, $TBIF_SIZE)
DllStructSetData($tButton, "Size", $iButton)
DllStructSetData($tButton, "Mask", $iMask)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_GETBUTTONINFOW, $iCommandID, $tButton, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iButton, $tMemMap)
_MemWrite($tMemMap, $tButton, $pMemory, $iButton)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TB_GETBUTTONINFOW, $iCommandID, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $TB_GETBUTTONINFOA, $iCommandID, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tButton, $iButton)
_MemFree($tMemMap)
EndIf
Return SetError($iRet = -1, 0, $tButton)
EndFunc
Func _GUICtrlToolbar_GetButtonParam($hWnd, $iCommandID)
Local $tButton = _GUICtrlToolbar_GetButtonInfoEx($hWnd, $iCommandID)
Return DllStructGetData($tButton, "Param")
EndFunc
Func _GUICtrlToolbar_GetButtonRect($hWnd, $iCommandID)
Local $aRect[4]
Local $tRECT = _GUICtrlToolbar_GetButtonRectEx($hWnd, $iCommandID)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlToolbar_GetButtonRectEx($hWnd, $iCommandID)
Local $tRECT = DllStructCreate($tagRECT)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
_SendMessage($hWnd, $TB_GETRECT, $iCommandID, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $TB_GETRECT, $iCommandID, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Return $tRECT
EndFunc
Func _GUICtrlToolbar_GetButtonSize($hWnd)
Local $aSize[2]
Local $iRet = _SendMessage($hWnd, $TB_GETBUTTONSIZE)
$aSize[0] = _WinAPI_HiWord($iRet)
$aSize[1] = _WinAPI_LoWord($iRet)
Return $aSize
EndFunc
Func _GUICtrlToolbar_GetButtonState($hWnd, $iCommandID)
Return _SendMessage($hWnd, $TB_GETSTATE, $iCommandID)
EndFunc
Func _GUICtrlToolbar_GetButtonStyle($hWnd, $iCommandID)
Local $tButton = _GUICtrlToolbar_GetButtonInfoEx($hWnd, $iCommandID)
Return DllStructGetData($tButton, "Style")
EndFunc
Func _GUICtrlToolbar_GetButtonText($hWnd, $iCommandID)
Local $bUnicode = _GUICtrlToolbar_GetUnicodeFormat($hWnd)
Local $iBuffer
If $bUnicode Then
$iBuffer = _SendMessage($hWnd, $TB_GETBUTTONTEXTW, $iCommandID)
Else
$iBuffer = _SendMessage($hWnd, $TB_GETBUTTONTEXTA, $iCommandID)
EndIf
If $iBuffer = 0 Then Return SetError(True, 0, "")
If $iBuffer = 1 Then Return SetError(False, 0, "")
If $iBuffer <= -1 Then Return SetError(False, -1, "")
$iBuffer += 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_GETBUTTONTEXTW, $iCommandID, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TB_GETBUTTONTEXTW, $iCommandID, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $TB_GETBUTTONTEXTA, $iCommandID, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Return SetError($iRet > 0, 0, DllStructGetData($tBuffer, "Text"))
EndFunc
Func _GUICtrlToolbar_GetColorScheme($hWnd)
Local $aColor[2], $iRet
Local $tColor = DllStructCreate($tagCOLORSCHEME)
Local $iColor = DllStructGetSize($tColor)
DllStructSetData($tColor, "Size", $iColor)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_GETCOLORSCHEME, 0, $tColor, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColor, $tMemMap)
$iRet = _SendMessage($hWnd, $TB_GETCOLORSCHEME, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tColor, $iColor)
_MemFree($tMemMap)
EndIf
$aColor[0] = DllStructGetData($tColor, "BtnHighlight")
$aColor[1] = DllStructGetData($tColor, "BtnShadow")
Return SetError($iRet = 0, 0, $aColor)
EndFunc
Func _GUICtrlToolbar_GetDisabledImageList($hWnd)
Return Ptr(_SendMessage($hWnd, $TB_GETDISABLEDIMAGELIST))
EndFunc
Func _GUICtrlToolbar_GetExtendedStyle($hWnd)
Return _SendMessage($hWnd, $TB_GETEXTENDEDSTYLE)
EndFunc
Func _GUICtrlToolbar_GetHotImageList($hWnd)
Return Ptr(_SendMessage($hWnd, $TB_GETHOTIMAGELIST))
EndFunc
Func _GUICtrlToolbar_GetHotItem($hWnd)
Return _SendMessage($hWnd, $TB_GETHOTITEM)
EndFunc
Func _GUICtrlToolbar_GetImageList($hWnd)
Return Ptr(_SendMessage($hWnd, $TB_GETIMAGELIST))
EndFunc
Func _GUICtrlToolbar_GetInsertMark($hWnd)
Local $aMark[2], $iRet
Local $tMark = DllStructCreate($tagTBINSERTMARK)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_GETINSERTMARK, 0, $tMark, 0, "wparam", "struct*")
Else
Local $iMark = DllStructGetSize($tMark)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMark, $tMemMap)
$iRet = _SendMessage($hWnd, $TB_GETINSERTMARK, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tMark, $iMark)
_MemFree($tMemMap)
EndIf
$aMark[0] = DllStructGetData($tMark, "Button")
$aMark[1] = DllStructGetData($tMark, "Flags")
Return SetError($iRet <> 0, 0, $aMark)
EndFunc
Func _GUICtrlToolbar_GetInsertMarkColor($hWnd)
Return _SendMessage($hWnd, $TB_GETINSERTMARKCOLOR)
EndFunc
Func _GUICtrlToolbar_GetMaxSize($hWnd)
Local $aSize[2], $iRet
Local $tSize = DllStructCreate($tagSIZE)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_GETMAXSIZE, 0, $tSize, 0, "wparam", "struct*")
Else
Local $iSize = DllStructGetSize($tSize)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
$iRet = _SendMessage($hWnd, $TB_GETMAXSIZE, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tSize, $iSize)
_MemFree($tMemMap)
EndIf
$aSize[0] = DllStructGetData($tSize, "X")
$aSize[1] = DllStructGetData($tSize, "Y")
Return SetError($iRet = 0, 0, $aSize)
EndFunc
Func _GUICtrlToolbar_GetMetrics($hWnd)
Local $aMetrics[4]
Local $tMetrics = DllStructCreate($tagTBMETRICS)
Local $iMetrics = DllStructGetSize($tMetrics)
Local $iMask = BitOR($TBMF_PAD, $TBMF_BUTTONSPACING)
DllStructSetData($tMetrics, "Size", $iMetrics)
DllStructSetData($tMetrics, "Mask", $iMask)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
_SendMessage($hWnd, $TB_GETMETRICS, 0, $tMetrics, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMetrics, $tMemMap)
_SendMessage($hWnd, $TB_GETMETRICS, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tMetrics, $iMetrics)
_MemFree($tMemMap)
EndIf
$aMetrics[0] = DllStructGetData($tMetrics, "XPad")
$aMetrics[1] = DllStructGetData($tMetrics, "YPad")
$aMetrics[2] = DllStructGetData($tMetrics, "XSpacing")
$aMetrics[3] = DllStructGetData($tMetrics, "YSpacing")
Return $aMetrics
EndFunc
Func _GUICtrlToolbar_GetPadding($hWnd)
Local $aPad[2]
Local $iPad = _SendMessage($hWnd, $TB_GETPADDING)
$aPad[0] = _WinAPI_LoWord($iPad)
$aPad[1] = _WinAPI_HiWord($iPad)
Return $aPad
EndFunc
Func _GUICtrlToolbar_GetRows($hWnd)
Return _SendMessage($hWnd, $TB_GETROWS)
EndFunc
Func _GUICtrlToolbar_GetString($hWnd, $iIndex)
Local $bUnicode = _GUICtrlToolbar_GetUnicodeFormat($hWnd)
Local $iBuffer
If $bUnicode Then
$iBuffer = _SendMessage($hWnd, $TB_GETSTRINGW, _WinAPI_MakeLong(0, $iIndex), 0, 0, "long") + 1
Else
$iBuffer = _SendMessage($hWnd, $TB_GETSTRINGA, _WinAPI_MakeLong(0, $iIndex), 0, 0, "long") + 1
EndIf
If $iBuffer = 0 Then Return SetError(-1, 0, "")
If $iBuffer = 1 Then Return ""
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_GETSTRINGW, _WinAPI_MakeLong($iBuffer, $iIndex), $tBuffer, 0, "long", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TB_GETSTRINGW, _WinAPI_MakeLong($iBuffer, $iIndex), $pMemory, 0, "long", "ptr")
Else
$iRet = _SendMessage($hWnd, $TB_GETSTRINGA, _WinAPI_MakeLong($iBuffer, $iIndex), $pMemory, 0, "long", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Return SetError($iRet = -1, 0, DllStructGetData($tBuffer, "Text"))
EndFunc
Func _GUICtrlToolbar_GetStyle($hWnd)
Return _SendMessage($hWnd, $TB_GETSTYLE)
EndFunc
Func _GUICtrlToolbar_GetStyleAltDrag($hWnd)
Return BitAND(_GUICtrlToolbar_GetStyle($hWnd), $TBSTYLE_ALTDRAG) <> 0
EndFunc
Func _GUICtrlToolbar_GetStyleCustomErase($hWnd)
Return BitAND(_GUICtrlToolbar_GetStyle($hWnd), $TBSTYLE_CUSTOMERASE) <> 0
EndFunc
Func _GUICtrlToolbar_GetStyleFlat($hWnd)
Return BitAND(_GUICtrlToolbar_GetStyle($hWnd), $TBSTYLE_FLAT) <> 0
EndFunc
Func _GUICtrlToolbar_GetStyleList($hWnd)
Return BitAND(_GUICtrlToolbar_GetStyle($hWnd), $TBSTYLE_LIST) <> 0
EndFunc
Func _GUICtrlToolbar_GetStyleRegisterDrop($hWnd)
Return BitAND(_GUICtrlToolbar_GetStyle($hWnd), $TBSTYLE_REGISTERDROP) <> 0
EndFunc
Func _GUICtrlToolbar_GetStyleToolTips($hWnd)
Return BitAND(_GUICtrlToolbar_GetStyle($hWnd), $TBSTYLE_TOOLTIPS) <> 0
EndFunc
Func _GUICtrlToolbar_GetStyleTransparent($hWnd)
Return BitAND(_GUICtrlToolbar_GetStyle($hWnd), $TBSTYLE_TRANSPARENT) <> 0
EndFunc
Func _GUICtrlToolbar_GetStyleWrapable($hWnd)
Return BitAND(_GUICtrlToolbar_GetStyle($hWnd), $TBSTYLE_WRAPABLE) <> 0
EndFunc
Func _GUICtrlToolbar_GetTextRows($hWnd)
Return _SendMessage($hWnd, $TB_GETTEXTROWS)
EndFunc
Func _GUICtrlToolbar_GetToolTips($hWnd)
Return HWnd(_SendMessage($hWnd, $TB_GETTOOLTIPS))
EndFunc
Func _GUICtrlToolbar_GetUnicodeFormat($hWnd)
Return _SendMessage($hWnd, $TB_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlToolbar_HideButton($hWnd, $iCommandID, $bHide = True)
Return _SendMessage($hWnd, $TB_HIDEBUTTON, $iCommandID, $bHide) <> 0
EndFunc
Func _GUICtrlToolbar_HighlightButton($hWnd, $iCommandID, $bHighlight = True)
Return _SendMessage($hWnd, $TB_MARKBUTTON, $iCommandID, $bHighlight) <> 0
EndFunc
Func _GUICtrlToolbar_HitTest($hWnd, $iX, $iY)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iX)
DllStructSetData($tPoint, "Y", $iY)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_HITTEST, 0, $tPoint, 0, "wparam", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
_MemWrite($tMemMap, $tPoint, $pMemory, $iPoint)
$iRet = _SendMessage($hWnd, $TB_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func _GUICtrlToolbar_IndexToCommand($hWnd, $iIndex)
Local $tButton = DllStructCreate($tagTBBUTTON)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
_SendMessage($hWnd, $TB_GETBUTTON, $iIndex, $tButton, 0, "wparam", "struct*")
Else
Local $iButton = DllStructGetSize($tButton)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iButton, $tMemMap)
_MemWrite($tMemMap, $tButton, $pMemory, $iButton)
_SendMessage($hWnd, $TB_GETBUTTON, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tButton, $iButton)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tButton, "Command")
EndFunc
Func _GUICtrlToolbar_InsertButton($hWnd, $iIndex, $iID, $iImage, $sText = "", $iStyle = 0, $iState = 4, $iParam = 0)
Local $bUnicode = _GUICtrlToolbar_GetUnicodeFormat($hWnd)
Local $tBuffer, $iRet
Local $tButton = DllStructCreate($tagTBBUTTON)
Local $iBuffer = StringLen($sText) + 1
If $iBuffer > 1 Then
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tButton, "String", DllStructGetPtr($tBuffer))
EndIf
DllStructSetData($tButton, "Bitmap", $iImage)
DllStructSetData($tButton, "Command", $iID)
DllStructSetData($tButton, "State", $iState)
DllStructSetData($tButton, "Style", $iStyle)
DllStructSetData($tButton, "Param", $iParam)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_INSERTBUTTONW, $iIndex, $tButton, 0, "wparam", "struct*")
Else
Local $iButton = DllStructGetSize($tButton)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iButton + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iButton
_MemWrite($tMemMap, $tButton, $pMemory, $iButton)
If $iBuffer > 1 Then
DllStructSetData($tButton, "String", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
EndIf
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TB_INSERTBUTTONW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $TB_INSERTBUTTONA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlToolbar_InsertMarkHitTest($hWnd, $iX, $iY)
Local $aMark[2], $iRet
Local $tPoint = DllStructCreate($tagPOINT)
Local $tMark = DllStructCreate($tagTBINSERTMARK)
DllStructSetData($tPoint, "X", $iX)
DllStructSetData($tPoint, "Y", $iY)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_INSERTMARKHITTEST, $tPoint, $tMark, 0, "struct*", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $iMark = DllStructGetSize($tMark)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint + $iMark, $tMemMap)
Local $pMarkPtr = $pMemory + $iPoint
_MemWrite($tMemMap, $tPoint, $pMemory, $iPoint)
$iRet = _SendMessage($hWnd, $TB_INSERTMARKHITTEST, $pMemory, $pMarkPtr, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMarkPtr, $tMark, $iMark)
_MemFree($tMemMap)
EndIf
$aMark[0] = DllStructGetData($tMark, "Button")
$aMark[1] = DllStructGetData($tMark, "Flags")
Return SetError($iRet <> 0, 0, $aMark)
EndFunc
Func _GUICtrlToolbar_IsButtonChecked($hWnd, $iCommandID)
Return _SendMessage($hWnd, $TB_ISBUTTONCHECKED, $iCommandID) <> 0
EndFunc
Func _GUICtrlToolbar_IsButtonEnabled($hWnd, $iCommandID)
Return _SendMessage($hWnd, $TB_ISBUTTONENABLED, $iCommandID) <> 0
EndFunc
Func _GUICtrlToolbar_IsButtonHidden($hWnd, $iCommandID)
Return _SendMessage($hWnd, $TB_ISBUTTONHIDDEN, $iCommandID) <> 0
EndFunc
Func _GUICtrlToolbar_IsButtonHighlighted($hWnd, $iCommandID)
Return _SendMessage($hWnd, $TB_ISBUTTONHIGHLIGHTED, $iCommandID) <> 0
EndFunc
Func _GUICtrlToolbar_IsButtonIndeterminate($hWnd, $iCommandID)
Return _SendMessage($hWnd, $TB_ISBUTTONINDETERMINATE, $iCommandID) <> 0
EndFunc
Func _GUICtrlToolbar_IsButtonPressed($hWnd, $iCommandID)
Return _SendMessage($hWnd, $TB_ISBUTTONPRESSED, $iCommandID) <> 0
EndFunc
Func _GUICtrlToolbar_LoadBitmap($hWnd, $sFileName)
Local $aSize = _GUICtrlToolbar_GetButtonSize($hWnd)
Local $hBitmap = _WinAPI_LoadImage(0, $sFileName, 0, $aSize[1], $aSize[0], $LR_LOADFROMFILE)
If $hBitmap = 0 Then Return SetError(-1, -1, -1)
Return _GUICtrlToolbar_AddBitmap($hWnd, 1, 0, $hBitmap)
EndFunc
Func _GUICtrlToolbar_LoadImages($hWnd, $iBitMapID)
Return _SendMessage($hWnd, $TB_LOADIMAGES, $iBitMapID, $__TOOLBARCONSTANT_HINST_COMMCTRL)
EndFunc
Func _GUICtrlToolbar_MapAccelerator($hWnd, $sAccelKey)
Local $tCommand = DllStructCreate("int Data")
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
_SendMessage($hWnd, $TB_MAPACCELERATORW, Asc($sAccelKey), $tCommand, 0, "wparam", "struct*")
Else
Local $iCommand = DllStructGetSize($tCommand)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iCommand, $tMemMap)
_SendMessage($hWnd, $TB_MAPACCELERATORW, Asc($sAccelKey), $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tCommand, $iCommand)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tCommand, "Data")
EndFunc
Func _GUICtrlToolbar_MoveButton($hWnd, $iOldPos, $iNewPos)
Return _SendMessage($hWnd, $TB_MOVEBUTTON, $iOldPos, $iNewPos) <> 0
EndFunc
Func _GUICtrlToolbar_PressButton($hWnd, $iCommandID, $bPress = True)
Return _SendMessage($hWnd, $TB_PRESSBUTTON, $iCommandID, $bPress) <> 0
EndFunc
Func _GUICtrlToolbar_SetAnchorHighlight($hWnd, $bAnchor)
Return _SendMessage($hWnd, $TB_SETANCHORHIGHLIGHT, $bAnchor)
EndFunc
Func _GUICtrlToolbar_SetBitmapSize($hWnd, $iWidth, $iHeight)
Return _SendMessage($hWnd, $TB_SETBITMAPSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight), 0, "wparam", "long") <> 0
EndFunc
Func _GUICtrlToolbar_SetButtonBitMap($hWnd, $iCommandID, $iIndex)
Return _SendMessage($hWnd, $TB_CHANGEBITMAP, $iCommandID, $iIndex) <> 0
EndFunc
Func _GUICtrlToolbar_SetButtonInfo($hWnd, $iCommandID, $iImage = -3, $iState = -1, $iStyle = -1, $iWidth = -1, $iParam = -1)
Local $iMask = 0
Local $tButton = DllStructCreate($tagTBBUTTONINFO)
If $iImage <> -3 Then
$iMask = $TBIF_IMAGE
DllStructSetData($tButton, "Image", $iImage)
EndIf
If $iState <> -1 Then
$iMask = BitOR($iMask, $TBIF_STATE)
DllStructSetData($tButton, "State", $iState)
EndIf
If $iStyle <> -1 Then
$iMask = BitOR($iMask, $TBIF_STYLE)
DllStructSetData($tButton, "Style", $iStyle)
EndIf
If $iWidth <> -1 Then
$iMask = BitOR($iMask, $TBIF_SIZE)
DllStructSetData($tButton, "CX", $iWidth)
EndIf
If $iParam <> -1 Then
$iMask = BitOR($iMask, $TBIF_LPARAM)
DllStructSetData($tButton, "Param", $iParam)
EndIf
DllStructSetData($tButton, "Mask", $iMask)
Return _GUICtrlToolbar_SetButtonInfoEx($hWnd, $iCommandID, $tButton)
EndFunc
Func _GUICtrlToolbar_SetButtonInfoEx($hWnd, $iCommandID, $tButton)
Local $iButton = DllStructGetSize($tButton)
DllStructSetData($tButton, "Size", $iButton)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
$iRet = _SendMessage($hWnd, $TB_SETBUTTONINFOW, $iCommandID, $tButton, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetData($tButton, "TextMax")
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iButton + $iBuffer, $tMemMap)
Local $pBuffer = $pMemory + $iButton
DllStructSetData($tButton, "Text", $pBuffer)
_MemWrite($tMemMap, $tButton, $pMemory, $iButton)
_MemWrite($tMemMap, $pBuffer, $pBuffer, $iBuffer)
$iRet = _SendMessage($hWnd, $TB_SETBUTTONINFOW, $iCommandID, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlToolbar_SetButtonParam($hWnd, $iCommandID, $iParam)
Local $tButton = DllStructCreate($tagTBBUTTONINFO)
DllStructSetData($tButton, "Mask", $TBIF_LPARAM)
DllStructSetData($tButton, "Param", $iParam)
Return _GUICtrlToolbar_SetButtonInfoEx($hWnd, $iCommandID, $tButton)
EndFunc
Func _GUICtrlToolbar_SetButtonSize($hWnd, $iHeight, $iWidth)
Return _SendMessage($hWnd, $TB_SETBUTTONSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight), 0, "wparam", "long") <> 0
EndFunc
Func _GUICtrlToolbar_SetButtonState($hWnd, $iCommandID, $iState)
Return _SendMessage($hWnd, $TB_SETSTATE, $iCommandID, $iState) <> 0
EndFunc
Func _GUICtrlToolbar_SetButtonStyle($hWnd, $iCommandID, $iStyle)
Local $tButton = DllStructCreate($tagTBBUTTONINFO)
DllStructSetData($tButton, "Mask", $TBIF_STYLE)
DllStructSetData($tButton, "Style", $iStyle)
Return _GUICtrlToolbar_SetButtonInfoEx($hWnd, $iCommandID, $tButton)
EndFunc
Func _GUICtrlToolbar_SetButtonText($hWnd, $iCommandID, $sText)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("wchar Text[" & $iBuffer * 2 & "]")
$iBuffer *= 2
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tButton = DllStructCreate($tagTBBUTTONINFO)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tButton, "Mask", $TBIF_TEXT)
DllStructSetData($tButton, "Text", $pBuffer)
DllStructSetData($tButton, "TextMax", $iBuffer)
Return _GUICtrlToolbar_SetButtonInfoEx($hWnd, $iCommandID, $tButton)
EndFunc
Func _GUICtrlToolbar_SetButtonWidth($hWnd, $iMin, $iMax)
Return _SendMessage($hWnd, $TB_SETBUTTONWIDTH, 0, _WinAPI_MakeLong($iMin, $iMax), 0, "wparam", "long") <> 0
EndFunc
Func _GUICtrlToolbar_SetCmdID($hWnd, $iIndex, $iCommandID)
Return _SendMessage($hWnd, $TB_SETCMDID, $iIndex, $iCommandID) <> 0
EndFunc
Func _GUICtrlToolbar_SetColorScheme($hWnd, $iHighlight, $iShadow)
Local $tColor = DllStructCreate($tagCOLORSCHEME)
Local $iColor = DllStructGetSize($tColor)
DllStructSetData($tColor, "Size", $iColor)
DllStructSetData($tColor, "BtnHighlight", $iHighlight)
DllStructSetData($tColor, "BtnShadow", $iShadow)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
_SendMessage($hWnd, $TB_SETCOLORSCHEME, 0, $tColor, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColor, $tMemMap)
_MemWrite($tMemMap, $tColor, $pMemory, $iColor)
_SendMessage($hWnd, $TB_SETCOLORSCHEME, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUICtrlToolbar_SetDisabledImageList($hWnd, $hImageList)
Return _SendMessage($hWnd, $TB_SETDISABLEDIMAGELIST, 0, $hImageList, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlToolbar_SetDrawTextFlags($hWnd, $iMask, $iDTFlags)
Return _SendMessage($hWnd, $TB_SETDRAWTEXTFLAGS, $iMask, $iDTFlags)
EndFunc
Func _GUICtrlToolbar_SetExtendedStyle($hWnd, $iStyle)
Return _SendMessage($hWnd, $TB_SETEXTENDEDSTYLE, 0, $iStyle)
EndFunc
Func _GUICtrlToolbar_SetHotImageList($hWnd, $hImageList)
Return _SendMessage($hWnd, $TB_SETHOTIMAGELIST, 0, $hImageList, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlToolbar_SetHotItem($hWnd, $iIndex)
Return _SendMessage($hWnd, $TB_SETHOTITEM, $iIndex)
EndFunc
Func _GUICtrlToolbar_SetImageList($hWnd, $hImageList)
Return _SendMessage($hWnd, $TB_SETIMAGELIST, 0, $hImageList, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlToolbar_SetIndent($hWnd, $iIndent)
Return _SendMessage($hWnd, $TB_SETINDENT, $iIndent) <> 0
EndFunc
Func _GUICtrlToolbar_SetIndeterminate($hWnd, $iCommandID, $bState = True)
Return _SendMessage($hWnd, $TB_INDETERMINATE, $iCommandID, $bState) <> 0
EndFunc
Func _GUICtrlToolbar_SetInsertMark($hWnd, $iButton, $iFlags = 0)
Local $tMark = DllStructCreate($tagTBINSERTMARK)
DllStructSetData($tMark, "Button", $iButton)
DllStructSetData($tMark, "Flags", $iFlags)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
_SendMessage($hWnd, $TB_SETINSERTMARK, 0, $tMark, 0, "wparam", "struct*")
Else
Local $iMark = DllStructGetSize($tMark)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMark, $tMemMap)
_MemWrite($tMemMap, $tMark, $pMemory, $iMark)
_SendMessage($hWnd, $TB_SETINSERTMARK, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUICtrlToolbar_SetInsertMarkColor($hWnd, $iColor)
Return _SendMessage($hWnd, $TB_SETINSERTMARKCOLOR, 0, $iColor)
EndFunc
Func _GUICtrlToolbar_SetMaxTextRows($hWnd, $iMaxRows)
Return _SendMessage($hWnd, $TB_SETMAXTEXTROWS, $iMaxRows) <> 0
EndFunc
Func _GUICtrlToolbar_SetMetrics($hWnd, $iXPad, $iYPad, $iXSpacing, $iYSpacing)
Local $tMetrics = DllStructCreate($tagTBMETRICS)
Local $iMetrics = DllStructGetSize($tMetrics)
Local $iMask = BitOR($TBMF_PAD, $TBMF_BUTTONSPACING)
DllStructSetData($tMetrics, "Size", $iMetrics)
DllStructSetData($tMetrics, "Mask", $iMask)
DllStructSetData($tMetrics, "XPad", $iXPad)
DllStructSetData($tMetrics, "YPad", $iYPad)
DllStructSetData($tMetrics, "XSpacing", $iXSpacing)
DllStructSetData($tMetrics, "YSpacing", $iYSpacing)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
_SendMessage($hWnd, $TB_SETMETRICS, 0, $tMetrics, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMetrics, $tMemMap)
_MemWrite($tMemMap, $tMetrics, $pMemory, $iMetrics)
_SendMessage($hWnd, $TB_SETMETRICS, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUICtrlToolbar_SetPadding($hWnd, $iCX, $iCY)
Return _SendMessage($hWnd, $TB_SETPADDING, 0, _WinAPI_MakeLong($iCX, $iCY), 0, "wparam", "long")
EndFunc
Func _GUICtrlToolbar_SetParent($hWnd, $hParent)
Return HWnd(_SendMessage($hWnd, $TB_SETPARENT, $hParent))
EndFunc
Func _GUICtrlToolbar_SetRows($hWnd, $iRows, $bLarger = True)
Local $tRECT = DllStructCreate($tagRECT)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
_SendMessage($hWnd, $TB_SETROWS, _WinAPI_MakeLong($iRows, $bLarger), $tRECT, 0, "long", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $TB_SETROWS, _WinAPI_MakeLong($iRows, $bLarger), $pMemory, 0, "long", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlToolbar_SetStyle($hWnd, $iStyle)
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__TOOLBARCONSTANT_WS_CLIPSIBLINGS, $__UDFGUICONSTANT_WS_VISIBLE)
_SendMessage($hWnd, $TB_SETSTYLE, 0, $iStyle)
EndFunc
Func _GUICtrlToolbar_SetStyleAltDrag($hWnd, $bState = True)
Return __GUICtrlToolbar_SetStyleEx($hWnd, $TBSTYLE_ALTDRAG, $bState)
EndFunc
Func _GUICtrlToolbar_SetStyleCustomErase($hWnd, $bState = True)
Return __GUICtrlToolbar_SetStyleEx($hWnd, $TBSTYLE_CUSTOMERASE, $bState)
EndFunc
Func __GUICtrlToolbar_SetStyleEx($hWnd, $iStyle, $bStyle)
Local $iN = _GUICtrlToolbar_GetStyle($hWnd)
If $bStyle Then
$iN = BitOR($iN, $iStyle)
Else
$iN = BitAND($iN, BitNOT($iStyle))
EndIf
Return _GUICtrlToolbar_SetStyle($hWnd, $iN)
EndFunc
Func _GUICtrlToolbar_SetStyleFlat($hWnd, $bState)
Return __GUICtrlToolbar_SetStyleEx($hWnd, $TBSTYLE_FLAT, $bState)
EndFunc
Func _GUICtrlToolbar_SetStyleList($hWnd, $bState)
Return __GUICtrlToolbar_SetStyleEx($hWnd, $TBSTYLE_LIST, $bState)
EndFunc
Func _GUICtrlToolbar_SetStyleRegisterDrop($hWnd, $bState)
Return __GUICtrlToolbar_SetStyleEx($hWnd, $TBSTYLE_REGISTERDROP, $bState)
EndFunc
Func _GUICtrlToolbar_SetStyleToolTips($hWnd, $bState)
Return __GUICtrlToolbar_SetStyleEx($hWnd, $TBSTYLE_TOOLTIPS, $bState)
EndFunc
Func _GUICtrlToolbar_SetStyleTransparent($hWnd, $bState)
Return __GUICtrlToolbar_SetStyleEx($hWnd, $TBSTYLE_TRANSPARENT, $bState)
EndFunc
Func _GUICtrlToolbar_SetStyleWrapable($hWnd, $bState)
Return __GUICtrlToolbar_SetStyleEx($hWnd, $TBSTYLE_WRAPABLE, $bState)
EndFunc
Func _GUICtrlToolbar_SetToolTips($hWnd, $hToolTip)
_SendMessage($hWnd, $TB_SETTOOLTIPS, $hToolTip, 0, 0, "hwnd")
EndFunc
Func _GUICtrlToolbar_SetUnicodeFormat($hWnd, $bUnicode = False)
Return _SendMessage($hWnd, $TB_SETUNICODEFORMAT, $bUnicode)
EndFunc
Func _GUICtrlToolbar_SetWindowTheme($hWnd, $sTheme)
Local $tTheme = _WinAPI_MultiByteToWideChar($sTheme)
If _WinAPI_InProcess($hWnd, $__g_hTBLastWnd) Then
_SendMessage($hWnd, $TB_SETWINDOWTHEME, 0, $tTheme, 0, "wparam", "struct*")
Else
Local $iTheme = DllStructGetSize($tTheme)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iTheme, $tMemMap)
_MemWrite($tMemMap, $tTheme, $pMemory, $iTheme)
_SendMessage($hWnd, $TB_SETWINDOWTHEME, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Global Const $PBS_MARQUEE = 0x00000008
Global Const $PBS_SMOOTH = 1
Global Const $PBS_SMOOTHREVERSE = 0x10
Global Const $PBS_VERTICAL = 4
Global Const $GUI_SS_DEFAULT_PROGRESS = 0
Global Const $__PROGRESSBARCONSTANT_WM_USER = 0X400
Global Const $PBM_DELTAPOS = $__PROGRESSBARCONSTANT_WM_USER + 3
Global Const $PBM_GETBARCOLOR = 0x040F
Global Const $PBM_GETBKCOLOR = 0x040E
Global Const $PBM_GETPOS = $__PROGRESSBARCONSTANT_WM_USER + 8
Global Const $PBM_GETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 7
Global Const $PBM_GETSTATE = 0x0411
Global Const $PBM_GETSTEP = 0x040D
Global Const $PBM_SETBARCOLOR = $__PROGRESSBARCONSTANT_WM_USER + 9
Global Const $PBM_SETBKCOLOR = 0x2000 + 1
Global Const $PBM_SETMARQUEE = $__PROGRESSBARCONSTANT_WM_USER + 10
Global Const $PBM_SETPOS = $__PROGRESSBARCONSTANT_WM_USER + 2
Global Const $PBM_SETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 1
Global Const $PBM_SETRANGE32 = $__PROGRESSBARCONSTANT_WM_USER + 6
Global Const $PBM_SETSTATE = 0x0410
Global Const $PBM_SETSTEP = $__PROGRESSBARCONSTANT_WM_USER + 4
Global Const $PBM_STEPIT = $__PROGRESSBARCONSTANT_WM_USER + 5
Global Const $SS_LEFT = 0x0
Global Const $SS_CENTER = 0x1
Global Const $SS_RIGHT = 0x2
Global Const $SS_ICON = 0x3
Global Const $SS_BLACKRECT = 0x4
Global Const $SS_GRAYRECT = 0x5
Global Const $SS_WHITERECT = 0x6
Global Const $SS_BLACKFRAME = 0x7
Global Const $SS_GRAYFRAME = 0x8
Global Const $SS_WHITEFRAME = 0x9
Global Const $SS_SIMPLE = 0xB
Global Const $SS_LEFTNOWORDWRAP = 0xC
Global Const $SS_BITMAP = 0xE
Global Const $SS_ENHMETAFILE = 0xF
Global Const $SS_ETCHEDHORZ = 0x10
Global Const $SS_ETCHEDVERT = 0x11
Global Const $SS_ETCHEDFRAME = 0x12
Global Const $SS_REALSIZECONTROL = 0x40
Global Const $SS_NOPREFIX = 0x0080
Global Const $SS_NOTIFY = 0x0100
Global Const $SS_CENTERIMAGE = 0x0200
Global Const $SS_RIGHTJUST = 0x0400
Global Const $SS_SUNKEN = 0x1000
Global Const $GUI_SS_DEFAULT_LABEL = 0
Global Const $GUI_SS_DEFAULT_GRAPHIC = 0
Global Const $GUI_SS_DEFAULT_ICON = $SS_NOTIFY
Global Const $GUI_SS_DEFAULT_PIC = $SS_NOTIFY
Global Const $STM_SETICON = 0x0170
Global Const $STM_GETICON = 0x0171
Global Const $STM_SETIMAGE = 0x0172
Global Const $STM_GETIMAGE = 0x0173
Global Const $TCS_EX_FLATSEPARATORS = 0x00000001
Global Const $TCS_EX_REGISTERDROP = 0x00000002
Global Const $TCHT_NOWHERE = 0x00000001
Global Const $TCHT_ONITEMICON = 0x00000002
Global Const $TCHT_ONITEMLABEL = 0x00000004
Global Const $TCHT_ONITEM = 0x00000006
Global Const $TCIF_TEXT = 0x00000001
Global Const $TCIF_IMAGE = 0x00000002
Global Const $TCIF_RTLREADING = 0x00000004
Global Const $TCIF_PARAM = 0x00000008
Global Const $TCIF_STATE = 0x00000010
Global Const $TCIF_ALLDATA = 0x0000001B
Global Const $TCIS_BUTTONPRESSED = 0x00000001
Global Const $TCIS_HIGHLIGHTED = 0x00000002
Global Const $TC_ERR = -1
Global Const $TCS_BOTTOM = 0x00000002
Global Const $TCS_BUTTONS = 0x00000100
Global Const $TCS_FIXEDWIDTH = 0x00000400
Global Const $TCS_FLATBUTTONS = 0x00000008
Global Const $TCS_FOCUSNEVER = 0x00008000
Global Const $TCS_FOCUSONBUTTONDOWN = 0x00001000
Global Const $TCS_FORCEICONLEFT = 0x00000010
Global Const $TCS_FORCELABELLEFT = 0x00000020
Global Const $TCS_HOTTRACK = 0x00000040
Global Const $TCS_MULTILINE = 0x00000200
Global Const $TCS_MULTISELECT = 0x00000004
Global Const $TCS_OWNERDRAWFIXED = 0x00002000
Global Const $TCS_RAGGEDRIGHT = 0x00000800
Global Const $TCS_RIGHT = 0x00000002
Global Const $TCS_RIGHTJUSTIFY = 0x00000000
Global Const $TCS_SCROLLOPPOSITE = 0x00000001
Global Const $TCS_SINGLELINE = 0x00000000
Global Const $TCS_TABS = 0x00000000
Global Const $TCS_TOOLTIPS = 0x00004000
Global Const $TCS_VERTICAL = 0x00000080
Global Const $GUI_SS_DEFAULT_TAB = 0
Global Const $TCM_FIRST = 0x1300
Global Const $TCCM_FIRST = 0X2000
Global Const $TCM_ADJUSTRECT = ($TCM_FIRST + 40)
Global Const $TCM_DELETEALLITEMS = ($TCM_FIRST + 9)
Global Const $TCM_DELETEITEM = ($TCM_FIRST + 8)
Global Const $TCM_DESELECTALL = ($TCM_FIRST + 50)
Global Const $TCM_GETCURFOCUS = ($TCM_FIRST + 47)
Global Const $TCM_GETCURSEL = ($TCM_FIRST + 11)
Global Const $TCM_GETEXTENDEDSTYLE = ($TCM_FIRST + 53)
Global Const $TCM_GETIMAGELIST = ($TCM_FIRST + 2)
Global Const $TCM_GETITEMA = ($TCM_FIRST + 5)
Global Const $TCM_GETITEMW = ($TCM_FIRST + 60)
Global Const $TCM_GETITEMCOUNT = ($TCM_FIRST + 4)
Global Const $TCM_GETITEMRECT = ($TCM_FIRST + 10)
Global Const $TCM_GETROWCOUNT = ($TCM_FIRST + 44)
Global Const $TCM_GETTOOLTIPS = ($TCM_FIRST + 45)
Global Const $TCCM_GETUNICODEFORMAT = ($TCCM_FIRST + 6)
Global Const $TCM_GETUNICODEFORMAT = $TCCM_GETUNICODEFORMAT
Global Const $TCM_HIGHLIGHTITEM = ($TCM_FIRST + 51)
Global Const $TCM_HITTEST = ($TCM_FIRST + 13)
Global Const $TCM_INSERTITEMA = ($TCM_FIRST + 7)
Global Const $TCM_INSERTITEMW = ($TCM_FIRST + 62)
Global Const $TCM_REMOVEIMAGE = ($TCM_FIRST + 42)
Global Const $TCM_SETITEMA = ($TCM_FIRST + 6)
Global Const $TCM_SETITEMW = ($TCM_FIRST + 61)
Global Const $TCM_SETITEMEXTRA = ($TCM_FIRST + 14)
Global Const $TCM_SETITEMSIZE = $TCM_FIRST + 41
Global Const $TCM_SETCURFOCUS = ($TCM_FIRST + 48)
Global Const $TCM_SETCURSEL = ($TCM_FIRST + 12)
Global Const $TCM_SETEXTENDEDSTYLE = ($TCM_FIRST + 52)
Global Const $TCM_SETIMAGELIST = $TCM_FIRST + 3
Global Const $TCM_SETMINTABWIDTH = ($TCM_FIRST + 49)
Global Const $TCM_SETPADDING = ($TCM_FIRST + 43)
Global Const $TCM_SETTOOLTIPS = ($TCM_FIRST + 46)
Global Const $TCCM_SETUNICODEFORMAT = ($TCCM_FIRST + 5)
Global Const $TCM_SETUNICODEFORMAT = $TCCM_SETUNICODEFORMAT
Global Const $TCN_FIRST = -550
Global Const $TCN_FOCUSCHANGE = ($TCN_FIRST - 4)
Global Const $TCN_GETOBJECT = ($TCN_FIRST - 3)
Global Const $TCN_KEYDOWN = ($TCN_FIRST - 0)
Global Const $TCN_SELCHANGE = ($TCN_FIRST - 1)
Global Const $TCN_SELCHANGING = ($TCN_FIRST - 2)
Global Const $CREATE_BREAKAWAY_FROM_JOB = 0x01000000
Global Const $CREATE_DEFAULT_ERROR_MODE = 0x04000000
Global Const $CREATE_NEW_CONSOLE = 0x00000010
Global Const $CREATE_NEW_PROCESS_GROUP = 0x00000200
Global Const $CREATE_NO_WINDOW = 0x08000000
Global Const $CREATE_PROTECTED_PROCESS = 0x00040000
Global Const $CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000
Global Const $CREATE_SEPARATE_WOW_VDM = 0x00000800
Global Const $CREATE_SHARED_WOW_VDM = 0x00001000
Global Const $CREATE_SUSPENDED = 0x00000004
Global Const $CREATE_UNICODE_ENVIRONMENT = 0x00000400
Global Const $LIST_MODULES_32BIT = 1
Global Const $LIST_MODULES_64BIT = 2
Global Const $LIST_MODULES_ALL = 3
Global Const $LIST_MODULES_DEFAULT = 0
Global Const $ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000
Global Const $BELOW_NORMAL_PRIORITY_CLASS = 0x00004000
Global Const $HIGH_PRIORITY_CLASS = 0x00000080
Global Const $IDLE_PRIORITY_CLASS = 0x00000040
Global Const $NORMAL_PRIORITY_CLASS = 0x00000020
Global Const $REALTIME_PRIORITY_CLASS = 0x00000100
Global Const $PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000
Global Const $PROCESS_MODE_BACKGROUND_END = 0x00200000
Global Const $MUTEX_MODIFY_STATE = 0x0001
Global Const $MUTEX_ALL_ACCESS = 0x001F0001
Global Const $JOB_OBJECT_ASSIGN_PROCESS = 0x0001
Global Const $JOB_OBJECT_QUERY = 0x0004
Global Const $JOB_OBJECT_SET_ATTRIBUTES = 0x0002
Global Const $JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 0x0010
Global Const $JOB_OBJECT_TERMINATE = 0x0008
Global Const $JOB_OBJECT_ALL_ACCESS = 0x001F001F
Global Const $JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 0x00000008
Global Const $JOB_OBJECT_LIMIT_AFFINITY = 0x00000010
Global Const $JOB_OBJECT_LIMIT_BREAKAWAY_OK = 0x00000800
Global Const $JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400
Global Const $JOB_OBJECT_LIMIT_JOB_MEMORY = 0x00000200
Global Const $JOB_OBJECT_LIMIT_JOB_TIME = 0x00000004
Global Const $JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 0x00002000
Global Const $JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 0x00000040
Global Const $JOB_OBJECT_LIMIT_PRIORITY_CLASS = 0x00000020
Global Const $JOB_OBJECT_LIMIT_PROCESS_MEMORY = 0x00000100
Global Const $JOB_OBJECT_LIMIT_PROCESS_TIME = 0x00000002
Global Const $JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 0x00000080
Global Const $JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 0x00001000
Global Const $JOB_OBJECT_LIMIT_WORKINGSET = 0x00000001
Global Const $JOB_OBJECT_UILIMIT_DESKTOP = 0x00000040
Global Const $JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 0x00000010
Global Const $JOB_OBJECT_UILIMIT_EXITWINDOWS = 0x00000080
Global Const $JOB_OBJECT_UILIMIT_GLOBALATOMS = 0x00000020
Global Const $JOB_OBJECT_UILIMIT_HANDLES = 0x00000001
Global Const $JOB_OBJECT_UILIMIT_READCLIPBOARD = 0x00000002
Global Const $JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008
Global Const $JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 0x00000004
Global Const $JOB_OBJECT_SECURITY_FILTER_TOKENS = 0x00000008
Global Const $JOB_OBJECT_SECURITY_NO_ADMIN = 0x00000001
Global Const $JOB_OBJECT_SECURITY_ONLY_TOKEN = 0x00000004
Global Const $JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x00000002
Global Const $JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0
Global Const $JOB_OBJECT_POST_AT_END_OF_JOB = 1
Global Const $SEMAPHORE_MODIFY_STATE = 0x0002
Global Const $SEMAPHORE_QUERY_STATE = 0x0001
Global Const $SEMAPHORE_ALL_ACCESS = 0x001F0003
Global Const $ES_AWAYMODE_REQUIRED = 0x00000040
Global Const $ES_CONTINUOUS = 0x80000000
Global Const $ES_DISPLAY_REQUIRED = 0x00000002
Global Const $ES_SYSTEM_REQUIRED = 0x00000001
Global Const $ES_USER_PRESENT = 0x00000004
Global Const $COINIT_APARTMENTTHREADED = 0x02
Global Const $COINIT_DISABLE_OLE1DDE = 0x04
Global Const $COINIT_MULTITHREADED = 0x00
Global Const $COINIT_SPEED_OVER_MEMORY = 0x08
#Region Global Variables and Constants
Global $__g_vEnum, $__g_vExt = 0
Global $__g_hHeap = 0, $__g_iRGBMode = 1
Global Const $tagOSVERSIONINFO = 'struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct'
Global Const $__WINVER = __WINVER()
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_ArrayToStruct(Const ByRef $aData, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aData, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'wchar[' & (StringLen($aData[$i]) + 1) & '];'
Next
Local $tData = DllStructCreate($tagStruct & 'wchar[1]')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tData, $iCount, $aData[$i])
$iCount += 1
Next
DllStructSetData($tData, $iCount, ChrW(0))
Return $tData
EndFunc
Func _WinAPI_CreateMargins($iLeftWidth, $iRightWidth, $iTopHeight, $iBottomHeight)
Local $tMARGINS = DllStructCreate($tagMARGINS)
DllStructSetData($tMARGINS, 1, $iLeftWidth)
DllStructSetData($tMARGINS, 2, $iRightWidth)
DllStructSetData($tMARGINS, 3, $iTopHeight)
DllStructSetData($tMARGINS, 4, $iBottomHeight)
Return $tMARGINS
EndFunc
Func _WinAPI_CreatePoint($iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
DllStructSetData($tPOINT, 1, $iX)
DllStructSetData($tPOINT, 2, $iY)
Return $tPOINT
EndFunc
Func _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iLeft)
DllStructSetData($tRECT, 2, $iTop)
DllStructSetData($tRECT, 3, $iRight)
DllStructSetData($tRECT, 4, $iBottom)
Return $tRECT
EndFunc
Func _WinAPI_CreateRectEx($iX, $iY, $iWidth, $iHeight)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iX)
DllStructSetData($tRECT, 2, $iY)
DllStructSetData($tRECT, 3, $iX + $iWidth)
DllStructSetData($tRECT, 4, $iY + $iHeight)
Return $tRECT
EndFunc
Func _WinAPI_CreateSize($iWidth, $iHeight)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, $iWidth)
DllStructSetData($tSIZE, 2, $iHeight)
Return $tSIZE
EndFunc
Func _WinAPI_FatalExit($iCode)
DllCall('kernel32.dll', 'none', 'FatalExit', 'int', $iCode)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_GetBitmapDimension($hBitmap)
Local Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return _WinAPI_CreateSize(DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'))
EndFunc
Func _WinAPI_GetString($pString, $bUnicode = True)
Local $iLength = _WinAPI_StrLen($pString, $bUnicode)
If @error Or Not $iLength Then Return SetError(@error + 10, @extended, '')
Local $tString = DllStructCreate(__Iif($bUnicode, 'wchar', 'char') & '[' & ($iLength + 1) & ']', $pString)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($iLength, DllStructGetData($tString, 1))
EndFunc
Func _WinAPI_IsBadReadPtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadReadPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadWritePtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadWritePtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsWow64Process($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsWow64Process', 'handle', $hProcess[0], 'bool*', 0)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, False)
Return $aRet[2]
EndFunc
Func _WinAPI_MoveMemory($pDestination, $pSource, $iLength)
If _WinAPI_IsBadReadPtr($pSource, $iLength) Then Return SetError(10, @extended, 0)
If _WinAPI_IsBadWritePtr($pDestination, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlMoveMemory', 'struct*', $pDestination, 'struct*', $pSource, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_PathIsDirectory($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsDirectoryW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StrLen($pString, $bUnicode = True)
Local $W = ''
If $bUnicode Then $W = 'W'
Local $aRet = DllCall('kernel32.dll', 'int', 'lstrlen' & $W, 'struct*', $pString)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_StructToArray(ByRef $tStruct, $iItems = 0)
Local $iSize = 2 * Floor(DllStructGetSize($tStruct) / 2)
Local $pStruct = DllStructGetPtr($tStruct)
If Not $iSize Or Not $pStruct Then Return SetError(1, 0, 0)
Local $tData, $iLength, $iOffset = 0
Local $aResult[101] = [0]
While 1
$iLength = _WinAPI_StrLen($pStruct + $iOffset)
If Not $iLength Then
ExitLoop
EndIf
If 2 * (1 + $iLength) + $iOffset > $iSize Then Return SetError(3, 0, 0)
$tData = DllStructCreate('wchar[' & (1 + $iLength) & ']', $pStruct + $iOffset)
If @error Then Return SetError(@error + 10, 0, 0)
__Inc($aResult)
$aResult[$aResult[0]] = DllStructGetData($tData, 1)
If $aResult[0] = $iItems Then
ExitLoop
EndIf
$iOffset += 2 * (1 + $iLength)
If $iOffset >= $iSize Then Return SetError(3, 0, 0)
WEnd
If Not $aResult[0] Then Return SetError(2, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_SwapDWord($iValue)
Local $tStruct1 = DllStructCreate('dword;dword')
Local $tStruct2 = DllStructCreate('byte[4];byte[4]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 4
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 5 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_SwapQWord($iValue)
Local $tStruct1 = DllStructCreate('int64;int64')
Local $tStruct2 = DllStructCreate('byte[8];byte[8]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 8
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 9 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_SwapWord($iValue)
Local $tStruct1 = DllStructCreate('word;word')
Local $tStruct2 = DllStructCreate('byte[2];byte[2]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 2
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 3 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_SwitchColor($iColor)
If $iColor = -1 Then Return $iColor
Return BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndFunc
Func _WinAPI_ZeroMemory($pMemory, $iLength)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlZeroMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __CheckErrorArrayBounds(Const ByRef $aData, ByRef $iStart, ByRef $iEnd, $nDim = 1, $iDim = $UBOUND_DIMENSIONS)
If Not IsArray($aData) Then Return SetError(1, 0, 1)
If UBound($aData, $iDim) <> $nDim Then Return SetError(2, 0, 1)
If $iStart < 0 Then $iStart = 0
Local $iUBound = UBound($aData) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart > $iEnd Then Return SetError(4, 0, 1)
Return 0
EndFunc
Func __CheckErrorCloseHandle($aRet, $hFile, $bLastError = 0, $iCurErr = @error, $iCurExt = @extended)
If Not $iCurErr And Not $aRet[0] Then $iCurErr = 10
Local $iLastError = _WinAPI_GetLastError()
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iCurErr Then _WinAPI_SetLastError($iLastError)
If $bLastError Then $iCurExt = $iLastError
Return SetError($iCurErr, $iCurExt, $iCurErr)
EndFunc
Func __DLL($sPath, $bPin = False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetModuleHandleExW', 'dword', __Iif($bPin, 0x0001, 0x0002), "wstr", $sPath, 'ptr*', 0)
If Not $aRet[3] Then
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sPath)
If Not $aResult[0] Then Return 0
EndIf
Return 1
EndFunc
Func __EnumWindowsProc($hWnd, $bVisible)
Local $aResult
If $bVisible Then
$aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If Not $aResult[0] Then
Return 1
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hWnd
$aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
$__g_vEnum[$__g_vEnum[0][0]][1] = $aResult[2]
Return 1
EndFunc
Func __FatalExit($iCode, $sText = '')
If $sText Then MsgBox($MB_SYSTEMMODAL, 'AutoIt', $sText)
_WinAPI_FatalExit($iCode)
EndFunc
Func __HeapAlloc($iSize, $bAbort = False)
Local $aRet
If Not $__g_hHeap Then
$aRet = DllCall('kernel32.dll', 'handle', 'HeapCreate', 'dword', 0, 'ulong_ptr', 0, 'ulong_ptr', 0)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
$__g_hHeap = $aRet[0]
EndIf
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 30, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func __HeapFree(ByRef $pMemory, $bCheck = False, $iCurErr = @error, $iCurExt = @extended)
If $bCheck And (Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'int', 'HeapFree', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or Not $aRet[0] Then Return SetError(@error + 40, @extended, 0)
$pMemory = 0
Return SetError($iCurErr, $iCurExt, 1)
EndFunc
Func __HeapReAlloc($pMemory, $iSize, $bAmount = False, $bAbort = False)
Local $aRet, $pRet
If __HeapValidate($pMemory) Then
If $bAmount And (__HeapSize($pMemory) >= $iSize) Then Return SetExtended(1, Ptr($pMemory))
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapReAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ptr', $pMemory,  'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 20, @extended, Ptr($pMemory))
EndIf
$pRet = $aRet[0]
Else
$pRet = __HeapAlloc($iSize, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
EndIf
Return $pRet
EndFunc
Func __HeapSize($pMemory, $bCheck = False)
If $bCheck And (Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'ulong_ptr', 'HeapSize', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or ($aRet[0] = Ptr(-1)) Then Return SetError(@error + 50, @extended, 0)
Return $aRet[0]
EndFunc
Func __HeapValidate($pMemory)
If (Not $__g_hHeap) Or (Not Ptr($pMemory)) Then Return SetError(9, 0, False)
Local $aRet = DllCall('kernel32.dll', 'int', 'HeapValidate', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func __Inc(ByRef $aData, $iIncrement = 100)
Select
Case UBound($aData, $UBOUND_COLUMNS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0][0] + 1][UBound($aData, $UBOUND_COLUMNS)]
Else
$aData[0][0] += 1
If $aData[0][0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0][0] + $iIncrement][UBound($aData, $UBOUND_COLUMNS)]
EndIf
EndIf
Case UBound($aData, $UBOUND_ROWS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0] + 1]
Else
$aData[0] += 1
If $aData[0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0] + $iIncrement]
EndIf
EndIf
Case Else
Return 0
EndSelect
Return 1
EndFunc
Func __Iif($bTest, $vTrue, $vFalse)
Return $bTest ? $vTrue : $vFalse
EndFunc
Func __Init($dData)
Local $iLength = BinaryLen($dData)
Local $aRet = DllCall('kernel32.dll', 'ptr', 'VirtualAlloc', 'ptr', 0, 'ulong_ptr', $iLength, 'dword', 0x00001000, 'dword', 0x00000040)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
Local $tData = DllStructCreate('byte[' & $iLength & "]", $aRet[0])
DllStructSetData($tData, 1, $dData)
Return $aRet[0]
EndFunc
Func __RGB($iColor)
If $__g_iRGBMode Then
$iColor = _WinAPI_SwitchColor($iColor)
EndIf
Return $iColor
EndFunc
Func __WINVER()
Local $tOSVI = DllStructCreate($tagOSVERSIONINFO)
DllStructSetData($tOSVI, 1, DllStructGetSize($tOSVI))
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVI)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return BitOR(BitShift(DllStructGetData($tOSVI, 2), -8), DllStructGetData($tOSVI, 3))
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $__tagWinAPICom_GUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CLSIDFromProgID($sProgID)
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aReturn = DllCall('ole32.dll', 'long', 'CLSIDFromProgID', 'wstr', $sProgID, 'struct*', $tGUID)
If @error Then Return SetError(@error, @extended, '')
If $aReturn[0] Then Return SetError(10, $aReturn[0], '')
$aReturn = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'struct*', $tGUID, 'wstr', '', 'int', 39)
If @error Or Not $aReturn[0] Then Return SetError(@error + 20, @extended, '')
Return $aReturn[2]
EndFunc
Func _WinAPI_CoInitialize($iFlags = 0)
Local $aReturn = DllCall('ole32.dll', 'long', 'CoInitializeEx', 'ptr', 0, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return 1
EndFunc
Func _WinAPI_CoTaskMemAlloc($iSize)
Local $aReturn = DllCall('ole32.dll', 'ptr', 'CoTaskMemAlloc', 'uint_ptr', $iSize)
If @error Then Return SetError(@error, @extended, 0)
Return $aReturn[0]
EndFunc
Func _WinAPI_CoTaskMemFree($pMemory)
DllCall('ole32.dll', 'none', 'CoTaskMemFree', 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_CoTaskMemRealloc($pMemory, $iSize)
Local $aReturn = DllCall('ole32.dll', 'ptr', 'CoTaskMemRealloc', 'ptr', $pMemory, 'ulong_ptr', $iSize)
If @error Then Return SetError(@error, @extended, 0)
Return $aReturn[0]
EndFunc
Func _WinAPI_CoUninitialize()
DllCall('ole32.dll', 'none', 'CoUninitialize')
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_CreateGUID()
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aReturn = DllCall('ole32.dll', 'long', 'CoCreateGuid', 'struct*', $tGUID)
If @error Then Return SetError(@error, @extended, '')
If $aReturn[0] Then Return SetError(10, $aReturn[0], '')
$aReturn = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'struct*', $tGUID, 'wstr', '', 'int', 65536)
If @error Or Not $aReturn[0] Then Return SetError(@error + 20, @extended, '')
Return $aReturn[2]
EndFunc
Func _WinAPI_CreateStreamOnHGlobal($hGlobal = 0, $bDeleteOnRelease = True)
Local $aReturn = DllCall('ole32.dll', 'long', 'CreateStreamOnHGlobal', 'handle', $hGlobal, 'bool', $bDeleteOnRelease, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return $aReturn[3]
EndFunc
Func _WinAPI_GetHGlobalFromStream($pStream)
Local $aReturn = DllCall('ole32.dll', 'uint', 'GetHGlobalFromStream', 'ptr', $pStream, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return $aReturn[2]
EndFunc
Func _WinAPI_ProgIDFromCLSID($sCLSID)
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aReturn = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $sCLSID, 'struct*', $tGUID)
If @error Or $aReturn[0] Then Return SetError(@error + 20, @extended, '')
$aReturn = DllCall('ole32.dll', 'uint', 'ProgIDFromCLSID', 'struct*', $tGUID, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aReturn[0] Then Return SetError(10, $aReturn[0], '')
Local $sID = _WinAPI_GetString($aReturn[2])
_WinAPI_CoTaskMemFree($aReturn[2])
Return $sID
EndFunc
Func _WinAPI_ReleaseStream($pStream)
Local $aReturn = DllCall('oleaut32.dll', 'long', 'DispCallFunc', 'ptr', $pStream, 'ulong_ptr', 8 * (1 + @AutoItX64), 'uint', 4,  'ushort', 23, 'uint', 0, 'ptr', 0, 'ptr', 0, 'str', '')
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return 1
EndFunc
#EndRegion Public Functions
Global Const $URL_SCHEME_INVALID = -1
Global Const $URL_SCHEME_UNKNOWN = 0
Global Const $URL_SCHEME_FTP = 1
Global Const $URL_SCHEME_HTTP = 2
Global Const $URL_SCHEME_GOPHER = 3
Global Const $URL_SCHEME_MAILTO = 4
Global Const $URL_SCHEME_NEWS = 5
Global Const $URL_SCHEME_NNTP = 6
Global Const $URL_SCHEME_TELNET = 7
Global Const $URL_SCHEME_WAIS = 8
Global Const $URL_SCHEME_FILE = 9
Global Const $URL_SCHEME_MK = 10
Global Const $URL_SCHEME_HTTPS = 11
Global Const $URL_SCHEME_SHELL = 12
Global Const $URL_SCHEME_SNEWS = 13
Global Const $URL_SCHEME_LOCAL = 14
Global Const $URL_SCHEME_JAVASCRIPT = 15
Global Const $URL_SCHEME_VBSCRIPT = 16
Global Const $URL_SCHEME_ABOUT = 17
Global Const $URL_SCHEME_RES = 18
Global Const $URL_SCHEME_MSSHELLROOTED = 19
Global Const $URL_SCHEME_MSSHELLIDLIST = 20
Global Const $URL_SCHEME_MSHELP = 21
Global Const $URL_SCHEME_MSSHELLDEVICE = 22
Global Const $URL_SCHEME_WILDCARD = 23
Global Const $URL_SCHEME_SEARCH_MS = 24
Global Const $URL_SCHEME_SEARCH = 25
Global Const $URL_SCHEME_KNOWNFOLDER = 26
Global Const $GCT_INVALID = 0x00
Global Const $GCT_LFNCHAR = 0x01
Global Const $GCT_SEPARATOR = 0x08
Global Const $GCT_SHORTCHAR = 0x02
Global Const $GCT_WILD = 0x04
Global Const $URL_APPLY_DEFAULT = 0x01
Global Const $URL_APPLY_GUESSSCHEME = 0x02
Global Const $URL_APPLY_GUESSFILE = 0x04
Global Const $URL_APPLY_FORCEAPPLY = 0x08
Global Const $URL_DONT_SIMPLIFY = 0x08000000
Global Const $URL_ESCAPE_AS_UTF8 = 0x00040000
Global Const $URL_ESCAPE_PERCENT = 0x00001000
Global Const $URL_ESCAPE_SPACES_ONLY = 0x04000000
Global Const $URL_ESCAPE_UNSAFE = 0x20000000
Global Const $URL_NO_META = 0x08000000
Global Const $URL_PLUGGABLE_PROTOCOL = 0x40000000
Global Const $URL_UNESCAPE = 0x10000000
Global Const $URL_PART_HOSTNAME = 2
Global Const $URL_PART_PASSWORD = 4
Global Const $URL_PART_PORT = 5
Global Const $URL_PART_QUERY = 6
Global Const $URL_PART_SCHEME = 1
Global Const $URL_PART_USERNAME = 3
Global Const $URLIS_APPLIABLE = 4
Global Const $URLIS_DIRECTORY = 5
Global Const $URLIS_FILEURL = 3
Global Const $URLIS_HASQUERY = 6
Global Const $URLIS_NOHISTORY = 2
Global Const $URLIS_OPAQUE = 1
Global Const $URLIS_URL = 0
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CommandLineToArgv($sCmd)
Local $aResult[1] = [0]
$sCmd = StringStripWS($sCmd, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If Not $sCmd Then
Return $aResult
EndIf
Local $aRet = DllCall('shell32.dll', 'ptr', 'CommandLineToArgvW', 'wstr', $sCmd, 'int*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[2]) Then Return SetError(@error + 10, @extended, 0)
Local $tPtr = DllStructCreate('ptr[' & $aRet[2] & ']', $aRet[0])
Dim $aResult[$aRet[2] + 1] = [$aRet[2]]
For $i = 1 To $aRet[2]
$aResult[$i] = _WinAPI_GetString(DllStructGetData($tPtr, 1, $i))
Next
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $aRet[0])
Return $aResult
EndFunc
Func _WinAPI_IsNameInExpression($sString, $sPattern, $bCaseSensitive = False)
If Not $bCaseSensitive Then $sPattern = StringUpper($sPattern)
Local $tUS1 = __US($sPattern)
Local $tUS2 = __US($sString)
Local $aRet = DllCall('ntdll.dll', 'boolean', 'RtlIsNameInExpression', 'struct*', $tUS1, 'struct*', $tUS2,  'boolean', Not $bCaseSensitive, 'ptr', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ParseURL($sUrl)
Local $tagPARSEDURL = 'dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme'
Local $tPURL = DllStructCreate($tagPARSEDURL)
DllStructSetData($tPURL, 1, DllStructGetSize($tPURL))
Local $tURL = DllStructCreate('wchar[4096]')
DllStructSetData($tURL, 1, $sUrl)
Local $aRet = DllCall('shlwapi.dll', 'long', 'ParseURLW', 'struct*', $tURL, 'struct*', $tPURL)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $aResult[3]
$aResult[0] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 3) & ']', DllStructGetData($tPURL, 2)), 1)
$aResult[1] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 5) & ']', DllStructGetData($tPURL, 4)), 1)
$aResult[2] = DllStructGetData($tPURL, 6)
Return $aResult
EndFunc
Func _WinAPI_ParseUserName($sUser)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $aRet = DllCall('credui.dll', 'dword', 'CredUIParseUserNameW', 'wstr', $sUser, 'wstr', '', 'ulong', 4096, 'wstr', '',  'ulong', 4096)
If @error Then Return SetError(@error, @extended, 0)
Switch $aRet[0]
Case 0
Case 1315
If StringStripWS($sUser, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$aRet[2] = $sUser
$aRet[4] = ''
Else
ContinueCase
EndIf
Case Else
Return SetError(10, $aRet[0], 0)
EndSwitch
Local $aResult[2]
$aResult[0] = $aRet[4]
$aResult[1] = $aRet[2]
Return $aResult
EndFunc
Func _WinAPI_PathAddBackslash($sFilePath)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathAddBackslashW', 'struct*', $tPath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathAddExtension($sFilePath, $sExt = '')
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $sTypeOfExt = 'wstr'
If Not StringStripWS($sExt, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfExt = 'ptr'
$sExt = 0
EndIf
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathAddExtensionW', 'struct*', $tPath, $sTypeOfExt, $sExt)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], DllStructGetData($tPath, 1))
EndFunc
Func _WinAPI_PathAppend($sFilePath, $sMore)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathAppendW', 'struct*', $tPath, 'wstr', $sMore)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathBuildRoot($iDrive)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathBuildRootW', 'wstr', '', 'int', $iDrive)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathCanonicalize($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathCanonicalizeW', 'wstr', '', 'wstr', $sFilePath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, $sFilePath)
Return $aRet[1]
EndFunc
Func _WinAPI_PathCommonPrefix($sPath1, $sPath2)
Local $aRet = DllCall('shlwapi.dll', 'int', 'PathCommonPrefixW', 'wstr', $sPath1, 'wstr', $sPath2, 'wstr', '')
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], $aRet[3])
EndFunc
Func _WinAPI_PathCompactPath($hWnd, $sFilePath, $iWidth = 0)
If $iWidth < 1 Then
Local $tRECT = DllStructCreate($tagRECT)
DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
$iWidth += DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndIf
Local $aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', $hWnd)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, $sFilePath)
Local $hDC = $aRet[0]
Local Const $WM_GETFONT = 0x0031
$aRet = DllCall('user32.dll', 'ptr', 'SendMessage', 'hwnd', $hWnd, 'uint', $WM_GETFONT, 'wparam', 0, 'lparam', 0)
Local $hBack = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $aRet[0])
Local $iError = 0
$aRet = DllCall('shlwapi.dll', 'bool', 'PathCompactPathW', 'handle', $hDC, 'wstr', $sFilePath, 'int', $iWidth)
If @error Or Not $aRet[0] Then $iError = @error + 10
DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hBack[0])
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If $iError Then Return SetError($iError, 0, $sFilePath)
Return $aRet[2]
EndFunc
Func _WinAPI_PathCompactPathEx($sFilePath, $iMax)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathCompactPathExW', 'wstr', '', 'wstr', $sFilePath, 'uint', $iMax + 1, 'dword', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, $sFilePath)
Return $aRet[1]
EndFunc
Func _WinAPI_PathCreateFromUrl($sUrl)
Local $aRet = DllCall('shlwapi.dll', 'long', 'PathCreateFromUrlW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_PathFindExtension($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'wstr', 'PathFindExtensionW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[0]
EndFunc
Func _WinAPI_PathFindFileName($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'wstr', 'PathFindFileNameW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, $sFilePath)
Return $aRet[0]
EndFunc
Func _WinAPI_PathFindNextComponent($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathFindNextComponentW', 'struct*', $tPath)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return _WinAPI_GetString($aRet[0])
EndFunc
Func _WinAPI_PathGetArgs($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathGetArgsW', 'struct*', $tPath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return _WinAPI_GetString($aRet[0])
EndFunc
Func _WinAPI_PathGetCharType($sChar)
Local $aRet = DllCall('shlwapi.dll', 'uint', 'PathGetCharTypeW', 'word', AscW($sChar))
If @error Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_PathGetDriveNumber($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'int', 'PathGetDriveNumberW', 'wstr', $sFilePath)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, '')
Return Chr($aRet[0] + 65) & ':'
EndFunc
Func _WinAPI_PathIsContentType($sFilePath, $sType)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsContentTypeW', 'wstr', $sFilePath, 'wstr', $sType)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsExe($sFilePath)
Local $aRet = DllCall('shell32.dll', 'bool', 'PathIsExe', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsFileSpec($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsLFNFileSpec($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsLFNFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsRelative($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsRelativeW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsRoot($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsRootW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsSameRoot($sPath1, $sPath2)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsSameRootW', 'wstr', $sPath1, 'wstr', $sPath2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsSystemFolder($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsSystemFolderW', 'wstr', $sFilePath, 'dword', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsUNC($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsUNCW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsUNCServer($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsUNCServerW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsUNCServerShare($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsUNCServerShareW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathMakeSystemFolder($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathMakeSystemFolderW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathMatchSpec($sFilePath, $sSpec)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathMatchSpecW', 'wstr', $sFilePath, 'wstr', $sSpec)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathParseIconLocation($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'int', 'PathParseIconLocationW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult[2]
$aResult[0] = $aRet[1]
$aResult[1] = $aRet[0]
Return $aResult
EndFunc
Func _WinAPI_PathRelativePathTo($sPathFrom, $bDirFrom, $sPathTo, $bDirTo)
If $bDirFrom Then
$bDirFrom = 0x10
EndIf
If $bDirTo Then
$bDirTo = 0x10
EndIf
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathRelativePathToW', 'wstr', '', 'wstr', $sPathFrom, 'dword', $bDirFrom,  'wstr', $sPathTo, 'dword', $bDirTo)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveArgs($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathRemoveArgsW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveBackslash($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathRemoveBackslashW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveExtension($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathRemoveExtensionW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveFileSpec($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathRemoveFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], $aRet[1])
EndFunc
Func _WinAPI_PathRenameExtension($sFilePath, $sExt)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathRenameExtensionW', 'struct*', $tPath, 'wstr', $sExt)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathSearchAndQualify($sFilePath, $bExists = False)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathSearchAndQualifyW', 'wstr', $sFilePath, 'wstr', '', 'int', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
If $bExists And Not FileExists($aRet[2]) Then Return SetError(20, 0, '')
Return $aRet[2]
EndFunc
Func _WinAPI_PathSkipRoot($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathSkipRootW', 'struct*', $tPath)
If @error Then Return SetError(@error, @extended, '')
If Not $aRet[0] Then Return $sFilePath
Return _WinAPI_GetString($aRet[0])
EndFunc
Func _WinAPI_PathStripPath($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathStripPathW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathStripToRoot($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathStripToRootW', 'wstr', $sFilePath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathUndecorate($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathUndecorateW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathUnExpandEnvStrings($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathUnExpandEnvStringsW', 'wstr', $sFilePath, 'wstr', '', 'uint', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_PathUnmakeSystemFolder($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathUnmakeSystemFolderW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathUnquoteSpaces($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathUnquoteSpacesW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathYetAnotherMakeUniqueName($sFilePath)
Local $aRet = DllCall('shell32.dll', 'int', 'PathYetAnotherMakeUniqueName', 'wstr', '', 'wstr', $sFilePath, 'ptr', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_ShellGetImageList($bSmall = False)
Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')
If $bSmall Then
$pLarge = 0
$pSmall = DllStructGetPtr($tPtr)
Else
$pLarge = DllStructGetPtr($tPtr)
$pSmall = 0
EndIf
Local $aRet = DllCall('shell32.dll', 'int', 'Shell_GetImageLists', 'ptr', $pLarge, 'ptr', $pSmall)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPtr, 1)
EndFunc
Func _WinAPI_UrlApplyScheme($sUrl, $iFlags = 1)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlApplySchemeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlCanonicalize($sUrl, $iFlags)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlCanonicalizeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlCombine($sUrl, $sPart, $iFlags = 0)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlCombineW', 'wstr', $sUrl, 'wstr', $sPart, 'wstr', '', 'dword*', 4096,  'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[3]
EndFunc
Func _WinAPI_UrlCompare($sUrl1, $sUrl2, $bIgnoreSlash = False)
Local $aRet = DllCall('shlwapi.dll', 'int', 'UrlCompareW', 'wstr', $sUrl1, 'wstr', $sUrl2, 'bool', $bIgnoreSlash)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UrlCreateFromPath($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlCreateFromPathW', 'wstr', $sFilePath, 'wstr', '', 'dword*', 4096, 'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] < 0 Or $aRet[0] > 1 Then
Return SetError(10, $aRet[0], '')
EndIf
Return $aRet[2]
EndFunc
Func _WinAPI_UrlFixup($sUrl)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlFixupW', 'wstr', $sUrl, 'wstr', '', 'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlGetPart($sUrl, $iPart)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlGetPartW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iPart,  'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlHash($sUrl, $iLength = 32)
If $iLength <= 0 Or $iLength > 256 Then Return SetError(256, 0, 0)
Local $tData = DllStructCreate('byte[' & $iLength & ']')
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlHashW', 'wstr', $sUrl, 'struct*', $tData, 'dword', $iLength)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_UrlIs($sUrl, $iType = 0)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'UrlIsW', 'wstr', $sUrl, 'uint', $iType)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __US($sString, $iLength = 0)
If $iLength Then
$sString = StringLeft($sString, $iLength)
Else
$iLength = StringLen($sString)
EndIf
Local $tUS = DllStructCreate('ushort;ushort;ptr;wchar[' & ($iLength + 1) & ']')
DllStructSetData($tUS, 1, 2 * StringLen($sString))
DllStructSetData($tUS, 2, 2 * $iLength)
DllStructSetData($tUS, 3, DllStructGetPtr($tUS, 4))
DllStructSetData($tUS, 4, $sString)
Return $tUS
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $tagIO_COUNTERS = 'struct;uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;endstruct'
Global Const $tagJOBOBJECT_ASSOCIATE_COMPLETION_PORT = 'ulong_ptr CompletionKey;ptr CompletionPort'
Global Const $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = 'struct;int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;endstruct'
Global Const $tagJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & ';' & $tagIO_COUNTERS
Global Const $tagJOBOBJECT_BASIC_LIMIT_INFORMATION = 'struct;int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;endstruct'
Global Const $tagJOBOBJECT_BASIC_PROCESS_ID_LIST = 'dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList'
Global Const $tagJOBOBJECT_BASIC_UI_RESTRICTIONS = 'dword UIRestrictionsClass'
Global Const $tagJOBOBJECT_END_OF_JOB_TIME_INFORMATION = 'dword EndOfJobTimeAction'
Global Const $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $tagJOBOBJECT_BASIC_LIMIT_INFORMATION & ';' & $tagIO_COUNTERS & ';ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed'
Global Const $tagJOBOBJECT_GROUP_INFORMATION = ''
Global Const $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION = 'dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids'
Global Const $tagMODULEINFO = 'ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint'
Global Const $tagPROCESSENTRY32 = 'dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_AdjustTokenPrivileges($hToken, $aPrivileges, $iAttributes, ByRef $aAdjust)
$aAdjust = 0
If Not $aPrivileges And IsNumber($aPrivileges) Then Return 0
Local $tTP1 = 0, $tTP2, $iCount, $aRet, $bDisable = False
If $aPrivileges = -1 Then
$tTP2 = DllStructCreate('dword')
$aRet = DllCall('advapi32.dll', 'bool', 'AdjustTokenPrivileges', 'handle', $hToken, 'bool', 1, 'ptr', 0,  'dword', 0, 'struct*', $tTP2, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
Local $iLastError = _WinAPI_GetLastError()
Switch $iLastError
Case 122
$tTP2 = DllStructCreate('dword;dword[' & ($aRet[6] / 4 - 1) & ']')
If @error Then
ContinueCase
EndIf
Case Else
Return SetError(10, $iLastError, 0)
EndSwitch
$bDisable = True
Else
Local $aPrev = 0
If Not IsArray($aPrivileges) Then
Dim $aPrev[1][2]
$aPrev[0][0] = $aPrivileges
$aPrev[0][1] = $iAttributes
Else
If Not UBound($aPrivileges, $UBOUND_COLUMNS) Then
$iCount = UBound($aPrivileges)
Dim $aPrev[$iCount][2]
For $i = 0 To $iCount - 1
$aPrev[$i][0] = $aPrivileges[$i]
$aPrev[$i][1] = $iAttributes
Next
EndIf
EndIf
If IsArray($aPrev) Then
$aPrivileges = $aPrev
EndIf
Local $tagStruct = 'dword;dword[' & (3 * UBound($aPrivileges)) & ']'
$tTP1 = DllStructCreate($tagStruct)
$tTP2 = DllStructCreate($tagStruct)
If @error Then Return SetError(@error + 20, 0, 0)
DllStructSetData($tTP1, 1, UBound($aPrivileges))
For $i = 0 To UBound($aPrivileges) - 1
DllStructSetData($tTP1, 2, $aPrivileges[$i][1], 3 * $i + 3)
$aRet = DllCall('advapi32.dll', 'bool', 'LookupPrivilegeValueW', 'ptr', 0, 'wstr', $aPrivileges[$i][0],  'ptr', DllStructGetPtr($tTP1, 2) + 12 * $i)
If @error Or Not $aRet[0] Then Return SetError(@error + 100, @extended, 0)
Next
EndIf
$aRet = DllCall('advapi32.dll', 'bool', 'AdjustTokenPrivileges', 'handle', $hToken, 'bool', $bDisable,  'struct*', $tTP1, 'dword', DllStructGetSize($tTP2), 'struct*', $tTP2, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 200, @extended, 0)
Local $iResult
Switch _WinAPI_GetLastError()
Case 1300
$iResult = 1
Case Else
$iResult = 0
EndSwitch
$iCount = DllStructGetData($tTP2, 1)
If $iCount Then
Local $tData = DllStructCreate('wchar[128]')
Dim $aPrivileges[$iCount][2]
For $i = 0 To $iCount - 1
$aRet = DllCall('advapi32.dll', 'bool', 'LookupPrivilegeNameW', 'ptr', 0,  'ptr', DllStructGetPtr($tTP2, 2) + 12 * $i, 'struct*', $tData, 'dword*', 128)
If @error Or Not $aRet[0] Then Return SetError(@error + 300, @extended, 0)
$aPrivileges[$i][1] = DllStructGetData($tTP2, 2, 3 * $i + 3)
$aPrivileges[$i][0] = DllStructGetData($tData, 1)
Next
$aAdjust = $aPrivileges
EndIf
Return SetExtended($iResult, 1)
EndFunc
Func _WinAPI_AssignProcessToJobObject($hJob, $hProcess)
Local $aRet = DllCall('kernel32.dll', 'bool', 'AssignProcessToJobObject', 'handle', $hJob, 'handle', $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateJobObject($sName = '', $tSecurity = 0)
Local $sTypeOfName = 'wstr'
If Not StringStripWS($sName, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfName = 'ptr'
$sName = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateJobObjectW', 'struct*', $tSecurity, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateMutex($sMutex, $bInitial = True, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateMutexW', 'struct*', $tSecurity, 'bool', $bInitial, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateProcessWithToken($sApp, $sCmd, $iFlags, $tStartupInfo, $tProcessInfo, $hToken, $iLogon = 0, $pEnvironment = 0, $sDir = '')
Local $sTypeOfApp = 'wstr', $sTypeOfCmd = 'wstr', $sTypeOfDir = 'wstr'
If Not StringStripWS($sApp, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfApp = 'ptr'
$sApp = 0
EndIf
If Not StringStripWS($sCmd, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfCmd = 'ptr'
$sCmd = 0
EndIf
If Not StringStripWS($sDir, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfDir = 'ptr'
$sDir = 0
EndIf
Local $aRet = DllCall('advapi32.dll', 'bool', 'CreateProcessWithTokenW', 'handle', $hToken, 'dword', $iLogon,  $sTypeOfApp, $sApp, $sTypeOfCmd, $sCmd, 'dword', $iFlags, 'struct*', $pEnvironment,  $sTypeOfDir, $sDir, 'struct*', $tStartupInfo, 'struct*', $tProcessInfo)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateSemaphoreW', 'struct*', $tSecurity, 'long', $iInitial,  'long', $iMaximum, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DuplicateTokenEx($hToken, $iAccess, $iLevel, $iType = 1, $tSecurity = 0)
Local $aRet = DllCall('advapi32.dll', 'bool', 'DuplicateTokenEx', 'handle', $hToken, 'dword', $iAccess,  'struct*', $tSecurity, 'int', $iLevel, 'int', $iType, 'handle*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[6]
EndFunc
Func _WinAPI_EmptyWorkingSet($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000500, 0x00001100),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EmptyWorkingSet', 'handle', $hProcess[0])
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_EnumChildProcess($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or ($hSnapshot[0] = Ptr(-1)) Then Return SetError(@error + 10, @extended, 0)
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
Local $aResult[101][2] = [[0]]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aRet[0])
If DllStructGetData($tPROCESSENTRY32, 'ParentProcessID') = $iPID Then
__Inc($aResult)
$aResult[$aResult[0][0]][0] = DllStructGetData($tPROCESSENTRY32, 'ProcessID')
$aResult[$aResult[0][0]][1] = DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aResult[0][0] Then Return SetError($iError + 20, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumDeviceDrivers()
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumDeviceDrivers', 'ptr', 0, 'dword', 0, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $iSize
If @AutoItX64 Then
$iSize = $aRet[3] / 8
Else
$iSize = $aRet[3] / 4
EndIf
Local $tData = DllStructCreate('ptr[' & $iSize & ']')
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumDeviceDrivers', 'struct*', $tData,  'dword', DllStructGetSize($tData), 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
Local $aResult[$iSize + 1] = [$iSize]
For $i = 1 To $iSize
$aResult[$i] = DllStructGetData($tData, 1, $i)
Next
Return $aResult
EndFunc
Func _WinAPI_EnumProcessHandles($iPID = 0, $iType = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $aResult[101][4] = [[0]]
Local $tSHI = DllStructCreate('ulong;byte[4194304]')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQuerySystemInformation', 'uint', 16, 'struct*', $tSHI,  'ulong', DllStructGetSize($tSHI), 'ulong*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $pData = DllStructGetPtr($tSHI, 2)
Local $tHandle
For $i = 1 To DllStructGetData($tSHI, 1)
$tHandle = DllStructCreate('align 4;ulong;byte;byte;ushort;ptr;ulong', $pData + __Iif(@AutoItX64, 4 + ($i - 1) * 24, ($i - 1) * 16))
If (DllStructGetData($tHandle, 1) = $iPID) And ((Not $iType) Or ($iType = DllStructGetData($tHandle, 2))) Then
__Inc($aResult)
$aResult[$aResult[0][0]][0] = Ptr(DllStructGetData($tHandle, 4))
$aResult[$aResult[0][0]][1] = DllStructGetData($tHandle, 2)
$aResult[$aResult[0][0]][2] = DllStructGetData($tHandle, 3)
$aResult[$aResult[0][0]][3] = DllStructGetData($tHandle, 6)
EndIf
Next
If Not $aResult[0][0] Then Return SetError(11, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessModules($iPID = 0, $iFlag = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $iCount, $aRet, $iError = 0
Do
If $__WINVER >= 0x0600 Then
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModulesEx', 'handle', $hProcess[0], 'ptr', 0,  'dword', 0, 'dword*', 0, 'dword', $iFlag)
Else
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModules', 'handle', $hProcess[0], 'ptr', 0,  'dword', 0, 'dword*', 0)
EndIf
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
If @AutoItX64 Then
$iCount = $aRet[4] / 8
Else
$iCount = $aRet[4] / 4
EndIf
Local $tPtr = DllStructCreate('ptr[' & $iCount & ']')
If @error Then
$iError = @error + 30
ExitLoop
EndIf
If $__WINVER >= 0x0600 Then
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModulesEx', 'handle', $hProcess[0], 'struct*', $tPtr,  'dword', DllStructGetSize($tPtr), 'dword*', 0, 'dword', $iFlag)
Else
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModules', 'handle', $hProcess[0], 'struct*', $tPtr,  'dword', DllStructGetSize($tPtr), 'dword*', 0)
EndIf
If @error Or Not $aRet[0] Then
$iError = @error + 40
ExitLoop
EndIf
Local $aResult[$iCount + 1][2] = [[$iCount]]
For $i = 1 To $iCount
$aResult[$i][0] = DllStructGetData($tPtr, 1, $i)
$aResult[$i][1] = _WinAPI_GetModuleFileNameEx($hProcess[0], $aResult[$i][0])
Next
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessThreads($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000004, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local Const $tagTHREADENTRY32 = 'dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags'
Local $tTHREADENTRY32 = DllStructCreate($tagTHREADENTRY32)
Local $aResult[101] = [0]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tTHREADENTRY32, 'Size', DllStructGetSize($tTHREADENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Thread32First', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
While Not @error And $aRet[0]
If DllStructGetData($tTHREADENTRY32, 'OwnerProcessID') = $iPID Then
__Inc($aResult)
$aResult[$aResult[0]] = DllStructGetData($tTHREADENTRY32, 'ThreadID')
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Thread32Next', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aResult[0] Then Return SetError(1, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessWindows($iPID = 0, $bVisible = True)
Local $aThreads = _WinAPI_EnumProcessThreads($iPID)
If @error Then Return SetError(@error, @extended, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
For $i = 1 To $aThreads[0]
DllCall('user32.dll', 'bool', 'EnumThreadWindows', 'dword', $aThreads[$i], 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', $bVisible)
If @error Then
ExitLoop
EndIf
Next
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then Return SetError(11, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_GetCurrentProcessExplicitAppUserModelID()
Local $aRet = DllCall('shell32.dll', 'long', 'GetCurrentProcessExplicitAppUserModelID', 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $sID = _WinAPI_GetString($aRet[1])
_WinAPI_CoTaskMemFree($aRet[1])
Return $sID
EndFunc
Func _WinAPI_GetDeviceDriverBaseName($pDriver)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetDeviceDriverBaseNameW', 'ptr', $pDriver, 'wstr', '',  'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetDeviceDriverFileName($pDriver)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetDeviceDriverFileNameW', 'ptr', $pDriver, 'wstr', '',  'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetExitCodeProcess($hProcess)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetExitCodeProcess', 'handle', $hProcess, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetModuleFileNameEx($hProcess, $hModule = 0)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetModuleFileNameExW', 'handle', $hProcess, 'handle', $hModule,  'wstr', '', 'int', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetModuleInformation($hProcess, $hModule = 0)
Local $tMODULEINFO = DllStructCreate($tagMODULEINFO)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetModuleInformation', 'handle', $hProcess, 'handle', $hModule,  'struct*', $tMODULEINFO, 'dword', DllStructGetSize($tMODULEINFO))
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tMODULEINFO
EndFunc
Func _WinAPI_GetParentProcess($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
Local $iResult = 0
$hSnapshot = $hSnapshot[0]
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aRet[0])
If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $iPID Then
$iResult = DllStructGetData($tPROCESSENTRY32, 'ParentProcessID')
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $iResult Then Return SetError($iError, 0, 0)
Return $iResult
EndFunc
Func _WinAPI_GetPriorityClass($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetPriorityClass', 'handle', $hProcess[0])
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetProcessCommandLine($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
$hProcess = $hProcess[0]
Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
Local $tCMD
Local $aRet, $iError = 0
Do
$aRet = DllCall('ntdll.dll', 'long', 'NtQueryInformationProcess', 'handle', $hProcess, 'ulong', 0, 'struct*', $tPBI,  'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
If @error Or $aRet[0] Then
$iError = @error + 30
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'struct*', $tPEB,  'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[5]) Then
$iError = @error + 40
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'struct*', $tUPP,  'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[5]) Then
$iError = @error + 50
ExitLoop
EndIf
$tCMD = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCommandLine') & ']')
If @error Then
$iError = @error + 60
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tUPP, 'CommandLine'), 'struct*', $tCMD,  'ulong_ptr', DllStructGetSize($tCMD), 'ulong_ptr*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[5]) Then
$iError = @error + 70
ExitLoop
EndIf
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If $iError Then Return SetError($iError, 0, '')
Return StringStripWS(_WinAPI_PathGetArgs(_WinAPI_GetString(DllStructGetPtr($tCMD, 1))), $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndFunc
Func _WinAPI_GetProcessFileName($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
Local $sPath = _WinAPI_GetModuleFileNameEx($hProcess[0])
Local $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError(@error, 0, '')
Return $sPath
EndFunc
Func _WinAPI_GetProcessHandleCount($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessHandleCount', 'handle', $hProcess[0], 'dword*', 0)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetProcessID($hProcess)
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetProcessId', 'handle', $hProcess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetProcessIoCounters($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tIO_COUNTERS = DllStructCreate('uint64[6]')
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessIoCounters', 'handle', $hProcess[0], 'struct*', $tIO_COUNTERS)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aResult[6]
For $i = 0 To 5
$aResult[$i] = DllStructGetData($tIO_COUNTERS, 1, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetProcessMemoryInfo($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tPMC_EX = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr')
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetProcessMemoryInfo', 'handle', $hProcess[0], 'struct*', $tPMC_EX,  'int', DllStructGetSize($tPMC_EX))
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aResult[10]
For $i = 0 To 9
$aResult[$i] = DllStructGetData($tPMC_EX, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_GetProcessName($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 20, @extended, '')
$hSnapshot = $hSnapshot[0]
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aRet[0])
If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $iPID Then
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If $iError Then Return SetError($iError, 0, '')
If Not $aRet[0] Then SetError(10, 0, '')
Return DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndFunc
Func _WinAPI_GetProcessTimes($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tFILETIME = DllStructCreate($tagFILETIME)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessTimes', 'handle', $hProcess[0], 'struct*', $tFILETIME, 'uint64*', 0,  'uint64*', 0, 'uint64*', 0)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aResult[3]
$aResult[0] = $tFILETIME
$aResult[1] = $aRet[4]
$aResult[2] = $aRet[5]
Return $aResult
EndFunc
Func _WinAPI_GetProcessUser($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $tSID, $hToken, $aRet
Local $iError = 0
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Do
$hToken = _WinAPI_OpenProcessToken(0x00000008, $hProcess[0])
If Not $hToken Then
$iError = @error + 10
ExitLoop
EndIf
$tSID = DllStructCreate('ptr;byte[1024]')
$aRet = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 1, 'struct*', $tSID,  'dword', DllStructGetSize($tSID), 'dword*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
ExitLoop
EndIf
$aRet = DllCall('advapi32.dll', 'bool', 'LookupAccountSidW', 'ptr', 0, 'ptr', DllStructGetData($tSID, 1), 'wstr', '',  'dword*', 2048, 'wstr', '', 'dword*', 2048, 'uint*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 40
ExitLoop
EndIf
Until 1
If $hToken Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Local $aResult[2]
$aResult[0] = $aRet[3]
$aResult[1] = $aRet[5]
Return $aResult
EndFunc
Func _WinAPI_GetProcessWorkingDirectory($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $aRet, $iError = 0
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
$hProcess = $hProcess[0]
Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
Local $tDIR
Do
$aRet = DllCall('ntdll.dll', 'long', 'NtQueryInformationProcess', 'handle', $hProcess, 'ulong', 0, 'struct*', $tPBI,  'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
If @error Or ($aRet[0]) Then
$iError = @error + 10
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'struct*', $tPEB,  'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
If @error Or (Not $aRet[0]) Or (Not $aRet[5]) Then
$iError = @error + 30
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'struct*', $tUPP,  'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
If @error Or (Not $aRet[0]) Or (Not $aRet[5]) Then
$iError = @error + 40
ExitLoop
EndIf
$tDIR = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCurrentDirectory') & ']')
If @error Then
$iError = @error + 50
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tUPP, 'CurrentDirectory'), 'struct*', $tDIR,  'ulong_ptr', DllStructGetSize($tDIR), 'ulong_ptr*', 0)
If @error Or (Not $aRet[0]) Or (Not $aRet[5]) Then
$iError = @error + 60
ExitLoop
EndIf
$iError = 0
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If $iError Then Return SetError($iError, 0, '')
Return _WinAPI_PathRemoveBackslash(_WinAPI_GetString(DllStructGetPtr($tDIR)))
EndFunc
Func _WinAPI_GetThreadDesktop($iThreadId)
Local $aRet = DllCall('user32.dll', 'handle', 'GetThreadDesktop', 'dword', $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetThreadErrorMode()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetThreadErrorMode')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWindowFileName($hWnd)
Local $iPID = 0
Local $aResult = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hWnd)
If $aResult[0] Then
$aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
$iPID = $aResult[2]
EndIf
If Not $iPID Then Return SetError(1, 0, '')
Local $sResult = _WinAPI_GetProcessFileName($iPID)
If @error Then Return SetError(@error, @extended, '')
Return $sResult
EndFunc
Func _WinAPI_IsElevated()
Local $iElev, $aRet, $iError = 0
Local $hToken = _WinAPI_OpenProcessToken(0x0008)
If Not $hToken Then Return SetError(@error + 10, @extended, False)
Do
$aRet = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 20, 'uint*', 0, 'dword', 4,  'dword*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
$iElev = $aRet[3]
$aRet = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 18, 'uint*', 0, 'dword', 4,  'dword*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 20
ExitLoop
EndIf
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
If $iError Then Return SetError($iError, 0, False)
Return SetExtended($aRet[0] - 1, $iElev)
EndFunc
Func _WinAPI_IsProcessInJob($hProcess, $hJob = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsProcessInJob', 'handle', $hProcess, 'handle', $hJob, 'bool*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
Return $aRet[3]
EndFunc
Func _WinAPI_OpenJobObject($sName, $iAccess = $JOB_OBJECT_ALL_ACCESS, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenJobObjectW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenMutex($sMutex, $iAccess = $MUTEX_ALL_ACCESS, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenMutexW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenProcessToken($iAccess, $hProcess = 0)
If Not $hProcess Then
$hProcess = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
$hProcess = $hProcess[0]
EndIf
Local $aRet = DllCall('advapi32.dll', 'bool', 'OpenProcessToken', 'handle', $hProcess, 'dword', $iAccess, 'handle*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_OpenSemaphore($sSemaphore, $iAccess = 0x001F0003, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenSemaphoreW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_QueryInformationJobObject($hJob, $iJobObjectInfoClass, ByRef $tJobObjectInfo)
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryInformationJobObject', 'handle', $hJob, 'int', $iJobObjectInfoClass,  'struct*', $tJobObjectInfo, 'dword', DllStructGetSize($tJobObjectInfo), 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[5]
EndFunc
Func _WinAPI_ReleaseMutex($hMutex)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseMutex', 'handle', $hMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ReleaseSemaphore($hSemaphore, $iIncrease = 1)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseSemaphore', 'handle', $hSemaphore, 'long', $iIncrease, 'long*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_ResetEvent($hEvent)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ResetEvent', 'handle', $hEvent)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetInformationJobObject($hJob, $iJobObjectInfoClass, $tJobObjectInfo)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetInformationJobObject', 'handle', $hJob, 'int', $iJobObjectInfoClass,  'struct*', $tJobObjectInfo, 'dword', DllStructGetSize($tJobObjectInfo))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetPriorityClass($iPriority, $iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000600, 0x00001200),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 10, @extended, 0)
Local $iError = 0
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetPriorityClass', 'handle', $hProcess[0], 'dword', $iPriority)
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetThreadDesktop($hDesktop)
Local $aRet = DllCall('user32.dll', 'bool', 'SetThreadDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetThreadErrorMode($iMode)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetThreadErrorMode', 'dword', $iMode, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_SetThreadExecutionState($iFlags)
Local $aRet = DllCall('kernel32.dll', 'dword', 'SetThreadExecutionState', 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TerminateJobObject($hJob, $iExitCode = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'TerminateJobObject', 'handle', $hJob, 'uint', $iExitCode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TerminateProcess($hProcess, $iExitCode = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'TerminateProcess', 'handle', $hProcess, 'uint', $iExitCode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UserHandleGrantAccess($hObject, $hJob, $bGrant)
Local $aRet = DllCall('kernel32.dll', 'bool', 'UserHandleGrantAccess', 'handle', $hObject, 'handle', $hJob, 'bool', $bGrant)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
Global Const $LINGUISTIC_IGNORECASE = 0x00000010
Global Const $LINGUISTIC_IGNOREDIACRITIC = 0x00000020
Global Const $NORM_IGNORECASE = 0x00000001
Global Const $NORM_IGNOREKANATYPE = 0x00010000
Global Const $NORM_IGNORENONSPACE = 0x00000002
Global Const $NORM_IGNORESYMBOLS = 0x00000004
Global Const $NORM_IGNOREWIDTH = 0x00020000
Global Const $NORM_LINGUISTIC_CASING = 0x08000000
Global Const $SORT_DIGITSASNUMBERS = 0x00000008
Global Const $SORT_STRINGSORT = 0x00001000
Global Const $CSTR_LESS_THAN = 1
Global Const $CSTR_EQUAL = 2
Global Const $CSTR_GREATER_THAN = 3
Global Const $MUI_LANGUAGE_ID = 0x0004
Global Const $MUI_LANGUAGE_NAME = 0x0008
Global Const $DATE_AUTOLAYOUT = 0x40
Global Const $DATE_LONGDATE = 0x02
Global Const $DATE_LTRREADING = 0x10
Global Const $DATE_SHORTDATE = 0x01
Global Const $DATE_RTLREADING = 0x20
Global Const $DATE_USE_ALT_CALENDAR = 0x04
Global Const $DATE_YEARMONTH = 0x08
Global Const $GEO_NATION = 1
Global Const $GEO_LATITUDE = 2
Global Const $GEO_LONGITUDE = 3
Global Const $GEO_ISO2 = 4
Global Const $GEO_ISO3 = 5
Global Const $GEO_RFC1766 = 6
Global Const $GEO_LCID = 7
Global Const $GEO_FRIENDLYNAME = 8
Global Const $GEO_OFFICIALNAME = 9
Global Const $GEO_TIMEZONES = 10
Global Const $GEO_OFFICIALLANGUAGES = 11
Global Const $GEO_ISO_UN_NUMBER = 12
Global Const $GEO_PARENT = 13
Global Const $LOCALE_ILANGUAGE = 0x0001
Global Const $LOCALE_SLANGUAGE = 0x0002
Global Const $LOCALE_SENGLANGUAGE = 0x1001
Global Const $LOCALE_SABBREVLANGNAME = 0x0003
Global Const $LOCALE_SNATIVELANGNAME = 0x0004
Global Const $LOCALE_ICOUNTRY = 0x0005
Global Const $LOCALE_SCOUNTRY = 0x0006
Global Const $LOCALE_SENGCOUNTRY = 0x1002
Global Const $LOCALE_SABBREVCTRYNAME = 0x0007
Global Const $LOCALE_SNATIVECTRYNAME = 0x0008
Global Const $LOCALE_IDEFAULTLANGUAGE = 0x0009
Global Const $LOCALE_IDEFAULTCOUNTRY = 0x000A
Global Const $LOCALE_IDEFAULTCODEPAGE = 0x000B
Global Const $LOCALE_IDEFAULTANSICODEPAGE = 0x1004
Global Const $LOCALE_IDEFAULTMACCODEPAGE = 0x1011
Global Const $LOCALE_SLIST = 0x000C
Global Const $LOCALE_IMEASURE = 0x000D
Global Const $LOCALE_SDECIMAL = 0x000E
Global Const $LOCALE_STHOUSAND = 0x000F
Global Const $LOCALE_SGROUPING = 0x0010
Global Const $LOCALE_IDIGITS = 0x0011
Global Const $LOCALE_ILZERO = 0x0012
Global Const $LOCALE_INEGNUMBER = 0x1010
Global Const $LOCALE_SNATIVEDIGITS = 0x0013
Global Const $LOCALE_SCURRENCY = 0x0014
Global Const $LOCALE_SINTLSYMBOL = 0x0015
Global Const $LOCALE_SMONDECIMALSEP = 0x0016
Global Const $LOCALE_SMONTHOUSANDSEP = 0x0017
Global Const $LOCALE_SMONGROUPING = 0x0018
Global Const $LOCALE_ICURRDIGITS = 0x0019
Global Const $LOCALE_IINTLCURRDIGITS = 0x001A
Global Const $LOCALE_ICURRENCY = 0x001B
Global Const $LOCALE_INEGCURR = 0x001C
Global Const $LOCALE_SDATE = 0x001D
Global Const $LOCALE_STIME = 0x001E
Global Const $LOCALE_SSHORTDATE = 0x001F
Global Const $LOCALE_SLONGDATE = 0x0020
Global Const $LOCALE_STIMEFORMAT = 0x1003
Global Const $LOCALE_IDATE = 0x0021
Global Const $LOCALE_ILDATE = 0x0022
Global Const $LOCALE_ITIME = 0x0023
Global Const $LOCALE_ITIMEMARKPOSN = 0x1005
Global Const $LOCALE_ICENTURY = 0x0024
Global Const $LOCALE_ITLZERO = 0x0025
Global Const $LOCALE_IDAYLZERO = 0x0026
Global Const $LOCALE_IMONLZERO = 0x0027
Global Const $LOCALE_S1159 = 0x0028
Global Const $LOCALE_S2359 = 0x0029
Global Const $LOCALE_ICALENDARTYPE = 0x1009
Global Const $LOCALE_IOPTIONALCALENDAR = 0x100B
Global Const $LOCALE_IFIRSTDAYOFWEEK = 0x100C
Global Const $LOCALE_IFIRSTWEEKOFYEAR = 0x100D
Global Const $LOCALE_SDAYNAME1 = 0x002A
Global Const $LOCALE_SDAYNAME2 = 0x002B
Global Const $LOCALE_SDAYNAME3 = 0x002C
Global Const $LOCALE_SDAYNAME4 = 0x002D
Global Const $LOCALE_SDAYNAME5 = 0x002E
Global Const $LOCALE_SDAYNAME6 = 0x002F
Global Const $LOCALE_SDAYNAME7 = 0x0030
Global Const $LOCALE_SABBREVDAYNAME1 = 0x0031
Global Const $LOCALE_SABBREVDAYNAME2 = 0x0032
Global Const $LOCALE_SABBREVDAYNAME3 = 0x0033
Global Const $LOCALE_SABBREVDAYNAME4 = 0x0034
Global Const $LOCALE_SABBREVDAYNAME5 = 0x0035
Global Const $LOCALE_SABBREVDAYNAME6 = 0x0036
Global Const $LOCALE_SABBREVDAYNAME7 = 0x0037
Global Const $LOCALE_SMONTHNAME1 = 0x0038
Global Const $LOCALE_SMONTHNAME2 = 0x0039
Global Const $LOCALE_SMONTHNAME3 = 0x003A
Global Const $LOCALE_SMONTHNAME4 = 0x003B
Global Const $LOCALE_SMONTHNAME5 = 0x003C
Global Const $LOCALE_SMONTHNAME6 = 0x003D
Global Const $LOCALE_SMONTHNAME7 = 0x003E
Global Const $LOCALE_SMONTHNAME8 = 0x003F
Global Const $LOCALE_SMONTHNAME9 = 0x0040
Global Const $LOCALE_SMONTHNAME10 = 0x0041
Global Const $LOCALE_SMONTHNAME11 = 0x0042
Global Const $LOCALE_SMONTHNAME12 = 0x0043
Global Const $LOCALE_SMONTHNAME13 = 0x100E
Global Const $LOCALE_SABBREVMONTHNAME1 = 0x0044
Global Const $LOCALE_SABBREVMONTHNAME2 = 0x0045
Global Const $LOCALE_SABBREVMONTHNAME3 = 0x0046
Global Const $LOCALE_SABBREVMONTHNAME4 = 0x0047
Global Const $LOCALE_SABBREVMONTHNAME5 = 0x0048
Global Const $LOCALE_SABBREVMONTHNAME6 = 0x0049
Global Const $LOCALE_SABBREVMONTHNAME7 = 0x004A
Global Const $LOCALE_SABBREVMONTHNAME8 = 0x004B
Global Const $LOCALE_SABBREVMONTHNAME9 = 0x004C
Global Const $LOCALE_SABBREVMONTHNAME10 = 0x004D
Global Const $LOCALE_SABBREVMONTHNAME11 = 0x004E
Global Const $LOCALE_SABBREVMONTHNAME12 = 0x004F
Global Const $LOCALE_SABBREVMONTHNAME13 = 0x100F
Global Const $LOCALE_SPOSITIVESIGN = 0x0050
Global Const $LOCALE_SNEGATIVESIGN = 0x0051
Global Const $LOCALE_IPOSSIGNPOSN = 0x0052
Global Const $LOCALE_INEGSIGNPOSN = 0x0053
Global Const $LOCALE_IPOSSYMPRECEDES = 0x0054
Global Const $LOCALE_IPOSSEPBYSPACE = 0x0055
Global Const $LOCALE_INEGSYMPRECEDES = 0x0056
Global Const $LOCALE_INEGSEPBYSPACE = 0x0057
Global Const $LOCALE_FONTSIGNATURE = 0x0058
Global Const $LOCALE_SISO639LANGNAME = 0x0059
Global Const $LOCALE_SISO3166CTRYNAME = 0x005A
Global Const $LOCALE_IDEFAULTEBCDICCODEPAGE = 0x1012
Global Const $LOCALE_IPAPERSIZE = 0x100A
Global Const $LOCALE_SENGCURRNAME = 0x1007
Global Const $LOCALE_SNATIVECURRNAME = 0x1008
Global Const $LOCALE_SYEARMONTH = 0x1006
Global Const $LOCALE_SSORTNAME = 0x1013
Global Const $LOCALE_IDIGITSUBSTITUTION = 0x1014
Global Const $LOCALE_CUSTOM_DEFAULT = 0x0C00
Global Const $LOCALE_CUSTOM_UI_DEFAULT = 0x1400
Global Const $LOCALE_CUSTOM_UNSPECIFIED = 0x1000
Global Const $LOCALE_INVARIANT = 0x007F
Global Const $LOCALE_SYSTEM_DEFAULT = 0x0800
Global Const $LOCALE_USER_DEFAULT = 0x0400
Global Const $TIME_FORCE24HOURFORMAT = 0x08
Global Const $TIME_NOMINUTESORSECONDS = 0x01
Global Const $TIME_NOSECONDS = 0x02
Global Const $TIME_NOTIMEMARKER = 0x04
Global Const $LCID_INSTALLED = 1
Global Const $LCID_SUPPORTED = 2
Global Const $RT_ACCELERATOR = 9
Global Const $RT_ANICURSOR = 21
Global Const $RT_ANIICON = 22
Global Const $RT_BITMAP = 2
Global Const $RT_CURSOR = 1
Global Const $RT_DIALOG = 5
Global Const $RT_DLGINCLUDE = 17
Global Const $RT_FONT = 8
Global Const $RT_FONTDIR = 7
Global Const $RT_GROUP_CURSOR = 12
Global Const $RT_GROUP_ICON = 14
Global Const $RT_HTML = 23
Global Const $RT_ICON = 3
Global Const $RT_MANIFEST = 24
Global Const $RT_MENU = 4
Global Const $RT_MESSAGETABLE = 11
Global Const $RT_PLUGPLAY = 19
Global Const $RT_RCDATA = 10
Global Const $RT_STRING = 6
Global Const $RT_VERSION = 16
Global Const $RT_VXD = 20
Global Const $FILE_VER_GET_LOCALISED = 0x01
Global Const $FILE_VER_GET_NEUTRAL = 0x02
Global Const $FILE_VER_GET_PREFETCHED = 0x04
Global Const $OCR_NORMAL = 32512
Global Const $OCR_IBEAM = 32513
Global Const $OCR_WAIT = 32514
Global Const $OCR_CROSS = 32515
Global Const $OCR_UP = 32516
Global Const $OCR_SIZE = 32640
Global Const $OCR_ICON = 32641
Global Const $OCR_SIZENWSE = 32642
Global Const $OCR_SIZENESW = 32643
Global Const $OCR_SIZEWE = 32644
Global Const $OCR_SIZENS = 32645
Global Const $OCR_SIZEALL = 32646
Global Const $OCR_ICOCUR = 32647
Global Const $OCR_NO = 32648
Global Const $OCR_HAND = 32649
Global Const $OCR_APPSTARTING = 32650
Global Const $OCR_HELP = 32651
Global Const $VS_FF_DEBUG = 0x00000001
Global Const $VS_FF_INFOINFERRED = 0x00000010
Global Const $VS_FF_PATCHED = 0x00000004
Global Const $VS_FF_PRERELEASE = 0x00000002
Global Const $VS_FF_PRIVATEBUILD = 0x00000008
Global Const $VS_FF_SPECIALBUILD = 0x00000020
Global Const $VOS_DOS = 0x00010000
Global Const $VOS_NT = 0x00040000
Global Const $VOS__WINDOWS16 = 0x00000001
Global Const $VOS__WINDOWS32 = 0x00000004
Global Const $VOS_OS216 = 0x00020000
Global Const $VOS_OS232 = 0x00030000
Global Const $VOS__PM16 = 0x00000002
Global Const $VOS__PM32 = 0x00000003
Global Const $VOS_UNKNOWN = 0x00000000
Global Const $VOS_DOS_WINDOWS16 = 0x00010001
Global Const $VOS_DOS_WINDOWS32 = 0x00010004
Global Const $VOS_NT_WINDOWS32 = 0x00040004
Global Const $VOS_OS216_PM16 = 0x00020002
Global Const $VOS_OS232_PM32 = 0x00030003
Global Const $VFT_APP = 0x00000001
Global Const $VFT_DLL = 0x00000002
Global Const $VFT_DRV = 0x00000003
Global Const $VFT_FONT = 0x00000004
Global Const $VFT_STATIC_LIB = 0x00000007
Global Const $VFT_UNKNOWN = 0x00000000
Global Const $VFT_VXD = 0x00000005
Global Const $VFT2_DRV_COMM = 0x0000000A
Global Const $VFT2_DRV_DISPLAY = 0x00000004
Global Const $VFT2_DRV_INSTALLABLE = 0x00000008
Global Const $VFT2_DRV_KEYBOARD = 0x00000002
Global Const $VFT2_DRV_LANGUAGE = 0x00000003
Global Const $VFT2_DRV_MOUSE = 0x00000005
Global Const $VFT2_DRV_NETWORK = 0x00000006
Global Const $VFT2_DRV_PRINTER = 0x00000001
Global Const $VFT2_DRV_SOUND = 0x00000009
Global Const $VFT2_DRV_SYSTEM = 0x00000007
Global Const $VFT2_DRV_VERSIONED_PRINTER = 0x0000000C
Global Const $VFT2_UNKNOWN = 0x00000000
Global Const $VFT2_FONT_RASTER = 0x00000001
Global Const $VFT2_FONT_TRUETYPE = 0x00000003
Global Const $VFT2_FONT_VECTOR = 0x00000002
Global Const $FR_PRIVATE = 0x10
Global Const $FR_NOT_ENUM = 0x20
Global Const $COMPRESSION_BITMAP_PNG = 0
Global Const $COMPRESSION_BITMAP_JPEG = 1
Global Const $BS_DIBPATTERN = 5
Global Const $BS_DIBPATTERN8X8 = 8
Global Const $BS_DIBPATTERNPT = 6
Global Const $BS_HATCHED = 2
Global Const $BS_HOLLOW = 1
Global Const $BS_NULL = 1
Global Const $BS_PATTERN = 3
Global Const $BS_PATTERN8X8 = 7
Global Const $BS_SOLID = 0
Global Const $HS_BDIAGONAL = 3
Global Const $HS_CROSS = 4
Global Const $HS_DIAGCROSS = 5
Global Const $HS_FDIAGONAL = 2
Global Const $HS_HORIZONTAL = 0
Global Const $HS_VERTICAL = 1
Global Const $DIB_PAL_COLORS = 1
Global Const $DIB_RGB_COLORS = 0
Global Const $CA_NEGATIVE = 0x01
Global Const $CA_LOG_FILTER = 0x02
Global Const $ILLUMINANT_DEVICE_DEFAULT = 0
Global Const $ILLUMINANT_A = 1
Global Const $ILLUMINANT_B = 2
Global Const $ILLUMINANT_C = 3
Global Const $ILLUMINANT_D50 = 4
Global Const $ILLUMINANT_D55 = 5
Global Const $ILLUMINANT_D65 = 6
Global Const $ILLUMINANT_D75 = 7
Global Const $ILLUMINANT_F2 = 8
Global Const $ILLUMINANT_TUNGSTEN = $ILLUMINANT_A
Global Const $ILLUMINANT_DAYLIGHT = $ILLUMINANT_C
Global Const $ILLUMINANT_FLUORESCENT = $ILLUMINANT_F2
Global Const $ILLUMINANT_NTSC = $ILLUMINANT_C
Global Const $BI_RGB = 0
Global Const $BI_RLE8 = 1
Global Const $BI_RLE4 = 2
Global Const $BI_BITFIELDS = 3
Global Const $BI_JPEG = 4
Global Const $BI_PNG = 5
Global Const $ALTERNATE = 1
Global Const $WINDING = 2
Global Const $DWMWA_NCRENDERING_ENABLED = 1
Global Const $DWMWA_NCRENDERING_POLICY = 2
Global Const $DWMWA_TRANSITIONS_FORCEDISABLED = 3
Global Const $DWMWA_ALLOW_NCPAINT = 4
Global Const $DWMWA_CAPTION_BUTTON_BOUNDS = 5
Global Const $DWMWA_NONCLIENT_RTL_LAYOUT = 6
Global Const $DWMWA_FORCE_ICONIC_REPRESENTATION = 7
Global Const $DWMWA_FLIP3D_POLICY = 8
Global Const $DWMWA_EXTENDED_FRAME_BOUNDS = 9
Global Const $DWMWA_HAS_ICONIC_BITMAP = 10
Global Const $DWMWA_DISALLOW_PEEK = 11
Global Const $DWMWA_EXCLUDED_FROM_PEEK = 12
Global Const $DWMNCRP_USEWINDOWSTYLE = 0
Global Const $DWMNCRP_DISABLED = 1
Global Const $DWMNCRP_ENABLED = 2
Global Const $DWMFLIP3D_DEFAULT = 0
Global Const $DWMFLIP3D_EXCLUDEBELOW = 1
Global Const $DWMFLIP3D_EXCLUDEABOVE = 2
Global Const $DM_BITSPERPEL = 0x00040000
Global Const $DM_COLLATE = 0x0008000
Global Const $DM_COLOR = 0x00000800
Global Const $DM_COPIES = 0x00000100
Global Const $DM_DEFAULTSOURCE = 0x00000200
Global Const $DM_DISPLAYFIXEDOUTPUT = 0x20000000
Global Const $DM_DISPLAYFLAGS = 0x00200000
Global Const $DM_DISPLAYFREQUENCY = 0x00400000
Global Const $DM_DISPLAYORIENTATION = 0x00000080
Global Const $DM_DITHERTYPE = 0x04000000
Global Const $DM_DUPLEX = 0x0001000
Global Const $DM_FORMNAME = 0x00010000
Global Const $DM_ICMINTENT = 0x01000000
Global Const $DM_ICMMETHOD = 0x00800000
Global Const $DM_LOGPIXELS = 0x00020000
Global Const $DM_MEDIATYPE = 0x02000000
Global Const $DM_NUP = 0x00000040
Global Const $DM_ORIENTATION = 0x00000001
Global Const $DM_PANNINGHEIGHT = 0x10000000
Global Const $DM_PANNINGWIDTH = 0x08000000
Global Const $DM_PAPERLENGTH = 0x00000004
Global Const $DM_PAPERSIZE = 0x00000002
Global Const $DM_PAPERWIDTH = 0x00000008
Global Const $DM_PELSHEIGHT = 0x00100000
Global Const $DM_PELSWIDTH = 0x00080000
Global Const $DM_POSITION = 0x00000020
Global Const $DM_PRINTQUALITY = 0x00000400
Global Const $DM_SCALE = 0x00000010
Global Const $DM_TTOPTION = 0x0004000
Global Const $DM_YRESOLUTION = 0x0002000
Global Const $DMPAPER_LETTER = 1
Global Const $DMPAPER_LETTERSMALL = 2
Global Const $DMPAPER_TABLOID = 3
Global Const $DMPAPER_LEDGER = 4
Global Const $DMPAPER_LEGAL = 5
Global Const $DMPAPER_STATEMENT = 6
Global Const $DMPAPER_EXECUTIVE = 7
Global Const $DMPAPER_A3 = 8
Global Const $DMPAPER_A4 = 9
Global Const $DMPAPER_A4SMALL = 10
Global Const $DMPAPER_A5 = 11
Global Const $DMPAPER_B4 = 12
Global Const $DMPAPER_B5 = 13
Global Const $DMPAPER_FOLIO = 14
Global Const $DMPAPER_QUARTO = 15
Global Const $DMPAPER_10X14 = 16
Global Const $DMPAPER_11X17 = 17
Global Const $DMPAPER_NOTE = 18
Global Const $DMPAPER_ENV_9 = 19
Global Const $DMPAPER_ENV_10 = 20
Global Const $DMPAPER_ENV_11 = 21
Global Const $DMPAPER_ENV_12 = 22
Global Const $DMPAPER_ENV_14 = 23
Global Const $DMPAPER_CSHEET = 24
Global Const $DMPAPER_DSHEET = 25
Global Const $DMPAPER_ESHEET = 26
Global Const $DMPAPER_ENV_DL = 27
Global Const $DMPAPER_ENV_C5 = 28
Global Const $DMPAPER_ENV_C3 = 29
Global Const $DMPAPER_ENV_C4 = 30
Global Const $DMPAPER_ENV_C6 = 31
Global Const $DMPAPER_ENV_C65 = 32
Global Const $DMPAPER_ENV_B4 = 33
Global Const $DMPAPER_ENV_B5 = 34
Global Const $DMPAPER_ENV_B6 = 35
Global Const $DMPAPER_ENV_ITALY = 36
Global Const $DMPAPER_ENV_MONARCH = 37
Global Const $DMPAPER_ENV_PERSONAL = 38
Global Const $DMPAPER_FANFOLD_US = 39
Global Const $DMPAPER_FANFOLD_STD_GERMAN = 40
Global Const $DMPAPER_FANFOLD_LGL_GERMAN = 41
Global Const $DMPAPER_ISO_B4 = 42
Global Const $DMPAPER_JAPANESE_POSTCARD = 43
Global Const $DMPAPER_9X11 = 44
Global Const $DMPAPER_10X11 = 45
Global Const $DMPAPER_15X11 = 46
Global Const $DMPAPER_ENV_INVITE = 47
Global Const $DMPAPER_RESERVED_48 = 48
Global Const $DMPAPER_RESERVED_49 = 49
Global Const $DMPAPER_LETTER_EXTRA = 50
Global Const $DMPAPER_LEGAL_EXTRA = 51
Global Const $DMPAPER_TABLOID_EXTRA = 52
Global Const $DMPAPER_A4_EXTRA = 53
Global Const $DMPAPER_LETTER_TRANSVERSE = 54
Global Const $DMPAPER_A4_TRANSVERSE = 55
Global Const $DMPAPER_LETTER_EXTRA_TRANSVERSE = 56
Global Const $DMPAPER_A_PLUS = 57
Global Const $DMPAPER_B_PLUS = 58
Global Const $DMPAPER_LETTER_PLUS = 59
Global Const $DMPAPER_A4_PLUS = 60
Global Const $DMPAPER_A5_TRANSVERSE = 61
Global Const $DMPAPER_B5_TRANSVERSE = 62
Global Const $DMPAPER_A3_EXTRA = 63
Global Const $DMPAPER_A5_EXTRA = 64
Global Const $DMPAPER_B5_EXTRA = 65
Global Const $DMPAPER_A2 = 66
Global Const $DMPAPER_A3_TRANSVERSE = 67
Global Const $DMPAPER_A3_EXTRA_TRANSVERSE = 68
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD = 69
Global Const $DMPAPER_A6 = 70
Global Const $DMPAPER_JENV_KAKU2 = 71
Global Const $DMPAPER_JENV_KAKU3 = 72
Global Const $DMPAPER_JENV_CHOU3 = 73
Global Const $DMPAPER_JENV_CHOU4 = 74
Global Const $DMPAPER_LETTER_ROTATED = 75
Global Const $DMPAPER_A3_ROTATED = 76
Global Const $DMPAPER_A4_ROTATED = 77
Global Const $DMPAPER_A5_ROTATED = 78
Global Const $DMPAPER_B4_JIS_ROTATED = 79
Global Const $DMPAPER_B5_JIS_ROTATED = 80
Global Const $DMPAPER_JAPANESE_POSTCARD_ROTATED = 81
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82
Global Const $DMPAPER_A6_ROTATED = 83
Global Const $DMPAPER_JENV_KAKU2_ROTATED = 84
Global Const $DMPAPER_JENV_KAKU3_ROTATED = 85
Global Const $DMPAPER_JENV_CHOU3_ROTATED = 86
Global Const $DMPAPER_JENV_CHOU4_ROTATED = 87
Global Const $DMPAPER_B6_JIS = 88
Global Const $DMPAPER_B6_JIS_ROTATED = 89
Global Const $DMPAPER_12X11 = 90
Global Const $DMPAPER_JENV_YOU4 = 91
Global Const $DMPAPER_JENV_YOU4_ROTATED = 92
Global Const $DMPAPER_P16K = 93
Global Const $DMPAPER_P32K = 94
Global Const $DMPAPER_P32KBIG = 95
Global Const $DMPAPER_PENV_1 = 96
Global Const $DMPAPER_PENV_2 = 97
Global Const $DMPAPER_PENV_3 = 98
Global Const $DMPAPER_PENV_4 = 99
Global Const $DMPAPER_PENV_5 = 100
Global Const $DMPAPER_PENV_6 = 101
Global Const $DMPAPER_PENV_7 = 102
Global Const $DMPAPER_PENV_8 = 103
Global Const $DMPAPER_PENV_9 = 104
Global Const $DMPAPER_PENV_10 = 105
Global Const $DMPAPER_P16K_ROTATED = 106
Global Const $DMPAPER_P32K_ROTATED = 107
Global Const $DMPAPER_P32KBIG_ROTATED = 108
Global Const $DMPAPER_PENV_1_ROTATED = 109
Global Const $DMPAPER_PENV_2_ROTATED = 110
Global Const $DMPAPER_PENV_3_ROTATED = 111
Global Const $DMPAPER_PENV_4_ROTATED = 112
Global Const $DMPAPER_PENV_5_ROTATED = 113
Global Const $DMPAPER_PENV_6_ROTATED = 114
Global Const $DMPAPER_PENV_7_ROTATED = 115
Global Const $DMPAPER_PENV_8_ROTATED = 116
Global Const $DMPAPER_PENV_9_ROTATED = 117
Global Const $DMPAPER_PENV_10_ROTATED = 118
Global Const $DMPAPER_USER = 256
Global Const $DMBIN_UPPER = 1
Global Const $DMBIN_LOWER = 2
Global Const $DMBIN_MIDDLE = 3
Global Const $DMBIN_MANUAL = 4
Global Const $DMBIN_ENVELOPE = 5
Global Const $DMBIN_ENVMANUAL = 6
Global Const $DMBIN_AUTO = 7
Global Const $DMBIN_TRACTOR = 8
Global Const $DMBIN_SMALLFMT = 9
Global Const $DMBIN_LARGEFMT = 10
Global Const $DMBIN_LARGECAPACITY = 11
Global Const $DMBIN_CASSETTE = 14
Global Const $DMBIN_FORMSOURCE = 15
Global Const $DMBIN_USER = 256
Global Const $DMRES_DRAFT = -1
Global Const $DMRES_LOW = -2
Global Const $DMRES_MEDIUM = -3
Global Const $DMRES_HIGH = -4
Global Const $DMDO_DEFAULT = 0
Global Const $DMDO_90 = 1
Global Const $DMDO_180 = 2
Global Const $DMDO_270 = 3
Global Const $DMDFO_DEFAULT = 0
Global Const $DMDFO_STRETCH = 1
Global Const $DMDFO_CENTER = 2
Global Const $DMCOLOR_MONOCHROME = 1
Global Const $DMCOLOR_COLOR = 2
Global Const $DMDUP_SIMPLEX = 1
Global Const $DMDUP_VERTICAL = 2
Global Const $DMDUP_HORIZONTAL = 3
Global Const $DMTT_BITMAP = 1
Global Const $DMTT_DOWNLOAD = 2
Global Const $DMTT_SUBDEV = 3
Global Const $DMTT_DOWNLOAD_OUTLINE = 4
Global Const $DMCOLLATE_FALSE = 0
Global Const $DMCOLLATE_TRUE = 1
Global Const $DM_GRAYSCALE = 1
Global Const $DM_INTERLACED = 2
Global Const $DMNUP_SYSTEM = 1
Global Const $DMNUP_ONEUP = 2
Global Const $DMICMMETHOD_NONE = 1
Global Const $DMICMMETHOD_SYSTEM = 2
Global Const $DMICMMETHOD_DRIVER = 3
Global Const $DMICMMETHOD_DEVICE = 4
Global Const $DMICMMETHOD_USER = 256
Global Const $DMICM_SATURATE = 1
Global Const $DMICM_CONTRAST = 2
Global Const $DMICM_COLORIMETRIC = 3
Global Const $DMICM_ABS_COLORIMETRIC = 4
Global Const $DMICM_USER = 256
Global Const $DMMEDIA_STANDARD = 1
Global Const $DMMEDIA_TRANSPARENCY = 2
Global Const $DMMEDIA_GLOSSY = 3
Global Const $DMMEDIA_USER = 256
Global Const $DMDITHER_NONE = 1
Global Const $DMDITHER_COARSE = 2
Global Const $DMDITHER_FINE = 3
Global Const $DMDITHER_LINEART = 4
Global Const $DMDITHER_ERRORDIFFUSION = 5
Global Const $DMDITHER_RESERVED6 = 6
Global Const $DMDITHER_RESERVED7 = 7
Global Const $DMDITHER_RESERVED8 = 8
Global Const $DMDITHER_RESERVED9 = 9
Global Const $DMDITHER_GRAYSCALE = 10
Global Const $DMDITHER_USER = 256
Global Const $ENUM_CURRENT_SETTINGS = -1
Global Const $ENUM_REGISTRY_SETTINGS = -2
Global Const $DEVICE_FONTTYPE = 0x2
Global Const $RASTER_FONTTYPE = 0x1
Global Const $TRUETYPE_FONTTYPE = 0x4
Global Const $NTM_BOLD = 0x00000020
Global Const $NTM_DSIG = 0x00200000
Global Const $NTM_ITALIC = 0x00000001
Global Const $NTM_MULTIPLEMASTER = 0x00080000
Global Const $NTM_NONNEGATIVE_AC = 0x00010000
Global Const $NTM_PS_OPENTYPE = 0x00020000
Global Const $NTM_REGULAR = 0x00000040
Global Const $NTM_TT_OPENTYPE = 0x00040000
Global Const $NTM_TYPE1 = 0x00100000
Global Const $FLOODFILLBORDER = 0
Global Const $FLOODFILLSURFACE = 1
Global Const $AD_COUNTERCLOCKWISE = 1
Global Const $AD_CLOCKWISE = 2
Global Const $DCB_ACCUMULATE = 0x02
Global Const $DCB_DISABLE = 0x08
Global Const $DCB_ENABLE = 0x04
Global Const $DCB_RESET = 0x01
Global Const $DCB_SET = BitOR($DCB_RESET, $DCB_ACCUMULATE)
Global Const $OBJ_BITMAP = 7
Global Const $OBJ_BRUSH = 2
Global Const $OBJ_COLORSPACE = 14
Global Const $OBJ_DC = 3
Global Const $OBJ_ENHMETADC = 12
Global Const $OBJ_ENHMETAFILE = 13
Global Const $OBJ_EXTPEN = 11
Global Const $OBJ_FONT = 6
Global Const $OBJ_MEMDC = 10
Global Const $OBJ_METADC = 4
Global Const $OBJ_METAFILE = 9
Global Const $OBJ_PAL = 5
Global Const $OBJ_PEN = 1
Global Const $OBJ_REGION = 8
Global Const $DCX_WINDOW = 0x00000001
Global Const $DCX_CACHE = 0x00000002
Global Const $DCX_PARENTCLIP = 0x00000020
Global Const $DCX_CLIPSIBLINGS = 0x00000010
Global Const $DCX_CLIPCHILDREN = 0x00000008
Global Const $DCX_NORESETATTRS = 0x00000004
Global Const $DCX_LOCKWINDOWUPDATE = 0x00000400
Global Const $DCX_EXCLUDERGN = 0x00000040
Global Const $DCX_INTERSECTRGN = 0x00000080
Global Const $DCX_INTERSECTUPDATE = 0x00000200
Global Const $DCX_VALIDATE = 0x00200000
Global Const $GGO_BEZIER = 3
Global Const $GGO_BITMAP = 1
Global Const $GGO_GLYPH_INDEX = 0x0080
Global Const $GGO_GRAY2_BITMAP = 4
Global Const $GGO_GRAY4_BITMAP = 5
Global Const $GGO_GRAY8_BITMAP = 6
Global Const $GGO_METRICS = 0
Global Const $GGO_NATIVE = 2
Global Const $GGO_UNHINTED = 0x0100
Global Const $GM_COMPATIBLE = 1
Global Const $GM_ADVANCED = 2
Global Const $MM_ANISOTROPIC = 8
Global Const $MM_HIENGLISH = 5
Global Const $MM_HIMETRIC = 3
Global Const $MM_ISOTROPIC = 7
Global Const $MM_LOENGLISH = 4
Global Const $MM_LOMETRIC = 2
Global Const $MM_TEXT = 1
Global Const $MM_TWIPS = 6
Global Const $R2_BLACK = 1
Global Const $R2_COPYPEN = 13
Global Const $R2_LAST = 16
Global Const $R2_MASKNOTPEN = 3
Global Const $R2_MASKPEN = 9
Global Const $R2_MASKPENNOT = 5
Global Const $R2_MERGENOTPEN = 12
Global Const $R2_MERGEPEN = 15
Global Const $R2_MERGEPENNOT = 14
Global Const $R2_NOP = 11
Global Const $R2_NOT = 6
Global Const $R2_NOTCOPYPEN = 4
Global Const $R2_NOTMASKPEN = 8
Global Const $R2_NOTMERGEPEN = 2
Global Const $R2_NOTXORPEN = 10
Global Const $R2_WHITE = 16
Global Const $R2_XORPEN = 7
Global Const $BLACKONWHITE = 1
Global Const $COLORONCOLOR = 3
Global Const $HALFTONE = 4
Global Const $WHITEONBLACK = 2
Global Const $STRETCH_ANDSCANS = $BLACKONWHITE
Global Const $STRETCH_DELETESCANS = $COLORONCOLOR
Global Const $STRETCH_HALFTONE = $HALFTONE
Global Const $STRETCH_ORSCANS = $WHITEONBLACK
Global Const $TA_BASELINE = 0x0018
Global Const $TA_BOTTOM = 0x0008
Global Const $TA_TOP = 0x0000
Global Const $TA_CENTER = 0x0006
Global Const $TA_LEFT = 0x0000
Global Const $TA_RIGHT = 0x0002
Global Const $TA_NOUPDATECP = 0x0000
Global Const $TA_RTLREADING = 0x0100
Global Const $TA_UPDATECP = 0x0001
Global Const $VTA_BASELINE = $TA_BASELINE
Global Const $VTA_BOTTOM = $TA_RIGHT
Global Const $VTA_TOP = $TA_LEFT
Global Const $VTA_CENTER = $TA_CENTER
Global Const $VTA_LEFT = $TA_BOTTOM
Global Const $VTA_RIGHT = $TA_TOP
Global Const $UDF_BGR = 1
Global Const $UDF_RGB = 0
Global Const $MWT_IDENTITY = 0x01
Global Const $MWT_LEFTMULTIPLY = 0x02
Global Const $MWT_RIGHTMULTIPLY = 0x03
Global Const $MWT_SET = 0x04
Global Const $MONITOR_DEFAULTTONEAREST = 2
Global Const $MONITOR_DEFAULTTONULL = 0
Global Const $MONITOR_DEFAULTTOPRIMARY = 1
Global Const $PT_BEZIERTO = 4
Global Const $PT_LINETO = 2
Global Const $PT_MOVETO = 6
Global Const $PT_CLOSEFIGURE = 1
#Region Global Variables and Constants
Global Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Global Const $tagBITMAPV4HEADER = 'struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct'
Global Const $tagBITMAPV5HEADER = 'struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct'
Global Const $tagCOLORADJUSTMENT = 'ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint'
Global Const $tagDEVMODE_DISPLAY = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;' & $tagPOINT & ';dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency'
Global Const $tagDIBSECTION = $tagBITMAP & ';' & $tagBITMAPINFOHEADER & ';dword dsBitfields[3];ptr dshSection;dword dsOffset'
Global Const $tagDWM_COLORIZATION_PARAMETERS = 'dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend'
Global Const $tagENHMETAHEADER = 'struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct'
Global Const $tagEXTLOGPEN = 'dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries'
Global Const $tagFONTSIGNATURE = 'dword fsUsb[4];dword fsCsb[2]'
Global Const $tagGLYPHMETRICS = 'uint BlackBoxX;uint BlackBoxY;' & $tagPOINT & ';short CellIncX;short CellIncY'
Global Const $tagLOGBRUSH = 'uint Style;dword Color;ulong_ptr Hatch'
Global Const $tagLOGPEN = 'uint Style;dword Width;dword Color'
Global Const $tagMAT2 = 'short eM11[2];short eM12[2];short eM21[2];short eM22[2]'
Global Const $tagNEWTEXTMETRIC = $tagTEXTMETRIC & ';dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth'
Global Const $tagNEWTEXTMETRICEX = $tagNEWTEXTMETRIC & ';' & $tagFONTSIGNATURE
Global Const $tagPANOSE = 'struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct'
Global Const $tagOUTLINETEXTMETRIC = 'struct;uint otmSize;' & $tagTEXTMETRIC & ';byte otmFiller;' & $tagPANOSE & ';byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct'
Global Const $tagPAINTSTRUCT = 'hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]'
Global Const $tagRGNDATAHEADER = 'struct;dword Size;dword Type;dword Count;dword RgnSize;' & $tagRECT & ';endstruct'
Global Const $tagXFORM = 'float eM11;float eM12;float eM21;float eM22;float eDx;float eDy'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_AbortPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'AbortPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AddFontMemResourceEx($pData, $iSize)
Local $aRet = DllCall('gdi32.dll', 'handle', 'AddFontMemResourceEx', 'ptr', $pData, 'dword', $iSize, 'ptr', 0, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aRet[4], $aRet[0])
EndFunc
Func _WinAPI_AddFontResourceEx($sFont, $iFlag = 0, $bNotify = False)
Local $aRet = DllCall('gdi32.dll', 'int', 'AddFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
If $bNotify Then
Local Const $WM_FONTCHANGE = 0x001D
Local Const $HWND_BROADCAST = 0xFFFF
DllCall('user32.dll', 'lresult', 'SendMessage', 'hwnd', $HWND_BROADCAST, 'uint', $WM_FONTCHANGE, 'wparam', 0,  'lparam', 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_AddIconOverlay($hIcon, $hOverlay)
Local $aRet, $hResult = 0, $iError = 0
Local $ahDev[2] = [0, 0]
Local $tSIZE = _WinAPI_GetIconDimension($hIcon)
Local $hIL = DllCall('comctl32.dll', 'handle', 'ImageList_Create', 'int', DllStructGetData($tSIZE, 1),  'int', DllStructGetData($tSIZE, 2), 'uint', 0x0021, 'int', 2, 'int', 2)
If @error Or Not $hIL[0] Then Return SetError(@error + 10, @extended, 0)
Do
$ahDev[0] = _WinAPI_Create32BitHICON($hIcon)
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'handle', $hIL[0], 'int', -1, 'handle', $ahDev[0])
If @error Or ($aRet[0] = -1) Then
$iError = @error + 200
ExitLoop
EndIf
$ahDev[1] = _WinAPI_Create32BitHICON($hOverlay)
If @error Then
$iError = @error + 300
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'handle', $hIL[0], 'int', -1, 'handle', $ahDev[1])
If @error Or ($aRet[0] = -1) Then
$iError = @error + 400
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'bool', 'ImageList_SetOverlayImage', 'handle', $hIL[0], 'int', 1, 'int', 1)
If @error Or Not $aRet[0] Then
$iError = @error + 500
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'handle', 'ImageList_GetIcon', 'handle', $hIL[0], 'int', 0, 'uint', 0x00000100)
If @error Or Not $aRet[0] Then
$iError = @error + 600
ExitLoop
EndIf
$hResult = $aRet[0]
Until 1
DllCall('comctl32.dll', 'bool', 'ImageList_Destroy', 'handle', $hIL[0])
For $i = 0 To 1
If $ahDev[$i] Then
_WinAPI_DestroyIcon($ahDev[$i])
EndIf
Next
If Not $hResult Then Return SetError($iError, 0, 0)
Return $hResult
EndFunc
Func _WinAPI_AdjustBitmap($hBitmap, $iWidth, $iHeight, $iMode = 3, $tAdjustment = 0)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
If $iWidth = -1 Then
$iWidth = DllStructGetData($tObj, 'bmWidth')
EndIf
If $iHeight = -1 Then
$iHeight = DllStructGetData($tObj, 'bmHeight')
EndIf
$aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', 0)
Local $hDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleBitmap', 'handle', $hDC, 'int', $iWidth, 'int', $iHeight)
Local $hBmp = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBmp)
Local $hDestSv = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hSrcDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hBitmap)
Local $hSrcSv = $aRet[0]
If _WinAPI_SetStretchBltMode($hDestDC, $iMode) Then
Switch $iMode
Case 4
If IsDllStruct($tAdjustment) Then
If Not _WinAPI_SetColorAdjustment($hDestDC, $tAdjustment) Then
EndIf
EndIf
Case Else
EndSwitch
EndIf
$aRet = _WinAPI_StretchBlt($hDestDC, 0, 0, $iWidth, $iHeight, $hSrcDC, 0, 0, DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'), 0x00CC0020)
DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'handle', $hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hSrcSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hSrcDC)
If Not $aRet Then Return SetError(10, 0, 0)
Return $hBmp
EndFunc
Func _WinAPI_AlphaBlend($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iAlpha, $bAlpha = False)
Local $iBlend = BitOR(BitShift(Not ($bAlpha = False), -24), BitShift(BitAND($iAlpha, 0xFF), -16))
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiAlphaBlend', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'handle', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iBlend)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AngleArc($hDC, $iX, $iY, $iRadius, $nStartAngle, $nSweepAngle)
Local $aRet = DllCall('gdi32.dll', 'bool', 'AngleArc', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', $iRadius,  'float', $nStartAngle, 'float', $nSweepAngle)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Arc($hDC, $tRECT, $iXStartArc, $iYStartArc, $iXEndArc, $iYEndArc)
Local $aRet = DllCall('gdi32.dll', 'bool', 'Arc', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4),  'int', $iXStartArc, 'int', $iYStartArc, 'int', $iXEndArc, 'int', $iYEndArc)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ArcTo($hDC, $tRECT, $iXRadial1, $iYRadial1, $iXRadial2, $iYRadial2)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ArcTo', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4),  'int', $iXRadial1, 'int', $iYRadial1, 'int', $iXRadial2, 'int', $iYRadial2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_BeginPaint($hWnd, ByRef $tPAINTSTRUCT)
$tPAINTSTRUCT = DllStructCreate($tagPAINTSTRUCT)
Local $aRet = DllCall('user32.dll', 'handle', 'BeginPaint', 'hwnd', $hWnd, 'struct*', $tPAINTSTRUCT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_BeginPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'BeginPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseEnhMetaFile($hDC)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CloseEnhMetaFile', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseFigure($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'CloseFigure', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ColorAdjustLuma($iRGB, $iPercent, $bScale = True)
If $iRGB = -1 Then Return SetError(10, 0, -1)
If $bScale Then
$iPercent = Floor($iPercent * 10)
EndIf
Local $aRet = DllCall('shlwapi.dll', 'dword', 'ColorAdjustLuma', 'dword', __RGB($iRGB), 'int', $iPercent, 'bool', $bScale)
If @error Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_ColorHLSToRGB($iHue, $iLuminance, $iSaturation)
If Not $iSaturation Then $iHue = 160
Local $aRet = DllCall('shlwapi.dll', 'dword', 'ColorHLSToRGB', 'word', $iHue, 'word', $iLuminance, 'word', $iSaturation)
If @error Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_ColorRGBToHLS($iRGB, ByRef $iHue, ByRef $iLuminance, ByRef $iSaturation)
Local $aRet = DllCall('shlwapi.dll', 'none', 'ColorRGBToHLS', 'dword', __RGB($iRGB), 'word*', 0, 'word*', 0, 'word*', 0)
If @error Then Return SetError(@error, @extended, 0)
$iHue = $aRet[2]
$iLuminance = $aRet[3]
$iSaturation = $aRet[4]
Return 1
EndFunc
Func _WinAPI_CombineTransform($tXFORM1, $tXFORM2)
Local $tXFORM = DllStructCreate($tagXFORM)
Local $aRet = DllCall('gdi32.dll', 'bool', 'CombineTransform', 'struct*', $tXFORM, 'struct*', $tXFORM1, 'struct*', $tXFORM2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tXFORM
EndFunc
Func _WinAPI_CompressBitmapBits($hBitmap, ByRef $pBuffer, $iCompression = 0, $iQuality = 100)
If Not __DLL('gdiplus.dll') Then Return SetError(103, 0, 0)
Local $aSize[2], $iCount, $iFormat, $iLength, $sMime, $aRet, $hDC, $hSv, $hMem, $tBits, $tData, $pData, $iError = 1
Local $hSource = 0, $hImage = 0, $hToken = 0, $pStream = 0, $tParam = 0
Local $tDIB = DllStructCreate($tagDIBSECTION)
Do
Switch $iCompression
Case 0
$sMime = 'image/png'
Case 1
$sMime = 'image/jpeg'
Case Else
$iError = 10
ExitLoop
EndSwitch
While $hBitmap
If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB) Then
$iError = 11
ExitLoop 2
EndIf
If (DllStructGetData($tDIB, 'bmBitsPixel') = 32) And (Not DllStructGetData($tDIB, 'biCompression')) Then
$iError = 12
ExitLoop
EndIf
If $hSource Then
$iError = 13
ExitLoop 2
EndIf
$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'))
If Not $hSource Then
$iError = @error + 100
ExitLoop 2
EndIf
$hDC = _WinAPI_CreateCompatibleDC(0)
$hSv = _WinAPI_SelectObject($hDC, $hSource)
If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
$hBitmap = $hSource
Else
$iError = @error + 200
$hBitmap = 0
EndIf
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
WEnd
If Not $hBitmap Then
ExitLoop
EndIf
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tDIB, $i + 2)
Next
$tBits = DllStructCreate('byte[' & ($aSize[0] * $aSize[1] * 4) & ']')
If Not _WinAPI_GetBitmapBits($hBitmap, DllStructGetSize($tBits), $tBits) Then
$iError = @error + 300
ExitLoop
EndIf
$tData = DllStructCreate($tagGDIPSTARTUPINPUT)
DllStructSetData($tData, "Version", 1)
$aRet = DllCall('gdiplus.dll', 'int', 'GdiplusStartup', 'ulong_ptr*', 0, 'struct*', $tData, 'ptr', 0)
If @error Or $aRet[0] Then
$iError = @error + 400
ExitLoop
EndIf
If _WinAPI_IsAlphaBitmap($hBitmap) Then
$iFormat = 0x0026200A
Else
$iFormat = 0x00022009
EndIf
$hToken = $aRet[1]
$aRet = DllCall('gdiplus.dll', 'int', 'GdipCreateBitmapFromScan0', 'int', $aSize[0], 'int', $aSize[1],  'uint', $aSize[0] * 4, 'int', $iFormat, 'struct*', $tBits, 'ptr*', 0)
If @error Or $aRet[0] Then
$iError = @error + 500
ExitLoop
EndIf
$hImage = $aRet[6]
$aRet = DllCall('gdiplus.dll', 'int', 'GdipGetImageEncodersSize', 'uint*', 0, 'uint*', 0)
If @error Or $aRet[0] Then
$iError = @error + 600
ExitLoop
EndIf
$iCount = $aRet[1]
$tData = DllStructCreate('byte[' & $aRet[2] & ']')
If @error Then
$iError = @error + 700
ExitLoop
EndIf
$pData = DllStructGetPtr($tData)
$aRet = DllCall('gdiplus.dll', 'int', 'GdipGetImageEncoders', 'uint', $iCount, 'uint', $aRet[2], 'struct*', $tData)
If @error Or $aRet[0] Then
$iError = @error + 800
ExitLoop
EndIf
Local $tCodec, $pEncoder = 0
For $i = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pData)
If Not StringInStr(_WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, 'MimeType')), $sMime) Then
$pData += DllStructGetSize($tagGDIPIMAGECODECINFO)
Else
$pEncoder = $pData
$iError = 0
ExitLoop
EndIf
Next
If Not $pEncoder Then
$iError = 15
ExitLoop
EndIf
Switch $iCompression
Case 0
Case 1
Local Const $tagENCODERPARAMETER = 'byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue'
$tParam = DllStructCreate('dword Count;' & $tagENCODERPARAMETER & ';ulong Quality')
DllStructSetData($tParam, 'Count', 1)
DllStructSetData($tParam, 'NumberOfValues', 1)
DllStructSetData($tParam, 'Type', 4)
DllStructSetData($tParam, 'pValue', DllStructGetPtr($tParam, 'Quality'))
DllStructSetData($tParam, 'Quality', $iQuality)
$aRet = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}',  'ptr', DllStructGetPtr($tParam, 2))
If @error Or $aRet[0] Then
$tParam = 0
EndIf
EndSwitch
$pStream = _WinAPI_CreateStreamOnHGlobal()
$aRet = DllCall('gdiplus.dll', 'int', 'GdipSaveImageToStream', 'handle', $hImage, 'ptr', $pStream,  'ptr', $pEncoder, 'struct*', $tParam)
If @error Or $aRet[0] Then
$iError = @error + 900
ExitLoop
EndIf
$hMem = _WinAPI_GetHGlobalFromStream($pStream)
$aRet = DllCall('kernel32.dll', 'ulong_ptr', 'GlobalSize', 'handle', $hMem)
If @error Or Not $aRet[0] Then
$iError = @error + 1000
ExitLoop
EndIf
$iLength = $aRet[0]
$aRet = DllCall('kernel32.dll', 'ptr', 'GlobalLock', 'handle', $hMem)
If @error Or Not $aRet[0] Then
$iError = @error + 1100
ExitLoop
EndIf
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 1)
If Not @error Then
_WinAPI_MoveMemory($pBuffer, $aRet[0], $iLength)
Else
$iError = @error + 1300
EndIf
Until 1
If $pStream Then
_WinAPI_ReleaseStream($pStream)
EndIf
If $hImage Then
DllCall('gdiplus.dll', 'int', 'GdipDisposeImage', 'handle', $hImage)
EndIf
If $hToken Then
DllCall('gdiplus.dll', 'none', 'GdiplusShutdown', 'ulong_ptr', $hToken)
EndIf
If $hSource Then
_WinAPI_DeleteObject($hSource)
EndIf
If $iError Then Return SetError($iError, 0, 0)
Return $iLength
EndFunc
Func _WinAPI_CopyBitmap($hBitmap)
$hBitmap = _WinAPI_CopyImage($hBitmap, 0, 0, 0, 0x2000)
Return SetError(@error, @extended, $hBitmap)
EndFunc
Func _WinAPI_CopyEnhMetaFile($hEmf, $sFilePath = '')
Local $sTypeOfFile = 'wstr'
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFile = 'ptr'
$sFilePath = 0
EndIf
Local $aRet = DllCall('gdi32.dll', 'handle', 'CopyEnhMetaFileW', 'handle', $hEmf, $sTypeOfFile, $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CopyImage($hImage, $iType = 0, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CopyImage', 'handle', $hImage, 'uint', $iType,  'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CopyRect($tRECT)
Local $tData = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'CopyRect', 'struct*', $tData, 'struct*', $tRECT)
If @error Or Not $aRet[0] Then SetError(@error + 10, @extended, 0)
Return $tData
EndFunc
Func _WinAPI_Create32BitHBITMAP($hIcon, $bDib = False, $bDelete = False)
Local $hBitmap = 0
Local $aDIB[2] = [0, 0]
Local $hTemp = _WinAPI_Create32BitHICON($hIcon)
If @error Then Return SetError(@error, @extended, 0)
Local $iError = 0
Do
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hTemp, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
For $i = 0 To 1
$aDIB[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($aDIB[0], DllStructGetSize($tBITMAP), $tBITMAP) Then
$iError = @error + 20
ExitLoop
EndIf
If $bDib Then
$hBitmap = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
_WinAPI_DrawIconEx($hDC, 0, 0, $hTemp)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = $aDIB[1]
$aDIB[1] = 0
EndIf
Until 1
For $i = 0 To 1
If $aDIB[$i] Then
_WinAPI_DeleteObject($aDIB[$i])
EndIf
Next
_WinAPI_DestroyIcon($hTemp)
If $iError Then Return SetError($iError, 0, 0)
If Not $hBitmap Then Return SetError(12, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hBitmap
EndFunc
Func _WinAPI_Create32BitHICON($hIcon, $bDelete = False)
Local $ahBitmap[2], $hResult = 0
Local $aDIB[2][2] = [[0, 0], [0, 0]]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
If _WinAPI_IsAlphaBitmap($ahBitmap[1]) Then
$aDIB[0][0] = _WinAPI_CreateANDBitmap($ahBitmap[1])
If Not @error Then
$hResult = _WinAPI_CreateIconIndirect($ahBitmap[1], $aDIB[0][0])
EndIf
Else
Local $tSIZE = _WinAPI_GetBitmapDimension($ahBitmap[1])
Local $aSize[2]
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tSIZE, $i + 1)
Next
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv, $hDstSv
For $i = 0 To 1
$aDIB[$i][0] = _WinAPI_CreateDIB($aSize[0], $aSize[1])
$aDIB[$i][1] = $__g_vExt
$hSrcSv = _WinAPI_SelectObject($hSrcDC, $ahBitmap[$i])
$hDstSv = _WinAPI_SelectObject($hDstDC, $aDIB[$i][0])
_WinAPI_BitBlt($hDstDC, 0, 0, $aSize[0], $aSize[1], $hSrcDC, 0, 0, 0x00C000CA)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_SelectObject($hDstDC, $hDstSv)
Next
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_DeleteDC($hDstDC)
$aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __XORProc(), 'ptr', 0,  'uint', $aSize[0] * $aSize[1] * 4, 'wparam', $aDIB[0][1], 'lparam', $aDIB[1][1])
If Not @error And $aRet[0] Then
$hResult = _WinAPI_CreateIconIndirect($aDIB[1][0], $ahBitmap[0])
EndIf
EndIf
For $i = 0 To 1
_WinAPI_DeleteObject($ahBitmap[$i])
If $aDIB[$i][0] Then
_WinAPI_DeleteObject($aDIB[$i][0])
EndIf
Next
If Not $hResult Then Return SetError(11, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_CreateANDBitmap($hBitmap)
Local $iError = 0, $hDib = 0
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Do
Local $atDIB[2]
$atDIB[0] = DllStructCreate($tagDIBSECTION)
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($atDIB[0]), $atDIB[0]))  Or (DllStructGetData($atDIB[0], 'bmBitsPixel') <> 32) Or (DllStructGetData($atDIB[0], 'biCompression')) Then
$iError = 10
ExitLoop
EndIf
$atDIB[1] = DllStructCreate($tagBITMAP)
$hDib = _WinAPI_CreateDIB(DllStructGetData($atDIB[0], 'bmWidth'), DllStructGetData($atDIB[0], 'bmHeight'), 1)
If Not _WinAPI_GetObject($hDib, DllStructGetSize($atDIB[1]), $atDIB[1]) Then
$iError = 11
ExitLoop
EndIf
Local $aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __ANDProc(), 'ptr', 0, 'uint', 0,  'wparam', DllStructGetPtr($atDIB[0]), 'lparam', DllStructGetPtr($atDIB[1]))
If @error Then
$iError = @error
ExitLoop
EndIf
If Not $aRet[0] Then
$iError = 12
ExitLoop
EndIf
$iError = 0
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
$hDib = 0
EndIf
Return SetError($iError, 0, $hDib)
EndFunc
Func _WinAPI_CreateBitmapIndirect(ByRef $tBITMAP)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateBitmapIndirect', 'struct*', $tBITMAP)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateBrushIndirect($iStyle, $iRGB, $iHatch = 0)
Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)
DllStructSetData($tLOGBRUSH, 1, $iStyle)
DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
DllStructSetData($tLOGBRUSH, 3, $iHatch)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateBrushIndirect', 'struct*', $tLOGBRUSH)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateColorAdjustment($iFlags = 0, $iIlluminant = 0, $iGammaR = 10000, $iGammaG = 10000, $iGammaB = 10000, $iBlack = 0, $iWhite = 10000, $iContrast = 0, $iBrightness = 0, $iColorfulness = 0, $iTint = 0)
Local $tCA = DllStructCreate($tagCOLORADJUSTMENT)
DllStructSetData($tCA, 1, DllStructGetSize($tCA))
DllStructSetData($tCA, 2, $iFlags)
DllStructSetData($tCA, 3, $iIlluminant)
DllStructSetData($tCA, 4, $iGammaR)
DllStructSetData($tCA, 5, $iGammaG)
DllStructSetData($tCA, 6, $iGammaB)
DllStructSetData($tCA, 7, $iBlack)
DllStructSetData($tCA, 8, $iWhite)
DllStructSetData($tCA, 9, $iContrast)
DllStructSetData($tCA, 10, $iBrightness)
DllStructSetData($tCA, 11, $iColorfulness)
DllStructSetData($tCA, 12, $iTint)
Return $tCA
EndFunc
Func _WinAPI_CreateCompatibleBitmapEx($hDC, $iWidth, $iHeight, $iRGB)
Local $hBrush = _WinAPI_CreateBrushIndirect(0, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleBitmap', 'handle', $hDC, 'int', $iWidth, 'int', $iHeight)
Local $hBmp = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBmp)
Local $hDestSv = $aRet[0]
Local $tRECT = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
Local $iError = 0
$aRet = DllCall('user32.dll', 'int', 'FillRect', 'handle', $hDestDC, 'struct*', $tRECT, 'handle', $hBrush)
If @error Or Not $aRet[0] Then
$iError = @error + 10
_WinAPI_DeleteObject($hBmp)
EndIf
_WinAPI_DeleteObject($hBrush)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
If $iError Then Return SetError($iError, 0, 0)
Return $hBmp
EndFunc
Func _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel = 32, $tColorTable = 0, $iColorCount = 0)
Local $aRGBQ[2], $iColors, $tagRGBQ
Switch $iBitsPerPel
Case 1
$iColors = 2
Case 4
$iColors = 16
Case 8
$iColors = 256
Case Else
$iColors = 0
EndSwitch
If $iColors Then
If Not IsDllStruct($tColorTable) Then
Switch $iBitsPerPel
Case 1
$aRGBQ[0] = 0
$aRGBQ[1] = 0xFFFFFF
$tColorTable = _WinAPI_CreateDIBColorTable($aRGBQ)
Case Else
EndSwitch
Else
If $iColors > $iColorCount Then
$iColors = $iColorCount
EndIf
If (Not $iColors) Or ((4 * $iColors) > DllStructGetSize($tColorTable)) Then
Return SetError(20, 0, 0)
EndIf
EndIf
$tagRGBQ = ';dword aRGBQuad[' & $iColors & ']'
Else
$tagRGBQ = ''
EndIf
Local $tBITMAPINFO = DllStructCreate($tagBITMAPINFOHEADER & $tagRGBQ)
DllStructSetData($tBITMAPINFO, 'biSize', 40)
DllStructSetData($tBITMAPINFO, 'biWidth', $iWidth)
DllStructSetData($tBITMAPINFO, 'biHeight', $iHeight)
DllStructSetData($tBITMAPINFO, 'biPlanes', 1)
DllStructSetData($tBITMAPINFO, 'biBitCount', $iBitsPerPel)
DllStructSetData($tBITMAPINFO, 'biCompression', 0)
DllStructSetData($tBITMAPINFO, 'biSizeImage', 0)
DllStructSetData($tBITMAPINFO, 'biXPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biYPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biClrUsed', $iColors)
DllStructSetData($tBITMAPINFO, 'biClrImportant', 0)
If $iColors Then
If IsDllStruct($tColorTable) Then
_WinAPI_MoveMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), $tColorTable, 4 * $iColors)
Else
_WinAPI_ZeroMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), 4 * $iColors)
EndIf
EndIf
Local $hBitmap = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $__g_vExt)
If Not $hBitmap Then Return SetError(@error, @extended, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateDIBColorTable(Const ByRef $aColorTable, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aColorTable, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tColorTable = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tColorTable, 1, _WinAPI_SwitchColor(__RGB($aColorTable[$i])), $iCount)
$iCount += 1
Next
Return $tColorTable
EndFunc
Func _WinAPI_CreateDIBitmap($hDC, ByRef $tBITMAPINFO, $iUsage, $pBits = 0)
Local $iInit = 0
If $pBits Then
$iInit = 0x04
EndIf
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateDIBitmap', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'dword', $iInit, 'struct*', $pBits,  'struct*', $tBITMAPINFO, 'uint', $iUsage)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateDIBSection($hDC, $tBITMAPINFO, $iUsage, ByRef $pBits, $hSection = 0, $iOffset = 0)
$pBits = 0
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateDIBSection', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'uint', $iUsage,  'ptr*', 0, 'handle', $hSection, 'dword', $iOffset)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBits = $aRet[4]
Return $aRet[0]
EndFunc
Func _WinAPI_CreateEllipticRgn($tRECT)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateEllipticRgnIndirect', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateEmptyIcon($iWidth, $iHeight, $iBitsPerPel = 32)
Local $hXOR = _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel)
Local $hAND = _WinAPI_CreateDIB($iWidth, $iHeight, 1)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hAND)
Local $hBrush = _WinAPI_CreateSolidBrush(0xFFFFFF)
Local $tRECT = _WinAPI_CreateRect(0, 0, $iWidth, $iHeight)
_WinAPI_FillRect($hDC, $tRECT, $hBrush)
_WinAPI_DeleteObject($hBrush)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Local $hIcon = _WinAPI_CreateIconIndirect($hXOR, $hAND)
Local $iError = @error
If $hXOR Then
_WinAPI_DeleteObject($hXOR)
EndIf
If $hAND Then
_WinAPI_DeleteObject($hAND)
EndIf
If Not $hIcon Then Return SetError($iError + 10, 0, 0)
Return $hIcon
EndFunc
Func _WinAPI_CreateEnhMetaFile($hDC = 0, $tRECT = 0, $bPixels = False, $sFilePath = '', $sDescription = '')
Local $sTypeOfFile = 'wstr'
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFile = 'ptr'
$sFilePath = 0
EndIf
Local $tData = 0, $aData = StringSplit($sDescription, '|', $STR_NOCOUNT)
If UBound($aData) < 2 Then
ReDim $aData[2]
$aData[1] = ''
EndIf
For $i = 0 To 1
$aData[$i] = StringStripWS($aData[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING)
Next
If ($aData[0]) Or ($aData[1]) Then
$tData = _WinAPI_ArrayToStruct($aData)
EndIf
Local $iXp, $iYp, $iXm, $iYm, $hRef = 0
If $bPixels And (IsDllStruct($tRECT)) Then
If Not $hDC Then
$hRef = _WinAPI_GetDC(0)
EndIf
$iXp = _WinAPI_GetDeviceCaps($hRef, 8)
$iYp = _WinAPI_GetDeviceCaps($hRef, 10)
$iXm = _WinAPI_GetDeviceCaps($hRef, 4)
$iYm = _WinAPI_GetDeviceCaps($hRef, 6)
If $hRef Then
_WinAPI_ReleaseDC(0, $hRef)
EndIf
For $i = 1 To 3 Step 2
DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $iXm / $iXp * 100))
Next
For $i = 2 To 4 Step 2
DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $iYm / $iYp * 100))
Next
EndIf
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateEnhMetaFileW', 'handle', $hDC, $sTypeOfFile, $sFilePath, 'struct*', $tRECT,  'struct*', $tData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateFontEx($iHeight, $iWidth = 0, $iEscapement = 0, $iOrientation = 0, $iWeight = 400, $bItalic = False, $bUnderline = False, $bStrikeOut = False, $iCharSet = 1, $iOutPrecision = 0, $iClipPrecision = 0, $iQuality = 0, $iPitchAndFamily = 0, $sFaceName = '', $iStyle = 0)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateFontW', 'int', $iHeight, 'int', $iWidth, 'int', $iEscapement,  'int', $iOrientation, 'int', $iWeight, 'dword', $bItalic, 'dword', $bUnderline, 'dword', $bStrikeOut,  'dword', $iCharSet, 'dword', $iOutPrecision, 'dword', $iClipPrecision, 'dword', $iQuality,  'dword', $iPitchAndFamily, 'wstr', _WinAPI_GetFontName($sFaceName, $iStyle, $iCharSet))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateIconIndirect($hBitmap, $hMask, $iXHotspot = 0, $iYHotspot = 0, $bIcon = True)
Local $tICONINFO = DllStructCreate($tagICONINFO)
DllStructSetData($tICONINFO, 1, $bIcon)
DllStructSetData($tICONINFO, 2, $iXHotspot)
DllStructSetData($tICONINFO, 3, $iYHotspot)
DllStructSetData($tICONINFO, 4, $hMask)
DllStructSetData($tICONINFO, 5, $hBitmap)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIconIndirect', 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateNullRgn()
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateRectRgn', 'int', 0, 'int', 0, 'int', 0, 'int', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreatePolygonRgn(Const ByRef $aPoint, $iStart = 0, $iEnd = -1, $iMode = 1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, 0)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'int[2];'
Next
Local $tData = DllStructCreate($tagStruct)
Local $iCount = 1
For $i = $iStart To $iEnd
For $j = 0 To 1
DllStructSetData($tData, $iCount, $aPoint[$i][$j], $j + 1)
Next
$iCount += 1
Next
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreatePolygonRgn', 'struct*', $tData, 'int', $iCount - 1, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateRectRgnIndirect($tRECT)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateRectRgnIndirect', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateTransform($nM11 = 1, $nM12 = 0, $nM21 = 0, $nM22 = 1, $nDX = 0, $nDY = 0)
Local $tXFORM = DllStructCreate($tagXFORM)
DllStructSetData($tXFORM, 1, $nM11)
DllStructSetData($tXFORM, 2, $nM12)
DllStructSetData($tXFORM, 3, $nM21)
DllStructSetData($tXFORM, 4, $nM22)
DllStructSetData($tXFORM, 5, $nDX)
DllStructSetData($tXFORM, 6, $nDY)
Return $tXFORM
EndFunc
Func _WinAPI_DeleteEnhMetaFile($hEmf)
Local $aRet = DllCall('gdi32.dll', 'bool', 'DeleteEnhMetaFile', 'handle', $hEmf)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DPtoLP($hDC, ByRef $tPOINT, $iCount = 1)
Local $aRet = DllCall('gdi32.dll', 'bool', 'DPtoLP', 'handle', $hDC, 'struct*', $tPOINT, 'int', $iCount)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DrawAnimatedRects($hWnd, $tRectFrom, $tRectTo)
Local $aRet = DllCall('user32.dll', 'bool', 'DrawAnimatedRects', 'hwnd', $hWnd, 'int', 3, 'struct*', $tRectFrom,  'struct*', $tRectTo)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DrawBitmap($hDC, $iX, $iY, $hBitmap, $iRop = 0x00CC0020)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
$aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', 0)
Local $_hDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $_hDC)
Local $hSrcDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hBitmap)
Local $hSrcSv = $aRet[0]
Local $iError = 0
$aRet = DllCall('gdi32.dll', 'int', 'BitBlt', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'int', DllStructGetData($tObj, 'bmWidth'), 'int', DllStructGetData($tObj, 'bmHeight'), 'hwnd', $hSrcDC, 'int', 0, 'int', 0, 'int', $iRop)
If @error Or Not $aRet[0] Then
$iError = @error + 1
EndIf
DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'handle', $_hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hSrcSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hSrcDC)
If $iError Then Return SetError(10, 0, 0)
Return 1
EndFunc
Func _WinAPI_DrawFocusRect($hDC, $tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'DrawFocusRect', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DrawShadowText($hDC, $sText, $iRGBText, $iRGBShadow, $iXOffset = 0, $iYOffset = 0, $tRECT = 0, $iFlags = 0)
Local $aRet
If Not IsDllStruct($tRECT) Then
$tRECT = DllStructCreate($tagRECT)
$aRet = DllCall('user32.dll', 'bool', 'GetClientRect', 'hwnd', _WinAPI_WindowFromDC($hDC), 'struct*', $tRECT)
If @error Then Return SetError(@error + 10, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
EndIf
$aRet = DllCall('comctl32.dll', 'int', 'DrawShadowText', 'handle', $hDC, 'wstr', $sText, 'uint', -1, 'struct*', $tRECT,  'dword', $iFlags, 'int', __RGB($iRGBText), 'int', __RGB($iRGBShadow), 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DwmDefWindowProc($hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('dwmapi.dll', 'bool', 'DwmDefWindowProc', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam, 'lresult*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[5]
EndFunc
Func _WinAPI_DwmEnableBlurBehindWindow($hWnd, $bEnable = True, $bTransition = False, $hRgn = 0)
Local $tBLURBEHIND = DllStructCreate('dword;bool;handle;bool')
Local $iFlags = 0
If $hRgn Then
$iFlags += 2
DllStructSetData($tBLURBEHIND, 3, $hRgn)
EndIf
DllStructSetData($tBLURBEHIND, 1, BitOR($iFlags, 0x05))
DllStructSetData($tBLURBEHIND, 2, $bEnable)
DllStructSetData($tBLURBEHIND, 4, $bTransition)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmEnableBlurBehindWindow', 'hwnd', $hWnd, 'struct*', $tBLURBEHIND)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmEnableComposition($bEnable)
If $bEnable Then $bEnable = 1
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmEnableComposition', 'uint', $bEnable)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmExtendFrameIntoClientArea($hWnd, $tMARGINS = 0)
If Not IsDllStruct($tMARGINS) Then
$tMARGINS = _WinAPI_CreateMargins(-1, -1, -1, -1)
EndIf
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmExtendFrameIntoClientArea', 'hwnd', $hWnd, 'struct*', $tMARGINS)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmGetColorizationColor()
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmGetColorizationColor', 'dword*', 0, 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return SetExtended($aRet[2], $aRet[1])
EndFunc
Func _WinAPI_DwmGetColorizationParameters()
Local $tDWMCP = DllStructCreate($tagDWM_COLORIZATION_PARAMETERS)
Local $aRet = DllCall('dwmapi.dll', 'uint', 127, 'struct*', $tDWMCP)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tDWMCP
EndFunc
Func _WinAPI_DwmGetWindowAttribute($hWnd, $iAttribute)
Local $tagStruct
Switch $iAttribute
Case 5, 9
$tagStruct = $tagRECT
Case 1
$tagStruct = 'uint'
Case Else
Return SetError(11, 0, 0)
EndSwitch
Local $tData = DllStructCreate($tagStruct)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmGetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute,  'struct*', $tData, 'dword', DllStructGetSize($tData))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Switch $iAttribute
Case 1
Return DllStructGetData($tData, 1)
Case Else
Return $tData
EndSwitch
EndFunc
Func _WinAPI_DwmInvalidateIconicBitmaps($hWnd)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmInvalidateIconicBitmaps', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmIsCompositionEnabled()
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmIsCompositionEnabled', 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[1]
EndFunc
Func _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmQueryThumbnailSourceSize', 'handle', $hThumbnail, 'struct*', $tSIZE)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tSIZE
EndFunc
Func _WinAPI_DwmRegisterThumbnail($hDestination, $hSource)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmRegisterThumbnail', 'hwnd', $hDestination, 'hwnd', $hSource, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[3]
EndFunc
Func _WinAPI_DwmSetColorizationParameters($tDWMCP)
Local $aRet = DllCall('dwmapi.dll', 'uint', 131, 'struct*', $tDWMCP, 'uint', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetIconicLivePreviewBitmap($hWnd, $hBitmap, $bFrame = False, $tClient = 0)
Local $iFlags
If $bFrame Then
$iFlags = 0x00000001
Else
$iFlags = 0
EndIf
Local $aRet = DllCall('dwmapi.dll', 'uint', 'DwmSetIconicLivePreviewBitmap', 'hwnd', $hWnd, 'handle', $hBitmap,  'struct*', $tClient, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetIconicThumbnail($hWnd, $hBitmap, $bFrame = False)
Local $iFlags
If $bFrame Then
$iFlags = 0x00000001
Else
$iFlags = 0
EndIf
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmSetIconicThumbnail', 'hwnd', $hWnd, 'handle', $hBitmap, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetWindowAttribute($hWnd, $iAttribute, $iData)
Switch $iAttribute
Case 2, 3, 4, 6, 7, 8, 10, 11, 12
Case Else
Return SetError(1, 0, 0)
EndSwitch
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmSetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute,  'dword*', $iData, 'dword', 4)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUnregisterThumbnail($hThumbnail)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUnregisterThumbnail', 'handle', $hThumbnail)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUpdateThumbnailProperties($hThumbnail, $bVisible = True, $bClientAreaOnly = False, $iOpacity = 255, $tRectDest = 0, $tRectSrc = 0)
Local Const $tagDWM_THUMBNAIL_PROPERTIES = 'struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct'
Local $tTHUMBNAILPROPERTIES = DllStructCreate($tagDWM_THUMBNAIL_PROPERTIES)
Local $tSIZE, $iFlags = 0
If Not IsDllStruct($tRectDest) Then
$tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
If @error Then
Return SetError(@error + 10, @extended, 0)
EndIf
$tRectDest = _WinAPI_CreateRectEx(0, 0, DllStructGetData($tSIZE, 1), DllStructGetData($tSIZE, 2))
EndIf
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 2, DllStructGetData($tRectDest, $i), $i)
Next
If IsDllStruct($tRectSrc) Then
$iFlags += 2
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 3, DllStructGetData($tRectSrc, $i), $i)
Next
EndIf
DllStructSetData($tTHUMBNAILPROPERTIES, 1, BitOR($iFlags, 0x1D))
DllStructSetData($tTHUMBNAILPROPERTIES, 4, $iOpacity)
DllStructSetData($tTHUMBNAILPROPERTIES, 5, $bVisible)
DllStructSetData($tTHUMBNAILPROPERTIES, 6, $bClientAreaOnly)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUpdateThumbnailProperties', 'handle', $hThumbnail,  'struct*', $tTHUMBNAILPROPERTIES)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_Ellipse($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'Ellipse', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EndPaint($hWnd, ByRef $tPAINTSTRUCT)
Local $aRet = DllCall('user32.dll', 'bool', 'EndPaint', 'hwnd', $hWnd, 'struct*', $tPAINTSTRUCT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EndPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'EndPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumDisplayMonitors($hDC = 0, $tRECT = 0)
Local $hEnumProc = DllCallbackRegister('__EnumDisplayMonitorsProc', 'bool', 'handle;handle;ptr;lparam')
Dim $__g_vEnum[101][2] = [[0]]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDisplayMonitors', 'handle', $hDC, 'struct*', $tRECT,  'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumDisplaySettings($sDevice, $iMode)
Local $sTypeOfDevice = 'wstr'
If Not StringStripWS($sDevice, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfDevice = 'ptr'
$sDevice = 0
EndIf
Local $tDEVMODE = DllStructCreate($tagDEVMODE_DISPLAY)
DllStructSetData($tDEVMODE, 'Size', DllStructGetSize($tDEVMODE))
DllStructSetData($tDEVMODE, 'DriverExtra', 0)
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDisplaySettingsW', $sTypeOfDevice, $sDevice, 'dword', $iMode,  'struct*', $tDEVMODE)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[5]
$aResult[0] = DllStructGetData($tDEVMODE, 'PelsWidth')
$aResult[1] = DllStructGetData($tDEVMODE, 'PelsHeight')
$aResult[2] = DllStructGetData($tDEVMODE, 'BitsPerPel')
$aResult[3] = DllStructGetData($tDEVMODE, 'DisplayFrequency')
$aResult[4] = DllStructGetData($tDEVMODE, 'DisplayFlags')
Return $aResult
EndFunc
Func _WinAPI_EnumFontFamilies($hDC = 0, $sFaceName = '', $iCharSet = 1, $iFontType = 0x07, $sPattern = '', $bExclude = False)
Local $tLOGFONT = DllStructCreate($tagLOGFONT)
Local $tPattern = DllStructCreate('uint;uint;ptr;wchar[' & (StringLen($sPattern) + 1) & ']')
DllStructSetData($tPattern, 1, $iFontType)
If Not $sPattern Then
DllStructSetData($tPattern, 2, 0)
DllStructSetData($tPattern, 3, 0)
Else
DllStructSetData($tPattern, 2, $bExclude)
DllStructSetData($tPattern, 3, DllStructGetPtr($tPattern, 4))
DllStructSetData($tPattern, 4, $sPattern)
EndIf
DllStructSetData($tLOGFONT, 9, $iCharSet)
DllStructSetData($tLOGFONT, 13, 0)
DllStructSetData($tLOGFONT, 14, StringLeft($sFaceName, 31))
Local $hCDC
If Not $hDC Then
$hCDC = _WinAPI_CreateCompatibleDC(0)
Else
$hCDC = $hDC
EndIf
Dim $__g_vEnum[101][8] = [[0]]
Local $hEnumProc = DllCallbackRegister('__EnumFontFamiliesProc', 'int', 'ptr;ptr;dword;PTR')
Local $aRet = DllCall('gdi32.dll', 'int', 'EnumFontFamiliesExW', 'handle', $hCDC, 'struct*', $tLOGFONT,  'ptr', DllCallbackGetPtr($hEnumProc), 'struct*', $tPattern, 'dword', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If Not $hDC Then
_WinAPI_DeleteDC($hCDC)
EndIf
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EqualRect($tRECT1, $tRECT2)
Local $aRet = DllCall('user32.dll', 'bool', 'EqualRect', 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EqualRgn($hRgn1, $hRgn2)
Local $aRet = DllCall('gdi32.dll', 'bool', 'EqualRgn', 'handle', $hRgn1, 'handle', $hRgn2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ExcludeClipRect($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'ExcludeClipRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtCreatePen($iPenStyle, $iWidth, $iBrushStyle, $iRGB, $iHatch = 0, $aUserStyle = 0, $iStart = 0, $iEnd = -1)
Local $iCount = 0, $tStyle = 0
If BitAND($iPenStyle, 0xFF) = 7 Then
If __CheckErrorArrayBounds($aUserStyle, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$tStyle = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
For $i = $iStart To $iEnd
DllStructSetData($tStyle, 1, $aUserStyle[$i], $iCount + 1)
$iCount += 1
Next
EndIf
Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)
DllStructSetData($tLOGBRUSH, 1, $iBrushStyle)
DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
DllStructSetData($tLOGBRUSH, 3, $iHatch)
Local $aRet = DllCall('gdi32.dll', 'handle', 'ExtCreatePen', 'dword', $iPenStyle, 'dword', $iWidth, 'struct*', $tLOGBRUSH,  'dword', $iCount, 'struct*', $tStyle)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtCreateRegion($tRGNDATA, $tXFORM = 0)
Local $aRet = DllCall('gdi32.dll', 'handle', 'ExtCreateRegion', 'struct*', $tXFORM, 'dword', DllStructGetSize($tRGNDATA),  'struct*', $tRGNDATA)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtFloodFill($hDC, $iX, $iY, $iRGB, $iType = 0)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ExtFloodFill', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB),  'uint', $iType)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtSelectClipRgn($hDC, $hRgn, $iMode = 5)
Local $aRet = DllCall('gdi32.dll', 'int', 'ExtSelectClipRgn', 'handle', $hDC, 'handle', $hRgn, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FillPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FillPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FillRgn($hDC, $hRgn, $hBrush)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FillRgn', 'handle', $hDC, 'handle', $hRgn, 'handle', $hBrush)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FlattenPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FlattenPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FrameRgn($hDC, $hRgn, $hBrush, $iWidth, $iHeight)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FrameRgn', 'handle', $hDC, 'handle', $hRgn, 'handle', $hBrush, 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GdiComment($hDC, $pBuffer, $iSize)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiComment', 'handle', $hDC, 'uint', $iSize, 'struct*', $pBuffer)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GetArcDirection($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetArcDirection', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
If ($aRet[0] < 1) Or ($aRet[0] > 2) Then Return SetError(10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetBitmapBits($hBitmap, $iSize, $pBits)
Local $aRet = DllCall('gdi32.dll', 'long', 'GetBitmapBits', 'handle', $hBitmap, 'long', $iSize, 'struct*', $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetBitmapDimensionEx($hBitmap)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetBitmapDimensionEx', 'handle', $hBitmap, 'struct*', $tSIZE)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetBkColor($hDC)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetBkColor', 'handle', $hDC)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetBoundsRect($hDC, $iFlags = 0)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetBoundsRect', 'handle', $hDC, 'struct*', $tRECT, 'uint', $iFlags)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended($aRet[0], $tRECT)
EndFunc
Func _WinAPI_GetBrushOrg($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetBrushOrgEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetBValue($iRGB)
Return BitShift(BitAND(__RGB($iRGB), 0xFF0000), 16)
EndFunc
Func _WinAPI_GetClipBox($hDC, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetClipBox', 'handle', $hDC, 'struct*', $tRECT)
If @error Or Not $aRet[0] Then
$tRECT = 0
Return SetError(@error, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_GetClipRgn($hDC)
Local $hRgn = _WinAPI_CreateRectRgn(0, 0, 0, 0)
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'int', 'GetClipRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Or ($aRet[0] = -1) Then $iError = @error + 10
If $iError Or Not $aRet[0] Then
_WinAPI_DeleteObject($hRgn)
$hRgn = 0
EndIf
Return SetError($iError, 0, $hRgn)
EndFunc
Func _WinAPI_GetColorAdjustment($hDC)
Local $tAdjustment = DllStructCreate($tagCOLORADJUSTMENT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetColorAdjustment', 'handle', $hDC, 'struct*', $tAdjustment)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tAdjustment
EndFunc
Func _WinAPI_GetCurrentObject($hDC, $iType)
Local $aRet = DllCall('gdi32.dll', 'handle', 'GetCurrentObject', 'handle', $hDC, 'uint', $iType)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCurrentPosition($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetCurrentPositionEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetDCEx($hWnd, $hRgn, $iFlags)
Local $aRet = DllCall('user32.dll', 'handle', 'GetDCEx', 'hwnd', $hWnd, 'handle', $hRgn, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetDeviceGammaRamp($hDC, ByRef $aRamp)
$aRamp = 0
Local $tData = DllStructCreate('word[256];word[256];word[256]')
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetDeviceGammaRamp', 'handle', $hDC, 'struct*', $tData)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Dim $aRamp[256][3]
For $i = 0 To 2
For $j = 0 To 255
$aRamp[$j][$i] = DllStructGetData($tData, $i + 1, $j + 1)
Next
Next
Return 1
EndFunc
Func _WinAPI_GetDIBColorTable($hBitmap)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
Local $tPeak = DllStructCreate('dword[256]')
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetDIBColorTable', 'handle', $hDC, 'uint', 0, 'uint', 256, 'struct*', $tPeak)
If @error Or Not $aRet[0] Then $iError = @error + 10
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
If $iError Then Return SetError($iError, 0, 0)
Local $tData = DllStructCreate('dword[' & $aRet[0] & ']')
If @error Then Return SetError(@error + 20, @extended, 0)
_WinAPI_MoveMemory($tData, $aRet[4], 4 * $aRet[0])
Return SetExtended($aRet[0], $tData)
EndFunc
Func _WinAPI_GetEnhMetaFile($sFilePath)
Local $aRet = DllCall('gdi32.dll', 'handle', 'GetEnhMetaFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetEnhMetaFileBits($hEmf, ByRef $pBuffer)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'handle', $hEmf, 'uint', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 50, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aRet[0], 1)
If @error Then Return SetError(@error, @extended, 0)
$aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'handle', $hEmf, 'uint', $aRet[0], 'ptr', $pBuffer)
If Not $aRet[0] Then Return SetError(60, 0, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetEnhMetaFileDescription($hEmf)
Local $tData = DllStructCreate('wchar[4096]')
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileDescriptionW', 'handle', $hEmf, 'uint', 4096, 'struct*', $tData)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error + 20, $aRet[0], 0)
If Not $aRet[0] Then Return 0
Local $aData = _WinAPI_StructToArray($tData)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult[2]
For $i = 0 To 1
If $aData[0] > $i Then
$aResult[$i] = $aData[$i + 1]
Else
$aResult[$i] = ''
EndIf
Next
Return $aResult
EndFunc
Func _WinAPI_GetEnhMetaFileDimension($hEmf)
Local $tENHMETAHEADER = _WinAPI_GetEnhMetaFileHeader($hEmf)
If @error Then Return SetError(@error, @extended, 0)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 3) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 1)) * DllStructGetData($tENHMETAHEADER, 'Device', 1) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 1) / 100))
DllStructSetData($tSIZE, 2, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 4) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 2)) * DllStructGetData($tENHMETAHEADER, 'Device', 2) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 2) / 100))
Return $tSIZE
EndFunc
Func _WinAPI_GetEnhMetaFileHeader($hEmf)
Local $tENHMETAHEADER = DllStructCreate($tagENHMETAHEADER)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileHeader', 'handle', $hEmf,  'uint', DllStructGetSize($tENHMETAHEADER), 'struct*', $tENHMETAHEADER)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended($aRet[0], $tENHMETAHEADER)
EndFunc
Func _WinAPI_GetFontName($sFaceName, $iStyle = 0, $iCharSet = 1)
If Not $sFaceName Then Return SetError(1, 0, '')
Local $iFlags = 0
If BitAND($iStyle, 0x01) Then
$iFlags += 0x00000020
EndIf
If BitAND($iStyle, 0x02) Then
$iFlags += 0x00000001
EndIf
If Not $iFlags Then
$iFlags = 0x00000040
EndIf
Local $tLOGFONT = DllStructCreate($tagLOGFONT)
DllStructSetData($tLOGFONT, 9, $iCharSet)
DllStructSetData($tLOGFONT, 13, 0)
DllStructSetData($tLOGFONT, 14, StringLeft($sFaceName, 31))
Local $tFN = DllStructCreate('dword;wchar[64]')
DllStructSetData($tFN, 1, $iFlags)
DllStructSetData($tFN, 2, '')
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hEnumProc = DllCallbackRegister('__EnumFontStylesProc', 'int', 'ptr;ptr;dword;lparam')
Local $sRet = ''
Local $aRet = DllCall('gdi32.dll', 'int', 'EnumFontFamiliesExW', 'handle', $hDC, 'struct*', $tLOGFONT,  'ptr', DllCallbackGetPtr($hEnumProc), 'struct*', $tFN, 'dword', 0)
If Not @error And Not $aRet[0] Then $sRet = DllStructGetData($tFN, 2)
DllCallbackFree($hEnumProc)
_WinAPI_DeleteDC($hDC)
If Not $sRet Then Return SetError(2, 0, '')
Return $sRet
EndFunc
Func _WinAPI_GetFontResourceInfo($sFont, $bForce = False, $iFlag = Default)
If $iFlag = Default Then
If $bForce Then
If Not _WinAPI_AddFontResourceEx($sFont, $FR_NOT_ENUM) Then Return SetError(@error + 20, @extended, '')
EndIf
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetFontResourceInfoW', 'wstr', $sFont, 'dword*', 4096, 'wstr', '', 'dword', 0x01)
If @error Or Not $aRet[0] Then $iError = @error + 10
If $bForce Then
_WinAPI_RemoveFontResourceEx($sFont, $FR_NOT_ENUM)
EndIf
If $iError Then Return SetError($iError, 0, '')
Return $aRet[3]
Else
If Not FileExists($sFont) Then
$sFont = RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Fonts") & "\" & $sFont
If Not FileExists($sFont) Then Return SetError(31, 0, "")
EndIf
Local Const $hFile = _WinAPI_CreateFile($sFont, 2, 2, 2)
If Not $hFile Then Return SetError(32, _WinAPI_GetLastError(), "")
Local Const $iFile = FileGetSize($sFont)
Local Const $tBuffer = DllStructCreate("byte[" & $iFile + 1 & "]")
Local Const $pFile = DllStructGetPtr($tBuffer)
Local $iRead
_WinAPI_ReadFile($hFile, $pFile, $iFile, $iRead)
_WinAPI_CloseHandle($hFile)
Local $sTTFName = _WinAPI_GetFontMemoryResourceInfo($pFile, $iFlag)
If @error Then
If @error = 1 And $iFlag = 4 Then
$sTTFName = _WinAPI_GetFontResourceInfo($sFont, True)
Return SetError(@error, @extended, $sTTFName)
EndIf
Return SetError(33, @error, "")
EndIf
Return $sTTFName
EndIf
EndFunc
Func _WinAPI_GetFontMemoryResourceInfo($pMemory, $iFlag = 1)
Local Const $tagTT_OFFSET_TABLE = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
Local Const $tagTT_TABLE_DIRECTORY = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
Local Const $tagTT_NAME_TABLE_HEADER = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
Local Const $tagTT_NAME_RECORD = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
Local $tTTOffsetTable = DllStructCreate($tagTT_OFFSET_TABLE, $pMemory)
Local $iNumOfTables = _WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uNumOfTables"))
If Not (_WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uMajorVersion")) = 1 And _WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uMinorVersion")) = 0) Then Return SetError(1, 0, "")
Local $iTblDirSize = DllStructGetSize(DllStructCreate($tagTT_TABLE_DIRECTORY))
Local $bFound = False, $iOffset, $tTblDir
For $i = 0 To $iNumOfTables - 1
$tTblDir = DllStructCreate($tagTT_TABLE_DIRECTORY, $pMemory + DllStructGetSize($tTTOffsetTable) + $i * $iTblDirSize)
If StringLeft(DllStructGetData($tTblDir, "szTag"), 4) = "name" Then
$bFound = True
$iOffset = _WinAPI_SwapDWord(DllStructGetData($tTblDir, "uOffset"))
ExitLoop
EndIf
Next
If Not $bFound Then Return SetError(2, 0, "")
Local $tNTHeader = DllStructCreate($tagTT_NAME_TABLE_HEADER, $pMemory + $iOffset)
Local $iNTHeaderSize = DllStructGetSize($tNTHeader)
Local $iNRCount = _WinAPI_SwapWord(DllStructGetData($tNTHeader, "uNRCount"))
Local $iStorageOffset = _WinAPI_SwapWord(DllStructGetData($tNTHeader, "uStorageOffset"))
Local $iTTRecordSize = DllStructGetSize(DllStructCreate($tagTT_NAME_RECORD))
Local $tResult, $sResult, $iStringLength, $iStringOffset, $iEncodingID, $tTTRecord
For $i = 0 To $iNRCount - 1
$tTTRecord = DllStructCreate($tagTT_NAME_RECORD, $pMemory + $iOffset + $iNTHeaderSize + $i * $iTTRecordSize)
If _WinAPI_SwapWord($tTTRecord.uNameID) = $iFlag Then
$iStringLength = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uStringLength"))
$iStringOffset = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uStringOffset"))
$iEncodingID = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uEncodingID"))
Local $sWchar = "char"
If $iEncodingID = 1 Then
$sWchar = "word"
$iStringLength = $iStringLength / 2
EndIf
$tResult = DllStructCreate($sWchar & " szTTFName[" & $iStringLength & "]", $pMemory + $iOffset + $iStringOffset + $iStorageOffset)
If $iEncodingID = 1 Then
$sResult = ""
For $j = 1 To $iStringLength
$sResult &= ChrW(_WinAPI_SwapWord(DllStructGetData($tResult, 1, $j)))
Next
Else
$sResult = $tResult.szTTFName
EndIf
If StringLen($sResult) > 0 Then ExitLoop
EndIf
Next
Return $sResult
EndFunc
Func _WinAPI_GetGlyphOutline($hDC, $sChar, $iFormat, ByRef $pBuffer, $tMAT2 = 0)
Local $tGM = DllStructCreate($tagGLYPHMETRICS)
Local $aRet, $iLength = 0
If Not IsDllStruct($tMAT2) Then
$tMAT2 = DllStructCreate('short[8]')
DllStructSetData($tMAT2, 1, 1, 2)
DllStructSetData($tMAT2, 1, 1, 8)
EndIf
If $iFormat Then
$aRet = DllCall('gdi32.dll', 'dword', 'GetGlyphOutlineW', 'handle', $hDC, 'uint', AscW($sChar), 'uint', $iFormat,  'struct*', $tGM, 'dword', 0, 'ptr', 0, 'struct*', $tMAT2)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error + 10, @extended, 0)
$iLength = $aRet[0]
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 1)
If @error Then Return SetError(@error + 20, @extended, 0)
EndIf
$aRet = DllCall('gdi32.dll', 'dword', 'GetGlyphOutlineW', 'handle', $hDC, 'uint', AscW($sChar), 'uint', $iFormat,  'struct*', $tGM, 'dword', $iLength, 'ptr', $pBuffer, 'struct*', $tMAT2)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return SetExtended($iLength, $tGM)
EndFunc
Func _WinAPI_GetGraphicsMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetGraphicsMode', 'handle', $hDC)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetGValue($iRGB)
Return BitShift(BitAND(__RGB($iRGB), 0x00FF00), 8)
EndFunc
Func _WinAPI_GetIconDimension($hIcon)
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $tSIZE = _WinAPI_GetBitmapDimension(DllStructGetData($tICONINFO, 5))
For $i = 4 To 5
_WinAPI_DeleteObject(DllStructGetData($tICONINFO, $i))
Next
If Not IsDllStruct($tSIZE) Then Return SetError(20, 0, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetMapMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetMapMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetObjectType($hObject)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetObjectType', 'handle', $hObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetOutlineTextMetrics($hDC)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'handle', $hDC, 'uint', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $tData = DllStructCreate('byte[' & $aRet[0] & ']')
Local $tOLTM = DllStructCreate($tagOUTLINETEXTMETRIC, DllStructGetPtr($tData))
$aRet = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'handle', $hDC, 'uint', $aRet[0], 'struct*', $tData)
If Not $aRet[0] Then Return SetError(20, 0, 0)
Return $tOLTM
EndFunc
Func _WinAPI_GetPixel($hDC, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetPixel', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetPolyFillMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetPolyFillMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetPosFromRect($tRECT)
Local $aResult[4]
For $i = 0 To 3
$aResult[$i] = DllStructGetData($tRECT, $i + 1)
If @error Then Return SetError(@error, @extended, 0)
Next
For $i = 2 To 3
$aResult[$i] -= $aResult[$i - 2]
Next
Return $aResult
EndFunc
Func _WinAPI_GetRegionData($hRgn, ByRef $tRGNDATA)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'handle', $hRgn, 'dword', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then
$tRGNDATA = 0
Return SetError(@error, @extended, False)
EndIf
$tRGNDATA = DllStructCreate($tagRGNDATAHEADER)
Local $iRectSize = $aRet[0] - DllStructGetSize($tRGNDATA)
If $iRectSize > 0 Then $tRGNDATA = DllStructCreate($tagRGNDATAHEADER & ';byte[' & $iRectSize & ']')
$aRet = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'handle', $hRgn, 'dword', $aRet[0], 'struct*', $tRGNDATA)
If Not $aRet[0] Then $tRGNDATA = 0
Return $aRet[0]
EndFunc
Func _WinAPI_GetRgnBox($hRgn, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetRgnBox', 'handle', $hRgn, 'struct*', $tRECT)
If @error Or Not $aRet[0] Then
$tRECT = 0
Return SetError(@error, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_GetROP2($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetROP2', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetRValue($iRGB)
Return BitAND(__RGB($iRGB), 0x0000FF)
EndFunc
Func _WinAPI_GetStretchBltMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetStretchBltMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTabbedTextExtent($hDC, $sText, $aTab = 0, $iStart = 0, $iEnd = -1)
Local $iTab, $iCount
If Not IsArray($aTab) Then
If $aTab Then
$iTab = $aTab
Dim $aTab[1] = [$iTab]
$iStart = 0
$iEnd = 0
$iCount = 1
Else
$iCount = 0
EndIf
Else
$iCount = 1
EndIf
Local $tTab = 0
If $iCount Then
If __CheckErrorArrayBounds($aTab, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
$tTab = DllStructCreate('uint[' & $iCount & ']')
$iTab = 1
For $i = $iStart To $iEnd
DllStructSetData($tTab, 1, $aTab[$i], $iTab)
$iTab += 1
Next
EndIf
Local $aRet = DllCall('user32.dll', 'dword', 'GetTabbedTextExtentW', 'handle', $hDC, 'wstr', $sText, 'int', StringLen($sText), 'int', $iCount, 'struct*', $tTab)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
Return _WinAPI_CreateSize(_WinAPI_LoWord($aRet[0]), _WinAPI_HiWord($aRet[0]))
EndFunc
Func _WinAPI_GetTextAlign($hDC)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetTextAlign', 'handle', $hDC)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTextCharacterExtra($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetTextCharacterExtra', 'handle', $hDC)
If @error Or ($aRet[0] = 0x8000000) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTextColor($hDC)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetTextColor', 'handle', $hDC)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetTextFace($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetTextFaceW', 'handle', $hDC, 'int', 2048, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetUDFColorMode()
Return Number($__g_iRGBMode)
EndFunc
Func _WinAPI_GetUpdateRect($hWnd, $bErase = True)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'GetUpdateRect', 'hwnd', $hWnd, 'struct*', $tRECT, 'bool', $bErase)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetUpdateRgn($hWnd, $hRgn, $bErase = True)
Local $aRet = DllCall('user32.dll', 'int', 'GetUpdateRgn', 'hwnd', $hWnd, 'handle', $hRgn, 'bool', $bErase)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWindowExt($hDC)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetWindowExtEx', 'handle', $hDC, 'struct*', $tSIZE)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetWindowOrg($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetWindowOrgEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetWindowRgnBox($hWnd, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetWindowRgnBox', 'hwnd', $hWnd, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWorldTransform($hDC)
Local $tXFORM = DllStructCreate($tagXFORM)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetWorldTransform', 'handle', $hDC, 'struct*', $tXFORM)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tXFORM
EndFunc
Func _WinAPI_GradientFill($hDC, Const ByRef $aVertex, $iStart = 0, $iEnd = -1, $bRotate = False)
If __CheckErrorArrayBounds($aVertex, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aVertex, $UBOUND_COLUMNS) < 3 Then Return SetError(13, 0, 0)
Local $iPoint = $iEnd - $iStart + 1
If $iPoint > 3 Then
$iEnd = $iStart + 2
$iPoint = 3
EndIf
Local $iMode
Switch $iPoint
Case 2
$iMode = Number(Not $bRotate)
Case 3
$iMode = 2
Case Else
Return SetError(15, 0, 0)
EndSwitch
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'ushort[8];'
Next
Local $tVertex = DllStructCreate($tagStruct)
Local $iCount = 1
Local $tGradient = DllStructCreate('ulong[' & $iPoint & ']')
For $i = $iStart To $iEnd
DllStructSetData($tGradient, 1, $iCount - 1, $iCount)
DllStructSetData($tVertex, $iCount, _WinAPI_LoWord($aVertex[$i][0]), 1)
DllStructSetData($tVertex, $iCount, _WinAPI_HiWord($aVertex[$i][0]), 2)
DllStructSetData($tVertex, $iCount, _WinAPI_LoWord($aVertex[$i][1]), 3)
DllStructSetData($tVertex, $iCount, _WinAPI_HiWord($aVertex[$i][1]), 4)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetRValue($aVertex[$i][2]), -8), 5)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetGValue($aVertex[$i][2]), -8), 6)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetBValue($aVertex[$i][2]), -8), 7)
DllStructSetData($tVertex, $iCount, 0, 8)
$iCount += 1
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiGradientFill', 'handle', $hDC, 'struct*', $tVertex, 'ulong', $iPoint,  'struct*', $tGradient, 'ulong', 1, 'ulong', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_InflateRect(ByRef $tRECT, $iDX, $iDY)
Local $aRet = DllCall('user32.dll', 'bool', 'InflateRect', 'struct*', $tRECT, 'int', $iDX, 'int', $iDY)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IntersectClipRect($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'IntersectClipRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3),  'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_IntersectRect($tRECT1, $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'IntersectRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_InvalidateRgn($hWnd, $hRgn = 0, $bErase = True)
Local $aRet = DllCall('user32.dll', 'bool', 'InvalidateRgn', 'hwnd', $hWnd, 'handle', $hRgn, 'bool', $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_InvertANDBitmap($hBitmap, $bDelete = False)
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tBITMAP), $tBITMAP) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 1) Then
Return SetError(@error + 10, @extended, 0)
EndIf
Local $hResult = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), 1)
If Not $hResult Then Return SetError(@error, @extended, 0)
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv = _WinAPI_SelectObject($hSrcDC, $hBitmap)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstSv = _WinAPI_SelectObject($hDstDC, $hResult)
_WinAPI_BitBlt($hDstDC, 0, 0, DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), $hSrcDC, 0, 0, 0x00330008)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_SelectObject($hDstDC, $hDstSv)
_WinAPI_DeleteDC($hDstDC)
If $bDelete Then
_WinAPI_DeleteObject($hBitmap)
EndIf
Return $hResult
EndFunc
Func _WinAPI_InvertColor($iColor)
If $iColor = -1 Then Return 0
Return 0xFFFFFF - BitAND($iColor, 0xFFFFFF)
EndFunc
Func _WinAPI_InvertRect($hDC, ByRef $tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'InvertRect', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_InvertRgn($hDC, $hRgn)
Local $aRet = DllCall('gdi32.dll', 'bool', 'InvertRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsAlphaBitmap($hBitmap)
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Local $aRet, $iError = 0
Do
Local $tDIB = DllStructCreate($tagDIBSECTION)
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or (DllStructGetData($tDIB, 'bmBitsPixel') <> 32) Or (DllStructGetData($tDIB, 'biCompression')) Then
$iError = 1
ExitLoop
EndIf
$aRet = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __AlphaProc(), 'ptr', 0, 'uint', 0, 'struct*', $tDIB, 'ptr', 0)
If @error Or ($aRet[0] = -1) Then
$iError = @error + 10
ExitLoop
EndIf
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_IsRectEmpty(ByRef $tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'IsRectEmpty', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LineDDA($iX1, $iY1, $iX2, $iY2, $pLineProc, $pData = 0)
Local $aRet = DllCall('gdi32.dll', 'bool', 'LineDDA', 'int', $iX1, 'int', $iY1, 'int', $iX2, 'int', $iY2, 'ptr', $pLineProc,  'lparam', $pData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LockWindowUpdate($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'LockWindowUpdate', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LPtoDP($hDC, ByRef $tPOINT, $iCount = 1)
Local $aRet = DllCall('gdi32.dll', 'bool', 'LPtoDP', 'handle', $hDC, 'struct*', $tPOINT, 'int', $iCount)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MaskBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $hMask, $iXMask, $iYMask, $iRop)
Local $aRet = DllCall('gdi32.dll', 'bool', 'MaskBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidth, 'int', $iHeight, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'handle', $hMask,  'int', $iXMask, 'int', $iYMask, 'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ModifyWorldTransform($hDC, ByRef $tXFORM, $iMode)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ModifyWorldTransform', 'handle', $hDC, 'struct*', $tXFORM, 'dword', $iMode)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MonitorFromPoint(ByRef $tPOINT, $iFlag = 1)
If DllStructGetSize($tPOINT) <> 8 Then Return SetError(@error + 10, @extended, 0)
Local $aRet = DllCall('user32.dll', 'handle', 'MonitorFromPoint', 'struct', $tPOINT, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MonitorFromRect(ByRef $tRECT, $iFlag = 1)
Local $aRet = DllCall('user32.dll', 'ptr', 'MonitorFromRect', 'struct*', $tRECT, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MonitorFromWindow($hWnd, $iFlag = 1)
Local $aRet = DllCall('user32.dll', 'handle', 'MonitorFromWindow', 'hwnd', $hWnd, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MoveToEx($hDC, $iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'MoveToEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_OffsetClipRgn($hDC, $iXOffset, $iYOffset)
Local $aRet = DllCall('gdi32.dll', 'int', 'OffsetClipRgn', 'handle', $hDC, 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OffsetPoints(ByRef $aPoint, $iXOffset, $iYOffset, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 2 Then Return SetError(13, 0, 0)
For $i = $iStart To $iEnd
$aPoint[$i][0] += $iXOffset
$aPoint[$i][1] += $iYOffset
Next
Return 1
EndFunc
Func _WinAPI_OffsetRect(ByRef $tRECT, $iDX, $iDY)
Local $aRet = DllCall('user32.dll', 'bool', 'OffsetRect', 'struct*', $tRECT, 'int', $iDX, 'int', $iDY)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OffsetRgn($hRgn, $iXOffset, $iYOffset)
Local $aRet = DllCall('gdi32.dll', 'int', 'OffsetRgn', 'handle', $hRgn, 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OffsetWindowOrg($hDC, $iXOffset, $iYOffset)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'OffsetWindowOrgEx', 'handle', $hDC, 'int', $iXOffset, 'int', $iYOffset,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PaintDesktop($hDC)
Local $aRet = DllCall('user32.dll', 'bool', 'PaintDesktop', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PaintRgn($hDC, $hRgn)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PaintRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PatBlt($hDC, $iX, $iY, $iWidth, $iHeight, $iRop)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PatBlt', 'handle', $hDC, 'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight,  'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathToRegion($hDC)
Local $aRet = DllCall('gdi32.dll', 'handle', 'PathToRegion', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PlayEnhMetaFile($hDC, $hEmf, ByRef $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PlayEnhMetaFile', 'handle', $hDC, 'handle', $hEmf, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PlgBlt($hDestDC, Const ByRef $aPoint, $hSrcDC, $iXSrc, $iYSrc, $iWidth, $iHeight, $hMask = 0, $iXMask = 0, $iYMask = 0)
If (UBound($aPoint) < 3) Or (UBound($aPoint, $UBOUND_COLUMNS) < 2) Then Return SetError(12, 0, False)
Local $tPoints = DllStructCreate('long[2];long[2];long[2]')
For $i = 0 To 2
For $j = 0 To 1
DllStructSetData($tPoints, $i + 1, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PlgBlt', 'handle', $hDestDC, 'struct*', $tPoints, 'handle', $hSrcDC,  'int', $iXSrc, 'int', $iYSrc, 'int', $iWidth, 'int', $iHeight, 'handle', $hMask,  'int', $iXMask, 'int', $iYMask)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PolyBezier($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $iPoint = 1 + 3 * Floor(($iEnd - $iStart) / 3)
If $iPoint < 1 Then Return SetError(15, 0, False)
$iEnd = $iStart + $iPoint - 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PolyBezier', 'handle', $hDC, 'struct*', $tPOINT, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PolyBezierTo($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $iPoint = 3 * Floor(($iEnd - $iStart + 1) / 3)
If $iPoint < 3 Then Return SetError(15, 0, False)
$iEnd = $iStart + $iPoint - 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PolyBezierTo', 'handle', $hDC, 'struct*', $tPOINT, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PolyDraw($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 3 Then Return SetError(13, 0, False)
Local $iPoint = $iEnd - $iStart + 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $tTypes = DllStructCreate('byte[' & $iPoint & ']')
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
DllStructSetData($tTypes, 1, $aPoint[$i][2], $iCount)
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PolyDraw', 'handle', $hDC, 'struct*', $tPOINT, 'struct*', $tTypes, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Polygon($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'int[2];'
Next
Local $tData = DllStructCreate($tagStruct)
Local $iCount = 1
For $i = $iStart To $iEnd
For $j = 0 To 1
DllStructSetData($tData, $iCount, $aPoint[$i][$j], $j + 1)
Next
$iCount += 1
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'Polygon', 'handle', $hDC, 'struct*', $tData, 'int', $iCount - 1)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PrintWindow($hWnd, $hDC, $bClient = False)
Local $aRet = DllCall('user32.dll', 'bool', 'PrintWindow', 'hwnd', $hWnd, 'handle', $hDC, 'uint', $bClient)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRectEx($iX, $iY, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tPOINT = _WinAPI_CreatePoint($iX, $iY)
Local $aRet = DllCall('user32.dll', 'bool', 'PtInRect', 'struct*', $tRECT, 'struct', $tPOINT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRegion($hRgn, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PtInRegion', 'handle', $hRgn, 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PtVisible($hDC, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PtVisible', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aRet[0] = -1 Then Return SetError(10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RadialGradientFill($hDC, $iX, $iY, $iRadius, $iRGB1, $iRGB2, $fAngleStart = 0, $fAngleEnd = 360, $fStep = 5)
If Abs($fAngleStart) > 360 Then
$fAngleStart = Mod($fAngleStart, 360)
EndIf
If Abs($fAngleEnd) > 360 Then
$fAngleEnd = Mod($fAngleEnd, 360)
EndIf
If ($fAngleStart < 0) Or ($fAngleEnd < 0) Then
$fAngleStart += 360
$fAngleEnd += 360
EndIf
If $fAngleStart > $fAngleEnd Then
Local $fVal = $fAngleStart
$fAngleStart = $fAngleEnd
$fAngleEnd = $fVal
EndIf
If $fStep < 1 Then
$fStep = 1
EndIf
Local $fKi = ATan(1) / 45
Local $iXp = Round($iX + $iRadius * Cos($fKi * $fAngleStart))
Local $iYp = Round($iY + $iRadius * Sin($fKi * $fAngleStart))
Local $iXn, $iYn, $fAn = $fAngleStart
Local $aVertex[3][3]
While $fAn < $fAngleEnd
$fAn += $fStep
If $fAn > $fAngleEnd Then
$fAn = $fAngleEnd
EndIf
$iXn = Round($iX + $iRadius * Cos($fKi * $fAn))
$iYn = Round($iY + $iRadius * Sin($fKi * $fAn))
$aVertex[0][0] = $iX
$aVertex[0][1] = $iY
$aVertex[0][2] = $iRGB1
$aVertex[1][0] = $iXp
$aVertex[1][1] = $iYp
$aVertex[1][2] = $iRGB2
$aVertex[2][0] = $iXn
$aVertex[2][1] = $iYn
$aVertex[2][2] = $iRGB2
If Not _WinAPI_GradientFill($hDC, $aVertex, 0, 2) Then
Return SetError(@error, @extended, 0)
EndIf
$iXp = $iXn
$iYp = $iYn
WEnd
Return 1
EndFunc
Func _WinAPI_Rectangle($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'Rectangle', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RectInRegion($hRgn, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RectInRegion', 'handle', $hRgn, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RectVisible($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RectVisible', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Switch $aRet[0]
Case 0, 1, 2
Case Else
Return SetError(10, $aRet[0], 0)
EndSwitch
Return $aRet[0]
EndFunc
Func _WinAPI_RemoveFontMemResourceEx($hFont)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RemoveFontMemResourceEx', 'handle', $hFont)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RemoveFontResourceEx($sFont, $iFlag = 0, $bNotify = False)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RemoveFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
If $bNotify Then
Local Const $WM_FONTCHANGE = 0x001D
Local Const $HWND_BROADCAST = 0xFFFF
DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $HWND_BROADCAST, 'uint', $WM_FONTCHANGE, 'wparam', 0, 'lparam', 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_RestoreDC($hDC, $iID)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RestoreDC', 'handle', $hDC, 'int', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RGB($iRed, $iGreen, $iBlue)
Return __RGB(BitOR(BitShift($iBlue, -16), BitShift($iGreen, -8), $iRed))
EndFunc
Func _WinAPI_RotatePoints(ByRef $aPoint, $iXC, $iYC, $fAngle, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 2 Then Return SetError(13, 0, 0)
Local $fCos = Cos(ATan(1) / 45 * $fAngle)
Local $fSin = Sin(ATan(1) / 45 * $fAngle)
Local $iXn, $iYn
For $i = $iStart To $iEnd
$iXn = $aPoint[$i][0] - $iXC
$iYn = $aPoint[$i][1] - $iYC
$aPoint[$i][0] = $iXC + Round($iXn * $fCos - $iYn * $fSin)
$aPoint[$i][1] = $iYC + Round($iXn * $fSin + $iYn * $fCos)
Next
Return 1
EndFunc
Func _WinAPI_RoundRect($hDC, $tRECT, $iWidth, $iHeight)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RoundRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3),  'int', DllStructGetData($tRECT, 4), 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SaveDC($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'SaveDC', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SaveHBITMAPToFile($sFilePath, $hBitmap, $iXPelsPerMeter = Default, $iYPelsPerMeter = Default)
Local $tBMP = DllStructCreate('align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset')
Local $tDIB = DllStructCreate($tagDIBSECTION)
Local $hDC, $hSv, $hSource = 0
While $hBitmap
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or (DllStructGetData($tDIB, 'biCompression')) Then
$hBitmap = 0
Else
Switch DllStructGetData($tDIB, 'bmBitsPixel')
Case 32
If Not _WinAPI_IsAlphaBitmap($hBitmap) Then
If Not $hSource Then
$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'), 24)
If Not $hSource Then
$hBitmap = 0
EndIf
$hDC = _WinAPI_CreateCompatibleDC(0)
$hSv = _WinAPI_SelectObject($hDC, $hSource)
If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
$hBitmap = $hSource
Else
$hBitmap = 0
EndIf
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = 0
EndIf
ContinueLoop
EndIf
Case Else
EndSwitch
If (Not DllStructGetData($tDIB, 'bmBits')) Or (Not DllStructGetData($tDIB, 'biSizeImage')) Then
If Not $hSource Then
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
$hSource = $hBitmap
Else
$hBitmap = 0
EndIf
Else
ExitLoop
EndIf
EndIf
WEnd
Local $hFile = 0, $iError = 0, $iResult = 0
Do
If Not $hBitmap Then
$iError = 1
ExitLoop
EndIf
Local $aData[4][2]
$aData[0][0] = DllStructGetPtr($tBMP)
$aData[0][1] = DllStructGetSize($tBMP)
$aData[1][0] = DllStructGetPtr($tDIB, 'biSize')
$aData[1][1] = 40
$aData[2][1] = DllStructGetData($tDIB, 'biClrUsed') * 4
Local $tTable = 0
If $aData[2][1] Then
$tTable = _WinAPI_GetDIBColorTable($hBitmap)
If @error Or (@extended <> $aData[2][1] / 4) Then
$iError = @error + 10
ExitLoop
EndIf
EndIf
$aData[2][0] = DllStructGetPtr($tTable)
$aData[3][0] = DllStructGetData($tDIB, 'bmBits')
$aData[3][1] = DllStructGetData($tDIB, 'biSizeImage')
DllStructSetData($tBMP, 'bfType', 0x4D42)
DllStructSetData($tBMP, 'bfSize', $aData[0][1] + $aData[1][1] + $aData[2][1] + $aData[3][1])
DllStructSetData($tBMP, 'bfReserved1', 0)
DllStructSetData($tBMP, 'bfReserved2', 0)
DllStructSetData($tBMP, 'bfOffset', $aData[0][1] + $aData[1][1] + $aData[2][1])
$hDC = _WinAPI_GetDC(0)
If $iXPelsPerMeter = Default Then
If Not DllStructGetData($tDIB, 'biXPelsPerMeter') Then
DllStructSetData($tDIB, 'biXPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 8) / _WinAPI_GetDeviceCaps($hDC, 4) * 1000)
EndIf
Else
DllStructSetData($tDIB, 'biXPelsPerMeter', $iXPelsPerMeter)
EndIf
If $iYPelsPerMeter = Default Then
If Not DllStructGetData($tDIB, 'biYPelsPerMeter') Then
DllStructSetData($tDIB, 'biYPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 10) / _WinAPI_GetDeviceCaps($hDC, 6) * 1000)
EndIf
Else
DllStructSetData($tDIB, 'biYPelsPerMeter', $iYPelsPerMeter)
EndIf
_WinAPI_ReleaseDC(0, $hDC)
$hFile = _WinAPI_CreateFile($sFilePath, 1, 4)
If @error Then
$iError = @error + 20
ExitLoop
EndIf
Local $iBytes
For $i = 0 To 3
If $aData[$i][1] Then
If Not _WinAPI_WriteFile($hFile, $aData[$i][0], $aData[$i][1], $iBytes) Then
$iError = @error + 30
ExitLoop 2
EndIf
EndIf
Next
$iResult = 1
Until 1
If $hSource Then
_WinAPI_DeleteObject($hSource)
EndIf
_WinAPI_CloseHandle($hFile)
If Not $iResult Then
FileDelete($sFilePath)
EndIf
Return SetError($iError, 0, $iResult)
EndFunc
Func _WinAPI_SaveHICONToFile($sFilePath, Const ByRef $vIcon, $bCompress = 0, $iStart = 0, $iEnd = -1)
Local $aIcon, $aTemp, $iCount = 1
If Not IsArray($vIcon) Then
Dim $aIcon[1] = [$vIcon]
Dim $aTemp[1] = [0]
Else
If __CheckErrorArrayBounds($vIcon, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
If $iCount Then
Dim $aIcon[$iCount]
Dim $aTemp[$iCount]
For $i = 0 To $iCount - 1
$aIcon[$i] = $vIcon[$iStart + $i]
$aTemp[$i] = 0
Next
EndIf
EndIf
Local $hFile = _WinAPI_CreateFile($sFilePath, 1, 4)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tIco = DllStructCreate('align 1;ushort Reserved;ushort Type;ushort Count;byte Data[' & (16 * $iCount) & ']')
Local $iLength = DllStructGetSize($tIco)
Local $tBI = DllStructCreate($tagBITMAPINFOHEADER)
Local $tII = DllStructCreate($tagICONINFO)
Local $tDIB = DllStructCreate($tagDIBSECTION)
Local $iDIB = DllStructGetSize($tDIB)
Local $pDIB = DllStructGetPtr($tDIB)
Local $iOffset = $iLength
DllStructSetData($tBI, 'biSize', 40)
DllStructSetData($tBI, 'biPlanes', 1)
DllStructSetData($tBI, 'biXPelsPerMeter', 0)
DllStructSetData($tBI, 'biYPelsPerMeter', 0)
DllStructSetData($tBI, 'biClrUsed', 0)
DllStructSetData($tBI, 'biClrImportant', 0)
DllStructSetData($tIco, 'Reserved', 0)
DllStructSetData($tIco, 'Type', 1)
DllStructSetData($tIco, 'Count', $iCount)
Local $iResult = 0, $iError = 0
Do
Local $iBytes
If Not _WinAPI_WriteFile($hFile, $tIco, $iLength, $iBytes) Then
$iError = @error + 30
ExitLoop
EndIf
Local $aInfo[8], $aRet, $pData = 0, $iIndex = 0
While $iCount > $iIndex
$aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $aIcon[$iIndex], 'struct*', $tII)
If @error Or Not $aRet[0] Then
$iError = @error + 40
ExitLoop 2
EndIf
For $i = 4 To 5
$aInfo[$i] = _WinAPI_CopyImage(DllStructGetData($tII, $i), 0, 0, 0, 0x2008)
If _WinAPI_GetObject($aInfo[$i], $iDIB, $pDIB) Then
$aInfo[$i - 4] = DllStructGetData($tDIB, 'biSizeImage')
$aInfo[$i - 2] = DllStructGetData($tDIB, 'bmBits')
Else
$iError = @error + 50
EndIf
Next
$aInfo[6] = 40
$aInfo[7] = DllStructGetData($tDIB, 'bmBitsPixel')
Switch $aInfo[7]
Case 16, 24
Case 32
If Not _WinAPI_IsAlphaBitmap($aInfo[5]) Then
If Not $aTemp[$iIndex] Then
$aIcon[$iIndex] = _WinAPI_Create32BitHICON($aIcon[$iIndex])
$aTemp[$iIndex] = $aIcon[$iIndex]
If Not @error Then
ContinueLoop
Else
ContinueCase
EndIf
EndIf
Else
If ($aInfo[1] >= 256 * 256 * 4) And ($bCompress) Then
$iBytes = _WinAPI_CompressBitmapBits($aInfo[5], $pData)
If Not @error Then
$aInfo[0] = 0
$aInfo[1] = $iBytes
$aInfo[2] = 0
$aInfo[3] = $pData
$aInfo[6] = 0
EndIf
EndIf
EndIf
Case Else
$iError = 60
EndSwitch
If $iError Then
Else
Local $aSize[2]
Local $tData = DllStructCreate('byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset', DllStructGetPtr($tIco) + 6 + 16 * $iIndex)
DllStructSetData($tData, 'ColorCount', 0)
DllStructSetData($tData, 'Reserved', 0)
DllStructSetData($tData, 'Planes', 1)
DllStructSetData($tData, 'BitCount', $aInfo[7])
DllStructSetData($tData, 'Size', $aInfo[0] + $aInfo[1] + $aInfo[6])
DllStructSetData($tData, 'Offset', $iOffset)
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tDIB, $i + 2)
If $aSize[$i] < 256 Then
DllStructSetData($tData, $i + 1, $aSize[$i])
Else
DllStructSetData($tData, $i + 1, 0)
EndIf
Next
DllStructSetData($tBI, 'biWidth', $aSize[0])
DllStructSetData($tBI, 'biHeight', 2 * $aSize[1])
DllStructSetData($tBI, 'biBitCount', $aInfo[7])
DllStructSetData($tBI, 'biCompression', 0)
DllStructSetData($tBI, 'biSizeImage', $aInfo[0] + $aInfo[1])
$iOffset += $aInfo[0] + $aInfo[1] + $aInfo[6]
Do
If $aInfo[6] Then
If Not _WinAPI_WriteFile($hFile, $tBI, $aInfo[6], $iBytes) Then
$iError = @error + 70
ExitLoop
EndIf
For $i = 1 To 0 Step -1
If Not _WinAPI_WriteFile($hFile, $aInfo[$i + 2], $aInfo[$i], $iBytes) Then
$iError = @error + 80
ExitLoop 2
EndIf
Next
Else
If Not _WinAPI_WriteFile($hFile, $aInfo[3], $aInfo[1], $iBytes) Then
$iError = @error + 90
ExitLoop
EndIf
EndIf
Until 1
EndIf
For $i = 4 To 5
_WinAPI_DeleteObject($aInfo[$i])
Next
If $iError Then
ExitLoop 2
EndIf
$iIndex += 1
WEnd
$aRet = DllCall('kernel32.dll', 'bool', 'SetFilePointerEx', 'handle', $hFile, 'int64', 0, 'int64*', 0, 'dword', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 100
ExitLoop
EndIf
If Not _WinAPI_WriteFile($hFile, $tIco, $iLength, $iBytes) Then
$iError = @error + 110
ExitLoop
EndIf
$iResult = 1
Until 1
For $i = 0 To $iCount - 1
If $aTemp[$i] Then
_WinAPI_DestroyIcon($aTemp[$i])
EndIf
Next
If $pData Then
__HeapFree($pData)
EndIf
_WinAPI_CloseHandle($hFile)
If Not $iResult Then
FileDelete($sFilePath)
EndIf
Return SetError($iError, 0, $iResult)
EndFunc
Func _WinAPI_ScaleWindowExt($hDC, $iXNum, $iXDenom, $iYNum, $iYDenom)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ScaleWindowExtEx', 'handle', $hDC, 'int', $iXNum, 'int', $iXDenom, 'int', $iYNum,  'int', $iYDenom, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SelectClipPath($hDC, $iMode = 5)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SelectClipPath', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SelectClipRgn($hDC, $hRgn)
Local $aRet = DllCall('gdi32.dll', 'int', 'SelectClipRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetArcDirection($hDC, $iDirection)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetArcDirection', 'handle', $hDC, 'int', $iDirection)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBitmapBits($hBitmap, $iSize, $pBits)
Local $aRet = DllCall('gdi32.dll', 'long', 'SetBitmapBits', 'handle', $hBitmap, 'dword', $iSize, 'struct*', $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBitmapDimensionEx($hBitmap, $iWidth, $iHeight)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetBitmapDimensionEx', 'handle', $hBitmap, 'int', $iWidth, 'int', $iHeight,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBoundsRect($hDC, $iFlags, $tRECT = 0)
Local $aRet = DllCall('gdi32.dll', 'uint', 'SetBoundsRect', 'handle', $hDC, 'struct*', $tRECT, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBrushOrg($hDC, $iX, $iY)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetBrushOrgEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetColorAdjustment($hDC, $tAdjustment)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetColorAdjustment', 'handle', $hDC, 'struct*', $tAdjustment)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDCBrushColor($hDC, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'dword', 'SetDCBrushColor', 'handle', $hDC, 'dword', __RGB($iRGB))
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_SetDCPenColor($hDC, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'dword', 'SetDCPenColor', 'handle', $hDC, 'dword', __RGB($iRGB))
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_SetDeviceGammaRamp($hDC, Const ByRef $aRamp)
If (UBound($aRamp, $UBOUND_DIMENSIONS) <> 2) Or (UBound($aRamp, $UBOUND_ROWS) <> 256) Or (UBound($aRamp, $UBOUND_COLUMNS) <> 3) Then
Return SetError(12, 0, 0)
EndIf
Local $tData = DllStructCreate('ushort[256];ushort[256];ushort[256]')
For $i = 0 To 2
For $j = 0 To 255
DllStructSetData($tData, $i + 1, $aRamp[$j][$i], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetDeviceGammaRamp', 'handle', $hDC, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDIBColorTable($hBitmap, $tColorTable, $iColorCount)
If $iColorCount > DllStructGetSize($tColorTable) / 4 Then Return SetError(1, 0, 0)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'uint', 'SetDIBColorTable', 'handle', $hDC, 'uint', 0, 'uint', $iColorCount, 'struct*', $tColorTable)
If @error Then $iError = @error
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDIBitsToDevice($hDC, $iXDest, $iYDest, $iWidth, $iHeight, $iXSrc, $iYSrc, $iStartScan, $iScanLines, $tBITMAPINFO, $iUsage, $pBits)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetDIBitsToDevice', 'handle', $hDC, 'int', $iXDest, 'int', $iYDest,  'dword', $iWidth, 'dword', $iHeight, 'int', $iXSrc, 'int', $iYSrc, 'uint', $iStartScan,  'uint', $iScanLines, 'struct*', $pBits, 'struct*', $tBITMAPINFO, 'uint', $iUsage)
If @error Or ($aRet[0] = -1) Then Return SetError(@error + 10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetEnhMetaFileBits($pData, $iLength)
Local $aRet = DllCall('gdi32.dll', 'handle', 'SetEnhMetaFileBits', 'uint', $iLength, 'struct*', $pData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetGraphicsMode($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetGraphicsMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetMapMode($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetMapMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetPixel($hDC, $iX, $iY, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetPixelV', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetPolyFillMode($hDC, $iMode = 1)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetPolyFillMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetRectRgn($hRgn, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetRectRgn', 'handle', $hRgn, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetROP2($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetROP2', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetStretchBltMode($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetStretchBltMode', 'handle', $hDC, 'int', $iMode)
If @error Or Not $aRet[0] Or ($aRet[0] = 87) Then Return SetError(@error + 10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTextAlign($hDC, $iMode = 0)
Local $aRet = DllCall('gdi32.dll', 'uint', 'SetTextAlign', 'handle', $hDC, 'uint', $iMode)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTextCharacterExtra($hDC, $iCharExtra)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetTextCharacterExtra', 'handle', $hDC, 'int', $iCharExtra)
If @error Or ($aRet[0] = 0x80000000) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTextJustification($hDC, $iBreakExtra, $iBreakCount)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetTextJustification', 'handle', $hDC, 'int', $iBreakExtra, 'int', $iBreakCount)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetUDFColorMode($iMode)
$__g_iRGBMode = Not ($iMode = 0)
EndFunc
Func _WinAPI_SetWindowExt($hDC, $iXExtent, $iYExtent)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetWindowExtEx', 'handle', $hDC, 'int', $iXExtent, 'int', $iYExtent,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowOrg($hDC, $iX, $iY)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetWindowOrgEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWorldTransform($hDC, ByRef $tXFORM)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetWorldTransform', 'handle', $hDC, 'struct*', $tXFORM)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StretchBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRop)
Local $aRet = DllCall('gdi32.dll', 'bool', 'StretchBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest,  'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StretchDIBits($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $tBITMAPINFO, $iUsage, $pBits, $iRop)
Local $aRet = DllCall('gdi32.dll', 'int', 'StretchDIBits', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'struct*', $pBits, 'struct*', $tBITMAPINFO, 'uint', $iUsage,  'dword', $iRop)
If @error Or ($aRet[0] = -1) Then Return SetError(@error + 10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_StrokeAndFillPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'StrokeAndFillPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StrokePath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'StrokePath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SubtractRect(ByRef $tRECT1, ByRef $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'SubtractRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_TabbedTextOut($hDC, $iX, $iY, $sText, $aTab = 0, $iStart = 0, $iEnd = -1, $iOrigin = 0)
Local $iTab, $iCount
If Not IsArray($aTab) Then
If $aTab Then
$iTab = $aTab
Dim $aTab[1] = [$iTab]
$iStart = 0
$iEnd = 0
$iCount = 1
Else
$iCount = 0
EndIf
Else
$iCount = 1
EndIf
Local $tTab = 0
If $iCount Then
If __CheckErrorArrayBounds($aTab, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
$tTab = DllStructCreate('uint[' & $iCount & ']')
$iTab = 1
For $i = $iStart To $iEnd
DllStructSetData($tTab, 1, $aTab[$i], $iTab)
$iTab += 1
Next
EndIf
Local $aRet = DllCall('user32.dll', 'long', 'TabbedTextOutW', 'handle', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText,  'int', StringLen($sText), 'int', $iCount, 'struct*', $tTab, 'int', $iOrigin)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$__g_vExt = _WinAPI_CreateSize(_WinAPI_LoWord($aRet[0]), _WinAPI_HiWord($aRet[0]))
Return 1
EndFunc
Func _WinAPI_TextOut($hDC, $iX, $iY, $sText)
Local $aRet = DllCall('gdi32.dll', 'bool', 'TextOutW', 'handle', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText,  'int', StringLen($sText))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TransparentBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiTransparentBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', __RGB($iRGB))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UnionRect(ByRef $tRECT1, ByRef $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'UnionRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, 0, 0)
Return $tRECT
EndFunc
Func _WinAPI_ValidateRect($hWnd, $tRECT = 0)
Local $aRet = DllCall('user32.dll', 'bool', 'ValidateRect', 'hwnd', $hWnd, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ValidateRgn($hWnd, $hRgn = 0)
Local $aRet = DllCall('user32.dll', 'bool', 'ValidateRgn', 'hwnd', $hWnd, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_WidenPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'WidenPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_WindowFromDC($hDC)
Local $aRet = DllCall('user32.dll', 'hwnd', 'WindowFromDC', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Embedded DLL Functions
Func __AlphaProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' &  '48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883' &  '7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB' &  '034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B' &  '6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24' &  '287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080' &  '7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB' &  '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D' &  '1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407' &  'B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302' &  '83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00' &  '007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __ANDProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C2420554157415648C7C009000000' &  '4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405' &  '4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405' &  '4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405' &  '4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405' &  '4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048' &  '21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000' &  'EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7' &  '44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100' &  '0048C74424380000000048C74424400000000048C744244800000000488BAC24' &  'A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B' &  '7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440' &  '4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24' &  '4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7' &  '442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C' &  '24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845' &  '0048FF4424604883442458F871B948C74424380000000048C744244000000000' &  '48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7' &  'D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C' &  '244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D' &  '184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24' &  '585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0' &  '010000004863C0EB034831C04883C470415E415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05' &  'B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24' &  '38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0' &  'EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000' &  '00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7' &  '042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000' &  'C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B' &  '3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480' &  '7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24' &  '0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000' &  '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' &  'FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424' &  '0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3' &  '8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000' &  '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' &  'FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8' &  '01000000EB0231C083C4205F5B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __XORProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' &  '48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074' &  '054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0' &  '4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C' &  '3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405' &  '4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C' &  '897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB' &  '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074' &  '0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB' &  '5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B' &  '6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303' &  '895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D' &  'C21000'))
EndIf
EndIf
Return $pProc
EndFunc
#EndRegion Embedded DLL Functions
#Region Internal Functions
Func __EnumDisplayMonitorsProc($hMonitor, $hDC, $pRECT, $lParam)
#forceref $hDC, $lParam
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hMonitor
If Not $pRECT Then
$__g_vEnum[$__g_vEnum[0][0]][1] = 0
Else
$__g_vEnum[$__g_vEnum[0][0]][1] = DllStructCreate($tagRECT)
If Not _WinAPI_MoveMemory(DllStructGetPtr($__g_vEnum[$__g_vEnum[0][0]][1]), $pRECT, 16) Then Return 0
EndIf
Return 1
EndFunc
Func __EnumFontFamiliesProc($pELFEX, $pNTMEX, $iFontType, $pPattern)
Local $tELFEX = DllStructCreate($tagLOGFONT & ';wchar FullName[64];wchar Style[32];wchar Script[32]', $pELFEX)
Local $tNTMEX = DllStructCreate($tagNEWTEXTMETRICEX, $pNTMEX)
Local $tPattern = DllStructCreate('uint;uint;ptr', $pPattern)
If $iFontType And Not BitAND($iFontType, DllStructGetData($tPattern, 1)) Then
Return 1
EndIf
If DllStructGetData($tPattern, 3) Then
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathMatchSpecW', 'ptr', DllStructGetPtr($tELFEX, 14), 'ptr', DllStructGetData($tPattern, 3))
If Not @error Then
If DllStructGetData($tPattern, 2) Then
If $aRet[0] Then
Return 1
Else
EndIf
Else
If $aRet[0] Then
Else
Return 1
EndIf
EndIf
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData($tELFEX, 14)
$__g_vEnum[$__g_vEnum[0][0]][1] = DllStructGetData($tELFEX, 16)
$__g_vEnum[$__g_vEnum[0][0]][2] = DllStructGetData($tELFEX, 15)
$__g_vEnum[$__g_vEnum[0][0]][3] = DllStructGetData($tELFEX, 17)
$__g_vEnum[$__g_vEnum[0][0]][4] = $iFontType
$__g_vEnum[$__g_vEnum[0][0]][5] = DllStructGetData($tNTMEX, 19)
$__g_vEnum[$__g_vEnum[0][0]][6] = DllStructGetData($tNTMEX, 20)
$__g_vEnum[$__g_vEnum[0][0]][7] = DllStructGetData($tNTMEX, 21)
Return 1
EndFunc
Func __EnumFontStylesProc($pELFEX, $pNTMEX, $iFontType, $pFN)
#forceref $iFontType
Local $tELFEX = DllStructCreate($tagLOGFONT & ';wchar FullName[64];wchar Style[32];wchar Script[32]', $pELFEX)
Local $tNTMEX = DllStructCreate($tagNEWTEXTMETRICEX, $pNTMEX)
Local $tFN = DllStructCreate('dword;wchar[64]', $pFN)
If BitAND(DllStructGetData($tNTMEX, 'ntmFlags'), 0x0061) = DllStructGetData($tFN, 1) Then
DllStructSetData($tFN, 2, DllStructGetData($tELFEX, 'FullName'))
Return 0
Else
Return 1
EndIf
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global $__g_vVal
Global Const $tagVS_FIXEDFILEINFO = 'dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_AddIconTransparency($hIcon, $iPercent = 50, $bDelete = False)
Local $tBITMAP, $hDib = 0, $hResult = 0
Local $ahBitmap[2]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $iError = 0
Do
$hDib = _WinAPI_CopyBitmap($ahBitmap[1])
If Not $hDib Then
$iError = 20
ExitLoop
EndIf
$tBITMAP = DllStructCreate($tagBITMAP)
If (Not _WinAPI_GetObject($hDib, DllStructGetSize($tBITMAP), $tBITMAP)) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 32) Then
$iError = 21
ExitLoop
EndIf
$aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'PTR', __TransparencyProc(), 'hwnd', 0,  'uint', $iPercent, 'wparam', DllStructGetPtr($tBITMAP), 'lparam', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
ExitLoop
EndIf
If $aRet[0] = -1 Then
$hResult = _WinAPI_CreateEmptyIcon(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Else
$hResult = _WinAPI_CreateIconIndirect($hDib, $ahBitmap[0])
EndIf
If Not $hResult Then $iError = 22
Until 1
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
For $i = 0 To 1
If $ahBitmap[$i] Then
_WinAPI_DeleteObject($ahBitmap[$i])
EndIf
Next
If $iError Then Return SetError($iError, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_BeginUpdateResource($sFilePath, $bDelete = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'BeginUpdateResourceW', 'wstr', $sFilePath, 'bool', $bDelete)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ClipCursor($tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'ClipCursor', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CopyCursor($hCursor)
Return _WinAPI_CopyIcon($hCursor)
EndFunc
Func _WinAPI_CreateCaret($hWnd, $hBitmap, $iWidth = 0, $iHeight = 0)
Local $aRet = DllCall('user32.dll', 'bool', 'CreateCaret', 'hwnd', $hWnd, 'handle', $hBitmap, 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateIcon($hInstance, $iWidth, $iHeight, $iPlanes, $iBitsPixel, $pANDBits, $pXORBits)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIcon', 'handle', $hInstance, 'int', $iWidth, 'int', $iHeight,  'byte', $iPlanes, 'byte', $iBitsPixel, 'struct*', $pANDBits, 'struct*', $pXORBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateIconFromResourceEx($pData, $iSize, $bIcon = True, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIconFromResourceEx', 'ptr', $pData, 'dword', $iSize, 'bool', $bIcon,  'dword', 0x00030000, 'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DestroyCaret()
Local $aRet = DllCall('user32.dll', 'bool', 'DestroyCaret')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DestroyCursor($hCursor)
Local $aRet = DllCall('user32.dll', 'bool', 'DestroyCursor', 'handle', $hCursor)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_EndUpdateResource($hUpdate, $bDiscard = False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'EndUpdateResourceW', 'handle', $hUpdate, 'bool', $bDiscard)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumResourceLanguages($hModule, $sType, $sName)
Local $iLibrary = 0, $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Dim $__g_vEnum[101] = [0]
Local $hEnumProc = DllCallbackRegister('__EnumResLanguagesProc', 'bool', 'handle;ptr;ptr;word;long_ptr')
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceLanguagesW', 'handle', $hModule, $sTypeOfType, $sType,  $sTypeOfName, $sName, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumResourceNames($hModule, $sType)
Local $aRet, $hEnumProc, $iLibrary = 0, $sTypeOfType = 'int'
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
Dim $__g_vEnum[101] = [0]
$hEnumProc = DllCallbackRegister('__EnumResNamesProc', 'bool', 'handle;ptr;ptr;long_ptr')
$aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceNamesW', 'handle', $hModule, $sTypeOfType, $sType,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aRet[0] Or (Not $__g_vEnum[0]) Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumResourceTypes($hModule)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Dim $__g_vEnum[101] = [0]
Local $hEnumProc = DllCallbackRegister('__EnumResTypesProc', 'bool', 'handle;ptr;long_ptr')
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceTypesW', 'handle', $hModule,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aRet[0] Or (Not $__g_vEnum[0]) Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_ExtractIcon($sIcon, $iIndex, $bSmall = False)
Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')
If $bSmall Then
$pLarge = 0
$pSmall = DllStructGetPtr($tPtr)
Else
$pLarge = DllStructGetPtr($tPtr)
$pSmall = 0
EndIf
DllCall('shell32.dll', 'uint', 'ExtractIconExW', 'wstr', $sIcon, 'int', $iIndex, 'ptr', $pLarge, 'ptr', $pSmall, 'uint', 1)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPtr, 1)
EndFunc
Func _WinAPI_FileIconInit($bRestore = True)
Local $aRet = DllCall('shell32.dll', 'int', 660, 'int', $bRestore)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return 1
EndFunc
Func _WinAPI_FindResource($hInstance, $sType, $sName)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindResourceW', 'handle', $hInstance, $sTypeOfName, $sName, $sTypeOfType, $sType)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindResourceExW', 'handle', $hInstance, $sTypeOfType, $sType,  $sTypeOfName, $sName, 'ushort', $iLanguage)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FreeResource($hData)
Local $aRet = DllCall('kernel32.dll', 'bool', 'FreeResource', 'handle', $hData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCaretBlinkTime()
Local $aRet = DllCall('user32.dll', 'uint', 'GetCaretBlinkTime')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCaretPos()
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('user32.dll', 'bool', 'GetCaretPos', 'struct*', $tagPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[2]
For $i = 0 To 1
$aResult[$i] = DllStructGetData($tPOINT, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetClipCursor()
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'GetClipCursor', 'struct*', $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetCursor()
Local $aRet = DllCall('user32.dll', 'handle', 'GetCursor')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetFileVersionInfo($sFilePath, ByRef $pBuffer, $iFlags = 0)
Local $aRet
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeExW', 'dword', BitAND($iFlags, 0x03), 'wstr', $sFilePath,  'ptr', 0)
Else
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeW', 'wstr', $sFilePath, 'ptr', 0)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aRet[0], 1)
If @error Then Return SetError(@error + 100, @extended, 0)
Local $iNbByte = $aRet[0]
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoExW', 'dword', BitAND($iFlags, 0x07), 'wstr', $sFilePath,  'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
Else
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoW', 'wstr', $sFilePath,  'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $iNbByte
EndFunc
Func _WinAPI_GetIconInfoEx($hIcon)
Local $tIIEX = DllStructCreate('dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]')
DllStructSetData($tIIEX, 1, DllStructGetSize($tIIEX))
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfoExW', 'handle', $hIcon, 'struct*', $tIIEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[8]
For $i = 0 To 7
$aResult[$i] = DllStructGetData($tIIEX, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_HideCaret($hWnd)
Local $aRet = DllCall('user32.dll', 'int', 'HideCaret', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadCursor($hInstance, $sName)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('user32.dll', 'handle', 'LoadCursorW', 'handle', $hInstance, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadCursorFromFile($sFilePath)
Local $aRet = DllCall('user32.dll', 'handle', 'LoadCursorFromFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadIcon($hInstance, $sName)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('user32.dll', 'handle', 'LoadIconW', 'handle', $hInstance, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadIndirectString($sStrIn)
Local $aRet = DllCall('shlwapi.dll', 'uint', 'SHLoadIndirectString', 'wstr', $sStrIn, 'wstr', '', 'uint', 4096, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_LoadResource($hInstance, $hResource)
Local $aRet = DllCall('kernel32.dll', 'handle', 'LoadResource', 'handle', $hInstance, 'handle', $hResource)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadStringEx($hModule, $iID, $iLanguage = $LOCALE_USER_DEFAULT)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(@error + 20, @extended, '')
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Local $sResult = ''
Local $pData = __ResLoad($hModule, 6, Floor($iID / 16) + 1, $iLanguage)
If Not @error Then
Local $iOffset = 0
For $i = 0 To Mod($iID, 16) - 1
$iOffset += 2 * (DllStructGetData(DllStructCreate('ushort', $pData + $iOffset), 1) + 1)
Next
$sResult = DllStructGetData(DllStructCreate('ushort;wchar[' & DllStructGetData(DllStructCreate('ushort', $pData + $iOffset), 1) & ']', $pData + $iOffset), 2)
If @error Then $sResult = ''
Else
Return SetError(10, 0, '')
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
Return SetError(Number(Not $sResult), 0, $sResult)
EndFunc
Func _WinAPI_LockResource($hData)
Local $aRet = DllCall('kernel32.dll', 'ptr', 'LockResource', 'handle', $hData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LookupIconIdFromDirectoryEx($pData, $bIcon = True, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'int', 'LookupIconIdFromDirectoryEx', 'ptr', $pData, 'bool', $bIcon,  'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetCaretBlinkTime($iDuration)
Local $iPrev = _WinAPI_GetCaretBlinkTime()
If Not $iPrev Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('user32.dll', 'bool', 'SetCaretBlinkTime', 'uint', $iDuration)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $iPrev
EndFunc
Func _WinAPI_SetCaretPos($iX, $iY)
Local $aRet = DllCall('user32.dll', 'int', 'SetCaretPos', 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetSystemCursor($hCursor, $iID, $bCopy = False)
If $bCopy Then
$hCursor = _WinAPI_CopyCursor($hCursor)
EndIf
Local $aRet = DllCall('user32.dll', 'bool', 'SetSystemCursor', 'handle', $hCursor, 'dword', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShowCaret($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'ShowCaret', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SizeOfResource($hInstance, $hResource)
Local $aRet = DllCall('kernel32.dll', 'dword', 'SizeofResource', 'handle', $hInstance, 'handle', $hResource)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UpdateResource($hUpdate, $sType, $sName, $iLanguage, $pData, $iSize)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'UpdateResourceW', 'handle', $hUpdate, $sTypeOfType, $sType, $sTypeOfName, $sName,  'word', $iLanguage, 'ptr', $pData, 'dword', $iSize)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_VerQueryRoot($pData)
Local $aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then Return SetError(@error + 10, @extended, 0)
Local $tVFFI = DllStructCreate($tagVS_FIXEDFILEINFO)
If Not _WinAPI_MoveMemory($tVFFI, $aRet[3], $aRet[4]) Then Return SetError(@error + 20, @extended, 0)
Return $tVFFI
EndFunc
Func _WinAPI_VerQueryValue($pData, $sValues = '')
$sValues = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $sValues Then
$sValues = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$sValues = StringSplit($sValues, '|', $STR_NOCOUNT)
Local $aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0,  'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then Return SetError(@error + 10, 0, 0)
Local $iLength = Floor($aRet[4] / 4)
Local $tLang = DllStructCreate('dword[' & $iLength & ']', $aRet[3])
If @error Then Return SetError(@error + 20, 0, 0)
Local $sCP, $aInfo[101][UBound($sValues) + 1] = [[0]]
For $i = 1 To $iLength
__Inc($aInfo)
$aInfo[$aInfo[0][0]][0] = _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))
$sCP = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tLang, 1, $i)), _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))), 8)
For $j = 0 To UBound($sValues) - 1
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $sValues[$j],  'ptr*', 0, 'uint*', 0)
If Not @error And $aRet[0] And $aRet[4] Then
$aInfo[$aInfo[0][0]][$j + 1] = DllStructGetData(DllStructCreate('wchar[' & $aRet[4] & ']', $aRet[3]), 1)
Else
$aInfo[$aInfo[0][0]][$j + 1] = ''
EndIf
Next
Next
__Inc($aInfo, -1)
Return $aInfo
EndFunc
Func _WinAPI_VerQueryValueEx($hModule, $sValues = '', $iLanguage = 0x0400)
$__g_vVal = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $__g_vVal Then
$__g_vVal = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$__g_vVal = StringSplit($__g_vVal, '|')
If Not IsArray($__g_vVal) Then Return SetError(1, 0, 0)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then
Return SetError(@error + 10, @extended, 0)
EndIf
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Dim $__g_vEnum[101][$__g_vVal[0] + 1] = [[0]]
Local $hEnumProc = DllCallbackRegister('__EnumVerValuesProc', 'bool', 'ptr;ptr;ptr;word;long_ptr')
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceLanguagesW', 'handle', $hModule, 'int', 16, 'int', 1,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', $iLanguage)
Do
If @error Then
$__g_vEnum = @error + 20
Else
If Not $aRet[0] Then
Switch _WinAPI_GetLastError()
Case 0, 15106
ExitLoop
Case Else
$__g_vEnum = 20
EndSwitch
Else
ExitLoop
EndIf
EndIf
Until 1
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then $__g_vEnum = 230
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
#EndRegion Public Functions
#Region Embedded DLL Functions
Func __TransparencyProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C0505050505050' &  '4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522' &  '488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502' &  'EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63' &  '7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF' &  '7D08C74424780000000048C74424280100000048C74424300000000048C74424' &  '3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF' &  'F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18' &  '4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C' &  '244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899' &  '48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7' &  '4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24' &  '3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0' &  'FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F' &  '5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24' &  '28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021' &  'C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24' &  '2421DB7D08C744242400000000C7042401000000C744240400000000C7442408' &  '000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B' &  '6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24' &  '100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058' &  '8845008B6C240C807D00007407C7042400000000C74424040100000083442408' &  '047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF' &  'FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
#EndRegion Embedded DLL Functions
#Region Internal Functions
Func __EnumResLanguagesProc($hModule, $iType, $iName, $iLanguage, $lParam)
#forceref $hModule, $iType, $iName, $lParam
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = $iLanguage
Return 1
EndFunc
Func __EnumResNamesProc($hModule, $iType, $iName, $lParam)
#forceref $hModule, $iType, $lParam
Local $iLength = _WinAPI_StrLen($iName)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $iName), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = Number($iName)
EndIf
Return 1
EndFunc
Func __EnumResTypesProc($hModule, $iType, $lParam)
#forceref $hModule, $lParam
Local $iLength = _WinAPI_StrLen($iType)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $iType), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = Number($iType)
EndIf
Return 1
EndFunc
Func __EnumVerValuesProc($hModule, $iType, $iName, $iLanguage, $iDefault)
Local $aRet, $iEnum = 1, $iError = 0
Switch $iDefault
Case -1
Case 0x0400
$iLanguage = 0x0400
$iEnum = 0
Case Else
If $iLanguage <> $iDefault Then
Return 1
EndIf
$iEnum = 0
EndSwitch
Do
Local $pData = __ResLoad($hModule, $iType, $iName, $iLanguage)
If @error Then
$iError = @error + 10
ExitLoop
EndIf
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then
$iError = @error + 20
ExitLoop
EndIf
Local $tData = DllStructCreate('ushort;ushort', $aRet[3])
If @error Then
$iError = @error + 30
ExitLoop
EndIf
Until 1
If Not $iError Then
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData($tData, 1)
Local $sCP = Hex(_WinAPI_MakeLong(DllStructGetData($tData, 2), DllStructGetData($tData, 1)), 8)
For $i = 1 To $__g_vVal[0]
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $__g_vVal[$i],  'ptr*', 0, 'uint*', 0)
If Not @error And $aRet[0] And $aRet[4] Then
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData(DllStructCreate('wchar[' & $aRet[4] & ']', $aRet[3]), 1)
Else
$__g_vEnum[$__g_vEnum[0][0]][$i] = ''
EndIf
Next
Else
$__g_vEnum = @error + 40
EndIf
If $__g_vEnum Then Return SetError($iError, 0, 0)
Return $iEnum
EndFunc
Func __ResLoad($hInstance, $sType, $sName, $iLanguage)
Local $hInfo = _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)
If Not $hInfo Then Return SetError(@error + 10, @extended, 0)
Local $iSize = _WinAPI_SizeOfResource($hInstance, $hInfo)
If Not $iSize Then Return SetError(@error + 20, @extended, 0)
Local $hData = _WinAPI_LoadResource($hInstance, $hInfo)
If Not $hData Then Return SetError(@error + 30, @extended, 0)
Local $pData = _WinAPI_LockResource($hData)
If Not $pData Then Return SetError(@error + 40, @extended, 0)
Return SetExtended($iSize, $pData)
EndFunc
#EndRegion Internal Functions
Global Const $GDIP_DASHCAPFLAT = 0
Global Const $GDIP_DASHCAPROUND = 2
Global Const $GDIP_DASHCAPTRIANGLE = 3
Global Const $GDIP_DASHSTYLESOLID = 0
Global Const $GDIP_DASHSTYLEDASH = 1
Global Const $GDIP_DASHSTYLEDOT = 2
Global Const $GDIP_DASHSTYLEDASHDOT = 3
Global Const $GDIP_DASHSTYLEDASHDOTDOT = 4
Global Const $GDIP_DASHSTYLECUSTOM = 5
Global Const $GDIP_EPGCHROMINANCETABLE = '{F2E455DC-09B3-4316-8260-676ADA32481C}'
Global Const $GDIP_EPGCOLORDEPTH = '{66087055-AD66-4C7C-9A18-38A2310B8337}'
Global Const $GDIP_EPGCOMPRESSION = '{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}'
Global Const $GDIP_EPGLUMINANCETABLE = '{EDB33BCE-0266-4A77-B904-27216099E717}'
Global Const $GDIP_EPGQUALITY = '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}'
Global Const $GDIP_EPGRENDERMETHOD = '{6D42C53A-229A-4825-8BB7-5C99E2B9A8B8}'
Global Const $GDIP_EPGSAVEFLAG = '{292266FC-AC40-47BF-8CFC-A85B89A655DE}'
Global Const $GDIP_EPGSCANMETHOD = '{3A4E2661-3109-4E56-8536-42C156E7DCFA}'
Global Const $GDIP_EPGTRANSFORMATION = '{8D0EB2D1-A58E-4EA8-AA14-108074B7B6F9}'
Global Const $GDIP_EPGVERSION = '{24D18C76-814A-41A4-BF53-1C219CCCF797}'
Global Const $GDIP_EPTBYTE = 1
Global Const $GDIP_EPTASCII = 2
Global Const $GDIP_EPTSHORT = 3
Global Const $GDIP_EPTLONG = 4
Global Const $GDIP_EPTRATIONAL = 5
Global Const $GDIP_EPTLONGRANGE = 6
Global Const $GDIP_EPTUNDEFINED = 7
Global Const $GDIP_EPTRATIONALRANGE = 8
Global Const $GDIP_ERROK = 0
Global Const $GDIP_ERRGENERICERROR = 1
Global Const $GDIP_ERRINVALIDPARAMETER = 2
Global Const $GDIP_ERROUTOFMEMORY = 3
Global Const $GDIP_ERROBJECTBUSY = 4
Global Const $GDIP_ERRINSUFFICIENTBUFFER = 5
Global Const $GDIP_ERRNOTIMPLEMENTED = 6
Global Const $GDIP_ERRWIN32ERROR = 7
Global Const $GDIP_ERRWRONGSTATE = 8
Global Const $GDIP_ERRABORTED = 9
Global Const $GDIP_ERRFILENOTFOUND = 10
Global Const $GDIP_ERRVALUEOVERFLOW = 11
Global Const $GDIP_ERRACCESSDENIED = 12
Global Const $GDIP_ERRUNKNOWNIMAGEFORMAT = 13
Global Const $GDIP_ERRFONTFAMILYNOTFOUND = 14
Global Const $GDIP_ERRFONTSTYLENOTFOUND = 15
Global Const $GDIP_ERRNOTTRUETYPEFONT = 16
Global Const $GDIP_ERRUNSUPPORTEDGDIVERSION = 17
Global Const $GDIP_ERRGDIPLUSNOTINITIALIZED = 18
Global Const $GDIP_ERRPROPERTYNOTFOUND = 19
Global Const $GDIP_ERRPROPERTYNOTSUPPORTED = 20
Global Const $GDIP_EVTCOMPRESSIONLZW = 2
Global Const $GDIP_EVTCOMPRESSIONCCITT3 = 3
Global Const $GDIP_EVTCOMPRESSIONCCITT4 = 4
Global Const $GDIP_EVTCOMPRESSIONRLE = 5
Global Const $GDIP_EVTCOMPRESSIONNONE = 6
Global Const $GDIP_EVTTRANSFORMROTATE90 = 13
Global Const $GDIP_EVTTRANSFORMROTATE180 = 14
Global Const $GDIP_EVTTRANSFORMROTATE270 = 15
Global Const $GDIP_EVTTRANSFORMFLIPHORIZONTAL = 16
Global Const $GDIP_EVTTRANSFORMFLIPVERTICAL = 17
Global Const $GDIP_EVTMULTIFRAME = 18
Global Const $GDIP_EVTLASTFRAME = 19
Global Const $GDIP_EVTFLUSH = 20
Global Const $GDIP_EVTFRAMEDIMENSIONPAGE = 23
Global Const $GDIP_ICFENCODER = 0x00000001
Global Const $GDIP_ICFDECODER = 0x00000002
Global Const $GDIP_ICFSUPPORTBITMAP = 0x00000004
Global Const $GDIP_ICFSUPPORTVECTOR = 0x00000008
Global Const $GDIP_ICFSEEKABLEENCODE = 0x00000010
Global Const $GDIP_ICFBLOCKINGDECODE = 0x00000020
Global Const $GDIP_ICFBUILTIN = 0x00010000
Global Const $GDIP_ICFSYSTEM = 0x00020000
Global Const $GDIP_ICFUSER = 0x00040000
Global Const $GDIP_ILMREAD = 0x0001
Global Const $GDIP_ILMWRITE = 0x0002
Global Const $GDIP_ILMUSERINPUTBUF = 0x0004
Global Const $GDIP_LINECAPFLAT = 0x00
Global Const $GDIP_LINECAPSQUARE = 0x01
Global Const $GDIP_LINECAPROUND = 0x02
Global Const $GDIP_LINECAPTRIANGLE = 0x03
Global Const $GDIP_LINECAPNOANCHOR = 0x10
Global Const $GDIP_LINECAPSQUAREANCHOR = 0x11
Global Const $GDIP_LINECAPROUNDANCHOR = 0x12
Global Const $GDIP_LINECAPDIAMONDANCHOR = 0x13
Global Const $GDIP_LINECAPARROWANCHOR = 0x14
Global Const $GDIP_LINECAPCUSTOM = 0xFF
Global Const $GDIP_PXF01INDEXED = 0x00030101
Global Const $GDIP_PXF04INDEXED = 0x00030402
Global Const $GDIP_PXF08INDEXED = 0x00030803
Global Const $GDIP_PXF16GRAYSCALE = 0x00101004
Global Const $GDIP_PXF16RGB555 = 0x00021005
Global Const $GDIP_PXF16RGB565 = 0x00021006
Global Const $GDIP_PXF16ARGB1555 = 0x00061007
Global Const $GDIP_PXF24RGB = 0x00021808
Global Const $GDIP_PXF32RGB = 0x00022009
Global Const $GDIP_PXF32ARGB = 0x0026200A
Global Const $GDIP_PXF32PARGB = 0x000E200B
Global Const $GDIP_PXF48RGB = 0x0010300C
Global Const $GDIP_PXF64ARGB = 0x0034400D
Global Const $GDIP_PXF64PARGB = 0x001A400E
Global Const $GDIP_IMAGEFORMAT_UNDEFINED = "{B96B3CA9-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_MEMORYBMP = "{B96B3CAA-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_BMP = "{B96B3CAB-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EMF = "{B96B3CAC-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_WMF = "{B96B3CAD-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_JPEG = "{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_PNG = "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_GIF = "{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_TIFF = "{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_EXIF = "{B96B3CB2-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGEFORMAT_ICON = "{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}"
Global Const $GDIP_IMAGETYPE_UNKNOWN = 0
Global Const $GDIP_IMAGETYPE_BITMAP = 1
Global Const $GDIP_IMAGETYPE_METAFILE = 2
Global Const $GDIP_IMAGEFLAGS_NONE = 0x0
Global Const $GDIP_IMAGEFLAGS_SCALABLE = 0x0001
Global Const $GDIP_IMAGEFLAGS_HASALPHA = 0x0002
Global Const $GDIP_IMAGEFLAGS_HASTRANSLUCENT = 0x0004
Global Const $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE = 0x0008
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_RGB = 0x0010
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_CMYK = 0x0020
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_GRAY = 0x0040
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR = 0x0080
Global Const $GDIP_IMAGEFLAGS_COLORSPACE_YCCK = 0x0100
Global Const $GDIP_IMAGEFLAGS_HASREALDPI = 0x1000
Global Const $GDIP_IMAGEFLAGS_HASREALPIXELSIZE = 0x2000
Global Const $GDIP_IMAGEFLAGS_READONLY = 0x00010000
Global Const $GDIP_IMAGEFLAGS_CACHING = 0x00020000
Global Const $GDIP_SMOOTHINGMODE_INVALID = -1
Global Const $GDIP_SMOOTHINGMODE_DEFAULT = 0
Global Const $GDIP_SMOOTHINGMODE_HIGHSPEED = 1
Global Const $GDIP_SMOOTHINGMODE_HIGHQUALITY = 2
Global Const $GDIP_SMOOTHINGMODE_NONE = 3
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X4 = 4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS = $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
Global Const $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 = 5
Global Const $GDIP_RLUM = 0.3086
Global Const $GDIP_GLUM = 0.6094
Global Const $GDIP_BLUM = 0.0820
Global Const $GDIP_INTERPOLATIONMODE_INVALID = -1
Global Const $GDIP_INTERPOLATIONMODE_DEFAULT = 0
Global Const $GDIP_INTERPOLATIONMODE_LOWQUALITY = 1
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITY = 2
Global Const $GDIP_INTERPOLATIONMODE_BILINEAR = 3
Global Const $GDIP_INTERPOLATIONMODE_BICUBIC = 4
Global Const $GDIP_INTERPOLATIONMODE_NEARESTNEIGHBOR = 5
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBILINEAR = 6
Global Const $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC = 7
Global Const $GDIP_TEXTRENDERINGHINT_SYSTEMDEFAULT = 0
Global Const $GDIP_TEXTRENDERINGHINT_SINGLEBITPERPIXELGRIDFIT = 1
Global Const $GDIP_TEXTRENDERINGHINT_SINGLEBITPERPIXEL = 2
Global Const $GDIP_TEXTRENDERINGHINT_ANTIALIASGRIDFIT = 3
Global Const $GDIP_TEXTRENDERINGHINT_ANTIALIAS = 4
Global Const $GDIP_TEXTRENDERINGHINT_CLEARTYPEGRIDFIT = 5
Global Const $GDIP_PIXELOFFSETMODE_INVALID = -1
Global Const $GDIP_PIXELOFFSETMODE_DEFAULT = 0
Global Const $GDIP_PIXELOFFSETMODE_HIGHSPEED = 1
Global Const $GDIP_PIXELOFFSETMODE_HIGHQUALITY = 2
Global Const $GDIP_PIXELOFFSETMODE_NONE = 3
Global Const $GDIP_PIXELOFFSETMODE_HALF = 4
Global Const $GDIP_PENSETLINEJOIN_MITER = 0
Global Const $GDIP_PENSETLINEJOIN_BEVEL = 1
Global Const $GDIP_PENSETLINEJOIN_ROUND = 2
Global Const $GDIP_PENSETLINEJOIN_MITERCLIPPED = 3
Global Const $GDIP_FillModeAlternate = 0
Global Const $GDIP_FillModeWinding = 1
Global Const $GDIP_QUALITYMODEINVALID = -1
Global Const $GDIP_QUALITYMODEDEFAULT = 0
Global Const $GDIP_QUALITYMODELOW = 1
Global Const $GDIP_QUALITYMODEHIGH = 2
Global Const $GDIP_COMPOSITINGMODESOURCEOVER = 0
Global Const $GDIP_COMPOSITINGMODESOURCECOPY = 1
Global Const $GDIP_COMPOSITINGQUALITYINVALID = $GDIP_QUALITYMODEINVALID
Global Const $GDIP_COMPOSITINGQUALITYDEFAULT = $GDIP_QUALITYMODEDEFAULT
Global Const $GDIP_COMPOSITINGQUALITYHIGHSPEED = $GDIP_QUALITYMODELOW
Global Const $GDIP_COMPOSITINGQUALITYHIGHQUALITY = $GDIP_QUALITYMODEHIGH
Global Const $GDIP_COMPOSITINGQUALITYGAMMACORRECTED = 3
Global Const $GDIP_COMPOSITINGQUALITYASSUMELINEAR = 4
Global Const $GDIP_HATCHSTYLE_HORIZONTAL = 0
Global Const $GDIP_HATCHSTYLE_VERTICAL = 1
Global Const $GDIP_HATCHSTYLE_FORWARDDIAGONAL = 2
Global Const $GDIP_HATCHSTYLE_BACKWARDDIAGONAL = 3
Global Const $GDIP_HATCHSTYLE_CROSS = 4
Global Const $GDIP_HATCHSTYLE_DIAGONALCROSS = 5
Global Const $GDIP_HATCHSTYLE_05PERCENT = 6
Global Const $GDIP_HATCHSTYLE_10PERCENT = 7
Global Const $GDIP_HATCHSTYLE_20PERCENT = 8
Global Const $GDIP_HATCHSTYLE_25PERCENT = 9
Global Const $GDIP_HATCHSTYLE_30PERCENT = 10
Global Const $GDIP_HATCHSTYLE_40PERCENT = 11
Global Const $GDIP_HATCHSTYLE_50PERCENT = 12
Global Const $GDIP_HATCHSTYLE_60PERCENT = 13
Global Const $GDIP_HATCHSTYLE_70PERCENT = 14
Global Const $GDIP_HATCHSTYLE_75PERCENT = 15
Global Const $GDIP_HATCHSTYLE_80PERCENT = 16
Global Const $GDIP_HATCHSTYLE_90PERCENT = 17
Global Const $GDIP_HATCHSTYLE_LIGHTDOWNWARDDIAGONAL = 18
Global Const $GDIP_HATCHSTYLE_LIGHTUPWARDDIAGONAL = 19
Global Const $GDIP_HATCHSTYLE_DARKDOWNWARDDIAGONAL = 20
Global Const $GDIP_HATCHSTYLE_DARKUPWARDDIAGONAL = 21
Global Const $GDIP_HATCHSTYLE_WIDEDOWNWARDDIAGONAL = 22
Global Const $GDIP_HATCHSTYLE_WIDEUPWARDDIAGONAL = 23
Global Const $GDIP_HATCHSTYLE_LIGHTVERTICAL = 24
Global Const $GDIP_HATCHSTYLE_LIGHTHORIZONTAL = 25
Global Const $GDIP_HATCHSTYLE_NARROWVERTICAL = 26
Global Const $GDIP_HATCHSTYLE_NARROWHORIZONTAL = 27
Global Const $GDIP_HATCHSTYLE_DARKVERTICAL = 28
Global Const $GDIP_HATCHSTYLE_DARKHORIZONTAL = 29
Global Const $GDIP_HATCHSTYLE_DASHEDDOWNWARDDIAGONAL = 30
Global Const $GDIP_HATCHSTYLE_DASHEDUPWARDDIAGONAL = 31
Global Const $GDIP_HATCHSTYLE_DASHEDHORIZONTAL = 32
Global Const $GDIP_HATCHSTYLE_DASHEDVERTICAL = 33
Global Const $GDIP_HATCHSTYLE_SMALLCONFETTI = 34
Global Const $GDIP_HATCHSTYLE_LARGECONFETTI = 35
Global Const $GDIP_HATCHSTYLE_ZIGZAG = 36
Global Const $GDIP_HATCHSTYLE_WAVE = 37
Global Const $GDIP_HATCHSTYLE_DIAGONALBRICK = 38
Global Const $GDIP_HATCHSTYLE_HORIZONTALBRICK = 39
Global Const $GDIP_HATCHSTYLE_WEAVE = 40
Global Const $GDIP_HATCHSTYLE_PLAID = 41
Global Const $GDIP_HATCHSTYLE_DIVOT = 42
Global Const $GDIP_HATCHSTYLE_DOTTEDGRID = 43
Global Const $GDIP_HATCHSTYLE_DOTTEDDIAMOND = 44
Global Const $GDIP_HATCHSTYLE_SHINGLE = 45
Global Const $GDIP_HATCHSTYLE_TRELLIS = 46
Global Const $GDIP_HATCHSTYLE_SPHERE = 47
Global Const $GDIP_HATCHSTYLE_SMALLGRID = 48
Global Const $GDIP_HATCHSTYLE_SMALLCHECKERBOARD = 49
Global Const $GDIP_HATCHSTYLE_LARGECHECKERBOARD = 50
Global Const $GDIP_HATCHSTYLE_OUTLINEDDIAMOND = 51
Global Const $GDIP_HATCHSTYLE_SOLIDDIAMOND = 52
Global Const $GDIP_HATCHSTYLE_TOTAL = 53
Global Const $GDIP_HATCHSTYLE_LARGEGRID = $GDIP_HATCHSTYLE_CROSS
Global Const $GDIP_HATCHSTYLE_MIN = $GDIP_HATCHSTYLE_HORIZONTAL
Global Const $GDIP_HATCHSTYLE_MAX = $GDIP_HATCHSTYLE_TOTAL - 1
Global Const $GDIP_BlurEffectGuid = '{633C80A4-1843-482b-9EF2-BE2834C5FDD4}'
Global Const $GDIP_SharpenEffectGuid = '{63CBF3EE-C526-402c-8F71-62C540BF5142}'
Global Const $GDIP_ColorMatrixEffectGuid = '{718F2615-7933-40e3-A511-5F68FE14DD74}'
Global Const $GDIP_ColorLUTEffectGuid = '{A7CE72A9-0F7F-40d7-B3CC-D0C02D5C3212}'
Global Const $GDIP_BrightnessContrastEffectGuid = '{D3A1DBE1-8EC4-4c17-9F4C-EA97AD1C343D}'
Global Const $GDIP_HueSaturationLightnessEffectGuid = '{8B2DD6C3-EB07-4d87-A5F0-7108E26A9C5F}'
Global Const $GDIP_LevelsEffectGuid = '{99C354EC-2A31-4f3a-8C34-17A803B33A25}'
Global Const $GDIP_TintEffectGuid = '{1077AF00-2848-4441-9489-44AD4C2D7A2C}'
Global Const $GDIP_ColorBalanceEffectGuid = '{537E597D-251E-48da-9664-29CA496B70F8}'
Global Const $GDIP_RedEyeCorrectionEffectGuid = '{74D29D05-69A4-4266-9549-3CC52836B632}'
Global Const $GDIP_ColorCurveEffectGuid = '{DD6A0022-58E4-4a67-9D9B-D48EB881A53D}'
Global Const $GDIP_AdjustExposure = 0
Global Const $GDIP_AdjustDensity = 1
Global Const $GDIP_AdjustContrast = 2
Global Const $GDIP_AdjustHighlight = 3
Global Const $GDIP_AdjustShadow = 4
Global Const $GDIP_AdjustMidtone = 5
Global Const $GDIP_AdjustWhiteSaturation = 6
Global Const $GDIP_AdjustBlackSaturation = 7
Global Const $GDIP_CurveChannelAll = 0
Global Const $GDIP_CurveChannelRed = 1
Global Const $GDIP_CurveChannelGreen = 2
Global Const $GDIP_CurveChannelBlue = 3
Global Const $GDIP_PaletteTypeCustom = 0
Global Const $GDIP_PaletteTypeOptimal = 1
Global Const $GDIP_PaletteTypeFixedBW = 2
Global Const $GDIP_PaletteTypeFixedHalftone8 = 3
Global Const $GDIP_PaletteTypeFixedHalftone27 = 4
Global Const $GDIP_PaletteTypeFixedHalftone64 = 5
Global Const $GDIP_PaletteTypeFixedHalftone125 = 6
Global Const $GDIP_PaletteTypeFixedHalftone216 = 7
Global Const $GDIP_PaletteTypeFixedHalftone252 = 8
Global Const $GDIP_PaletteTypeFixedHalftone256 = 9
Global Const $GDIP_PaletteFlagsHasAlpha = 0x0001
Global Const $GDIP_PaletteFlagsGrayScale = 0x0002
Global Const $GDIP_PaletteFlagsHalftone = 0x0004
Global Const $GDIP_DitherTypeNone = 0
Global Const $GDIP_DitherTypeSolid = 1
Global Const $GDIP_DitherTypeOrdered4x4 = 2
Global Const $GDIP_DitherTypeOrdered8x8 = 3
Global Const $GDIP_DitherTypeOrdered16x16 = 4
Global Const $GDIP_DitherTypeOrdered91x91 = 5
Global Const $GDIP_DitherTypeSpiral4x4 = 6
Global Const $GDIP_DitherTypeSpiral8x8 = 7
Global Const $GDIP_DitherTypeDualSpiral4x4 = 8
Global Const $GDIP_DitherTypeDualSpiral8x8 = 9
Global Const $GDIP_DitherTypeErrorDiffusion = 10
Global Const $GDIP_DitherTypeMax = 10
Global Const $GDIP_HistogramFormatARGB = 0
Global Const $GDIP_HistogramFormatPARGB = 1
Global Const $GDIP_HistogramFormatRGB = 2
Global Const $GDIP_HistogramFormatGray = 3
Global Const $GDIP_HistogramFormatB = 4
Global Const $GDIP_HistogramFormatG = 5
Global Const $GDIP_HistogramFormatR = 6
Global Const $GDIP_HistogramFormatA = 7
Global Const $GDIP_TextRenderingHintSystemDefault = 0
Global Const $GDIP_TextRenderingHintSingleBitPerPixelGridFit = 1
Global Const $GDIP_TextRenderingHintSingleBitPerPixel = 2
Global Const $GDIP_TextRenderingHintAntialiasGridFit = 3
Global Const $GDIP_TextRenderingHintAntialias = 4
Global Const $GDIP_TextRenderingHintClearTypeGridFit = 5
Global Const $GDIP_RotateNoneFlipNone = 0
Global Const $GDIP_Rotate90FlipNone = 1
Global Const $GDIP_Rotate180FlipNone = 2
Global Const $GDIP_Rotate270FlipNone = 3
Global Const $GDIP_RotateNoneFlipX = 4
Global Const $GDIP_Rotate90FlipX = 5
Global Const $GDIP_Rotate180FlipX = 6
Global Const $GDIP_Rotate270FlipX = 7
Global Const $GDIP_RotateNoneFlipY = $GDIP_Rotate180FlipX
Global Const $GDIP_Rotate90FlipY = $GDIP_Rotate270FlipX
Global Const $GDIP_Rotate180FlipY = $GDIP_RotateNoneFlipX
Global Const $GDIP_Rotate270FlipY = $GDIP_Rotate90FlipX
Global Const $GDIP_RotateNoneFlipXY = $GDIP_Rotate180FlipNone
Global Const $GDIP_Rotate90FlipXY = $GDIP_Rotate270FlipNone
Global Const $GDIP_Rotate270FlipXY = $GDIP_Rotate90FlipNone
Global $__g_hGDIPBrush = 0
Global $__g_hGDIPDll = 0
Global $__g_hGDIPPen = 0
Global $__g_iGDIPRef = 0
Global $__g_iGDIPToken = 0
Global $__g_bGDIP_V1_0 = True
Func _GDIPlus_ArrowCapCreate($fHeight, $fWidth, $bFilled = True)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateAdjustableArrowCap", "float", $fHeight, "float", $fWidth, "bool", $bFilled, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_ArrowCapDispose($hCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteCustomLineCap", "handle", $hCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapGetFillState($hArrowCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapFillState", "handle", $hArrowCap, "bool*", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapGetHeight($hArrowCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapHeight", "handle", $hArrowCap, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ArrowCapGetMiddleInset($hArrowCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapMiddleInset", "handle", $hArrowCap, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ArrowCapGetWidth($hArrowCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetAdjustableArrowCapWidth", "handle", $hArrowCap, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ArrowCapSetFillState($hArrowCap, $bFilled = True)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapFillState", "handle", $hArrowCap, "bool", $bFilled)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapSetHeight($hArrowCap, $fHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapHeight", "handle", $hArrowCap, "float", $fHeight)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapSetMiddleInset($hArrowCap, $fInset)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapMiddleInset", "handle", $hArrowCap, "float", $fInset)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ArrowCapSetWidth($hArrowCap, $fWidth)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetAdjustableArrowCapWidth", "handle", $hArrowCap, "float", $fWidth)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapCloneArea($hBitmap, $nLeft, $nTop, $nWidth, $nHeight, $iFormat = 0x00021808)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneBitmapArea", "float", $nLeft, "float", $nTop, "float", $nWidth, "float", $nHeight,  "int", $iFormat, "handle", $hBitmap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
Local $aRet = DllCall($__g_hGDIPDll, "uint", "GdipGetImageDimension", "handle", $hBitmap, "float*", 0, "float*", 0)
If @error Or $aRet[0] Then Return SetError(@error + 10, $aRet[0], 0)
Local $tData = _GDIPlus_BitmapLockBits($hBitmap, 0, 0, $aRet[2], $aRet[3], $GDIP_ILMREAD, $GDIP_PXF32ARGB)
Local $pBits = DllStructGetData($tData, "Scan0")
If Not $pBits Then Return 0
Local $tBIHDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIHDR, "bV5Size", DllStructGetSize($tBIHDR))
DllStructSetData($tBIHDR, "bV5Width", $aRet[2])
DllStructSetData($tBIHDR, "bV5Height", $aRet[3])
DllStructSetData($tBIHDR, "bV5Planes", 1)
DllStructSetData($tBIHDR, "bV5BitCount", 32)
DllStructSetData($tBIHDR, "bV5Compression", 0)
DllStructSetData($tBIHDR, "bV5SizeImage", $aRet[3] * DllStructGetData($tData, "Stride"))
DllStructSetData($tBIHDR, "bV5AlphaMask", 0xFF000000)
DllStructSetData($tBIHDR, "bV5RedMask", 0x00FF0000)
DllStructSetData($tBIHDR, "bV5GreenMask", 0x0000FF00)
DllStructSetData($tBIHDR, "bV5BlueMask", 0x000000FF)
DllStructSetData($tBIHDR, "bV5CSType", 2)
DllStructSetData($tBIHDR, "bV5Intent", 4)
Local $hHBitmapv5 = DllCall("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0, "struct*", $tBIHDR, "uint", 0, "ptr*", 0, "ptr", 0, "dword", 0)
If Not @error And $hHBitmapv5[0] Then
DllCall("gdi32.dll", "dword", "SetBitmapBits", "ptr", $hHBitmapv5[0], "dword", $aRet[2] * $aRet[3] * 4, "ptr", DllStructGetData($tData, "Scan0"))
$hHBitmapv5 = $hHBitmapv5[0]
Else
$hHBitmapv5 = 0
EndIf
_GDIPlus_BitmapUnlockBits($hBitmap, $tData)
$tData = 0
$tBIHDR = 0
Return $hHBitmapv5
EndFunc
Func _GDIPlus_BitmapCreateFromFile($sFileName)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromFile", "wstr", $sFileName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateFromGraphics($iWidth, $iHeight, $hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromGraphics", "int", $iWidth, "int", $iHeight, "handle", $hGraphics,  "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_BitmapCreateFromHBITMAP($hBitmap, $hPal = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromHBITMAP", "handle", $hBitmap, "handle", $hPal, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_BitmapCreateFromMemory($dImage, $bHBITMAP = False)
If Not IsBinary($dImage) Then Return SetError(1, 0, 0)
Local $aResult = 0
Local Const $dMemBitmap = Binary($dImage)
Local Const $iLen = BinaryLen($dMemBitmap)
Local Const $GMEM_MOVEABLE = 0x0002
$aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $iLen)
If @error Then Return SetError(4, 0, 0)
Local Const $hData = $aResult[0]
$aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hData)
If @error Then Return SetError(5, 0, 0)
Local $tMem = DllStructCreate("byte[" & $iLen & "]", $aResult[0])
DllStructSetData($tMem, 1, $dMemBitmap)
DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hData)
If @error Then Return SetError(6, 0, 0)
Local Const $hStream = _WinAPI_CreateStreamOnHGlobal($hData)
If @error Then Return SetError(2, 0, 0)
Local Const $hBitmap = _GDIPlus_BitmapCreateFromStream($hStream)
If @error Then Return SetError(3, 0, 0)
DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $hStream, "ulong_ptr", 8 * (1 + @AutoItX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
If $bHBITMAP Then
Local Const $hHBmp = _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
_GDIPlus_BitmapDispose($hBitmap)
Return $hHBmp
EndIf
Return $hBitmap
EndFunc
Func _GDIPlus_BitmapCreateFromResource($hInst, $vResourceName)
Local $sType = "int"
If IsString($vResourceName) Then $sType = "wstr"
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromResource", "handle", $hInst, $sType, $vResourceName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight, $iPixelFormat = $GDIP_PXF32ARGB, $iStride = 0, $pScan0 = 0)
Local $aResult = DllCall($__g_hGDIPDll, "uint", "GdipCreateBitmapFromScan0", "int", $iWidth, "int", $iHeight, "int", $iStride, "int", $iPixelFormat, "struct*", $pScan0, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_BitmapCreateFromStream($pStream)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromStream", "ptr", $pStream, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateHBITMAPFromBitmap($hBitmap, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateHBITMAPFromBitmap", "handle", $hBitmap, "handle*", 0, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapDispose($hBitmap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hBitmap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapCreateFromHICON($hIcon)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateBitmapFromHICON", "handle", $hIcon, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BitmapCreateFromHICON32($hIcon)
Local $tSIZE = _WinAPI_GetIconDimension($hIcon)
Local $iWidth = DllStructGetData($tSIZE, 'X')
Local $iHeight = DllStructGetData($tSIZE, 'Y')
If $iWidth <= 0 Or $iHeight <= 0 Then Return SetError(10, -1, 0)
Local $tBITMAPINFO = DllStructCreate("dword Size;long Width;long Height;word Planes;word BitCount;dword Compression;dword SizeImage;long XPelsPerMeter;long YPelsPerMeter;dword ClrUsed;dword ClrImportant;dword RGBQuad")
DllStructSetData($tBITMAPINFO, 'Size', DllStructGetSize($tBITMAPINFO) - 4)
DllStructSetData($tBITMAPINFO, 'Width', $iWidth)
DllStructSetData($tBITMAPINFO, 'Height', -$iHeight)
DllStructSetData($tBITMAPINFO, 'Planes', 1)
DllStructSetData($tBITMAPINFO, 'BitCount', 32)
DllStructSetData($tBITMAPINFO, 'Compression', 0)
DllStructSetData($tBITMAPINFO, 'SizeImage', 0)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $pBits
Local $hBmp = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $pBits)
Local $hOrig = _WinAPI_SelectObject($hDC, $hBmp)
_WinAPI_DrawIconEx($hDC, 0, 0, $hIcon, $iWidth, $iHeight)
Local $hBitmapIcon = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight, $GDIP_PXF32ARGB, $iWidth * 4, $pBits)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight)
Local $hContext = _GDIPlus_ImageGetGraphicsContext($hBitmap)
_GDIPlus_GraphicsDrawImage($hContext, $hBitmapIcon, 0, 0)
_GDIPlus_GraphicsDispose($hContext)
_GDIPlus_BitmapDispose($hBitmapIcon)
_WinAPI_SelectObject($hDC, $hOrig)
_WinAPI_DeleteDC($hDC)
_WinAPI_DeleteObject($hBmp)
Return $hBitmap
EndFunc
Func _GDIPlus_BitmapGetPixel($hBitmap, $iX, $iY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetPixel", "handle", $hBitmap, "int", $iX, "int", $iY, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_BitmapLockBits($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $iFlags = $GDIP_ILMREAD, $iFormat = $GDIP_PXF32RGB)
Local $tData = DllStructCreate($tagGDIPBITMAPDATA)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iWidth)
DllStructSetData($tRECT, "Bottom", $iHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapLockBits", "handle", $hBitmap, "struct*", $tRECT, "uint", $iFlags, "int", $iFormat, "struct*", $tData)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $tData
EndFunc
Func _GDIPlus_BitmapSetPixel($hBitmap, $iX, $iY, $iARGB)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapSetPixel", "handle", $hBitmap, "int", $iX, "int", $iY, "uint", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapUnlockBits($hBitmap, $tBitmapData)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapUnlockBits", "handle", $hBitmap, "struct*", $tBitmapData)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BrushClone($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneBrush", "handle", $hBrush, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushCreateSolid($iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateSolidFill", "int", $iARGB, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushDispose($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteBrush", "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BrushGetSolidColor($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetSolidFillColor", "handle", $hBrush, "dword*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushGetType($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetBrushType", "handle", $hBrush, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_BrushSetSolidColor($hBrush, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetSolidFillColor", "handle", $hBrush, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ColorMatrixCreate()
Return _GDIPlus_ColorMatrixCreateScale(1, 1, 1, 1)
EndFunc
Func _GDIPlus_ColorMatrixCreateGrayScale()
Local $iI, $iJ, $tCM, $aLums[4] = [$GDIP_RLUM, $GDIP_GLUM, $GDIP_BLUM, 0]
$tCM = DllStructCreate($tagGDIPCOLORMATRIX)
For $iI = 0 To 3
For $iJ = 1 To 3
DllStructSetData($tCM, "m", $aLums[$iI], $iI * 5 + $iJ)
Next
Next
DllStructSetData($tCM, "m", 1, 19)
DllStructSetData($tCM, "m", 1, 25)
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateNegative()
Local $iI, $tCM
$tCM = _GDIPlus_ColorMatrixCreateScale(-1, -1, -1, 1)
For $iI = 1 To 4
DllStructSetData($tCM, "m", 1, 20 + $iI)
Next
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateSaturation($fSat)
Local $fSatComp, $tCM
$tCM = DllStructCreate($tagGDIPCOLORMATRIX)
$fSatComp = (1 - $fSat)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_RLUM + $fSat, 1)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_RLUM, 2)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_RLUM, 3)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_GLUM, 6)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_GLUM + $fSat, 7)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_GLUM, 8)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_BLUM, 11)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_BLUM, 12)
DllStructSetData($tCM, "m", $fSatComp * $GDIP_BLUM + $fSat, 13)
DllStructSetData($tCM, "m", 1, 19)
DllStructSetData($tCM, "m", 1, 25)
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateScale($fRed, $fGreen, $fBlue, $fAlpha = 1)
Local $tCM
$tCM = DllStructCreate($tagGDIPCOLORMATRIX)
DllStructSetData($tCM, "m", $fRed, 1)
DllStructSetData($tCM, "m", $fGreen, 7)
DllStructSetData($tCM, "m", $fBlue, 13)
DllStructSetData($tCM, "m", $fAlpha, 19)
DllStructSetData($tCM, "m", 1, 25)
Return $tCM
EndFunc
Func _GDIPlus_ColorMatrixCreateTranslate($fRed, $fGreen, $fBlue, $fAlpha = 0)
Local $iI, $tCM, $aFactors[4] = [$fRed, $fGreen, $fBlue, $fAlpha]
$tCM = _GDIPlus_ColorMatrixCreate()
For $iI = 0 To 3
DllStructSetData($tCM, "m", $aFactors[$iI], 21 + $iI)
Next
Return $tCM
EndFunc
Func _GDIPlus_CustomLineCapClone($hCustomLineCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneCustomLineCap", "handle", $hCustomLineCap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_CustomLineCapCreate($hPathFill, $hPathStroke, $iLineCap = 0, $nBaseInset = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateCustomLineCap", "handle", $hPathFill, "handle", $hPathStroke, "int", $iLineCap, "float", $nBaseInset, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[5]
EndFunc
Func _GDIPlus_CustomLineCapDispose($hCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteCustomLineCap", "handle", $hCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_CustomLineCapGetStrokeCaps($hCustomLineCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCustomLineCapStrokeCaps", "hwnd", $hCustomLineCap, "ptr*", 0, "ptr*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then SetError(10, $aResult[0], 0)
Local $aCaps[2]
$aCaps[0] = $aResult[2]
$aCaps[1] = $aResult[3]
Return $aCaps
EndFunc
Func _GDIPlus_CustomLineCapSetStrokeCaps($hCustomLineCap, $iStartCap, $iEndCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetCustomLineCapStrokeCaps", "handle", $hCustomLineCap, "int", $iStartCap, "int", $iEndCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_Decoders()
Local $iCount = _GDIPlus_DecodersGetCount()
Local $iSize = _GDIPlus_DecodersGetSize()
Local $tBuffer = DllStructCreate("byte[" & $iSize & "]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageDecoders", "uint", $iCount, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tCodec, $aInfo[$iCount + 1][14]
$aInfo[0][0] = $iCount
For $iI = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pBuffer)
$aInfo[$iI][1] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "CLSID"))
$aInfo[$iI][2] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "FormatID"))
$aInfo[$iI][3] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "CodecName"))
$aInfo[$iI][4] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "DllName"))
$aInfo[$iI][5] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FormatDesc"))
$aInfo[$iI][6] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FileExt"))
$aInfo[$iI][7] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "MimeType"))
$aInfo[$iI][8] = DllStructGetData($tCodec, "Flags")
$aInfo[$iI][9] = DllStructGetData($tCodec, "Version")
$aInfo[$iI][10] = DllStructGetData($tCodec, "SigCount")
$aInfo[$iI][11] = DllStructGetData($tCodec, "SigSize")
$aInfo[$iI][12] = DllStructGetData($tCodec, "SigPattern")
$aInfo[$iI][13] = DllStructGetData($tCodec, "SigMask")
$pBuffer += DllStructGetSize($tCodec)
Next
Return $aInfo
EndFunc
Func _GDIPlus_DecodersGetCount()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[1]
EndFunc
Func _GDIPlus_DecodersGetSize()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_DrawImagePoints($hGraphic, $hImage, $nULX, $nULY, $nURX, $nURY, $nLLX, $nLLY, $iCount = 3)
Local $tPoint = DllStructCreate("float X;float Y;float X2;float Y2;float X3;float Y3")
DllStructSetData($tPoint, "X", $nULX)
DllStructSetData($tPoint, "Y", $nULY)
DllStructSetData($tPoint, "X2", $nURX)
DllStructSetData($tPoint, "Y2", $nURY)
DllStructSetData($tPoint, "X3", $nLLX)
DllStructSetData($tPoint, "Y3", $nLLY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImagePoints", "handle", $hGraphic, "handle", $hImage, "struct*", $tPoint, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_Encoders()
Local $iCount = _GDIPlus_EncodersGetCount()
Local $iSize = _GDIPlus_EncodersGetSize()
Local $tBuffer = DllStructCreate("byte[" & $iSize & "]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncoders", "uint", $iCount, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tCodec, $aInfo[$iCount + 1][14]
$aInfo[0][0] = $iCount
For $iI = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pBuffer)
$aInfo[$iI][1] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "CLSID"))
$aInfo[$iI][2] = _WinAPI_StringFromGUID(DllStructGetPtr($tCodec, "FormatID"))
$aInfo[$iI][3] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "CodecName"))
$aInfo[$iI][4] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "DllName"))
$aInfo[$iI][5] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FormatDesc"))
$aInfo[$iI][6] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "FileExt"))
$aInfo[$iI][7] = _WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, "MimeType"))
$aInfo[$iI][8] = DllStructGetData($tCodec, "Flags")
$aInfo[$iI][9] = DllStructGetData($tCodec, "Version")
$aInfo[$iI][10] = DllStructGetData($tCodec, "SigCount")
$aInfo[$iI][11] = DllStructGetData($tCodec, "SigSize")
$aInfo[$iI][12] = DllStructGetData($tCodec, "SigPattern")
$aInfo[$iI][13] = DllStructGetData($tCodec, "SigMask")
$pBuffer += DllStructGetSize($tCodec)
Next
Return $aInfo
EndFunc
Func _GDIPlus_EncodersGetCLSID($sFileExtension)
Local $aEncoders = _GDIPlus_Encoders()
If @error Then Return SetError(@error, 0, "")
For $iI = 1 To $aEncoders[0][0]
If StringInStr($aEncoders[$iI][6], "*." & $sFileExtension) > 0 Then Return $aEncoders[$iI][1]
Next
Return SetError(-1, -1, "")
EndFunc
Func _GDIPlus_EncodersGetCount()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[1]
EndFunc
Func _GDIPlus_EncodersGetParamList($hImage, $sEncoder)
Local $iSize = _GDIPlus_EncodersGetParamListSize($hImage, $sEncoder)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $iRemainingSize = $iSize - 4 - _GDIPlus_ParamSize()
Local $tBuffer
If $iRemainingSize Then
$tBuffer = DllStructCreate("dword Count;" & $tagGDIPENCODERPARAM & ";byte [" & $iRemainingSize & "]")
Else
$tBuffer = DllStructCreate("dword Count;" & $tagGDIPENCODERPARAM)
EndIf
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEncoderParameterList", "handle", $hImage, "struct*", $tGUID, "uint", $iSize, "struct*", $tBuffer)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $tBuffer
EndFunc
Func _GDIPlus_EncodersGetParamListSize($hImage, $sEncoder)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEncoderParameterListSize", "handle", $hImage, "struct*", $tGUID, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_EncodersGetSize()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_FontCreate($hFamily, $fSize, $iStyle = 0, $iUnit = 3)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFont", "handle", $hFamily, "float", $fSize, "int", $iStyle, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[5]
EndFunc
Func _GDIPlus_FontDispose($hFont)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFont", "handle", $hFont)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontFamilyCreate($sFamily, $pCollection = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFontFamilyFromName", "wstr", $sFamily, "ptr", $pCollection, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyCreateFromCollection($sFontName, $hFontCollection)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFontFamilyFromName", "wstr", $sFontName, "ptr", $hFontCollection, "ptr*", 0)
If @error Then Return SetError(@error, @extended, "")
If $aResult[0] Then Return SetError(10, $aResult[0], "")
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyDispose($hFamily)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteFontFamily", "handle", $hFamily)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontFamilyGetCellAscent($hFontFamily, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCellAscent", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyGetCellDescent($hFontFamily, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCellDescent", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyGetEmHeight($hFontFamily, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEmHeight", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontFamilyGetLineSpacing($hFontFamily, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetLineSpacing", "handle", $hFontFamily, "int", $iStyle, "ushort*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontGetHeight($hFont, $hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetFontHeight", "handle", $hFont, "handle", $hGraphics, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_FontPrivateAddFont($hFontCollection, $sFontFile)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPrivateAddFontFile", "ptr", $hFontCollection, "wstr", $sFontFile)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontPrivateAddMemoryFont($hFontCollection, $tFont)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPrivateAddMemoryFont", "handle", $hFontCollection, "struct*", $tFont, "int", DllStructGetSize($tFont))
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontPrivateCollectionDispose($hFontCollection)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePrivateFontCollection", "handle*", $hFontCollection)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_FontPrivateCreateCollection()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipNewPrivateFontCollection", "ptr*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_GraphicsClear($hGraphics, $iARGB = 0xFF000000)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGraphicsClear", "handle", $hGraphics, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsCreateFromHDC($hDC)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFromHDC", "handle", $hDC, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsCreateFromHWND($hWnd)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateFromHWND", "hwnd", $hWnd, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsDispose($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteGraphics", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawArc($hGraphics, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawArc", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawBezier($hGraphics, $nX1, $nY1, $nX2, $nY2, $nX3, $nY3, $nX4, $nY4, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawBezier", "handle", $hGraphics, "handle", $hPen, "float", $nX1, "float", $nY1,  "float", $nX2, "float", $nY2, "float", $nX3, "float", $nY3, "float", $nX4, "float", $nY4)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawClosedCurve($hGraphics, $aPoints, $hPen = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawClosedCurve", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawClosedCurve2($hGraphics, $aPoints, $nTension, $hPen = 0)
Local $iI, $iCount, $tPoints, $aResult
__GDIPlus_PenDefCreate($hPen)
$iCount = $aPoints[0][0]
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawClosedCurve2", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount, "float", $nTension)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawCurve($hGraphics, $aPoints, $hPen = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawCurve", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawCurve2($hGraphics, $aPoints, $nTension, $hPen = 0)
Local $iI, $iCount, $tPoints, $aResult
__GDIPlus_PenDefCreate($hPen)
$iCount = $aPoints[0][0]
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawCurve2", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount, "float", $nTension)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawEllipse($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawEllipse", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImage($hGraphics, $hImage, $nX, $nY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImage", "handle", $hGraphics, "handle", $hImage, "float", $nX, "float", $nY)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImagePointsRect($hGraphics, $hImage, $nULX, $nULY, $nURX, $nURY, $nLLX, $nLLY, $nSrcX, $nSrcY, $nSrcWidth, $nSrcHeight, $hImageAttributes = 0, $iUnit = 2)
Local $tPoints = DllStructCreate("float X; float Y; float X2; float Y2; float X3; float Y3;")
DllStructSetData($tPoints, "X", $nULX)
DllStructSetData($tPoints, "Y", $nULY)
DllStructSetData($tPoints, "X2", $nURX)
DllStructSetData($tPoints, "Y2", $nURY)
DllStructSetData($tPoints, "X3", $nLLX)
DllStructSetData($tPoints, "Y3", $nLLY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImagePointsRect", "handle", $hGraphics, "handle", $hImage, "struct*", $tPoints, "int", 3, "float", $nSrcX, "float", $nSrcY, "float", $nSrcWidth, "float", $nSrcHeight, "int", $iUnit, "handle", $hImageAttributes, "ptr", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImageRect($hGraphics, $hImage, $nX, $nY, $nW, $nH)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImageRect", "handle", $hGraphics, "handle", $hImage, "float", $nX, "float", $nY,  "float", $nW, "float", $nH)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawImageRectRect($hGraphics, $hImage, $nSrcX, $nSrcY, $nSrcWidth, $nSrcHeight, $nDstX, $nDstY, $nDstWidth, $nDstHeight, $pAttributes = 0, $iUnit = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImageRectRect", "handle", $hGraphics, "handle", $hImage,  "float", $nDstX, "float", $nDstY, "float", $nDstWidth, "float", $nDstHeight,  "float", $nSrcX, "float", $nSrcY, "float", $nSrcWidth, "float", $nSrcHeight,  "int", $iUnit, "handle", $pAttributes, "ptr", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawLine($hGraphics, $nX1, $nY1, $nX2, $nY2, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawLine", "handle", $hGraphics, "handle", $hPen, "float", $nX1, "float", $nY1,  "float", $nX2, "float", $nY2)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawPath($hGraphics, $hPath, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawPath", "handle", $hGraphics, "handle", $hPen, "handle", $hPath)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawPie($hGraphics, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawPie", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawPolygon($hGraphics, $aPoints, $hPen = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawPolygon", "handle", $hGraphics, "handle", $hPen, "struct*", $tPoints, "int", $iCount)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hPen = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawRectangle", "handle", $hGraphics, "handle", $hPen, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsDrawString($hGraphics, $sString, $nX, $nY, $sFont = "Arial", $fSize = 10, $iFormat = 0)
Local $hBrush = _GDIPlus_BrushCreateSolid()
Local $hFormat = _GDIPlus_StringFormatCreate($iFormat)
Local $hFamily = _GDIPlus_FontFamilyCreate($sFont)
Local $hFont = _GDIPlus_FontCreate($hFamily, $fSize)
Local $tLayout = _GDIPlus_RectFCreate($nX, $nY, 0.0, 0.0)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult = _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
Local $iError = @error, $iExtended = @extended
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
Return SetError($iError, $iExtended, $aResult)
EndFunc
Func _GDIPlus_GraphicsDrawStringEx($hGraphics, $sString, $hFont, $tLayout, $hFormat, $hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont,  "struct*", $tLayout, "handle", $hFormat, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillClosedCurve($hGraphics, $aPoints, $hBrush = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillClosedCurve", "handle", $hGraphics, "handle", $hBrush, "struct*", $tPoints, "int", $iCount)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillClosedCurve2($hGraphics, $aPoints, $nTension, $hBrush = 0, $iFillMode = 0)
Local $iI, $iCount, $tPoints, $aResult
__GDIPlus_BrushDefCreate($hBrush)
$iCount = $aPoints[0][0]
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipFillClosedCurve2", "handle", $hGraphics, "handle", $hBrush, "struct*", $tPoints, "int", $iCount, "float", $nTension, "int", $iFillMode)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillEllipse($hGraphics, $nX, $nY, $nWidth, $nHeight, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillEllipse", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillPath($hGraphics, $hPath, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillPath", "handle", $hGraphics, "handle", $hBrush, "handle", $hPath)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillPie($hGraphics, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillPie", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillPolygon($hGraphics, $aPoints, $hBrush = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillPolygon", "handle", $hGraphics, "handle", $hBrush,  "struct*", $tPoints, "int", $iCount, "int", "FillModeAlternate")
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillRectangle", "handle", $hGraphics, "handle", $hBrush, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsFillRegion($hGraphics, $hRegion, $hBrush = 0)
__GDIPlus_BrushDefCreate($hBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFillRegion", "handle", $hGraphics, "handle", $hBrush, "handle", $hRegion)
__GDIPlus_BrushDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsGetCompositingMode($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCompositingMode", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsGetCompositingQuality($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetCompositingQuality", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsGetDC($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetDC", "handle", $hGraphics, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsGetInterpolationMode($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetInterpolationMode", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsGetSmoothingMode($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetSmoothingMode", "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Switch $aResult[2]
Case $GDIP_SMOOTHINGMODE_NONE
Return 0
Case $GDIP_SMOOTHINGMODE_HIGHQUALITY, $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
Return 1
Case $GDIP_SMOOTHINGMODE_ANTIALIAS8X8
Return 2
Case Else
Return 0
EndSwitch
EndFunc
Func _GDIPlus_GraphicsGetTransform($hGraphics, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetWorldTransform", "handle", $hGraphics, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsMeasureCharacterRanges($hGraphics, $sString, $hFont, $tLayout, $hStringFormat)
Local $iCount = _GDIPlus_StringFormatGetMeasurableCharacterRangeCount($hStringFormat)
If @error Then Return SetError(@error, @extended, 0)
Local $tRegions = DllStructCreate("handle[" & $iCount & "]")
Local $aRegions[$iCount + 1] = [$iCount]
For $iI = 1 To $iCount
$aRegions[$iI] = _GDIPlus_RegionCreate()
DllStructSetData($tRegions, 1, $aRegions[$iI], $iI)
Next
DllCall($__g_hGDIPDll, "int", "GdipMeasureCharacterRanges", "handle", $hGraphics, "wstr", $sString, "int", -1, "hwnd", $hFont, "struct*", $tLayout, "handle", $hStringFormat, "int", $iCount, "struct*", $tRegions)
Local $iError = @error, $iExtended = @extended
If $iError Then
For $iI = 1 To $iCount
_GDIPlus_RegionDispose($aRegions[$iI])
Next
Return SetError($iError + 10, $iExtended, 0)
EndIf
Return $aRegions
EndFunc
Func _GDIPlus_GraphicsMeasureString($hGraphics, $sString, $hFont, $tLayout, $hFormat)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMeasureString", "handle", $hGraphics, "wstr", $sString, "int", -1, "handle", $hFont,  "struct*", $tLayout, "handle", $hFormat, "struct*", $tRECTF, "int*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $aInfo[3]
$aInfo[0] = $tRECTF
$aInfo[1] = $aResult[8]
$aInfo[2] = $aResult[9]
Return $aInfo
EndFunc
Func _GDIPlus_GraphicsReleaseDC($hGraphics, $hDC)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipReleaseDC", "handle", $hGraphics, "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsResetClip($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetClip", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsResetTransform($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetWorldTransform", "handle", $hGraphics)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsRestore($hGraphics, $iState)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipRestoreGraphics", "handle", $hGraphics, "uint", $iState)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsRotateTransform($hGraphics, $fAngle, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipRotateWorldTransform", "handle", $hGraphics, "float", $fAngle, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSave($hGraphics)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveGraphics", "handle", $hGraphics, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_GraphicsScaleTransform($hGraphics, $fScaleX, $fScaleY, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipScaleWorldTransform", "handle", $hGraphics, "float", $fScaleX, "float", $fScaleY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetClipPath($hGraphics, $hPath, $iCombineMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetClipPath", "handle", $hGraphics, "handle", $hPath, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetClipRect($hGraphics, $nX, $nY, $nWidth, $nHeight, $iCombineMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetClipRect", "handle", $hGraphics, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetClipRegion($hGraphics, $hRegion, $iCombineMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetClipRegion", "handle", $hGraphics, "handle", $hRegion, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetCompositingMode($hGraphics, $iCompositionMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetCompositingMode", "handle", $hGraphics, "int", $iCompositionMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetCompositingQuality($hGraphics, $iCompositionQuality)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetCompositingQuality", "handle", $hGraphics, "int", $iCompositionQuality)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetInterpolationMode($hGraphics, $iInterpolationMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetInterpolationMode", "handle", $hGraphics, "int", $iInterpolationMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetPixelOffsetMode($hGraphics, $iPixelOffsetMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPixelOffsetMode", "handle", $hGraphics, "int", $iPixelOffsetMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetSmoothingMode($hGraphics, $iSmooth)
If $iSmooth < $GDIP_SMOOTHINGMODE_DEFAULT Or $iSmooth > $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 Then $iSmooth = $GDIP_SMOOTHINGMODE_DEFAULT
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetSmoothingMode", "handle", $hGraphics, "int", $iSmooth)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetTextRenderingHint($hGraphics, $iTextRenderingHint)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetTextRenderingHint", "handle", $hGraphics, "int", $iTextRenderingHint)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsSetTransform($hGraphics, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetWorldTransform", "handle", $hGraphics, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_GraphicsTransformPoints($hGraphics, ByRef $aPoints, $iCoordSpaceTo = 0, $iCoordSpaceFrom = 1)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], ($iI - 1) * 2 + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], ($iI - 1) * 2 + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTransformPoints", "handle", $hGraphics, "int", $iCoordSpaceTo, "int", $iCoordSpaceFrom, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
For $iI = 1 To $iCount
$aPoints[$iI][0] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 1)
$aPoints[$iI][1] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 2)
Next
Return True
EndFunc
Func _GDIPlus_GraphicsTranslateTransform($hGraphics, $nDX, $nDY, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTranslateWorldTransform", "handle", $hGraphics, "float", $nDX, "float", $nDY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_HatchBrushCreate($iHatchStyle = 0, $iARGBForeground = 0xFFFFFFFF, $iARGBBackground = 0xFFFFFFFF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateHatchBrush", "int", $iHatchStyle, "uint", $iARGBForeground, "uint", $iARGBBackground, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_HICONCreateFromBitmap($hBitmap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateHICONFromBitmap", "handle", $hBitmap, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageAttributesCreate()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateImageAttributes", "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_ImageAttributesDispose($hImageAttributes)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImageAttributes", "handle", $hImageAttributes)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetColorKeys($hImageAttributes, $iColorAdjustType = 0, $bEnable = False, $iARGBLow = 0, $iARGBHigh = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesColorKeys", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "uint", $iARGBLow, "uint", $iARGBHigh)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageAttributesSetColorMatrix($hImageAttributes, $iColorAdjustType = 0, $bEnable = False, $tClrMatrix = 0, $tGrayMatrix = 0, $iColorMatrixFlags = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetImageAttributesColorMatrix", "handle", $hImageAttributes, "int", $iColorAdjustType, "int", $bEnable, "struct*", $tClrMatrix, "struct*", $tGrayMatrix, "int", $iColorMatrixFlags)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageDispose($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDisposeImage", "handle", $hImage)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageGetDimension($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageDimension", "handle", $hImage, "float*", 0, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Local $aImgDim[2] = [$aResult[2], $aResult[3]]
Return $aImgDim
EndFunc
Func _GDIPlus_ImageGetFlags($hImage)
Local $aFlag[2] = [0, ""]
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, $aFlag)
Local $aImageFlags[13][2] =  [["Pixel data Cacheable", $GDIP_IMAGEFLAGS_CACHING],  ["Pixel data read-only", $GDIP_IMAGEFLAGS_READONLY],  ["Pixel size in image", $GDIP_IMAGEFLAGS_HASREALPIXELSIZE],  ["DPI info in image", $GDIP_IMAGEFLAGS_HASREALDPI],  ["YCCK color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCCK],  ["YCBCR color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR],  ["Grayscale image", $GDIP_IMAGEFLAGS_COLORSPACE_GRAY],  ["CMYK color space", $GDIP_IMAGEFLAGS_COLORSPACE_CMYK],  ["RGB color space", $GDIP_IMAGEFLAGS_COLORSPACE_RGB],  ["Partially scalable", $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE],  ["Alpha values other than 0 (transparent) and 255 (opaque)", $GDIP_IMAGEFLAGS_HASTRANSLUCENT],  ["Alpha values", $GDIP_IMAGEFLAGS_HASALPHA],  ["Scalable", $GDIP_IMAGEFLAGS_SCALABLE]]
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageFlags", "handle", $hImage, "long*", 0)
If @error Then Return SetError(@error, @extended, $aFlag)
If $aResult[0] Then Return SetError(10, $aResult[0], $aFlag)
If $aResult[2] = $GDIP_IMAGEFLAGS_NONE Then
$aFlag[1] = "No pixel data"
Return SetError(12, $aResult[2], $aFlag)
EndIf
$aFlag[0] = $aResult[2]
For $i = 0 To 12
If BitAND($aResult[2], $aImageFlags[$i][1]) = $aImageFlags[$i][1] Then
If StringLen($aFlag[1]) Then $aFlag[1] &= "|"
$aResult[2] -= $aImageFlags[$i][1]
$aFlag[1] &= $aImageFlags[$i][0]
EndIf
Next
Return $aFlag
EndFunc
Func _GDIPlus_ImageGetGraphicsContext($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageGraphicsContext", "handle", $hImage, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetHeight($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageHeight", "handle", $hImage, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetHorizontalResolution($hImage)
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageHorizontalResolution", "handle", $hImage, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return Round($aResult[2])
EndFunc
Func _GDIPlus_ImageGetPixelFormat($hImage)
Local $aFormat[2] = [0, ""]
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, $aFormat)
Local $aPixelFormat[14][2] =  [["1 Bpp Indexed", $GDIP_PXF01INDEXED],  ["4 Bpp Indexed", $GDIP_PXF04INDEXED],  ["8 Bpp Indexed", $GDIP_PXF08INDEXED],  ["16 Bpp Grayscale", $GDIP_PXF16GRAYSCALE],  ["16 Bpp RGB 555", $GDIP_PXF16RGB555],  ["16 Bpp RGB 565", $GDIP_PXF16RGB565],  ["16 Bpp ARGB 1555", $GDIP_PXF16ARGB1555],  ["24 Bpp RGB", $GDIP_PXF24RGB],  ["32 Bpp RGB", $GDIP_PXF32RGB],  ["32 Bpp ARGB", $GDIP_PXF32ARGB],  ["32 Bpp PARGB", $GDIP_PXF32PARGB],  ["48 Bpp RGB", $GDIP_PXF48RGB],  ["64 Bpp ARGB", $GDIP_PXF64ARGB],  ["64 Bpp PARGB", $GDIP_PXF64PARGB]]
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImagePixelFormat", "handle", $hImage, "int*", 0)
If @error Then Return SetError(@error, @extended, $aFormat)
If $aResult[0] Then Return SetError(10, $aResult[0], $aFormat)
For $i = 0 To 13
If $aPixelFormat[$i][1] = $aResult[2] Then
$aFormat[0] = $aPixelFormat[$i][1]
$aFormat[1] = $aPixelFormat[$i][0]
Return $aFormat
EndIf
Next
Return SetError(12, 0, $aFormat)
EndFunc
Func _GDIPlus_ImageGetRawFormat($hImage)
Local $aGuid[2]
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, $aGuid)
Local $aImageType[11][2] =  [["UNDEFINED", $GDIP_IMAGEFORMAT_UNDEFINED],  ["MEMORYBMP", $GDIP_IMAGEFORMAT_MEMORYBMP],  ["BMP", $GDIP_IMAGEFORMAT_BMP],  ["EMF", $GDIP_IMAGEFORMAT_EMF],  ["WMF", $GDIP_IMAGEFORMAT_WMF],  ["JPEG", $GDIP_IMAGEFORMAT_JPEG],  ["PNG", $GDIP_IMAGEFORMAT_PNG],  ["GIF", $GDIP_IMAGEFORMAT_GIF],  ["TIFF", $GDIP_IMAGEFORMAT_TIFF],  ["EXIF", $GDIP_IMAGEFORMAT_EXIF],  ["ICON", $GDIP_IMAGEFORMAT_ICON]]
Local $tStruct = DllStructCreate("byte[16]")
Local $aResult1 = DllCall($__g_hGDIPDll, "int", "GdipGetImageRawFormat", "handle", $hImage, "struct*", $tStruct)
If @error Then Return SetError(@error, @extended, $aGuid)
If $aResult1[0] Then Return SetError(10, $aResult1[0], $aGuid)
Local $sResult2 = _WinAPI_StringFromGUID($aResult1[2])
If @error Then Return SetError(@error + 20, @extended, $aGuid)
If $sResult2 = "" Then Return SetError(12, 0, $aGuid)
For $i = 0 To 10
If $aImageType[$i][1] == $sResult2 Then
$aGuid[0] = $aImageType[$i][1]
$aGuid[1] = $aImageType[$i][0]
Return $aGuid
EndIf
Next
Return SetError(13, 0, $aGuid)
EndFunc
Func _GDIPlus_ImageGetThumbnail($hImage, $iWidth = 0, $iHeight = 0, $bKeepRatio = True, $hCallback = Null, $hCallbackData = Null)
If $bKeepRatio Then
Local $aImgDim = _GDIPlus_ImageGetDimension($hImage)
If @error Then Return SetError(@error + 20, @extended, False)
Local $f
If $iWidth < 1 Or $iHeight < 1 Then
$iWidth = 0
$iHeight = 0
Else
If ($aImgDim[0] / $aImgDim[1]) > 1 Then
$f = $aImgDim[0] / $iWidth
Else
$f = $aImgDim[1] / $iHeight
EndIf
$iWidth = Int($aImgDim[0] / $f)
$iHeight = Int($aImgDim[1] / $f)
EndIf
EndIf
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageThumbnail", "handle", $hImage, "uint", $iWidth, "uint", $iHeight, "ptr*", 0, "ptr", $hCallback, "ptr", $hCallbackData)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return $aResult[4]
EndFunc
Func _GDIPlus_ImageGetType($hImage)
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, -1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageType", "handle", $hImage, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageGetVerticalResolution($hImage)
If ($hImage = -1) Or (Not $hImage) Then Return SetError(11, 0, 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageVerticalResolution", "handle", $hImage, "float*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return Round($aResult[2])
EndFunc
Func _GDIPlus_ImageGetWidth($hImage)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetImageWidth", "handle", $hImage, "uint*", -1)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageLoadFromFile($sFileName)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipLoadImageFromFile", "wstr", $sFileName, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageLoadFromStream($pStream)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipLoadImageFromStream", "ptr", $pStream, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_ImageRotateFlip($hImage, $iRotateFlipType)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipImageRotateFlip", "handle", $hImage, "int", $iRotateFlipType)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveToFile($hImage, $sFileName)
Local $sExt = __GDIPlus_ExtractFileExt($sFileName)
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-1, 0, False)
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, 0)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sEncoder, $tParams = 0)
Local $tGUID = _WinAPI_GUIDFromString($sEncoder)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveImageToFile", "handle", $hImage, "wstr", $sFileName, "struct*", $tGUID, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageSaveToStream($hImage, $pStream, $tEncoder, $tParams = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSaveImageToStream", "handle", $hImage, "ptr", $pStream, "struct*", $tEncoder, "struct*", $tParams)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ImageScale($hImage, $iScaleW, $iScaleH, $iInterpolationMode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
Local $iWidth = _GDIPlus_ImageGetWidth($hImage) * $iScaleW
If @error Then Return SetError(1, 0, 0)
Local $iHeight = _GDIPlus_ImageGetHeight($hImage) * $iScaleH
If @error Then Return SetError(2, 0, 0)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight)
If @error Then Return SetError(3, 0, 0)
Local $hBmpCtxt = _GDIPlus_ImageGetGraphicsContext($hBitmap)
If @error Then
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(4, 0, 0)
EndIf
_GDIPlus_GraphicsSetInterpolationMode($hBmpCtxt, $iInterpolationMode)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(5, 0, 0)
EndIf
_GDIPlus_GraphicsDrawImageRect($hBmpCtxt, $hImage, 0, 0, $iWidth, $iHeight)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(6, 0, 0)
EndIf
_GDIPlus_GraphicsDispose($hBmpCtxt)
Return $hBitmap
EndFunc
Func _GDIPlus_ImageResize($hImage, $iNewWidth, $iNewHeight, $iInterpolationMode = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
Local $hBitmap = _GDIPlus_BitmapCreateFromScan0($iNewWidth, $iNewHeight)
If @error Then Return SetError(1, 0, 0)
Local $hBmpCtxt = _GDIPlus_ImageGetGraphicsContext($hBitmap)
If @error Then
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(2, @extended, 0)
EndIf
_GDIPlus_GraphicsSetInterpolationMode($hBmpCtxt, $iInterpolationMode)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(3, @extended, 0)
EndIf
_GDIPlus_GraphicsDrawImageRect($hBmpCtxt, $hImage, 0, 0, $iNewWidth, $iNewHeight)
If @error Then
_GDIPlus_GraphicsDispose($hBmpCtxt)
_GDIPlus_BitmapDispose($hBitmap)
Return SetError(4, @extended, 0)
EndIf
_GDIPlus_GraphicsDispose($hBmpCtxt)
Return $hBitmap
EndFunc
Func _GDIPlus_LineBrushCreate($nX1, $nY1, $nX2, $nY2, $iARGBClr1, $iARGBClr2, $iWrapMode = 0)
Local $tPointF1, $tPointF2, $aResult
$tPointF1 = DllStructCreate("float;float")
$tPointF2 = DllStructCreate("float;float")
DllStructSetData($tPointF1, 1, $nX1)
DllStructSetData($tPointF1, 2, $nY1)
DllStructSetData($tPointF2, 1, $nX2)
DllStructSetData($tPointF2, 2, $nY2)
$aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateLineBrush", "struct*", $tPointF1, "struct*", $tPointF2, "uint", $iARGBClr1, "uint", $iARGBClr2, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_LineBrushCreateFromRect($tRECTF, $iARGBClr1, $iARGBClr2, $iGradientMode = 0, $iWrapMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateLineBrushFromRect", "struct*", $tRECTF, "uint", $iARGBClr1, "uint", $iARGBClr2, "int", $iGradientMode, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_LineBrushCreateFromRectWithAngle($tRECTF, $iARGBClr1, $iARGBClr2, $fAngle, $bIsAngleScalable = True, $iWrapMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateLineBrushFromRectWithAngle", "struct*", $tRECTF, "uint", $iARGBClr1, "uint", $iARGBClr2, "float", $fAngle, "int", $bIsAngleScalable, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_LineBrushGetColors($hLineGradientBrush)
Local $tARGBs, $aARGBs[2], $aResult
$tARGBs = DllStructCreate("uint;uint")
$aResult = DllCall($__g_hGDIPDll, "uint", "GdipGetLineColors", "handle", $hLineGradientBrush, "struct*", $tARGBs)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
$aARGBs[0] = DllStructGetData($tARGBs, 1)
$aARGBs[1] = DllStructGetData($tARGBs, 2)
Return $aARGBs
EndFunc
Func _GDIPlus_LineBrushGetRect($hLineGradientBrush)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetLineRect", "handle", $hLineGradientBrush, "struct*", $tRECTF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aRectF[4]
For $iI = 1 To 4
$aRectF[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aRectF
EndFunc
Func _GDIPlus_LineBrushMultiplyTransform($hLineGradientBrush, $hMatrix, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMultiplyLineTransform", "handle", $hLineGradientBrush, "handle", $hMatrix, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushResetTransform($hLineGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetLineTransform", "handle", $hLineGradientBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetBlend($hLineGradientBrush, $aBlends)
Local $iI, $iCount, $tFactors, $tPositions, $aResult
$iCount = $aBlends[0][0]
$tFactors = DllStructCreate("float[" & $iCount & "]")
$tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tFactors, 1, $aBlends[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aBlends[$iI][1], $iI)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineBlend", "handle", $hLineGradientBrush, "struct*", $tFactors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetColors($hLineGradientBrush, $iARGBStart, $iARGBEnd)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineColors", "handle", $hLineGradientBrush, "uint", $iARGBStart, "uint", $iARGBEnd)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetGammaCorrection($hLineGradientBrush, $bUseGammaCorrection = True)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineGammaCorrection", "handle", $hLineGradientBrush, "int", $bUseGammaCorrection)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetLinearBlend($hLineGradientBrush, $fFocus, $fScale = 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineLinearBlend", "handle", $hLineGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetPresetBlend($hLineGradientBrush, $aInterpolations)
Local $iI, $iCount, $tColors, $tPositions, $aResult
$iCount = $aInterpolations[0][0]
$tColors = DllStructCreate("uint[" & $iCount & "]")
$tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tColors, 1, $aInterpolations[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aInterpolations[$iI][1], $iI)
Next
$aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLinePresetBlend", "handle", $hLineGradientBrush, "struct*", $tColors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetSigmaBlend($hLineGradientBrush, $fFocus, $fScale = 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineSigmaBlend", "handle", $hLineGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_LineBrushSetTransform($hLineGradientBrush, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetLineTransform", "handle", $hLineGradientBrush, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixCreate()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateMatrix", "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_MatrixClone($hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneMatrix", "handle", $hMatrix, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_MatrixDispose($hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteMatrix", "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixGetElements($hMatrix)
Local $tElements = DllStructCreate("float[6]")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetMatrixElements", "handle", $hMatrix, "struct*", $tElements)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aElements[6]
For $iI = 1 To 6
$aElements[$iI - 1] = DllStructGetData($tElements, 1, $iI)
Next
Return $aElements
EndFunc
Func _GDIPlus_MatrixInvert($hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipInvertMatrix", "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixMultiply($hMatrix1, $hMatrix2, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMultiplyMatrix", "handle", $hMatrix1, "handle", $hMatrix2, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixRotate($hMatrix, $fAngle, $bAppend = False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipRotateMatrix", "handle", $hMatrix, "float", $fAngle, "int", $bAppend)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixScale($hMatrix, $fScaleX, $fScaleY, $bOrder = False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipScaleMatrix", "handle", $hMatrix, "float", $fScaleX, "float", $fScaleY, "int", $bOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixSetElements($hMatrix, $nM11 = 1, $nM12 = 0, $nM21 = 0, $nM22 = 1, $nDX = 0, $nDY = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetMatrixElements", "handle", $hMatrix, "float", $nM11, "float", $nM12,  "float", $nM21, "float", $nM22, "float", $nDX, "float", $nDY)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixShear($hMatrix, $fShearX, $fShearY, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipShearMatrix", "handle", $hMatrix, "float", $fShearX, "float", $fShearY, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_MatrixTransformPoints($hMatrix, ByRef $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], ($iI - 1) * 2 + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], ($iI - 1) * 2 + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTransformMatrixPoints", "handle", $hMatrix, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
For $iI = 1 To $iCount
$aPoints[$iI][0] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 1)
$aPoints[$iI][1] = DllStructGetData($tPoints, 1, ($iI - 1) * 2 + 2)
Next
Return True
EndFunc
Func _GDIPlus_MatrixTranslate($hMatrix, $fOffsetX, $fOffsetY, $bAppend = False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTranslateMatrix", "handle", $hMatrix, "float", $fOffsetX, "float", $fOffsetY, "int", $bAppend)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_ParamAdd(ByRef $tParams, $sGUID, $iNbOfValues, $iType, $pValues)
Local $iCount = DllStructGetData($tParams, "Count")
Local $pGUID = DllStructGetPtr($tParams, "GUID") + ($iCount * _GDIPlus_ParamSize())
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM, $pGUID)
_WinAPI_GUIDFromStringEx($sGUID, $pGUID)
DllStructSetData($tParam, "Type", $iType)
DllStructSetData($tParam, "NumberOfValues", $iNbOfValues)
DllStructSetData($tParam, "Values", $pValues)
DllStructSetData($tParams, "Count", $iCount + 1)
EndFunc
Func _GDIPlus_ParamInit($iCount)
Local $sStruct = $tagGDIPENCODERPARAMS
For $i = 2 To $iCount
$sStruct &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
Next
Return DllStructCreate($sStruct)
EndFunc
Func _GDIPlus_ParamSize()
Local $tParam = DllStructCreate($tagGDIPENCODERPARAM)
Return DllStructGetSize($tParam)
EndFunc
Func _GDIPlus_PathAddArc($hPath, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathArc", "handle", $hPath, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddBezier($hPath, $nX1, $nY1, $nX2, $nY2, $nX3, $nY3, $nX4, $nY4)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathBezier", "handle", $hPath, "float", $nX1, "float", $nY1, "float", $nX2, "float", $nY2, "float", $nX3, "float", $nY3, "float", $nX4, "float", $nY4)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddClosedCurve($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathClosedCurve", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddClosedCurve2($hPath, $aPoints, $nTension = 0.5)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathClosedCurve2", "handle", $hPath, "struct*", $tPoints, "int", $iCount, "float", $nTension)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddCurve($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathCurve", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddCurve2($hPath, $aPoints, $nTension = 0.5)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathCurve2", "handle", $hPath, "struct*", $tPoints, "int", $iCount, "float", $nTension)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddCurve3($hPath, $aPoints, $iOffset, $iNumOfSegments, $nTension = 0.5)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathCurve3", "handle", $hPath, "struct*", $tPoints, "int", $iCount, "int", $iOffset, "int", $iNumOfSegments, "float", $nTension)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddEllipse($hPath, $nX, $nY, $nWidth, $nHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathEllipse", "handle", $hPath, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddLine($hPath, $nX1, $nY1, $nX2, $nY2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathLine", "handle", $hPath, "float", $nX1, "float", $nY1, "float", $nX2, "float", $nY2)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddLine2($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathLine2", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddPath($hPath1, $hPath2, $bConnect = True)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathPath", "handle", $hPath1, "handle", $hPath2, "int", $bConnect)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddPie($hPath, $nX, $nY, $nWidth, $nHeight, $fStartAngle, $fSweepAngle)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathPie", "handle", $hPath, "float", $nX, "float", $nY,  "float", $nWidth, "float", $nHeight, "float", $fStartAngle, "float", $fSweepAngle)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddPolygon($hPath, $aPoints)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathPolygon", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddRectangle($hPath, $nX, $nY, $nWidth, $nHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathRectangle", "handle", $hPath, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathAddString($hPath, $sString, $tLayout, $hFamily, $iStyle = 0, $fSize = 8.5, $hFormat = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipAddPathString", "handle", $hPath, "wstr", $sString, "int", -1,  "handle", $hFamily, "int", $iStyle, "float", $fSize, "struct*", $tLayout, "handle", $hFormat)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushCreate($aPoints, $iWrapMode = 0)
Local $iCount = $aPoints[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePathGradient", "struct*", $tPoints, "int", $iCount, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_PathBrushCreateFromPath($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePathGradientFromPath", "handle", $hPath, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathBrushGetCenterPoint($hPathGradientBrush)
Local $tPointF = DllStructCreate("float;float")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientCenterPoint", "handle", $hPathGradientBrush, "struct*", $tPointF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aPointF[2]
$aPointF[0] = DllStructGetData($tPointF, 1)
$aPointF[1] = DllStructGetData($tPointF, 2)
Return $aPointF
EndFunc
Func _GDIPlus_PathBrushGetFocusScales($hPathGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientFocusScales", "handle", $hPathGradientBrush, "float*", 0, "float*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aScales[2]
$aScales[0] = $aResult[2]
$aScales[1] = $aResult[3]
Return $aScales
EndFunc
Func _GDIPlus_PathBrushGetPointCount($hPathGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientPointCount", "handle", $hPathGradientBrush, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathBrushGetRect($hPathGradientBrush)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientRect", "handle", $hPathGradientBrush, "struct*", $tRECTF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aRectF[4]
For $iI = 1 To 4
$aRectF[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aRectF
EndFunc
Func _GDIPlus_PathBrushGetWrapMode($hPathGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathGradientWrapMode", "handle", $hPathGradientBrush, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathBrushMultiplyTransform($hPathGradientBrush, $hMatrix, $iOrder = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipMultiplyPathGradientTransform", "handle", $hPathGradientBrush, "handle", $hMatrix, "int", $iOrder)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushResetTransform($hPathGradientBrush)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetPathGradientTransform", "handle", $hPathGradientBrush)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetBlend($hPathGradientBrush, $aBlends)
Local $iCount = $aBlends[0][0]
Local $tFactors = DllStructCreate("float[" & $iCount & "]")
Local $tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tFactors, 1, $aBlends[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aBlends[$iI][1], $iI)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientBlend", "handle", $hPathGradientBrush, "struct*", $tFactors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetCenterColor($hPathGradientBrush, $iARGB)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientCenterColor", "handle", $hPathGradientBrush, "uint", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetCenterPoint($hPathGradientBrush, $nX, $nY)
Local $tPointF = DllStructCreate("float;float")
DllStructSetData($tPointF, 1, $nX)
DllStructSetData($tPointF, 2, $nY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientCenterPoint", "handle", $hPathGradientBrush, "struct*", $tPointF)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetFocusScales($hPathGradientBrush, $fScaleX, $fScaleY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientFocusScales", "handle", $hPathGradientBrush, "float", $fScaleX, "float", $fScaleY)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetGammaCorrection($hPathGradientBrush, $bUseGammaCorrection)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientGammaCorrection", "handle", $hPathGradientBrush, "int", $bUseGammaCorrection)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetLinearBlend($hPathGradientBrush, $fFocus, $fScale = 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientLinearBlend", "handle", $hPathGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetPresetBlend($hPathGradientBrush, $aInterpolations)
Local $iCount = $aInterpolations[0][0]
Local $tColors = DllStructCreate("uint[" & $iCount & "]")
Local $tPositions = DllStructCreate("float[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tColors, 1, $aInterpolations[$iI][0], $iI)
DllStructSetData($tPositions, 1, $aInterpolations[$iI][1], $iI)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientPresetBlend", "handle", $hPathGradientBrush, "struct*", $tColors, "struct*", $tPositions, "int", $iCount)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetSigmaBlend($hPathGradientBrush, $fFocus, $fScale = 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientSigmaBlend", "handle", $hPathGradientBrush, "float", $fFocus, "float", $fScale)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetSurroundColor($hPathGradientBrush, $iARGB)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hPathGradientBrush, "uint*", $iARGB, "int*", 1)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetSurroundColorsWithCount($hPathGradientBrush, $aColors)
Local $iCount = $aColors[0]
Local $iColors = _GDIPlus_PathBrushGetPointCount($hPathGradientBrush)
If $iColors < $iCount Then $iCount = $iColors
Local $tColors = DllStructCreate("uint[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tColors, 1, $aColors[$iI], $iI)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hPathGradientBrush, "struct*", $tColors, "int*", $iCount)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_PathBrushSetTransform($hPathGradientBrush, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientTransform", "handle", $hPathGradientBrush, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathBrushSetWrapMode($hPathGradientBrush, $iWrapMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathGradientWrapMode", "handle", $hPathGradientBrush, "int", $iWrapMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathClone($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipClonePath", "handle", $hPath, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathCloseFigure($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipClosePathFigure", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathCreate($iFillMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePath", "int", $iFillMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathCreate2($aPathData, $iFillMode = 0)
Local $iCount = $aPathData[0][0]
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
Local $tTypes = DllStructCreate("byte[" & $iCount & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPathData[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tPoints, 1, $aPathData[$iI][1], (($iI - 1) * 2) + 2)
DllStructSetData($tTypes, 1, $aPathData[$iI][2], $iI)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePath2", "struct*", $tPoints, "struct*", $tTypes, "int", $iCount, "int", $iFillMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[5]
EndFunc
Func _GDIPlus_PathDispose($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePath", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathFlatten($hPath, $fFlatness = 0.25, $hMatrix = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipFlattenPath", "handle", $hPath, "handle", $hMatrix, "float", $fFlatness)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathGetData($hPath)
Local $iCount = _GDIPlus_PathGetPointCount($hPath)
Local $tPathData = DllStructCreate("int Count; ptr Points; ptr Types;")
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
Local $tTypes = DllStructCreate("byte[" & $iCount & "]")
DllStructSetData($tPathData, "Count", $iCount)
DllStructSetData($tPathData, "Points", DllStructGetPtr($tPoints))
DllStructSetData($tPathData, "Types", DllStructGetPtr($tTypes))
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathData", "handle", $hPath, "struct*", $tPathData)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError($aResult[0], $aResult[0], -1)
Local $aData[$iCount + 1][3]
$aData[0][0] = $iCount
For $iI = 1 To $iCount
$aData[$iI][0] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 1)
$aData[$iI][1] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 2)
$aData[$iI][2] = DllStructGetData($tTypes, 1, $iI)
Next
Return $aData
EndFunc
Func _GDIPlus_PathGetFillMode($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathFillMode", "handle", $hPath, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathGetLastPoint($hPath)
Local $tPointF = DllStructCreate("float;float")
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathLastPoint", "handle", $hPath, "struct*", $tPointF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aPointF[2]
$aPointF[0] = DllStructGetData($tPointF, 1)
$aPointF[1] = DllStructGetData($tPointF, 2)
Return $aPointF
EndFunc
Func _GDIPlus_PathGetPointCount($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPointCount", "handle", $hPath, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathGetPoints($hPath)
Local $iI, $iCount, $tPoints, $aPoints[1][1], $aResult
$iCount = _GDIPlus_PathGetPointCount($hPath)
If @error Then Return SetError(@error + 10, @extended, -1)
$tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
$aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathPoints", "handle", $hPath, "struct*", $tPoints, "int", $iCount)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aPoints[$iCount + 1][2]
$aPoints[0][0] = $iCount
For $iI = 1 To $iCount
$aPoints[$iI][0] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 1)
$aPoints[$iI][1] = DllStructGetData($tPoints, 1, (($iI - 1) * 2) + 2)
Next
Return $aPoints
EndFunc
Func _GDIPlus_PathGetWorldBounds($hPath, $hMatrix = 0, $hPen = 0)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPathWorldBounds", "handle", $hPath, "struct*", $tRECTF, "handle", $hMatrix, "handle", $hPen)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aRectF[4]
For $iI = 1 To 4
$aRectF[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aRectF
EndFunc
Func _GDIPlus_PathIsOutlineVisiblePoint($hPath, $nX, $nY, $hPen = 0, $hGraphics = 0)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipIsOutlineVisiblePathPoint", "handle", $hPath, "float", $nX, "float", $nY, "handle", $hPen, "handle", $hGraphics, "int*", 0)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return $aResult[6] <> 0
EndFunc
Func _GDIPlus_PathIsVisiblePoint($hPath, $nX, $nY, $hGraphics = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipIsVisiblePathPoint", "handle", $hPath, "float", $nX, "float", $nY, "handle", $hGraphics, "int*", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return $aResult[5] <> 0
EndFunc
Func _GDIPlus_PathIterCreate($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePathIter", "handle*", 0, "handle", $hPath)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_PathIterDispose($hPathIter)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePathIter", "handle", $hPathIter)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathIterGetSubpathCount($hPathIter)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPathIterGetSubpathCount", "handle", $hPathIter, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathIterNextMarkerPath($hPathIter, $hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPathIterNextMarkerPath", "handle", $hPathIter, "int*", 0, "handle", $hPath)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PathIterNextSubpathPath($hPathIter, $hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPathIterNextSubpathPath", "handle", $hPathIter, "int*", 0, "handle", $hPath, "bool*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aReturn[2]
$aReturn[0] = $aResult[2]
$aReturn[1] = $aResult[4]
Return $aReturn
EndFunc
Func _GDIPlus_PathIterRewind($hPathIter)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipPathIterRewind", "handle", $hPathIter)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathReset($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipResetPath", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathReverse($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipReversePath", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathSetFillMode($hPath, $iFillMode)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathFillMode", "handle", $hPath, "int", $iFillMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathSetMarker($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPathMarker", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathStartFigure($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipStartPathFigure", "handle", $hPath)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathTransform($hPath, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTransformPath", "handle", $hPath, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathWarp($hPath, $hMatrix, $aPoints, $nX, $nY, $nWidth, $nHeight, $iWarpMode = 0, $fFlatness = 0.25)
Local $iCount = $aPoints[0][0]
If $iCount <> 3 And $iCount <> 4 Then Return SetError(11, 0, False)
Local $tPoints = DllStructCreate("float[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tPoints, 1, $aPoints[$iI][0], ($iI - 1) * 2 + 1)
DllStructSetData($tPoints, 1, $aPoints[$iI][1], ($iI - 1) * 2 + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipWarpPath", "handle", $hPath, "handle", $hMatrix, "struct*", $tPoints, "int", $iCount,  "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "int", $iWarpMode, "float", $fFlatness)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathWiden($hPath, $hPen, $hMatrix = 0, $fFlatness = 0.25)
__GDIPlus_PenDefCreate($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipWidenPath", "handle", $hPath, "handle", $hPen, "handle", $hMatrix, "float", $fFlatness)
__GDIPlus_PenDefDispose()
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PathWindingModeOutline($hPath, $hMatrix = 0, $fFlatness = 0.25)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipWindingModeOutline", "handle", $hPath, "handle", $hMatrix, "float", $fFlatness)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenCreate($iARGB = 0xFF000000, $nWidth = 1, $iUnit = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePen1", "dword", $iARGB, "float", $nWidth, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_PenCreate2($hBrush, $nWidth = 1, $iUnit = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreatePen2", "handle", $hBrush, "float", $nWidth, "int", $iUnit, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[4]
EndFunc
Func _GDIPlus_PenDispose($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeletePen", "handle", $hPen)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenGetAlignment($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenMode", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetColor($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenColor", "handle", $hPen, "dword*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetCustomEndCap($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenCustomEndCap", "handle", $hPen, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetDashCap($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenDashCap197819", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetDashStyle($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenDashStyle", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetEndCap($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenEndCap", "handle", $hPen, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetMiterLimit($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenMiterLimit", "handle", $hPen, "float*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenGetWidth($hPen)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetPenWidth", "handle", $hPen, "float*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_PenSetAlignment($hPen, $iAlignment = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenMode", "handle", $hPen, "int", $iAlignment)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetColor($hPen, $iARGB)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenColor", "handle", $hPen, "dword", $iARGB)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetCustomEndCap($hPen, $hEndCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenCustomEndCap", "handle", $hPen, "handle", $hEndCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetDashCap($hPen, $iDash = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenDashCap197819", "handle", $hPen, "int", $iDash)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetDashStyle($hPen, $iStyle = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenDashStyle", "handle", $hPen, "int", $iStyle)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetEndCap($hPen, $iEndCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenEndCap", "handle", $hPen, "int", $iEndCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetLineCap($hPen, $iStartCap, $iEndCap, $iDashCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenLineCap197819", "handle", $hPen, "int", $iStartCap, "int", $iEndCap, "int", $iDashCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetLineJoin($hPen, $iLineJoin)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenLineJoin", "handle", $hPen, "int", $iLineJoin)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetMiterLimit($hPen, $fMiterLimit)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenMiterLimit", "handle", $hPen, "float", $fMiterLimit)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetStartCap($hPen, $iLineCap)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenStartCap", "handle", $hPen, "int", $iLineCap)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PenSetWidth($hPen, $fWidth)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetPenWidth", "handle", $hPen, "float", $fWidth)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RectFCreate($nX = 0, $nY = 0, $nWidth = 0, $nHeight = 0)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
DllStructSetData($tRECTF, "X", $nX)
DllStructSetData($tRECTF, "Y", $nY)
DllStructSetData($tRECTF, "Width", $nWidth)
DllStructSetData($tRECTF, "Height", $nHeight)
Return $tRECTF
EndFunc
Func _GDIPlus_RegionClone($hRegion)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCloneRegion", "handle", $hRegion, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_RegionCombinePath($hRegion, $hPath, $iCombineMode = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCombineRegionPath", "handle", $hRegion, "handle", $hPath, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionCombineRect($hRegion, $nX, $nY, $nWidth, $nHeight, $iCombineMode = 2)
Local $tRECTF = _GDIPlus_RectFCreate($nX, $nY, $nWidth, $nHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCombineRegionRect", "handle", $hRegion, "struct*", $tRECTF, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionCombineRegion($hRegionDst, $hRegionSrc, $iCombineMode = 2)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCombineRegionRegion", "handle", $hRegionDst, "handle", $hRegionSrc, "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionCreate()
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateRegion", "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[1]
EndFunc
Func _GDIPlus_RegionCreateFromPath($hPath)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateRegionPath", "handle", $hPath, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_RegionCreateFromRect($nX, $nY, $nWidth, $nHeight)
Local $tRECTF = _GDIPlus_RectFCreate($nX, $nY, $nWidth, $nHeight)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateRegionRect", "struct*", $tRECTF, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_RegionDispose($hRegion)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteRegion", "handle", $hRegion)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionGetBounds($hRegion, $hGraphics)
Local $tRECTF = DllStructCreate($tagGDIPRECTF)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetRegionBounds", "handle", $hRegion, "handle", $hGraphics, "struct*", $tRECTF)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Local $aBounds[4]
For $iI = 1 To 4
$aBounds[$iI - 1] = DllStructGetData($tRECTF, $iI)
Next
Return $aBounds
EndFunc
Func _GDIPlus_RegionGetHRgn($hRegion, $hGraphics = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetRegionHRgn", "handle", $hRegion, "handle", $hGraphics, "handle*", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return $aResult[3]
EndFunc
Func _GDIPlus_RegionTransform($hRegion, $hMatrix)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTransformRegion", "handle", $hRegion, "handle", $hMatrix)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_RegionTranslate($hRegion, $nDX, $nDY)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipTranslateRegion", "handle", $hRegion, "float", $nDX, "float", $nDY)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_Shutdown()
If $__g_hGDIPDll = 0 Then Return SetError(-1, -1, False)
$__g_iGDIPRef -= 1
If $__g_iGDIPRef = 0 Then
DllCall($__g_hGDIPDll, "none", "GdiplusShutdown", "ulong_ptr", $__g_iGDIPToken)
DllClose($__g_hGDIPDll)
$__g_hGDIPDll = 0
EndIf
Return True
EndFunc
Func _GDIPlus_Startup($sGDIPDLL = Default, $bRetDllHandle = False)
$__g_iGDIPRef += 1
If $__g_iGDIPRef > 1 Then Return True
If $sGDIPDLL = Default Then $sGDIPDLL = "gdiplus.dll"
$__g_hGDIPDll = DllOpen($sGDIPDLL)
If $__g_hGDIPDll = -1 Then
$__g_iGDIPRef = 0
Return SetError(1, 2, False)
EndIf
Local $sVer = FileGetVersion($sGDIPDLL)
$sVer = StringSplit($sVer, ".")
If $sVer[1] > 5 Then $__g_bGDIP_V1_0 = False
Local $tInput = DllStructCreate($tagGDIPSTARTUPINPUT)
Local $tToken = DllStructCreate("ulong_ptr Data")
DllStructSetData($tInput, "Version", 1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdiplusStartup", "struct*", $tToken, "struct*", $tInput, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
$__g_iGDIPToken = DllStructGetData($tToken, "Data")
If $bRetDllHandle Then Return $__g_hGDIPDll
Return SetExtended($sVer[1], True)
EndFunc
Func _GDIPlus_StringFormatCreate($iFormat = 0, $iLangID = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateStringFormat", "int", $iFormat, "word", $iLangID, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_StringFormatDispose($hFormat)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteStringFormat", "handle", $hFormat)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_StringFormatGetMeasurableCharacterRangeCount($hStringFormat)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetStringFormatMeasurableCharacterRangeCount", "handle", $hStringFormat, "int*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_StringFormatSetAlign($hStringFormat, $iFlag)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetStringFormatAlign", "handle", $hStringFormat, "int", $iFlag)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_StringFormatSetLineAlign($hStringFormat, $iStringAlign)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetStringFormatLineAlign", "handle", $hStringFormat, "int", $iStringAlign)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_StringFormatSetMeasurableCharacterRanges($hStringFormat, $aRanges)
Local $iCount = $aRanges[0][0]
Local $tCharacterRanges = DllStructCreate("int[" & $iCount * 2 & "]")
For $iI = 1 To $iCount
DllStructSetData($tCharacterRanges, 1, $aRanges[$iI][0], (($iI - 1) * 2) + 1)
DllStructSetData($tCharacterRanges, 1, $aRanges[$iI][1], (($iI - 1) * 2) + 2)
Next
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetStringFormatMeasurableCharacterRanges", "handle", $hStringFormat, "int", $iCount, "struct*", $tCharacterRanges)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_TextureCreate($hImage, $iWrapMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateTexture", "handle", $hImage, "int", $iWrapMode, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_TextureCreate2($hImage, $nX, $nY, $nWidth, $nHeight, $iWrapMode = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateTexture2", "handle", $hImage, "int", $iWrapMode, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func _GDIPlus_TextureCreateIA($hImage, $nX, $nY, $nWidth, $nHeight, $pImageAttributes = 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateTextureIA", "handle", $hImage, "handle", $pImageAttributes, "float", $nX, "float", $nY, "float", $nWidth, "float", $nHeight, "ptr*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[7]
EndFunc
Func __GDIPlus_BrushDefCreate(ByRef $hBrush)
If $hBrush = 0 Then
$__g_hGDIPBrush = _GDIPlus_BrushCreateSolid()
$hBrush = $__g_hGDIPBrush
EndIf
EndFunc
Func __GDIPlus_BrushDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPBrush <> 0 Then
_GDIPlus_BrushDispose($__g_hGDIPBrush)
$__g_hGDIPBrush = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Func __GDIPlus_ExtractFileExt($sFileName, $bNoDot = True)
Local $iIndex = __GDIPlus_LastDelimiter(".\:", $sFileName)
If ($iIndex > 0) And (StringMid($sFileName, $iIndex, 1) = '.') Then
If $bNoDot Then
Return StringMid($sFileName, $iIndex + 1)
Else
Return StringMid($sFileName, $iIndex)
EndIf
Else
Return ""
EndIf
EndFunc
Func __GDIPlus_LastDelimiter($sDelimiters, $sString)
Local $sDelimiter, $iN
For $iI = 1 To StringLen($sDelimiters)
$sDelimiter = StringMid($sDelimiters, $iI, 1)
$iN = StringInStr($sString, $sDelimiter, 0, -1)
If $iN > 0 Then Return $iN
Next
EndFunc
Func __GDIPlus_PenDefCreate(ByRef $hPen)
If $hPen = 0 Then
$__g_hGDIPPen = _GDIPlus_PenCreate()
$hPen = $__g_hGDIPPen
EndIf
EndFunc
Func __GDIPlus_PenDefDispose($iCurError = @error, $iCurExtended = @extended)
If $__g_hGDIPPen <> 0 Then
_GDIPlus_PenDispose($__g_hGDIPPen)
$__g_hGDIPPen = 0
EndIf
Return SetError($iCurError, $iCurExtended)
EndFunc
Func _GDIPlus_BitmapApplyEffect($hBitmap, $hEffect, $tRECT = Null)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
If Not IsPtr($hEffect) Then Return SetError(10, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapApplyEffect", "handle", $hBitmap, "handle", $hEffect, "struct*", $tRECT, "int", 0, "ptr*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapApplyEffectEx($hBitmap, $hEffect, $iX = 0, $iY = 0, $iW = 0, $iH = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $tRECT = 0
If BitOR($iX, $iY, $iW, $iH) Then
$tRECT = DllStructCreate("int Left; int Top; int Right; int Bottom;")
DllStructSetData($tRECT, "Right", $iW + DllStructSetData($tRECT, "Left", $iX))
DllStructSetData($tRECT, "Bottom", $iH + DllStructSetData($tRECT, "Top", $iY))
EndIf
Local $iStatus = _GDIPlus_BitmapApplyEffect($hBitmap, $hEffect, $tRECT)
If Not $iStatus Then Return SetError(@error, @extended, False)
Return True
EndFunc
Func _GDIPlus_BitmapConvertFormat($hBitmap, $iPixelFormat, $iDitherType, $iPaletteType, $tPalette, $fAlphaThresholdPercent = 0.0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapConvertFormat", "handle", $hBitmap, "uint", $iPixelFormat, "uint", $iDitherType, "uint", $iPaletteType, "struct*", $tPalette, "float", $fAlphaThresholdPercent)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapCreateApplyEffect($hBitmap, $hEffect, $tRECT = Null, $tOutRECT = Null)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapCreateApplyEffect", "handle*", $hBitmap, "int", 1, "handle", $hEffect, "struct*", $tRECT, "struct*", $tOutRECT, "handle*", 0, "int", 0, "ptr*", 0, "int*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[6]
EndFunc
Func _GDIPlus_BitmapCreateApplyEffectEx($hBitmap, $hEffect, $iX = 0, $iY = 0, $iW = 0, $iH = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tRECT = 0
If BitOR($iX, $iY, $iW, $iH) Then
$tRECT = DllStructCreate("int Left; int Top; int Right; int Bottom;")
DllStructSetData($tRECT, "Right", $iW + DllStructSetData($tRECT, "Left", $iX))
DllStructSetData($tRECT, "Bottom", $iH + DllStructSetData($tRECT, "Top", $iY))
EndIf
Local $hBitmap_FX = _GDIPlus_BitmapCreateApplyEffect($hBitmap, $hEffect, $tRECT, Null)
Return SetError(@error, @extended, $hBitmap_FX)
EndFunc
Func _GDIPlus_BitmapGetHistogram($hBitmap, $iHistogramFormat, $iHistogramSize, $tChannel_0, $tChannel_1 = 0, $tChannel_2 = 0, $tChannel_3 = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetHistogram", "handle", $hBitmap, "uint", $iHistogramFormat, "uint", $iHistogramSize, "struct*", $tChannel_0, "struct*", $tChannel_1, "struct*", $tChannel_2, "struct*", $tChannel_3)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_BitmapGetHistogramEx($hBitmap)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $iSize = _GDIPlus_BitmapGetHistogramSize($GDIP_HistogramFormatARGB)
Local $tHistogram = DllStructCreate("int Size; uint Red[" & $iSize & "]; uint MaxRed; uint Green[" & $iSize & "]; uint MaxGreen; uint Blue[" & $iSize & "]; uint MaxBlue; uint Alpha[" & $iSize & "]; uint MaxAlpha; uint Grey[" & $iSize & "]; uint MaxGrey;")
DllStructSetData($tHistogram, "Size", $iSize)
Local $iStatus = _GDIPlus_BitmapGetHistogram($hBitmap, $GDIP_HistogramFormatARGB, $iSize, DllStructGetPtr($tHistogram, "Alpha"), DllStructGetPtr($tHistogram, "Red"), DllStructGetPtr($tHistogram, "Green"), DllStructGetPtr($tHistogram, "Blue"))
If Not $iStatus Then Return SetError(@error, @extended, 0)
$iStatus = _GDIPlus_BitmapGetHistogram($hBitmap, $GDIP_HistogramFormatGray, $iSize, DllStructGetPtr($tHistogram, "Grey"))
If Not $iStatus Then Return SetError(@error + 10, @extended, 0)
Local $iMaxRed = 0, $iMaxGreen = 0, $iMaxBlue = 0, $iMaxAlpha = 0, $iMaxGrey = 0
For $i = 1 To $iSize
If DllStructGetData($tHistogram, "Red", $i) > $iMaxRed Then $iMaxRed = DllStructGetData($tHistogram, "Red", $i)
If DllStructGetData($tHistogram, "Green", $i) > $iMaxGreen Then $iMaxGreen = DllStructGetData($tHistogram, "Green", $i)
If DllStructGetData($tHistogram, "Blue", $i) > $iMaxBlue Then $iMaxBlue = DllStructGetData($tHistogram, "Blue", $i)
If DllStructGetData($tHistogram, "Alpha", $i) > $iMaxAlpha Then $iMaxAlpha = DllStructGetData($tHistogram, "Alpha", $i)
If DllStructGetData($tHistogram, "Grey", $i) > $iMaxGrey Then $iMaxGrey = DllStructGetData($tHistogram, "Grey", $i)
Next
DllStructSetData($tHistogram, "MaxRed", $iMaxRed)
DllStructSetData($tHistogram, "MaxGreen", $iMaxGreen)
DllStructSetData($tHistogram, "MaxBlue", $iMaxBlue)
DllStructSetData($tHistogram, "MaxAlpha", $iMaxAlpha)
DllStructSetData($tHistogram, "MaxGrey", $iMaxGrey)
Return $tHistogram
EndFunc
Func _GDIPlus_BitmapGetHistogramSize($iFormat)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipBitmapGetHistogramSize", "uint", $iFormat, "uint*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[2]
EndFunc
Func _GDIPlus_DrawImageFX($hGraphics, $hImage, $hEffect, $tRECTF = 0, $hMatrix = 0, $hImgAttributes = 0, $iUnit = 2)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDrawImageFX", "handle", $hGraphics, "handle", $hImage, "struct*", $tRECTF, "handle", $hMatrix, "handle", $hEffect, "handle", $hImgAttributes, "uint", $iUnit)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_DrawImageFXEx($hGraphics, $hImage, $hEffect, $nX = 0, $nY = 0, $nW = 0, $nH = 0, $hMatrix = 0, $hImgAttributes = 0, $iUnit = 2)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $tRECTF = 0
If BitOR($nX, $nY, $nW, $nH) Then $tRECTF = _GDIPlus_RectFCreate($nX, $nY, $nW, $nH)
Local $iStatus = _GDIPlus_DrawImageFX($hGraphics, $hImage, $hEffect, $tRECTF, $hMatrix, $hImgAttributes, $iUnit)
Return SetError(@error, @extended, $iStatus)
EndFunc
Func _GDIPlus_EffectCreate($sEffectGUID)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tGUID = _WinAPI_GUIDFromString($sEffectGUID)
Local $tElem = DllStructCreate("uint64[2];", DllStructGetPtr($tGUID))
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipCreateEffect", "uint64", DllStructGetData($tElem, 1, 1), "uint64", DllStructGetData($tElem, 1, 2), "handle*", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $aResult[3]
EndFunc
Func _GDIPlus_EffectCreateBlur($fRadius = 10.0, $bExpandEdge = False)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Blur)
DllStructSetData($tEffectParameters, "Radius", $fRadius)
DllStructSetData($tEffectParameters, "ExpandEdge", $bExpandEdge)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_BlurEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateBrightnessContrast($iBrightnessLevel = 0, $iContrastLevel = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_BrightnessContrast)
DllStructSetData($tEffectParameters, "BrightnessLevel", $iBrightnessLevel)
DllStructSetData($tEffectParameters, "ContrastLevel", $iContrastLevel)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_BrightnessContrastEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorBalance($iCyanRed = 0, $iMagentaGreen = 0, $iYellowBlue = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_ColorBalance)
DllStructSetData($tEffectParameters, "CyanRed", $iCyanRed)
DllStructSetData($tEffectParameters, "MagentaGreen", $iMagentaGreen)
DllStructSetData($tEffectParameters, "YellowBlue", $iYellowBlue)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorBalanceEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorCurve($iAdjustment, $iChannel, $iAdjustValue)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_ColorCurve)
DllStructSetData($tEffectParameters, "Adjustment", $iAdjustment)
DllStructSetData($tEffectParameters, "Channel", $iChannel)
DllStructSetData($tEffectParameters, "AdjustValue", $iAdjustValue)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorCurveEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorLUT($aColorLUT)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_ColorLUT)
For $iI = 0 To 255
DllStructSetData($tEffectParameters, "LutA", $aColorLUT[$iI][0], $iI + 1)
DllStructSetData($tEffectParameters, "LutR", $aColorLUT[$iI][1], $iI + 1)
DllStructSetData($tEffectParameters, "LutG", $aColorLUT[$iI][2], $iI + 1)
DllStructSetData($tEffectParameters, "LutB", $aColorLUT[$iI][3], $iI + 1)
Next
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorLUTEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateColorMatrix($tColorMatrix)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_ColorMatrixEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tColorMatrix)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateHueSaturationLightness($iHueLevel = 0, $iSaturationLevel = 0, $iLightnessLevel = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_HueSaturationLightness)
DllStructSetData($tEffectParameters, "HueLevel", $iHueLevel)
DllStructSetData($tEffectParameters, "SaturationLevel", $iSaturationLevel)
DllStructSetData($tEffectParameters, "LightnessLevel", $iLightnessLevel)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_HueSaturationLightnessEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateLevels($iHighlight = 100, $iMidtone = 0, $iShadow = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Levels)
DllStructSetData($tEffectParameters, "Highlight", $iHighlight)
DllStructSetData($tEffectParameters, "Midtone", $iMidtone)
DllStructSetData($tEffectParameters, "Shadow", $iShadow)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_LevelsEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateRedEyeCorrection($aAreas)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $iCount = $aAreas[0][0]
Local $tAreas = DllStructCreate("long[" & $iCount * 4 & "]")
For $iI = 1 To $iCount
DllStructSetData($tAreas, 1, DllStructSetData($tAreas, 1, $aAreas[$iI][0], (($iI - 1) * 4) + 1) + $aAreas[$iI][2], (($iI - 1) * 4) + 3)
DllStructSetData($tAreas, 1, DllStructSetData($tAreas, 1, $aAreas[$iI][1], (($iI - 1) * 4) + 2) + $aAreas[$iI][3], (($iI - 1) * 4) + 4)
Next
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_RedEyeCorrection)
DllStructSetData($tEffectParameters, "NumberOfAreas", $iCount)
DllStructSetData($tEffectParameters, "Areas", DllStructGetPtr($tAreas))
Local $hEffect = _GDIPlus_EffectCreate($GDIP_RedEyeCorrectionEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters, (DllStructGetSize($tAreas) + DllStructGetSize($tEffectParameters)) / DllStructGetSize($tEffectParameters))
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateSharpen($fRadius = 10.0, $fAmount = 50.0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Sharpen)
DllStructSetData($tEffectParameters, "Radius", $fRadius)
DllStructSetData($tEffectParameters, "Amount", $fAmount)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_SharpenEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectCreateTint($iHue = 0, $iAmount = 0)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
Local $tEffectParameters = DllStructCreate($tagGDIP_EFFECTPARAMS_Tint)
DllStructSetData($tEffectParameters, "Hue", $iHue)
DllStructSetData($tEffectParameters, "Amount", $iAmount)
Local $hEffect = _GDIPlus_EffectCreate($GDIP_TintEffectGuid)
If @error Then Return SetError(@error, @extended, 0)
_GDIPlus_EffectSetParameters($hEffect, $tEffectParameters)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $hEffect
EndFunc
Func _GDIPlus_EffectDispose($hEffect)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipDeleteEffect", "handle", $hEffect)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_EffectGetParameters($hEffect, $tEffectParameters)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
If DllStructGetSize($tEffectParameters) < __GDIPlus_EffectGetParameterSize($hEffect) Then Return SetError(2, 5, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEffectParameters", "handle", $hEffect, "uint*", DllStructGetSize($tEffectParameters), "struct*", $tEffectParameters)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func __GDIPlus_EffectGetParameterSize($hEffect)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, -1)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipGetEffectParameterSize", "handle", $hEffect, "uint*", 0)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] Then Return SetError(10, $aResult[0], -1)
Return $aResult[2]
EndFunc
Func _GDIPlus_EffectSetParameters($hEffect, $tEffectParameters, $iSizeAdjust = 1)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, False)
Local $iSize = __GDIPlus_EffectGetParameterSize($hEffect)
If @error Then Return SetError(@error, @extended, False)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipSetEffectParameters", "handle", $hEffect, "struct*", $tEffectParameters, "uint", $iSize * $iSizeAdjust)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] Then Return SetError(10, $aResult[0], False)
Return True
EndFunc
Func _GDIPlus_PaletteInitialize($iEntries, $iPaletteType = $GDIP_PaletteTypeOptimal, $iOptimalColors = 0, $bUseTransparentColor = True, $hBitmap = Null)
If $__g_bGDIP_V1_0 Then Return SetError(-1, 0, 0)
If $iOptimalColors > 0 Then $iPaletteType = $GDIP_PaletteTypeOptimal
Local $tPalette = DllStructCreate("uint Flags; uint Count; uint ARGB[" & $iEntries & "];")
DllStructSetData($tPalette, "Flags", $iPaletteType)
DllStructSetData($tPalette, "Count", $iEntries)
Local $aResult = DllCall($__g_hGDIPDll, "int", "GdipInitializePalette", "struct*", $tPalette, "uint", $iPaletteType, "uint", $iOptimalColors, "bool", $bUseTransparentColor, "handle", $hBitmap)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return SetError(10, $aResult[0], 0)
Return $tPalette
EndFunc
Global $__g_iBMPFormat = $GDIP_PXF24RGB
Global $__g_iJPGQuality = 100
Global $__g_iTIFColorDepth = 24
Global $__g_iTIFCompression = $GDIP_EVTCOMPRESSIONLZW
Global Const $__SCREENCAPTURECONSTANT_SM_CXSCREEN = 0
Global Const $__SCREENCAPTURECONSTANT_SM_CYSCREEN = 1
Global Const $__SCREENCAPTURECONSTANT_SRCCOPY = 0x00CC0020
Func _ScreenCapture_Capture($sFileName = "", $iLeft = 0, $iTop = 0, $iRight = -1, $iBottom = -1, $bCursor = True)
Local $bRet = False
If $iRight = -1 Then $iRight = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CXSCREEN) - 1
If $iBottom = -1 Then $iBottom = _WinAPI_GetSystemMetrics($__SCREENCAPTURECONSTANT_SM_CYSCREEN) - 1
If $iRight < $iLeft Then Return SetError(-1, 0, $bRet)
If $iBottom < $iTop Then Return SetError(-2, 0, $bRet)
Local $iW = ($iRight - $iLeft) + 1
Local $iH = ($iBottom - $iTop) + 1
Local $hWnd = _WinAPI_GetDesktopWindow()
Local $hDDC = _WinAPI_GetDC($hWnd)
Local $hCDC = _WinAPI_CreateCompatibleDC($hDDC)
Local $hBMP = _WinAPI_CreateCompatibleBitmap($hDDC, $iW, $iH)
_WinAPI_SelectObject($hCDC, $hBMP)
_WinAPI_BitBlt($hCDC, 0, 0, $iW, $iH, $hDDC, $iLeft, $iTop, $__SCREENCAPTURECONSTANT_SRCCOPY)
If $bCursor Then
Local $aCursor = _WinAPI_GetCursorInfo()
If Not @error And $aCursor[1] Then
$bCursor = True
Local $hIcon = _WinAPI_CopyIcon($aCursor[2])
Local $aIcon = _WinAPI_GetIconInfo($hIcon)
If Not @error Then
_WinAPI_DeleteObject($aIcon[4])
If $aIcon[5] <> 0 Then _WinAPI_DeleteObject($aIcon[5])
_WinAPI_DrawIcon($hCDC, $aCursor[3] - $aIcon[2] - $iLeft, $aCursor[4] - $aIcon[3] - $iTop, $hIcon)
EndIf
_WinAPI_DestroyIcon($hIcon)
EndIf
EndIf
_WinAPI_ReleaseDC($hWnd, $hDDC)
_WinAPI_DeleteDC($hCDC)
If $sFileName = "" Then Return $hBMP
$bRet = _ScreenCapture_SaveImage($sFileName, $hBMP, True)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _ScreenCapture_CaptureWnd($sFileName, $hWnd, $iLeft = 0, $iTop = 0, $iRight = -1, $iBottom = -1, $bCursor = True)
If Not IsHWnd($hWnd) Then $hWnd = WinGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local Const $DWMWA_EXTENDED_FRAME_BOUNDS = 9
Local $bRet = DllCall("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $hWnd, "dword", $DWMWA_EXTENDED_FRAME_BOUNDS, "struct*", $tRECT, "dword", DllStructGetSize($tRECT))
If (@error Or $bRet[0] Or (Abs(DllStructGetData($tRECT, "Left")) + Abs(DllStructGetData($tRECT, "Top")) +  Abs(DllStructGetData($tRECT, "Right")) + Abs(DllStructGetData($tRECT, "Bottom"))) = 0) Then
$tRECT = _WinAPI_GetWindowRect($hWnd)
If @error Then Return SetError(@error + 10, @extended, False)
EndIf
$iLeft += DllStructGetData($tRECT, "Left")
$iTop += DllStructGetData($tRECT, "Top")
If $iRight = -1 Then $iRight = DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left") - 1
If $iBottom = -1 Then $iBottom = DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top") - 1
$iRight += DllStructGetData($tRECT, "Left")
$iBottom += DllStructGetData($tRECT, "Top")
If $iLeft > DllStructGetData($tRECT, "Right") Then $iLeft = DllStructGetData($tRECT, "Left")
If $iTop > DllStructGetData($tRECT, "Bottom") Then $iTop = DllStructGetData($tRECT, "Top")
If $iRight > DllStructGetData($tRECT, "Right") Then $iRight = DllStructGetData($tRECT, "Right") - 1
If $iBottom > DllStructGetData($tRECT, "Bottom") Then $iBottom = DllStructGetData($tRECT, "Bottom") - 1
$bRet = _ScreenCapture_Capture($sFileName, $iLeft, $iTop, $iRight, $iBottom, $bCursor)
Return SetError(@error, @extended, $bRet)
EndFunc
Func _ScreenCapture_SaveImage($sFileName, $hBitmap, $bFreeBmp = True)
_GDIPlus_Startup()
If @error Then Return SetError(-1, -1, False)
Local $sExt = StringUpper(__GDIPlus_ExtractFileExt($sFileName))
Local $sCLSID = _GDIPlus_EncodersGetCLSID($sExt)
If $sCLSID = "" Then Return SetError(-2, -2, False)
Local $hImage = _GDIPlus_BitmapCreateFromHBITMAP($hBitmap)
If @error Then Return SetError(-3, -3, False)
Local $tData, $tParams
Switch $sExt
Case "BMP"
Local $iX = _GDIPlus_ImageGetWidth($hImage)
Local $iY = _GDIPlus_ImageGetHeight($hImage)
Local $hClone = _GDIPlus_BitmapCloneArea($hImage, 0, 0, $iX, $iY, $__g_iBMPFormat)
_GDIPlus_ImageDispose($hImage)
$hImage = $hClone
Case "JPG", "JPEG"
$tParams = _GDIPlus_ParamInit(1)
$tData = DllStructCreate("int Quality")
DllStructSetData($tData, "Quality", $__g_iJPGQuality)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGQUALITY, 1, $GDIP_EPTLONG, DllStructGetPtr($tData))
Case "TIF", "TIFF"
$tParams = _GDIPlus_ParamInit(2)
$tData = DllStructCreate("int ColorDepth;int Compression")
DllStructSetData($tData, "ColorDepth", $__g_iTIFColorDepth)
DllStructSetData($tData, "Compression", $__g_iTIFCompression)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGCOLORDEPTH, 1, $GDIP_EPTLONG, DllStructGetPtr($tData, "ColorDepth"))
_GDIPlus_ParamAdd($tParams, $GDIP_EPGCOMPRESSION, 1, $GDIP_EPTLONG, DllStructGetPtr($tData, "Compression"))
EndSwitch
Local $pParams = 0
If IsDllStruct($tParams) Then $pParams = $tParams
Local $bRet = _GDIPlus_ImageSaveToFileEx($hImage, $sFileName, $sCLSID, $pParams)
_GDIPlus_ImageDispose($hImage)
If $bFreeBmp Then _WinAPI_DeleteObject($hBitmap)
_GDIPlus_Shutdown()
Return SetError($bRet = False, 0, $bRet)
EndFunc
Func _ScreenCapture_SetBMPFormat($iFormat)
Switch $iFormat
Case 0
$__g_iBMPFormat = $GDIP_PXF16RGB555
Case 1
$__g_iBMPFormat = $GDIP_PXF16RGB565
Case 2
$__g_iBMPFormat = $GDIP_PXF24RGB
Case 3
$__g_iBMPFormat = $GDIP_PXF32RGB
Case 4
$__g_iBMPFormat = $GDIP_PXF32ARGB
Case Else
$__g_iBMPFormat = $GDIP_PXF24RGB
EndSwitch
EndFunc
Func _ScreenCapture_SetJPGQuality($iQuality)
If $iQuality < 0 Then $iQuality = 0
If $iQuality > 100 Then $iQuality = 100
$__g_iJPGQuality = $iQuality
EndFunc
Func _ScreenCapture_SetTIFColorDepth($iDepth)
Switch $iDepth
Case 24
$__g_iTIFColorDepth = 24
Case 32
$__g_iTIFColorDepth = 32
Case Else
$__g_iTIFColorDepth = 0
EndSwitch
EndFunc
Func _ScreenCapture_SetTIFCompression($iCompress)
Switch $iCompress
Case 1
$__g_iTIFCompression = $GDIP_EVTCOMPRESSIONNONE
Case 2
$__g_iTIFCompression = $GDIP_EVTCOMPRESSIONLZW
Case Else
$__g_iTIFCompression = 0
EndSwitch
EndFunc
Global Enum $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER, $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING
Global Enum $ARRAYUNIQUE_NOCOUNT, $ARRAYUNIQUE_COUNT
Global Enum $ARRAYUNIQUE_AUTO, $ARRAYUNIQUE_FORCE32, $ARRAYUNIQUE_FORCE64, $ARRAYUNIQUE_MATCH, $ARRAYUNIQUE_DISTINCT
Func _ArrayAdd(ByRef $aArray, $vValue, $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
EndSwitch
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + 1]
$aArray[$iDim_1] = $vValue
Return $iDim_1
EndIf
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
EndIf
$vValue = $aTmp
EndIf
Local $iAdd = UBound($vValue, $UBOUND_ROWS)
ReDim $aArray[$iDim_1 + $iAdd]
For $i = 0 To $iAdd - 1
If IsFunc($hDataType) Then
$aArray[$iDim_1 + $i] = $hDataType($vValue[$i])
Else
$aArray[$iDim_1 + $i] = $vValue[$i]
EndIf
Next
Return $iDim_1 + $iAdd - 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(4, 0, -1)
Local $iValDim_1, $iValDim_2 = 0, $iColCount
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(5, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
Local $aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
Local $aTmp[$iValDim_1][0], $aSplit_2
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iColCount = UBound($aSplit_2)
If $iColCount > $iValDim_2 Then
$iValDim_2 = $iColCount
ReDim $aTmp[$iValDim_1][$iValDim_2]
EndIf
For $j = 0 To $iColCount - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1 + $iValDim_1][$iDim_2]
For $iWriteTo_Index = 0 To $iValDim_1 - 1
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
Else
If IsFunc($hDataType) Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = $hDataType($vValue[$iWriteTo_Index][$j - $iStart])
Else
$aArray[$iWriteTo_Index + $iDim_1][$j] = $vValue[$iWriteTo_Index][$j - $iStart]
EndIf
EndIf
Next
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS) - 1
EndFunc
Func _ArrayBinarySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iColumn = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iColumn = Default Then $iColumn = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iDim_1 = 0 Then Return SetError(6, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_1 - 1 Then $iEnd = $iDim_1 - 1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Local $iMid = Int(($iEnd + $iStart) / 2)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $aArray[$iStart] > $vValue Or $aArray[$iEnd] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid]
If $vValue < $aArray[$iMid] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(7, 0, -1)
If $aArray[$iStart][$iColumn] > $vValue Or $aArray[$iEnd][$iColumn] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid][$iColumn]
If $vValue < $aArray[$iMid][$iColumn] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case Else
Return SetError(5, 0, -1)
EndSwitch
Return $iMid
EndFunc
Func _ArrayColDelete(ByRef $aArray, $iColumn, $bConvert = False)
If $bConvert = Default Then $bConvert = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(2, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
Switch $iDim_2
Case 2
If $iColumn < 0 Or $iColumn > 1 Then Return SetError(3, 0, -1)
If $bConvert Then
Local $aTempArray[$iDim_1]
For $i = 0 To $iDim_1 - 1
$aTempArray[$i] = $aArray[$i][(Not $iColumn)]
Next
$aArray = $aTempArray
Else
ContinueCase
EndIf
Case Else
If $iColumn < 0 Or $iColumn > $iDim_2 - 1 Then Return SetError(3, 0, -1)
For $i = 0 To $iDim_1 - 1
For $j = $iColumn To $iDim_2 - 2
$aArray[$i][$j] = $aArray[$i][$j + 1]
Next
Next
ReDim $aArray[$iDim_1][$iDim_2 - 1]
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayColInsert(ByRef $aArray, $iColumn)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aTempArray[$iDim_1][2]
Switch $iColumn
Case 0, 1
For $i = 0 To $iDim_1 - 1
$aTempArray[$i][(Not $iColumn)] = $aArray[$i]
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
$aArray = $aTempArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1][$iDim_2 + 1]
For $i = 0 To $iDim_1 - 1
For $j = $iDim_2 To $iColumn + 1 Step -1
$aArray[$i][$j] = $aArray[$i][$j - 1]
Next
$aArray[$i][$iColumn] = ""
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayCombinations(Const ByRef $aArray, $iSet, $sDelimiter = "")
If $sDelimiter = Default Then $sDelimiter = ""
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, 0)
Local $iN = UBound($aArray)
Local $iR = $iSet
Local $aIdx[$iR]
For $i = 0 To $iR - 1
$aIdx[$i] = $i
Next
Local $iTotal = __Array_Combinations($iN, $iR)
Local $iLeft = $iTotal
Local $aResult[$iTotal + 1]
$aResult[0] = $iTotal
Local $iCount = 1
While $iLeft > 0
__Array_GetNext($iN, $iR, $iLeft, $iTotal, $aIdx)
For $i = 0 To $iSet - 1
$aResult[$iCount] &= $aArray[$aIdx[$i]] & $sDelimiter
Next
If $sDelimiter <> "" Then $aResult[$iCount] = StringTrimRight($aResult[$iCount], 1)
$iCount += 1
WEnd
Return $aResult
EndFunc
Func _ArrayConcatenate(ByRef $aArrayTarget, Const ByRef $aArraySource, $iStart = 0)
If $iStart = Default Then $iStart = 0
If Not IsArray($aArrayTarget) Then Return SetError(1, 0, -1)
If Not IsArray($aArraySource) Then Return SetError(2, 0, -1)
Local $iDim_Total_Tgt = UBound($aArrayTarget, $UBOUND_DIMENSIONS)
Local $iDim_Total_Src = UBound($aArraySource, $UBOUND_DIMENSIONS)
Local $iDim_1_Tgt = UBound($aArrayTarget, $UBOUND_ROWS)
Local $iDim_1_Src = UBound($aArraySource, $UBOUND_ROWS)
If $iStart < 0 Or $iStart > $iDim_1_Src - 1 Then Return SetError(6, 0, -1)
Switch $iDim_Total_Tgt
Case 1
If $iDim_Total_Src <> 1 Then Return SetError(4, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart]
For $i = $iStart To $iDim_1_Src - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart] = $aArraySource[$i]
Next
Case 2
If $iDim_Total_Src <> 2 Then Return SetError(4, 0, -1)
Local $iDim_2_Tgt = UBound($aArrayTarget, $UBOUND_COLUMNS)
If UBound($aArraySource, $UBOUND_COLUMNS) <> $iDim_2_Tgt Then Return SetError(5, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart][$iDim_2_Tgt]
For $i = $iStart To $iDim_1_Src - 1
For $j = 0 To $iDim_2_Tgt - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart][$j] = $aArraySource[$i][$j]
Next
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
Return UBound($aArrayTarget, $UBOUND_ROWS)
EndFunc
Func _ArrayDelete(ByRef $aArray, $vRange)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber, $aSplit_1, $aSplit_2
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
Local $iCopyTo_Index = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
$aArray[$iCopyTo_Index] = $aArray[$iReadFrom_Index]
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1]
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]][0] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index][0] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
For $j = 0 To $iDim_2
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFrom_Index][$j]
Next
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1][$iDim_2 + 1]
Case Else
Return SetError(2, 0, False)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayDisplay(Const ByRef $aArray, $sTitle = Default, $sArrayRange = Default, $iFlags = Default, $vUser_Separator = Default, $sHeader = Default, $iMax_ColWidth = Default, $iAlt_Color = Default, $hUser_Function = Default)
If $sTitle = Default Then $sTitle = "ArrayDisplay"
If $sArrayRange = Default Then $sArrayRange = ""
If $iFlags = Default Then $iFlags = 0
If $vUser_Separator = Default Then $vUser_Separator = ""
If $sHeader = Default Then $sHeader = ""
If $iMax_ColWidth = Default Then $iMax_ColWidth = 350
If $iAlt_Color = Default Then $iAlt_Color = 0
If $hUser_Function = Default Then $hUser_Function = 0
Local $iTranspose = BitAND($iFlags, 1)
Local $iColAlign = BitAND($iFlags, 6)
Local $iVerbose = BitAND($iFlags, 8)
Local $iButtonMargin = ((BitAND($iFlags, 32)) ? (0) : ((BitAND($iFlags, 16)) ? (20) : (40)))
Local $iNoRow = BitAND($iFlags, 64)
Local $sMsg = "", $iRet = 1
If IsArray($aArray) Then
Local $iDimension = UBound($aArray, $UBOUND_DIMENSIONS), $iRowCount = UBound($aArray, $UBOUND_ROWS), $iColCount = UBound($aArray, $UBOUND_COLUMNS)
If $iDimension > 2 Then
$sMsg = "Larger than 2D array passed to function"
$iRet = 2
EndIf
Else
$sMsg = "No array variable passed to function"
EndIf
If $sMsg Then
If $iVerbose And MsgBox($MB_SYSTEMMODAL + $MB_ICONERROR + $MB_YESNO,  "ArrayDisplay Error: " & $sTitle, $sMsg & @CRLF & @CRLF & "Exit the script?") = $IDYES Then
Exit
Else
Return SetError($iRet, 0, "")
EndIf
EndIf
Local $iCW_ColWidth = Number($vUser_Separator)
Local $sAD_Separator = ChrW(0xFAB1)
Local $sCurr_Separator = Opt("GUIDataSeparatorChar", $sAD_Separator)
If $vUser_Separator = "" Then $vUser_Separator = $sCurr_Separator
Local $vTmp, $iRowLimit = 65525, $iColLimit = 250
Local $iDataRow = $iRowCount
Local $iDataCol = $iColCount
Local $iItem_Start = 0, $iItem_End = $iRowCount - 1, $iSubItem_Start = 0, $iSubItem_End = (($iDimension = 2) ? ($iColCount - 1) : (0))
Local $bRange_Flag = False, $avRangeSplit
If $sArrayRange Then
Local $aArray_Range = StringRegExp($sArrayRange & "||", "(?U)(.*)\|", 3)
If $aArray_Range[0] Then
$avRangeSplit = StringSplit($aArray_Range[0], ":")
If @error Then
$iItem_End = Number($avRangeSplit[1])
Else
$iItem_Start = Number($avRangeSplit[1])
$iItem_End = Number($avRangeSplit[2])
EndIf
EndIf
If $iItem_Start > $iItem_End Then
$vTmp = $iItem_Start
$iItem_Start = $iItem_End
$iItem_End = $vTmp
EndIf
If $iItem_Start < 0 Then $iItem_Start = 0
If $iItem_End > $iRowCount - 1 Then $iItem_End = $iRowCount - 1
If $iItem_Start <> 0 Or $iItem_End <> $iRowCount - 1 Then $bRange_Flag = True
If $iDimension = 2 And $aArray_Range[1] Then
$avRangeSplit = StringSplit($aArray_Range[1], ":")
If @error Then
$iSubItem_End = Number($avRangeSplit[1])
Else
$iSubItem_Start = Number($avRangeSplit[1])
$iSubItem_End = Number($avRangeSplit[2])
EndIf
If $iSubItem_Start > $iSubItem_End Then
$vTmp = $iSubItem_Start
$iSubItem_Start = $iSubItem_End
$iSubItem_End = $vTmp
EndIf
If $iSubItem_Start < 0 Then $iSubItem_Start = 0
If $iSubItem_End > $iColCount - 1 Then $iSubItem_End = $iColCount - 1
If $iSubItem_Start <> 0 Or $iSubItem_End <> $iColCount - 1 Then $bRange_Flag = True
EndIf
EndIf
Local $sDisplayData = "[" & $iDataRow
Local $bTruncated = False
If $iTranspose Then
If $iItem_End - $iItem_Start > $iColLimit Then
$bTruncated = True
$iItem_End = $iItem_Start + $iColLimit - 1
EndIf
Else
If $iItem_End - $iItem_Start > $iRowLimit Then
$bTruncated = True
$iItem_End = $iItem_Start + $iRowLimit - 1
EndIf
EndIf
If $bTruncated Then
$sDisplayData &= "*]"
Else
$sDisplayData &= "]"
EndIf
If $iDimension = 2 Then
$sDisplayData &= " [" & $iDataCol
If $iTranspose Then
If $iSubItem_End - $iSubItem_Start > $iRowLimit Then
$bTruncated = True
$iSubItem_End = $iSubItem_Start + $iRowLimit - 1
EndIf
Else
If $iSubItem_End - $iSubItem_Start > $iColLimit Then
$bTruncated = True
$iSubItem_End = $iSubItem_Start + $iColLimit - 1
EndIf
EndIf
If $bTruncated Then
$sDisplayData &= "*]"
Else
$sDisplayData &= "]"
EndIf
EndIf
Local $sTipData = ""
If $bTruncated Then $sTipData &= "Truncated"
If $bRange_Flag Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Range set"
EndIf
If $iTranspose Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Transposed"
EndIf
Local $asHeader = StringSplit($sHeader, $sCurr_Separator, $STR_NOCOUNT)
If UBound($asHeader) = 0 Then Local $asHeader[1] = [""]
$sHeader = "Row"
Local $iIndex = $iSubItem_Start
If $iTranspose Then
For $j = $iItem_Start To $iItem_End
$sHeader &= $sAD_Separator & "Col " & $j
Next
Else
If $asHeader[0] Then
For $iIndex = $iSubItem_Start To $iSubItem_End
If $iIndex >= UBound($asHeader) Then ExitLoop
$sHeader &= $sAD_Separator & $asHeader[$iIndex]
Next
EndIf
For $j = $iIndex To $iSubItem_End
$sHeader &= $sAD_Separator & "Col " & $j
Next
EndIf
If $iNoRow Then $sHeader = StringTrimLeft($sHeader, 4)
If $iVerbose And ($iItem_End - $iItem_Start + 1) * ($iSubItem_End - $iSubItem_Start + 1) > 10000 Then
SplashTextOn("ArrayDisplay", "Preparing display" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local $iBuffer = 4094
If $iTranspose Then
$vTmp = $iItem_Start
$iItem_Start = $iSubItem_Start
$iSubItem_Start = $vTmp
$vTmp = $iItem_End
$iItem_End = $iSubItem_End
$iSubItem_End = $vTmp
EndIf
Local $avArrayText[$iItem_End - $iItem_Start + 1]
For $i = $iItem_Start To $iItem_End
If Not $iNoRow Then $avArrayText[$i - $iItem_Start] = "[" & $i & "]"
For $j = $iSubItem_Start To $iSubItem_End
If $iDimension = 1 Then
If $iTranspose Then
Switch VarGetType($aArray[$j])
Case "Array"
$vTmp = "{Array}"
Case Else
$vTmp = $aArray[$j]
EndSwitch
Else
Switch VarGetType($aArray[$i])
Case "Array"
$vTmp = "{Array}"
Case Else
$vTmp = $aArray[$i]
EndSwitch
EndIf
Else
If $iTranspose Then
Switch VarGetType($aArray[$j][$i])
Case "Array"
$vTmp = "{Array}"
Case Else
$vTmp = $aArray[$j][$i]
EndSwitch
Else
Switch VarGetType($aArray[$i][$j])
Case "Array"
$vTmp = "{Array}"
Case Else
$vTmp = $aArray[$i][$j]
EndSwitch
EndIf
EndIf
If StringLen($vTmp) > $iBuffer Then $vTmp = StringLeft($vTmp, $iBuffer)
$avArrayText[$i - $iItem_Start] &= $sAD_Separator & $vTmp
Next
If $iNoRow Then $avArrayText[$i - $iItem_Start] = StringTrimLeft($avArrayText[$i - $iItem_Start], 1)
Next
Local Const $_ARRAYCONSTANT_GUI_DOCKBOTTOM = 64
Local Const $_ARRAYCONSTANT_GUI_DOCKBORDERS = 102
Local Const $_ARRAYCONSTANT_GUI_DOCKHEIGHT = 512
Local Const $_ARRAYCONSTANT_GUI_DOCKLEFT = 2
Local Const $_ARRAYCONSTANT_GUI_DOCKRIGHT = 4
Local Const $_ARRAYCONSTANT_GUI_DOCKHCENTER = 8
Local Const $_ARRAYCONSTANT_GUI_EVENT_CLOSE = -3
Local Const $_ARRAYCONSTANT_GUI_FOCUS = 256
Local Const $_ARRAYCONSTANT_GUI_BKCOLOR_LV_ALTERNATE = 0xFE000000
Local Const $_ARRAYCONSTANT_SS_CENTER = 0x1
Local Const $_ARRAYCONSTANT_SS_CENTERIMAGE = 0x0200
Local Const $_ARRAYCONSTANT_LVM_GETITEMCOUNT = (0x1000 + 4)
Local Const $_ARRAYCONSTANT_LVM_GETITEMRECT = (0x1000 + 14)
Local Const $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH = (0x1000 + 29)
Local Const $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH = (0x1000 + 30)
Local Const $_ARRAYCONSTANT_LVM_GETITEMSTATE = (0x1000 + 44)
Local Const $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT = (0x1000 + 50)
Local Const $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000 + 54)
Local Const $_ARRAYCONSTANT_LVS_EX_GRIDLINES = 0x1
Local Const $_ARRAYCONSTANT_LVIS_SELECTED = 0x2
Local Const $_ARRAYCONSTANT_LVS_SHOWSELALWAYS = 0x8
Local Const $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT = 0x20
Local Const $_ARRAYCONSTANT_WS_EX_CLIENTEDGE = 0x0200
Local Const $_ARRAYCONSTANT_WS_MAXIMIZEBOX = 0x00010000
Local Const $_ARRAYCONSTANT_WS_MINIMIZEBOX = 0x00020000
Local Const $_ARRAYCONSTANT_WS_SIZEBOX = 0x00040000
Local Const $_ARRAYCONSTANT_WM_SETREDRAW = 11
Local Const $_ARRAYCONSTANT_LVSCW_AUTOSIZE = -1
Local $iCoordMode = Opt("GUICoordMode", 1)
Local $iOrgWidth = 210, $iHeight = 200, $iMinSize = 250
Local $hGUI = GUICreate($sTitle, $iOrgWidth, $iHeight, Default, Default, BitOR($_ARRAYCONSTANT_WS_SIZEBOX, $_ARRAYCONSTANT_WS_MINIMIZEBOX, $_ARRAYCONSTANT_WS_MAXIMIZEBOX))
Local $aiGUISize = WinGetClientSize($hGUI)
Local $iButtonWidth_2 = $aiGUISize[0] / 2
Local $iButtonWidth_3 = $aiGUISize[0] / 3
Local $idListView = GUICtrlCreateListView($sHeader, 0, 0, $aiGUISize[0], $aiGUISize[1] - $iButtonMargin, $_ARRAYCONSTANT_LVS_SHOWSELALWAYS)
GUICtrlSetBkColor($idListView, $_ARRAYCONSTANT_GUI_BKCOLOR_LV_ALTERNATE)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_GRIDLINES, $_ARRAYCONSTANT_LVS_EX_GRIDLINES)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE)
Local $idCopy_ID = 9999, $idCopy_Data = 99999, $idData_Label = 99999, $idUser_Func = 99999, $idExit_Script = 99999
If $iButtonMargin Then
$idCopy_ID = GUICtrlCreateButton("Copy Data && Hdr/Row", 0, $aiGUISize[1] - $iButtonMargin, $iButtonWidth_2, 20)
$idCopy_Data = GUICtrlCreateButton("Copy Data Only", $iButtonWidth_2, $aiGUISize[1] - $iButtonMargin, $iButtonWidth_2, 20)
If $iButtonMargin = 40 Then
Local $iButtonWidth_Var = $iButtonWidth_2
Local $iOffset = $iButtonWidth_2
If IsFunc($hUser_Function) Then
$idUser_Func = GUICtrlCreateButton("Run User Func", $iButtonWidth_3, $aiGUISize[1] - 20, $iButtonWidth_3, 20)
$iButtonWidth_Var = $iButtonWidth_3
$iOffset = $iButtonWidth_3 * 2
EndIf
$idExit_Script = GUICtrlCreateButton("Exit Script", $iOffset, $aiGUISize[1] - 20, $iButtonWidth_Var, 20)
$idData_Label = GUICtrlCreateLabel($sDisplayData, 0, $aiGUISize[1] - 20, $iButtonWidth_Var, 18, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
Select
Case $bTruncated Or $iTranspose Or $bRange_Flag
GUICtrlSetColor($idData_Label, 0xFF0000)
GUICtrlSetTip($idData_Label, $sTipData)
EndSelect
EndIf
EndIf
GUICtrlSetResizing($idListView, $_ARRAYCONSTANT_GUI_DOCKBORDERS)
GUICtrlSetResizing($idCopy_ID, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idCopy_Data, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idData_Label, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idUser_Func, $_ARRAYCONSTANT_GUI_DOCKHCENTER + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idExit_Script, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_WM_SETREDRAW, 0, 0)
Local $idItem
For $i = 0 To UBound($avArrayText) - 1
$idItem = GUICtrlCreateListViewItem($avArrayText[$i], $idListView)
If $iAlt_Color Then
GUICtrlSetBkColor($idItem, $iAlt_Color)
EndIf
Next
If $iColAlign Then
Local Const $_ARRAYCONSTANT_LVCF_FMT = 0x01
Local Const $_ARRAYCONSTANT_LVM_SETCOLUMNW = (0x1000 + 96)
Local $tColumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
DllStructSetData($tColumn, "Mask", $_ARRAYCONSTANT_LVCF_FMT)
DllStructSetData($tColumn, "Fmt", $iColAlign / 2)
Local $pColumn = DllStructGetPtr($tColumn)
For $i = 1 To $iSubItem_End - $iSubItem_Start + 1
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNW, $i, $pColumn)
Next
EndIf
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_WM_SETREDRAW, 1, 0)
Local $iBorder = 45
If UBound($avArrayText) > 20 Then
$iBorder += 20
EndIf
Local $iWidth = $iBorder, $iColWidth = 0, $aiColWidth[$iSubItem_End - $iSubItem_Start + 2], $iMin_ColWidth = 55
For $i = 0 To $iSubItem_End - $iSubItem_Start + 1
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $_ARRAYCONSTANT_LVSCW_AUTOSIZE)
$iColWidth = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH, $i, 0)
If $iColWidth < $iMin_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMin_ColWidth)
$iColWidth = $iMin_ColWidth
EndIf
$iWidth += $iColWidth
$aiColWidth[$i] = $iColWidth
Next
If $iNoRow Then $iWidth -= 55
If $iWidth > @DesktopWidth - 100 Then
$iWidth = $iBorder
For $i = 0 To $iSubItem_End - $iSubItem_Start + 1
If $aiColWidth[$i] > $iMax_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMax_ColWidth)
$iWidth += $iMax_ColWidth
Else
$iWidth += $aiColWidth[$i]
EndIf
Next
EndIf
If $iWidth > @DesktopWidth - 100 Then
$iWidth = @DesktopWidth - 100
ElseIf $iWidth < $iMinSize Then
$iWidth = $iMinSize
EndIf
Local $tRECT = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", GUICtrlGetHandle($idListView), "uint", $_ARRAYCONSTANT_LVM_GETITEMRECT, "wparam", 0, "struct*", $tRECT)
Local $aiWin_Pos = WinGetPos($hGUI)
Local $aiLV_Pos = ControlGetPos($hGUI, "", $idListView)
$iHeight = ((UBound($avArrayText) + 2) * (DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top"))) + $aiWin_Pos[3] - $aiLV_Pos[3]
If $iHeight > @DesktopHeight - 100 Then
$iHeight = @DesktopHeight - 100
ElseIf $iHeight < $iMinSize Then
$iHeight = $iMinSize
EndIf
If $iVerbose Then SplashOff()
GUISetState(@SW_HIDE, $hGUI)
WinMove($hGUI, "", (@DesktopWidth - $iWidth) / 2, (@DesktopHeight - $iHeight) / 2, $iWidth, $iHeight)
GUISetState(@SW_SHOW, $hGUI)
Local $iOnEventMode = Opt("GUIOnEventMode", 0), $iMsg
While 1
$iMsg = GUIGetMsg()
Switch $iMsg
Case $_ARRAYCONSTANT_GUI_EVENT_CLOSE
ExitLoop
Case $idCopy_ID, $idCopy_Data
Local $iSel_Count = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT, 0, 0)
If $iVerbose And (Not $iSel_Count) And ($iItem_End - $iItem_Start) * ($iSubItem_End - $iSubItem_Start) > 10000 Then
SplashTextOn("ArrayDisplay", "Copying data" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local $sClip = "", $sItem, $aSplit
For $i = 0 To $iItem_End - $iItem_Start
If $iSel_Count And Not (GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED)) Then
ContinueLoop
EndIf
$sItem = $avArrayText[$i]
If $iMsg = $idCopy_Data Then
$sItem = StringRegExpReplace($sItem, "^\[\d+\].(.*)$", "$1")
EndIf
If $iCW_ColWidth Then
$aSplit = StringSplit($sItem, $sAD_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sItem, $sAD_Separator, $vUser_Separator)
EndIf
$sClip &= $sItem & @CRLF
Next
If $iMsg = $idCopy_ID Then
If $iCW_ColWidth Then
$aSplit = StringSplit($sHeader, $sAD_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sHeader, $sAD_Separator, $vUser_Separator)
EndIf
$sClip = $sItem & @CRLF & $sClip
EndIf
ClipPut($sClip)
SplashOff()
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idUser_Func
Local $aiSelItems[$iRowLimit] = [0]
For $i = 0 To GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMCOUNT, 0, 0)
If GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) Then
$aiSelItems[0] += 1
$aiSelItems[$aiSelItems[0]] = $i + $iItem_Start
EndIf
Next
ReDim $aiSelItems[$aiSelItems[0] + 1]
$hUser_Function($aArray, $aiSelItems)
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idExit_Script
GUIDelete($hGUI)
Exit
EndSwitch
WEnd
GUIDelete($hGUI)
Opt("GUICoordMode", $iCoordMode)
Opt("GUIOnEventMode", $iOnEventMode)
Opt("GUIDataSeparatorChar", $sCurr_Separator)
Return 1
EndFunc
Func _ArrayExtract(Const ByRef $aArray, $iStart_Row = -1, $iEnd_Row = -1, $iStart_Col = -1, $iEnd_Col = -1)
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
For $i = 0 To $iEnd_Row - $iStart_Row
$aRetArray[$i] = $aArray[$i + $iStart_Row]
Next
Return $aRetArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col = -1 Then $iStart_Col = 0
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
If $iStart_Col = $iEnd_Col Then
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
Else
Local $aRetArray[$iEnd_Row - $iStart_Row + 1][$iEnd_Col - $iStart_Col + 1]
EndIf
For $i = 0 To $iEnd_Row - $iStart_Row
For $j = 0 To $iEnd_Col - $iStart_Col
If $iStart_Col = $iEnd_Col Then
$aRetArray[$i] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
Else
$aRetArray[$i][$j] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
EndIf
Next
Next
Return $aRetArray
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayFindAll(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iSubItem = 0, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iSubItem = Default Then $iSubItem = 0
If $bRow = Default Then $bRow = False
$iStart = _ArraySearch($aArray, $vValue, $iStart, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
If @error Then Return SetError(@error, 0, -1)
Local $iIndex = 0, $avResult[UBound($aArray, ($bRow ? $UBOUND_COLUMNS : $UBOUND_ROWS))]
Do
$avResult[$iIndex] = $iStart
$iIndex += 1
$iStart = _ArraySearch($aArray, $vValue, $iStart + 1, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
Until @error
ReDim $avResult[$iIndex]
Return $avResult
EndFunc
Func _ArrayInsert(ByRef $aArray, $vRange, $vValue = "", $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $vValue = Default Then $vValue = ""
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
EndSwitch
Local $aSplit_1, $aSplit_2
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
For $i = 2 To $vRange[0]
If $vRange[$i] < $vRange[$i - 1] Then Return SetError(3, 0, -1)
Next
Local $iCopyTo_Index = $iDim_1 + $vRange[0]
Local $iInsertPoint_Index = $vRange[0]
Local $iInsert_Index = $vRange[$iInsertPoint_Index]
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + $vRange[0] + 1]
For $iReadFromIndex = $iDim_1 To 0 Step -1
$aArray[$iCopyTo_Index] = $aArray[$iReadFromIndex]
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
$aArray[$iCopyTo_Index] = $vValue
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index < 1 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Return $iDim_1 + $vRange[0] + 1
EndIf
ReDim $aArray[$iDim_1 + $vRange[0] + 1]
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
$hDataType = 0
EndIf
$vValue = $aTmp
EndIf
For $iReadFromIndex = $iDim_1 To 0 Step -1
$aArray[$iCopyTo_Index] = $aArray[$iReadFromIndex]
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
If $iInsertPoint_Index <= UBound($vValue, $UBOUND_ROWS) Then
If IsFunc($hDataType) Then
$aArray[$iCopyTo_Index] = $hDataType($vValue[$iInsertPoint_Index - 1])
Else
$aArray[$iCopyTo_Index] = $vValue[$iInsertPoint_Index - 1]
EndIf
Else
$aArray[$iCopyTo_Index] = ""
EndIf
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index = 0 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(6, 0, -1)
Local $iValDim_1, $iValDim_2
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(7, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
$aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
StringReplace($aSplit_1[0], $sDelim_Item, "")
$iValDim_2 = @extended + 1
Local $aTmp[$iValDim_1][$iValDim_2]
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
For $j = 0 To $iValDim_2 - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(8, 0, -1)
ReDim $aArray[$iDim_1 + $vRange[0] + 1][$iDim_2]
For $iReadFromIndex = $iDim_1 To 0 Step -1
For $j = 0 To $iDim_2 - 1
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFromIndex][$j]
Next
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iCopyTo_Index][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iCopyTo_Index][$j] = ""
Else
If $iInsertPoint_Index - 1 < $iValDim_1 Then
If IsFunc($hDataType) Then
$aArray[$iCopyTo_Index][$j] = $hDataType($vValue[$iInsertPoint_Index - 1][$j - $iStart])
Else
$aArray[$iCopyTo_Index][$j] = $vValue[$iInsertPoint_Index - 1][$j - $iStart]
EndIf
Else
$aArray[$iCopyTo_Index][$j] = ""
EndIf
EndIf
Next
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index = 0 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayMax(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMaxIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_GreaterThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayMin(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMinIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMinIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_LessThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayPermute(ByRef $aArray, $sDelimiter = "")
If $sDelimiter = Default Then $sDelimiter = ""
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, 0)
Local $iSize = UBound($aArray), $iFactorial = 1, $aIdx[$iSize], $aResult[1], $iCount = 1
If UBound($aArray) Then
For $i = 0 To $iSize - 1
$aIdx[$i] = $i
Next
For $i = $iSize To 1 Step -1
$iFactorial *= $i
Next
ReDim $aResult[$iFactorial + 1]
$aResult[0] = $iFactorial
__Array_ExeterInternal($aArray, 0, $iSize, $sDelimiter, $aIdx, $aResult, $iCount)
Else
$aResult[0] = 0
EndIf
Return $aResult
EndFunc
Func _ArrayPop(ByRef $aArray)
If (Not IsArray($aArray)) Then Return SetError(1, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, "")
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(3, 0, "")
Local $sLastVal = $aArray[$iUBound]
If $iUBound > -1 Then
ReDim $aArray[$iUBound]
EndIf
Return $sLastVal
EndFunc
Func _ArrayPush(ByRef $aArray, $vValue, $iDirection = 0)
If $iDirection = Default Then $iDirection = 0
If (Not IsArray($aArray)) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
Local $iUBound = UBound($aArray) - 1
If IsArray($vValue) Then
Local $iUBoundS = UBound($vValue)
If ($iUBoundS - 1) > $iUBound Then Return SetError(2, 0, 0)
If $iDirection Then
For $i = $iUBound To $iUBoundS Step -1
$aArray[$i] = $aArray[$i - $iUBoundS]
Next
For $i = 0 To $iUBoundS - 1
$aArray[$i] = $vValue[$i]
Next
Else
For $i = 0 To $iUBound - $iUBoundS
$aArray[$i] = $aArray[$i + $iUBoundS]
Next
For $i = 0 To $iUBoundS - 1
$aArray[$i + $iUBound - $iUBoundS + 1] = $vValue[$i]
Next
EndIf
Else
If $iUBound > -1 Then
If $iDirection Then
For $i = $iUBound To 1 Step -1
$aArray[$i] = $aArray[$i - 1]
Next
$aArray[0] = $vValue
Else
For $i = 0 To $iUBound - 1
$aArray[$i] = $aArray[$i + 1]
Next
$aArray[$iUBound] = $vValue
EndIf
EndIf
EndIf
Return 1
EndFunc
Func _ArrayReverse(ByRef $aArray, $iStart = 0, $iEnd = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
If Not UBound($aArray) Then Return SetError(4, 0, 0)
Local $vTmp, $iUBound = UBound($aArray) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
For $i = $iStart To Int(($iStart + $iEnd - 1) / 2)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iEnd]
$aArray[$iEnd] = $vTmp
$iEnd -= 1
Next
Return 1
EndFunc
Func _ArraySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iForward = 1, $iSubItem = -1, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iForward = Default Then $iForward = 1
If $iSubItem = Default Then $iSubItem = -1
If $bRow = Default Then $bRow = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray) - 1
If $iDim_1 = -1 Then Return SetError(3, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
Local $bCompType = False
If $iCompare = 2 Then
$iCompare = 0
$bCompType = True
EndIf
If $bRow Then
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then Return SetError(5, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_2 Then $iEnd = $iDim_2
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Else
If $iEnd < 1 Or $iEnd > $iDim_1 Then $iEnd = $iDim_1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
EndIf
Local $iStep = 1
If Not $iForward Then
Local $iTmp = $iStart
$iStart = $iEnd
$iEnd = $iTmp
$iStep = -1
EndIf
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] = $vValue Then Return $i
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] == $vValue Then Return $i
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If StringRegExp($aArray[$i], $vValue) Then Return $i
Else
If StringInStr($aArray[$i], $vValue, $iCase) > 0 Then Return $i
EndIf
Next
EndIf
Case 2
Local $iDim_Sub
If $bRow Then
$iDim_Sub = $iDim_1
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
Else
$iDim_Sub = $iDim_2
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
EndIf
For $j = $iSubItem To $iDim_Sub
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] = $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] = $vValue Then Return $i
EndIf
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] == $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] == $vValue Then Return $i
EndIf
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If $bRow Then
If StringRegExp($aArray[$j][$i], $vValue) Then Return $i
Else
If StringRegExp($aArray[$i][$j], $vValue) Then Return $i
EndIf
Else
If $bRow Then
If StringInStr($aArray[$j][$i], $vValue, $iCase) > 0 Then Return $i
Else
If StringInStr($aArray[$i][$j], $vValue, $iCase) > 0 Then Return $i
EndIf
EndIf
Next
EndIf
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return SetError(6, 0, -1)
EndFunc
Func _ArrayShuffle(ByRef $aArray, $iStart_Row = 0, $iEnd_Row = 0, $iCol = -1)
If $iStart_Row = Default Then $iStart_Row = 0
If $iEnd_Row = Default Then $iEnd_Row = 0
If $iCol = Default Then $iCol = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iEnd_Row = 0 Then $iEnd_Row = $iDim_1 - 1
If $iStart_Row < 0 Or $iStart_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iEnd_Row < 1 Or $iEnd_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $vTmp, $iRand
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iRand]
$aArray[$iRand] = $vTmp
Next
Return 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iCol < -1 Or $iCol > $iDim_2 - 1 Then Return SetError(5, 0, -1)
Local $iCol_Start, $iCol_End
If $iCol = -1 Then
$iCol_Start = 0
$iCol_End = $iDim_2 - 1
Else
$iCol_Start = $iCol
$iCol_End = $iCol
EndIf
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
For $j = $iCol_Start To $iCol_End
$vTmp = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$iRand][$j]
$aArray[$iRand][$j] = $vTmp
Next
Next
Return 1
Case Else
Return SetError(2, 0, -1)
EndSwitch
EndFunc
Func _ArraySort(ByRef $aArray, $iDescending = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0, $iPivot = 0)
If $iDescending = Default Then $iDescending = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If $iPivot = Default Then $iPivot = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(5, 0, 0)
If $iEnd = Default Then $iEnd = 0
If $iEnd < 1 Or $iEnd > $iUBound Or $iEnd = Default Then $iEnd = $iUBound
If $iStart < 0 Or $iStart = Default Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
If $iDescending = Default Then $iDescending = 0
If $iPivot = Default Then $iPivot = 0
If $iSubItem = Default Then $iSubItem = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iPivot Then
__ArrayDualPivotSort($aArray, $iStart, $iEnd)
Else
__ArrayQuickSort1D($aArray, $iStart, $iEnd)
EndIf
If $iDescending Then _ArrayReverse($aArray, $iStart, $iEnd)
Case 2
If $iPivot Then Return SetError(6, 0, 0)
Local $iSubMax = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem > $iSubMax Then Return SetError(3, 0, 0)
If $iDescending Then
$iDescending = -1
Else
$iDescending = 1
EndIf
__ArrayQuickSort2D($aArray, $iDescending, $iStart, $iEnd, $iSubItem, $iSubMax)
Case Else
Return SetError(4, 0, 0)
EndSwitch
Return 1
EndFunc
Func __ArrayQuickSort1D(ByRef $aArray, Const ByRef $iStart, Const ByRef $iEnd)
If $iEnd <= $iStart Then Return
Local $vTmp
If ($iEnd - $iStart) < 15 Then
Local $vCur
For $i = $iStart + 1 To $iEnd
$vTmp = $aArray[$i]
If IsNumber($vTmp) Then
For $j = $i - 1 To $iStart Step -1
$vCur = $aArray[$j]
If ($vTmp >= $vCur And IsNumber($vCur)) Or (Not IsNumber($vCur) And StringCompare($vTmp, $vCur) >= 0) Then ExitLoop
$aArray[$j + 1] = $vCur
Next
Else
For $j = $i - 1 To $iStart Step -1
If (StringCompare($vTmp, $aArray[$j]) >= 0) Then ExitLoop
$aArray[$j + 1] = $aArray[$j]
Next
EndIf
$aArray[$j + 1] = $vTmp
Next
Return
EndIf
Local $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While ($aArray[$L] < $vPivot And IsNumber($aArray[$L])) Or (Not IsNumber($aArray[$L]) And StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While ($aArray[$R] > $vPivot And IsNumber($aArray[$R])) Or (Not IsNumber($aArray[$R]) And StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
Else
While (StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While (StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
$vTmp = $aArray[$L]
$aArray[$L] = $aArray[$R]
$aArray[$R] = $vTmp
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort1D($aArray, $iStart, $R)
__ArrayQuickSort1D($aArray, $L, $iEnd)
EndFunc
Func __ArrayQuickSort2D(ByRef $aArray, Const ByRef $iStep, Const ByRef $iStart, Const ByRef $iEnd, Const ByRef $iSubItem, Const ByRef $iSubMax)
If $iEnd <= $iStart Then Return
Local $vTmp, $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)][$iSubItem], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While ($iStep * ($aArray[$L][$iSubItem] - $vPivot) < 0 And IsNumber($aArray[$L][$iSubItem])) Or (Not IsNumber($aArray[$L][$iSubItem]) And $iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While ($iStep * ($aArray[$R][$iSubItem] - $vPivot) > 0 And IsNumber($aArray[$R][$iSubItem])) Or (Not IsNumber($aArray[$R][$iSubItem]) And $iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
Else
While ($iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While ($iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
For $i = 0 To $iSubMax
$vTmp = $aArray[$L][$i]
$aArray[$L][$i] = $aArray[$R][$i]
$aArray[$R][$i] = $vTmp
Next
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort2D($aArray, $iStep, $iStart, $R, $iSubItem, $iSubMax)
__ArrayQuickSort2D($aArray, $iStep, $L, $iEnd, $iSubItem, $iSubMax)
EndFunc
Func __ArrayDualPivotSort(ByRef $aArray, $iPivot_Left, $iPivot_Right, $bLeftMost = True)
If $iPivot_Left > $iPivot_Right Then Return
Local $iLength = $iPivot_Right - $iPivot_Left + 1
Local $i, $j, $k, $iAi, $iAk, $iA1, $iA2, $iLast
If $iLength < 45 Then
If $bLeftMost Then
$i = $iPivot_Left
While $i < $iPivot_Right
$j = $i
$iAi = $aArray[$i + 1]
While $iAi < $aArray[$j]
$aArray[$j + 1] = $aArray[$j]
$j -= 1
If $j + 1 = $iPivot_Left Then ExitLoop
WEnd
$aArray[$j + 1] = $iAi
$i += 1
WEnd
Else
While 1
If $iPivot_Left >= $iPivot_Right Then Return 1
$iPivot_Left += 1
If $aArray[$iPivot_Left] < $aArray[$iPivot_Left - 1] Then ExitLoop
WEnd
While 1
$k = $iPivot_Left
$iPivot_Left += 1
If $iPivot_Left > $iPivot_Right Then ExitLoop
$iA1 = $aArray[$k]
$iA2 = $aArray[$iPivot_Left]
If $iA1 < $iA2 Then
$iA2 = $iA1
$iA1 = $aArray[$iPivot_Left]
EndIf
$k -= 1
While $iA1 < $aArray[$k]
$aArray[$k + 2] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 2] = $iA1
While $iA2 < $aArray[$k]
$aArray[$k + 1] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 1] = $iA2
$iPivot_Left += 1
WEnd
$iLast = $aArray[$iPivot_Right]
$iPivot_Right -= 1
While $iLast < $aArray[$iPivot_Right]
$aArray[$iPivot_Right + 1] = $aArray[$iPivot_Right]
$iPivot_Right -= 1
WEnd
$aArray[$iPivot_Right + 1] = $iLast
EndIf
Return 1
EndIf
Local $iSeventh = BitShift($iLength, 3) + BitShift($iLength, 6) + 1
Local $iE1, $iE2, $iE3, $iE4, $iE5, $t
$iE3 = Ceiling(($iPivot_Left + $iPivot_Right) / 2)
$iE2 = $iE3 - $iSeventh
$iE1 = $iE2 - $iSeventh
$iE4 = $iE3 + $iSeventh
$iE5 = $iE4 + $iSeventh
If $aArray[$iE2] < $aArray[$iE1] Then
$t = $aArray[$iE2]
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
If $aArray[$iE3] < $aArray[$iE2] Then
$t = $aArray[$iE3]
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
If $aArray[$iE4] < $aArray[$iE3] Then
$t = $aArray[$iE4]
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
If $aArray[$iE5] < $aArray[$iE4] Then
$t = $aArray[$iE5]
$aArray[$iE5] = $aArray[$iE4]
$aArray[$iE4] = $t
If $t < $aArray[$iE3] Then
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
EndIf
Local $iLess = $iPivot_Left
Local $iGreater = $iPivot_Right
If (($aArray[$iE1] <> $aArray[$iE2]) And ($aArray[$iE2] <> $aArray[$iE3]) And ($aArray[$iE3] <> $aArray[$iE4]) And ($aArray[$iE4] <> $aArray[$iE5])) Then
Local $iPivot_1 = $aArray[$iE2]
Local $iPivot_2 = $aArray[$iE4]
$aArray[$iE2] = $aArray[$iPivot_Left]
$aArray[$iE4] = $aArray[$iPivot_Right]
Do
$iLess += 1
Until $aArray[$iLess] >= $iPivot_1
Do
$iGreater -= 1
Until $aArray[$iGreater] <= $iPivot_2
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk > $iPivot_2 Then
While $aArray[$iGreater] > $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
$aArray[$iPivot_Left] = $aArray[$iLess - 1]
$aArray[$iLess - 1] = $iPivot_1
$aArray[$iPivot_Right] = $aArray[$iGreater + 1]
$aArray[$iGreater + 1] = $iPivot_2
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 2, True)
__ArrayDualPivotSort($aArray, $iGreater + 2, $iPivot_Right, False)
If ($iLess < $iE1) And ($iE5 < $iGreater) Then
While $aArray[$iLess] = $iPivot_1
$iLess += 1
WEnd
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
WEnd
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk = $iPivot_2 Then
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iPivot_1
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
EndIf
__ArrayDualPivotSort($aArray, $iLess, $iGreater, False)
Else
Local $iPivot = $aArray[$iE3]
$k = $iLess
While $k <= $iGreater
If $aArray[$k] = $iPivot Then
$k += 1
ContinueLoop
EndIf
$iAk = $aArray[$k]
If $iAk < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
Else
While $aArray[$iGreater] > $iPivot
$iGreater -= 1
WEnd
If $aArray[$iGreater] < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $iPivot
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 1, True)
__ArrayDualPivotSort($aArray, $iGreater + 1, $iPivot_Right, False)
EndIf
EndFunc
Func _ArraySwap(ByRef $aArray, $iIndex_1, $iIndex_2, $bCol = False, $iStart = -1, $iEnd = -1)
If $bCol = Default Then $bCol = False
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iDim_2 = -1 Then
$bCol = False
$iStart = -1
$iEnd = -1
EndIf
If $iStart > $iEnd Then Return SetError(5, 0, -1)
If $bCol Then
If $iIndex_1 < 0 Or $iIndex_2 > $iDim_2 Then Return SetError(3, 0, -1)
If $iStart = -1 Then $iStart = 0
If $iEnd = -1 Then $iEnd = $iDim_1
Else
If $iIndex_1 < 0 Or $iIndex_2 > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart = -1 Then $iStart = 0
If $iEnd = -1 Then $iEnd = $iDim_2
EndIf
Local $vTmp
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
$vTmp = $aArray[$iIndex_1]
$aArray[$iIndex_1] = $aArray[$iIndex_2]
$aArray[$iIndex_2] = $vTmp
Case 2
If $iStart < -1 Or $iEnd < -1 Then Return SetError(4, 0, -1)
If $bCol Then
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(4, 0, -1)
For $j = $iStart To $iEnd
$vTmp = $aArray[$j][$iIndex_1]
$aArray[$j][$iIndex_1] = $aArray[$j][$iIndex_2]
$aArray[$j][$iIndex_2] = $vTmp
Next
Else
If $iStart > $iDim_2 Or $iEnd > $iDim_2 Then Return SetError(4, 0, -1)
For $j = $iStart To $iEnd
$vTmp = $aArray[$iIndex_1][$j]
$aArray[$iIndex_1][$j] = $aArray[$iIndex_2][$j]
$aArray[$iIndex_2][$j] = $vTmp
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayToClip(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
Local $sResult = _ArrayToString($aArray, $sDelim_Col, $iStart_Row, $iEnd_Row, $sDelim_Row, $iStart_Col, $iEnd_Col)
If @error Then Return SetError(@error, 0, 0)
If ClipPut($sResult) Then Return 1
Return SetError(-1, 0, 0)
EndFunc
Func _ArrayToString(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
If $sDelim_Col = Default Then $sDelim_Col = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, "")
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $sRet = ""
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iStart_Row To $iEnd_Row
$sRet &= $aArray[$i] & $sDelim_Col
Next
Return StringTrimRight($sRet, StringLen($sDelim_Col))
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iStart_Col = -1 Then $iStart_Col = 0
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
For $i = $iStart_Row To $iEnd_Row
For $j = $iStart_Col To $iEnd_Col
$sRet &= $aArray[$i][$j] & $sDelim_Col
Next
$sRet = StringTrimRight($sRet, StringLen($sDelim_Col)) & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Row))
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayTranspose(ByRef $aArray)
Switch UBound($aArray, 0)
Case 0
Return SetError(2, 0, 0)
Case 1
Local $aTemp[1][UBound($aArray)]
For $i = 0 To UBound($aArray) - 1
$aTemp[0][$i] = $aArray[$i]
Next
$aArray = $aTemp
Case 2
Local $iDim_1 = UBound($aArray, 1), $iDim_2 = UBound($aArray, 2)
If $iDim_1 <> $iDim_2 Then
Local $aTemp[$iDim_2][$iDim_1]
For $i = 0 To $iDim_1 - 1
For $j = 0 To $iDim_2 - 1
$aTemp[$j][$i] = $aArray[$i][$j]
Next
Next
$aArray = $aTemp
Else
Local $vElement
For $i = 0 To $iDim_1 - 1
For $j = $i + 1 To $iDim_2 - 1
$vElement = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$j][$i]
$aArray[$j][$i] = $vElement
Next
Next
EndIf
Case Else
Return SetError(1, 0, 0)
EndSwitch
Return 1
EndFunc
Func _ArrayTrim(ByRef $aArray, $iTrimNum, $iDirection = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0)
If $iDirection = Default Then $iDirection = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iEnd = 0 Then $iEnd = $iDim_1
If $iStart > $iEnd Then Return SetError(3, 0, -1)
If $iStart < 0 Or $iEnd < 0 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iDirection Then
For $i = $iStart To $iEnd
$aArray[$i] = StringTrimRight($aArray[$i], $iTrimNum)
Next
Else
For $i = $iStart To $iEnd
$aArray[$i] = StringTrimLeft($aArray[$i], $iTrimNum)
Next
EndIf
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem < 0 Or $iSubItem > $iDim_2 Then Return SetError(5, 0, -1)
If $iDirection Then
For $i = $iStart To $iEnd
$aArray[$i][$iSubItem] = StringTrimRight($aArray[$i][$iSubItem], $iTrimNum)
Next
Else
For $i = $iStart To $iEnd
$aArray[$i][$iSubItem] = StringTrimLeft($aArray[$i][$iSubItem], $iTrimNum)
Next
EndIf
Case Else
Return SetError(2, 0, 0)
EndSwitch
Return 1
EndFunc
Func _ArrayUnique(Const ByRef $aArray, $iColumn = 0, $iBase = 0, $iCase = 0, $iCount = $ARRAYUNIQUE_COUNT, $iIntType = $ARRAYUNIQUE_AUTO)
If $iColumn = Default Then $iColumn = 0
If $iBase = Default Then $iBase = 0
If $iCase = Default Then $iCase = 0
If $iCount = Default Then $iCount = $ARRAYUNIQUE_COUNT
If UBound($aArray, $UBOUND_ROWS) = 0 Then Return SetError(1, 0, 0)
Local $iDims = UBound($aArray, $UBOUND_DIMENSIONS), $iNumColumns = UBound($aArray, $UBOUND_COLUMNS)
If $iDims > 2 Then Return SetError(2, 0, 0)
If $iBase < 0 Or $iBase > 1 Or (Not IsInt($iBase)) Then Return SetError(3, 0, 0)
If $iCase < 0 Or $iCase > 1 Or (Not IsInt($iCase)) Then Return SetError(3, 0, 0)
If $iCount < 0 Or $iCount > 1 Or (Not IsInt($iCount)) Then Return SetError(4, 0, 0)
If $iIntType < 0 Or $iIntType > 4 Or (Not IsInt($iIntType)) Then Return SetError(5, 0, 0)
If $iColumn < 0 Or ($iNumColumns = 0 And $iColumn > 0) Or ($iNumColumns > 0 And $iColumn >= $iNumColumns) Then Return SetError(6, 0, 0)
If $iIntType = $ARRAYUNIQUE_AUTO Then
Local $vFirstElem = ( ($iDims = 1) ? ($aArray[$iBase]) : ($aArray[$iColumn][$iBase]) )
If IsInt($vFirstElem) Then
Switch VarGetType($vFirstElem)
Case "Int32"
$iIntType = $ARRAYUNIQUE_FORCE32
Case "Int64"
$iIntType = $ARRAYUNIQUE_FORCE64
EndSwitch
Else
$iIntType = $ARRAYUNIQUE_FORCE32
EndIf
EndIf
ObjEvent("AutoIt.Error", "__ArrayUnique_AutoErrFunc")
Local $oDictionary = ObjCreate("Scripting.Dictionary")
$oDictionary.CompareMode = Number(Not $iCase)
Local $vElem, $sType, $vKey, $bCOMError = False
For $i = $iBase To UBound($aArray) - 1
If $iDims = 1 Then
$vElem = $aArray[$i]
Else
$vElem = $aArray[$i][$iColumn]
EndIf
Switch $iIntType
Case $ARRAYUNIQUE_FORCE32
$oDictionary.Item($vElem)
If @error Then
$bCOMError = True
ExitLoop
EndIf
Case $ARRAYUNIQUE_FORCE64
$sType = VarGetType($vElem)
If $sType = "Int32" Then
$bCOMError = True
ExitLoop
EndIf
$vKey = "#" & $sType & "#" & String($vElem)
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
Case $ARRAYUNIQUE_MATCH
$sType = VarGetType($vElem)
If StringLeft($sType, 3) = "Int" Then
$vKey = "#Int#" & String($vElem)
Else
$vKey = "#" & $sType & "#" & String($vElem)
EndIf
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
Case $ARRAYUNIQUE_DISTINCT
$vKey = "#" & VarGetType($vElem) & "#" & String($vElem)
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
EndSwitch
Next
Local $aValues, $j = 0
If $bCOMError Then
Return SetError(7, 0, 0)
ElseIf $iIntType <> $ARRAYUNIQUE_FORCE32 Then
Local $aValues[$oDictionary.Count]
For $vKey In $oDictionary.Keys()
$aValues[$j] = $oDictionary($vKey)
If StringLeft($vKey, 5) = "#Ptr#" Then
$aValues[$j] = Ptr($aValues[$j])
EndIf
$j += 1
Next
Else
$aValues = $oDictionary.Keys()
EndIf
If $iCount Then
_ArrayInsert($aValues, 0, $oDictionary.Count)
EndIf
Return $aValues
EndFunc
Func _Array1DToHistogram($aArray, $iSizing = 100)
If UBound($aArray, 0) > 1 Then Return SetError(1, 0, "")
$iSizing = $iSizing * 8
Local $t, $n, $iMin = 0, $iMax = 0, $iOffset = 0
For $i = 0 To UBound($aArray) - 1
$t = $aArray[$i]
$t = IsNumber($t) ? Round($t) : 0
If $t < $iMin Then $iMin = $t
If $t > $iMax Then $iMax = $t
Next
Local $iRange = Int(Round(($iMax - $iMin) / 8)) * 8
Local $iSpaceRatio = 4
For $i = 0 To UBound($aArray) - 1
$t = $aArray[$i]
If $t Then
$n = Abs(Round(($iSizing * $t) / $iRange) / 8)
$aArray[$i] = ""
If $t > 0 Then
If $iMin Then
$iOffset = Int(Abs(Round(($iSizing * $iMin) / $iRange) / 8) / 8 * $iSpaceRatio)
$aArray[$i] = __Array_StringRepeat(ChrW(0x20), $iOffset)
EndIf
Else
If $iMin <> $t Then
$iOffset = Int(Abs(Round(($iSizing * ($t - $iMin)) / $iRange) / 8) / 8 * $iSpaceRatio)
$aArray[$i] = __Array_StringRepeat(ChrW(0x20), $iOffset)
EndIf
EndIf
$aArray[$i] &= __Array_StringRepeat(ChrW(0x2588), Int($n / 8))
$n = Mod($n, 8)
If $n > 0 Then $aArray[$i] &= ChrW(0x2588 + 8 - $n)
$aArray[$i] &= ' ' & $t
Else
$aArray[$i] = ""
EndIf
Next
Return $aArray
EndFunc
Func __Array_StringRepeat($sString, $iRepeatCount)
$iRepeatCount = Int($iRepeatCount)
If StringLen($sString) < 1 Or $iRepeatCount <= 0 Then Return SetError(1, 0, "")
Local $sResult = ""
While $iRepeatCount > 1
If BitAND($iRepeatCount, 1) Then $sResult &= $sString
$sString &= $sString
$iRepeatCount = BitShift($iRepeatCount, 1)
WEnd
Return $sString & $sResult
EndFunc
Func __Array_ExeterInternal(ByRef $aArray, $iStart, $iSize, $sDelimiter, ByRef $aIdx, ByRef $aResult, ByRef $iCount)
If $iStart == $iSize - 1 Then
For $i = 0 To $iSize - 1
$aResult[$iCount] &= $aArray[$aIdx[$i]] & $sDelimiter
Next
If $sDelimiter <> "" Then $aResult[$iCount] = StringTrimRight($aResult[$iCount], StringLen($sDelimiter))
$iCount += 1
Else
Local $iTemp
For $i = $iStart To $iSize - 1
$iTemp = $aIdx[$i]
$aIdx[$i] = $aIdx[$iStart]
$aIdx[$iStart] = $iTemp
__Array_ExeterInternal($aArray, $iStart + 1, $iSize, $sDelimiter, $aIdx, $aResult, $iCount)
$aIdx[$iStart] = $aIdx[$i]
$aIdx[$i] = $iTemp
Next
EndIf
EndFunc
Func __Array_Combinations($iN, $iR)
Local $i_Total = 1
For $i = $iR To 1 Step -1
$i_Total *= ($iN / $i)
$iN -= 1
Next
Return Round($i_Total)
EndFunc
Func __Array_GetNext($iN, $iR, ByRef $iLeft, $iTotal, ByRef $aIdx)
If $iLeft == $iTotal Then
$iLeft -= 1
Return
EndIf
Local $i = $iR - 1
While $aIdx[$i] == $iN - $iR + $i
$i -= 1
WEnd
$aIdx[$i] += 1
For $j = $i + 1 To $iR - 1
$aIdx[$j] = $aIdx[$i] + $j - $i
Next
$iLeft -= 1
EndFunc
Func __Array_MinMaxIndex(Const ByRef $aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, $fuComparison)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iCompNumeric <> 1 Then $iCompNumeric = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iDim_1 < 0 Then Return SetError(1, 0, -1)
If $iEnd = -1 Then $iEnd = $iDim_1
If $iStart = -1 Then $iStart = 0
If $iStart < -1 Or $iEnd < -1 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
If $iDim_1 < 0 Then Return SetError(5, 0, -1)
Local $iMaxMinIndex = $iStart
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i]), Number($aArray[$iMaxMinIndex])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i], $aArray[$iMaxMinIndex]) Then $iMaxMinIndex = $i
Next
EndIf
Case 2
If $iSubItem < 0 Or $iSubItem > UBound($aArray, $UBOUND_COLUMNS) - 1 Then Return SetError(6, 0, -1)
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i][$iSubItem]), Number($aArray[$iMaxMinIndex][$iSubItem])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i][$iSubItem], $aArray[$iMaxMinIndex][$iSubItem]) Then $iMaxMinIndex = $i
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return $iMaxMinIndex
EndFunc
Func __Array_GreaterThan($vValue1, $vValue2)
Return $vValue1 > $vValue2
EndFunc
Func __Array_LessThan($vValue1, $vValue2)
Return $vValue1 < $vValue2
EndFunc
Func __ArrayUnique_AutoErrFunc()
EndFunc
Global Const $DTS_SHORTDATEFORMAT = 0
Global Const $DTS_UPDOWN = 1
Global Const $DTS_SHOWNONE = 2
Global Const $DTS_LONGDATEFORMAT = 4
Global Const $DTS_TIMEFORMAT = 9
Global Const $DTS_RIGHTALIGN = 32
Global Const $DTS_SHORTDATECENTURYFORMAT = 0x0000000C
Global Const $DTS_APPCANPARSE = 0x00000010
Global Const $DMW_LONGNAME = 0
Global Const $DMW_SHORTNAME = 1
Global Const $DMW_LOCALE_LONGNAME = 2
Global Const $DMW_LOCALE_SHORTNAME = 3
Global Const $GDT_ERROR = -1
Global Const $GDT_VALID = 0
Global Const $GDT_NONE = 1
Global Const $GDTR_MIN = 0x0001
Global Const $GDTR_MAX = 0x0002
Global Const $MCHT_NOWHERE = 0x00000000
Global Const $MCHT_TITLE = 0x00010000
Global Const $MCHT_CALENDAR = 0x00020000
Global Const $MCHT_TODAYLINK = 0x00030000
Global Const $MCHT_NEXT = 0x01000000
Global Const $MCHT_PREV = 0x02000000
Global Const $MCHT_TITLEBK = 0x00010000
Global Const $MCHT_TITLEMONTH = 0x00010001
Global Const $MCHT_TITLEYEAR = 0x00010002
Global Const $MCHT_TITLEBTNNEXT = 0x01010003
Global Const $MCHT_TITLEBTNPREV = 0x02010003
Global Const $MCHT_CALENDARBK = 0x00020000
Global Const $MCHT_CALENDARDATE = 0x00020001
Global Const $MCHT_CALENDARDAY = 0x00020002
Global Const $MCHT_CALENDARWEEKNUM = 0x00020003
Global Const $MCHT_CALENDARDATENEXT = 0x01020000
Global Const $MCHT_CALENDARDATEPREV = 0x02020000
Global Const $MCS_DAYSTATE = 0x0001
Global Const $MCS_MULTISELECT = 0x0002
Global Const $MCS_WEEKNUMBERS = 0x0004
Global Const $MCS_NOTODAYCIRCLE = 0x0008
Global Const $MCS_NOTODAY = 0x0010
Global Const $MCS_NOTRAILINGDATES = 0x0040
Global Const $MCS_SHORTDAYSOFWEEK = 0x0080
Global Const $MCS_NOSELCHANGEONNAV = 0x0100
Global Const $MCM_FIRST = 0x1000
Global Const $MCM_GETCALENDARBORDER = ($MCM_FIRST + 31)
Global Const $MCM_GETCALENDARCOUNT = ($MCM_FIRST + 23)
Global Const $MCM_GETCALENDARGRIDINFO = ($MCM_FIRST + 24)
Global Const $MCM_GETCALID = ($MCM_FIRST + 27)
Global Const $MCM_GETCOLOR = ($MCM_FIRST + 11)
Global Const $MCM_GETCURRENTVIEW = ($MCM_FIRST + 22)
Global Const $MCM_GETCURSEL = ($MCM_FIRST + 1)
Global Const $MCM_GETFIRSTDAYOFWEEK = ($MCM_FIRST + 16)
Global Const $MCM_GETMAXSELCOUNT = ($MCM_FIRST + 3)
Global Const $MCM_GETMAXTODAYWIDTH = ($MCM_FIRST + 21)
Global Const $MCM_GETMINREQRECT = ($MCM_FIRST + 9)
Global Const $MCM_GETMONTHDELTA = ($MCM_FIRST + 19)
Global Const $MCM_GETMONTHRANGE = ($MCM_FIRST + 7)
Global Const $MCM_GETRANGE = ($MCM_FIRST + 17)
Global Const $MCM_GETSELRANGE = ($MCM_FIRST + 5)
Global Const $MCM_GETTODAY = ($MCM_FIRST + 13)
Global Const $MCM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $MCM_HITTEST = ($MCM_FIRST + 14)
Global Const $MCM_SETCALENDARBORDER = ($MCM_FIRST + 30)
Global Const $MCM_SETCALID = ($MCM_FIRST + 28)
Global Const $MCM_SETCOLOR = ($MCM_FIRST + 10)
Global Const $MCM_SETCURRENTVIEW = ($MCM_FIRST + 32)
Global Const $MCM_SETCURSEL = ($MCM_FIRST + 2)
Global Const $MCM_SETDAYSTATE = ($MCM_FIRST + 8)
Global Const $MCM_SETFIRSTDAYOFWEEK = ($MCM_FIRST + 15)
Global Const $MCM_SETMAXSELCOUNT = ($MCM_FIRST + 4)
Global Const $MCM_SETMONTHDELTA = ($MCM_FIRST + 20)
Global Const $MCM_SETRANGE = ($MCM_FIRST + 18)
Global Const $MCM_SETSELRANGE = ($MCM_FIRST + 6)
Global Const $MCM_SETTODAY = ($MCM_FIRST + 12)
Global Const $MCM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $MCM_SIZERECTTOMIN = ($MCM_FIRST + 29)
Global Const $MCN_FIRST = -746
Global Const $MCN_SELCHANGE = ($MCN_FIRST - 3)
Global Const $MCN_GETDAYSTATE = ($MCN_FIRST - 1)
Global Const $MCN_SELECT = ($MCN_FIRST)
Global Const $MCN_VIEWCHANGE = ($MCN_FIRST - 4)
Global Const $MCSC_BACKGROUND = 0
Global Const $MCSC_MONTHBK = 4
Global Const $MCSC_TEXT = 1
Global Const $MCSC_TITLEBK = 2
Global Const $MCSC_TITLETEXT = 3
Global Const $MCSC_TRAILINGTEXT = 5
Global Const $DTM_FIRST = 0x1000
Global Const $DTM_GETSYSTEMTIME = $DTM_FIRST + 1
Global Const $DTM_SETSYSTEMTIME = $DTM_FIRST + 2
Global Const $DTM_GETRANGE = $DTM_FIRST + 3
Global Const $DTM_SETRANGE = $DTM_FIRST + 4
Global Const $DTM_SETFORMAT = $DTM_FIRST + 5
Global Const $DTM_SETMCCOLOR = $DTM_FIRST + 6
Global Const $DTM_GETMCCOLOR = $DTM_FIRST + 7
Global Const $DTM_GETMONTHCAL = $DTM_FIRST + 8
Global Const $DTM_SETMCFONT = $DTM_FIRST + 9
Global Const $DTM_GETMCFONT = $DTM_FIRST + 10
Global Const $DTM_SETFORMATW = $DTM_FIRST + 50
Global Const $DTN_FIRST = -740
Global Const $DTN_FIRST2 = -753
Global Const $DTN_DATETIMECHANGE = $DTN_FIRST2 - 6
Global Const $DTN_USERSTRING = $DTN_FIRST2 - 5
Global Const $DTN_WMKEYDOWN = $DTN_FIRST2 - 4
Global Const $DTN_FORMAT = $DTN_FIRST2 - 3
Global Const $DTN_FORMATQUERY = $DTN_FIRST2 - 2
Global Const $DTN_DROPDOWN = $DTN_FIRST2 - 1
Global Const $DTN_CLOSEUP = $DTN_FIRST2 - 0
Global Const $DTN_USERSTRINGW = $DTN_FIRST - 5
Global Const $DTN_WMKEYDOWNW = $DTN_FIRST - 4
Global Const $DTN_FORMATW = $DTN_FIRST - 3
Global Const $DTN_FORMATQUERYW = $DTN_FIRST - 2
Global Const $GUI_SS_DEFAULT_DATE = $DTS_LONGDATEFORMAT
Global Const $GUI_SS_DEFAULT_MONTHCAL = 0
#Region Global Variables and Constants
Global Const $tagNUMBERFMT = 'uint NumDigits;uint LeadingZero;uint Grouping;ptr DecimalSep;ptr ThousandSep;uint NegativeOrder'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CompareString($iLCID, $sString1, $sString2, $iFlags = 0)
Local $aRet = DllCall('kernel32.dll', 'int', 'CompareStringW', 'dword', $iLCID, 'dword', $iFlags, 'wstr', $sString1,  'int', -1, 'wstr', $sString2, 'int', -1)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateNumberFormatInfo($iNumDigits, $iLeadingZero, $iGrouping, $sDecimalSep, $sThousandSep, $iNegativeOrder)
Local $tFMT = DllStructCreate($tagNUMBERFMT & ';wchar[' & (StringLen($sDecimalSep) + 1) & '];wchar[' & (StringLen($sThousandSep) + 1) & ']')
DllStructSetData($tFMT, 1, $iNumDigits)
DllStructSetData($tFMT, 2, $iLeadingZero)
DllStructSetData($tFMT, 3, $iGrouping)
DllStructSetData($tFMT, 4, DllStructGetPtr($tFMT, 7))
DllStructSetData($tFMT, 5, DllStructGetPtr($tFMT, 8))
DllStructSetData($tFMT, 6, $iNegativeOrder)
DllStructSetData($tFMT, 7, $sDecimalSep)
DllStructSetData($tFMT, 8, $sThousandSep)
Return $tFMT
EndFunc
Func _WinAPI_EnumSystemGeoID()
Local $hEnumProc = DllCallbackRegister('__EnumGeoIDProc', 'bool', 'long')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumSystemGeoID', 'dword', 16, 'long', 0, 'ptr', DllCallbackGetPtr($hEnumProc))
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumSystemLocales($iFlag)
Local $hEnumProc = DllCallbackRegister('__EnumLocalesProc', 'bool', 'ptr')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumSystemLocalesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'dword', $iFlag)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumUILanguages($iFlag = 0)
Local $hEnumProc = DllCallbackRegister('__EnumUILanguagesProc', 'bool', 'ptr;long_ptr')
Local $iID = 1
If $__WINVER >= 0x0600 Then
If BitAND($iFlag, 0x0008) Then
$iID = 0
EndIf
Else
$iFlag = 0
EndIf
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumUILanguagesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'dword', $iFlag,  'long_ptr', $iID)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_GetDateFormat($iLCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')
If Not $iLCID Then $iLCID = 0x0400
Local $sTypeOfFormat = 'wstr'
If Not StringStripWS($sFormat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFormat = 'ptr'
$sFormat = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'int', 'GetDateFormatW', 'dword', $iLCID, 'dword', $iFlags, 'struct*', $tSYSTEMTIME,  $sTypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_GetDurationFormat($iLCID, $iDuration, $sFormat = '')
If Not $iLCID Then $iLCID = 0x0400
Local $pST, $iVal
If IsDllStruct($iDuration) Then
$pST = DllStructGetPtr($iDuration)
$iVal = 0
Else
$pST = 0
$iVal = $iDuration
EndIf
Local $sTypeOfFormat = 'wstr'
If Not StringStripWS($sFormat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFormat = 'ptr'
$sFormat = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'int', 'GetDurationFormat', 'dword', $iLCID, 'dword', 0, 'ptr', $pST, 'uint64', $iVal,  $sTypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[6]
EndFunc
Func _WinAPI_GetGeoInfo($iGEOID, $iType, $iLanguage = 0)
Local $aRet = DllCall('kernel32.dll', 'int', 'GetGeoInfoW', 'long', $iGEOID, 'dword', $iType, 'wstr', '', 'int', 4096,  'word', $iLanguage)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_GetLocaleInfo($iLCID, $iType)
Local $aRet = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'dword', $iLCID, 'dword', $iType, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetNumberFormat($iLCID, $sNumber, $tNUMBERFMT = 0)
If Not $iLCID Then $iLCID = 0x0400
Local $aRet = DllCall('kernel32.dll', 'int', 'GetNumberFormatW', 'dword', $iLCID, 'dword', 0, 'wstr', $sNumber,  'struct*', $tNUMBERFMT, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_GetSystemDefaultLangID()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetSystemDefaultLangID')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetSystemDefaultLCID()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetSystemDefaultLCID')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetSystemDefaultUILanguage()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetSystemDefaultUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetThreadLocale()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetThreadLocale')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetThreadUILanguage()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetThreadUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTimeFormat($iLCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')
If Not $iLCID Then $iLCID = 0x0400
Local $sTypeOfFormat = 'wstr'
If Not StringStripWS($sFormat, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFormat = 'ptr'
$sFormat = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'int', 'GetTimeFormatW', 'dword', $iLCID, 'dword', $iFlags, 'struct*', $tSYSTEMTIME,  $sTypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[5]
EndFunc
Func _WinAPI_GetUserDefaultLangID()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetUserDefaultLangID')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetUserDefaultLCID()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetUserDefaultLCID')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetUserDefaultUILanguage()
Local $aRet = DllCall('kernel32.dll', 'word', 'GetUserDefaultUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetUserGeoID()
Local $aRet = DllCall('kernel32.dll', 'long', 'GetUserGeoID', 'uint', 16)
If @error Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_IsValidLocale($iLCID, $iFlag = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsValidLocale', 'dword', $iLCID, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetLocaleInfo($iLCID, $iType, $sData)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetLocaleInfoW', 'dword', $iLCID, 'dword', $iType, 'wstr', $sData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetThreadLocale($iLCID)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetThreadLocale', 'dword', $iLCID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetThreadUILanguage($iLanguage)
Local $aRet = DllCall('kernel32.dll', 'word', 'SetThreadUILanguage', 'word', $iLanguage)
If @error Then Return SetError(@error, @extended, False)
Return ($aRet[0] = $aRet[1])
EndFunc
Func _WinAPI_SetUserGeoID($iGEOID)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetUserGeoID', 'long', $iGEOID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __EnumGeoIDProc($iID)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = $iID
Return 1
EndFunc
Func __EnumLocalesProc($pLocale)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = Dec(DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pLocale) + 1) & ']', $pLocale), 1))
Return 1
EndFunc
Func __EnumUILanguagesProc($pLanguage, $iID)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pLanguage) + 1) & ']', $pLanguage), 1)
If $iID Then
$__g_vEnum[$__g_vEnum[0]] = Dec($__g_vEnum[$__g_vEnum[0]])
EndIf
Return 1
EndFunc
#EndRegion Internal Functions
Func _DateAdd($sType, $iNumber, $sDate)
Local $asTimePart[4]
Local $asDatePart[4]
Local $iJulianDate
$sType = StringLeft($sType, 1)
If StringInStr("D,M,Y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not StringIsInt($iNumber) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sDate) Then
Return SetError(3, 0, 0)
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If $sType = "d" Or $sType = "w" Then
If $sType = "w" Then $iNumber = $iNumber * 7
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iNumber
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
EndIf
If $sType = "m" Then
$asDatePart[2] = $asDatePart[2] + $iNumber
While $asDatePart[2] > 12
$asDatePart[2] = $asDatePart[2] - 12
$asDatePart[1] = $asDatePart[1] + 1
WEnd
While $asDatePart[2] < 1
$asDatePart[2] = $asDatePart[2] + 12
$asDatePart[1] = $asDatePart[1] - 1
WEnd
EndIf
If $sType = "y" Then
$asDatePart[1] = $asDatePart[1] + $iNumber
EndIf
If $sType = "h" Or $sType = "n" Or $sType = "s" Then
Local $iTimeVal = _TimeToTicks($asTimePart[1], $asTimePart[2], $asTimePart[3]) / 1000
If $sType = "h" Then $iTimeVal = $iTimeVal + $iNumber * 3600
If $sType = "n" Then $iTimeVal = $iTimeVal + $iNumber * 60
If $sType = "s" Then $iTimeVal = $iTimeVal + $iNumber
Local $iDay2Add = Int($iTimeVal / (24 * 60 * 60))
$iTimeVal = $iTimeVal - $iDay2Add * 24 * 60 * 60
If $iTimeVal < 0 Then
$iDay2Add = $iDay2Add - 1
$iTimeVal = $iTimeVal + 24 * 60 * 60
EndIf
$iJulianDate = _DateToDayValue($asDatePart[1], $asDatePart[2], $asDatePart[3]) + $iDay2Add
_DayValueToDate($iJulianDate, $asDatePart[1], $asDatePart[2], $asDatePart[3])
_TicksToTime($iTimeVal * 1000, $asTimePart[1], $asTimePart[2], $asTimePart[3])
EndIf
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $iNumDays[$asDatePart[2]] < $asDatePart[3] Then $asDatePart[3] = $iNumDays[$asDatePart[2]]
$sDate = $asDatePart[1] & '/' & StringRight("0" & $asDatePart[2], 2) & '/' & StringRight("0" & $asDatePart[3], 2)
If $asTimePart[0] > 0 Then
If $asTimePart[0] > 2 Then
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2) & ':' & StringRight("0" & $asTimePart[3], 2)
Else
$sDate = $sDate & " " & StringRight("0" & $asTimePart[1], 2) & ':' & StringRight("0" & $asTimePart[2], 2)
EndIf
EndIf
Return $sDate
EndFunc
Func _DateDayOfWeek($iDayNum, $iFormat = Default)
Local Const $MONDAY_IS_NO1 = 128
If $iFormat = Default Then $iFormat = 0
$iDayNum = Int($iDayNum)
If $iDayNum < 1 Or $iDayNum > 7 Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", BitAND($iFormat, $MONDAY_IS_NO1) ? 2007 : 2006)
DllStructSetData($tSYSTEMTIME, "Month", 1)
DllStructSetData($tSYSTEMTIME, "Day", $iDayNum)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "ddd" : "dddd")
EndFunc
Func _DateDaysInMonth($iYear, $iMonthNum)
$iMonthNum = Int($iMonthNum)
$iYear = Int($iYear)
Return __DateIsMonth($iMonthNum) And __DateIsYear($iYear) ? _DaysInMonth($iYear)[$iMonthNum] : SetError(1, 0, 0)
EndFunc
Func _DateDiff($sType, $sStartDate, $sEndDate)
$sType = StringLeft($sType, 1)
If StringInStr("d,m,y,w,h,n,s", $sType) = 0 Or $sType = "" Then
Return SetError(1, 0, 0)
EndIf
If Not _DateIsValid($sStartDate) Then
Return SetError(2, 0, 0)
EndIf
If Not _DateIsValid($sEndDate) Then
Return SetError(3, 0, 0)
EndIf
Local $asStartDatePart[4], $asStartTimePart[4], $asEndDatePart[4], $asEndTimePart[4]
_DateTimeSplit($sStartDate, $asStartDatePart, $asStartTimePart)
_DateTimeSplit($sEndDate, $asEndDatePart, $asEndTimePart)
Local $aDaysDiff = _DateToDayValue($asEndDatePart[1], $asEndDatePart[2], $asEndDatePart[3]) - _DateToDayValue($asStartDatePart[1], $asStartDatePart[2], $asStartDatePart[3])
Local $iTimeDiff, $iYearDiff, $iStartTimeInSecs, $iEndTimeInSecs
If $asStartTimePart[0] > 1 And $asEndTimePart[0] > 1 Then
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $iTimeDiff < 0 Then
$aDaysDiff = $aDaysDiff - 1
$iTimeDiff = $iTimeDiff + 24 * 60 * 60
EndIf
Else
$iTimeDiff = 0
EndIf
Select
Case $sType = "d"
Return $aDaysDiff
Case $sType = "m"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
Local $iMonthDiff = $asEndDatePart[2] - $asStartDatePart[2] + $iYearDiff * 12
If $asEndDatePart[3] < $asStartDatePart[3] Then $iMonthDiff = $iMonthDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iMonthDiff = $iMonthDiff - 1
Return $iMonthDiff
Case $sType = "y"
$iYearDiff = $asEndDatePart[1] - $asStartDatePart[1]
If $asEndDatePart[2] < $asStartDatePart[2] Then $iYearDiff = $iYearDiff - 1
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] < $asStartDatePart[3] Then $iYearDiff = $iYearDiff - 1
$iStartTimeInSecs = $asStartTimePart[1] * 3600 + $asStartTimePart[2] * 60 + $asStartTimePart[3]
$iEndTimeInSecs = $asEndTimePart[1] * 3600 + $asEndTimePart[2] * 60 + $asEndTimePart[3]
$iTimeDiff = $iEndTimeInSecs - $iStartTimeInSecs
If $asEndDatePart[2] = $asStartDatePart[2] And $asEndDatePart[3] = $asStartDatePart[3] And $iTimeDiff < 0 Then $iYearDiff = $iYearDiff - 1
Return $iYearDiff
Case $sType = "w"
Return Int($aDaysDiff / 7)
Case $sType = "h"
Return $aDaysDiff * 24 + Int($iTimeDiff / 3600)
Case $sType = "n"
Return $aDaysDiff * 24 * 60 + Int($iTimeDiff / 60)
Case $sType = "s"
Return $aDaysDiff * 24 * 60 * 60 + $iTimeDiff
EndSelect
EndFunc
Func _DateIsLeapYear($iYear)
If StringIsInt($iYear) Then
Select
Case Mod($iYear, 4) = 0 And Mod($iYear, 100) <> 0
Return 1
Case Mod($iYear, 400) = 0
Return 1
Case Else
Return 0
EndSelect
EndIf
Return SetError(1, 0, 0)
EndFunc
Func __DateIsMonth($iNumber)
$iNumber = Int($iNumber)
Return $iNumber >= 1 And $iNumber <= 12
EndFunc
Func _DateIsValid($sDate)
Local $asDatePart[4], $asTimePart[4]
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
If Not StringIsInt($asDatePart[1]) Then Return 0
If Not StringIsInt($asDatePart[2]) Then Return 0
If Not StringIsInt($asDatePart[3]) Then Return 0
$asDatePart[1] = Int($asDatePart[1])
$asDatePart[2] = Int($asDatePart[2])
$asDatePart[3] = Int($asDatePart[3])
Local $iNumDays = _DaysInMonth($asDatePart[1])
If $asDatePart[1] < 1000 Or $asDatePart[1] > 2999 Then Return 0
If $asDatePart[2] < 1 Or $asDatePart[2] > 12 Then Return 0
If $asDatePart[3] < 1 Or $asDatePart[3] > $iNumDays[$asDatePart[2]] Then Return 0
If $asTimePart[0] < 1 Then Return 1
If $asTimePart[0] < 2 Then Return 0
If $asTimePart[0] = 2 Then $asTimePart[3] = "00"
If Not StringIsInt($asTimePart[1]) Then Return 0
If Not StringIsInt($asTimePart[2]) Then Return 0
If Not StringIsInt($asTimePart[3]) Then Return 0
$asTimePart[1] = Int($asTimePart[1])
$asTimePart[2] = Int($asTimePart[2])
$asTimePart[3] = Int($asTimePart[3])
If $asTimePart[1] < 0 Or $asTimePart[1] > 23 Then Return 0
If $asTimePart[2] < 0 Or $asTimePart[2] > 59 Then Return 0
If $asTimePart[3] < 0 Or $asTimePart[3] > 59 Then Return 0
Return 1
EndFunc
Func __DateIsYear($iNumber)
Return StringLen($iNumber) = 4
EndFunc
Func _DateLastWeekdayNum($iWeekdayNum)
Select
Case Not StringIsInt($iWeekdayNum)
Return SetError(1, 0, 0)
Case $iWeekdayNum < 1 Or $iWeekdayNum > 7
Return SetError(2, 0, 0)
Case Else
Local $iLastWeekdayNum
If $iWeekdayNum = 1 Then
$iLastWeekdayNum = 7
Else
$iLastWeekdayNum = $iWeekdayNum - 1
EndIf
Return $iLastWeekdayNum
EndSelect
EndFunc
Func _DateLastMonthNum($iMonthNum)
Select
Case Not StringIsInt($iMonthNum)
Return SetError(1, 0, 0)
Case Not __DateIsMonth($iMonthNum)
Return SetError(2, 0, 0)
Case Else
Local $iLastMonthNum
If $iMonthNum = 1 Then
$iLastMonthNum = 12
Else
$iLastMonthNum = $iMonthNum - 1
EndIf
$iLastMonthNum = StringFormat("%02d", $iLastMonthNum)
Return $iLastMonthNum
EndSelect
EndFunc
Func _DateLastMonthYear($iMonthNum, $iYear)
Select
Case Not StringIsInt($iMonthNum) Or Not StringIsInt($iYear)
Return SetError(1, 0, 0)
Case Not __DateIsMonth($iMonthNum)
Return SetError(2, 0, 0)
Case Else
Local $iLastYear
If $iMonthNum = 1 Then
$iLastYear = $iYear - 1
Else
$iLastYear = $iYear
EndIf
$iLastYear = StringFormat("%04d", $iLastYear)
Return $iLastYear
EndSelect
EndFunc
Func _DateNextWeekdayNum($iWeekdayNum)
Select
Case Not StringIsInt($iWeekdayNum)
Return SetError(1, 0, 0)
Case $iWeekdayNum < 1 Or $iWeekdayNum > 7
Return SetError(2, 0, 0)
Case Else
Local $iNextWeekdayNum
If $iWeekdayNum = 7 Then
$iNextWeekdayNum = 1
Else
$iNextWeekdayNum = $iWeekdayNum + 1
EndIf
Return $iNextWeekdayNum
EndSelect
EndFunc
Func _DateNextMonthNum($iMonthNum)
Select
Case Not StringIsInt($iMonthNum)
Return SetError(1, 0, 0)
Case Not __DateIsMonth($iMonthNum)
Return SetError(2, 0, 0)
Case Else
Local $iNextMonthNum
If $iMonthNum = 12 Then
$iNextMonthNum = 1
Else
$iNextMonthNum = $iMonthNum + 1
EndIf
$iNextMonthNum = StringFormat("%02d", $iNextMonthNum)
Return $iNextMonthNum
EndSelect
EndFunc
Func _DateNextMonthYear($iMonthNum, $iYear)
Select
Case Not StringIsInt($iMonthNum) Or Not StringIsInt($iYear)
Return SetError(1, 0, 0)
Case Not __DateIsMonth($iMonthNum)
Return SetError(2, 0, 0)
Case Else
Local $iNextYear
If $iMonthNum = 12 Then
$iNextYear = $iYear + 1
Else
$iNextYear = $iYear
EndIf
$iNextYear = StringFormat("%04d", $iNextYear)
Return $iNextYear
EndSelect
EndFunc
Func _DateTimeFormat($sDate, $sType)
Local $asDatePart[4], $asTimePart[4]
Local $sTempDate = "", $sTempTime = ""
Local $sAM, $sPM, $sTempString = ""
If Not _DateIsValid($sDate) Then
Return SetError(1, 0, "")
EndIf
If $sType < 0 Or $sType > 5 Or Not IsInt($sType) Then
Return SetError(2, 0, "")
EndIf
_DateTimeSplit($sDate, $asDatePart, $asTimePart)
Switch $sType
Case 0
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not ($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not ($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 1
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SLONGDATE)
If Not @error And Not ($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "dddd, MMMM dd, yyyy"
EndIf
Case 2
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
If Not @error And Not ($sTempString = '') Then
$sTempDate = $sTempString
Else
$sTempDate = "M/d/yyyy"
EndIf
Case 3
If $asTimePart[0] > 1 Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
If Not @error And Not ($sTempString = '') Then
$sTempTime = $sTempString
Else
$sTempTime = "h:mm:ss tt"
EndIf
EndIf
Case 4
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm"
EndIf
Case 5
If $asTimePart[0] > 1 Then
$sTempTime = "hh:mm:ss"
EndIf
EndSwitch
If $sTempDate <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_SDATE)
If Not @error And Not ($sTempString = '') Then
$sTempDate = StringReplace($sTempDate, "/", $sTempString)
EndIf
Local $iWday = _DateToDayOfWeek($asDatePart[1], $asDatePart[2], $asDatePart[3])
$asDatePart[3] = StringRight("0" & $asDatePart[3], 2)
$asDatePart[2] = StringRight("0" & $asDatePart[2], 2)
$sTempDate = StringReplace($sTempDate, "d", "@")
$sTempDate = StringReplace($sTempDate, "m", "#")
$sTempDate = StringReplace($sTempDate, "y", "&")
$sTempDate = StringReplace($sTempDate, "@@@@", _DateDayOfWeek($iWday, 0))
$sTempDate = StringReplace($sTempDate, "@@@", _DateDayOfWeek($iWday, 1))
$sTempDate = StringReplace($sTempDate, "@@", $asDatePart[3])
$sTempDate = StringReplace($sTempDate, "@", StringReplace(StringLeft($asDatePart[3], 1), "0", "") & StringRight($asDatePart[3], 1))
$sTempDate = StringReplace($sTempDate, "####", _DateToMonth($asDatePart[2], 0))
$sTempDate = StringReplace($sTempDate, "###", _DateToMonth($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "##", $asDatePart[2])
$sTempDate = StringReplace($sTempDate, "#", StringReplace(StringLeft($asDatePart[2], 1), "0", "") & StringRight($asDatePart[2], 1))
$sTempDate = StringReplace($sTempDate, "&&&&", $asDatePart[1])
$sTempDate = StringReplace($sTempDate, "&&", StringRight($asDatePart[1], 2))
EndIf
If $sTempTime <> "" Then
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S1159)
If Not @error And Not ($sTempString = '') Then
$sAM = $sTempString
Else
$sAM = "AM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_S2359)
If Not @error And Not ($sTempString = '') Then
$sPM = $sTempString
Else
$sPM = "PM"
EndIf
$sTempString = _WinAPI_GetLocaleInfo($LOCALE_USER_DEFAULT, $LOCALE_STIME)
If Not @error And Not ($sTempString = '') Then
$sTempTime = StringReplace($sTempTime, ":", $sTempString)
EndIf
If StringInStr($sTempTime, "tt") Then
If $asTimePart[1] < 12 Then
$sTempTime = StringReplace($sTempTime, "tt", $sAM)
If $asTimePart[1] = 0 Then $asTimePart[1] = 12
Else
$sTempTime = StringReplace($sTempTime, "tt", $sPM)
If $asTimePart[1] > 12 Then $asTimePart[1] = $asTimePart[1] - 12
EndIf
EndIf
$asTimePart[1] = StringRight("0" & $asTimePart[1], 2)
$asTimePart[2] = StringRight("0" & $asTimePart[2], 2)
$asTimePart[3] = StringRight("0" & $asTimePart[3], 2)
$sTempTime = StringReplace($sTempTime, "hh", StringFormat("%02d", $asTimePart[1]))
$sTempTime = StringReplace($sTempTime, "h", StringReplace(StringLeft($asTimePart[1], 1), "0", "") & StringRight($asTimePart[1], 1))
$sTempTime = StringReplace($sTempTime, "mm", StringFormat("%02d", $asTimePart[2]))
$sTempTime = StringReplace($sTempTime, "ss", StringFormat("%02d", $asTimePart[3]))
$sTempDate = StringStripWS($sTempDate & " " & $sTempTime, $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndIf
Return $sTempDate
EndFunc
Func _DateTimeSplit($sDate, ByRef $aDatePart, ByRef $iTimePart)
Local $sDateTime = StringSplit($sDate, " T")
If $sDateTime[0] > 0 Then $aDatePart = StringSplit($sDateTime[1], "/-.")
If $sDateTime[0] > 1 Then
$iTimePart = StringSplit($sDateTime[2], ":")
If UBound($iTimePart) < 4 Then ReDim $iTimePart[4]
Else
Dim $iTimePart[4]
EndIf
If UBound($aDatePart) < 4 Then ReDim $aDatePart[4]
For $x = 1 To 3
If StringIsInt($aDatePart[$x]) Then
$aDatePart[$x] = Int($aDatePart[$x])
Else
$aDatePart[$x] = -1
EndIf
If StringIsInt($iTimePart[$x]) Then
$iTimePart[$x] = Int($iTimePart[$x])
Else
$iTimePart[$x] = 0
EndIf
Next
Return 1
EndFunc
Func _DateToDayOfWeek($iYear, $iMonth, $iDay)
If Not _DateIsValid($iYear & "/" & $iMonth & "/" & $iDay) Then
Return SetError(1, 0, "")
EndIf
Local $i_FactorA = Int((14 - $iMonth) / 12)
Local $i_FactorY = $iYear - $i_FactorA
Local $i_FactorM = $iMonth + (12 * $i_FactorA) - 2
Local $i_FactorD = Mod($iDay + $i_FactorY + Int($i_FactorY / 4) - Int($i_FactorY / 100) + Int($i_FactorY / 400) + Int((31 * $i_FactorM) / 12), 7)
Return $i_FactorD + 1
EndFunc
Func _DateToDayOfWeekISO($iYear, $iMonth, $iDay)
Local $iDow = _DateToDayOfWeek($iYear, $iMonth, $iDay)
If @error Then
Return SetError(1, 0, "")
EndIf
If $iDow >= 2 Then Return $iDow - 1
Return 7
EndFunc
Func _DateToDayValue($iYear, $iMonth, $iDay)
If Not _DateIsValid(StringFormat("%04d/%02d/%02d", $iYear, $iMonth, $iDay)) Then
Return SetError(1, 0, "")
EndIf
If $iMonth < 3 Then
$iMonth = $iMonth + 12
$iYear = $iYear - 1
EndIf
Local $i_FactorA = Int($iYear / 100)
Local $i_FactorB = Int($i_FactorA / 4)
Local $i_FactorC = 2 - $i_FactorA + $i_FactorB
Local $i_FactorE = Int(1461 * ($iYear + 4716) / 4)
Local $i_FactorF = Int(153 * ($iMonth + 1) / 5)
Local $iJulianDate = $i_FactorC + $iDay + $i_FactorE + $i_FactorF - 1524.5
Return $iJulianDate
EndFunc
Func _DateToMonth($iMonNum, $iFormat = Default)
If $iFormat = Default Then $iFormat = 0
$iMonNum = Int($iMonNum)
If Not __DateIsMonth($iMonNum) Then Return SetError(1, 0, "")
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Year", @YEAR)
DllStructSetData($tSYSTEMTIME, "Month", $iMonNum)
DllStructSetData($tSYSTEMTIME, "Day", 1)
Return _WinAPI_GetDateFormat(BitAND($iFormat, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $tSYSTEMTIME, 0, BitAND($iFormat, $DMW_SHORTNAME) ? "MMM" : "MMMM")
EndFunc
Func _DayValueToDate($iJulianDate, ByRef $iYear, ByRef $iMonth, ByRef $iDay)
If $iJulianDate < 0 Or Not IsNumber($iJulianDate) Then
Return SetError(1, 0, 0)
EndIf
Local $i_FactorZ = Int($iJulianDate + 0.5)
Local $i_FactorW = Int(($i_FactorZ - 1867216.25) / 36524.25)
Local $i_FactorX = Int($i_FactorW / 4)
Local $i_FactorA = $i_FactorZ + 1 + $i_FactorW - $i_FactorX
Local $i_FactorB = $i_FactorA + 1524
Local $i_FactorC = Int(($i_FactorB - 122.1) / 365.25)
Local $i_FactorD = Int(365.25 * $i_FactorC)
Local $i_FactorE = Int(($i_FactorB - $i_FactorD) / 30.6001)
Local $i_FactorF = Int(30.6001 * $i_FactorE)
$iDay = $i_FactorB - $i_FactorD - $i_FactorF
If $i_FactorE - 1 < 13 Then
$iMonth = $i_FactorE - 1
Else
$iMonth = $i_FactorE - 13
EndIf
If $iMonth < 3 Then
$iYear = $i_FactorC - 4715
Else
$iYear = $i_FactorC - 4716
EndIf
$iYear = StringFormat("%04d", $iYear)
$iMonth = StringFormat("%02d", $iMonth)
$iDay = StringFormat("%02d", $iDay)
Return $iYear & "/" & $iMonth & "/" & $iDay
EndFunc
Func _Date_JulianDayNo($iYear, $iMonth, $iDay)
Local $sFullDate = StringFormat("%04d/%02d/%02d", $iYear, $iMonth, $iDay)
If Not _DateIsValid($sFullDate) Then
Return SetError(1, 0, "")
EndIf
Local $iJDay = 0
Local $aiDaysInMonth = _DaysInMonth($iYear)
For $iCntr = 1 To $iMonth - 1
$iJDay = $iJDay + $aiDaysInMonth[$iCntr]
Next
$iJDay = ($iYear * 1000) + ($iJDay + $iDay)
Return $iJDay
EndFunc
Func _JulianToDate($iJDay, $sSep = "/")
Local $iYear = Int($iJDay / 1000)
Local $iDays = Mod($iJDay, 1000)
Local $iMaxDays = 365
If _DateIsLeapYear($iYear) Then $iMaxDays = 366
If $iDays > $iMaxDays Then
Return SetError(1, 0, "")
EndIf
Local $aiDaysInMonth = _DaysInMonth($iYear)
Local $iMonth = 1
While $iDays > $aiDaysInMonth[$iMonth]
$iDays = $iDays - $aiDaysInMonth[$iMonth]
$iMonth = $iMonth + 1
WEnd
Return StringFormat("%04d%s%02d%s%02d", $iYear, $sSep, $iMonth, $sSep, $iDays)
EndFunc
Func _Now()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, 0)
EndFunc
Func _NowCalc()
Return @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC
EndFunc
Func _NowCalcDate()
Return @YEAR & "/" & @MON & "/" & @MDAY
EndFunc
Func _NowDate()
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY, 0)
EndFunc
Func _NowTime($sType = 3)
If $sType < 3 Or $sType > 5 Then $sType = 3
Return _DateTimeFormat(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, $sType)
EndFunc
Func _SetDate($iDay, $iMonth = 0, $iYear = 0)
If $iYear = 0 Then $iYear = @YEAR
If $iMonth = 0 Then $iMonth = @MON
If Not _DateIsValid($iYear & "/" & $iMonth & "/" & $iDay) Then Return 1
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, 0)
DllStructSetData($tSYSTEMTIME, "Day", $iDay)
If $iMonth > 0 Then DllStructSetData($tSYSTEMTIME, "Month", $iMonth)
If $iYear > 0 Then DllStructSetData($tSYSTEMTIME, "Year", $iYear)
Local $iReturn = _Date_Time_SetLocalTime($tSYSTEMTIME)
If @error Then Return SetError(@error + 10, @extended, 0)
Return Int($iReturn)
EndFunc
Func _SetTime($iHour, $iMinute, $iSecond = 0, $iMSeconds = 0)
If $iHour < 0 Or $iHour > 23 Then Return 1
If $iMinute < 0 Or $iMinute > 59 Then Return 1
If $iSecond < 0 Or $iSecond > 59 Then Return 1
If $iMSeconds < 0 Or $iMSeconds > 999 Then Return 1
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, 0)
DllStructSetData($tSYSTEMTIME, "Hour", $iHour)
DllStructSetData($tSYSTEMTIME, "Minute", $iMinute)
If $iSecond > 0 Then DllStructSetData($tSYSTEMTIME, "Seconds", $iSecond)
If $iMSeconds > 0 Then DllStructSetData($tSYSTEMTIME, "MSeconds", $iMSeconds)
Local $iReturn = _Date_Time_SetLocalTime($tSYSTEMTIME)
If @error Then Return SetError(@error + 10, @extended, 0)
Return Int($iReturn)
EndFunc
Func _TicksToTime($iTicks, ByRef $iHours, ByRef $iMins, ByRef $iSecs)
If Number($iTicks) > 0 Then
$iTicks = Int($iTicks / 1000)
$iHours = Int($iTicks / 3600)
$iTicks = Mod($iTicks, 3600)
$iMins = Int($iTicks / 60)
$iSecs = Mod($iTicks, 60)
Return 1
ElseIf Number($iTicks) = 0 Then
$iHours = 0
$iTicks = 0
$iMins = 0
$iSecs = 0
Return 1
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _TimeToTicks($iHours = @HOUR, $iMins = @MIN, $iSecs = @SEC)
If StringIsInt($iHours) And StringIsInt($iMins) And StringIsInt($iSecs) Then
Local $iTicks = 1000 * ((3600 * $iHours) + (60 * $iMins) + $iSecs)
Return $iTicks
Else
Return SetError(1, 0, 0)
EndIf
EndFunc
Func _WeekNumberISO($iYear = @YEAR, $iMonth = @MON, $iDay = @MDAY)
If $iDay > 31 Or $iDay < 1 Then
Return SetError(1, 0, -1)
ElseIf Not __DateIsMonth($iMonth) Then
Return SetError(2, 0, -1)
ElseIf $iYear < 1 Or $iYear > 2999 Then
Return SetError(3, 0, -1)
EndIf
Local $iDow = _DateToDayOfWeekISO($iYear, $iMonth, $iDay) - 1
Local $iDow0101 = _DateToDayOfWeekISO($iYear, 1, 1) - 1
If ($iMonth = 1 And 3 < $iDow0101 And $iDow0101 < 7 - ($iDay - 1)) Then
$iDow = $iDow0101 - 1
$iDow0101 = _DateToDayOfWeekISO($iYear - 1, 1, 1) - 1
$iMonth = 12
$iDay = 31
$iYear = $iYear - 1
ElseIf ($iMonth = 12 And 30 - ($iDay - 1) < _DateToDayOfWeekISO($iYear + 1, 1, 1) - 1 And _DateToDayOfWeekISO($iYear + 1, 1, 1) - 1 < 4) Then
Return 1
EndIf
Return Int((_DateToDayOfWeekISO($iYear, 1, 1) - 1 < 4) + 4 * ($iMonth - 1) + (2 * ($iMonth - 1) + ($iDay - 1) + $iDow0101 - $iDow + 6) * 36 / 256)
EndFunc
Func _WeekNumber($iYear = @YEAR, $iMonth = @MON, $iDay = @MDAY, $iWeekStart = 1)
If $iDay > 31 Or $iDay < 1 Then
Return SetError(1, 0, -1)
ElseIf Not __DateIsMonth($iMonth) Then
Return SetError(3, 0, -1)
ElseIf $iYear < 1 Or $iYear > 2999 Then
Return SetError(4, 0, -1)
ElseIf $iWeekStart < 1 Or $iWeekStart > 2 Then
Return SetError(2, 0, -1)
EndIf
Local $iStartWeek1, $iEndWeek1
Local $iDow0101 = _DateToDayOfWeekISO($iYear, 1, 1)
Local $iDate = $iYear & '/' & $iMonth & '/' & $iDay
If $iWeekStart = 1 Then
If $iDow0101 = 6 Then
$iStartWeek1 = 0
Else
$iStartWeek1 = -1 * $iDow0101 - 1
EndIf
$iEndWeek1 = $iStartWeek1 + 6
Else
$iStartWeek1 = $iDow0101 * -1
$iEndWeek1 = $iStartWeek1 + 6
EndIf
Local $iStartWeek1ny
Local $iEndWeek1Date = _DateAdd('d', $iEndWeek1, $iYear & '/01/01')
Local $iDow0101ny = _DateToDayOfWeekISO($iYear + 1, 1, 1)
If $iWeekStart = 1 Then
If $iDow0101ny = 6 Then
$iStartWeek1ny = 0
Else
$iStartWeek1ny = -1 * $iDow0101ny - 1
EndIf
Else
$iStartWeek1ny = $iDow0101ny * -1
EndIf
Local $iStartWeek1Dateny = _DateAdd('d', $iStartWeek1ny, $iYear + 1 & '/01/01')
Local $iCurrDateDiff = _DateDiff('d', $iEndWeek1Date, $iDate) - 1
Local $iCurrDateDiffny = _DateDiff('d', $iStartWeek1Dateny, $iDate)
If $iCurrDateDiff >= 0 And $iCurrDateDiffny < 0 Then Return 2 + Int($iCurrDateDiff / 7)
If $iCurrDateDiff < 0 Or $iCurrDateDiffny >= 0 Then Return 1
EndFunc
Func _DaysInMonth($iYear)
Local $aDays = [12, 31, (_DateIsLeapYear($iYear) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
Return $aDays
EndFunc
Func __Date_Time_CloneSystemTime($pSystemTime)
Local $tSystemTime1 = DllStructCreate($tagSYSTEMTIME, $pSystemTime)
Local $tSystemTime2 = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSystemTime2, "Month", DllStructGetData($tSystemTime1, "Month"))
DllStructSetData($tSystemTime2, "Day", DllStructGetData($tSystemTime1, "Day"))
DllStructSetData($tSystemTime2, "Year", DllStructGetData($tSystemTime1, "Year"))
DllStructSetData($tSystemTime2, "Hour", DllStructGetData($tSystemTime1, "Hour"))
DllStructSetData($tSystemTime2, "Minute", DllStructGetData($tSystemTime1, "Minute"))
DllStructSetData($tSystemTime2, "Second", DllStructGetData($tSystemTime1, "Second"))
DllStructSetData($tSystemTime2, "MSeconds", DllStructGetData($tSystemTime1, "MSeconds"))
DllStructSetData($tSystemTime2, "DOW", DllStructGetData($tSystemTime1, "DOW"))
Return $tSystemTime2
EndFunc
Func _Date_Time_CompareFileTime($tFileTime1, $tFileTime2)
Local $aResult = DllCall("kernel32.dll", "long", "CompareFileTime", "struct*", $tFileTime1, "struct*", $tFileTime2)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _Date_Time_DOSDateTimeToFileTime($iFatDate, $iFatTime)
Local $tTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "DosDateTimeToFileTime", "word", $iFatDate, "word", $iFatTime, "struct*", $tTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tTime)
EndFunc
Func _Date_Time_DOSDateToArray($iDosDate)
Local $aDate[3]
$aDate[0] = BitAND($iDosDate, 0x1F)
$aDate[1] = BitAND(BitShift($iDosDate, 5), 0x0F)
$aDate[2] = BitAND(BitShift($iDosDate, 9), 0x3F) + 1980
Return $aDate
EndFunc
Func _Date_Time_DOSDateTimeToArray($iDosDate, $iDosTime)
Local $aDate[6]
$aDate[0] = BitAND($iDosDate, 0x1F)
$aDate[1] = BitAND(BitShift($iDosDate, 5), 0x0F)
$aDate[2] = BitAND(BitShift($iDosDate, 9), 0x3F) + 1980
$aDate[5] = BitAND($iDosTime, 0x1F) * 2
$aDate[4] = BitAND(BitShift($iDosTime, 5), 0x3F)
$aDate[3] = BitAND(BitShift($iDosTime, 11), 0x1F)
Return $aDate
EndFunc
Func _Date_Time_DOSDateTimeToStr($iDosDate, $iDosTime)
Local $aDate = _Date_Time_DOSDateTimeToArray($iDosDate, $iDosTime)
Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $aDate[0], $aDate[1], $aDate[2], $aDate[3], $aDate[4], $aDate[5])
EndFunc
Func _Date_Time_DOSDateToStr($iDosDate)
Local $aDate = _Date_Time_DOSDateToArray($iDosDate)
Return StringFormat("%02d/%02d/%04d", $aDate[0], $aDate[1], $aDate[2])
EndFunc
Func _Date_Time_DOSTimeToArray($iDosTime)
Local $aTime[3]
$aTime[2] = BitAND($iDosTime, 0x1F) * 2
$aTime[1] = BitAND(BitShift($iDosTime, 5), 0x3F)
$aTime[0] = BitAND(BitShift($iDosTime, 11), 0x1F)
Return $aTime
EndFunc
Func _Date_Time_DOSTimeToStr($iDosTime)
Local $aTime = _Date_Time_DOSTimeToArray($iDosTime)
Return StringFormat("%02d:%02d:%02d", $aTime[0], $aTime[1], $aTime[2])
EndFunc
Func _Date_Time_EncodeFileTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour, $iMinute, $iSecond, $iMSeconds)
Return _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
EndFunc
Func _Date_Time_EncodeSystemTime($iMonth, $iDay, $iYear, $iHour = 0, $iMinute = 0, $iSecond = 0, $iMSeconds = 0)
Local $tSYSTEMTIME = DllStructCreate($tagSYSTEMTIME)
DllStructSetData($tSYSTEMTIME, "Month", $iMonth)
DllStructSetData($tSYSTEMTIME, "Day", $iDay)
DllStructSetData($tSYSTEMTIME, "Year", $iYear)
DllStructSetData($tSYSTEMTIME, "Hour", $iHour)
DllStructSetData($tSYSTEMTIME, "Minute", $iMinute)
DllStructSetData($tSYSTEMTIME, "Second", $iSecond)
DllStructSetData($tSYSTEMTIME, "MSeconds", $iMSeconds)
Return $tSYSTEMTIME
EndFunc
Func _Date_Time_FileTimeToArray(ByRef $tFileTime)
If ((DllStructGetData($tFileTime, 1) + DllStructGetData($tFileTime, 2)) = 0) Then Return SetError(10, 0, 0)
Local $tSYSTEMTIME = _Date_Time_FileTimeToSystemTime($tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return _Date_Time_SystemTimeToArray($tSYSTEMTIME)
EndFunc
Func _Date_Time_FileTimeToStr(ByRef $tFileTime, $iFmt = 0)
Local $aDate = _Date_Time_FileTimeToArray($tFileTime)
If @error Then Return SetError(@error, @extended, "")
If $iFmt Then
Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $aDate[2], $aDate[0], $aDate[1], $aDate[3], $aDate[4], $aDate[5])
Else
Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $aDate[0], $aDate[1], $aDate[2], $aDate[3], $aDate[4], $aDate[5])
EndIf
EndFunc
Func _Date_Time_FileTimeToDOSDateTime($tFileTime)
Local $aDate[2]
Local $aResult = DllCall("kernel32.dll", "bool", "FileTimeToDosDateTime", "struct*", $tFileTime, "word*", 0, "word*", 0)
If @error Then Return SetError(@error, @extended, $aDate)
$aDate[0] = $aResult[2]
$aDate[1] = $aResult[3]
Return SetExtended($aResult[0], $aDate)
EndFunc
Func _Date_Time_FileTimeToLocalFileTime($tFileTime)
Local $tLocal = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "FileTimeToLocalFileTime", "struct*", $tFileTime, "struct*", $tLocal)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tLocal)
EndFunc
Func _Date_Time_FileTimeToSystemTime($tFileTime)
Local $tSystTime = DllStructCreate($tagSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "FileTimeToSystemTime", "struct*", $tFileTime, "struct*", $tSystTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tSystTime)
EndFunc
Func _Date_Time_GetFileTime($hFile)
Local $aDate[3]
$aDate[0] = DllStructCreate($tagFILETIME)
$aDate[1] = DllStructCreate($tagFILETIME)
$aDate[2] = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "GetFileTime", "handle", $hFile, "struct*", $aDate[0], "struct*", $aDate[1], "struct*", $aDate[2])
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $aDate)
EndFunc
Func _Date_Time_GetLocalTime()
Local $tSystTime = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetLocalTime", "struct*", $tSystTime)
If @error Then Return SetError(@error, @extended, 0)
Return $tSystTime
EndFunc
Func _Date_Time_GetSystemTime()
Local $tSystTime = DllStructCreate($tagSYSTEMTIME)
DllCall("kernel32.dll", "none", "GetSystemTime", "struct*", $tSystTime)
If @error Then Return SetError(@error, @extended, 0)
Return $tSystTime
EndFunc
Func _Date_Time_GetSystemTimeAdjustment()
Local $aInfo[3]
Local $aResult = DllCall("kernel32.dll", "bool", "GetSystemTimeAdjustment", "dword*", 0, "dword*", 0, "bool*", 0)
If @error Then Return SetError(@error, @extended, 0)
$aInfo[0] = $aResult[1]
$aInfo[1] = $aResult[2]
$aInfo[2] = $aResult[3] <> 0
Return SetExtended($aResult[0], $aInfo)
EndFunc
Func _Date_Time_GetSystemTimeAsFileTime()
Local $tFileTime = DllStructCreate($tagFILETIME)
DllCall("kernel32.dll", "none", "GetSystemTimeAsFileTime", "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return $tFileTime
EndFunc
Func _Date_Time_GetSystemTimes()
Local $aInfo[3]
$aInfo[0] = DllStructCreate($tagFILETIME)
$aInfo[1] = DllStructCreate($tagFILETIME)
$aInfo[2] = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "GetSystemTimes", "struct*", $aInfo[0], "struct*", $aInfo[1], "struct*", $aInfo[2])
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $aInfo)
EndFunc
Func _Date_Time_GetTickCount()
Local $aResult = DllCall("kernel32.dll", "dword", "GetTickCount")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _Date_Time_GetTimeZoneInformation()
Local $tTimeZone = DllStructCreate($tagTIME_ZONE_INFORMATION)
Local $aResult = DllCall("kernel32.dll", "dword", "GetTimeZoneInformation", "struct*", $tTimeZone)
If @error Or $aResult[0] = -1 Then Return SetError(@error, @extended, 0)
Local $aInfo[8]
$aInfo[0] = $aResult[0]
$aInfo[1] = DllStructGetData($tTimeZone, "Bias")
$aInfo[2] = _WinAPI_WideCharToMultiByte(DllStructGetPtr($tTimeZone, "StdName"))
$aInfo[3] = __Date_Time_CloneSystemTime(DllStructGetPtr($tTimeZone, "StdDate"))
$aInfo[4] = DllStructGetData($tTimeZone, "StdBias")
$aInfo[5] = _WinAPI_WideCharToMultiByte(DllStructGetPtr($tTimeZone, "DayName"))
$aInfo[6] = __Date_Time_CloneSystemTime(DllStructGetPtr($tTimeZone, "DayDate"))
$aInfo[7] = DllStructGetData($tTimeZone, "DayBias")
Return $aInfo
EndFunc
Func _Date_Time_LocalFileTimeToFileTime($tLocalTime)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "LocalFileTimeToFileTime", "struct*", $tLocalTime, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Func _Date_Time_SetFileTime($hFile, $tCreateTime, $tLastAccess, $tLastWrite)
Local $aResult = DllCall("kernel32.dll", "bool", "SetFileTime", "handle", $hFile, "struct*", $tCreateTime, "struct*", $tLastAccess, "struct*", $tLastWrite)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _Date_Time_SetLocalTime($tSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SetLocalTime", "struct*", $tSYSTEMTIME)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, False)
$aResult = DllCall("kernel32.dll", "bool", "SetLocalTime", "struct*", $tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _Date_Time_SetSystemTime($tSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SetSystemTime", "struct*", $tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _Date_Time_SetSystemTimeAdjustment($iAdjustment, $bDisabled)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, False)
_Security__SetPrivilege($hToken, "SeSystemtimePrivilege", True)
Local $iError = @error
Local $iLastError = @extended
Local $bRet = False
If Not @error Then
Local $aResult = DllCall("kernel32.dll", "bool", "SetSystemTimeAdjustment", "dword", $iAdjustment, "bool", $bDisabled)
If @error Then
$iError = @error
$iLastError = @extended
ElseIf $aResult[0] Then
$bRet = True
Else
$iError = 20
$iLastError = _WinAPI_GetLastError()
EndIf
_Security__SetPrivilege($hToken, "SeSystemtimePrivilege", False)
If Not $iError And @error Then $iError = 22
EndIf
_WinAPI_CloseHandle($hToken)
Return SetError($iError, $iLastError, $bRet)
EndFunc
Func _Date_Time_SetTimeZoneInformation($iBias, $sStdName, $tStdDate, $iStdBias, $sDayName, $tDayDate, $iDayBias)
Local $tStdName = _WinAPI_MultiByteToWideChar($sStdName)
Local $tDayName = _WinAPI_MultiByteToWideChar($sDayName)
Local $tZoneInfo = DllStructCreate($tagTIME_ZONE_INFORMATION)
DllStructSetData($tZoneInfo, "Bias", $iBias)
DllStructSetData($tZoneInfo, "StdName", DllStructGetData($tStdName, 1))
_MemMoveMemory($tStdDate, DllStructGetPtr($tZoneInfo, "StdDate"), DllStructGetSize($tStdDate))
DllStructSetData($tZoneInfo, "StdBias", $iStdBias)
DllStructSetData($tZoneInfo, "DayName", DllStructGetData($tDayName, 1))
_MemMoveMemory($tDayDate, DllStructGetPtr($tZoneInfo, "DayDate"), DllStructGetSize($tDayDate))
DllStructSetData($tZoneInfo, "DayBias", $iDayBias)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, False)
_Security__SetPrivilege($hToken, "SeSystemtimePrivilege", True)
Local $iError = @error
Local $iLastError = @extended
Local $bRet = False
If Not @error Then
Local $aResult = DllCall("kernel32.dll", "bool", "SetTimeZoneInformation", "struct*", $tZoneInfo)
If @error Then
$iError = @error
$iLastError = @extended
ElseIf $aResult[0] Then
$iLastError = 0
$bRet = True
Else
$iError = 20
$iLastError = _WinAPI_GetLastError()
EndIf
_Security__SetPrivilege($hToken, "SeSystemtimePrivilege", False)
If Not $iError And @error Then $iError = 22
EndIf
_WinAPI_CloseHandle($hToken)
Return SetError($iError, $iLastError, $bRet)
EndFunc
Func _Date_Time_SystemTimeToArray(ByRef $tSYSTEMTIME)
Local $aInfo[8]
$aInfo[0] = DllStructGetData($tSYSTEMTIME, "Month")
$aInfo[1] = DllStructGetData($tSYSTEMTIME, "Day")
$aInfo[2] = DllStructGetData($tSYSTEMTIME, "Year")
$aInfo[3] = DllStructGetData($tSYSTEMTIME, "Hour")
$aInfo[4] = DllStructGetData($tSYSTEMTIME, "Minute")
$aInfo[5] = DllStructGetData($tSYSTEMTIME, "Second")
$aInfo[6] = DllStructGetData($tSYSTEMTIME, "MSeconds")
$aInfo[7] = DllStructGetData($tSYSTEMTIME, "DOW")
Return $aInfo
EndFunc
Func _Date_Time_SystemTimeToDateStr(ByRef $tSYSTEMTIME, $iFmt = 0)
Local $aInfo = _Date_Time_SystemTimeToArray($tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, "")
If $iFmt Then
Return StringFormat("%04d/%02d/%02d", $aInfo[2], $aInfo[0], $aInfo[1])
Else
Return StringFormat("%02d/%02d/%04d", $aInfo[0], $aInfo[1], $aInfo[2])
EndIf
EndFunc
Func _Date_Time_SystemTimeToDateTimeStr(ByRef $tSYSTEMTIME, $iFmt = 0)
Local $aInfo = _Date_Time_SystemTimeToArray($tSYSTEMTIME)
If @error Then Return SetError(@error, @extended, "")
If $iFmt Then
Return StringFormat("%04d/%02d/%02d %02d:%02d:%02d", $aInfo[2], $aInfo[0], $aInfo[1], $aInfo[3], $aInfo[4], $aInfo[5])
Else
Return StringFormat("%02d/%02d/%04d %02d:%02d:%02d", $aInfo[0], $aInfo[1], $aInfo[2], $aInfo[3], $aInfo[4], $aInfo[5])
EndIf
EndFunc
Func _Date_Time_SystemTimeToFileTime($tSYSTEMTIME)
Local $tFileTime = DllStructCreate($tagFILETIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SystemTimeToFileTime", "struct*", $tSYSTEMTIME, "struct*", $tFileTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tFileTime)
EndFunc
Func _Date_Time_SystemTimeToTimeStr(ByRef $tSYSTEMTIME)
Local $aInfo = _Date_Time_SystemTimeToArray($tSYSTEMTIME)
Return StringFormat("%02d:%02d:%02d", $aInfo[3], $aInfo[4], $aInfo[5])
EndFunc
Func _Date_Time_SystemTimeToTzSpecificLocalTime($tUTC, $tTimeZone = 0)
Local $tLocalTime = DllStructCreate($tagSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "SystemTimeToTzSpecificLocalTime", "struct*", $tTimeZone, "struct*", $tUTC, "struct*", $tLocalTime)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tLocalTime)
EndFunc
Func _Date_Time_TzSpecificLocalTimeToSystemTime($tLocalTime, $tTimeZone = 0)
Local $tUTC = DllStructCreate($tagSYSTEMTIME)
Local $aResult = DllCall("kernel32.dll", "bool", "TzSpecificLocalTimeToSystemTime", "struct*", $tTimeZone, "struct*", $tLocalTime, "struct*", $tUTC)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tUTC)
EndFunc
Global Const $FW_DONTCARE = 0
Global Const $FW_THIN = 100
Global Const $FW_EXTRALIGHT = 200
Global Const $FW_ULTRALIGHT = 200
Global Const $FW_LIGHT = 300
Global Const $FW_NORMAL = 400
Global Const $FW_REGULAR = 400
Global Const $FW_MEDIUM = 500
Global Const $FW_SEMIBOLD = 600
Global Const $FW_DEMIBOLD = 600
Global Const $FW_BOLD = 700
Global Const $FW_EXTRABOLD = 800
Global Const $FW_ULTRABOLD = 800
Global Const $FW_HEAVY = 900
Global Const $FW_BLACK = 900
Global Const $CF_EFFECTS = 0x100
Global Const $CF_PRINTERFONTS = 0x2
Global Const $CF_SCREENFONTS = 0x1
Global Const $CF_NOSCRIPTSEL = 0x800000
Global Const $CF_INITTOLOGFONTSTRUCT = 0x40
Global Const $LOGPIXELSX = 88
Global Const $LOGPIXELSY = 90
Global Const $ANSI_CHARSET = 0
Global Const $ARABIC_CHARSET = 178
Global Const $BALTIC_CHARSET = 186
Global Const $CHINESEBIG5_CHARSET = 136
Global Const $DEFAULT_CHARSET = 1
Global Const $EASTEUROPE_CHARSET = 238
Global Const $GB2312_CHARSET = 134
Global Const $GREEK_CHARSET = 161
Global Const $HANGEUL_CHARSET = 129
Global Const $HEBREW_CHARSET = 177
Global Const $JOHAB_CHARSET = 130
Global Const $MAC_CHARSET = 77
Global Const $OEM_CHARSET = 255
Global Const $RUSSIAN_CHARSET = 204
Global Const $SHIFTJIS_CHARSET = 128
Global Const $SYMBOL_CHARSET = 2
Global Const $THAI_CHARSET = 222
Global Const $TURKISH_CHARSET = 162
Global Const $VIETNAMESE_CHARSET = 163
Global Const $OUT_CHARACTER_PRECIS = 2
Global Const $OUT_DEFAULT_PRECIS = 0
Global Const $OUT_DEVICE_PRECIS = 5
Global Const $OUT_OUTLINE_PRECIS = 8
Global Const $OUT_PS_ONLY_PRECIS = 10
Global Const $OUT_RASTER_PRECIS = 6
Global Const $OUT_STRING_PRECIS = 1
Global Const $OUT_STROKE_PRECIS = 3
Global Const $OUT_TT_ONLY_PRECIS = 7
Global Const $OUT_TT_PRECIS = 4
Global Const $CLIP_CHARACTER_PRECIS = 1
Global Const $CLIP_DEFAULT_PRECIS = 0
Global Const $CLIP_DFA_DISABLE = 0x0030
Global Const $CLIP_EMBEDDED = 128
Global Const $CLIP_LH_ANGLES = 16
Global Const $CLIP_MASK = 0xF
Global Const $CLIP_DFA_OVERRIDE = 0x0040
Global Const $CLIP_STROKE_PRECIS = 2
Global Const $CLIP_TT_ALWAYS = 32
Global Const $ANTIALIASED_QUALITY = 4
Global Const $DEFAULT_QUALITY = 0
Global Const $DRAFT_QUALITY = 1
Global Const $NONANTIALIASED_QUALITY = 3
Global Const $PROOF_QUALITY = 2
Global Const $CLEARTYPE_QUALITY = 5
Global Const $DEFAULT_PITCH = 0
Global Const $FIXED_PITCH = 1
Global Const $VARIABLE_PITCH = 2
Global Const $FF_DECORATIVE = 80
Global Const $FF_DONTCARE = 0
Global Const $FF_MODERN = 48
Global Const $FF_ROMAN = 16
Global Const $FF_SCRIPT = 64
Global Const $FF_SWISS = 32
Global Const $FS_REGULAR = 0x00
Global Const $FS_BOLD = 0x01
Global Const $FS_ITALIC = 0x02
Global Const $__MISCCONSTANT_CC_ANYCOLOR = 0x0100
Global Const $__MISCCONSTANT_CC_FULLOPEN = 0x0002
Global Const $__MISCCONSTANT_CC_RGBINIT = 0x0001
Global Const $tagCHOOSECOLOR = "dword Size;hwnd hWndOwnder;handle hInstance;dword rgbResult;ptr CustColors;dword Flags;lparam lCustData;" &  "ptr lpfnHook;ptr lpTemplateName"
Global Const $tagCHOOSEFONT = "dword Size;hwnd hWndOwner;handle hDC;ptr LogFont;int PointSize;dword Flags;dword rgbColors;lparam CustData;" &  "ptr fnHook;ptr TemplateName;handle hInstance;ptr szStyle;word FontType;int SizeMin;int SizeMax"
Func _ChooseColor($iReturnType = 0, $iColorRef = 0, $iRefType = 0, $hWndOwnder = 0)
Local $tagCustcolors = "dword[16]"
Local $tChoose = DllStructCreate($tagCHOOSECOLOR)
Local $tCc = DllStructCreate($tagCustcolors)
If $iRefType = 1 Then
$iColorRef = Int($iColorRef)
ElseIf $iRefType = 2 Then
$iColorRef = Hex(String($iColorRef), 6)
$iColorRef = '0x' & StringMid($iColorRef, 5, 2) & StringMid($iColorRef, 3, 2) & StringMid($iColorRef, 1, 2)
EndIf
DllStructSetData($tChoose, "Size", DllStructGetSize($tChoose))
DllStructSetData($tChoose, "hWndOwnder", $hWndOwnder)
DllStructSetData($tChoose, "rgbResult", $iColorRef)
DllStructSetData($tChoose, "CustColors", DllStructGetPtr($tCc))
DllStructSetData($tChoose, "Flags", BitOR($__MISCCONSTANT_CC_ANYCOLOR, $__MISCCONSTANT_CC_FULLOPEN, $__MISCCONSTANT_CC_RGBINIT))
Local $aResult = DllCall("comdlg32.dll", "bool", "ChooseColor", "struct*", $tChoose)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] = 0 Then Return SetError(-3, -3, -1)
Local $sColor_picked = DllStructGetData($tChoose, "rgbResult")
If $iReturnType = 1 Then
Return '0x' & Hex(String($sColor_picked), 6)
ElseIf $iReturnType = 2 Then
$sColor_picked = Hex(String($sColor_picked), 6)
Return '0x' & StringMid($sColor_picked, 5, 2) & StringMid($sColor_picked, 3, 2) & StringMid($sColor_picked, 1, 2)
ElseIf $iReturnType = 0 Then
Return $sColor_picked
Else
Return SetError(-4, -4, -1)
EndIf
EndFunc
Func _ChooseFont($sFontName = "Courier New", $iPointSize = 10, $iFontColorRef = 0, $iFontWeight = 0, $bItalic = False, $bUnderline = False, $bStrikethru = False, $hWndOwner = 0)
Local $iItalic = 0, $iUnderline = 0, $iStrikeout = 0
$iFontColorRef = BitOR(BitShift(BitAND($iFontColorRef, 0x000000FF), -16), BitAND($iFontColorRef, 0x0000FF00), BitShift(BitAND($iFontColorRef, 0x00FF0000), 16))
Local $hDC = __MISC_GetDC(0)
Local $iHeight = Round(($iPointSize * __MISC_GetDeviceCaps($hDC, $LOGPIXELSX)) / 72, 0)
__MISC_ReleaseDC(0, $hDC)
Local $tChooseFont = DllStructCreate($tagCHOOSEFONT)
Local $tLogFont = DllStructCreate($tagLOGFONT)
DllStructSetData($tChooseFont, "Size", DllStructGetSize($tChooseFont))
DllStructSetData($tChooseFont, "hWndOwner", $hWndOwner)
DllStructSetData($tChooseFont, "LogFont", DllStructGetPtr($tLogFont))
DllStructSetData($tChooseFont, "PointSize", $iPointSize)
DllStructSetData($tChooseFont, "Flags", BitOR($CF_SCREENFONTS, $CF_PRINTERFONTS, $CF_EFFECTS, $CF_INITTOLOGFONTSTRUCT, $CF_NOSCRIPTSEL))
DllStructSetData($tChooseFont, "rgbColors", $iFontColorRef)
DllStructSetData($tChooseFont, "FontType", 0)
DllStructSetData($tLogFont, "Height", $iHeight)
DllStructSetData($tLogFont, "Weight", $iFontWeight)
DllStructSetData($tLogFont, "Italic", $bItalic)
DllStructSetData($tLogFont, "Underline", $bUnderline)
DllStructSetData($tLogFont, "Strikeout", $bStrikethru)
DllStructSetData($tLogFont, "FaceName", $sFontName)
Local $aResult = DllCall("comdlg32.dll", "bool", "ChooseFontW", "struct*", $tChooseFont)
If @error Then Return SetError(@error, @extended, -1)
If $aResult[0] = 0 Then Return SetError(-3, -3, -1)
Local $sFaceName = DllStructGetData($tLogFont, "FaceName")
If StringLen($sFaceName) = 0 And StringLen($sFontName) > 0 Then $sFaceName = $sFontName
If DllStructGetData($tLogFont, "Italic") Then $iItalic = 2
If DllStructGetData($tLogFont, "Underline") Then $iUnderline = 4
If DllStructGetData($tLogFont, "Strikeout") Then $iStrikeout = 8
Local $iAttributes = BitOR($iItalic, $iUnderline, $iStrikeout)
Local $iSize = DllStructGetData($tChooseFont, "PointSize") / 10
Local $iColorRef = DllStructGetData($tChooseFont, "rgbColors")
Local $iWeight = DllStructGetData($tLogFont, "Weight")
Local $sColor_picked = Hex(String($iColorRef), 6)
Return StringSplit($iAttributes & "," & $sFaceName & "," & $iSize & "," & $iWeight & "," & $iColorRef & "," & '0x' & $sColor_picked & "," & '0x' & StringMid($sColor_picked, 5, 2) & StringMid($sColor_picked, 3, 2) & StringMid($sColor_picked, 1, 2), ",")
EndFunc
Func _ClipPutFile($sFilePath, $sDelimiter = "|")
Local Const $GMEM_MOVEABLE = 0x0002, $CF_HDROP = 15
$sFilePath &= $sDelimiter & $sDelimiter
Local $nGlobMemSize = 2 * (StringLen($sFilePath) + 20)
Local $aResult = DllCall("user32.dll", "bool", "OpenClipboard", "hwnd", 0)
If @error Or $aResult[0] = 0 Then Return SetError(1, _WinAPI_GetLastError(), False)
Local $iError = 0, $iLastError = 0
$aResult = DllCall("user32.dll", "bool", "EmptyClipboard")
If @error Or Not $aResult[0] Then
$iError = 2
$iLastError = _WinAPI_GetLastError()
Else
$aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $nGlobMemSize)
If @error Or Not $aResult[0] Then
$iError = 3
$iLastError = _WinAPI_GetLastError()
Else
Local $hGlobal = $aResult[0]
$aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hGlobal)
If @error Or Not $aResult[0] Then
$iError = 4
$iLastError = _WinAPI_GetLastError()
Else
Local $hLock = $aResult[0]
Local $tDROPFILES = DllStructCreate("dword pFiles;" & $tagPOINT & ";bool fNC;bool fWide;wchar[" & StringLen($sFilePath) + 1 & "]", $hLock)
If @error Then Return SetError(5, 6, False)
Local $tStruct = DllStructCreate("dword;long;long;bool;bool")
DllStructSetData($tDROPFILES, "pFiles", DllStructGetSize($tStruct))
DllStructSetData($tDROPFILES, "X", 0)
DllStructSetData($tDROPFILES, "Y", 0)
DllStructSetData($tDROPFILES, "fNC", 0)
DllStructSetData($tDROPFILES, "fWide", 1)
DllStructSetData($tDROPFILES, 6, $sFilePath)
For $i = 1 To StringLen($sFilePath)
If DllStructGetData($tDROPFILES, 6, $i) = $sDelimiter Then DllStructSetData($tDROPFILES, 6, Chr(0), $i)
Next
$aResult = DllCall("user32.dll", "handle", "SetClipboardData", "uint", $CF_HDROP, "handle", $hGlobal)
If @error Or Not $aResult[0] Then
$iError = 6
$iLastError = _WinAPI_GetLastError()
EndIf
$aResult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hGlobal)
If (@error Or Not $aResult[0]) And Not $iError And _WinAPI_GetLastError() Then
$iError = 8
$iLastError = _WinAPI_GetLastError()
EndIf
EndIf
$aResult = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hGlobal)
If (@error Or $aResult[0]) And Not $iError Then
$iError = 9
$iLastError = _WinAPI_GetLastError()
EndIf
EndIf
EndIf
$aResult = DllCall("user32.dll", "bool", "CloseClipboard")
If (@error Or Not $aResult[0]) And Not $iError Then Return SetError(7, _WinAPI_GetLastError(), False)
If $iError Then Return SetError($iError, $iLastError, False)
Return True
EndFunc
Func _MouseTrap($iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0)
Local $aReturn = 0
If $iLeft = Default Then $iLeft = 0
If $iTop = Default Then $iTop = 0
If $iRight = Default Then $iRight = 0
If $iBottom = Default Then $iBottom = 0
If @NumParams = 0 Then
$aReturn = DllCall("user32.dll", "bool", "ClipCursor", "ptr", 0)
If @error Or Not $aReturn[0] Then Return SetError(1, _WinAPI_GetLastError(), False)
Else
If @NumParams = 2 Then
$iRight = $iLeft + 1
$iBottom = $iTop + 1
EndIf
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
$aReturn = DllCall("user32.dll", "bool", "ClipCursor", "struct*", $tRECT)
If @error Or Not $aReturn[0] Then Return SetError(2, _WinAPI_GetLastError(), False)
EndIf
Return True
EndFunc
Func _Singleton($sOccurrenceName, $iFlag = 0)
Local Const $ERROR_ALREADY_EXISTS = 183
Local Const $SECURITY_DESCRIPTOR_REVISION = 1
Local $tSecurityAttributes = 0
If BitAND($iFlag, 2) Then
Local $tSecurityDescriptor = DllStructCreate("byte;byte;word;ptr[4]")
Local $aRet = DllCall("advapi32.dll", "bool", "InitializeSecurityDescriptor",  "struct*", $tSecurityDescriptor, "dword", $SECURITY_DESCRIPTOR_REVISION)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then
$aRet = DllCall("advapi32.dll", "bool", "SetSecurityDescriptorDacl",  "struct*", $tSecurityDescriptor, "bool", 1, "ptr", 0, "bool", 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then
$tSecurityAttributes = DllStructCreate($tagSECURITY_ATTRIBUTES)
DllStructSetData($tSecurityAttributes, 1, DllStructGetSize($tSecurityAttributes))
DllStructSetData($tSecurityAttributes, 2, DllStructGetPtr($tSecurityDescriptor))
DllStructSetData($tSecurityAttributes, 3, 0)
EndIf
EndIf
EndIf
Local $aHandle = DllCall("kernel32.dll", "handle", "CreateMutexW", "struct*", $tSecurityAttributes, "bool", 1, "wstr", $sOccurrenceName)
If @error Then Return SetError(@error, @extended, 0)
Local $aLastError = DllCall("kernel32.dll", "dword", "GetLastError")
If @error Then Return SetError(@error, @extended, 0)
If $aLastError[0] = $ERROR_ALREADY_EXISTS Then
If BitAND($iFlag, 1) Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $aHandle[0])
If @error Then Return SetError(@error, @extended, 0)
Return SetError($aLastError[0], $aLastError[0], 0)
Else
Exit -1
EndIf
EndIf
Return $aHandle[0]
EndFunc
Func _IsPressed($sHexKey, $vDLL = 'user32.dll')
Local $a_R = DllCall($vDLL, "short", "GetAsyncKeyState", "int", '0x' & $sHexKey)
If @error Then Return SetError(@error, @extended, False)
Return BitAND($a_R[0], 0x8000) <> 0
EndFunc
Func _VersionCompare($sVersion1, $sVersion2)
If $sVersion1 = $sVersion2 Then Return 0
Local $sSubVersion1 = "", $sSubVersion2 = ""
If StringIsAlpha(StringRight($sVersion1, 1)) Then
$sSubVersion1 = StringRight($sVersion1, 1)
$sVersion1 = StringTrimRight($sVersion1, 1)
EndIf
If StringIsAlpha(StringRight($sVersion2, 1)) Then
$sSubVersion2 = StringRight($sVersion2, 1)
$sVersion2 = StringTrimRight($sVersion2, 1)
EndIf
Local $aVersion1 = StringSplit($sVersion1, ".,"),  $aVersion2 = StringSplit($sVersion2, ".,")
Local $iPartDifference = ($aVersion1[0] - $aVersion2[0])
If $iPartDifference < 0 Then
ReDim $aVersion1[UBound($aVersion2)]
$aVersion1[0] = UBound($aVersion1) - 1
For $i = (UBound($aVersion1) - Abs($iPartDifference)) To $aVersion1[0]
$aVersion1[$i] = "0"
Next
ElseIf $iPartDifference > 0 Then
ReDim $aVersion2[UBound($aVersion1)]
$aVersion2[0] = UBound($aVersion2) - 1
For $i = (UBound($aVersion2) - Abs($iPartDifference)) To $aVersion2[0]
$aVersion2[$i] = "0"
Next
EndIf
For $i = 1 To $aVersion1[0]
If StringIsDigit($aVersion1[$i]) And StringIsDigit($aVersion2[$i]) Then
If Number($aVersion1[$i]) > Number($aVersion2[$i]) Then
Return SetExtended(2, 1)
ElseIf Number($aVersion1[$i]) < Number($aVersion2[$i]) Then
Return SetExtended(2, -1)
ElseIf $i = $aVersion1[0] Then
If $sSubVersion1 > $sSubVersion2 Then
Return SetExtended(3, 1)
ElseIf $sSubVersion1 < $sSubVersion2 Then
Return SetExtended(3, -1)
EndIf
EndIf
Else
If $aVersion1[$i] > $aVersion2[$i] Then
Return SetExtended(1, 1)
ElseIf $aVersion1[$i] < $aVersion2[$i] Then
Return SetExtended(1, -1)
EndIf
EndIf
Next
Return SetExtended(Abs($iPartDifference), 0)
EndFunc
Func __MISC_GetDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Or Not $aResult[0] Then Return SetError(1, _WinAPI_GetLastError(), 0)
Return $aResult[0]
EndFunc
Func __MISC_GetDeviceCaps($hDC, $iIndex)
Local $aResult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func __MISC_ReleaseDC($hWnd, $hDC)
Local $aResult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _FileCountLines($sFilePath)
Local $hFileOpen = FileOpen($sFilePath, $FO_READ)
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $sFileRead = StringStripWS(FileRead($hFileOpen), $STR_STRIPTRAILING)
FileClose($hFileOpen)
Return UBound(StringRegExp($sFileRead, "\R", $STR_REGEXPARRAYGLOBALMATCH)) + 1 - Int($sFileRead = "")
EndFunc
Func _FileCreate($sFilePath)
Local $hFileOpen = FileOpen($sFilePath, BitOR($FO_OVERWRITE, $FO_CREATEPATH))
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iFileWrite = FileWrite($hFileOpen, "")
FileClose($hFileOpen)
If Not $iFileWrite Then Return SetError(2, 0, 0)
Return 1
EndFunc
Func _FileListToArray($sFilePath, $sFilter = "*", $iFlag = $FLTA_FILESFOLDERS, $bReturnPath = False)
Local $sDelimiter = "|", $sFileList = "", $sFileName = "", $sFullPath = ""
$sFilePath = StringRegExpReplace($sFilePath, "[\\/]+$", "") & "\"
If $iFlag = Default Then $iFlag = $FLTA_FILESFOLDERS
If $bReturnPath Then $sFullPath = $sFilePath
If $sFilter = Default Then $sFilter = "*"
If Not FileExists($sFilePath) Then Return SetError(1, 0, 0)
If StringRegExp($sFilter, "[\\/:><\|]|(?s)^\s*$") Then Return SetError(2, 0, 0)
If Not ($iFlag = 0 Or $iFlag = 1 Or $iFlag = 2) Then Return SetError(3, 0, 0)
Local $hSearch = FileFindFirstFile($sFilePath & $sFilter)
If @error Then Return SetError(4, 0, 0)
While 1
$sFileName = FileFindNextFile($hSearch)
If @error Then ExitLoop
If ($iFlag + @extended = 2) Then ContinueLoop
$sFileList &= $sDelimiter & $sFullPath & $sFileName
WEnd
FileClose($hSearch)
If $sFileList = "" Then Return SetError(4, 0, 0)
Return StringSplit(StringTrimLeft($sFileList, 1), $sDelimiter)
EndFunc
Func _FileListToArrayRec($sFilePath, $sMask = "*", $iReturn = $FLTAR_FILESFOLDERS, $iRecur = $FLTAR_NORECUR, $iSort = $FLTAR_NOSORT, $iReturnPath = $FLTAR_RELPATH)
If Not FileExists($sFilePath) Then Return SetError(1, 1, "")
If $sMask = Default Then $sMask = "*"
If $iReturn = Default Then $iReturn = $FLTAR_FILESFOLDERS
If $iRecur = Default Then $iRecur = $FLTAR_NORECUR
If $iSort = Default Then $iSort = $FLTAR_NOSORT
If $iReturnPath = Default Then $iReturnPath = $FLTAR_RELPATH
If $iRecur > 1 Or Not IsInt($iRecur) Then Return SetError(1, 6, "")
Local $bLongPath = False
If StringLeft($sFilePath, 4) == "\\?\" Then
$bLongPath = True
EndIf
Local $sFolderSlash = ""
If StringRight($sFilePath, 1) = "\" Then
$sFolderSlash = "\"
Else
$sFilePath = $sFilePath & "\"
EndIf
Local $asFolderSearchList[100] = [1]
$asFolderSearchList[1] = $sFilePath
Local $iHide_HS = 0,  $sHide_HS = ""
If BitAND($iReturn, 4) Then
$iHide_HS += 2
$sHide_HS &= "H"
$iReturn -= 4
EndIf
If BitAND($iReturn, 8) Then
$iHide_HS += 4
$sHide_HS &= "S"
$iReturn -= 8
EndIf
Local $iHide_Link = 0
If BitAND($iReturn, 16) Then
$iHide_Link = 0x400
$iReturn -= 16
EndIf
Local $iMaxLevel = 0
If $iRecur < 0 Then
StringReplace($sFilePath, "\", "", 0, $STR_NOCASESENSEBASIC)
$iMaxLevel = @extended - $iRecur
EndIf
Local $sExclude_List = "", $sExclude_List_Folder = "", $sInclude_List = "*"
Local $aMaskSplit = StringSplit($sMask, "|")
Switch $aMaskSplit[0]
Case 3
$sExclude_List_Folder = $aMaskSplit[3]
ContinueCase
Case 2
$sExclude_List = $aMaskSplit[2]
ContinueCase
Case 1
$sInclude_List = $aMaskSplit[1]
EndSwitch
Local $sInclude_File_Mask = ".+"
If $sInclude_List <> "*" Then
If Not __FLTAR_ListToMask($sInclude_File_Mask, $sInclude_List) Then Return SetError(1, 2, "")
EndIf
Local $sInclude_Folder_Mask = ".+"
Switch $iReturn
Case 0
Switch $iRecur
Case 0
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Case 2
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Local $sExclude_File_Mask = ":"
If $sExclude_List <> "" Then
If Not __FLTAR_ListToMask($sExclude_File_Mask, $sExclude_List) Then Return SetError(1, 3, "")
EndIf
Local $sExclude_Folder_Mask = ":"
If $iRecur Then
If $sExclude_List_Folder Then
If Not __FLTAR_ListToMask($sExclude_Folder_Mask, $sExclude_List_Folder) Then Return SetError(1, 4, "")
EndIf
If $iReturn = 2 Then
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
Else
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
If Not ($iReturn = 0 Or $iReturn = 1 Or $iReturn = 2) Then Return SetError(1, 5, "")
If Not ($iSort = 0 Or $iSort = 1 Or $iSort = 2) Then Return SetError(1, 7, "")
If Not ($iReturnPath = 0 Or $iReturnPath = 1 Or $iReturnPath = 2) Then Return SetError(1, 8, "")
If $iHide_Link Then
Local $tFile_Data = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" &  "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
Local $hDLL = DllOpen('kernel32.dll'), $aDLL_Ret
EndIf
Local $asReturnList[100] = [0]
Local $asFileMatchList = $asReturnList, $asRootFileMatchList = $asReturnList, $asFolderMatchList = $asReturnList
Local $bFolder = False,  $hSearch = 0,  $sCurrentPath = "", $sName = "", $sRetPath = ""
Local $iAttribs = 0,  $sAttribs = ''
Local $asFolderFileSectionList[100][2] = [[0, 0]]
While $asFolderSearchList[0] > 0
$sCurrentPath = $asFolderSearchList[$asFolderSearchList[0]]
$asFolderSearchList[0] -= 1
Switch $iReturnPath
Case 1
$sRetPath = StringReplace($sCurrentPath, $sFilePath, "")
Case 2
If $bLongPath Then
$sRetPath = StringTrimLeft($sCurrentPath, 4)
Else
$sRetPath = $sCurrentPath
EndIf
EndSwitch
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'handle', 'FindFirstFileW', 'wstr', $sCurrentPath & "*", 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ContinueLoop
EndIf
$hSearch = $aDLL_Ret[0]
Else
$hSearch = FileFindFirstFile($sCurrentPath & "*")
If $hSearch = -1 Then
ContinueLoop
EndIf
EndIf
If $iReturn = 0 And $iSort And $iReturnPath Then
__FLTAR_AddToList($asFolderFileSectionList, $sRetPath, $asFileMatchList[0] + 1)
EndIf
$sAttribs = ''
While 1
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'int', 'FindNextFileW', 'handle', $hSearch, 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ExitLoop
EndIf
$sName = DllStructGetData($tFile_Data, "FileName")
If $sName = ".." Then
ContinueLoop
EndIf
$iAttribs = DllStructGetData($tFile_Data, "FileAttributes")
If $iHide_HS And BitAND($iAttribs, $iHide_HS) Then
ContinueLoop
EndIf
If BitAND($iAttribs, $iHide_Link) Then
ContinueLoop
EndIf
$bFolder = False
If BitAND($iAttribs, 16) Then
$bFolder = True
EndIf
Else
$bFolder = False
$sName = FileFindNextFile($hSearch, 1)
If @error Then
ExitLoop
EndIf
$sAttribs = @extended
If StringInStr($sAttribs, "D") Then
$bFolder = True
EndIf
If StringRegExp($sAttribs, "[" & $sHide_HS & "]") Then
ContinueLoop
EndIf
EndIf
If $bFolder Then
Select
Case $iRecur < 0
StringReplace($sCurrentPath, "\", "", 0, $STR_NOCASESENSEBASIC)
If @extended < $iMaxLevel Then
ContinueCase
EndIf
Case $iRecur = 1
If Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderSearchList, $sCurrentPath & $sName & "\")
EndIf
EndSelect
EndIf
If $iSort Then
If $bFolder Then
If StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderMatchList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
If $sCurrentPath = $sFilePath Then
__FLTAR_AddToList($asRootFileMatchList, $sRetPath & $sName)
Else
__FLTAR_AddToList($asFileMatchList, $sRetPath & $sName)
EndIf
EndIf
EndIf
Else
If $bFolder Then
If $iReturn <> 1 And StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If $iReturn <> 2 And StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName)
EndIf
EndIf
EndIf
WEnd
If $iHide_Link Then
DllCall($hDLL, 'int', 'FindClose', 'ptr', $hSearch)
Else
FileClose($hSearch)
EndIf
WEnd
If $iHide_Link Then
DllClose($hDLL)
EndIf
If $iSort Then
Switch $iReturn
Case 2
If $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
$asReturnList = $asFolderMatchList
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Case 1
If $asRootFileMatchList[0] = 0 And $asFileMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList, 1)
EndIf
Case 0
If $asRootFileMatchList[0] = 0 And $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
$asReturnList[0] += $asFolderMatchList[0]
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
_ArrayConcatenate($asReturnList, $asFolderMatchList, 1)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
Local $asReturnList[$asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0] + 1]
$asReturnList[0] = $asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0]
__ArrayDualPivotSort($asRootFileMatchList, 1, $asRootFileMatchList[0])
For $i = 1 To $asRootFileMatchList[0]
$asReturnList[$i] = $asRootFileMatchList[$i]
Next
Local $iNextInsertionIndex = $asRootFileMatchList[0] + 1
__ArrayDualPivotSort($asFolderMatchList, 1, $asFolderMatchList[0])
Local $sFolderToFind = ""
For $i = 1 To $asFolderMatchList[0]
$asReturnList[$iNextInsertionIndex] = $asFolderMatchList[$i]
$iNextInsertionIndex += 1
If $sFolderSlash Then
$sFolderToFind = $asFolderMatchList[$i]
Else
$sFolderToFind = $asFolderMatchList[$i] & "\"
EndIf
Local $iFileSectionEndIndex = 0, $iFileSectionStartIndex = 0
For $j = 1 To $asFolderFileSectionList[0][0]
If $sFolderToFind = $asFolderFileSectionList[$j][0] Then
$iFileSectionStartIndex = $asFolderFileSectionList[$j][1]
If $j = $asFolderFileSectionList[0][0] Then
$iFileSectionEndIndex = $asFileMatchList[0]
Else
$iFileSectionEndIndex = $asFolderFileSectionList[$j + 1][1] - 1
EndIf
If $iSort = 1 Then
__ArrayDualPivotSort($asFileMatchList, $iFileSectionStartIndex, $iFileSectionEndIndex)
EndIf
For $k = $iFileSectionStartIndex To $iFileSectionEndIndex
$asReturnList[$iNextInsertionIndex] = $asFileMatchList[$k]
$iNextInsertionIndex += 1
Next
ExitLoop
EndIf
Next
Next
EndIf
EndSwitch
Else
If $asReturnList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asReturnList[$asReturnList[0] + 1]
EndIf
Return $asReturnList
EndFunc
Func __FLTAR_AddFileLists(ByRef $asTarget, $asSource_1, $asSource_2, $iSort = 0)
ReDim $asSource_1[$asSource_1[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_1, 1, $asSource_1[0])
$asTarget = $asSource_1
$asTarget[0] += $asSource_2[0]
ReDim $asSource_2[$asSource_2[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_2, 1, $asSource_2[0])
_ArrayConcatenate($asTarget, $asSource_2, 1)
EndFunc
Func __FLTAR_AddToList(ByRef $aList, $vValue_0, $vValue_1 = -1)
If $vValue_1 = -1 Then
$aList[0] += 1
If UBound($aList) <= $aList[0] Then ReDim $aList[UBound($aList) * 2]
$aList[$aList[0]] = $vValue_0
Else
$aList[0][0] += 1
If UBound($aList) <= $aList[0][0] Then ReDim $aList[UBound($aList) * 2][2]
$aList[$aList[0][0]][0] = $vValue_0
$aList[$aList[0][0]][1] = $vValue_1
EndIf
EndFunc
Func __FLTAR_ListToMask(ByRef $sMask, $sList)
If StringRegExp($sList, "\\|/|:|\<|\>|\|") Then Return 0
$sList = StringReplace(StringStripWS(StringRegExpReplace($sList, "\s*;\s*", ";"), $STR_STRIPLEADING + $STR_STRIPTRAILING), ";", "|")
$sList = StringReplace(StringReplace(StringRegExpReplace($sList, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
$sMask = "(?i)^(" & $sList & ")\z"
Return 1
EndFunc
Func _FilePrint($sFilePath, $iShow = @SW_HIDE)
If $iShow = Default Then $iShow = @SW_HIDE
Return ShellExecute($sFilePath, "", @WorkingDir, "print", $iShow)
EndFunc
Func _FileReadToArray($sFilePath, ByRef $vReturn, $iFlags = $FRTA_COUNT, $sDelimiter = "")
$vReturn = 0
If $iFlags = Default Then $iFlags = $FRTA_COUNT
If $sDelimiter = Default Then $sDelimiter = ""
Local $bExpand = True
If BitAND($iFlags, $FRTA_INTARRAYS) Then
$bExpand = False
$iFlags -= $FRTA_INTARRAYS
EndIf
Local $iEntire = $STR_CHRSPLIT
If BitAND($iFlags, $FRTA_ENTIRESPLIT) Then
$iEntire = $STR_ENTIRESPLIT
$iFlags -= $FRTA_ENTIRESPLIT
EndIf
Local $iNoCount = 0
If $iFlags <> $FRTA_COUNT Then
$iFlags = $FRTA_NOCOUNT
$iNoCount = $STR_NOCOUNT
EndIf
If $sDelimiter Then
Local $aLines = FileReadToArray($sFilePath)
If @error Then Return SetError(@error, 0, 0)
Local $iDim_1 = UBound($aLines) + $iFlags
If $bExpand Then
Local $iDim_2 = UBound(StringSplit($aLines[0], $sDelimiter, $iEntire + $STR_NOCOUNT))
Local $aTemp_Array[$iDim_1][$iDim_2]
Local $iFields,  $aSplit
For $i = 0 To $iDim_1 - $iFlags - 1
$aSplit = StringSplit($aLines[$i], $sDelimiter, $iEntire + $STR_NOCOUNT)
$iFields = UBound($aSplit)
If $iFields <> $iDim_2 Then
Return SetError(3, 0, 0)
EndIf
For $j = 0 To $iFields - 1
$aTemp_Array[$i + $iFlags][$j] = $aSplit[$j]
Next
Next
If $iDim_2 < 2 Then Return SetError(4, 0, 0)
If $iFlags Then
$aTemp_Array[0][0] = $iDim_1 - $iFlags
$aTemp_Array[0][1] = $iDim_2
EndIf
Else
Local $aTemp_Array[$iDim_1]
For $i = 0 To $iDim_1 - $iFlags - 1
$aTemp_Array[$i + $iFlags] = StringSplit($aLines[$i], $sDelimiter, $iEntire + $iNoCount)
Next
If $iFlags Then
$aTemp_Array[0] = $iDim_1 - $iFlags
EndIf
EndIf
$vReturn = $aTemp_Array
Else
If $iFlags Then
Local $hFileOpen = FileOpen($sFilePath, $FO_READ)
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
If StringLen($sFileRead) Then
$vReturn = StringRegExp(@LF & $sFileRead, "(?|(\N+)\z|(\N*)(?:\R))", 3)
$vReturn[0] = UBound($vReturn) - 1
Else
Return SetError(2, 0, 0)
EndIf
Else
$vReturn = FileReadToArray($sFilePath)
If @error Then
$vReturn = 0
Return SetError(@error, 0, 0)
EndIf
EndIf
EndIf
Return 1
EndFunc
Func _FileWriteFromArray($sFilePath, Const ByRef $aArray, $iBase = Default, $iUBound = Default, $sDelimiter = "|")
Local $iReturn = 0
If Not IsArray($aArray) Then Return SetError(2, 0, $iReturn)
Local $iDims = UBound($aArray, $UBOUND_DIMENSIONS)
If $iDims > 2 Then Return SetError(4, 0, 0)
Local $iLast = UBound($aArray) - 1
If $iUBound = Default Or $iUBound > $iLast Then $iUBound = $iLast
If $iBase < 0 Or $iBase = Default Then $iBase = 0
If $iBase > $iUBound Then Return SetError(5, 0, $iReturn)
If $sDelimiter = Default Then $sDelimiter = "|"
Local $hFileOpen = $sFilePath
If IsString($sFilePath) Then
$hFileOpen = FileOpen($sFilePath, $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(1, 0, $iReturn)
EndIf
Local $iError = 0
$iReturn = 1
Switch $iDims
Case 1
For $i = $iBase To $iUBound
If Not FileWrite($hFileOpen, $aArray[$i] & @CRLF) Then
$iError = 3
$iReturn = 0
ExitLoop
EndIf
Next
Case 2
Local $sTemp = ""
For $i = $iBase To $iUBound
$sTemp = $aArray[$i][0]
For $j = 1 To UBound($aArray, $UBOUND_COLUMNS) - 1
$sTemp &= $sDelimiter & $aArray[$i][$j]
Next
If Not FileWrite($hFileOpen, $sTemp & @CRLF) Then
$iError = 3
$iReturn = 0
ExitLoop
EndIf
Next
EndSwitch
If IsString($sFilePath) Then FileClose($hFileOpen)
Return SetError($iError, 0, $iReturn)
EndFunc
Func _FileWriteLog($sLogPath, $sLogMsg, $iFlag = -1)
Local $iOpenMode = $FO_APPEND
Local $sDateNow = @YEAR & "-" & @MON & "-" & @MDAY
Local $sTimeNow = @HOUR & ":" & @MIN & ":" & @SEC
Local $sMsg = $sDateNow & " " & $sTimeNow & " : " & $sLogMsg
If $iFlag = Default Then $iFlag = -1
If $iFlag <> -1 Then
$iOpenMode = $FO_OVERWRITE
$sMsg &= @CRLF & FileRead($sLogPath)
EndIf
Local $hFileOpen = $sLogPath
If IsString($sLogPath) Then
$hFileOpen = FileOpen($sLogPath, $iOpenMode)
EndIf
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iReturn = FileWriteLine($hFileOpen, $sMsg)
If IsString($sLogPath) Then $iReturn = FileClose($hFileOpen)
If $iReturn <= 0 Then Return SetError(2, $iReturn, 0)
Return $iReturn
EndFunc
Func _FileWriteToLine($sFilePath, $iLine, $sText, $bOverWrite = False)
If $iLine <= 0 Then Return SetError(4, 0, 0)
If Not IsString($sText) Then
$sText = String($sText)
If $sText = "" Then Return SetError(6, 0, 0)
EndIf
If $bOverWrite = Default Then $bOverWrite = False
If Not (IsBool($bOverWrite) Or $bOverWrite = 0 Or $bOverWrite = 1) Then Return SetError(5, 0, 0)
If Not FileExists($sFilePath) Then Return SetError(2, 0, 0)
Local $aArray = FileReadToArray($sFilePath)
Local $iUBound = UBound($aArray) - 1
If ($iUBound + 1) < $iLine Then Return SetError(1, 0, 0)
Local $hFileOpen = FileOpen($sFilePath, FileGetEncoding($sFilePath) + $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(3, 0, 0)
Local $sData = ""
$iLine -= 1
For $i = 0 To $iUBound
If $i = $iLine Then
If $bOverWrite Then
If $sText Then $sData &= $sText & @CRLF
Else
$sData &= $sText & @CRLF & $aArray[$i] & @CRLF
EndIf
ElseIf $i < $iUBound Then
$sData &= $aArray[$i] & @CRLF
ElseIf $i = $iUBound Then
$sData &= $aArray[$i]
EndIf
Next
FileWrite($hFileOpen, $sData)
FileClose($hFileOpen)
Return 1
EndFunc
Func _PathFull($sRelativePath, $sBasePath = @WorkingDir)
If Not $sRelativePath Or $sRelativePath = "." Then Return $sBasePath
Local $sFullPath = StringReplace($sRelativePath, "/", "\")
Local Const $sFullPathConst = $sFullPath
Local $sPath
Local $bRootOnly = StringLeft($sFullPath, 1) = "\" And StringMid($sFullPath, 2, 1) <> "\"
If $sBasePath = Default Then $sBasePath = @WorkingDir
For $i = 1 To 2
$sPath = StringLeft($sFullPath, 2)
If $sPath = "\\" Then
$sFullPath = StringTrimLeft($sFullPath, 2)
Local $nServerLen = StringInStr($sFullPath, "\") - 1
$sPath = "\\" & StringLeft($sFullPath, $nServerLen)
$sFullPath = StringTrimLeft($sFullPath, $nServerLen)
ExitLoop
ElseIf StringRight($sPath, 1) = ":" Then
$sFullPath = StringTrimLeft($sFullPath, 2)
ExitLoop
Else
$sFullPath = $sBasePath & "\" & $sFullPath
EndIf
Next
If StringLeft($sFullPath, 1) <> "\" Then
If StringLeft($sFullPathConst, 2) = StringLeft($sBasePath, 2) Then
$sFullPath = $sBasePath & "\" & $sFullPath
Else
$sFullPath = "\" & $sFullPath
EndIf
EndIf
Local $aTemp = StringSplit($sFullPath, "\")
Local $aPathParts[$aTemp[0]], $j = 0
For $i = 2 To $aTemp[0]
If $aTemp[$i] = ".." Then
If $j Then $j -= 1
ElseIf Not ($aTemp[$i] = "" And $i <> $aTemp[0]) And $aTemp[$i] <> "." Then
$aPathParts[$j] = $aTemp[$i]
$j += 1
EndIf
Next
$sFullPath = $sPath
If Not $bRootOnly Then
For $i = 0 To $j - 1
$sFullPath &= "\" & $aPathParts[$i]
Next
Else
$sFullPath &= $sFullPathConst
If StringInStr($sFullPath, "..") Then $sFullPath = _PathFull($sFullPath)
EndIf
Do
$sFullPath = StringReplace($sFullPath, ".\", "\")
Until @extended = 0
Return $sFullPath
EndFunc
Func _PathGetRelative($sFrom, $sTo)
If StringRight($sFrom, 1) <> "\" Then $sFrom &= "\"
If StringRight($sTo, 1) <> "\" Then $sTo &= "\"
If $sFrom = $sTo Then Return SetError(1, 0, StringTrimRight($sTo, 1))
Local $asFrom = StringSplit($sFrom, "\")
Local $asTo = StringSplit($sTo, "\")
If $asFrom[1] <> $asTo[1] Then Return SetError(2, 0, StringTrimRight($sTo, 1))
Local $i = 2
Local $iDiff = 1
While 1
If $asFrom[$i] <> $asTo[$i] Then
$iDiff = $i
ExitLoop
EndIf
$i += 1
WEnd
$i = 1
Local $sRelPath = ""
For $j = 1 To $asTo[0]
If $i >= $iDiff Then
$sRelPath &= "\" & $asTo[$i]
EndIf
$i += 1
Next
$sRelPath = StringTrimLeft($sRelPath, 1)
$i = 1
For $j = 1 To $asFrom[0]
If $i > $iDiff Then
$sRelPath = "..\" & $sRelPath
EndIf
$i += 1
Next
If StringRight($sRelPath, 1) == "\" Then $sRelPath = StringTrimRight($sRelPath, 1)
Return $sRelPath
EndFunc
Func _PathMake($sDrive, $sDir, $sFileName, $sExtension)
If StringLen($sDrive) Then
If Not (StringLeft($sDrive, 2) = "\\") Then $sDrive = StringLeft($sDrive, 1) & ":"
EndIf
If StringLen($sDir) Then
If Not (StringRight($sDir, 1) = "\") And Not (StringRight($sDir, 1) = "/") Then $sDir = $sDir & "\"
Else
$sDir = "\"
EndIf
If StringLen($sDir) Then
If Not (StringLeft($sDir, 1) = "\") And Not (StringLeft($sDir, 1) = "/") Then $sDir = "\" & $sDir
EndIf
If StringLen($sExtension) Then
If Not (StringLeft($sExtension, 1) = ".") Then $sExtension = "." & $sExtension
EndIf
Return $sDrive & $sDir & $sFileName & $sExtension
EndFunc
Func _PathSplit($sFilePath, ByRef $sDrive, ByRef $sDir, ByRef $sFileName, ByRef $sExtension)
Local $aArray = StringRegExp($sFilePath, "^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$", $STR_REGEXPARRAYMATCH)
If @error Then
ReDim $aArray[5]
$aArray[0] = $sFilePath
EndIf
$sDrive = $aArray[1]
If StringLeft($aArray[2], 1) == "/" Then
$sDir = StringRegExpReplace($aArray[2], "\h*[\/\\]+\h*", "\/")
Else
$sDir = StringRegExpReplace($aArray[2], "\h*[\/\\]+\h*", "\\")
EndIf
$aArray[2] = $sDir
$sFileName = $aArray[3]
$sExtension = $aArray[4]
Return $aArray
EndFunc
Func _ReplaceStringInFile($sFilePath, $sSearchString, $sReplaceString, $iCaseSensitive = 0, $iOccurance = 1)
If StringInStr(FileGetAttrib($sFilePath), "R") Then Return SetError(1, 0, -1)
Local $hFileOpen = FileOpen($sFilePath, $FO_READ)
If $hFileOpen = -1 Then Return SetError(2, 0, -1)
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
If $iCaseSensitive = Default Then $iCaseSensitive = 0
If $iOccurance = Default Then $iOccurance = 1
$sFileRead = StringReplace($sFileRead, $sSearchString, $sReplaceString, 1 - $iOccurance, $iCaseSensitive)
Local $iReturn = @extended
If $iReturn Then
Local $iFileEncoding = FileGetEncoding($sFilePath)
$hFileOpen = FileOpen($sFilePath, $iFileEncoding + $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(3, 0, -1)
FileWrite($hFileOpen, $sFileRead)
FileClose($hFileOpen)
EndIf
Return $iReturn
EndFunc
Func _TempFile($sDirectoryName = @TempDir, $sFilePrefix = "~", $sFileExtension = ".tmp", $iRandomLength = 7)
If $iRandomLength = Default Or $iRandomLength <= 0 Then $iRandomLength = 7
If $sDirectoryName = Default Or (Not FileExists($sDirectoryName)) Then $sDirectoryName = @TempDir
If $sFileExtension = Default Then $sFileExtension = ".tmp"
If $sFilePrefix = Default Then $sFilePrefix = "~"
If Not FileExists($sDirectoryName) Then $sDirectoryName = @ScriptDir
$sDirectoryName = StringRegExpReplace($sDirectoryName, "[\\/]+$", "")
$sFileExtension = StringRegExpReplace($sFileExtension, "^\.+", "")
$sFilePrefix = StringRegExpReplace($sFilePrefix, '[\\/:*?"<>|]', "")
Local $sTempName = ""
Do
$sTempName = ""
While StringLen($sTempName) < $iRandomLength
$sTempName &= Chr(Random(97, 122, 1))
WEnd
$sTempName = $sDirectoryName & "\" & $sFilePrefix & $sTempName & "." & $sFileExtension
Until Not FileExists($sTempName)
Return $sTempName
EndFunc
Global Const $TRAY_ITEM_EXIT = 3
Global Const $TRAY_ITEM_PAUSE = 4
Global Const $TRAY_ITEM_FIRST = 7
Global Const $TRAY_CHECKED = 1
Global Const $TRAY_UNCHECKED = 4
Global Const $TRAY_ENABLE = 64
Global Const $TRAY_DISABLE = 128
Global Const $TRAY_FOCUS = 256
Global Const $TRAY_DEFAULT = 512
Global Const $TRAY_EVENT_NONE = 0
Global Const $TRAY_EVENT_SHOWICON = -3
Global Const $TRAY_EVENT_HIDEICON = -4
Global Const $TRAY_EVENT_FLASHICON = -5
Global Const $TRAY_EVENT_NOFLASHICON = -6
Global Const $TRAY_EVENT_PRIMARYDOWN = -7
Global Const $TRAY_EVENT_PRIMARYUP = -8
Global Const $TRAY_EVENT_SECONDARYDOWN = -9
Global Const $TRAY_EVENT_SECONDARYUP = -10
Global Const $TRAY_EVENT_MOUSEOVER = -11
Global Const $TRAY_EVENT_MOUSEOUT = -12
Global Const $TRAY_EVENT_PRIMARYDOUBLE = -13
Global Const $TRAY_EVENT_SECONDARYDOUBLE = -14
Global Const $TIP_ICONNONE = 0
Global Const $TIP_ICONASTERISK = 1
Global Const $TIP_ICONEXCLAMATION = 2
Global Const $TIP_ICONHAND = 3
Global Const $TIP_NOSOUND = 16
Global Const $TRAY_ITEM_NORMAL = 0
Global Const $TRAY_ITEM_RADIO = 1
Global Const $TRAY_CLICK_SHOW = 0
Global Const $TRAY_CLICK_PRIMARYDOWN = 1
Global Const $TRAY_CLICK_PRIMARYUP = 2
Global Const $TRAY_DBLCLICK_PRIMARY= 4
Global Const $TRAY_CLICK_SECONDARYDOWN = 8
Global Const $TRAY_CLICK_SECONDARYUP = 16
Global Const $TRAY_DBLCLICK_SECONDARY= 32
Global Const $TRAY_CLICK_HOVERING= 64
Global Const $TRAY_ICONSTATE_SHOW = 1
Global Const $TRAY_ICONSTATE_HIDE = 2
Global Const $TRAY_ICONSTATE_FLASH = 4
Global Const $TRAY_ICONSTATE_STOPFLASH = 8
Global Const $TRAY_ICONSTATE_RESET = 16
Global Const $MF_UNHILITE = 0x0
Global Const $MF_ENABLED = 0x0
Global Const $MF_UNCHECKED = 0x0
Global Const $MF_STRING = 0x0
Global Const $MF_GRAYED = 0x00000001
Global Const $MF_DISABLED = 0x00000002
Global Const $MF_BITMAP = 0x00000004
Global Const $MF_CHECKED = 0x00000008
Global Const $MF_POPUP = 0x00000010
Global Const $MF_MENUBARBREAK = 0x00000020
Global Const $MF_MENUBREAK = 0x00000040
Global Const $MF_HILITE = 0x00000080
Global Const $MF_OWNERDRAW = 0x00000100
Global Const $MF_USECHECKBITMAPS = 0x00000200
Global Const $MF_BYPOSITION = 0x00000400
Global Const $MF_SEPARATOR = 0x00000800
Global Const $MF_DEFAULT = 0x00001000
Global Const $MF_SYSMENU = 0x00002000
Global Const $MF_HELP = 0x00004000
Global Const $MF_RIGHTJUSTIFY = 0x00004000
Global Const $MF_MOUSESELECT = 0x00008000
Global Const $MFS_GRAYED = 0x00000003
Global Const $MFS_DISABLED = $MFS_GRAYED
Global Const $MFS_CHECKED = $MF_CHECKED
Global Const $MFS_HILITE = $MF_HILITE
Global Const $MFS_ENABLED = $MF_ENABLED
Global Const $MFS_UNCHECKED = $MF_UNCHECKED
Global Const $MFS_UNHILITE = $MF_UNHILITE
Global Const $MFS_DEFAULT = $MF_DEFAULT
Global Const $MFT_STRING = $MF_STRING
Global Const $MFT_BITMAP = $MF_BITMAP
Global Const $MFT_MENUBARBREAK = $MF_MENUBARBREAK
Global Const $MFT_MENUBREAK = $MF_MENUBREAK
Global Const $MFT_OWNERDRAW = $MF_OWNERDRAW
Global Const $MFT_RADIOCHECK = 0x00000200
Global Const $MFT_SEPARATOR = $MF_SEPARATOR
Global Const $MFT_RIGHTORDER = 0x00002000
Global Const $MFT_RIGHTJUSTIFY = $MF_RIGHTJUSTIFY
Global Const $MIIM_STATE = 0x00000001
Global Const $MIIM_ID = 0x00000002
Global Const $MIIM_SUBMENU = 0x00000004
Global Const $MIIM_CHECKMARKS = 0x00000008
Global Const $MIIM_TYPE = 0x00000010
Global Const $MIIM_DATA = 0x00000020
Global Const $MIIM_DATAMASK = 0x0000003F
Global Const $MIIM_STRING = 0x00000040
Global Const $MIIM_BITMAP = 0x00000080
Global Const $MIIM_FTYPE = 0x00000100
Global Const $MIM_MAXHEIGHT = 0x00000001
Global Const $MIM_BACKGROUND = 0x00000002
Global Const $MIM_HELPID = 0x00000004
Global Const $MIM_MENUDATA = 0x00000008
Global Const $MIM_STYLE = 0x00000010
Global Const $MIM_APPLYTOSUBMENUS = 0x80000000
Global Const $MNS_CHECKORBMP = 0x04000000
Global Const $MNS_NOTIFYBYPOS = 0x08000000
Global Const $MNS_AUTODISMISS = 0x10000000
Global Const $MNS_DRAGDROP = 0x20000000
Global Const $MNS_MODELESS = 0x40000000
Global Const $MNS_NOCHECK = 0x80000000
Global Const $TPM_LEFTBUTTON = 0x0
Global Const $TPM_LEFTALIGN = 0x0
Global Const $TPM_TOPALIGN = 0x0
Global Const $TPM_HORIZONTAL = 0x0
Global Const $TPM_RECURSE = 0x00000001
Global Const $TPM_RIGHTBUTTON = 0x00000002
Global Const $TPM_CENTERALIGN = 0x00000004
Global Const $TPM_RIGHTALIGN = 0x00000008
Global Const $TPM_VCENTERALIGN = 0x00000010
Global Const $TPM_BOTTOMALIGN = 0x00000020
Global Const $TPM_VERTICAL = 0x00000040
Global Const $TPM_NONOTIFY = 0x00000080
Global Const $TPM_RETURNCMD = 0x00000100
Global Const $TPM_HORPOSANIMATION = 0x00000400
Global Const $TPM_HORNEGANIMATION = 0x00000800
Global Const $TPM_VERPOSANIMATION = 0x00001000
Global Const $TPM_VERNEGANIMATION = 0x00002000
Global Const $TPM_NOANIMATION = 0x00004000
Global Const $TPM_LAYOUTRTL = 0x00008000
Global Const $TPM_WORKAREA = 0x00010000
Global Const $SC_SIZE = 0xF000
Global Const $SC_MOVE = 0xF010
Global Const $SC_MINIMIZE = 0xF020
Global Const $SC_MAXIMIZE = 0xF030
Global Const $SC_NEXTWINDOW = 0xF040
Global Const $SC_PREVWINDOW = 0xF050
Global Const $SC_CLOSE = 0xF060
Global Const $SC_VSCROLL = 0xF070
Global Const $SC_HSCROLL = 0xF080
Global Const $SC_MOUSEMENU = 0xF090
Global Const $SC_KEYMENU = 0xF100
Global Const $SC_ARRANGE = 0xF110
Global Const $SC_RESTORE = 0xF120
Global Const $SC_TASKLIST = 0xF130
Global Const $SC_SCREENSAVE = 0xF140
Global Const $SC_HOTKEY = 0xF150
Global Const $SC_DEFAULT = 0xF160
Global Const $SC_MONITORPOWER = 0xF170
Global Const $SC_CONTEXTHELP = 0xF180
Global Const $SC_SEPARATOR = 0xF00F
Global Const $OBJID_SYSMENU = 0xFFFFFFFF
Global Const $OBJID_MENU = 0xFFFFFFFD
Global Const $__MENUCONSTANT_OBJID_CLIENT = 0xFFFFFFFC
Global Const $tagMENUBARINFO = "dword Size;" & $tagRECT & ";handle hMenu;handle hWndMenu;bool Focused"
Global Const $tagMDINEXTMENU = "handle hMenuIn;handle hMenuNext;hwnd hWndNext"
Global Const $tagMENUGETOBJECTINFO = "dword Flags;uint Pos;handle hMenu;ptr RIID;ptr Obj"
Global Const $tagTPMPARAMS = "uint Size;" & $tagRECT
Func _GUICtrlMenu_AddMenuItem($hMenu, $sText, $iCmdID = 0, $hSubMenu = 0)
Local $iIndex = _GUICtrlMenu_GetItemCount($hMenu)
Local $tMenu = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tMenu, "Size", DllStructGetSize($tMenu))
DllStructSetData($tMenu, "ID", $iCmdID)
DllStructSetData($tMenu, "SubMenu", $hSubMenu)
If $sText = "" Then
DllStructSetData($tMenu, "Mask", $MIIM_FTYPE)
DllStructSetData($tMenu, "Type", $MFT_SEPARATOR)
Else
DllStructSetData($tMenu, "Mask", BitOR($MIIM_ID, $MIIM_STRING, $MIIM_SUBMENU))
DllStructSetData($tMenu, "Type", $MFT_STRING)
Local $tText = DllStructCreate("wchar Text[" & StringLen($sText) + 1 & "]")
DllStructSetData($tText, "Text", $sText)
DllStructSetData($tMenu, "TypeData", DllStructGetPtr($tText))
EndIf
Local $aResult = DllCall("user32.dll", "bool", "InsertMenuItemW", "handle", $hMenu, "uint", $iIndex, "bool", True, "struct*", $tMenu)
If @error Then Return SetError(@error, @extended, -1)
Return SetExtended($aResult[0], $iIndex)
EndFunc
Func _GUICtrlMenu_AppendMenu($hMenu, $iFlags, $iNewItem, $vNewItem)
Local $sType = "wstr"
If BitAND($iFlags, $MF_BITMAP) Then $sType = "handle"
If BitAND($iFlags, $MF_OWNERDRAW) Then $sType = "ulong_ptr"
Local $aResult = DllCall("user32.dll", "bool", "AppendMenuW", "handle", $hMenu, "uint", $iFlags, "uint_ptr", $iNewItem, $sType, $vNewItem)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] = 0 Then Return SetError(10, 0, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _GUICtrlMenu_CalculatePopupWindowPosition($iX, $iY, $iWidth, $iHeight, $iFlags = 0, $tExclude = 0)
Local $tAnchor = DllStructCreate($tagPOINT)
DllStructSetData($tAnchor, 1, $iX)
DllStructSetData($tAnchor, 2, $iY)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, $iWidth)
DllStructSetData($tSIZE, 2, $iHeight)
Local $tPos = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'CalculatePopupWindowPosition', 'struct*', $tAnchor, 'struct*', $tSIZE,  'uint', $iFlags, 'struct*', $tExclude, 'struct*', $tPos)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPos
EndFunc
Func _GUICtrlMenu_CheckMenuItem($hMenu, $iItem, $bCheck = True, $bByPos = True)
Local $iByPos = 0
If $bCheck Then $iByPos = BitOR($iByPos, $MF_CHECKED)
If $bByPos Then $iByPos = BitOR($iByPos, $MF_BYPOSITION)
Local $aResult = DllCall("user32.dll", "dword", "CheckMenuItem", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_CheckRadioItem($hMenu, $iFirst, $iLast, $iCheck, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aResult = DllCall("user32.dll", "bool", "CheckMenuRadioItem", "handle", $hMenu, "uint", $iFirst, "uint", $iLast, "uint", $iCheck, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_CreateMenu($iStyle = $MNS_CHECKORBMP)
Local $aResult = DllCall("user32.dll", "handle", "CreateMenu")
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] = 0 Then Return SetError(10, 0, 0)
_GUICtrlMenu_SetMenuStyle($aResult[0], $iStyle)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_CreatePopup($iStyle = $MNS_CHECKORBMP)
Local $aResult = DllCall("user32.dll", "handle", "CreatePopupMenu")
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] = 0 Then Return SetError(10, 0, 0)
_GUICtrlMenu_SetMenuStyle($aResult[0], $iStyle)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_DeleteMenu($hMenu, $iItem, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aResult = DllCall("user32.dll", "bool", "DeleteMenu", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] = 0 Then Return SetError(10, 0, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _GUICtrlMenu_DestroyMenu($hMenu)
Local $aResult = DllCall("user32.dll", "bool", "DestroyMenu", "handle", $hMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_DrawMenuBar($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DrawMenuBar", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_EnableMenuItem($hMenu, $iItem, $iState = 0, $bByPos = True)
Local $iByPos = $iState
If $bByPos Then $iByPos = BitOR($iByPos, $MF_BYPOSITION)
Local $aResult = DllCall("user32.dll", "bool", "EnableMenuItem", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] = 0 Then Return SetError(10, 0, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _GUICtrlMenu_EndMenu()
Local $aResult = DllCall("user32.dll", "bool", "EndMenu")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_FindItem($hMenu, $sText, $bInStr = False, $iStart = 0)
Local $sMenu
For $iI = $iStart To _GUICtrlMenu_GetItemCount($hMenu)
$sMenu = StringReplace(_GUICtrlMenu_GetItemText($hMenu, $iI), "&", "")
Switch $bInStr
Case False
If $sMenu = $sText Then Return $iI
Case True
If StringInStr($sMenu, $sText) Then Return $iI
EndSwitch
Next
Return -1
EndFunc
Func _GUICtrlMenu_FindParent($hMenu)
Local $hList = _WinAPI_EnumWindowsTop()
For $iI = 1 To $hList[0][0]
If _GUICtrlMenu_GetMenu($hList[$iI][0]) = $hMenu Then Return $hList[$iI][0]
Next
EndFunc
Func _GUICtrlMenu_GetItemBmp($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "BmpItem")
EndFunc
Func _GUICtrlMenu_GetItemBmpChecked($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "BmpChecked")
EndFunc
Func _GUICtrlMenu_GetItemBmpUnchecked($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "BmpUnchecked")
EndFunc
Func _GUICtrlMenu_GetItemChecked($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_CHECKED) <> 0
EndFunc
Func _GUICtrlMenu_GetItemCount($hMenu)
Local $aResult = DllCall("user32.dll", "int", "GetMenuItemCount", "handle", $hMenu)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetItemData($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "ItemData")
EndFunc
Func _GUICtrlMenu_GetItemDefault($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_DEFAULT) <> 0
EndFunc
Func _GUICtrlMenu_GetItemDisabled($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_DISABLED) <> 0
EndFunc
Func _GUICtrlMenu_GetItemEnabled($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_DISABLED) = 0
EndFunc
Func _GUICtrlMenu_GetItemGrayed($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_GRAYED) <> 0
EndFunc
Func _GUICtrlMenu_GetItemHighlighted($hMenu, $iItem, $bByPos = True)
Return BitAND(_GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos), $MF_HILITE) <> 0
EndFunc
Func _GUICtrlMenu_GetItemID($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "ID")
EndFunc
Func _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_DATAMASK)
Local $aResult = DllCall("user32.dll", "bool", "GetMenuItemInfo", "handle", $hMenu, "uint", $iItem, "bool", $bByPos, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tInfo)
EndFunc
Func _GUICtrlMenu_GetItemRect($hWnd, $hMenu, $iItem)
Local $tRECT = _GUICtrlMenu_GetItemRectEx($hWnd, $hMenu, $iItem)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlMenu_GetItemRectEx($hWnd, $hMenu, $iItem)
Local $tRECT = DllStructCreate($tagRECT)
Local $aResult = DllCall("user32.dll", "bool", "GetMenuItemRect", "hwnd", $hWnd, "handle", $hMenu, "uint", $iItem, "struct*", $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tRECT)
EndFunc
Func _GUICtrlMenu_GetItemState($hMenu, $iItem, $bByPos = True)
Local $iRet = 0
Local $iState = _GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos)
If BitAND($iState, $MFS_CHECKED) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iState, $MFS_DEFAULT) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iState, $MFS_DISABLED) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iState, $MFS_GRAYED) <> 0 Then $iRet = BitOR($iRet, 8)
If BitAND($iState, $MFS_HILITE) <> 0 Then $iRet = BitOR($iRet, 16)
Return $iRet
EndFunc
Func _GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "State")
EndFunc
Func _GUICtrlMenu_GetItemSubMenu($hMenu, $iItem)
Local $aResult = DllCall("user32.dll", "handle", "GetSubMenu", "handle", $hMenu, "int", $iItem)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetItemText($hMenu, $iItem, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aResult = DllCall("user32.dll", "int", "GetMenuStringW", "handle", $hMenu, "uint", $iItem, "wstr", "", "int", 4096, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $aResult[3])
EndFunc
Func _GUICtrlMenu_GetItemType($hMenu, $iItem, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
Return DllStructGetData($tInfo, "Type")
EndFunc
Func _GUICtrlMenu_GetMenu($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetMenu", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetMenuBackground($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "hBack")
EndFunc
Func _GUICtrlMenu_GetMenuBarInfo($hWnd, $iItem = 0, $iObject = 1)
Local $aObject[3] = [$__MENUCONSTANT_OBJID_CLIENT, $OBJID_MENU, $OBJID_SYSMENU]
Local $tInfo = DllStructCreate($tagMENUBARINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
Local $aResult = DllCall("user32.dll", "bool", "GetMenuBarInfo", "hwnd", $hWnd, "long", $aObject[$iObject], "long", $iItem, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, 0)
Local $aInfo[8]
$aInfo[0] = DllStructGetData($tInfo, "Left")
$aInfo[1] = DllStructGetData($tInfo, "Top")
$aInfo[2] = DllStructGetData($tInfo, "Right")
$aInfo[3] = DllStructGetData($tInfo, "Bottom")
$aInfo[4] = DllStructGetData($tInfo, "hMenu")
$aInfo[5] = DllStructGetData($tInfo, "hWndMenu")
$aInfo[6] = BitAND(DllStructGetData($tInfo, "Focused"), 1) <> 0
$aInfo[7] = BitAND(DllStructGetData($tInfo, "Focused"), 2) <> 0
Return SetExtended($aResult[0], $aInfo)
EndFunc
Func _GUICtrlMenu_GetMenuContextHelpID($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "ContextHelpID")
EndFunc
Func _GUICtrlMenu_GetMenuData($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "MenuData")
EndFunc
Func _GUICtrlMenu_GetMenuDefaultItem($hMenu, $bByPos = True, $iFlags = 0)
Local $aResult = DllCall("user32.dll", "INT", "GetMenuDefaultItem", "handle", $hMenu, "uint", $bByPos, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_GetMenuHeight($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "YMax")
EndFunc
Func _GUICtrlMenu_GetMenuInfo($hMenu)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", BitOR($MIM_BACKGROUND, $MIM_HELPID, $MIM_MAXHEIGHT, $MIM_MENUDATA, $MIM_STYLE))
Local $aResult = DllCall("user32.dll", "bool", "GetMenuInfo", "handle", $hMenu, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tInfo)
EndFunc
Func _GUICtrlMenu_GetMenuStyle($hMenu)
Local $tInfo = _GUICtrlMenu_GetMenuInfo($hMenu)
Return DllStructGetData($tInfo, "Style")
EndFunc
Func _GUICtrlMenu_GetSystemMenu($hWnd, $bRevert = False)
Local $aResult = DllCall("user32.dll", "hwnd", "GetSystemMenu", "hwnd", $hWnd, "int", $bRevert)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_InsertMenuItem($hMenu, $iIndex, $sText, $iCmdID = 0, $hSubMenu = 0)
Local $tMenu = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tMenu, "Size", DllStructGetSize($tMenu))
DllStructSetData($tMenu, "ID", $iCmdID)
DllStructSetData($tMenu, "SubMenu", $hSubMenu)
If $sText = "" Then
DllStructSetData($tMenu, "Mask", $MIIM_FTYPE)
DllStructSetData($tMenu, "Type", $MFT_SEPARATOR)
Else
DllStructSetData($tMenu, "Mask", BitOR($MIIM_ID, $MIIM_STRING, $MIIM_SUBMENU))
DllStructSetData($tMenu, "Type", $MFT_STRING)
Local $tText = DllStructCreate("wchar Text[" & StringLen($sText) + 1 & "]")
DllStructSetData($tText, "Text", $sText)
DllStructSetData($tMenu, "TypeData", DllStructGetPtr($tText))
EndIf
Local $aResult = DllCall("user32.dll", "bool", "InsertMenuItemW", "handle", $hMenu, "uint", $iIndex, "bool", True, "struct*", $tMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_InsertMenuItemEx($hMenu, $iIndex, ByRef $tMenu, $bByPos = True)
Local $aResult = DllCall("user32.dll", "bool", "InsertMenuItemW", "handle", $hMenu, "uint", $iIndex, "bool", $bByPos, "struct*", $tMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_IsMenu($hMenu)
Local $aResult = DllCall("user32.dll", "bool", "IsMenu", "handle", $hMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_LoadMenu($hInst, $sMenuName)
Local $aResult = DllCall("user32.dll", "handle", "LoadMenuW", "handle", $hInst, "wstr", $sMenuName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_MapAccelerator($hMenu, $sAccelKey)
Local $sText
Local $iCount = _GUICtrlMenu_GetItemCount($hMenu)
For $iI = 0 To $iCount - 1
$sText = _GUICtrlMenu_GetItemText($hMenu, $iI)
If StringInStr($sText, "&" & $sAccelKey) > 0 Then Return $iI
Next
Return -1
EndFunc
Func _GUICtrlMenu_MenuItemFromPoint($hWnd, $hMenu, $iX = -1, $iY = -1)
If $iX = -1 Then $iX = _WinAPI_GetMousePosX()
If $iY = -1 Then $iY = _WinAPI_GetMousePosY()
Local $aResult = DllCall("user32.dll", "int", "MenuItemFromPoint", "hwnd", $hWnd, "handle", $hMenu, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_RemoveMenu($hMenu, $iItem, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aResult = DllCall("user32.dll", "bool", "RemoveMenu", "handle", $hMenu, "uint", $iItem, "uint", $iByPos)
If @error Then Return SetError(@error, @extended, False)
If $aResult[0] = 0 Then Return SetError(10, 0, False)
_GUICtrlMenu_DrawMenuBar(_GUICtrlMenu_FindParent($hMenu))
Return True
EndFunc
Func _GUICtrlMenu_SetItemBitmaps($hMenu, $iItem, $hChecked, $hUnChecked, $bByPos = True)
Local $iByPos = 0
If $bByPos Then $iByPos = $MF_BYPOSITION
Local $aResult = DllCall("user32.dll", "bool", "SetMenuItemBitmaps", "handle", $hMenu, "uint", $iItem, "uint", $iByPos, "handle", $hUnChecked, "handle", $hChecked)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_SetItemBmp($hMenu, $iItem, $hBitmap, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_BITMAP)
DllStructSetData($tInfo, "BmpItem", $hBitmap)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemBmpChecked($hMenu, $iItem, $hBitmap, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
DllStructSetData($tInfo, "Mask", $MIIM_CHECKMARKS)
DllStructSetData($tInfo, "BmpChecked", $hBitmap)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemBmpUnchecked($hMenu, $iItem, $hBitmap, $bByPos = True)
Local $tInfo = _GUICtrlMenu_GetItemInfo($hMenu, $iItem, $bByPos)
DllStructSetData($tInfo, "Mask", $MIIM_CHECKMARKS)
DllStructSetData($tInfo, "BmpUnchecked", $hBitmap)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemChecked($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, $MFS_CHECKED, $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemData($hMenu, $iItem, $iData, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_DATA)
DllStructSetData($tInfo, "ItemData", $iData)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemDefault($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, $MFS_DEFAULT, $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemDisabled($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, BitOR($MFS_DISABLED, $MFS_GRAYED), $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemEnabled($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, BitOR($MFS_DISABLED, $MFS_GRAYED), Not $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemGrayed($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, $MFS_GRAYED, $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemHighlighted($hMenu, $iItem, $bState = True, $bByPos = True)
Return _GUICtrlMenu_SetItemState($hMenu, $iItem, $MFS_HILITE, $bState, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemID($hMenu, $iItem, $iID, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_ID)
DllStructSetData($tInfo, "ID", $iID)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemInfo($hMenu, $iItem, ByRef $tInfo, $bByPos = True)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
Local $aResult = DllCall("user32.dll", "bool", "SetMenuItemInfoW", "handle", $hMenu, "uint", $iItem, "bool", $bByPos, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_SetItemState($hMenu, $iItem, $iState, $bState = True, $bByPos = True)
Local $iFlag = _GUICtrlMenu_GetItemStateEx($hMenu, $iItem, $bByPos)
If $bState Then
$iState = BitOR($iFlag, $iState)
Else
$iState = BitAND($iFlag, BitNOT($iState))
EndIf
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_STATE)
DllStructSetData($tInfo, "State", $iState)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemSubMenu($hMenu, $iItem, $hSubMenu, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_SUBMENU)
DllStructSetData($tInfo, "SubMenu", $hSubMenu)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemText($hMenu, $iItem, $sText, $bByPos = True)
Local $tBuffer = DllStructCreate("wchar Text[" & StringLen($sText) + 1 & "]")
DllStructSetData($tBuffer, "Text", $sText)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_STRING)
DllStructSetData($tInfo, "TypeData", DllStructGetPtr($tBuffer))
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetItemType($hMenu, $iItem, $iType, $bByPos = True)
Local $tInfo = DllStructCreate($tagMENUITEMINFO)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
DllStructSetData($tInfo, "Mask", $MIIM_FTYPE)
DllStructSetData($tInfo, "Type", $iType)
Return _GUICtrlMenu_SetItemInfo($hMenu, $iItem, $tInfo, $bByPos)
EndFunc
Func _GUICtrlMenu_SetMenu($hWnd, $hMenu)
Local $aResult = DllCall("user32.dll", "bool", "SetMenu", "hwnd", $hWnd, "handle", $hMenu)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_SetMenuBackground($hMenu, $hBrush)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_BACKGROUND)
DllStructSetData($tInfo, "hBack", $hBrush)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_SetMenuContextHelpID($hMenu, $iHelpID)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_HELPID)
DllStructSetData($tInfo, "ContextHelpID", $iHelpID)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_SetMenuData($hMenu, $iData)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_MENUDATA)
DllStructSetData($tInfo, "MenuData", $iData)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_SetMenuDefaultItem($hMenu, $iItem, $bByPos = True)
Local $aResult = DllCall("user32.dll", "bool", "SetMenuDefaultItem", "handle", $hMenu, "uint", $iItem, "uint", $bByPos)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_SetMenuHeight($hMenu, $iHeight)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_MAXHEIGHT)
DllStructSetData($tInfo, "YMax", $iHeight)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_SetMenuInfo($hMenu, ByRef $tInfo)
DllStructSetData($tInfo, "Size", DllStructGetSize($tInfo))
Local $aResult = DllCall("user32.dll", "bool", "SetMenuInfo", "handle", $hMenu, "struct*", $tInfo)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlMenu_SetMenuStyle($hMenu, $iStyle)
Local $tInfo = DllStructCreate($tagMENUINFO)
DllStructSetData($tInfo, "Mask", $MIM_STYLE)
DllStructSetData($tInfo, "Style", $iStyle)
Return _GUICtrlMenu_SetMenuInfo($hMenu, $tInfo)
EndFunc
Func _GUICtrlMenu_TrackPopupMenu($hMenu, $hWnd, $iX = -1, $iY = -1, $iAlignX = 1, $iAlignY = 1, $iNotify = 0, $iButtons = 0)
If $iX = -1 Then $iX = _WinAPI_GetMousePosX()
If $iY = -1 Then $iY = _WinAPI_GetMousePosY()
Local $iFlags = 0
Switch $iAlignX
Case 1
$iFlags = BitOR($iFlags, $TPM_LEFTALIGN)
Case 2
$iFlags = BitOR($iFlags, $TPM_RIGHTALIGN)
Case Else
$iFlags = BitOR($iFlags, $TPM_CENTERALIGN)
EndSwitch
Switch $iAlignY
Case 1
$iFlags = BitOR($iFlags, $TPM_TOPALIGN)
Case 2
$iFlags = BitOR($iFlags, $TPM_VCENTERALIGN)
Case Else
$iFlags = BitOR($iFlags, $TPM_BOTTOMALIGN)
EndSwitch
If BitAND($iNotify, 1) <> 0 Then $iFlags = BitOR($iFlags, $TPM_NONOTIFY)
If BitAND($iNotify, 2) <> 0 Then $iFlags = BitOR($iFlags, $TPM_RETURNCMD)
Switch $iButtons
Case 1
$iFlags = BitOR($iFlags, $TPM_RIGHTBUTTON)
Case Else
$iFlags = BitOR($iFlags, $TPM_LEFTBUTTON)
EndSwitch
Local $aResult = DllCall("user32.dll", "bool", "TrackPopupMenu", "handle", $hMenu, "uint", $iFlags, "int", $iX, "int", $iY, "int", 0, "hwnd", $hWnd, "ptr", 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Global Const $CF_TEXT = 1
Global Const $CF_BITMAP = 2
Global Const $CF_METAFILEPICT = 3
Global Const $CF_SYLK = 4
Global Const $CF_DIF = 5
Global Const $CF_TIFF = 6
Global Const $CF_OEMTEXT = 7
Global Const $CF_DIB = 8
Global Const $CF_PALETTE = 9
Global Const $CF_PENDATA = 10
Global Const $CF_RIFF = 11
Global Const $CF_WAVE = 12
Global Const $CF_UNICODETEXT = 13
Global Const $CF_ENHMETAFILE = 14
Global Const $CF_HDROP = 15
Global Const $CF_LOCALE = 16
Global Const $CF_DIBV5 = 17
Global Const $CF_OWNERDISPLAY = 0x0080
Global Const $CF_DSPTEXT = 0x0081
Global Const $CF_DSPBITMAP = 0x0082
Global Const $CF_DSPMETAFILEPICT = 0x0083
Global Const $CF_DSPENHMETAFILE = 0x008E
Global Const $CF_PRIVATEFIRST = 0x0200
Global Const $CF_PRIVATELAST = 0x02FF
Global Const $CF_GDIOBJFIRST = 0x0300
Global Const $CF_GDIOBJLAST = 0x03FF
Func _ClipBoard_ChangeChain($hRemove, $hNewNext)
DllCall("user32.dll", "bool", "ChangeClipboardChain", "hwnd", $hRemove, "hwnd", $hNewNext)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _ClipBoard_Close()
Local $aResult = DllCall("user32.dll", "bool", "CloseClipboard")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _ClipBoard_CountFormats()
Local $aResult = DllCall("user32.dll", "int", "CountClipboardFormats")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_Empty()
Local $aResult = DllCall("user32.dll", "bool", "EmptyClipboard")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _ClipBoard_EnumFormats($iFormat)
Local $aResult = DllCall("user32.dll", "uint", "EnumClipboardFormats", "uint", $iFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_FormatStr($iFormat)
Local $aFormat[18] = [17, "Text", "Bitmap", "Metafile Picture", "SYLK", "DIF", "TIFF", "OEM Text", "DIB", "Palette",  "Pen Data", "RIFF", "WAVE", "Unicode Text", "Enhanced Metafile", "HDROP", "Locale", "DIB V5"]
If $iFormat >= 1 And $iFormat <= 17 Then Return $aFormat[$iFormat]
Switch $iFormat
Case $CF_OWNERDISPLAY
Return "Owner Display"
Case $CF_DSPTEXT
Return "Private Text"
Case $CF_DSPBITMAP
Return "Private Bitmap"
Case $CF_DSPMETAFILEPICT
Return "Private Metafile Picture"
Case $CF_DSPENHMETAFILE
Return "Private Enhanced Metafile"
Case Else
Return _ClipBoard_GetFormatName($iFormat)
EndSwitch
EndFunc
Func _ClipBoard_GetData($iFormat = 1)
If Not _ClipBoard_IsFormatAvailable($iFormat) Then Return SetError(-1, 0, 0)
If Not _ClipBoard_Open(0) Then Return SetError(-2, 0, 0)
Local $hMemory = _ClipBoard_GetDataEx($iFormat)
If $hMemory = 0 Then
_ClipBoard_Close()
Return SetError(-3, 0, 0)
EndIf
Local $pMemoryBlock = _MemGlobalLock($hMemory)
If $pMemoryBlock = 0 Then
_ClipBoard_Close()
Return SetError(-4, 0, 0)
EndIf
Local $iDataSize = _MemGlobalSize($hMemory)
If $iDataSize = 0 Then
_MemGlobalUnlock($hMemory)
_ClipBoard_Close()
Return SetError(-5, 0, "")
EndIf
Local $tData
Switch $iFormat
Case $CF_TEXT, $CF_OEMTEXT
$tData = DllStructCreate("char[" & $iDataSize & "]", $pMemoryBlock)
Case $CF_UNICODETEXT
$iDataSize = Round($iDataSize / 2)
$tData = DllStructCreate("wchar[" & $iDataSize & "]", $pMemoryBlock)
Case Else
$tData = DllStructCreate("byte[" & $iDataSize & "]", $pMemoryBlock)
EndSwitch
Local $vReturn = DllStructGetData($tData, 1)
_MemGlobalUnlock($hMemory)
_ClipBoard_Close()
Return SetExtended($iDataSize, $vReturn)
EndFunc
Func _ClipBoard_GetDataEx($iFormat = 1)
Local $aResult = DllCall("user32.dll", "handle", "GetClipboardData", "uint", $iFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetFormatName($iFormat)
Local $aResult = DllCall("user32.dll", "int", "GetClipboardFormatNameW", "uint", $iFormat, "wstr", "", "int", 4096)
If @error Then Return SetError(@error, @extended, "")
Return $aResult[2]
EndFunc
Func _ClipBoard_GetOpenWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetOpenClipboardWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetOwner()
Local $aResult = DllCall("user32.dll", "hwnd", "GetClipboardOwner")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetPriorityFormat($aFormats)
If Not IsArray($aFormats) Then Return SetError(-1, 0, 0)
If $aFormats[0] <= 0 Then Return SetError(-2, 0, 0)
Local $tData = DllStructCreate("uint[" & $aFormats[0] & "]")
For $iI = 1 To $aFormats[0]
DllStructSetData($tData, 1, $aFormats[$iI], $iI)
Next
Local $aResult = DllCall("user32.dll", "int", "GetPriorityClipboardFormat", "struct*", $tData, "int", $aFormats[0])
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetSequenceNumber()
Local $aResult = DllCall("user32.dll", "dword", "GetClipboardSequenceNumber")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_GetViewer()
Local $aResult = DllCall("user32.dll", "hwnd", "GetClipboardViewer")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_IsFormatAvailable($iFormat)
Local $aResult = DllCall("user32.dll", "bool", "IsClipboardFormatAvailable", "uint", $iFormat)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _ClipBoard_Open($hOwner)
Local $aResult = DllCall("user32.dll", "bool", "OpenClipboard", "hwnd", $hOwner)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _ClipBoard_RegisterFormat($sFormat)
Local $aResult = DllCall("user32.dll", "uint", "RegisterClipboardFormatW", "wstr", $sFormat)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_SetData($vData, $iFormat = 1)
Local $tData, $hLock, $hMemory, $iSize
If IsNumber($vData) And $vData = 0 Then
$hMemory = $vData
Else
If IsBinary($vData) Then
$iSize = BinaryLen($vData)
ElseIf IsString($vData) Then
$iSize = StringLen($vData)
Else
Return SetError(2, 0, 0)
EndIf
$iSize += 1
If $iFormat = $CF_UNICODETEXT Then
$hMemory = _MemGlobalAlloc($iSize * 2, $GHND)
Else
$hMemory = _MemGlobalAlloc($iSize, $GHND)
EndIf
If $hMemory = 0 Then Return SetError(-1, 0, 0)
$hLock = _MemGlobalLock($hMemory)
If $hLock = 0 Then Return SetError(-2, 0, 0)
Switch $iFormat
Case $CF_TEXT, $CF_OEMTEXT
$tData = DllStructCreate("char[" & $iSize & "]", $hLock)
Case $CF_UNICODETEXT
$tData = DllStructCreate("wchar[" & $iSize & "]", $hLock)
Case Else
$tData = DllStructCreate("byte[" & $iSize & "]", $hLock)
EndSwitch
DllStructSetData($tData, 1, $vData)
_MemGlobalUnlock($hMemory)
EndIf
If Not _ClipBoard_Open(0) Then Return SetError(-5, 0, 0)
If Not _ClipBoard_Empty() Then
_ClipBoard_Close()
Return SetError(-6, 0, 0)
EndIf
If Not _ClipBoard_SetDataEx($hMemory, $iFormat) Then
_ClipBoard_Close()
Return SetError(-7, 0, 0)
EndIf
_ClipBoard_Close()
Return $hMemory
EndFunc
Func _ClipBoard_SetDataEx(ByRef $hMemory, $iFormat = 1)
Local $aResult = DllCall("user32.dll", "handle", "SetClipboardData", "uint", $iFormat, "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _ClipBoard_SetViewer($hViewer)
Local $aResult = DllCall("user32.dll", "hwnd", "SetClipboardViewer", "hwnd", $hViewer)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Global Const $__RICHEDITCONSTANT_WM_USER = 0x400
Global Const $EM_AUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 91
Global Const $EM_CANPASTE = $__RICHEDITCONSTANT_WM_USER + 50
Global Const $EM_CANREDO = $__RICHEDITCONSTANT_WM_USER + 85
Global Const $EM_DISPLAYBAND = $__RICHEDITCONSTANT_WM_USER + 51
Global Const $EM_EXGETSEL = $__RICHEDITCONSTANT_WM_USER + 52
Global Const $EM_EXLIMITTEXT = $__RICHEDITCONSTANT_WM_USER + 53
Global Const $EM_EXLINEFROMCHAR = $__RICHEDITCONSTANT_WM_USER + 54
Global Const $EM_EXSETSEL = $__RICHEDITCONSTANT_WM_USER + 55
Global Const $EM_FINDTEXT = $__RICHEDITCONSTANT_WM_USER + 56
Global Const $EM_FINDTEXTEX = $__RICHEDITCONSTANT_WM_USER + 79
Global Const $EM_FINDTEXTEXW = $__RICHEDITCONSTANT_WM_USER + 124
Global Const $EM_FINDTEXTW = $__RICHEDITCONSTANT_WM_USER + 123
Global Const $EM_FINDWORDBREAK = $__RICHEDITCONSTANT_WM_USER + 76
Global Const $EM_FORMATRANGE = $__RICHEDITCONSTANT_WM_USER + 57
Global Const $EM_GETAUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 92
Global Const $EM_GETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 201
Global Const $EM_GETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 58
Global Const $EM_GETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 205
Global Const $EM_GETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 59
Global Const $EM_GETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 105
Global Const $EM_GETIMECOMPMODE = $__RICHEDITCONSTANT_WM_USER + 122
Global Const $EM_GETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 127
Global Const $EM_GETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 107
Global Const $EM_GETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 121
Global Const $EM_GETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 78
Global Const $EM_GETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 61
Global Const $EM_GETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 101
Global Const $EM_GETREDONAME = $__RICHEDITCONSTANT_WM_USER + 87
Global Const $EM_GETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 221
Global Const $EM_GETSELTEXT = $__RICHEDITCONSTANT_WM_USER + 62
Global Const $EM_GETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 94
Global Const $EM_GETTEXTLENGTHEX = $__RICHEDITCONSTANT_WM_USER + 95
Global Const $EM_GETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 90
Global Const $EM_GETTEXTRANGE = $__RICHEDITCONSTANT_WM_USER + 75
Global Const $EM_GETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 203
Global Const $EM_GETUNDONAME = $__RICHEDITCONSTANT_WM_USER + 86
Global Const $EM_GETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 80
Global Const $EM_GETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 103
Global Const $EM_GETZOOM = $__RICHEDITCONSTANT_WM_USER + 224
Global Const $EM_HIDESELECTION = $__RICHEDITCONSTANT_WM_USER + 63
Global Const $EM_PASTESPECIAL = $__RICHEDITCONSTANT_WM_USER + 64
Global Const $EM_RECONVERSION = $__RICHEDITCONSTANT_WM_USER + 125
Global Const $EM_REDO = $__RICHEDITCONSTANT_WM_USER + 84
Global Const $EM_REQUESTRESIZE = $__RICHEDITCONSTANT_WM_USER + 65
Global Const $EM_SELECTIONTYPE = $__RICHEDITCONSTANT_WM_USER + 66
Global Const $EM_SETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 200
Global Const $EM_SETBKGNDCOLOR = $__RICHEDITCONSTANT_WM_USER + 67
Global Const $EM_SETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 68
Global Const $EM_SETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 204
Global Const $EM_SETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 69
Global Const $EM_SETFONTSIZE = $__RICHEDITCONSTANT_WM_USER + 223
Global Const $EM_SETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 104
Global Const $EM_SETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 126
Global Const $EM_SETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 106
Global Const $EM_SETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 120
Global Const $EM_SETOLECALLBACK = $__RICHEDITCONSTANT_WM_USER + 70
Global Const $EM_SETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 77
Global Const $EM_SETPALETTE = $__RICHEDITCONSTANT_WM_USER + 93
Global Const $EM_SETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 71
Global Const $EM_SETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 100
Global Const $EM_SETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 222
Global Const $EM_SETTARGETDEVICE = $__RICHEDITCONSTANT_WM_USER + 72
Global Const $EM_SETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 97
Global Const $EM_SETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 89
Global Const $EM_SETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 202
Global Const $EM_SETUNDOLIMIT = $__RICHEDITCONSTANT_WM_USER + 82
Global Const $EM_SETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 81
Global Const $EM_SETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 102
Global Const $EM_SETZOOM = $__RICHEDITCONSTANT_WM_USER + 225
Global Const $EM_SHOWSCROLLBAR = $__RICHEDITCONSTANT_WM_USER + 96
Global Const $EM_STOPGROUPTYPING = $__RICHEDITCONSTANT_WM_USER + 88
Global Const $EM_STREAMIN = $__RICHEDITCONSTANT_WM_USER + 73
Global Const $EM_STREAMOUT = $__RICHEDITCONSTANT_WM_USER + 74
Global Const $EN_ALIGNLTR = 0X710
Global Const $EN_ALIGNRTL = 0X711
Global Const $EN_CORRECTTEXT = 0X705
Global Const $EN_DRAGDROPDONE = 0X70c
Global Const $EN_DROPFILES = 0X703
Global Const $EN_IMECHANGE = 0X707
Global Const $EN_LINK = 0X70b
Global Const $EN_MSGFILTER = 0X700
Global Const $EN_OBJECTPOSITIONS = 0X70a
Global Const $EN_OLEOPFAILED = 0X709
Global Const $EN_PROTECTED = 0X704
Global Const $EN_REQUESTRESIZE = 0X701
Global Const $EN_SAVECLIPBOARD = 0X708
Global Const $EN_SELCHANGE = 0X702
Global Const $EN_STOPNOUNDO = 0X706
Global Const $ENM_CHANGE = 0x1
Global Const $ENM_CORRECTTEXT = 0x400000
Global Const $ENM_DRAGDROPDONE = 0x10
Global Const $ENM_DROPFILES = 0x100000
Global Const $ENM_IMECHANGE = 0x800000
Global Const $ENM_KEYEVENTS = 0x10000
Global Const $ENM_LINK = 0x4000000
Global Const $ENM_MOUSEEVENTS = 0x20000
Global Const $ENM_OBJECTPOSITIONS = 0x2000000
Global Const $ENM_PROTECTED = 0x200000
Global Const $ENM_REQUESTRESIZE = 0x40000
Global Const $ENM_SCROLL = 0x4
Global Const $ENM_SCROLLEVENTS = 0x8
Global Const $ENM_SELCHANGE = 0x80000
Global Const $ENM_UPDATE = 0x2
Global Const $BOM_DEFPARADIR = 0x1
Global Const $BOM_PLAINTEXT = 0x2
Global Const $BOM_NEUTRALOVERRIDE = 0x4
Global Const $BOM_CONTEXTREADING = 0x8
Global Const $BOM_CONTEXTALIGNMENT = 0x10
Global Const $BOM_LEGACYBIDICLASS = 0x0040
Global Const $BOE_RTLDIR = 0x1
Global Const $BOE_PLAINTEXT = 0x2
Global Const $BOE_NEUTRALOVERRIDE = 0x4
Global Const $BOE_CONTEXTREADING = 0x8
Global Const $BOE_CONTEXTALIGNMENT = 0x10
Global Const $BOE_LEGACYBIDICLASS = 0x0040
Global Const $ST_DEFAULT = 0
Global Const $ST_KEEPUNDO = 1
Global Const $ST_SELECTION = 2
Global Const $GT_DEFAULT = 0
Global Const $GT_SELECTION = 2
Global Const $GT_USECRLF = 1
Global Const $GTL_CLOSE = 4
Global Const $GTL_DEFAULT = 0
Global Const $GTL_NUMBYTES = 16
Global Const $GTL_NUMCHARS = 8
Global Const $GTL_PRECISE = 2
Global Const $GTL_USECRLF = 1
Global Const $CFU_UNDERLINENONE = 0
Global Const $CFU_UNDERLINE = 1
Global Const $CFU_UNDERLINEWORD = 2
Global Const $CFU_UNDERLINEDOUBLE = 3
Global Const $CFU_UNDERLINEDOTTED = 4
Global Const $CP_ACP = 0
Global Const $CP_UNICODE = 1200
Global Const $CFE_SUBSCRIPT = 0x00010000
Global Const $CFE_SUPERSCRIPT = 0x00020000
Global Const $CFM_ALLCAPS = 0x80
Global Const $CFM_ANIMATION = 0x40000
Global Const $CFM_BACKCOLOR = 0x4000000
Global Const $CFM_BOLD = 0x1
Global Const $CFM_CHARSET = 0x8000000
Global Const $CFM_COLOR = 0x40000000
Global Const $CFM_DISABLED = 0x2000
Global Const $CFM_EMBOSS = 0x800
Global Const $CFM_FACE = 0x20000000
Global Const $CFM_HIDDEN = 0x100
Global Const $CFM_IMPRINT = 0x1000
Global Const $CFM_ITALIC = 0x2
Global Const $CFM_KERNING = 0x100000
Global Const $CFM_LCID = 0x2000000
Global Const $CFM_LINK = 0x20
Global Const $CFM_OFFSET = 0x10000000
Global Const $CFM_OUTLINE = 0x200
Global Const $CFM_PROTECTED = 0x10
Global Const $CFM_REVAUTHOR = 0x8000
Global Const $CFM_REVISED = 0x4000
Global Const $CFM_SHADOW = 0x400
Global Const $CFM_SIZE = 0x80000000
Global Const $CFM_SMALLCAPS = 0x40
Global Const $CFM_SPACING = 0x200000
Global Const $CFM_STRIKEOUT = 0x8
Global Const $CFM_STYLE = 0x80000
Global Const $CFM_SUBSCRIPT = BitOR($CFE_SUBSCRIPT, $CFE_SUPERSCRIPT)
Global Const $CFM_SUPERSCRIPT = $CFM_SUBSCRIPT
Global Const $CFM_UNDERLINE = 0x4
Global Const $CFM_UNDERLINETYPE = 0x800000
Global Const $CFM_WEIGHT = 0x400000
Global Const $CFE_ALLCAPS = $CFM_ALLCAPS
Global Const $CFE_AUTOBACKCOLOR = $CFM_BACKCOLOR
Global Const $CFE_AUTOCOLOR = $CFM_COLOR
Global Const $CFE_BOLD = $CFM_BOLD
Global Const $CFE_DISABLED = $CFM_DISABLED
Global Const $CFE_EMBOSS = $CFM_EMBOSS
Global Const $CFE_HIDDEN = $CFM_HIDDEN
Global Const $CFE_IMPRINT = $CFM_IMPRINT
Global Const $CFE_ITALIC = $CFM_ITALIC
Global Const $CFE_LINK = $CFM_LINK
Global Const $CFE_OUTLINE = $CFM_OUTLINE
Global Const $CFE_PROTECTED = $CFM_PROTECTED
Global Const $CFE_REVISED = $CFM_REVISED
Global Const $CFE_SHADOW = $CFM_SHADOW
Global Const $CFE_SMALLCAPS = $CFM_SMALLCAPS
Global Const $CFE_STRIKEOUT = $CFM_STRIKEOUT
Global Const $CFE_UNDERLINE = $CFM_UNDERLINE
Global Const $FR_MATCHALEFHAMZA = 0x80000000
Global Const $FR_MATCHDIAC = 0x20000000
Global Const $FR_MATCHKASHIDA = 0x40000000
Global Const $SCF_DEFAULT = 0x0
Global Const $SCF_SELECTION = 0x1
Global Const $SCF_WORD = 0x2
Global Const $SCF_ALL = 0x4
Global Const $SCF_USEUIRULES = 0x8
Global Const $SCF_ASSOCIATEFONT = 0x10
Global Const $SCF_NOKBUPDATE = 0x20
Global Const $LF_FACESIZE = 32
Global Const $MAX_TAB_STOPS = 32
Global Const $PFA_LEFT = 0x1
Global Const $PFA_RIGHT = 0x2
Global Const $PFA_CENTER = 0x3
Global Const $PFA_JUSTIFY = 4
Global Const $PFA_FULL_INTERWORD = 4
Global Const $PFE_TABLE = 0x4000
Global Const $PFM_NUMBERING = 0x20
Global Const $PFM_ALIGNMENT = 0x8
Global Const $PFM_SPACEBEFORE = 0x40
Global Const $PFM_NUMBERINGSTYLE = 0x2000
Global Const $PFM_NUMBERINGSTART = 0x8000
Global Const $PFM_BORDER = 0x800
Global Const $PFM_RIGHTINDENT = 0x2
Global Const $PFM_STARTINDENT = 0x1
Global Const $PFM_OFFSET = 0x4
Global Const $PFM_LINESPACING = 0x100
Global Const $PFM_SPACEAFTER = 0x80
Global Const $PFM_NUMBERINGTAB = 0x4000
Global Const $PFM_TABLE = 0x40000000
Global Const $PFM_TABSTOPS = 0x10
Global Const $PFN_BULLET = 0x1
Global Const $PFM_RTLPARA = 0x10000
Global Const $PFM_KEEP = 0x20000
Global Const $PFM_KEEPNEXT = 0x40000
Global Const $PFM_PAGEBREAKBEFORE = 0x80000
Global Const $PFM_NOLINENUMBER = 0x100000
Global Const $PFM_NOWIDOWCONTROL = 0x200000
Global Const $PFM_DONOTHYPHEN = 0x400000
Global Const $PFM_SIDEBYSIDE = 0x800000
Global Const $PFE_RTLPARA = 0x00000001
Global Const $PFE_KEEP = 0x00000002
Global Const $PFE_KEEPNEXT = 0x00000004
Global Const $PFE_PAGEBREAKBEFORE = 0x00000008
Global Const $PFE_NOLINENUMBER = 0x00000010
Global Const $PFE_NOWIDOWCONTROL = 0x00000020
Global Const $PFE_DONOTHYPHEN = 0x00000040
Global Const $PFE_SIDEBYSIDE = 0x00000080
Global Const $PFM_SHADING = 0x1000
Global Const $WB_CLASSIFY = 3
Global Const $WB_ISDELIMITER = 2
Global Const $WB_LEFT = 0
Global Const $WB_LEFTBREAK = 6
Global Const $WB_MOVEWORDLEFT = 4
Global Const $WB_MOVEWORDNEXT = 5
Global Const $WB_MOVEWORDPREV = 4
Global Const $WB_MOVEWORDRIGHT = 5
Global Const $WB_NEXTBREAK = 7
Global Const $WB_PREVBREAK = 6
Global Const $WB_RIGHT = 1
Global Const $WB_RIGHTBREAK = 7
Global Const $WBF_ISWHITE = 0x10
Global Const $WBF_BREAKLINE = 0x20
Global Const $WBF_BREAKAFTER = 0x40
Global Const $SF_TEXT = 0x1
Global Const $SF_RTF = 0x2
Global Const $SF_RTFNOOBJS = 0x3
Global Const $SF_TEXTIZED = 0x4
Global Const $SF_UNICODE = 0x0010
Global Const $SF_USECODEPAGE = 0x20
Global Const $SFF_PLAINRTF = 0x4000
Global Const $SFF_SELECTION = 0x8000
Global $__g_sRTFClassName, $__g_sRTFVersion, $__g_iRTFTwipsPeSpaceUnit = 1440
Global $__g_sGRE_CF_RTF, $__g_sGRE_CF_RETEXTOBJ
Global $__g_pGRC_StreamFromFileCallback = DllCallbackRegister("__GCR_StreamFromFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamFromVarCallback = DllCallbackRegister("__GCR_StreamFromVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToFileCallback = DllCallbackRegister("__GCR_StreamToFileCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_StreamToVarCallback = DllCallbackRegister("__GCR_StreamToVarCallback", "dword", "long_ptr;ptr;long;ptr")
Global $__g_pGRC_sStreamVar
Global $__g_hRELastWnd
Global $__g_tObj_RichComObject = DllStructCreate("ptr pIntf; dword  Refcount")
Global $__g_tCall_RichCom, $__g_pObj_RichCom
Global $__g_hLib_RichCom_OLE32 = DllOpen("OLE32.DLL")
Global $__g_pRichCom_Object_QueryInterface = DllCallbackRegister("__RichCom_Object_QueryInterface", "long", "ptr;dword;dword")
Global $__g_pRichCom_Object_AddRef = DllCallbackRegister("__RichCom_Object_AddRef", "long", "ptr")
Global $__g_pRichCom_Object_Release = DllCallbackRegister("__RichCom_Object_Release", "long", "ptr")
Global $__g_pRichCom_Object_GetNewStorage = DllCallbackRegister("__RichCom_Object_GetNewStorage", "long", "ptr;ptr")
Global $__g_pRichCom_Object_GetInPlaceContext = DllCallbackRegister("__RichCom_Object_GetInPlaceContext", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_ShowContainerUI = DllCallbackRegister("__RichCom_Object_ShowContainerUI", "long", "ptr;long")
Global $__g_pRichCom_Object_QueryInsertObject = DllCallbackRegister("__RichCom_Object_QueryInsertObject", "long", "ptr;dword;ptr;long")
Global $__g_pRichCom_Object_DeleteObject = DllCallbackRegister("__RichCom_Object_DeleteObject", "long", "ptr;ptr")
Global $__g_pRichCom_Object_QueryAcceptData = DllCallbackRegister("__RichCom_Object_QueryAcceptData", "long", "ptr;ptr;dword;dword;dword;ptr")
Global $__g_pRichCom_Object_ContextSensitiveHelp = DllCallbackRegister("__RichCom_Object_ContextSensitiveHelp", "long", "ptr;long")
Global $__g_pRichCom_Object_GetClipboardData = DllCallbackRegister("__RichCom_Object_GetClipboardData", "long", "ptr;ptr;dword;ptr")
Global $__g_pRichCom_Object_GetDragDropEffect = DllCallbackRegister("__RichCom_Object_GetDragDropEffect", "long", "ptr;dword;dword;dword")
Global $__g_pRichCom_Object_GetContextMenu = DllCallbackRegister("__RichCom_Object_GetContextMenu", "long", "ptr;short;ptr;ptr;ptr")
Global Const $__RICHEDITCONSTANT_SB_LINEDOWN = 1
Global Const $__RICHEDITCONSTANT_SB_LINEUP = 0
Global Const $__RICHEDITCONSTANT_SB_PAGEDOWN = 3
Global Const $__RICHEDITCONSTANT_SB_PAGEUP = 2
Global Const $__RICHEDITCONSTANT_WM_COPY = 0x00000301
Global Const $__RICHEDITCONSTANT_WM_SETFONT = 0x0030
Global Const $__RICHEDITCONSTANT_WM_CUT = 0x00000300
Global Const $__RICHEDITCONSTANT_WM_PASTE = 0x00000302
Global Const $__RICHEDITCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__RICHEDITCONSTANT_COLOR_WINDOWTEXT = 8
Global Const $_GCR_S_OK = 0
Global Const $_GCR_E_NOTIMPL = 0x80004001
Global Const $_GCR_E_INVALIDARG = 0x80070057
Global Const $tagEDITSTREAM = "align 4;dword_ptr dwCookie;dword dwError;ptr pfnCallback"
Global Const $tagBIDIOPTIONS = "uint cbSize;word wMask;word wEffects"
Global Const $tagCHARFORMAT = "struct;uint cbSize;dword dwMask;dword dwEffects;long yHeight;long yOffset;INT crCharColor;" &  "byte bCharSet;byte bPitchAndFamily;wchar szFaceName[32];endstruct"
Global Const $tagCHARFORMAT2 = $tagCHARFORMAT & ";word wWeight;short sSpacing;INT crBackColor;dword lcid;dword dwReserved;" &  "short sStyle;word wKerning;byte bUnderlineType;byte bAnimation;byte bRevAuthor;byte bReserved1"
Global Const $tagCHARRANGE = "struct;long cpMin;long cpMax;endstruct"
Global Const $tagFINDTEXT = $tagCHARRANGE & ";ptr lpstrText"
Global Const $tagFINDTEXTEX = $tagCHARRANGE & ";ptr lpstrText;long cpMinRang;long cpMaxRange"
Global Const $tagGETTEXTEX = "align 4;dword cb;dword flags;uint codepage;ptr lpDefaultChar;ptr lpbUsedDefChar"
Global Const $tagGETTEXTLENGTHEX = "dword flags;uint codepage"
Global Const $tagPARAFORMAT = "uint cbSize;dword dwMask;word wNumbering;word wEffects;long dxStartIndent;"  & "long dxRightIndent;long dxOffset;word wAlignment;short cTabCount;long rgxTabs[32]"
Global Const $tagPARAFORMAT2 = $tagPARAFORMAT  & ";long dySpaceBefore;long dySpaceAfter;long dyLineSpacing;short sStyle;byte bLineSpacingRule;"  & "byte bOutlineLevel;word wShadingWeight;word wShadingStyle;word wNumberingStart;word wNumberingStyle;"  & "word wNumberingTab;word wBorderSpace;word wBorderWidth;word wBorders"
Global Const $tagSETTEXTEX = "dword flags;uint codepage"
Global Const $tagTEXTRANGE = $tagCHARRANGE & ";ptr lpstrText"
Global Const $tagMSGFILTER = "align 4;" & $tagNMHDR & ";uint msg;wparam wParam;lparam lParam"
Global Const $tagENLINK = "align 4;" & $tagNMHDR & ";uint msg;wparam wParam;lparam lParam;" & $tagCHARRANGE
Func _GUICtrlRichEdit_AppendText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iLength = _GUICtrlRichEdit_GetTextLength($hWnd)
_GUICtrlRichEdit_SetSel($hWnd, $iLength, $iLength)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_AutoDetectURL($hWnd, $bState)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
If _SendMessage($hWnd, $EM_AUTOURLDETECT, $bState) Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_CanPaste($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_CANPASTE, 0, 0)
Return $iRet <> 0
EndFunc
Func _GUICtrlRichEdit_CanPasteSpecial($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_CANPASTE, $__g_sGRE_CF_RTF, 0) <> 0  And _SendMessage($hWnd, $EM_CANPASTE, $__g_sGRE_CF_RETEXTOBJ, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_CanRedo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_CANREDO, 0, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_CanUndo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_CANUNDO, 0, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_ChangeFontSize($hWnd, $iIncrement)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iIncrement) Then SetError(102, 0, False)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, False)
Return _SendMessage($hWnd, $EM_SETFONTSIZE, $iIncrement, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_Copy($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_COPY, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_Create($hWnd, $sText, $iLeft, $iTop, $iWidth = 150, $iHeight = 150, $iStyle = -1, $iExStyle = -1)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sText) Then Return SetError(2, 0, 0)
If Not __GCR_IsNumeric($iWidth, ">0,-1") Then Return SetError(105, 0, 0)
If Not __GCR_IsNumeric($iHeight, ">0,-1") Then Return SetError(106, 0, 0)
If Not __GCR_IsNumeric($iStyle, ">=0,-1") Then Return SetError(107, 0, 0)
If Not __GCR_IsNumeric($iExStyle, ">=0,-1") Then Return SetError(108, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = BitOR($ES_WANTRETURN, $ES_MULTILINE)
If BitAND($iStyle, $ES_MULTILINE) <> 0 Then $iStyle = BitOR($iStyle, $ES_WANTRETURN)
If $iExStyle = -1 Then $iExStyle = 0x200
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
If BitAND($iStyle, $ES_READONLY) = 0 Then $iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_TABSTOP)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
__GCR_Init()
Local $hRichEdit = _WinAPI_CreateWindowEx($iExStyle, $__g_sRTFClassName, "", $iStyle, $iLeft, $iTop, $iWidth,  $iHeight, $hWnd, $nCtrlID)
If $hRichEdit = 0 Then Return SetError(700, 0, False)
__GCR_SetOLECallback($hRichEdit)
_SendMessage($hRichEdit, $__RICHEDITCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($DEFAULT_GUI_FONT), True)
_GUICtrlRichEdit_AppendText($hRichEdit, $sText)
Return $hRichEdit
EndFunc
Func _GUICtrlRichEdit_Cut($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_CUT, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_Deselect($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $EM_SETSEL, -1, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hRELastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlRichEdit_EmptyUndoBuffer($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $EM_EMPTYUNDOBUFFER, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_FindText($hWnd, $sText, $bForward = True, $bMatchCase = False, $bWholeWord = False, $iBehavior = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, -1)
If $sText = "" Then Return SetError(102, 0, -1)
If Not IsBool($bForward) Then Return SetError(103, 0, -1)
If Not IsBool($bMatchCase) Then Return SetError(104, 0, -1)
If Not IsBool($bWholeWord) Then Return SetError(105, 0, -1)
If Not __GCR_IsNumeric($iBehavior) Then Return SetError(1061, 0, -1)
If BitAND($iBehavior, BitNOT(BitOR($FR_MATCHALEFHAMZA, $FR_MATCHDIAC, $FR_MATCHKASHIDA))) <> 0 Then Return SetError(1062, 0, -1)
Local $iLen = StringLen($sText) + 3
Local $tText = DllStructCreate("wchar[" & $iLen & "]")
DllStructSetData($tText, 1, $sText)
Local $tFindtext = DllStructCreate($tagFINDTEXT)
Local $aiAnchorActive
Local $bSel = _GUICtrlRichEdit_IsTextSelected($hWnd)
If $bSel Then
$aiAnchorActive = _GUICtrlRichEdit_GetSelAA($hWnd)
Else
$aiAnchorActive = _GUICtrlRichEdit_GetSel($hWnd)
EndIf
DllStructSetData($tFindtext, 1, $aiAnchorActive[0])
DllStructSetData($tFindtext, 2, ($bForward ? -1 : 0))
DllStructSetData($tFindtext, 3, DllStructGetPtr($tText))
Local Const $FR_DOWN = 0x00000001
Local Const $FR_WHOLEWORD = 0x00000002
Local Const $FR_MATCHCASE = 0x00000004
Local $wParam = 0
If $bForward Then $wParam = $FR_DOWN
If $bWholeWord Then $wParam = BitOR($wParam, $FR_WHOLEWORD)
If $bMatchCase Then $wParam = BitOR($wParam, $FR_MATCHCASE)
$wParam = BitOR($wParam, $iBehavior)
Return _SendMessage($hWnd, $EM_FINDTEXTW, $wParam, $tFindtext, "wparam", "ptr", "struct*")
EndFunc
Func _GUICtrlRichEdit_FindTextInRange($hWnd, $sText, $iStart = 0, $iEnd = -1, $bMatchCase = False, $bWholeWord = False, $iBehavior = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If $sText = "" Then Return SetError(102, 0, 0)
If Not __GCR_IsNumeric($iStart, ">=0,-1") Then Return SetError(103, 0, 0)
If Not __GCR_IsNumeric($iEnd, ">=0,-1") Then Return SetError(104, 0, 0)
If Not IsBool($bMatchCase) Then Return SetError(105, 0, 0)
If Not IsBool($bWholeWord) Then Return SetError(106, 0, 0)
If Not __GCR_IsNumeric($iBehavior) Then Return SetError(1071, 0, 0)
If BitAND($iBehavior, BitNOT(BitOR($FR_MATCHALEFHAMZA, $FR_MATCHDIAC, $FR_MATCHKASHIDA))) <> 0 Then Return SetError(1072, 0, 0)
Local $iLen = StringLen($sText) + 3
Local $tText = DllStructCreate("wchar Text[" & $iLen & "]")
DllStructSetData($tText, "Text", $sText)
Local $tFindtext = DllStructCreate($tagFINDTEXTEX)
DllStructSetData($tFindtext, "cpMin", $iStart)
DllStructSetData($tFindtext, "cpMax", $iEnd)
DllStructSetData($tFindtext, "lpstrText", DllStructGetPtr($tText))
Local Const $FR_DOWN = 0x00000001
Local Const $FR_WHOLEWORD = 0x00000002
Local Const $FR_MATCHCASE = 0x00000004
Local $wParam = 0
If $iEnd >= $iStart Or $iEnd = -1 Then
$wParam = $FR_DOWN
EndIf
If $bWholeWord Then $wParam = BitOR($wParam, $FR_WHOLEWORD)
If $bMatchCase Then $wParam = BitOR($wParam, $FR_MATCHCASE)
$wParam = BitOR($wParam, $iBehavior)
_SendMessage($hWnd, $EM_FINDTEXTEXW, $wParam, $tFindtext, "iWparam", "ptr", "struct*")
Local $aRet[2]
$aRet[0] = DllStructGetData($tFindtext, "cpMinRang")
$aRet[1] = DllStructGetData($tFindtext, "cpMaxRange")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetCharAttributes($hWnd)
Local Const $aV[17][3] = [  ["bo", $CFM_BOLD, $CFE_BOLD], ["di", $CFM_DISABLED, $CFE_DISABLED],  ["em", $CFM_EMBOSS, $CFE_EMBOSS], ["hi", $CFM_HIDDEN, $CFE_HIDDEN],  ["im", $CFM_IMPRINT, $CFE_IMPRINT], ["it", $CFM_ITALIC, $CFE_ITALIC],  ["li", $CFM_LINK, $CFE_LINK], ["ou", $CFM_OUTLINE, $CFE_OUTLINE],  ["pr", $CFM_PROTECTED, $CFE_PROTECTED], ["re", $CFM_REVISED, $CFE_REVISED],  ["sh", $CFM_SHADOW, $CFE_SHADOW], ["sm", $CFM_SMALLCAPS, $CFE_SMALLCAPS],  ["st", $CFM_STRIKEOUT, $CFE_STRIKEOUT], ["sb", $CFM_SUBSCRIPT, $CFE_SUBSCRIPT],  ["sp", $CFM_SUPERSCRIPT, $CFE_SUPERSCRIPT], ["un", $CFM_UNDERLINE, $CFE_UNDERLINE],  ["al", $CFM_ALLCAPS, $CFE_ALLCAPS]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $bSel = _GUICtrlRichEdit_IsTextSelected($hWnd)
If Not $bSel Then Return SetError(-1, 0, "")
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
Local $iMask = _SendMessage($hWnd, $EM_GETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
Local $iEffects = DllStructGetData($tCharFormat, 3)
Local $sStatesAndAtts = "", $sState, $bM, $bE
For $i = 0 To UBound($aV, $UBOUND_ROWS) - 1
$bM = BitAND($iMask, $aV[$i][1]) = $aV[$i][1]
$bE = BitAND($iEffects, $aV[$i][2]) = $aV[$i][2]
If $bSel Then
If $bM Then
If $bE Then
$sState = "+"
Else
$sState = "-"
EndIf
Else
$sState = "~"
EndIf
Else
If $bM Then
$sState = "+"
Else
$sState = "-"
EndIf
EndIf
If $sState <> "-" Then $sStatesAndAtts &= $aV[$i][0] & $sState
Next
Return $sStatesAndAtts
EndFunc
Func _GUICtrlRichEdit_GetCharBkColor($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
__GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
Local $iEffects = DllStructGetData($tCharFormat, 3)
Local $iBkColor
If BitAND($iEffects, $CFE_AUTOBACKCOLOR) = $CFE_AUTOBACKCOLOR Then
$iBkColor = _WinAPI_GetSysColor($__RICHEDITCONSTANT_COLOR_WINDOWTEXT)
Else
$iBkColor = DllStructGetData($tCharFormat, 12)
EndIf
Return SetExtended(BitAND($iEffects, $CFM_BACKCOLOR) <> 0, $iBkColor)
EndFunc
Func _GUICtrlRichEdit_GetCharColor($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
__GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
Local $iEffects = DllStructGetData($tCharFormat, 3)
Local $iColor
If BitAND($iEffects, $CFE_AUTOCOLOR) = $CFE_AUTOCOLOR Then
$iColor = _WinAPI_GetSysColor($__RICHEDITCONSTANT_COLOR_WINDOWTEXT)
Else
$iColor = DllStructGetData($tCharFormat, 6)
EndIf
Return SetExtended(BitAND($iEffects, $CFM_COLOR) <> 0, $iColor)
EndFunc
Func _GUICtrlRichEdit_GetCharPosFromXY($hWnd, $iX, $iY)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iX) Then Return SetError(102, 0, 0)
If Not __GCR_IsNumeric($iY) Then Return SetError(103, 0, 0)
Local $aiRect = _GUICtrlRichEdit_GetRECT($hWnd)
If $iX < $aiRect[0] Or $iX > $aiRect[2] Or $iY < $aiRect[1] Or $iY > $aiRect[3] Then Return -1
Local $tPointL = DllStructCreate("LONG x; LONG y;")
DllStructSetData($tPointL, 1, $iX)
DllStructSetData($tPointL, 2, $iY)
Local $iRet = _SendMessage($hWnd, $EM_CHARFROMPOS, 0, $tPointL, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(-1, 0, 0)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetCharPosOfNextWord($hWnd, $iCpStart)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCpStart) Then Return SetError(102, 0, 0)
Return _SendMessage($hWnd, $EM_FINDWORDBREAK, $WB_MOVEWORDRIGHT, $iCpStart)
EndFunc
Func _GUICtrlRichEdit_GetCharPosOfPreviousWord($hWnd, $iCpStart)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCpStart) Then Return SetError(102, 0, 0)
Return _SendMessage($hWnd, $EM_FINDWORDBREAK, $WB_MOVEWORDLEFT, $iCpStart)
EndFunc
Func _GUICtrlRichEdit_GetCharWordBreakInfo($hWnd, $iCp)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not __GCR_IsNumeric($iCp) Then Return SetError(102, 0, "")
Local $iRet = _SendMessage($hWnd, $EM_FINDWORDBREAK, $WB_CLASSIFY, $iCp)
Local $iClass = BitAND($iRet, 0xF0)
Local $sRet = ""
If BitAND($iClass, $WBF_BREAKAFTER) Then $sRet &= "c"
If BitAND($iClass, $WBF_BREAKLINE) Then $sRet &= "d"
If BitAND($iClass, $WBF_ISWHITE) Then $sRet &= "w"
$sRet &= ";" & BitAND($iRet, 0xF)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetBkColor($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $iBkColor = _SendMessage($hWnd, $EM_SETBKGNDCOLOR, False, 0)
_SendMessage($hWnd, $EM_SETBKGNDCOLOR, False, $iBkColor)
Return $iBkColor
EndFunc
Func _GUICtrlRichEdit_GetText($hWnd, $bCrToCrLf = False, $iCodePage = 0, $sReplChar = "")
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bCrToCrLf) Then Return SetError(102, 0, "")
If Not __GCR_IsNumeric($iCodePage) Then Return SetError(103, 0, "")
Local $iLen = _GUICtrlRichEdit_GetTextLength($hWnd, False, True) + 1
Local $sUni = ''
If $iCodePage = $CP_UNICODE Or Not $iCodePage Then $sUni = "w"
Local $tText = DllStructCreate($sUni & "char[" & $iLen & "]")
Local $tGetTextEx = DllStructCreate($tagGETTEXTEX)
DllStructSetData($tGetTextEx, "cb", DllStructGetSize($tText))
Local $iFlags = 0
If $bCrToCrLf Then $iFlags = $GT_USECRLF
DllStructSetData($tGetTextEx, "flags", $iFlags)
If $iCodePage = 0 Then $iCodePage = $CP_UNICODE
DllStructSetData($tGetTextEx, "codepage", $iCodePage)
Local $pUsedDefChar = 0, $pDefaultChar = 0
If $sReplChar <> "" Then
Local $tDefaultChar = DllStructCreate("char")
$pDefaultChar = DllStructGetPtr($tDefaultChar, 1)
DllStructSetData($tDefaultChar, 1, $sReplChar)
Local $tUsedDefChar = DllStructCreate("bool")
$pUsedDefChar = DllStructGetPtr($tUsedDefChar, 1)
EndIf
DllStructSetData($tGetTextEx, "lpDefaultChar", $pDefaultChar)
DllStructSetData($tGetTextEx, "lpbUsedDefChar", $pUsedDefChar)
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTEX, $tGetTextEx, $tText, 0, "struct*", "struct*")
If $iRet = 0 Then Return SetError(700, 0, "")
If $sReplChar <> "" Then SetExtended(DllStructGetData($tUsedDefChar, 1) <> 0)
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetTextLength($hWnd, $bExact = True, $bChars = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not IsBool($bExact) Then Return SetError(102, 0, 0)
If Not IsBool($bChars) Then Return SetError(103, 0, 0)
Local $tGetTextLen = DllStructCreate($tagGETTEXTLENGTHEX)
Local $iFlags = BitOR($GTL_USECRLF, ($bExact ? $GTL_PRECISE : $GTL_CLOSE))
$iFlags = BitOR($iFlags, ($bChars ? $GTL_DEFAULT : $GTL_NUMBYTES))
DllStructSetData($tGetTextLen, 1, $iFlags)
DllStructSetData($tGetTextLen, 2, ($bChars ? $CP_ACP : $CP_UNICODE))
Local $iRet = _SendMessage($hWnd, $EM_GETTEXTLENGTHEX, $tGetTextLen, 0, 0, "struct*")
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetZoom($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $wParam = 0, $lParam = 0
Local $aI = _SendMessage($hWnd, $EM_GETZOOM, $wParam, $lParam, -1, "int*", "int*")
If Not $aI[0] Then Return SetError(700, 0, 0)
Local $iRet
If $aI[3] = 0 And $aI[4] = 0 Then
$iRet = 100
Else
$iRet = $aI[3] / $aI[4] * 100
EndIf
Return StringFormat("%.2f", $iRet)
EndFunc
Func _GUICtrlRichEdit_GetFirstCharPosOnLine($hWnd, $iLine = -1)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iLine, ">0,-1") Then Return SetError(1021, 0, 0)
If $iLine <> -1 Then $iLine -= 1
Local $iRet = _SendMessage($hWnd, $EM_LINEINDEX, $iLine)
If $iRet = -1 Then Return SetError(1022, 0, 0)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetFont($hWnd)
Local $aRet[3] = [0, "", 0]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, "cbSize", DllStructGetSize($tCharFormat))
__GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
If BitAND(DllStructGetData($tCharFormat, "dwMask"), $CFM_FACE) = $CFM_FACE Then  $aRet[1] = DllStructGetData($tCharFormat, "szFaceName")
If BitAND(DllStructGetData($tCharFormat, "dwMask"), $CFM_SIZE) = $CFM_SIZE Then  $aRet[0] = DllStructGetData($tCharFormat, "yHeight") / 20
If BitAND(DllStructGetData($tCharFormat, "dwMask"), $CFM_CHARSET) = $CFM_CHARSET Then  $aRet[2] = DllStructGetData($tCharFormat, "bCharSet")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetRECT($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tRECT = DllStructCreate($tagRECT)
_SendMessage($hWnd, $EM_GETRECT, 0, $tRECT, 0, "wparam", "struct*")
Local $aiRect[4]
$aiRect[0] = DllStructGetData($tRECT, "Left")
$aiRect[1] = DllStructGetData($tRECT, "Top")
$aiRect[2] = DllStructGetData($tRECT, "Right")
$aiRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aiRect
EndFunc
Func _GUICtrlRichEdit_GetLineCount($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Return _SendMessage($hWnd, $EM_GETLINECOUNT)
EndFunc
Func _GUICtrlRichEdit_GetLineLength($hWnd, $iLine)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iLine, ">0,-1") Then Return SetError(102, 0, 0)
Local $iCharPos = _GUICtrlRichEdit_GetFirstCharPosOnLine($hWnd, $iLine)
Local $iRet = _SendMessage($hWnd, $EM_LINELENGTH, $iCharPos)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetLineNumberFromCharPos($hWnd, $iCharPos)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCharPos, ">=0") Then Return SetError(102, 0, 0)
Return _SendMessage($hWnd, $EM_EXLINEFROMCHAR, 0, $iCharPos) + 1
EndFunc
Func _GUICtrlRichEdit_GetNextRedo($hWnd, $bName = True)
Local Const $aS[6] = ["Unknown", "Typing", "Delete", "Drag and drop", "Cut", "Paste"]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bName) Then Return SetError(102, 0, "")
Local $iUid = _SendMessage($hWnd, $EM_GETREDONAME, 0, 0)
If $bName Then
Return $aS[$iUid]
Else
Return $iUid
EndIf
EndFunc
Func _GUICtrlRichEdit_GetNextUndo($hWnd, $bName = True)
Local Const $aS[6] = ["Unknown", "Typing", "Delete", "Drag and drop", "Cut", "Paste"]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
If Not IsBool($bName) Then Return SetError(102, 0, "")
Local $iUid = _SendMessage($hWnd, $EM_GETUNDONAME, 0, 0)
If $bName Then
Return $aS[$iUid]
Else
Return $iUid
EndIf
EndFunc
Func _GUICtrlRichEdit_GetNumberOfFirstVisibleLine($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Return _SendMessage($hWnd, $EM_GETFIRSTVISIBLELINE) + 1
EndFunc
Func _GUICtrlRichEdit_GetParaAlignment($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, 2)
Local $iAlignment = DllStructGetData($tParaFormat, 8)
Local $sRet = ""
Switch ($iAlignment)
Case $PFA_LEFT
$sRet = "l"
Case $PFA_CENTER
$sRet = "c"
Case $PFA_RIGHT
$sRet = "r"
Case $PFA_JUSTIFY
$sRet = "j"
Case $PFA_FULL_INTERWORD
$sRet = "w"
EndSwitch
$sRet &= ";" & __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_ALIGNMENT)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaAttributes($hWnd)
Local Enum $eAbbrev = 0, $eEffect, $eInverted
Local Const $aV[9][3] = [  ["fpg", $PFE_PAGEBREAKBEFORE, False],  ["hyp", $PFE_DONOTHYPHEN, True],  ["kpt", $PFE_KEEP, False],  ["kpn", $PFE_KEEPNEXT, False],  ["pwo", $PFE_NOWIDOWCONTROL, False],  ["r2l", $PFE_RTLPARA, False],  ["row", $PFE_TABLE, False],  ["sbs", $PFE_SIDEBYSIDE, False],  ["sln", $PFE_NOLINENUMBER, False]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iEffects = DllStructGetData($tParaFormat, "wEffects")
Local $sStatesAndAtts = "", $sState
For $i = 0 To UBound($aV, $UBOUND_ROWS) - 1
$sStatesAndAtts &= $aV[$i][$eAbbrev]
If BitAND($iEffects, $aV[$i][$eEffect]) = $aV[$i][$eEffect] Then
$sState = ($aV[$i][$eInverted] ? "-" : "+")
Else
$sState = ($aV[$i][$eInverted] ? "+" : "-")
EndIf
$sStatesAndAtts &= $sState & ";"
Next
$sStatesAndAtts &= (_GUICtrlRichEdit_IsTextSelected($hWnd) ? "f" : "c")
Return $sStatesAndAtts
EndFunc
Func _GUICtrlRichEdit_GetParaBorder($hWnd)
Local Const $avLocs[6][2] = [["l", 1], ["r", 2], ["t", 4], ["b", 8], ["i", 16], ["o", 32]]
Local Const $avLS[12] = ["none", .75, 1.5, 2.25, 3, 4.5, 6, ".75d", "1.5d", "2.25d", ".75g", ".75gd"]
Local Const $sClrs = "blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;"
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, 2)
Local $iSpace = DllStructGetData($tParaFormat, 22)
Local $iBorders = DllStructGetData($tParaFormat, 24)
Local $sRet = ""
For $i = 0 To UBound($avLocs, $UBOUND_ROWS) - 1
If BitAND($iBorders, $avLocs[$i][1]) Then $sRet &= $avLocs[$i][0]
Next
$sRet &= ";"
$sRet &= $avLS[BitShift(BitAND($iBorders, 0xF00), 8)]
$sRet &= ";"
If BitAND($iBorders, 64) Then
$sRet &= "aut"
Else
$sRet &= StringMid($sClrs, BitShift(BitAND($iBorders, 0xF000), 12) * 4 + 1, 3)
EndIf
$sRet &= ";"
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iSpace) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_BORDER)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaIndents($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "dwMask", BitOR($PFM_STARTINDENT, $PFM_OFFSET))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iIdxSI = DllStructGetData($tParaFormat, "dxStartIndent")
Local $iIdxOfs = DllStructGetData($tParaFormat, "dxOffset")
Local $iDxRI = DllStructGetData($tParaFormat, "dxRightIndent")
Local $iLeft = __GCR_ConvertTwipsToSpaceUnit($iIdxSI + $iIdxOfs)
Local $iFirstLine = __GCR_ConvertTwipsToSpaceUnit(-$iIdxOfs)
Local $iRight = __GCR_ConvertTwipsToSpaceUnit($iDxRI)
Local $iRet = $iLeft & ";" & $iRight & ";" & $iFirstLine & ";" & __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_STARTINDENT)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_GetParaNumbering($hWnd)
Local Const $avRoman[7][2] = [[1000, "m"], [500, "d"], [100, "c"], [50, "l"], [10, "x"], [5, "v"], [1, "i"]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, 2, BitOR($PFM_NUMBERING, $PFM_NUMBERINGSTART, $PFM_NUMBERINGSTYLE))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iChar = DllStructGetData($tParaFormat, "wNumbering")
Local $iStart = DllStructGetData($tParaFormat, "wNumberingStart")
Local $iStyle = DllStructGetData($tParaFormat, "wNumberingStyle")
Local $iTab = DllStructGetData($tParaFormat, "wNumberingTab")
Local $sRet = ""
Switch $iChar
Case 0
$sRet = ""
Case 1
$sRet = "."
Case 2
$sRet = $iStart
Case 3
$sRet = Chr(Asc("a") + $iStart - 1)
Case 4
$sRet = Chr(Asc("a") + $iStart - 1)
Case 5, 6
For $i = 0 To UBound($avRoman, $UBOUND_ROWS) - 2 Step 2
For $j = $i To $i + 1
While $iStart >= $avRoman[$j][0]
$sRet &= $avRoman[$j][1]
$iStart -= $avRoman[$j][0]
WEnd
If $iStart = $avRoman[$j][0] - 1 Then
$sRet &= $avRoman[$i + 2][1] & $avRoman[$j][1]
$iStart -= $avRoman[$j][0] - $avRoman[$i + 2][0]
EndIf
Next
Next
While $iStart > 0
$sRet &= "i"
$iStart -= 1
WEnd
If $iChar = 6 Then $sRet = StringUpper($sRet)
EndSwitch
If $iChar > 1 Then
Switch $iStyle
Case 0
$sRet &= ")"
Case 0x100
$sRet = "(" & $sRet & ")"
Case 0x200
$sRet &= "."
Case 0x300
EndSwitch
EndIf
Local $aV = _GUICtrlRichEdit_GetFont($hWnd)
Local $iPoints = $aV[0]
Local $iQspaces = Round($iTab / ($iPoints * 20), 0)
For $i = 1 To $iQspaces
$sRet &= " "
Next
$sRet &= ";"
$sRet &= (($iChar = 5 Or $iChar = 6) ? "Roman;" : ";")
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iTab) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, BitOR($PFM_NUMBERING, $PFM_NUMBERINGSTART, $PFM_NUMBERINGSTYLE))
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaShading($hWnd)
Local Const $asStyles[13] = ["non", "dhz", "dvt", "ddd", "dud", "dgr", "dtr", "lhz", "lrt", "ldd", "lud",  "lgr", "ltr"]
Local Const $asClrs[16] = ["blk", "blu", "cyn", "grn", "mag", "red", "yel", "whi", "dbl", "dgn", "dmg",  "drd", "dyl", "dgy", "lgy"]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iWeight = DllStructGetData($tParaFormat, "wShadingWeight")
Local $iS = DllStructGetData($tParaFormat, "wShadingStyle")
Local $sRet = $iWeight & ";"
Local $iN = BitAND($iS, 0xF)
$sRet &= $asStyles[$iN] & ";"
$iN = BitShift(BitAND($iS, 0xF0), 4)
$sRet &= $asClrs[$iN] & ";"
$iN = BitShift(BitAND($iS, 0xF00), 8)
$sRet &= $asClrs[$iN] & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_SHADING)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaSpacing($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iInter = DllStructGetData($tParaFormat, "dyLineSpacing")
Local $iRule = DllStructGetData($tParaFormat, "bLineSpacingRule")
Local $sRet = ""
Switch $iRule
Case 0
$sRet = "1 line;"
Case 1
$sRet = "1.5 lines;"
Case 2
$sRet = "2 lines;"
Case 3, 4
$sRet = __GCR_ConvertTwipsToSpaceUnit($iInter) & ";"
Case 5
$sRet = StringFormat("%.2f", $iInter / 20) & " lines;"
EndSwitch
Local $iMask = 0
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_LINESPACING) & ";"
Local $iBefore = DllStructGetData($tParaFormat, "dySpaceBefore")
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iBefore) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_SPACEBEFORE) & ";"
Local $iAfter = DllStructGetData($tParaFormat, "dySPaceAfter")
$sRet &= __GCR_ConvertTwipsToSpaceUnit($iAfter) & ";"
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_SPACEAFTER)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetParaTabStops($hWnd)
Local Const $asKind[5] = ["l", "c", "r", "d", "b"], $asLeader[6] = [" ", ".", "-", "_", "t", "="]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $tParaFormat = DllStructCreate($tagPARAFORMAT)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
__GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
If @error Then Return SetError(@error, 0, "")
Local $iMask = DllStructGetData($tParaFormat, "dwMask")
Local $iQtabs = DllStructGetData($tParaFormat, "cTabCount")
Local $sRet = $iQtabs & ";"
Local $iN, $iM
For $i = 1 To $iQtabs
$iN = DllStructGetData($tParaFormat, "rgxTabs", $i)
$sRet &= __GCR_ConvertTwipsToSpaceUnit(BitAND($iN, 0xFFFFF))
$iM = BitAND(BitShift($iN, 24), 0xF)
$sRet &= $asKind[$iM]
$iM = BitAND(BitShift($iN, 28), 0xF)
$sRet &= $asLeader[$iM] & ";"
Next
$sRet &= __GCR_GetParaScopeChar($hWnd, $iMask, $PFM_TABSTOPS)
Return $sRet
EndFunc
Func _GUICtrlRichEdit_GetPasswordChar($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $n = _SendMessage($hWnd, $EM_GETPASSWORDCHAR)
Return ($n = 0) ? "" : Chr($n)
EndFunc
Func _GUICtrlRichEdit_GetScrollPos($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tPoint = DllStructCreate($tagPOINT)
_SendMessage($hWnd, $EM_GETSCROLLPOS, 0, $tPoint, 0, "wparam", "struct*")
Local $aRet[2]
$aRet[0] = DllStructGetData($tPoint, "x")
$aRet[1] = DllStructGetData($tPoint, "y")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetSel($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $tCharRange = DllStructCreate($tagCHARRANGE)
_SendMessage($hWnd, $EM_EXGETSEL, 0, $tCharRange, 0, "wparam", "struct*")
Local $aRet[2]
$aRet[0] = DllStructGetData($tCharRange, 1)
$aRet[1] = DllStructGetData($tCharRange, 2)
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetSelAA($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
Local $aiLowHigh = _GUICtrlRichEdit_GetSel($hWnd)
If $aiLowHigh[0] = $aiLowHigh[1] Then Return SetError(-1, 0, 0)
_SendMessage($hWnd, $EM_SETSEL, -1, 0)
Local $aiNoSel = _GUICtrlRichEdit_GetSel($hWnd)
Local $aRet[2]
If $aiLowHigh[0] = $aiNoSel[0] Then
$aRet[0] = $aiLowHigh[1]
$aRet[1] = $aiLowHigh[0]
Else
$aRet = $aiLowHigh
EndIf
_SendMessage($hWnd, $EM_SETSEL, $aiLowHigh[0], $aiLowHigh[1])
_WinAPI_SetFocus($hWnd)
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GetSelText($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, -1)
Local $aiLowHigh = _GUICtrlRichEdit_GetSel($hWnd)
Local $tText = DllStructCreate("wchar[" & $aiLowHigh[1] - $aiLowHigh[0] + 1 & "]")
_SendMessage($hWnd, $EM_GETSELTEXT, 0, $tText, 0, "wparam", "struct*")
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetSpaceUnit()
Switch $__g_iRTFTwipsPeSpaceUnit
Case 1440
Return "in"
Case 567
Return "cm"
Case 56.7
Return "mm"
Case 20
Return "pt"
Case 1
Return "tw"
EndSwitch
EndFunc
Func _GUICtrlRichEdit_GetTextInLine($hWnd, $iLine)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iLine, ">0,-1") Then Return SetError(1021, 0, False)
If $iLine > _GUICtrlRichEdit_GetLineCount($hWnd) Then Return SetError(1022, 0, False)
Local $iLen = _GUICtrlRichEdit_GetLineLength($hWnd, $iLine)
If $iLen = 0 Then Return ""
Local $tBuffer = DllStructCreate("short Len;wchar Text[" & $iLen + 2 & "]")
DllStructSetData($tBuffer, "Len", $iLen + 2)
If $iLine <> -1 Then $iLine -= 1
Local $iRet = _SendMessage($hWnd, $EM_GETLINE, $iLine, $tBuffer, 10, "wparam", "struct*")
If $iRet = 0 Then Return SetError(700, 0, False)
Local $tString = DllStructCreate("wchar Text[" & $iLen + 1 & "]", DllStructGetPtr($tBuffer))
Return StringLeft(DllStructGetData($tString, "Text"), $iLen)
EndFunc
Func _GUICtrlRichEdit_GetTextInRange($hWnd, $iStart, $iEnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iStart, ">=0") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iEnd, ">=0,-1") Then Return SetError(1031, 0, False)
If Not ($iEnd > $iStart Or $iEnd = -1) Then Return SetError(1032, 0, False)
Local $iLen = _GUICtrlRichEdit_GetTextLength($hWnd)
Local $tText = DllStructCreate("wchar[" & ($iLen + 4) & "]")
Local $tTextRange = DllStructCreate($tagTEXTRANGE)
DllStructSetData($tTextRange, 1, $iStart)
DllStructSetData($tTextRange, 2, $iEnd)
DllStructSetData($tTextRange, 3, DllStructGetPtr($tText))
_SendMessage($hWnd, $EM_GETTEXTRANGE, 0, $tTextRange, 0, "wparam", "struct*")
Return DllStructGetData($tText, 1)
EndFunc
Func _GUICtrlRichEdit_GetVersion()
Return $__g_sRTFVersion
EndFunc
Func _GUICtrlRichEdit_GetXYFromCharPos($hWnd, $iCharPos)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If Not __GCR_IsNumeric($iCharPos, ">=0") Then Return SetError(1021, 0, 0)
If $iCharPos > _GUICtrlRichEdit_GetTextLength($hWnd) Then Return SetError(1022, 0, 0)
Local $tPoint = DllStructCreate($tagPOINT)
_SendMessage($hWnd, $EM_POSFROMCHAR, $tPoint, $iCharPos, 0, "struct*", "lparam")
Local $aRet[2]
$aRet[0] = DllStructGetData($tPoint, "X")
$aRet[1] = DllStructGetData($tPoint, "Y")
Return $aRet
EndFunc
Func _GUICtrlRichEdit_GotoCharPos($hWnd, $iCharPos)
_GUICtrlRichEdit_SetSel($hWnd, $iCharPos, $iCharPos)
If @error Then Return SetError(@error, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_HideSelection($hWnd, $bHide = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bHide) Then Return SetError(102, 0, False)
_SendMessage($hWnd, $EM_HIDESELECTION, $bHide, 0)
_WinAPI_SetFocus($hWnd)
EndFunc
Func _GUICtrlRichEdit_InsertText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If $sText = "" Then Return SetError(102, 0, False)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_SELECTION)
_GUICtrlRichEdit_Deselect($hWnd)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
DllStructSetData($tSetText, 2, $CP_ACP)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(103, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_IsModified($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_GETMODIFY) <> 0
EndFunc
Func _GUICtrlRichEdit_IsTextSelected($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharRange = DllStructCreate($tagCHARRANGE)
_SendMessage($hWnd, $EM_EXGETSEL, 0, $tCharRange, 0, "wparam", "struct*")
Return DllStructGetData($tCharRange, 2) <> DllStructGetData($tCharRange, 1)
EndFunc
Func _GUICtrlRichEdit_Paste($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_PASTE, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_PasteSpecial($hWnd, $bAndObjects = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iN = ($bAndObjects ? $__g_sGRE_CF_RETEXTOBJ : $__g_sGRE_CF_RTF)
_SendMessage($hWnd, $EM_PASTESPECIAL, $iN, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_PauseRedraw($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_SETREDRAW, False)
EndFunc
Func _GUICtrlRichEdit_Redo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_REDO, 0, 0) <> 0
EndFunc
Func _GUICtrlRichEdit_ReplaceText($hWnd, $sText, $bCanUndo = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bCanUndo) Then Return SetError(103, 0, False)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then Return SetError(-1, 0, False)
Local $tText = DllStructCreate("wchar Text[" & StringLen($sText) + 1 & "]")
DllStructSetData($tText, "Text", $sText)
If _WinAPI_InProcess($hWnd, $__g_hRELastWnd) Then
_SendMessage($hWnd, $EM_REPLACESEL, $bCanUndo, $tText, 0, "wparam", "struct*")
Else
Local $iText = DllStructGetSize($tText)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iText, $tMemMap)
_MemWrite($tMemMap, $tText)
_SendMessage($hWnd, $EM_REPLACESEL, $bCanUndo, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_ResumeRedraw($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $__RICHEDITCONSTANT_WM_SETREDRAW, True)
Return _WinAPI_InvalidateRect($hWnd)
EndFunc
Func _GUICtrlRichEdit_ScrollLineOrPage($hWnd, $sAction)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, 0)
If StringLen($sAction) <> 2 Then Return SetError(1021, 0, 0)
Local $sCh = StringLeft($sAction, 1)
If Not ($sCh = "l" Or $sCh = "p") Then Return SetError(1022, 0, 0)
$sCh = StringRight($sAction, 1)
If Not ($sCh = "d" Or $sCh = "u") Then Return SetError(1023, 0, 0)
Local $wParam = 0
Switch $sAction
Case "ld"
$wParam = $__RICHEDITCONSTANT_SB_LINEDOWN
Case "lu"
$wParam = $__RICHEDITCONSTANT_SB_LINEUP
Case "pd"
$wParam = $__RICHEDITCONSTANT_SB_PAGEDOWN
Case "pu"
$wParam = $__RICHEDITCONSTANT_SB_PAGEUP
EndSwitch
Local $iRet = _SendMessage($hWnd, $EM_SCROLL, $wParam, 0)
$iRet = BitAND($iRet, 0xFFFF)
If BitAND($iRet, 0x8000) <> 0 Then $iRet = BitOR($iRet, 0xFFFF0000)
Return $iRet
EndFunc
Func _GUICtrlRichEdit_ScrollLines($hWnd, $iQlines)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iQlines) Then SetError(102, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_LINESCROLL, 0, $iQlines)
If $iRet = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_ScrollToCaret($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
_SendMessage($hWnd, $EM_SCROLLCARET, 0, 0)
Return True
EndFunc
Func _GUICtrlRichEdit_SetCharAttributes($hWnd, $sStatesAndEffects, $bWord = False)
Local Const $aV[17][3] = [  ["bo", $CFM_BOLD, $CFE_BOLD], ["di", $CFM_DISABLED, $CFE_DISABLED],  ["em", $CFM_EMBOSS, $CFE_EMBOSS], ["hi", $CFM_HIDDEN, $CFE_HIDDEN],  ["im", $CFM_IMPRINT, $CFE_IMPRINT], ["it", $CFM_ITALIC, $CFE_ITALIC],  ["li", $CFM_LINK, $CFE_LINK], ["ou", $CFM_OUTLINE, $CFE_OUTLINE],  ["pr", $CFM_PROTECTED, $CFE_PROTECTED], ["re", $CFM_REVISED, $CFE_REVISED],  ["sh", $CFM_SHADOW, $CFE_SHADOW], ["sm", $CFM_SMALLCAPS, $CFE_SMALLCAPS],  ["st", $CFM_STRIKEOUT, $CFE_STRIKEOUT], ["sb", $CFM_SUBSCRIPT, $CFE_SUBSCRIPT],  ["sp", $CFM_SUPERSCRIPT, $CFE_SUPERSCRIPT], ["un", $CFM_UNDERLINE, $CFE_UNDERLINE],  ["al", $CFM_ALLCAPS, $CFE_ALLCAPS]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bWord) Then Return SetError(103, 0, False)
Local $iMask = 0, $iEffects = 0, $n, $s
For $i = 1 To StringLen($sStatesAndEffects) Step 3
$s = StringMid($sStatesAndEffects, $i + 1, 2)
$n = -1
For $j = 0 To UBound($aV) - 1
If $aV[$j][0] = $s Then
$n = $j
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(1023, $s, False)
$iMask = BitOR($iMask, $aV[$n][1])
$s = StringMid($sStatesAndEffects, $i, 1)
Switch $s
Case "+"
$iEffects = BitOR($iEffects, $aV[$n][2])
Case "-"
Case Else
Return SetError(1022, $s, False)
EndSwitch
Next
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
DllStructSetData($tCharFormat, 2, $iMask)
DllStructSetData($tCharFormat, 3, $iEffects)
Local $wParam = ($bWord ? BitOR($SCF_WORD, $SCF_SELECTION) : $SCF_SELECTION)
Local $iRet = _SendMessage($hWnd, $EM_SETCHARFORMAT, $wParam, $tCharFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetCharBkColor($hWnd, $iBkColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iBkColor = Default Then
DllStructSetData($tCharFormat, 3, $CFE_AUTOBACKCOLOR)
$iBkColor = 0
Else
If BitAND($iBkColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
DllStructSetData($tCharFormat, 2, $CFM_BACKCOLOR)
DllStructSetData($tCharFormat, 12, $iBkColor)
Return _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetCharColor($hWnd, $iColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iColor = Default Then
DllStructSetData($tCharFormat, 3, $CFE_AUTOCOLOR)
$iColor = 0
Else
If BitAND($iColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
DllStructSetData($tCharFormat, 2, $CFM_COLOR)
DllStructSetData($tCharFormat, 6, $iColor)
Return _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetBkColor($hWnd, $iBngColor = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $bSysColor = False
If $iBngColor = Default Then
$bSysColor = True
$iBngColor = 0
Else
If BitAND($iBngColor, 0xff000000) Then Return SetError(1022, 0, False)
EndIf
_SendMessage($hWnd, $EM_SETBKGNDCOLOR, $bSysColor, $iBngColor)
Return True
EndFunc
Func _GUICtrlRichEdit_SetLimitOnText($hWnd, $iNewLimit)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iNewLimit, ">=0") Then Return SetError(102, 0, False)
If $iNewLimit < 65535 Then $iNewLimit = 0
_SendMessage($hWnd, $EM_EXLIMITTEXT, 0, $iNewLimit)
Return True
EndFunc
Func _GUICtrlRichEdit_SetTabStops($hWnd, $vTabStops, $bRedraw = True)
Local Const $iTwipsPerDU = 18.75
Local $tTabStops, $tagTabStops = "", $wParam
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bRedraw) Then Return SetError(103, 0, False)
If IsString($vTabStops) Then
If $vTabStops = "" Then Return SetError(1023, 0, False)
Local $aS = StringSplit($vTabStops, ";")
Local $iNumTabStops = $aS[0]
For $i = 1 To $iNumTabStops
If Not __GCR_IsNumeric($aS[$i], ">0") Then Return SetError(1022, 0, False)
$tagTabStops &= "int;"
Next
$tagTabStops = StringTrimRight($tagTabStops, 1)
$tTabStops = DllStructCreate($tagTabStops)
For $i = 1 To $iNumTabStops
DllStructSetData($tTabStops, $i, $aS[$i] * $__g_iRTFTwipsPeSpaceUnit / $iTwipsPerDU)
Next
$wParam = $iNumTabStops
ElseIf IsNumber($vTabStops) Then
If __GCR_IsNumeric($vTabStops, ">0") Then
$tTabStops = DllStructCreate("int")
DllStructSetData($tTabStops, 1, $vTabStops * $__g_iRTFTwipsPeSpaceUnit / $iTwipsPerDU)
$wParam = 1
Else
Return SetError(1024, 9, False)
EndIf
Else
Return SetError(1021, 0, False)
EndIf
Local $bResult = _SendMessage($hWnd, $EM_SETTABSTOPS, $wParam, $tTabStops, 0, "wparam", "struct*") <> 0
If $bRedraw Then _WinAPI_InvalidateRect($hWnd)
Return $bResult
EndFunc
Func _GUICtrlRichEdit_SetZoom($hWnd, $iPercent)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iPercent, ">0") Then Return SetError(1021, 0, False)
Local $iNumerator, $iDenominator
Select
Case Not ($iPercent = 100 Or ($iPercent >= 200 And $iPercent < 6400))
Return SetError(1022, 0, False)
Case $iPercent >= 100
$iNumerator = 10000
$iDenominator = 10000 / ($iPercent / 100)
Case Else
$iNumerator = 10000 * ($iPercent / 100)
$iDenominator = 10000
EndSelect
Return _SendMessage($hWnd, $EM_SETZOOM, $iNumerator, $iDenominator) <> 0
EndFunc
Func _GUICtrlRichEdit_SetEventMask($hWnd, $iEventMask)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iEventMask) Then Return SetError(102, 0, False)
_SendMessage($hWnd, $EM_SETEVENTMASK, 0, $iEventMask)
Return True
EndFunc
Func _GUICtrlRichEdit_SetFont($hWnd, $iPoints = Default, $sName = Default, $iCharset = Default, $iLcid = Default)
Local $iDwMask = 0
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iPoints = Default Or __GCR_IsNumeric($iPoints, ">0")) Then Return SetError(102, 0, False)
If $sName <> Default Then
Local $aS = StringSplit($sName, " ")
For $i = 1 To UBound($aS) - 1
If Not StringIsAlpha($aS[$i]) Then Return SetError(103, 0, False)
Next
EndIf
If Not ($iCharset = Default Or __GCR_IsNumeric($iCharset)) Then Return SetError(104, 0, False)
If Not ($iLcid = Default Or __GCR_IsNumeric($iLcid)) Then Return SetError(105, 0, False)
Local $tCharFormat = DllStructCreate($tagCHARFORMAT2)
DllStructSetData($tCharFormat, 1, DllStructGetSize($tCharFormat))
If $iPoints <> Default Then
$iDwMask = $CFM_SIZE
DllStructSetData($tCharFormat, 4, Int($iPoints * 20))
EndIf
If $sName <> Default Then
If StringLen($sName) > $LF_FACESIZE - 1 Then SetError(-1, 0, False)
$iDwMask = BitOR($iDwMask, $CFM_FACE)
DllStructSetData($tCharFormat, 9, $sName)
EndIf
If $iCharset <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_CHARSET)
DllStructSetData($tCharFormat, 7, $iCharset)
EndIf
If $iLcid <> Default Then
$iDwMask = BitOR($iDwMask, $CFM_LCID)
DllStructSetData($tCharFormat, 13, $iLcid)
EndIf
DllStructSetData($tCharFormat, 2, $iDwMask)
Local $iRet = _SendMessage($hWnd, $EM_SETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(@error + 200, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetRECT($hWnd, $iLeft = Default, $iTop = Default, $iRight = Default, $iBottom = Default, $bRedraw = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iLeft = Default Or __GCR_IsNumeric($iLeft, ">0")) Then Return SetError(1021, 0, False)
If Not ($iTop = Default Or __GCR_IsNumeric($iTop, ">0")) Then Return SetError(1022, 0, False)
If Not ($iRight = Default Or __GCR_IsNumeric($iRight, ">0")) Then Return SetError(1023, 0, False)
If Not ($iBottom = Default Or __GCR_IsNumeric($iBottom, ">0")) Then Return SetError(1024, 0, False)
If @NumParams = 1 Then
Local $aPos = ControlGetPos($hWnd, "", "")
$iLeft = 2
$iTop = 2
$iRight = $aPos[2]
$iBottom = $aPos[3]
_GUICtrlRichEdit_SetRECT($hWnd, $iLeft, $iTop, $iRight, $iBottom)
Return True
Else
Local $aS = _GUICtrlRichEdit_GetRECT($hWnd)
If $iLeft = Default Then
$iLeft = $aS[0]
EndIf
If $iTop = Default Then
$iTop = $aS[1]
EndIf
If $iRight = Default Then
$iRight = $aS[2]
EndIf
If $iBottom = Default Then
$iBottom = $aS[3]
EndIf
If $iLeft >= $iRight Then Return SetError(1025, 0, False)
If $iTop >= $iBottom Then Return SetError(1026, 0, False)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", Number($iLeft))
DllStructSetData($tRECT, "Top", Number($iTop))
DllStructSetData($tRECT, "Right", Number($iRight))
DllStructSetData($tRECT, "Bottom", Number($iBottom))
Local $iMsg = ($bRedraw ? $EM_SETRECT : $EM_SETRECTNP)
_SendMessage($hWnd, $iMsg, 0, $tRECT, 0, "wparam", "struct*")
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_SetModified($hWnd, $bState = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
_SendMessage($hWnd, $EM_SETMODIFY, $bState)
Return True
EndFunc
Func _GUICtrlRichEdit_SetParaAlignment($hWnd, $sAlignment)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $iAlignment
Switch $sAlignment
Case "l"
$iAlignment = $PFA_LEFT
Case "c"
$iAlignment = $PFA_CENTER
Case "r"
$iAlignment = $PFA_RIGHT
Case "j"
$iAlignment = $PFA_JUSTIFY
Case "w"
$iAlignment = $PFA_FULL_INTERWORD
Case Else
Return SetError(102, 0, False)
EndSwitch
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, 2, $PFM_ALIGNMENT)
DllStructSetData($tParaFormat, 8, $iAlignment)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaAttributes($hWnd, $sStatesAndAtts)
Local Enum $eAbbrev = 0, $eMask, $eEffect, $eInverted
Local Const $aV[9][4] = [  ["fpg", $PFM_PAGEBREAKBEFORE, $PFE_PAGEBREAKBEFORE, False],  ["hyp", $PFM_DONOTHYPHEN, $PFE_DONOTHYPHEN, True],  ["kpt", $PFM_KEEP, $PFE_KEEP, False],  ["kpn", $PFM_KEEPNEXT, $PFE_KEEPNEXT, False],  ["pwo", $PFM_NOWIDOWCONTROL, $PFE_NOWIDOWCONTROL, False],  ["r2l", $PFM_RTLPARA, $PFE_RTLPARA, False],  ["row", $PFM_TABLE, $PFE_TABLE, False],  ["sbs", $PFM_SIDEBYSIDE, $PFE_SIDEBYSIDE, False],  ["sln", $PFM_NOLINENUMBER, $PFE_NOLINENUMBER, False]]
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Mod(StringLen($sStatesAndAtts) + 1, 5) <> 0 Then Return SetError(1023, 0, False)
Local $aS = StringSplit($sStatesAndAtts, ";")
Local $iMask = 0, $iEffects = 0, $s, $n
For $i = 1 To UBound($aS, $UBOUND_ROWS) - 1
$s = StringMid($aS[$i], 2)
$n = -1
For $j = 0 To UBound($aV, $UBOUND_ROWS) - 1
If $aV[$j][$eAbbrev] = $s Then
$n = $j
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(1022, $s, False)
$iMask = BitOR($iMask, $aV[$n][$eMask])
$s = StringLeft($aS[$i], 1)
Switch $s
Case "+"
If Not $aV[$n][$eInverted] Then
$iEffects = BitOR($iEffects, $aV[$n][$eEffect])
EndIf
Case "-"
If $aV[$n][$eInverted] Then
$iEffects = BitOR($iEffects, $aV[$n][$eEffect])
EndIf
Case Else
Return SetError(1021, $s, False)
EndSwitch
Next
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, 2, $iMask)
DllStructSetData($tParaFormat, 4, $iEffects)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaBorder($hWnd, $sLocation = Default, $vLineStyle = Default, $sColor = Default, $iSpace = Default)
Local $iBorders
Local Const $avLocs[6][2] = [["l", 1], ["r", 2], ["t", 4], ["b", 8], ["i", 16], ["o", 32]]
Local Const $avLS[12] = ["none", .75, 1.5, 2.25, 3, 4.5, 6, ".75d", "1.5d", "2.25d", ".75g", ".75gd"]
Local Const $sClrs = ";blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;aut;"
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iSpace = Default Or __GCR_IsNumeric($iSpace, ">=0")) Then Return SetError(105, 0, False)
If $sLocation = "" Then
$iBorders = 0
$iSpace = 0
Else
If $sLocation = Default Or $vLineStyle = Default Or $sColor = Default Or $iSpace = Default Then
Local $aS = StringSplit(_GUICtrlRichEdit_GetParaBorder($hWnd), ";")
If $sLocation = Default Then $sLocation = $aS[1]
If $vLineStyle = Default Then $vLineStyle = $aS[2]
If $sColor = Default Then $sColor = $aS[3]
If $iSpace = Default Then $iSpace = $aS[4]
EndIf
Local $iLoc = 0, $n, $s
For $i = 1 To StringLen($sLocation)
$s = StringMid($sLocation, $i, 1)
$n = -1
For $j = 0 To UBound($avLocs, $UBOUND_ROWS) - 1
If $avLocs[$j][0] = $s Then
$n = $j
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(102, $s, False)
$iLoc = BitOR($iLoc, $avLocs[$n][1])
Next
$n = -1
For $i = 0 To UBound($avLS, $UBOUND_ROWS) - 1
If $vLineStyle = $avLS[$i] Then
$n = $i
ExitLoop
EndIf
Next
If $n = -1 Then Return SetError(103, 0, False)
Local $iLineStyle = $n
$n = StringInStr($sClrs, ";" & $sColor & ";")
If $n = 0 Then Return SetError(104, 0, False)
Local $iColor = Int($n / 4)
If $iColor = 16 Then
$iLoc = BitOR($iLoc, 64)
$iColor = 0
EndIf
$iBorders = $iLoc + BitShift($iLineStyle, -8) + BitShift($iColor, -12)
EndIf
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "wBorderSpace", $iSpace * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, "wBorders", $iBorders)
DllStructSetData($tParaFormat, "dwMask", $PFM_BORDER)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaIndents($hWnd, $vLeft = Default, $iRight = Default, $iFirstLine = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($vLeft = Default Or __GCR_IsNumeric($vLeft)) Then Return SetError(1021, 0, False)
If Not ($iRight = Default Or __GCR_IsNumeric($iRight, ">=0")) Then Return SetError(103, 0, False)
If Not ($iFirstLine = Default Or __GCR_IsNumeric($iFirstLine)) Then Return SetError(104, 0, False)
Local $s = _GUICtrlRichEdit_GetParaIndents($hWnd)
Local $aS = StringSplit($s, ";")
If $vLeft = Default Then $vLeft = $aS[1]
If $iRight = Default Then $iRight = $aS[2]
If $iFirstLine = Default Then $iFirstLine = $aS[3]
If $vLeft < 0 Then Return SetError(1022, 0, False)
If $vLeft + $iFirstLine < 0 Then Return SetError(200, 0, False)
If StringInStr("+-", StringLeft($vLeft, 1)) <> 0 Then $vLeft = $aS[1] + $vLeft
Local $iIdxSI = $vLeft + $iFirstLine
Local $iIdxOfs = -$iFirstLine
Local $tParaFormat = DllStructCreate($tagPARAFORMAT)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "dxStartIndent", $iIdxSI * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, "dxOffset", $iIdxOfs * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, "dxRightIndent", $iRight * $__g_iRTFTwipsPeSpaceUnit)
DllStructSetData($tParaFormat, 2, BitOR($PFM_STARTINDENT, $PFM_OFFSET, $PFM_RIGHTINDENT))
Local $iRet = _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetParaNumbering($hWnd, $sStyle, $iTextToNbrSpace = Default, $bForceRoman = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iTextToNbrSpace = Default Or __GCR_IsNumeric($iTextToNbrSpace, ">0")) Then Return SetError(103, 0, False)
If Not IsBool($bForceRoman) Then Return SetError(104, 0, False)
Local $iPFM, $iWNumbering, $iWnumStart, $iWnumStyle, $iQspaces
__GCR_ParseParaNumberingStyle($sStyle, $bForceRoman, $iPFM, $iWNumbering, $iWnumStart, $iWnumStyle, $iQspaces)
If @error Then Return SetError(@error, 0, False)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, 1, DllStructGetSize($tParaFormat))
If BitAND($iPFM, $PFM_NUMBERING) Then DllStructSetData($tParaFormat, 3, $iWNumbering)
If BitAND($iPFM, $PFM_NUMBERINGSTART) Then DllStructSetData($tParaFormat, 19, $iWnumStart)
If BitAND($iPFM, $PFM_NUMBERINGSTYLE) Then DllStructSetData($tParaFormat, 20, $iWnumStyle)
If BitAND($iPFM, $PFM_NUMBERINGTAB) Then
Local $iTwips
If $iTextToNbrSpace = Default Then
Local $aV = _GUICtrlRichEdit_GetFont($hWnd)
Local $iPoints = $aV[0]
$iTwips = $iQspaces * $iPoints * 20
Else
$iTwips = $iTextToNbrSpace * $__g_iRTFTwipsPeSpaceUnit
EndIf
DllStructSetData($tParaFormat, 21, $iTwips)
EndIf
DllStructSetData($tParaFormat, 2, $iPFM)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetParaShading($hWnd, $iWeight = Default, $sStyle = Default, $sForeColor = Default, $sBackColor = Default)
Local $iS = 0
Local Const $sStyles = ";non;dhz;dvt;ddd;dud;dgr;dtr;lhz;lrt;ldd;lud;lgr;ltr;"
Local Const $sClrs = ";blk;blu;cyn;grn;mag;red;yel;whi;dbl;dgn;dmg;drd;dyl;dgy;lgy;"
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iWeight = Default Or __GCR_IsNumeric($iWeight, ">=0")) Then Return SetError(1021, 0, False)
If $iWeight <> Default Or $sStyle <> Default Or $sForeColor <> Default Or $sBackColor <> Default Then
Local $aS = StringSplit(_GUICtrlRichEdit_GetParaShading($hWnd), ";")
If $iWeight = Default Then $iWeight = $aS[1]
If $sStyle = Default Then $sStyle = $aS[2]
If $sForeColor = Default Then $sForeColor = $aS[3]
If $sBackColor = Default Then $sBackColor = $aS[4]
EndIf
If $iWeight < 0 Or $iWeight > 100 Then Return SetError(1022, 0, False)
Local $iN = StringInStr($sStyles, ";" & $sStyle & ";")
If $iN = 0 Then Return SetError(103, 0, False)
Local $iStyle = Int($iN / 4)
Local $iFore = BitShift(BitAND($iS, 0xF0), 4)
$iN = StringInStr($sClrs, ";" & $sForeColor & ";")
If $iN = 0 Then Return SetError(104, 0, False)
$iFore = Int($iN / 4)
$iN = StringInStr($sClrs, ";" & $sBackColor & ";")
If $iN = 0 Then Return SetError(105, 0, False)
Local $iBack = Int($iN / 4)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
DllStructSetData($tParaFormat, "wShadingWeight", $iWeight)
$iN = $iStyle + BitShift($iFore, -4) + BitShift($iBack, -8)
DllStructSetData($tParaFormat, "wShadingStyle", $iN)
DllStructSetData($tParaFormat, "dwMask", $PFM_SHADING)
Local $iRet = _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetParaSpacing($hWnd, $vInter = Default, $iBefore = Default, $iAfter = Default)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not ($iBefore = Default Or __GCR_IsNumeric($iBefore, ">=0")) Then Return SetError(103, 0, False)
If Not ($iAfter = Default Or __GCR_IsNumeric($iAfter, ">=0")) Then Return SetError(104, 0, False)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
Local $iMask = 0
If $vInter <> Default Then
$vInter = StringStripWS($vInter, $STR_STRIPALL)
Local $iP = StringInStr($vInter, "line", 2)
If $iP <> 0 Then
$vInter = StringLeft($vInter, $iP - 1)
EndIf
If Not __GCR_IsNumeric($vInter, ">=0") Then Return SetError(1021, 0, False)
Local $iRule, $iLnSp = 0
If $iP <> 0 Then
Switch $vInter
Case 1
$iRule = 0
Case 1.5
$iRule = 1
Case 2
$iRule = 2
Case Else
If $vInter < 1 Then Return SetError(1022, 0, False)
$iRule = 5
$iLnSp = $vInter * 20
EndSwitch
Else
$iRule = 4
$iLnSp = $vInter * $__g_iRTFTwipsPeSpaceUnit
EndIf
$iMask = $PFM_LINESPACING
DllStructSetData($tParaFormat, "bLineSpacingRule", $iRule)
If $iLnSp <> 0 Then DllStructSetData($tParaFormat, 13, $iLnSp)
EndIf
If $iBefore <> Default Then
$iMask = BitOR($iMask, $PFM_SPACEBEFORE)
DllStructSetData($tParaFormat, "dySpaceBefore", $iBefore * $__g_iRTFTwipsPeSpaceUnit)
EndIf
If $iAfter <> Default Then
$iMask = BitOR($iMask, $PFM_SPACEAFTER)
DllStructSetData($tParaFormat, "dySpaceAfter", $iAfter * $__g_iRTFTwipsPeSpaceUnit)
EndIf
If $iMask <> 0 Then
DllStructSetData($tParaFormat, "dwMask", $iMask)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
Else
Return True
EndIf
EndFunc
Func _GUICtrlRichEdit_SetParaTabStops($hWnd, $sTabStops)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tParaFormat = DllStructCreate($tagPARAFORMAT2)
DllStructSetData($tParaFormat, "cbSize", DllStructGetSize($tParaFormat))
If $sTabStops = "" Then
DllStructSetData($tParaFormat, "cTabCount", 0)
Else
Local $asTabs = StringSplit($sTabStops, ";")
If $asTabs[0] > $MAX_TAB_STOPS Then Return SetError(1021, 0, False)
Local $asAtab, $i, $s, $iN, $iP
For $iTab = 1 To $asTabs[0]
$asAtab = StringSplit($asTabs[$iTab], "")
$i = 1
While $i <= $asAtab[0] And StringInStr("01234567890.", $asAtab[$i]) <> 0
$i += 1
WEnd
If $i = 1 Then Return SetError(1021, $iTab, False)
$s = StringLeft($asTabs[$iTab], $i - 1)
If Not __GCR_IsNumeric($s, ">=0") Then Return SetError(1021, $iTab, False)
$iN = $s * $__g_iRTFTwipsPeSpaceUnit
If $i <= $asAtab[0] Then
$iP = StringInStr("lcrdb", $asAtab[$i])
If $iP = 0 Then Return SetError(1022, $iTab, False)
$iN = BitOR($iN, BitShift($iP - 1, -24))
EndIf
$i += 1
If $i <= $asAtab[0] Then
$iP = StringInStr(" .-_t=", $asAtab[$i])
If $iP = 0 Then Return SetError(1023, $iTab, False)
$iN = BitOR($iN, BitShift($iP - 1, -28))
EndIf
DllStructSetData($tParaFormat, "rgxTabs", $iN, $iTab)
Next
DllStructSetData($tParaFormat, "cTabCount", $asTabs[0])
EndIf
DllStructSetData($tParaFormat, "dwMask", $PFM_TABSTOPS)
Return _SendMessage($hWnd, $EM_SETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetPasswordChar($hWnd, $sDisplayChar = "*")
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsString($sDisplayChar) Then SetError(102, 0, False)
If $sDisplayChar = "" Then
_SendMessage($hWnd, $EM_SETPASSWORDCHAR)
Else
_SendMessage($hWnd, $EM_SETPASSWORDCHAR, Asc($sDisplayChar))
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_SetReadOnly($hWnd, $bState = True)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not IsBool($bState) Then Return SetError(102, 0, False)
Local $iRet = _SendMessage($hWnd, $EM_SETREADONLY, $bState)
If $iRet = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetScrollPos($hWnd, $iX, $iY)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iX, ">=0") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iY, ">=0") Then Return SetError(103, 0, False)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, 1, $iX)
DllStructSetData($tPoint, 2, $iY)
Return _SendMessage($hWnd, $EM_SETSCROLLPOS, 0, $tPoint, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlRichEdit_SetSel($hWnd, $iAnchor, $iActive, $bHideSel = False)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iAnchor, ">=0,-1") Then Return SetError(102, 0, False)
If Not __GCR_IsNumeric($iActive, ">=0,-1") Then Return SetError(103, 0, False)
If Not IsBool($bHideSel) Then Return SetError(104, 0, False)
_SendMessage($hWnd, $EM_SETSEL, $iAnchor, $iActive)
If $bHideSel Then _SendMessage($hWnd, $EM_HIDESELECTION, $bHideSel)
_WinAPI_SetFocus($hWnd)
Return True
EndFunc
Func _GUICtrlRichEdit_SetSpaceUnit($sUnit)
Switch StringLower($sUnit)
Case "in"
$__g_iRTFTwipsPeSpaceUnit = 1440
Case "cm"
$__g_iRTFTwipsPeSpaceUnit = 567
Case "mm"
$__g_iRTFTwipsPeSpaceUnit = 56.7
Case "pt"
$__g_iRTFTwipsPeSpaceUnit = 20
Case "tw"
$__g_iRTFTwipsPeSpaceUnit = 1
Case Else
Return SetError(1, 0, False)
EndSwitch
Return True
EndFunc
Func _GUICtrlRichEdit_SetText($hWnd, $sText)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tSetText = DllStructCreate($tagSETTEXTEX)
DllStructSetData($tSetText, 1, $ST_DEFAULT)
DllStructSetData($tSetText, 2, $CP_ACP)
Local $iRet
If StringLeft($sText, 5) <> "{\rtf" And StringLeft($sText, 5) <> "{urtf" Then
DllStructSetData($tSetText, 2, $CP_UNICODE)
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "wstr")
Else
$iRet = _SendMessage($hWnd, $EM_SETTEXTEX, $tSetText, $sText, 0, "struct*", "STR")
EndIf
If Not $iRet Then Return SetError(700, 0, False)
Return True
EndFunc
Func _GUICtrlRichEdit_SetUndoLimit($hWnd, $iLimit)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
If Not __GCR_IsNumeric($iLimit, ">=0") Then Return SetError(102, 0, False)
Return _SendMessage($hWnd, $EM_SETUNDOLIMIT, $iLimit) <> 0 Or $iLimit = 0
EndFunc
Func _GUICtrlRichEdit_StreamFromFile($hWnd, $sFileSpec)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamFromFileCallback))
Local $hFile = FileOpen($sFileSpec, $FO_READ)
If $hFile = -1 Then Return SetError(1021, 0, False)
Local $sBuf = FileRead($hFile, 5)
FileClose($hFile)
$hFile = FileOpen($sFileSpec, $FO_READ)
DllStructSetData($tEditStream, "dwCookie", $hFile)
Local $wParam = ($sBuf == "{\rtf" Or $sBuf == "{urtf") ? $SF_RTF : $SF_TEXT
$wParam = BitOR($wParam, $SFF_SELECTION)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
_GUICtrlRichEdit_SetText($hWnd, "")
EndIf
Local $iQchs = _SendMessage($hWnd, $EM_STREAMIN, $wParam, $tEditStream, 0, "wparam", "struct*")
FileClose($hFile)
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 1 Then SetError(700, $iError, False)
If $iQchs = 0 Then
If FileGetSize($sFileSpec) = 0 Then Return SetError(1022, 0, False)
Return SetError(700, $iError, False)
EndIf
Return True
EndFunc
Func _GUICtrlRichEdit_StreamFromVar($hWnd, $sVar)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamFromVarCallback))
$__g_pGRC_sStreamVar = $sVar
Local $s = StringLeft($sVar, 5)
Local $wParam = ($s == "{\rtf" Or $s == "{urtf") ? $SF_RTF : $SF_TEXT
$wParam = BitOR($wParam, $SFF_SELECTION)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
_GUICtrlRichEdit_SetText($hWnd, "")
EndIf
_SendMessage($hWnd, $EM_STREAMIN, $wParam, $tEditStream, 0, "wparam", "struct*")
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 1 Then Return SetError(700, $iError, False)
Return True
EndFunc
Func _GUICtrlRichEdit_StreamToFile($hWnd, $sFileSpec, $bIncludeCOM = True, $iOpts = 0, $iCodePage = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Local $wParam
If StringRight($sFileSpec, 4) = ".rtf" Then
$wParam = ($bIncludeCOM ? $SF_RTF : $SF_RTFNOOBJS)
Else
$wParam = ($bIncludeCOM ? $SF_TEXTIZED : $SF_TEXT)
If BitAND($iOpts, $SFF_PLAINRTF) Then Return SetError(1041, 0, False)
EndIf
If BitAND($iOpts, BitNOT(BitOR($SFF_PLAINRTF, $SF_UNICODE))) Then Return SetError(1042, 0, False)
If BitAND($iOpts, $SF_UNICODE) Then
If Not BitAND($wParam, $SF_TEXT) Then Return SetError(1043, 0, False)
EndIf
If _GUICtrlRichEdit_IsTextSelected($hWnd) Then $wParam = BitOR($wParam, $SFF_SELECTION)
$wParam = BitOR($wParam, $iOpts)
If $iCodePage <> 0 Then
$wParam = BitOR($wParam, $SF_USECODEPAGE, BitShift($iCodePage, -16))
EndIf
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamToFileCallback))
Local $hFile = FileOpen($sFileSpec, $FO_OVERWRITE)
If $hFile = -1 Then Return SetError(102, 0, False)
DllStructSetData($tEditStream, "dwCookie", $hFile)
_SendMessage($hWnd, $EM_STREAMOUT, $wParam, $tEditStream, 0, "wparam", "struct*")
FileClose($hFile)
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then SetError(700, $iError, False)
Return True
EndFunc
Func _GUICtrlRichEdit_StreamToVar($hWnd, $bRtf = True, $bIncludeCOM = True, $iOpts = 0, $iCodePage = 0)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, "")
Local $wParam
If $bRtf Then
$wParam = ($bIncludeCOM ? $SF_RTF : $SF_RTFNOOBJS)
Else
$wParam = ($bIncludeCOM ? $SF_TEXTIZED : $SF_TEXT)
If BitAND($iOpts, $SFF_PLAINRTF) Then Return SetError(1041, 0, "")
EndIf
If BitAND($iOpts, BitNOT(BitOR($SFF_PLAINRTF, $SF_UNICODE))) Then Return SetError(1042, 0, "")
If BitAND($iOpts, $SF_UNICODE) Then
If Not BitAND($wParam, $SF_TEXT) Then Return SetError(1043, 0, "")
EndIf
If _GUICtrlRichEdit_IsTextSelected($hWnd) Then $wParam = BitOR($wParam, $SFF_SELECTION)
$wParam = BitOR($wParam, $iOpts)
If $iCodePage <> 0 Then
$wParam = BitOR($wParam, $SF_USECODEPAGE, BitShift($iCodePage, -16))
EndIf
Local $tEditStream = DllStructCreate($tagEDITSTREAM)
DllStructSetData($tEditStream, "pfnCallback", DllCallbackGetPtr($__g_pGRC_StreamToVarCallback))
$__g_pGRC_sStreamVar = ""
_SendMessage($hWnd, $EM_STREAMOUT, $wParam, $tEditStream, 0, "wparam", "struct*")
Local $iError = DllStructGetData($tEditStream, "dwError")
If $iError <> 0 Then SetError(700, $iError, "")
Return $__g_pGRC_sStreamVar
EndFunc
Func _GUICtrlRichEdit_Undo($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__g_sRTFClassName) Then Return SetError(101, 0, False)
Return _SendMessage($hWnd, $EM_UNDO, 0, 0) <> 0
EndFunc
Func __GCR_Init()
Local $ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "MSFTEDIT.DLL")
If $ah_GUICtrlRTF_lib[0] <> 0 Then
$__g_sRTFClassName = "RichEdit50W"
$__g_sRTFVersion = 4.1
Else
$ah_GUICtrlRTF_lib = DllCall("kernel32.dll", "ptr", "LoadLibraryW", "wstr", "RICHED20.DLL")
$__g_sRTFVersion = FileGetVersion(@SystemDir & "\riched20.dll", "ProductVersion")
Switch $__g_sRTFVersion
Case 3.0
$__g_sRTFClassName = "RichEdit20W"
Case 5.0
$__g_sRTFClassName = "RichEdit50W"
Case 6.0
$__g_sRTFClassName = "RichEdit60W"
EndSwitch
EndIf
$__g_sGRE_CF_RTF = _ClipBoard_RegisterFormat("Rich Text Format")
$__g_sGRE_CF_RETEXTOBJ = _ClipBoard_RegisterFormat("Rich Text Format with Objects")
EndFunc
Func __GCR_StreamFromFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sBuf = FileRead($hFile, $iBuflen - 1)
If @error Then Return 1
DllStructSetData($tBuf, 1, $sBuf)
DllStructSetData($tQbytes, 1, StringLen($sBuf))
Return 0
EndFunc
Func __GCR_StreamFromVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tCtl = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $sCtl = StringLeft($__g_pGRC_sStreamVar, $iBuflen - 1)
If $sCtl = "" Then Return 1
DllStructSetData($tCtl, 1, $sCtl)
Local $iLen = StringLen($sCtl)
DllStructSetData($tQbytes, 1, $iLen)
$__g_pGRC_sStreamVar = StringMid($__g_pGRC_sStreamVar, $iLen + 1)
Return 0
EndFunc
Func __GCR_StreamToFileCallback($hFile, $pBuf, $iBuflen, $pQbytes)
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
FileWrite($hFile, $s)
DllStructSetData($tQbytes, 1, StringLen($s))
Return 0
EndFunc
Func __GCR_StreamToVarCallback($iCookie, $pBuf, $iBuflen, $pQbytes)
#forceref $iCookie
Local $tQbytes = DllStructCreate("long", $pQbytes)
DllStructSetData($tQbytes, 1, 0)
Local $tBuf = DllStructCreate("char[" & $iBuflen & "]", $pBuf)
Local $s = DllStructGetData($tBuf, 1)
$__g_pGRC_sStreamVar &= $s
Return 0
EndFunc
Func __GCR_ConvertTwipsToSpaceUnit($nIn)
Local $sRet
Switch $__g_iRTFTwipsPeSpaceUnit
Case 1440, 567
$sRet = StringFormat("%.2f", $nIn / $__g_iRTFTwipsPeSpaceUnit)
If $sRet = "-0.00" Then $sRet = "0.00"
Case 56.7, 72
$sRet = StringFormat("%.1f", $nIn / $__g_iRTFTwipsPeSpaceUnit)
If $sRet = "-0.0" Then $sRet = "0.0"
Case Else
$sRet = $nIn
EndSwitch
Return $sRet
EndFunc
Func __GCR_IsNumeric($vN, $sRange = "")
If Not (IsNumber($vN) Or StringIsInt($vN) Or StringIsFloat($vN)) Then Return False
Switch $sRange
Case ">0"
If $vN <= 0 Then Return False
Case ">=0"
If $vN < 0 Then Return False
Case ">0,-1"
If Not ($vN > 0 Or $vN = -1) Then Return False
Case ">=0,-1"
If Not ($vN >= 0 Or $vN = -1) Then Return False
EndSwitch
Return True
EndFunc
Func __GCR_GetParaScopeChar($hWnd, $iMask, $iPFM)
If Not _GUICtrlRichEdit_IsTextSelected($hWnd) Then
Return "c"
ElseIf BitAND($iMask, $iPFM) = $iPFM Then
Return "a"
Else
Return "f"
EndIf
EndFunc
Func __GCR_ParseParaNumberingStyle($sIn, $bForceRoman, ByRef $iPFM, ByRef $iWNumbering, ByRef $iWnumStart, ByRef $iWnumStyle, ByRef $iQspaces)
Local Const $sRoman = "mdclxviMDCLXVI", $iRpar = 0, $i2par = 0x100, $iPeriod = 0x200, $iNbrOnly = 0x300
If $sIn = "" Then
$iWNumbering = 0
$iPFM = $PFM_NUMBERING
Else
Local $s = StringStripWS($sIn, $STR_STRIPTRAILING)
$iQspaces = StringLen($sIn) - StringLen($s)
$sIn = $s
$iPFM = $PFM_NUMBERINGTAB
If $sIn = "." Then
$iWNumbering = $PFN_BULLET
$iPFM = BitOR($iPFM, $PFM_NUMBERING)
ElseIf $sIn = "=" Then
$iWnumStyle = 0x400
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTYLE)
Else
Switch StringRight($sIn, 1)
Case ")"
If StringLeft($sIn, 1) = "(" Then
$iWnumStyle = $i2par
$sIn = StringTrimLeft($sIn, 1)
Else
$iWnumStyle = $iRpar
EndIf
Case "."
$iWnumStyle = $iPeriod
Case Else
$iWnumStyle = $iNbrOnly
EndSwitch
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTYLE)
If $iWnumStyle <> 0x300 Then $sIn = StringTrimRight($sIn, 1)
If StringIsDigit($sIn) Then
$iWnumStart = Number($sIn)
$iWNumbering = 2
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
Else
Local $bMayBeRoman = True
For $i = 1 To StringLen($sIn)
If Not StringInStr($sRoman, StringMid($sIn, $i, 1)) Then
$bMayBeRoman = False
ExitLoop
EndIf
Next
Local $bIsRoman
If $bMayBeRoman Then
$bIsRoman = $bForceRoman
Else
$bIsRoman = False
EndIf
Switch True
Case $bIsRoman
$iWnumStart = __GCR_ConvertRomanToNumber($sIn)
If $iWnumStart = -1 Then Return SetError(102, 0, False)
$iWNumbering = (StringIsLower($sIn) ? 5 : 6)
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
Case StringIsAlpha($sIn)
If StringIsLower($sIn) Then
$iWNumbering = 3
Else
$iWNumbering = 4
$sIn = StringLower($sIn)
EndIf
$iWnumStart = 0
Local $iN
For $iP = 1 To StringLen($sIn)
$iN = Asc(StringMid($sIn, $i))
If $iN >= Asc("a") And $iN <= Asc("z") Then
$iWnumStart = $iWnumStart * 26 + ($iN - Asc("a") + 1)
EndIf
Next
$iPFM = BitOR($iPFM, $PFM_NUMBERINGSTART, $PFM_NUMBERING)
Case Else
Return SetError(102, 0, False)
EndSwitch
EndIf
EndIf
EndIf
Return True
EndFunc
Func __GCR_ConvertRomanToNumber($sRnum)
Local Enum $e9, $e5, $e4, $e1, $eMult, $eHigher
Local Const $aV[3][6] = [["cm", "d", "cd", "c", 100, "m"], ["xc", "l", "xl", "x", 10, "mdc"], ["ix", "v", "iv", "i", 1, "mdclx"]]
$sRnum = StringLower($sRnum)
Local $i = 1
While StringMid($sRnum, $i, 1) = "m"
$i += 1
WEnd
Local $iDigit, $iQ1s, $iRet = ($i - 1) * 1000
For $j = 0 To 2
$iDigit = 0
If StringMid($sRnum, $i, 2) = $aV[$j][$e9] Then
$iDigit = 9
$i += 2
ElseIf StringMid($sRnum, $i, 1) = $aV[$j][$e5] Then
$iDigit = 5
$i += 1
ElseIf StringMid($sRnum, $i, 2) = $aV[$j][$e4] Then
$iDigit = 4
$i += 2
ElseIf StringInStr($aV[$j][$eHigher], StringMid($sRnum, $i, 1)) Then
Return -1
EndIf
If $iDigit = 0 Or $iDigit = 5 Then
$iQ1s = 0
While StringMid($sRnum, $i, 1) = $aV[$j][$e1]
$iQ1s += 1
If $iQ1s > 3 Then Return 0
$i += 1
WEnd
$iDigit += $iQ1s
EndIf
$iRet += $iDigit * $aV[$j][$eMult]
Next
If $i <= StringLen($sRnum) Then Return -1
Return $iRet
EndFunc
Func __GCR_SendGetCharFormatMessage($hWnd, $tCharFormat)
Return _SendMessage($hWnd, $EM_GETCHARFORMAT, $SCF_SELECTION, $tCharFormat, 0, "wparam", "struct*")
EndFunc
Func __GCR_SendGetParaFormatMessage($hWnd, $tParaFormat)
Local $bIsSel = _GUICtrlRichEdit_IsTextSelected($hWnd)
Local $iInsPt = 0
If Not $bIsSel Then
Local $aS = _GUICtrlRichEdit_GetSel($hWnd)
$iInsPt = $aS[0]
Local $iN = _GUICtrlRichEdit_GetFirstCharPosOnLine($hWnd)
_GUICtrlRichEdit_SetSel($hWnd, $iN, $iN + 1, True)
EndIf
_SendMessage($hWnd, $EM_GETPARAFORMAT, 0, $tParaFormat, 0, "wparam", "struct*")
If @error Then Return SetError(@error, @extended, False)
If Not $bIsSel Then _GUICtrlRichEdit_SetSel($hWnd, $iInsPt, $iInsPt)
Return True
EndFunc
Func __GCR_SetOLECallback($hWnd)
If Not IsHWnd($hWnd) Then Return SetError(101, 0, False)
If Not $__g_pObj_RichCom Then
$__g_tCall_RichCom = DllStructCreate("ptr[20]")
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInterface), 1)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_AddRef), 2)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_Release), 3)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetNewStorage), 4)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetInPlaceContext), 5)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ShowContainerUI), 6)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryInsertObject), 7)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_DeleteObject), 8)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_QueryAcceptData), 9)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_ContextSensitiveHelp), 10)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetClipboardData), 11)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetDragDropEffect), 12)
DllStructSetData($__g_tCall_RichCom, 1, DllCallbackGetPtr($__g_pRichCom_Object_GetContextMenu), 13)
DllStructSetData($__g_tObj_RichComObject, 1, DllStructGetPtr($__g_tCall_RichCom))
DllStructSetData($__g_tObj_RichComObject, 2, 1)
$__g_pObj_RichCom = DllStructGetPtr($__g_tObj_RichComObject)
EndIf
Local Const $EM_SETOLECALLBACK = 0x400 + 70
If _SendMessage($hWnd, $EM_SETOLECALLBACK, 0, $__g_pObj_RichCom) = 0 Then Return SetError(700, 0, False)
Return True
EndFunc
Func __RichCom_Object_QueryInterface($pObject, $iREFIID, $pPvObj)
#forceref $pObject, $iREFIID, $pPvObj
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_AddRef($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
DllStructSetData($tData, 2, DllStructGetData($tData, 2) + 1)
Return DllStructGetData($tData, 2)
EndFunc
Func __RichCom_Object_Release($pObject)
Local $tData = DllStructCreate("ptr;dword", $pObject)
If DllStructGetData($tData, 2) > 0 Then
DllStructSetData($tData, 2, DllStructGetData($tData, 2) - 1)
Return DllStructGetData($tData, 2)
EndIf
EndFunc
Func __RichCom_Object_GetInPlaceContext($pObject, $pPFrame, $pPDoc, $pFrameInfo)
#forceref $pObject, $pPFrame, $pPDoc, $pFrameInfo
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_ShowContainerUI($pObject, $bShow)
#forceref $pObject, $bShow
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryInsertObject($pObject, $pClsid, $tStg, $vCp)
#forceref $pObject, $pClsid, $tStg, $vCp
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_DeleteObject($pObject, $pOleobj)
#forceref $pObject, $pOleobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_QueryAcceptData($pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict)
#forceref $pObject, $pDataobj, $pCfFormat, $vReco, $bReally, $hMetaPict
Return $_GCR_S_OK
EndFunc
Func __RichCom_Object_ContextSensitiveHelp($pObject, $bEnterMode)
#forceref $pObject, $bEnterMode
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetClipboardData($pObject, $pChrg, $vReco, $pPdataobj)
#forceref $pObject, $pChrg, $vReco, $pPdataobj
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetDragDropEffect($pObject, $bDrag, $iGrfKeyState, $piEffect)
#forceref $pObject, $bDrag, $iGrfKeyState, $piEffect
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetContextMenu($pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu)
#forceref $pObject, $iSeltype, $pOleobj, $pChrg, $pHmenu
Return $_GCR_E_NOTIMPL
EndFunc
Func __RichCom_Object_GetNewStorage($pObject, $pPstg)
#forceref $pObject
Local $aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "CreateILockBytesOnHGlobal", "hwnd", 0, "int", 1, "ptr*", 0)
Local $pLockBytes = $aSc[3]
$aSc = $aSc[0]
If $aSc Then Return $aSc
$aSc = DllCall($__g_hLib_RichCom_OLE32, "dword", "StgCreateDocfileOnILockBytes", "ptr", $pLockBytes, "dword", BitOR(0x10, 2, 0x1000), "dword", 0, "ptr*", 0)
Local $tStg = DllStructCreate("ptr", $pPstg)
DllStructSetData($tStg, 1, $aSc[4])
$aSc = $aSc[0]
If $aSc Then
Local $tObj = DllStructCreate("ptr", $pLockBytes)
Local $tUnknownFuncTable = DllStructCreate("ptr[3]", DllStructGetData($tObj, 1))
Local $pReleaseFunc = DllStructGetData($tUnknownFuncTable, 3)
DllCallAddress("long", $pReleaseFunc, "ptr", $pLockBytes)
EndIf
Return $aSc
EndFunc
Global Const $INET_LOCALCACHE = 0
Global Const $INET_FORCERELOAD = 1
Global Const $INET_IGNORESSL = 2
Global Const $INET_ASCIITRANSFER = 4
Global Const $INET_BINARYTRANSFER = 8
Global Const $INET_FORCEBYPASS = 16
Global Const $INET_DOWNLOADWAIT = 0
Global Const $INET_DOWNLOADBACKGROUND = 1
Global Const $INET_DOWNLOADREAD = 0
Global Const $INET_DOWNLOADSIZE = 1
Global Const $INET_DOWNLOADCOMPLETE = 2
Global Const $INET_DOWNLOADSUCCESS = 3
Global Const $INET_DOWNLOADERROR = 4
Global Const $INET_DOWNLOADEXTENDED = 5
Func _GetIP()
Local Const $GETIP_TIMER = 300000
Local Static $hTimer = 0
Local Static $sLastIP = 0
If TimerDiff($hTimer) < $GETIP_TIMER And Not $sLastIP Then
Return SetExtended(1, $sLastIP)
EndIf
Local $aGetIPURL[] = ["http://checkip.dyndns.org", "http://www.myexternalip.com/raw", "http://bot.whatismyipaddress.com"],  $aReturn = 0,  $sReturn = ""
For $i = 0 To UBound($aGetIPURL) - 1
$sReturn = InetRead($aGetIPURL[$i])
If @error Or $sReturn == "" Then ContinueLoop
$aReturn = StringRegExp(BinaryToString($sReturn), "((?:\d{1,3}\.){3}\d{1,3})", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$sReturn = $aReturn[0]
ExitLoop
EndIf
$sReturn = ""
Next
$hTimer = TimerInit()
$sLastIP = $sReturn
If $sReturn == "" Then Return SetError(1, 0, -1)
Return $sReturn
EndFunc
Func _INetExplorerCapable($sIEString)
If StringLen($sIEString) <= 0 Then Return SetError(1, 0, '')
Local $s_IEReturn
Local $n_IEChar
For $i_IECount = 1 To StringLen($sIEString)
$n_IEChar = '0x' & Hex(Asc(StringMid($sIEString, $i_IECount, 1)), 2)
If $n_IEChar < 0x21 Or $n_IEChar = 0x25 Or $n_IEChar = 0x2f Or $n_IEChar > 0x7f Then
$s_IEReturn = $s_IEReturn & '%' & StringRight($n_IEChar, 2)
Else
$s_IEReturn = $s_IEReturn & Chr($n_IEChar)
EndIf
Next
Return $s_IEReturn
EndFunc
Func _INetGetSource($sURL, $bString = True)
Local $sString = InetRead($sURL, $INET_FORCERELOAD)
Local $iError = @error, $iExtended = @extended
If $bString = Default Or $bString Then $sString = BinaryToString($sString)
Return SetError($iError, $iExtended, $sString)
EndFunc
Func _INetMail($sMailTo, $sMailSubject, $sMailBody)
Local $iPrev = Opt("ExpandEnvStrings", 1)
Local $sVar, $sDflt = RegRead('HKCU\Software\Clients\Mail', "")
If $sDflt = "Windows Live Mail" Then
$sVar = RegRead('HKCR\WLMail.Url.Mailto\Shell\open\command', "")
Else
$sVar = RegRead('HKCR\mailto\shell\open\command', "")
EndIf
Local $iRet = Run(StringReplace($sVar, '%1', _INetExplorerCapable('mailto:' & $sMailTo & '?subject=' & $sMailSubject & '&body=' & $sMailBody)))
Local $iError = @error, $iExtended = @extended
Opt("ExpandEnvStrings", $iPrev)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Func _INetSmtpMail($sSMTPServer, $sFromName, $sFromAddress, $sToAddress, $sSubject = "", $aBody = "", $sEHLO = "", $sFirst = "", $bTrace = 0)
If $sSMTPServer = "" Or $sFromAddress = "" Or $sToAddress = "" Or $sFromName = "" Or StringLen($sFromName) > 256 Then Return SetError(1, 0, 0)
If $sEHLO = "" Then $sEHLO = @ComputerName
If TCPStartup() = 0 Then Return SetError(2, 0, 0)
Local $s_IPAddress, $i_Count
If StringRegExp($sSMTPServer, "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$") Then
$s_IPAddress = $sSMTPServer
Else
$s_IPAddress = TCPNameToIP($sSMTPServer)
EndIf
If $s_IPAddress = "" Then
TCPShutdown()
Return SetError(3, 0, 0)
EndIf
Local $vSocket = TCPConnect($s_IPAddress, 25)
If $vSocket = -1 Then
TCPShutdown()
Return SetError(4, 0, 0)
EndIf
Local $aSend[6], $aReplyCode[6]
$aSend[0] = "HELO " & $sEHLO & @CRLF
If StringLeft($sEHLO, 5) = "EHLO " Then $aSend[0] = $sEHLO & @CRLF
$aReplyCode[0] = "250"
$aSend[1] = "MAIL FROM: <" & $sFromAddress & ">" & @CRLF
$aReplyCode[1] = "250"
$aSend[2] = "RCPT TO: <" & $sToAddress & ">" & @CRLF
$aReplyCode[2] = "250"
$aSend[3] = "DATA" & @CRLF
$aReplyCode[3] = "354"
Local $aResult = _Date_Time_GetTimeZoneInformation()
Local $iBias = -$aResult[1] / 60
Local $iBiasH = Int($iBias)
Local $iBiasM = 0
If $iBiasH <> $iBias Then $iBiasM = Abs($iBias - $iBiasH) * 60
$iBias = StringFormat(" (%+.2d%.2d)", $iBiasH, $iBiasM)
$aSend[4] = "From:" & $sFromName & "<" & $sFromAddress & ">" & @CRLF &  "To:" & "<" & $sToAddress & ">" & @CRLF &  "Subject:" & $sSubject & @CRLF &  "Mime-Version: 1.0" & @CRLF &  "Date: " & _DateDayOfWeek(@WDAY, 1) & ", " & @MDAY & " " & _DateToMonth(@MON, 1) & " " & @YEAR & " " & @HOUR & ":" & @MIN & ":" & @SEC & $iBias & @CRLF &  "Content-Type: text/plain; charset=US-ASCII" & @CRLF &  @CRLF
$aReplyCode[4] = ""
$aSend[5] = @CRLF & "." & @CRLF
$aReplyCode[5] = "250"
If __SmtpSend($vSocket, $aSend[0], $aReplyCode[0], $bTrace, "220", $sFirst) Then Return SetError(50, 0, 0)
For $i_Count = 1 To UBound($aSend) - 2
If __SmtpSend($vSocket, $aSend[$i_Count], $aReplyCode[$i_Count], $bTrace) Then Return SetError(50 + $i_Count, 0, 0)
Next
For $i_Count = 0 To UBound($aBody) - 1
If StringLeft($aBody[$i_Count], 1) = "." Then $aBody[$i_Count] = "." & $aBody[$i_Count]
If __SmtpSend($vSocket, $aBody[$i_Count] & @CRLF, "", $bTrace) Then Return SetError(500 + $i_Count, 0, 0)
Next
$i_Count = UBound($aSend) - 1
If __SmtpSend($vSocket, $aSend[$i_Count], $aReplyCode[$i_Count], $bTrace) Then Return SetError(5000, 0, 0)
TCPCloseSocket($vSocket)
TCPShutdown()
Return 1
EndFunc
Func __SmtpTrace($sStr, $iTimeout = 0)
Local $sW_TITLE = "SMTP trace"
Local $sSmtpTrace = ControlGetText($sW_TITLE, "", "Static1")
$sStr = StringLeft(StringReplace($sStr, @CRLF, ""), 70)
$sSmtpTrace &= @HOUR & ":" & @MIN & ":" & @SEC & " " & $sStr & @LF
If WinExists($sW_TITLE) Then
ControlSetText($sW_TITLE, "", "Static1", $sSmtpTrace)
Else
SplashTextOn($sW_TITLE, $sSmtpTrace, 400, 500, 500, 100, 4 + 16, "", 8)
EndIf
If $iTimeout Then Sleep($iTimeout * 1000)
EndFunc
Func __SmtpSend($vSocket, $sSend, $sReplyCode, $bTrace, $sIntReply = "", $sFirst = "")
Local $sReceive, $i, $hTimer
If $bTrace Then __SmtpTrace($sSend)
If $sIntReply <> "" Then
If $sFirst <> -1 Then
If TCPSend($vSocket, $sFirst) = 0 Then
TCPCloseSocket($vSocket)
TCPShutdown()
Return 1
EndIf
EndIf
$sReceive = ""
$hTimer = TimerInit()
While StringLeft($sReceive, StringLen($sIntReply)) <> $sIntReply And TimerDiff($hTimer) < 45000
$sReceive = TCPRecv($vSocket, 1000)
If $bTrace And $sReceive <> "" Then __SmtpTrace("intermediate->" & $sReceive)
WEnd
EndIf
If TCPSend($vSocket, $sSend) = 0 Then
TCPCloseSocket($vSocket)
TCPShutdown()
Return 1
EndIf
$hTimer = TimerInit()
$sReceive = ""
While $sReceive = "" And TimerDiff($hTimer) < 45000
$i += 1
$sReceive = TCPRecv($vSocket, 1000)
If $sReplyCode = "" Then ExitLoop
WEnd
If $sReplyCode <> "" Then
If $bTrace Then __SmtpTrace($i & " <- " & $sReceive)
If StringLeft($sReceive, StringLen($sReplyCode)) <> $sReplyCode Then
TCPCloseSocket($vSocket)
TCPShutdown()
If $bTrace Then __SmtpTrace("<-> " & $sReplyCode, 5)
Return 2
EndIf
EndIf
Return 0
EndFunc
Func _TCPIpToName($sIp, $iOption = Default, $hDll = Default)
Local $iINADDR_NONE = 0xffffffff, $iAF_INET = 2, $sSeparator = @CR
If $iOption = Default Then $iOption = 0
If $hDll = Default Then $hDll = "ws2_32.dll"
Local $avDllCall = DllCall($hDll, "ulong", "inet_addr", "STR", $sIp)
If @error Then Return SetError(1, 0, "")
Local $vBinIP = $avDllCall[0]
If $vBinIP = $iINADDR_NONE Then Return SetError(2, 0, "")
$avDllCall = DllCall($hDll, "ptr", "gethostbyaddr", "ptr*", $vBinIP, "int", 4, "int", $iAF_INET)
If @error Then Return SetError(3, 0, "")
Local $pvHostent = $avDllCall[0]
If $pvHostent = 0 Then
$avDllCall = DllCall($hDll, "int", "WSAGetLastError")
If @error Then Return SetError(5, 0, "")
Return SetError(4, $avDllCall[0], "")
EndIf
Local $tHostent = DllStructCreate("ptr;ptr;short;short;ptr", $pvHostent)
Local $sHostnames = __TCPIpToName_szStringRead(DllStructGetData($tHostent, 1))
If @error Then Return SetError(6, 0, $sHostnames)
If $iOption = 1 Then
Local $tAliases
$sHostnames &= $sSeparator
For $i = 0 To 63
$tAliases = DllStructCreate("ptr", DllStructGetData($tHostent, 2) + ($i * 4))
If DllStructGetData($tAliases, 1) = 0 Then ExitLoop
$sHostnames &= __TCPIpToName_szStringRead(DllStructGetData($tAliases, 1))
If @error Then
SetError(7)
ExitLoop
EndIf
Next
Return StringSplit(StringStripWS($sHostnames, $STR_STRIPTRAILING), @CR)
Else
Return $sHostnames
EndIf
EndFunc
Func __TCPIpToName_szStringRead($pStr, $iLen = -1)
Local $tString
If $pStr < 1 Then Return ""
If $iLen < 0 Then $iLen = _WinAPI_StringLenA($pStr)
$tString = DllStructCreate("char[" & $iLen & "]", $pStr)
If @error Then Return SetError(2, 0, "")
Return SetExtended($iLen, DllStructGetData($tString, 1))
EndFunc
Global $__g_hTabLastWnd
Global Const $__TABCONSTANT_ClassName = "SysTabControl32"
Global Const $__TABCONSTANT_WS_CLIPSIBLINGS = 0x04000000
Global Const $__TABCONSTANT_WM_NOTIFY = 0x004E
Global Const $__TABCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $tagTCITEM = "uint Mask;dword State;dword StateMask;ptr Text;int TextMax;int Image;lparam Param"
Global Const $tagTCHITTESTINFO = $tagPOINT & ";uint Flags"
Func __GUICtrlTab_AdjustRect($hWnd, ByRef $tRECT, $bLarger = False)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
_SendMessage($hWnd, $TCM_ADJUSTRECT, $bLarger, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT)
_SendMessage($hWnd, $TCM_ADJUSTRECT, $bLarger, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
EndIf
Return $tRECT
EndFunc
Func _GUICtrlTab_ActivateTab($hWnd, $iIndex)
Local $nIndX
If $hWnd = -1 Then $hWnd = GUICtrlGetHandle(-1)
If IsHWnd($hWnd) Then
$nIndX = _WinAPI_GetDlgCtrlID($hWnd)
Else
$nIndX = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
Local $hParent = _WinAPI_GetParent($hWnd)
If @error Then Return SetError(1, 0, -1)
Local $tNmhdr = DllStructCreate($tagNMHDR)
DllStructSetData($tNmhdr, 1, $hWnd)
DllStructSetData($tNmhdr, 2, $nIndX)
DllStructSetData($tNmhdr, 3, $TCN_SELCHANGING)
_SendMessage($hParent, $__TABCONSTANT_WM_NOTIFY, $nIndX, $tNmhdr, 0, "wparam", "struct*")
Local $iRet = _GUICtrlTab_SetCurSel($hWnd, $iIndex)
DllStructSetData($tNmhdr, 3, $TCN_SELCHANGE)
_SendMessage($hParent, $__TABCONSTANT_WM_NOTIFY, $nIndX, $tNmhdr, 0, "wparam", "struct*")
Return $iRet
EndFunc
Func _GUICtrlTab_ClickTab($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iX, $iY
If Not $bMove Then
Local $hWinParent = _WinAPI_GetParent($hWnd)
Local $avTabPos = _GUICtrlTab_GetItemRect($hWnd, $iIndex)
$iX = $avTabPos[0] + (($avTabPos[2] - $avTabPos[0]) / 2)
$iY = $avTabPos[1] + (($avTabPos[3] - $avTabPos[1]) / 2)
ControlClick($hWinParent, "", $hWnd, $sButton, $iClicks, $iX, $iY)
Else
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
Opt("MouseCoordMode", $iMode)
EndIf
EndFunc
Func _GUICtrlTab_Create($hWnd, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x00000040, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then
Return SetError(1, 0, 0)
EndIf
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = $TCS_HOTTRACK
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__TABCONSTANT_WS_CLIPSIBLINGS, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hTab = _WinAPI_CreateWindowEx($iExStyle, $__TABCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hTab, _WinAPI_GetStockObject($__TABCONSTANT_DEFAULT_GUI_FONT))
Return $hTab
EndFunc
Func _GUICtrlTab_DeleteAllItems($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_DELETEALLITEMS) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_DELETEALLITEMS, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_DeleteItem($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_DELETEITEM, $iIndex) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_DELETEITEM, $iIndex, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_DeselectAll($hWnd, $bExclude = True)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_DESELECTALL, $bExclude)
Else
GUICtrlSendMsg($hWnd, $TCM_DESELECTALL, $bExclude, 0)
EndIf
EndFunc
Func _GUICtrlTab_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__TABCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlTab_FindTab($hWnd, $sText, $bInStr = False, $iStart = 0)
Local $sTab
For $iI = $iStart To _GUICtrlTab_GetItemCount($hWnd)
$sTab = _GUICtrlTab_GetItemText($hWnd, $iI)
Switch $bInStr
Case False
If $sTab = $sText Then Return $iI
Case True
If StringInStr($sTab, $sText) Then Return $iI
EndSwitch
Next
Return -1
EndFunc
Func _GUICtrlTab_GetCurFocus($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETCURFOCUS)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETCURFOCUS, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetCurSel($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETCURSEL)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETCURSEL, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetDisplayRect($hWnd)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetDisplayRectEx($hWnd)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetDisplayRectEx($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
Return __GUICtrlTab_AdjustRect($hWnd, $tRECT)
EndFunc
Func _GUICtrlTab_GetExtendedStyle($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETEXTENDEDSTYLE)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETEXTENDEDSTYLE, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetImageList($hWnd)
If IsHWnd($hWnd) Then
Return Ptr(_SendMessage($hWnd, $TCM_GETIMAGELIST))
Else
Return Ptr(GUICtrlSendMsg($hWnd, $TCM_GETIMAGELIST, 0, 0))
EndIf
EndFunc
Func _GUICtrlTab_GetItem($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $bUnicode = _GUICtrlTab_GetUnicodeFormat($hWnd)
Local $iBuffer = 4096
Local $tagTCITEMEx = $tagTCITEM & ";ptr Filler"
Local $tItem = DllStructCreate($tagTCITEMEx)
DllStructSetData($tItem, "Mask", $TCIF_ALLDATA)
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "StateMask", BitOR($TCIS_HIGHLIGHTED, $TCIS_BUTTONPRESSED))
Local $iItem = DllStructGetSize($tItem)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
Local $iRet
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TCM_GETITEMW, $iIndex, $pMemory)
Else
$iRet = _SendMessage($hWnd, $TCM_GETITEMA, $iIndex, $pMemory)
EndIf
_MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
_MemFree($tMemMap)
Local $aItem[4]
$aItem[0] = DllStructGetData($tItem, "State")
$aItem[1] = DllStructGetData($tBuffer, "Text")
$aItem[2] = DllStructGetData($tItem, "Image")
$aItem[3] = DllStructGetData($tItem, "Param")
Return SetError($iRet = 0, 0, $aItem)
EndFunc
Func _GUICtrlTab_GetItemCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETITEMCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETITEMCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetItemImage($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[2]
EndFunc
Func _GUICtrlTab_GetItemParam($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[3]
EndFunc
Func _GUICtrlTab_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $TCM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlTab_GetItemState($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[0]
EndFunc
Func _GUICtrlTab_GetItemText($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[1]
EndFunc
Func _GUICtrlTab_GetRowCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETROWCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETROWCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetToolTips($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $TCM_GETTOOLTIPS))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $TCM_GETTOOLTIPS, 0, 0))
EndIf
EndFunc
Func _GUICtrlTab_GetUnicodeFormat($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETUNICODEFORMAT) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETUNICODEFORMAT, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_HighlightItem($hWnd, $iIndex, $bHighlight = True)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_HIGHLIGHTITEM, $iIndex, $bHighlight) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_HIGHLIGHTITEM, $iIndex, $bHighlight) <> 0
EndIf
EndFunc
Func _GUICtrlTab_HitTest($hWnd, $iX, $iY)
Local $aHit[2] = [-1, 1]
Local $tHit = DllStructCreate($tagTCHITTESTINFO)
DllStructSetData($tHit, "X", $iX)
DllStructSetData($tHit, "Y", $iY)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
$aHit[0] = _SendMessage($hWnd, $TCM_HITTEST, 0, $tHit, 0, "wparam", "struct*")
Else
Local $iHit = DllStructGetSize($tHit)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iHit, $tMemMap)
_MemWrite($tMemMap, $tHit)
$aHit[0] = _SendMessage($hWnd, $TCM_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tHit, $iHit)
_MemFree($tMemMap)
EndIf
Else
$aHit[0] = GUICtrlSendMsg($hWnd, $TCM_HITTEST, 0, DllStructGetPtr($tHit))
EndIf
$aHit[1] = DllStructGetData($tHit, "Flags")
Return $aHit
EndFunc
Func _GUICtrlTab_InsertItem($hWnd, $iIndex, $sText, $iImage = -1, $iParam = 0)
Local $bUnicode = _GUICtrlTab_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagTCITEM)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", BitOR($TCIF_TEXT, $TCIF_IMAGE, $TCIF_PARAM))
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Param", $iParam)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $TCM_INSERTITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TCM_INSERTITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $TCM_INSERTITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $TCM_INSERTITEMW, $iIndex, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $TCM_INSERTITEMA, $iIndex, $pItem)
EndIf
EndIf
Return $iRet
EndFunc
Func _GUICtrlTab_RemoveImage($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_REMOVEIMAGE, $iIndex)
_WinAPI_InvalidateRect($hWnd)
Else
GUICtrlSendMsg($hWnd, $TCM_REMOVEIMAGE, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetCurFocus($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETCURFOCUS, $iIndex)
Else
GUICtrlSendMsg($hWnd, $TCM_SETCURFOCUS, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetCurSel($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETCURSEL, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETCURSEL, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetExtendedStyle($hWnd, $iStyle)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETEXTENDEDSTYLE, 0, $iStyle)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETEXTENDEDSTYLE, 0, $iStyle)
EndIf
EndFunc
Func _GUICtrlTab_SetImageList($hWnd, $hImage)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETIMAGELIST, 0, $hImage, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $TCM_SETIMAGELIST, 0, $hImage))
EndIf
EndFunc
Func _GUICtrlTab_SetItem($hWnd, $iIndex, $sText = -1, $iState = -1, $iImage = -1, $iParam = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tItem = DllStructCreate($tagTCITEM)
Local $iBuffer, $tBuffer, $iMask = 0, $iRet
Local $bUnicode = _GUICtrlTab_GetUnicodeFormat($hWnd)
If IsString($sText) Then
$iBuffer = StringLen($sText) + 1
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
$iMask = $TCIF_TEXT
EndIf
If $iState <> -1 Then
DllStructSetData($tItem, "State", $iState)
DllStructSetData($tItem, "StateMask", $iState)
$iMask = BitOR($iMask, $TCIF_STATE)
EndIf
If $iImage <> -1 Then
DllStructSetData($tItem, "Image", $iImage)
$iMask = BitOR($iMask, $TCIF_IMAGE)
EndIf
If $iParam <> -1 Then
DllStructSetData($tItem, "Param", $iParam)
$iMask = BitOR($iMask, $TCIF_PARAM)
EndIf
DllStructSetData($tItem, "Mask", $iMask)
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + 8192, $tMemMap)
Local $pText = $pMemory + 4096
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If IsString($sText) Then _MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TCM_SETITEMW, $iIndex, $pMemory) <> 0
Else
$iRet = _SendMessage($hWnd, $TCM_SETITEMA, $iIndex, $pMemory) <> 0
EndIf
_MemFree($tMemMap)
Return $iRet
EndFunc
Func _GUICtrlTab_SetItemImage($hWnd, $iIndex, $iImage)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, -1, $iImage)
EndFunc
Func _GUICtrlTab_SetItemParam($hWnd, $iIndex, $iParam)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, -1, -1, $iParam)
EndFunc
Func _GUICtrlTab_SetItemSize($hWnd, $iWidth, $iHeight)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETITEMSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight))
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETITEMSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight))
EndIf
EndFunc
Func _GUICtrlTab_SetItemState($hWnd, $iIndex, $iState)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, $iState)
EndFunc
Func _GUICtrlTab_SetItemText($hWnd, $iIndex, $sText)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, $sText)
EndFunc
Func _GUICtrlTab_SetMinTabWidth($hWnd, $iMinWidth)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETMINTABWIDTH, 0, $iMinWidth)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETMINTABWIDTH, 0, $iMinWidth)
EndIf
EndFunc
Func _GUICtrlTab_SetPadding($hWnd, $iHorz, $iVert)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETPADDING, 0, _WinAPI_MakeLong($iHorz, $iVert))
Else
GUICtrlSendMsg($hWnd, $TCM_SETPADDING, 0, _WinAPI_MakeLong($iHorz, $iVert))
EndIf
EndFunc
Func _GUICtrlTab_SetToolTips($hWnd, $hToolTip)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETTOOLTIPS, $hToolTip, 0, 0, "hwnd")
Else
GUICtrlSendMsg($hWnd, $TCM_SETTOOLTIPS, $hToolTip, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetUnicodeFormat($hWnd, $bUnicode)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETUNICODEFORMAT, $bUnicode) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETUNICODEFORMAT, $bUnicode, 0) <> 0
EndIf
EndFunc
Func _HexToString($sHex)
If Not (StringLeft($sHex, 2) == "0x") Then $sHex = "0x" & $sHex
Return BinaryToString($sHex, $SB_UTF8)
EndFunc
Func _StringBetween($sString, $sStart, $sEnd, $iMode = $STR_ENDISSTART, $bCase = False)
$sStart = $sStart ? "\Q" & $sStart & "\E" : "\A"
If $iMode <> $STR_ENDNOTSTART Then $iMode = $STR_ENDISSTART
If $iMode = $STR_ENDISSTART Then
$sEnd = $sEnd ? "(?=\Q" & $sEnd & "\E)" : "\z"
Else
$sEnd = $sEnd ? "\Q" & $sEnd & "\E" : "\z"
EndIf
If $bCase = Default Then
$bCase = False
EndIf
Local $aReturn = StringRegExp($sString, "(?s" & (Not $bCase ? "i" : "") & ")" & $sStart & "(.*?)" & $sEnd, $STR_REGEXPARRAYGLOBALMATCH)
If @error Then Return SetError(1, 0, 0)
Return $aReturn
EndFunc
Func _StringExplode($sString, $sDelimiter, $iLimit = 0)
If $iLimit = Default Then $iLimit = 0
If $iLimit > 0 Then
Local Const $NULL = Chr(0)
$sString = StringReplace($sString, $sDelimiter, $NULL, $iLimit)
$sDelimiter = $NULL
ElseIf $iLimit < 0 Then
Local $iIndex = StringInStr($sString, $sDelimiter, 0, $iLimit)
If $iIndex Then
$sString = StringLeft($sString, $iIndex - 1)
EndIf
EndIf
Return StringSplit($sString, $sDelimiter, $STR_ENTIRESPLIT + $STR_NOCOUNT)
EndFunc
Func _StringInsert($sString, $sInsertString, $iPosition)
Local $iLength = StringLen($sString)
$iPosition = Int($iPosition)
If $iPosition < 0 Then $iPosition = $iLength + $iPosition
If $iLength < $iPosition Or $iPosition < 0 Then Return SetError(1, 0, $sString)
Return StringLeft($sString, $iPosition) & $sInsertString & StringRight($sString, $iLength - $iPosition)
EndFunc
Func _StringProper($sString)
Local $bCapNext = True, $sChr = "", $sReturn = ""
For $i = 1 To StringLen($sString)
$sChr = StringMid($sString, $i, 1)
Select
Case $bCapNext = True
If StringRegExp($sChr, '[a-zA-ZÃ-Ã¿Å¡ÅÅ¾Å¸]') Then
$sChr = StringUpper($sChr)
$bCapNext = False
EndIf
Case Not StringRegExp($sChr, '[a-zA-ZÃ-Ã¿Å¡ÅÅ¾Å¸]')
$bCapNext = True
Case Else
$sChr = StringLower($sChr)
EndSelect
$sReturn &= $sChr
Next
Return $sReturn
EndFunc
Func _StringRepeat($sString, $iRepeatCount)
$iRepeatCount = Int($iRepeatCount)
If $iRepeatCount = 0 Then Return ""
If StringLen($sString) < 1 Or $iRepeatCount < 0 Then Return SetError(1, 0, "")
Local $sResult = ""
While $iRepeatCount > 1
If BitAND($iRepeatCount, 1) Then $sResult &= $sString
$sString &= $sString
$iRepeatCount = BitShift($iRepeatCount, 1)
WEnd
Return $sString & $sResult
EndFunc
Func _StringTitleCase($sString)
Local $bCapNext = True, $sChr = "", $sReturn = ""
For $i = 1 To StringLen($sString)
$sChr = StringMid($sString, $i, 1)
Select
Case $bCapNext = True
If StringRegExp($sChr, "[a-zA-Z\xC0-\xFF0-9]") Then
$sChr = StringUpper($sChr)
$bCapNext = False
EndIf
Case Not StringRegExp($sChr, "[a-zA-Z\xC0-\xFF'0-9]")
$bCapNext = True
Case Else
$sChr = StringLower($sChr)
EndSelect
$sReturn &= $sChr
Next
Return $sReturn
EndFunc
Func _StringToHex($sString)
Return Hex(StringToBinary($sString, $SB_UTF8))
EndFunc
#Region Header
#EndRegion Header
#Region Global Variables
Global $__g_iIELoadWaitTimeout = 300000
Global $__g_bIEAU3Debug = False
Global $__g_bIEErrorNotify = True
Global $__g_oIEErrorHandler, $__g_sIEUserErrorHandler
#EndRegion Global Variables
#Region Global Constants
Global Const $__gaIEAU3VersionInfo[6] = ["T", 3, 0, 2, "20140819", "T3.0-2"]
Global Const $LSFW_LOCK = 1, $LSFW_UNLOCK = 2
Global Enum  $_IESTATUS_Success = 0,  $_IESTATUS_GeneralError,  $_IESTATUS_ComError,  $_IESTATUS_InvalidDataType,  $_IESTATUS_InvalidObjectType,  $_IESTATUS_InvalidValue,  $_IESTATUS_LoadWaitTimeout,  $_IESTATUS_NoMatch,  $_IESTATUS_AccessIsDenied,  $_IESTATUS_ClientDisconnected
#EndRegion Global Constants
#Region Core functions
Func _IECreate($sUrl = "about:blank", $iTryAttach = 0, $iVisible = 1, $iWait = 1, $iTakeFocus = 1)
If Not $iVisible Then $iTakeFocus = 0
If $iTryAttach Then
Local $oResult = _IEAttach($sUrl, "url")
If IsObj($oResult) Then
If $iTakeFocus Then WinActivate(HWnd($oResult.hWnd))
Return SetError($_IESTATUS_Success, 1, $oResult)
EndIf
EndIf
Local $iMustUnlock = 0
If Not $iVisible And __IELockSetForegroundWindow($LSFW_LOCK) Then $iMustUnlock = 1
Local $oObject = ObjCreate("InternetExplorer.Application")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IECreate", "", "Browser Object Creation Failed")
If $iMustUnlock Then __IELockSetForegroundWindow($LSFW_UNLOCK)
Return SetError($_IESTATUS_GeneralError, 0, 0)
EndIf
$oObject.visible = $iVisible
If $iMustUnlock And Not __IELockSetForegroundWindow($LSFW_UNLOCK) Then __IEConsoleWriteError("Warning", "_IECreate", "", "Foreground Window Unlock Failed!")
_IENavigate($oObject, $sUrl, $iWait)
Local $iError = @error
If Not $iError And StringLeft($sUrl, 6) = "about:" Then
Local $oDocument = $oObject.document
_IEAction($oDocument, "focus")
EndIf
Return SetError($iError, 0, $oObject)
EndFunc
Func _IECreateEmbedded()
Local $oObject = ObjCreate("Shell.Explorer.2")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IECreateEmbedded", "", "WebBrowser Object Creation Failed")
Return SetError($_IESTATUS_GeneralError, 0, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject)
EndFunc
Func _IENavigate(ByRef $oObject, $sUrl, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IENavigate", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IENavigate", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.navigate($sUrl)
If @error Then
__IEConsoleWriteError("Error", "_IENavigate", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndFunc
Func _IEAttach($sString, $sMode = "title", $iInstance = 1)
$sMode = StringLower($sMode)
$iInstance = Int($iInstance)
If $iInstance < 1 Then
__IEConsoleWriteError("Error", "_IEAttach", "$_IESTATUS_InvalidValue", "$iInstance < 1")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndIf
If $sMode = "embedded" Or $sMode = "dialogbox" Then
Local $iWinTitleMatchMode = Opt("WinTitleMatchMode", $OPT_MATCHANY)
If $sMode = "dialogbox" And $iInstance > 1 Then
If IsHWnd($sString) Then
$iInstance = 1
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_GeneralError", "$iInstance > 1 invalid with HWnd and DialogBox.  Setting to 1.")
Else
Local $aWinlist = WinList($sString, "")
If $iInstance <= $aWinlist[0][0] Then
$sString = $aWinlist[$iInstance][1]
$iInstance = 1
Else
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_NoMatch")
Opt("WinTitleMatchMode", $iWinTitleMatchMode)
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndIf
EndIf
EndIf
Local $hControl = ControlGetHandle($sString, "", "[CLASS:Internet Explorer_Server; INSTANCE:" & $iInstance & "]")
Local $oResult = __IEControlGetObjFromHWND($hControl)
Opt("WinTitleMatchMode", $iWinTitleMatchMode)
If IsObj($oResult) Then
Return SetError($_IESTATUS_Success, 0, $oResult)
Else
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndIf
EndIf
Local $oShell = ObjCreate("Shell.Application")
Local $oShellWindows = $oShell.Windows()
Local $iTmp = 1
Local $iNotifyStatus, $bIsBrowser, $sTmp
Local $bStatus
For $oWindow In $oShellWindows
$bIsBrowser = True
$bStatus = __IEInternalErrorHandlerRegister()
If Not $bStatus Then __IEConsoleWriteError("Warning", "_IEAttach",  "Cannot register internal error handler, cannot trap COM errors",  "Use _IEErrorHandlerRegister() to register a user error handler")
$iNotifyStatus = _IEErrorNotify()
_IEErrorNotify(False)
If $bIsBrowser Then
$sTmp = $oWindow.type
If @error Then $bIsBrowser = False
EndIf
If $bIsBrowser Then
$sTmp = $oWindow.document.title
If @error Then $bIsBrowser = False
EndIf
_IEErrorNotify($iNotifyStatus)
__IEInternalErrorHandlerDeRegister()
If $bIsBrowser Then
Switch $sMode
Case "title"
If StringInStr($oWindow.document.title, $sString) > 0 Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "instance"
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
Case "windowtitle"
Local $bFound = False
$sTmp = RegRead("HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main\", "Window Title")
If Not @error Then
If StringInStr($oWindow.document.title & " - " & $sTmp, $sString) Then $bFound = True
Else
If StringInStr($oWindow.document.title & " - Microsoft Internet Explorer", $sString) Then $bFound = True
If StringInStr($oWindow.document.title & " - Windows Internet Explorer", $sString) Then $bFound = True
EndIf
If $bFound Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "url"
If StringInStr($oWindow.LocationURL, $sString) > 0 Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "text"
If StringInStr($oWindow.document.body.innerText, $sString) > 0 Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "html"
If StringInStr($oWindow.document.body.innerHTML, $sString) > 0 Then
If $iInstance = $iTmp Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
Else
$iTmp += 1
EndIf
EndIf
Case "hwnd"
If $iInstance > 1 Then
$iInstance = 1
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_GeneralError", "$iInstance > 1 invalid with HWnd.  Setting to 1.")
EndIf
If _IEPropertyGet($oWindow, "hwnd") = $sString Then
Return SetError($_IESTATUS_Success, 0, $oWindow)
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEAttach", "$_IESTATUS_InvalidValue", "Invalid Mode Specified")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndSwitch
EndIf
Next
__IEConsoleWriteError("Warning", "_IEAttach", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndFunc
Func _IELoadWait(ByRef $oObject, $iDelay = 0, $iTimeout = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_InvalidObjectType", ObjName($oObject))
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oTemp, $bAbort = False, $iErrorStatusCode = $_IESTATUS_Success
Local $bStatus = __IEInternalErrorHandlerRegister()
If Not $bStatus Then __IEConsoleWriteError("Warning", "_IELoadWait",  "Cannot register internal error handler, cannot trap COM errors",  "Use _IEErrorHandlerRegister() to register a user error handler")
Local $iNotifyStatus = _IEErrorNotify()
_IEErrorNotify(False)
Sleep($iDelay)
Local $iError
Local $hIELoadWaitTimer = TimerInit()
If $iTimeout = -1 Then $iTimeout = $__g_iIELoadWaitTimeout
Select
Case __IEIsObjType($oObject, "browser", False)
While Not (String($oObject.readyState) = "complete" Or $oObject.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
While Not (String($oObject.document.readyState) = "complete" Or $oObject.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
Case __IEIsObjType($oObject, "window", False)
While Not (String($oObject.document.readyState) = "complete" Or $oObject.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
While Not (String($oObject.top.document.readyState) = "complete" Or $oObject.top.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
Case __IEIsObjType($oObject, "document", False)
$oTemp = $oObject.parentWindow
While Not (String($oTemp.document.readyState) = "complete" Or $oTemp.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
While Not (String($oTemp.top.document.readyState) = "complete" Or $oTemp.top.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
Case Else
$oTemp = $oObject.document.parentWindow
While Not (String($oTemp.document.readyState) = "complete" Or $oTemp.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
While Not (String($oTemp.top.document.readyState) = "complete" Or $oObject.top.document.readyState = 4 Or $bAbort)
If @error Then
$iError = @error
If __IEComErrorUnrecoverable($iError) Then
$iErrorStatusCode = __IEComErrorUnrecoverable($iError)
$bAbort = True
EndIf
ElseIf (TimerDiff($hIELoadWaitTimer) > $iTimeout) Then
$iErrorStatusCode = $_IESTATUS_LoadWaitTimeout
$bAbort = True
EndIf
Sleep(100)
WEnd
EndSelect
_IEErrorNotify($iNotifyStatus)
__IEInternalErrorHandlerDeRegister()
Switch $iErrorStatusCode
Case $_IESTATUS_Success
Return SetError($_IESTATUS_Success, 0, 1)
Case $_IESTATUS_LoadWaitTimeout
__IEConsoleWriteError("Warning", "_IELoadWait", "$_IESTATUS_LoadWaitTimeout")
Return SetError($_IESTATUS_LoadWaitTimeout, 3, 0)
Case $_IESTATUS_AccessIsDenied
__IEConsoleWriteError("Warning", "_IELoadWait", "$_IESTATUS_AccessIsDenied",  "Cannot verify readyState.  Likely casue: cross-domain scripting security restriction. (" & $iError & ")")
Return SetError($_IESTATUS_AccessIsDenied, 0, 0)
Case $_IESTATUS_ClientDisconnected
__IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_ClientDisconnected",  $iError & ", Browser has been deleted prior to operation.")
Return SetError($_IESTATUS_ClientDisconnected, 0, 0)
Case Else
__IEConsoleWriteError("Error", "_IELoadWait", "$_IESTATUS_GeneralError", "Invalid Error Status - Notify IE.au3 developer")
Return SetError($_IESTATUS_GeneralError, 0, 0)
EndSwitch
EndFunc
Func _IELoadWaitTimeout($iTimeout = -1)
If $iTimeout = -1 Then
Return SetError($_IESTATUS_Success, 0, $__g_iIELoadWaitTimeout)
Else
$__g_iIELoadWaitTimeout = $iTimeout
Return SetError($_IESTATUS_Success, 0, 1)
EndIf
EndFunc
#EndRegion Core functions
#Region Frame Functions
Func _IEIsFrameSet(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEIsFrameSet", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If String($oObject.document.body.tagName) = "frameset" Then
Return SetError($_IESTATUS_Success, 0, 1)
Else
If @error Then
__IEConsoleWriteError("Error", "_IEIsFrameSet", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 0)
EndIf
EndFunc
Func _IEFrameGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFrameGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oObject.document.parentwindow.frames.length,  $oObject.document.parentwindow.frames)
Case $iIndex > -1 And $iIndex < $oObject.document.parentwindow.frames.length
Return SetError($_IESTATUS_Success, $oObject.document.parentwindow.frames.length,  $oObject.document.parentwindow.frames.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IEFrameGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IEFrameGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndSelect
EndFunc
Func _IEFrameGetObjByName(ByRef $oObject, $sName)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFrameGetObjByName", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oTemp, $oFrames
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEFrameGetObjByName", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.parentWindow
Else
$oTemp = $oObject.document.parentWindow
EndIf
If _IEIsFrameSet($oTemp) Then
$oFrames = _IETagNameGetCollection($oTemp, "frame")
Else
$oFrames = _IETagNameGetCollection($oTemp, "iframe")
EndIf
If $oFrames.length Then
For $oFrame In $oFrames
If String($oFrame.name) = $sName Then Return SetError($_IESTATUS_Success, 0, $oTemp.frames($sName))
Next
__IEConsoleWriteError("Warning", "_IEFrameGetObjByName", "$_IESTATUS_NoMatch", "No frames matching name")
Return SetError($_IESTATUS_NoMatch, 2, 0)
Else
__IEConsoleWriteError("Warning", "_IEFrameGetObjByName", "$_IESTATUS_NoMatch", "No Frames found")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
EndFunc
#EndRegion Frame Functions
#Region Link functions
Func _IELinkClickByText(ByRef $oObject, $sLinkText, $iIndex = 0, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IELinkClickByText", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $iFound = 0, $sModeLinktext, $oLinks = $oObject.document.links
$iIndex = Number($iIndex)
For $oLink In $oLinks
$sModeLinktext = String($oLink.outerText)
If $sModeLinktext = $sLinkText Then
If ($iFound = $iIndex) Then
$oLink.click()
If @error Then
__IEConsoleWriteError("Error", "_IELinkClickByText", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndIf
$iFound = $iFound + 1
EndIf
Next
__IEConsoleWriteError("Warning", "_IELinkClickByText", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndFunc
Func _IELinkClickByIndex(ByRef $oObject, $iIndex, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IELinkClickByIndex", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oLinks = $oObject.document.links, $oLink
$iIndex = Number($iIndex)
If ($iIndex >= 0) And ($iIndex <= $oLinks.length - 1) Then
$oLink = $oLinks($iIndex)
$oLink.click()
If @error Then
__IEConsoleWriteError("Error", "_IELinkClickByIndex", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
Else
__IEConsoleWriteError("Warning", "_IELinkClickByIndex", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
EndFunc
Func _IELinkGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IELinkGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oObject.document.links.length,  $oObject.document.links)
Case $iIndex > -1 And $iIndex < $oObject.document.links.length
Return SetError($_IESTATUS_Success, $oObject.document.links.length,  $oObject.document.links.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IELinkGetCollection", "$_IESTATUS_InvalidValue")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IELinkGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndSelect
EndFunc
#EndRegion Link functions
#Region Image functions
Func _IEImgClick(ByRef $oObject, $sLinkText, $sMode = "src", $iIndex = 0, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEImgClick", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $sModeLinktext, $iFound = 0, $oImgs = $oObject.document.images
$sMode = StringLower($sMode)
$iIndex = Number($iIndex)
For $oImg In $oImgs
Select
Case $sMode = "alt"
$sModeLinktext = $oImg.alt
Case $sMode = "name"
$sModeLinktext = $oImg.name
If Not IsString($sModeLinktext) Then $sModeLinktext = $oImg.id
Case $sMode = "id"
$sModeLinktext = $oImg.id
Case $sMode = "src"
$sModeLinktext = $oImg.src
Case Else
__IEConsoleWriteError("Error", "_IEImgClick", "$_IESTATUS_InvalidValue", "Invalid mode: " & $sMode)
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSelect
If StringInStr($sModeLinktext, $sLinkText) Then
If ($iFound = $iIndex) Then
$oImg.click()
If @error Then
__IEConsoleWriteError("Error", "_IEImgClick", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndIf
$iFound = $iFound + 1
EndIf
Next
__IEConsoleWriteError("Warning", "_IEImgClick", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndFunc
Func _IEImgGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEImgGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oTemp = _IEDocGetObj($oObject)
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oTemp.images.length, $oTemp.images)
Case $iIndex > -1 And $iIndex < $oTemp.images.length
Return SetError($_IESTATUS_Success, $oTemp.images.length, $oTemp.images.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IEImgGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IEImgGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
#EndRegion Image functions
#Region Form functions
Func _IEFormGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oTemp = _IEDocGetObj($oObject)
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oTemp.forms.length, $oTemp.forms)
Case $iIndex > -1 And $iIndex < $oTemp.forms.length
Return SetError($_IESTATUS_Success, $oTemp.forms.length, $oTemp.forms.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IEFormGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IEFormGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
Func _IEFormGetObjByName(ByRef $oObject, $sName, $iIndex = 0)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormGetObjByName", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $iLength = 0
Local $oCol = $oObject.document.forms.item($sName)
If IsObj($oCol) Then
If __IEIsObjType($oCol, "elementcollection") Then
$iLength = $oCol.length
Else
$iLength = 1
EndIf
EndIf
$iIndex = Number($iIndex)
If $iIndex = -1 Then
Return SetError($_IESTATUS_Success, $iLength, $oObject.document.forms.item($sName))
Else
If IsObj($oObject.document.forms.item($sName, $iIndex)) Then
Return SetError($_IESTATUS_Success, $iLength, $oObject.document.forms.item($sName, $iIndex))
Else
__IEConsoleWriteError("Warning", "_IEFormGetObjByName", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndIf
EndIf
EndFunc
Func _IEFormElementGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormElementGetCollection", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oObject.elements.length, $oObject.elements)
Case $iIndex > -1 And $iIndex < $oObject.elements.length
Return SetError($_IESTATUS_Success, $oObject.elements.length, $oObject.elements.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IEFormElementGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
Func _IEFormElementGetObjByName(ByRef $oObject, $sName, $iIndex = 0)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementGetObjByName", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormElementGetObjByName", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $iLength = 0
Local $oCol = $oObject.elements.item($sName)
If IsObj($oCol) Then
If __IEIsObjType($oCol, "elementcollection") Then
$iLength = $oCol.length
Else
$iLength = 1
EndIf
EndIf
$iIndex = Number($iIndex)
If $iIndex = -1 Then
Return SetError($_IESTATUS_Success, $iLength, $oObject.elements.item($sName))
Else
If IsObj($oObject.elements.item($sName, $iIndex)) Then
Return SetError($_IESTATUS_Success, $iLength, $oObject.elements.item($sName, $iIndex))
Else
__IEConsoleWriteError("Warning", "_IEFormElementGetObjByName", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndIf
EndIf
EndFunc
Func _IEFormElementGetValue(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementGetValue", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "forminputelement") Then
__IEConsoleWriteError("Error", "_IEFormElementGetValue", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $sReturn = String($oObject.value)
If @error Then
__IEConsoleWriteError("Error", "_IEFormElementGetValue", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
SetError($_IESTATUS_Success)
Return $sReturn
EndFunc
Func _IEFormElementSetValue(ByRef $oObject, $sNewValue, $iFireEvent = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "forminputelement") Then
__IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If String($oObject.type) = "file" Then
__IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_InvalidObjectType", "Browser security prevents SetValue of TYPE=FILE")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.value = $sNewValue
If @error Then
__IEConsoleWriteError("Error", "_IEFormElementSetValue", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iFireEvent Then
$oObject.fireEvent("OnChange")
$oObject.fireEvent("OnClick")
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func _IEFormElementOptionSelect(ByRef $oObject, $sString, $iSelect = 1, $sMode = "byValue", $iFireEvent = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "formselectelement") Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oItem, $oItems = $oObject.options, $iNumItems = $oObject.options.length, $bIsMultiple = $oObject.multiple
Switch $sMode
Case "byValue"
For $oItem In $oItems
If $oItem.value = $sString Then
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItem.selected)
Case 0
If Not $bIsMultiple Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue",  "$iSelect=0 only valid for type=select multiple")
SetError($_IESTATUS_InvalidValue, 3)
EndIf
If $oItem.selected Then
$oItem.selected = False
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.selected Then
$oItem.selected = True
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSwitch
__IEConsoleWriteError("Warning", "_IEFormElementOptionSelect", "$_IESTATUS_NoMatch", "Value not matched")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
Next
Case "byText"
For $oItem In $oItems
If String($oItem.text) = $sString Then
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItem.selected)
Case 0
If Not $bIsMultiple Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue",  "$iSelect=0 only valid for type=select multiple")
SetError($_IESTATUS_InvalidValue, 3)
EndIf
If $oItem.selected Then
$oItem.selected = False
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.selected Then
$oItem.selected = True
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSwitch
__IEConsoleWriteError("Warning", "_IEFormElementOptionSelect", "$_IESTATUS_NoMatch", "Text not matched")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
Next
Case "byIndex"
Local $iIndex = Number($sString)
If $iIndex < 0 Or $iIndex >= $iNumItems Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid index value, " & $iIndex)
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndIf
$oItem = $oItems.item($iIndex)
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItems.item($iIndex).selected)
Case 0
If Not $bIsMultiple Then
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue",  "$iSelect=0 only valid for type=select multiple")
SetError($_IESTATUS_InvalidValue, 3)
EndIf
If $oItem.selected Then
$oItems.item($iIndex).selected = False
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.selected Then
$oItems.item($iIndex).selected = True
If $iFireEvent Then
$oObject.fireEvent("onChange")
$oObject.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSwitch
Case Else
__IEConsoleWriteError("Error", "_IEFormElementOptionSelect", "$_IESTATUS_InvalidValue", "Invalid Mode")
Return SetError($_IESTATUS_InvalidValue, 4, 0)
EndSwitch
EndFunc
Func _IEFormElementCheckBoxSelect(ByRef $oObject, $sString, $sName = "", $iSelect = 1, $sMode = "byValue", $iFireEvent = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$sString = String($sString)
$sName = String($sName)
Local $oItems
If $sName = "" Then
$oItems = _IETagNameGetCollection($oObject, "input")
Else
$oItems = Execute("$oObject.elements('" & $sName & "')")
EndIf
If Not IsObj($oItems) Then
__IEConsoleWriteError("Warning", "_IEFormElementCheckBoxSelect", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 3, 0)
EndIf
Local $oItem, $bFound = False
Switch $sMode
Case "byValue"
If __IEIsObjType($oItems, "forminputelement") Then
$oItem = $oItems
If String($oItem.type) = "checkbox" And String($oItem.value) = $sString Then $bFound = True
Else
For $oItem In $oItems
If String($oItem.type) = "checkbox" And String($oItem.value) = $sString Then
$bFound = True
ExitLoop
EndIf
Next
EndIf
Case "byIndex"
If __IEIsObjType($oItems, "forminputelement") Then
$oItem = $oItems
If String($oItem.type) = "checkbox" And Number($sString) = 0 Then $bFound = True
Else
Local $iCount = 0
For $oItem In $oItems
If String($oItem.type) = "checkbox" And Number($sString) = $iCount Then
$bFound = True
ExitLoop
Else
If String($oItem.type) = "checkbox" Then $iCount += 1
EndIf
Next
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidValue", "Invalid Mode")
Return SetError($_IESTATUS_InvalidValue, 5, 0)
EndSwitch
If Not $bFound Then
__IEConsoleWriteError("Warning", "_IEFormElementCheckBoxSelect", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItem.checked)
Case 0
If $oItem.checked Then
$oItem.checked = False
If $iFireEvent Then
$oItem.fireEvent("onChange")
$oItem.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.checked Then
$oItem.checked = True
If $iFireEvent Then
$oItem.fireEvent("onChange")
$oItem.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementCheckBoxSelect", "$_IESTATUS_InvalidValue", "Invalid $iSelect value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSwitch
EndFunc
Func _IEFormElementRadioSelect(ByRef $oObject, $sString, $sName, $iSelect = 1, $sMode = "byValue", $iFireEvent = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$sString = String($sString)
$sName = String($sName)
Local $oItems = Execute("$oObject.elements('" & $sName & "')")
If Not IsObj($oItems) Then
__IEConsoleWriteError("Warning", "_IEFormElementRadioSelect", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 3, 0)
EndIf
Local $oItem, $bFound = False
Switch $sMode
Case "byValue"
If __IEIsObjType($oItems, "forminputelement") Then
$oItem = $oItems
If String($oItem.type) = "radio" And String($oItem.value) = $sString Then $bFound = True
Else
For $oItem In $oItems
If String($oItem.type) = "radio" And String($oItem.value) = $sString Then
$bFound = True
ExitLoop
EndIf
Next
EndIf
Case "byIndex"
If __IEIsObjType($oItems, "forminputelement") Then
$oItem = $oItems
If String($oItem.type) = "radio" And Number($sString) = 0 Then $bFound = True
Else
Local $iCount = 0
For $oItem In $oItems
If String($oItem.type) = "radio" And Number($sString) = $iCount Then
$bFound = True
ExitLoop
Else
$iCount += 1
EndIf
Next
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidValue", "Invalid Mode")
Return SetError($_IESTATUS_InvalidValue, 5, 0)
EndSwitch
If Not $bFound Then
__IEConsoleWriteError("Warning", "_IEFormElementRadioSelect", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
Switch $iSelect
Case -1
Return SetError($_IESTATUS_Success, 0, $oItem.checked)
Case 0
If $oItem.checked Then
$oItem.checked = False
If $iFireEvent Then
$oItem.fireEvent("onChange")
$oItem.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case 1
If Not $oItem.checked Then
$oItem.checked = True
If $iFireEvent Then
$oItem.fireEvent("onChange")
$oItem.fireEvent("OnClick")
EndIf
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEFormElementRadioSelect", "$_IESTATUS_InvalidValue", "$iSelect value invalid")
Return SetError($_IESTATUS_InvalidValue, 4, 0)
EndSwitch
EndFunc
Func _IEFormImageClick(ByRef $oObject, $sLinkText, $sMode = "src", $iIndex = 0, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormImageClick", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $sModeLinktext, $iFound = 0
Local $oTemp = _IEDocGetObj($oObject)
Local $oImgs = _IETagNameGetCollection($oTemp, "input")
$sMode = StringLower($sMode)
$iIndex = Number($iIndex)
For $oImg In $oImgs
If String($oImg.type) = "image" Then
Select
Case $sMode = "alt"
$sModeLinktext = $oImg.alt
Case $sMode = "name"
$sModeLinktext = $oImg.name
If Not IsString($sModeLinktext) Then $sModeLinktext = $oImg.id
Case $sMode = "id"
$sModeLinktext = $oImg.id
Case $sMode = "src"
$sModeLinktext = $oImg.src
Case Else
__IEConsoleWriteError("Error", "_IEFormImageClick", "$_IESTATUS_InvalidValue", "Invalid mode: " & $sMode)
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSelect
If StringInStr($sModeLinktext, $sLinkText) Then
If ($iFound = $iIndex) Then
$oImg.click()
If @error Then
__IEConsoleWriteError("Error", "_IEFormImageClick", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndIf
$iFound = $iFound + 1
EndIf
EndIf
Next
__IEConsoleWriteError("Warning", "_IEFormImageClick", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndFunc
Func _IEFormSubmit(ByRef $oObject, $iWait = 1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormSubmit", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormSubmit", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oWindow = $oObject.document.parentWindow
$oObject.submit()
If @error Then
__IEConsoleWriteError("Error", "_IEFormSubmit", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
If $iWait Then
_IELoadWait($oWindow)
Return SetError(@error, 0, -1)
EndIf
Return SetError($_IESTATUS_Success, 0, -1)
EndFunc
Func _IEFormReset(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEFormReset", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "form") Then
__IEConsoleWriteError("Error", "_IEFormReset", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.reset()
If @error Then
__IEConsoleWriteError("Error", "_IEFormReset", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
#EndRegion Form functions
#Region Table functions
Func _IETableGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IETableGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oObject.document.GetElementsByTagName("table").length,  $oObject.document.GetElementsByTagName("table"))
Case $iIndex > -1 And $iIndex < $oObject.document.GetElementsByTagName("table").length
Return SetError($_IESTATUS_Success, $oObject.document.GetElementsByTagName("table").length,  $oObject.document.GetElementsByTagName("table").item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IETableGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Warning", "_IETableGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
Func _IETableWriteToArray(ByRef $oObject, $bTranspose = False)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IETableWriteToArray", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "table") Then
__IEConsoleWriteError("Error", "_IETableWriteToArray", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $iCols = 0, $oTds, $iCol
Local $oTrs = $oObject.rows
For $oTr In $oTrs
$oTds = $oTr.cells
$iCol = 0
For $oTd In $oTds
$iCol = $iCol + $oTd.colSpan
Next
If $iCol > $iCols Then $iCols = $iCol
Next
Local $iRows = $oTrs.length
Local $aTableCells[$iCols][$iRows]
Local $iRow = 0
For $oTr In $oTrs
$oTds = $oTr.cells
$iCol = 0
For $oTd In $oTds
$aTableCells[$iCol][$iRow] = String($oTd.innerText)
If @error Then
__IEConsoleWriteError("Error", "_IETableWriteToArray", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
$iCol = $iCol + $oTd.colSpan
Next
$iRow = $iRow + 1
Next
If $bTranspose Then
Local $iD1 = UBound($aTableCells, $UBOUND_ROWS), $iD2 = UBound($aTableCells, $UBOUND_COLUMNS), $aTmp[$iD2][$iD1]
For $i = 0 To $iD2 - 1
For $j = 0 To $iD1 - 1
$aTmp[$i][$j] = $aTableCells[$j][$i]
Next
Next
$aTableCells = $aTmp
EndIf
Return SetError($_IESTATUS_Success, 0, $aTableCells)
EndFunc
#EndRegion Table functions
#Region Read/Write functions
Func _IEBodyReadHTML(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEBodyReadHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document.body.innerHTML)
EndFunc
Func _IEBodyReadText(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEBodyReadText", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEBodyReadText", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document.body.innerText)
EndFunc
Func _IEBodyWriteHTML(ByRef $oObject, $sHTML)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEBodyWriteHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEBodyWriteHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.document.body.innerHTML = $sHTML
If @error Then
__IEConsoleWriteError("Error", "_IEBodyWriteHTML", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Local $oTemp = $oObject.document
_IELoadWait($oTemp)
Return SetError(@error, 0, -1)
EndFunc
Func _IEDocReadHTML(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocReadHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEDocReadHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document.documentElement.outerHTML)
EndFunc
Func _IEDocWriteHTML(ByRef $oObject, $sHTML)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocWriteHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEDocWriteHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.document.Write($sHTML)
$oObject.document.close()
Local $oTemp = $oObject.document
If @error Then
__IEConsoleWriteError("Error", "_IEDocWriteHTML", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
_IELoadWait($oTemp)
Return SetError(@error, 0, -1)
EndFunc
Func _IEDocInsertText(ByRef $oObject, $sString, $sWhere = "beforeend")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Or __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$sWhere = StringLower($sWhere)
Select
Case $sWhere = "beforebegin"
$oObject.insertAdjacentText($sWhere, $sString)
Case $sWhere = "afterbegin"
$oObject.insertAdjacentText($sWhere, $sString)
Case $sWhere = "beforeend"
$oObject.insertAdjacentText($sWhere, $sString)
Case $sWhere = "afterend"
$oObject.insertAdjacentText($sWhere, $sString)
Case Else
__IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_InvalidValue", "Invalid where value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSelect
If @error Then
__IEConsoleWriteError("Error", "_IEDocInsertText", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func _IEDocInsertHTML(ByRef $oObject, $sString, $sWhere = "beforeend")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Or __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_InvalidObjectType", "Expected document element")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$sWhere = StringLower($sWhere)
Select
Case $sWhere = "beforebegin"
$oObject.insertAdjacentHTML($sWhere, $sString)
Case $sWhere = "afterbegin"
$oObject.insertAdjacentHTML($sWhere, $sString)
Case $sWhere = "beforeend"
$oObject.insertAdjacentHTML($sWhere, $sString)
Case $sWhere = "afterend"
$oObject.insertAdjacentHTML($sWhere, $sString)
Case Else
__IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_InvalidValue", "Invalid where value")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
EndSelect
If @error Then
__IEConsoleWriteError("Error", "_IEDocInsertHTML", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func _IEHeadInsertEventScript(ByRef $oObject, $sHTMLFor, $sEvent, $sScript)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEHeadInsertEventScript", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oHead = $oObject.document.all.tags("HEAD").Item(0)
Local $oScript = $oObject.document.createElement("script")
If @error Then
__IEConsoleWriteError("Error", "_IEHeadInsertEventScript(script)", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
With $oScript
.defer = True
.language = "jscript"
.type = "text/javascript"
.htmlFor = $sHTMLFor
.event = $sEvent
.text = $sScript
EndWith
$oHead.appendChild($oScript)
If @error Then
__IEConsoleWriteError("Error", "_IEHeadInsertEventScript", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
#EndRegion Read/Write functions
#Region Utility functions
Func _IEDocGetObj(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEDocGetObj", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If __IEIsObjType($oObject, "document") Then
Return SetError($_IESTATUS_Success, 0, $oObject)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document)
EndFunc
Func _IETagNameGetCollection(ByRef $oObject, $sTagName, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oTemp
If __IEIsObjType($oObject, "documentcontainer") Then
$oTemp = _IEDocGetObj($oObject)
Else
$oTemp = $oObject
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oTemp.GetElementsByTagName($sTagName).length,  $oTemp.GetElementsByTagName($sTagName))
Case $iIndex > -1 And $iIndex < $oTemp.GetElementsByTagName($sTagName).length
Return SetError($_IESTATUS_Success, $oTemp.GetElementsByTagName($sTagName).length,  $oTemp.GetElementsByTagName($sTagName).item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 3, 0)
Case Else
__IEConsoleWriteError("Error", "_IETagNameGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndSelect
EndFunc
Func _IETagNameAllGetCollection(ByRef $oObject, $iIndex = -1)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oTemp
If __IEIsObjType($oObject, "documentcontainer") Then
$oTemp = _IEDocGetObj($oObject)
Else
$oTemp = $oObject
EndIf
$iIndex = Number($iIndex)
Select
Case $iIndex = -1
Return SetError($_IESTATUS_Success, $oTemp.all.length, $oTemp.all)
Case $iIndex > -1 And $iIndex < $oTemp.all.length
Return SetError($_IESTATUS_Success, $oTemp.all.length, $oTemp.all.item($iIndex))
Case $iIndex < -1
__IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_InvalidValue", "$iIndex < -1")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
Case Else
__IEConsoleWriteError("Error", "_IETagNameAllGetCollection", "$_IESTATUS_NoMatch")
Return SetError($_IESTATUS_NoMatch, 1, 0)
EndSelect
EndFunc
Func _IEGetObjByName(ByRef $oObject, $sName, $iIndex = 0)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEGetObjByName", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$iIndex = Number($iIndex)
If $iIndex = -1 Then
Return SetError($_IESTATUS_Success, $oObject.document.GetElementsByName($sName).length,  $oObject.document.GetElementsByName($sName))
Else
If IsObj($oObject.document.GetElementsByName($sName).item($iIndex)) Then
Return SetError($_IESTATUS_Success, $oObject.document.GetElementsByName($sName).length,  $oObject.document.GetElementsByName($sName).item($iIndex))
Else
__IEConsoleWriteError("Warning", "_IEGetObjByName", "$_IESTATUS_NoMatch", "Name: " & $sName & ", Index: " & $iIndex)
Return SetError($_IESTATUS_NoMatch, 0, 0)
EndIf
EndIf
EndFunc
Func _IEGetObjById(ByRef $oObject, $sID)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEGetObjById", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEGetObById", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If IsObj($oObject.document.getElementById($sID)) Then
Return SetError($_IESTATUS_Success, 0, $oObject.document.getElementById($sID))
Else
__IEConsoleWriteError("Warning", "_IEGetObjById", "$_IESTATUS_NoMatch", $sID)
Return SetError($_IESTATUS_NoMatch, 2, 0)
EndIf
EndFunc
Func _IEAction(ByRef $oObject, $sAction)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEAction(" & $sAction & ")", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
$sAction = StringLower($sAction)
Select
Case $sAction = "click"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(click)", " $_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Click()
Case $sAction = "disable"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(disable)", " $_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.disabled = True
Case $sAction = "enable"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(enable)", " $_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.disabled = False
Case $sAction = "focus"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(focus)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Focus()
Case $sAction = "scrollintoview"
If __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(scrollintoview)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.scrollIntoView()
Case $sAction = "copy"
$oObject.document.execCommand("Copy")
Case $sAction = "cut"
$oObject.document.execCommand("Cut")
Case $sAction = "paste"
$oObject.document.execCommand("Paste")
Case $sAction = "delete"
$oObject.document.execCommand("Delete")
Case $sAction = "saveas"
$oObject.document.execCommand("SaveAs")
Case $sAction = "refresh"
$oObject.document.execCommand("Refresh")
If @error Then
__IEConsoleWriteError("Error", "_IEAction(refresh)", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
_IELoadWait($oObject)
Case $sAction = "selectall"
$oObject.document.execCommand("SelectAll")
Case $sAction = "unselect"
$oObject.document.execCommand("Unselect")
Case $sAction = "print"
$oObject.document.parentwindow.Print()
Case $sAction = "printdefault"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(printdefault)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.execWB(6, 2)
Case $sAction = "back"
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(back)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.GoBack()
Case $sAction = "blur"
$oObject.Blur()
Case $sAction = "forward"
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(forward)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.GoForward()
Case $sAction = "home"
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(home)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.GoHome()
Case $sAction = "invisible"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(invisible)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.visible = 0
Case $sAction = "visible"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(visible)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.visible = 1
Case $sAction = "search"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(search)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.GoSearch()
Case $sAction = "stop"
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "_IEAction(stop)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Stop()
Case $sAction = "quit"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEAction(quit)", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Quit()
If @error Then
__IEConsoleWriteError("Error", "_IEAction(" & $sAction & ")", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
$oObject = 0
Return SetError($_IESTATUS_Success, 0, 1)
Case Else
__IEConsoleWriteError("Error", "_IEAction(" & $sAction & ")", "$_IESTATUS_InvalidValue", "Invalid Action")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndSelect
If @error Then
__IEConsoleWriteError("Error", "_IEAction(" & $sAction & ")", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func _IEPropertyGet(ByRef $oObject, $sProperty)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browserdom") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Local $oTemp, $iTemp
$sProperty = StringLower($sProperty)
Select
Case $sProperty = "browserx"
If __IEIsObjType($oObject, "browsercontainer") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oTemp = $oObject
$iTemp = 0
While IsObj($oTemp)
$iTemp += $oTemp.offsetLeft
$oTemp = $oTemp.offsetParent
WEnd
Return SetError($_IESTATUS_Success, 0, $iTemp)
Case $sProperty = "browsery"
If __IEIsObjType($oObject, "browsercontainer") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oTemp = $oObject
$iTemp = 0
While IsObj($oTemp)
$iTemp += $oTemp.offsetTop
$oTemp = $oTemp.offsetParent
WEnd
Return SetError($_IESTATUS_Success, 0, $iTemp)
Case $sProperty = "screenx"
If __IEIsObjType($oObject, "window") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.left())
Else
$oTemp = $oObject
$iTemp = 0
While IsObj($oTemp)
$iTemp += $oTemp.offsetLeft
$oTemp = $oTemp.offsetParent
WEnd
EndIf
Return SetError($_IESTATUS_Success, 0,  $iTemp + $oObject.document.parentWindow.screenLeft)
Case $sProperty = "screeny"
If __IEIsObjType($oObject, "window") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.top())
Else
$oTemp = $oObject
$iTemp = 0
While IsObj($oTemp)
$iTemp += $oTemp.offsetTop
$oTemp = $oTemp.offsetParent
WEnd
EndIf
Return SetError($_IESTATUS_Success, 0,  $iTemp + $oObject.document.parentWindow.screenTop)
Case $sProperty = "height"
If __IEIsObjType($oObject, "window") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.Height())
Else
Return SetError($_IESTATUS_Success, 0, $oObject.offsetHeight)
EndIf
Case $sProperty = "width"
If __IEIsObjType($oObject, "window") Or __IEIsObjType($oObject, "document") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.Width())
Else
Return SetError($_IESTATUS_Success, 0, $oObject.offsetWidth)
EndIf
Case $sProperty = "isdisabled"
Return SetError($_IESTATUS_Success, 0, $oObject.isDisabled())
Case $sProperty = "addressbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.AddressBar())
Case $sProperty = "busy"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Busy())
Case $sProperty = "fullscreen"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.fullScreen())
Case $sProperty = "hwnd"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, HWnd($oObject.HWnd()))
Case $sProperty = "left"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Left())
Case $sProperty = "locationname"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.LocationName())
Case $sProperty = "locationurl"
If __IEIsObjType($oObject, "browser") Then
Return SetError($_IESTATUS_Success, 0, $oObject.locationURL())
EndIf
If __IEIsObjType($oObject, "window") Then
Return SetError($_IESTATUS_Success, 0, $oObject.location.href())
EndIf
If __IEIsObjType($oObject, "document") Then
Return SetError($_IESTATUS_Success, 0, $oObject.parentwindow.location.href())
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentwindow.location.href())
Case $sProperty = "menubar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.MenuBar())
Case $sProperty = "offline"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.OffLine())
Case $sProperty = "readystate"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.ReadyState())
Case $sProperty = "resizable"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Resizable())
Case $sProperty = "silent"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Silent())
Case $sProperty = "statusbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.StatusBar())
Case $sProperty = "statustext"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.StatusText())
Case $sProperty = "top"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Top())
Case $sProperty = "visible"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.Visible())
Case $sProperty = "appcodename"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.appCodeName())
Case $sProperty = "appminorversion"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.appMinorVersion())
Case $sProperty = "appname"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.appName())
Case $sProperty = "appversion"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.appVersion())
Case $sProperty = "browserlanguage"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.browserLanguage())
Case $sProperty = "cookieenabled"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.cookieEnabled())
Case $sProperty = "cpuclass"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.cpuClass())
Case $sProperty = "javaenabled"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.javaEnabled())
Case $sProperty = "online"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.onLine())
Case $sProperty = "platform"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.platform())
Case $sProperty = "systemlanguage"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.systemLanguage())
Case $sProperty = "useragent"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.userAgent())
Case $sProperty = "userlanguage"
Return SetError($_IESTATUS_Success, 0, $oObject.document.parentWindow.top.navigator.userLanguage())
Case $sProperty = "referrer"
Return SetError($_IESTATUS_Success, 0, $oObject.document.referrer)
Case $sProperty = "theatermode"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.TheaterMode)
Case $sProperty = "toolbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject.ToolBar)
Case $sProperty = "contenteditable"
If __IEIsObjType($oObject, "browser") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.isContentEditable)
Case $sProperty = "innertext"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.innerText)
Case $sProperty = "outertext"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.outerText)
Case $sProperty = "innerhtml"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.innerHTML)
Case $sProperty = "outerhtml"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
Return SetError($_IESTATUS_Success, 0, $oTemp.outerHTML)
Case $sProperty = "title"
Return SetError($_IESTATUS_Success, 0, $oObject.document.title)
Case $sProperty = "uniqueid"
If __IEIsObjType($oObject, "window") Then
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
Else
Return SetError($_IESTATUS_Success, 0, $oObject.uniqueID)
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEPropertyGet", "$_IESTATUS_InvalidValue", "Invalid Property")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndSelect
EndFunc
Func _IEPropertySet(ByRef $oObject, $sProperty, $vValue)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $oTemp
#forceref $oTemp
$sProperty = StringLower($sProperty)
Select
Case $sProperty = "addressbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.AddressBar = $vValue
Case $sProperty = "height"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Height = $vValue
Case $sProperty = "left"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Left = $vValue
Case $sProperty = "menubar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.MenuBar = $vValue
Case $sProperty = "offline"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.OffLine = $vValue
Case $sProperty = "resizable"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Resizable = $vValue
Case $sProperty = "statusbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.StatusBar = $vValue
Case $sProperty = "statustext"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.StatusText = $vValue
Case $sProperty = "top"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Top = $vValue
Case $sProperty = "width"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.Width = $vValue
Case $sProperty = "theatermode"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If $vValue Then
$oObject.TheaterMode = True
Else
$oObject.TheaterMode = False
EndIf
Case $sProperty = "toolbar"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If $vValue Then
$oObject.ToolBar = True
Else
$oObject.ToolBar = False
EndIf
Case $sProperty = "contenteditable"
If __IEIsObjType($oObject, "browser") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
If $vValue Then
$oTemp.contentEditable = "true"
Else
$oTemp.contentEditable = "false"
EndIf
Case $sProperty = "innertext"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
$oTemp.innerText = $vValue
Case $sProperty = "outertext"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
$oTemp.outerText = $vValue
Case $sProperty = "innerhtml"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
$oTemp.innerHTML = $vValue
Case $sProperty = "outerhtml"
If __IEIsObjType($oObject, "documentcontainer") Or __IEIsObjType($oObject, "document") Then
$oTemp = $oObject.document.body
Else
$oTemp = $oObject
EndIf
$oTemp.outerHTML = $vValue
Case $sProperty = "title"
$oObject.document.title = $vValue
Case $sProperty = "silent"
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
If $vValue Then
$oObject.silent = True
Else
$oObject.silent = False
EndIf
Case Else
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_InvalidValue", "Invalid Property")
Return SetError($_IESTATUS_InvalidValue, 2, 0)
EndSelect
If @error Then
__IEConsoleWriteError("Error", "_IEPropertySet", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
Return SetError($_IESTATUS_Success, 0, 0)
EndFunc
Func _IEErrorNotify($vNotify = Default)
If $vNotify = Default Then Return $__g_bIEErrorNotify
If $vNotify Then
$__g_bIEErrorNotify = True
Else
$__g_bIEErrorNotify = False
EndIf
Return 1
EndFunc
Func _IEErrorHandlerRegister($sFunctionName = "__IEInternalErrorHandler")
$__g_oIEErrorHandler = ObjEvent("AutoIt.Error", $sFunctionName)
If IsObj($__g_oIEErrorHandler) Then
$__g_sIEUserErrorHandler = $sFunctionName
Return SetError($_IESTATUS_Success, 0, 1)
Else
$__g_oIEErrorHandler = ""
__IEConsoleWriteError("Error", "_IEErrorHandlerRegister", "$_IEStatus_GeneralError",  "Error Handler Not Registered - Check existance of error function")
Return SetError($_IEStatus_GeneralError, 1, 0)
EndIf
EndFunc
Func _IEErrorHandlerDeRegister()
$__g_sIEUserErrorHandler = ""
$__g_oIEErrorHandler = ""
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func __IEInternalErrorHandlerRegister()
Local $sCurrentErrorHandler = ObjEvent("AutoIt.Error")
If $sCurrentErrorHandler <> "" And Not IsObj($__g_oIEErrorHandler) Then
Return SetError($_IEStatus_GeneralError, 0, False)
EndIf
$__g_oIEErrorHandler = ObjEvent("AutoIt.Error", "__IEInternalErrorHandler")
If IsObj($__g_oIEErrorHandler) Then
Return SetError($_IESTATUS_Success, 0, True)
Else
$__g_oIEErrorHandler = ""
Return SetError($_IEStatus_GeneralError, 0, False)
EndIf
EndFunc
Func __IEInternalErrorHandlerDeRegister()
$__g_oIEErrorHandler = ""
If $__g_sIEUserErrorHandler <> "" Then
$__g_oIEErrorHandler = ObjEvent("AutoIt.Error", $__g_sIEUserErrorHandler)
EndIf
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
Func __IEInternalErrorHandler($oCOMError)
If $__g_bIEErrorNotify Or $__g_bIEAU3Debug Then ConsoleWrite("--> " & __COMErrorFormating($oCOMError, "----> $IEComError") & @CRLF)
SetError($_IEStatus_ComError)
Return
EndFunc
Func _IEQuit(ByRef $oObject)
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "_IEQuit", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "browser") Then
__IEConsoleWriteError("Error", "_IEQuit", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.quit()
If @error Then
__IEConsoleWriteError("Error", "_IEQuit", "$_IESTATUS_COMError", @error)
Return SetError($_IESTATUS_ComError, @error, 0)
EndIf
$oObject = 0
Return SetError($_IESTATUS_Success, 0, 1)
EndFunc
#EndRegion Utility functions
#Region General
Func _IE_Introduction($sModule = "basic")
Local $sHTML = ""
Switch $sModule
Case "basic"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Introduction ("basic")</title>' & @CR
$sHTML &= '<style>body {font-family: Arial}' & @CR
$sHTML &= 'td {padding:6px}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '<table border=1 id="table1" style="width:600px;border-spacing:6px;">' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<h1>Welcome to IE.au3</h1>' & @CR
$sHTML &= 'IE.au3 is a UDF (User Defined Function) library for the ' & @CR
$sHTML &= '<a href="http://www.autoitscript.com">AutoIt</a> scripting language.' & @CR
$sHTML &= '<br>  ' & @CR
$sHTML &= 'IE.au3 allows you to either create or attach to an Internet Explorer browser and do ' & @CR
$sHTML &= 'just about anything you could do with it interactively with the mouse and ' & @CR
$sHTML &= 'keyboard, but do it through script.' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= 'You can navigate to pages, click links, fill and submit forms etc. You can ' & @CR
$sHTML &= 'also do things you cannot do interactively like change or rewrite page ' & @CR
$sHTML &= 'content and JavaScripts, read, parse and save page content and monitor and act ' & @CR
$sHTML &= 'upon browser "events".<br>' & @CR
$sHTML &= 'IE.au3 uses the COM interface in AutoIt to interact with the Internet Explorer ' & @CR
$sHTML &= 'object model and the DOM (Document Object Model) supported by the browser.' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= 'Here are some links for more information and helpful tools:<br>' & @CR
$sHTML &= 'Reference Material: ' & @CR
$sHTML &= '<ul>' & @CR
$sHTML &= '<li><a href="http://msdn1.microsoft.com/">MSDN (Microsoft Developer Network)</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/library/aa752084.aspx" target="_blank">InternetExplorer Object</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/library/ms531073.aspx" target="_blank">Document Object</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/ie/aa740473.aspx" target="_blank">Overviews and Tutorials</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/library/ms533029.aspx" target="_blank">DHTML Objects</a></li>' & @CR
$sHTML &= '<li><a href="http://msdn2.microsoft.com/en-us/library/ms533051.aspx" target="_blank">DHTML Events</a></li>' & @CR
$sHTML &= '</ul><br>' & @CR
$sHTML &= 'Helpful Tools: ' & @CR
$sHTML &= '<ul>' & @CR
$sHTML &= '<li><a href="http://www.autoitscript.com/forum/index.php?showtopic=19368" target="_blank">AutoIt IE Builder</a> (build IE scripts interactively)</li>' & @CR
$sHTML &= '<li><a href="http://www.debugbar.com/" target="_blank">DebugBar</a> (DOM inspector, HTTP inspector, HTML validator and more - free for personal use) Recommended</li>' & @CR
$sHTML &= '<li><a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=e59c3964-672d-4511-bb3e-2d5e1db91038&amp;displaylang=en" target="_blank">IE Developer Toolbar</a> (comprehensive DOM analysis tool)</li>' & @CR
$sHTML &= '<li><a href="http://slayeroffice.com/tools/modi/v2.0/modi_help.html" target="_blank">MODIV2</a> (view the DOM of a web page by mousing around)</li>' & @CR
$sHTML &= '<li><a href="http://validator.w3.org/" target="_blank">HTML Validator</a> (verify HTML follows format rules)</li>' & @CR
$sHTML &= '<li><a href="http://www.fiddlertool.com/fiddler/" target="_blank">Fiddler</a> (examine HTTP traffic)</li>' & @CR
$sHTML &= '</ul>' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
Case Else
__IEConsoleWriteError("Error", "_IE_Introduction", "$_IESTATUS_InvalidValue")
Return SetError($_IESTATUS_InvalidValue, 1, 0)
EndSwitch
Local $oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
Return SetError($_IESTATUS_Success, 0, $oObject)
EndFunc
Func _IE_Example($sModule = "basic")
Local $sHTML = "", $oObject
Switch $sModule
Case "basic"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("basic")</title>' & @CR
$sHTML &= '<style>body {font-family: Arial}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '<a href="http://www.autoitscript.com"><img src="http://www.autoitscript.com/images/autoit_6_240x100.jpg" id="AutoItImage" alt="AutoIt Homepage Image"></a>' & @CR
$sHTML &= '<p></p>' & @CR
$sHTML &= '<div id="line1">This is a simple HTML page with text, links and images.</div>' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= '<div id="line2"><a href="http://www.autoitscript.com">AutoIt</a> is a wonderful automation scripting language.</div>' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= '<div id="line3">It is supported by a very active and supporting <a href="http://www.autoitscript.com/forum/">user forum</a>.</div>' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= '<div id="IEAu3Data"></div>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
Case "table"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=utf-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("table")</title>' & @CR
$sHTML &= '<style>body {font-family: Arial}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '$oTableOne = _IETableGetObjByName($oIE, "tableOne")<br>' & @CR
$sHTML &= '&lt;table border=1 id="tableOne"&gt;<br>' & @CR
$sHTML &= '<table border=1 id="tableOne">' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>AutoIt</td>' & @CR
$sHTML &= '		<td>is</td>' & @CR
$sHTML &= '		<td>really</td>' & @CR
$sHTML &= '		<td>great</td>' & @CR
$sHTML &= '		<td>with</td>' & @CR
$sHTML &= '		<td>IE.au3</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>1</td>' & @CR
$sHTML &= '		<td>2</td>' & @CR
$sHTML &= '		<td>3</td>' & @CR
$sHTML &= '		<td>4</td>' & @CR
$sHTML &= '		<td>5</td>' & @CR
$sHTML &= '		<td>6</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>the</td>' & @CR
$sHTML &= '		<td>quick</td>' & @CR
$sHTML &= '		<td>red</td>' & @CR
$sHTML &= '		<td>fox</td>' & @CR
$sHTML &= '		<td>jumped</td>' & @CR
$sHTML &= '		<td>over</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>the</td>' & @CR
$sHTML &= '		<td>lazy</td>' & @CR
$sHTML &= '		<td>brown</td>' & @CR
$sHTML &= '		<td>dog</td>' & @CR
$sHTML &= '		<td>the</td>' & @CR
$sHTML &= '		<td>time</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>has</td>' & @CR
$sHTML &= '		<td>come</td>' & @CR
$sHTML &= '		<td>for</td>' & @CR
$sHTML &= '		<td>all</td>' & @CR
$sHTML &= '		<td>good</td>' & @CR
$sHTML &= '		<td>men</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>to</td>' & @CR
$sHTML &= '		<td>come</td>' & @CR
$sHTML &= '		<td>to</td>' & @CR
$sHTML &= '		<td>the</td>' & @CR
$sHTML &= '		<td>aid</td>' & @CR
$sHTML &= '		<td>of</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '<br>' & @CR
$sHTML &= '$oTableTwo = _IETableGetObjByName($oIE, "tableTwo")<br>' & @CR
$sHTML &= '&lt;table border="1" id="tableTwo"&gt;<br>' & @CR
$sHTML &= '<table border=1 id="tableTwo">' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td colspan="4">Table Top</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>One</td>' & @CR
$sHTML &= '		<td colspan="3">Two</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>Three</td>' & @CR
$sHTML &= '		<td>Four</td>' & @CR
$sHTML &= '		<td colspan="2">Five</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>Six</td>' & @CR
$sHTML &= '		<td colspan="3">Seven</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '	<tr>' & @CR
$sHTML &= '		<td>Eight</td>' & @CR
$sHTML &= '		<td>Nine</td>' & @CR
$sHTML &= '		<td>Ten</td>' & @CR
$sHTML &= '		<td>Eleven</td>' & @CR
$sHTML &= '	</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
Case "form"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("form")</title>' & @CR
$sHTML &= '<style>body {font-family: Arial}' & @CR
$sHTML &= 'td {padding:6px}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '<form name="ExampleForm" onSubmit="javascript:alert(''ExampleFormSubmitted'');" method="post">' & @CR
$sHTML &= '<table style="border-spacing:6px 6px;" border=1>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>ExampleForm</td>' & @CR
$sHTML &= '<td>&lt;form name="ExampleForm" onSubmit="javascript:alert(''ExampleFormSubmitted'');" method="post"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>Hidden Input Element<input type="hidden" name="hiddenExample" value="secret value"></td>' & @CR
$sHTML &= '<td>&lt;input type="hidden" name="hiddenExample" value="secret value"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="text" name="textExample" value="http://" size="20" maxlength="30">' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="text" name="textExample" value="http://" size="20" maxlength="30"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="password" name="passwordExample" size="10">' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="password" name="passwordExample" size="10"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="file" name="fileExample">' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="file" name="fileExample"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="image" name="imageExample" alt="AutoIt Homepage" src="http://www.autoitscript.com/images/autoit_6_240x100.jpg">' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="image" name="imageExample" alt="AutoIt Homepage" src="http://www.autoitscript.com/images/autoit_6_240x100.jpg"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<textarea name="textareaExample" rows="5" cols="15">Hello!</textarea>' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;textarea name="textareaExample" rows="5" cols="15"&gt;Hello!&lt;/textarea&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="checkbox" name="checkboxG1Example" value="gameBasketball">Basketball<br>' & @CR
$sHTML &= '<input type="checkbox" name="checkboxG1Example" value="gameFootball">Football<br>' & @CR
$sHTML &= '<input type="checkbox" name="checkboxG2Example" value="gameTennis" checked>Tennis<br>' & @CR
$sHTML &= '<input type="checkbox" name="checkboxG2Example" value="gameBaseball">Baseball' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input type="checkbox" name="checkboxG1Example" value="gameBasketball"&gt;Basketball&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="checkbox" name="checkboxG1Example" value="gameFootball"&gt;Football&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="checkbox" name="checkboxG2Example" value="gameTennis" checked&gt;Tennis&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="checkbox" name="checkboxG2Example" value="gameBaseball"&gt;Baseball</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input type="radio" name="radioExample" value="vehicleAirplane">Airplane<br>' & @CR
$sHTML &= '<input type="radio" name="radioExample" value="vehicleTrain" checked>Train<br>' & @CR
$sHTML &= '<input type="radio" name="radioExample" value="vehicleBoat">Boat<br>' & @CR
$sHTML &= '<input type="radio" name="radioExample" value="vehicleCar">Car</td>' & @CR
$sHTML &= '<td>&lt;input type="radio" name="radioExample" value="vehicleAirplane"&gt;Airplane&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="radio" name="radioExample" value="vehicleTrain" checked&gt;Train&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="radio" name="radioExample" value="vehicleBoat"&gt;Boat&lt;br&gt;<br>' & @CR
$sHTML &= '&lt;input type="radio" name="radioExample" value="vehicleCar"&gt;Car&lt;br&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<select name="selectExample">' & @CR
$sHTML &= '<option value="homepage.html">Homepage' & @CR
$sHTML &= '<option value="midipage.html">Midipage' & @CR
$sHTML &= '<option value="freepage.html">Freepage' & @CR
$sHTML &= '</select>' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;select name="selectExample"&gt;<br>' & @CR
$sHTML &= '&lt;option value="homepage.html"&gt;Homepage<br>' & @CR
$sHTML &= '&lt;option value="midipage.html"&gt;Midipage<br>' & @CR
$sHTML &= '&lt;option value="freepage.html"&gt;Freepage<br>' & @CR
$sHTML &= '&lt;/select&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<select name="multipleSelectExample" size="6" multiple>' & @CR
$sHTML &= '<option value="Name1">Aaron' & @CR
$sHTML &= '<option value="Name2">Bruce' & @CR
$sHTML &= '<option value="Name3">Carlos' & @CR
$sHTML &= '<option value="Name4">Denis' & @CR
$sHTML &= '<option value="Name5">Ed' & @CR
$sHTML &= '<option value="Name6">Freddy' & @CR
$sHTML &= '</select>' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;select name="multipleSelectExample" size="6" multiple&gt;<br>' & @CR
$sHTML &= '&lt;option value="Name1"&gt;Aaron<br>' & @CR
$sHTML &= '&lt;option value="Name2"&gt;Bruce<br>' & @CR
$sHTML &= '&lt;option value="Name3"&gt;Carlos<br>' & @CR
$sHTML &= '&lt;option value="Name4"&gt;Denis<br>' & @CR
$sHTML &= '&lt;option value="Name5"&gt;Ed<br>' & @CR
$sHTML &= '&lt;option value="Name6"&gt;Freddy<br>' & @CR
$sHTML &= '&lt;/select&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td>' & @CR
$sHTML &= '<input name="submitExample" type="submit" value="Submit">' & @CR
$sHTML &= '<input name="resetExample" type="reset" value="Reset">' & @CR
$sHTML &= '</td>' & @CR
$sHTML &= '<td>&lt;input name="submitExample" type="submit" value="Submit"&gt;<br>' & @CR
$sHTML &= '&lt;input name="resetExample" type="reset" value="Reset"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '<input type="hidden" name="hiddenExample" value="secret value">' & @CR
$sHTML &= '</form>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
Case "frameset"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("frameset")</title>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<frameset rows="25,200">' & @CR
$sHTML &= '	<frame name=Top SRC=about:blank>' & @CR
$sHTML &= '	<frameset cols="100,500">' & @CR
$sHTML &= '		<frame name=Menu SRC=about:blank>' & @CR
$sHTML &= '		<frame name=Main SRC=about:blank>' & @CR
$sHTML &= '	</frameset>' & @CR
$sHTML &= '</frameset>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
_IEAction($oObject, "refresh")
Local $oFrameTop = _IEFrameGetObjByName($oObject, "Top")
Local $oFrameMenu = _IEFrameGetObjByName($oObject, "Menu")
Local $oFrameMain = _IEFrameGetObjByName($oObject, "Main")
_IEBodyWriteHTML($oFrameTop, '$oFrameTop = _IEFrameGetObjByName($oIE, "Top")')
_IEBodyWriteHTML($oFrameMenu, '$oFrameMenu = _IEFrameGetObjByName($oIE, "Menu")')
_IEBodyWriteHTML($oFrameMain, '$oFrameMain = _IEFrameGetObjByName($oIE, "Main")')
Case "iframe"
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>_IE_Example("iframe")</title>' & @CR
$sHTML &= '<style>td {padding:6px}</style>' & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR
$sHTML &= '<table style="border-spacing:6px" border=1>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td><iframe name="iFrameOne" src="about:blank" title="iFrameOne"></iframe></td>' & @CR
$sHTML &= '<td>&lt;iframe name="iFrameOne" src="about:blank" title="iFrameOne"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '<tr>' & @CR
$sHTML &= '<td><iframe name="iFrameTwo" src="about:blank" title="iFrameTwo"></iframe></td>' & @CR
$sHTML &= '<td>&lt;iframe name="iFrameTwo" src="about:blank" title="iFrameTwo"&gt;</td>' & @CR
$sHTML &= '</tr>' & @CR
$sHTML &= '</table>' & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
$oObject = _IECreate()
_IEDocWriteHTML($oObject, $sHTML)
_IEAction($oObject, "refresh")
Local $oIFrameOne = _IEFrameGetObjByName($oObject, "iFrameOne")
Local $oIFrameTwo = _IEFrameGetObjByName($oObject, "iFrameTwo")
_IEBodyWriteHTML($oIFrameOne, '$oIFrameOne = _IEFrameGetObjByName($oIE, "iFrameOne")')
_IEBodyWriteHTML($oIFrameTwo, '$oIFrameTwo = _IEFrameGetObjByName($oIE, "iFrameTwo")')
Case Else
__IEConsoleWriteError("Error", "_IE_Example", "$_IESTATUS_InvalidValue")
Return SetError($_IESTATUS_InvalidValue, 1, 0)
EndSwitch
Sleep(500)
Return SetError($_IESTATUS_Success, 0, $oObject)
EndFunc
Func _IE_VersionInfo()
__IEConsoleWriteError("Information", "_IE_VersionInfo", "version " &  $__gaIEAU3VersionInfo[0] &  $__gaIEAU3VersionInfo[1] & "." &  $__gaIEAU3VersionInfo[2] & "-" &  $__gaIEAU3VersionInfo[3], "Release date: " & $__gaIEAU3VersionInfo[4])
Return SetError($_IESTATUS_Success, 0, $__gaIEAU3VersionInfo)
EndFunc
#EndRegion General
#Region Internal functions
Func __IELockSetForegroundWindow($iLockCode)
Local $aRet = DllCall("user32.dll", "bool", "LockSetForegroundWindow", "uint", $iLockCode)
If @error Or Not $aRet[0] Then Return SetError(1, _WinAPI_GetLastError(), 0)
Return $aRet[0]
EndFunc
Func __IEControlGetObjFromHWND(ByRef $hWin)
DllCall("ole32.dll", "long", "CoInitialize", "ptr", 0)
If @error Then Return SetError(2, @error, 0)
Local Const $WM_HTML_GETOBJECT = __IERegisterWindowMessage("WM_HTML_GETOBJECT")
Local Const $SMTO_ABORTIFHUNG = 0x0002
Local $iResult
__IESendMessageTimeout($hWin, $WM_HTML_GETOBJECT, 0, 0, $SMTO_ABORTIFHUNG, 1000, $iResult)
Local $tUUID = DllStructCreate("int;short;short;byte[8]")
DllStructSetData($tUUID, 1, 0x626FC520)
DllStructSetData($tUUID, 2, 0xA41E)
DllStructSetData($tUUID, 3, 0x11CF)
DllStructSetData($tUUID, 4, 0xA7, 1)
DllStructSetData($tUUID, 4, 0x31, 2)
DllStructSetData($tUUID, 4, 0x0, 3)
DllStructSetData($tUUID, 4, 0xA0, 4)
DllStructSetData($tUUID, 4, 0xC9, 5)
DllStructSetData($tUUID, 4, 0x8, 6)
DllStructSetData($tUUID, 4, 0x26, 7)
DllStructSetData($tUUID, 4, 0x37, 8)
Local $aRet = DllCall("oleacc.dll", "long", "ObjectFromLresult", "lresult", $iResult, "struct*", $tUUID,  "wparam", 0, "idispatch*", 0)
If @error Then Return SetError(3, @error, 0)
If IsObj($aRet[4]) Then
Local $oIE = $aRet[4].Script()
Return $oIE.Document.parentwindow
Else
Return SetError(1, $aRet[0], 0)
EndIf
EndFunc
Func __IERegisterWindowMessage($sMsg)
Local $aRet = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $sMsg)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 0 Then Return SetError(10, _WinAPI_GetLastError(), 0)
Return $aRet[0]
EndFunc
Func __IESendMessageTimeout($hWnd, $iMsg, $wParam, $lParam, $iFlags, $iTimeout, ByRef $vOut, $r = 0, $sT1 = "int", $sT2 = "int")
Local $aRet = DllCall("user32.dll", "lresult", "SendMessageTimeout", "hwnd", $hWnd, "uint", $iMsg, $sT1, $wParam,  $sT2, $lParam, "uint", $iFlags, "uint", $iTimeout, "dword_ptr*", "")
If @error Or $aRet[0] = 0 Then
$vOut = 0
Return SetError(1, _WinAPI_GetLastError(), 0)
EndIf
$vOut = $aRet[7]
If $r >= 0 And $r <= 4 Then Return $aRet[$r]
Return $aRet
EndFunc
Func __IEIsObjType(ByRef $oObject, $sType, $bRegister = True)
If Not IsObj($oObject) Then
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
Local $bStatus = $bRegister
If $bRegister Then
$bStatus = __IEInternalErrorHandlerRegister()
If Not $bStatus Then __IEConsoleWriteError("Warning", "internal function __IEIsObjType",  "Cannot register internal error handler, cannot trap COM errors",  "Use _IEErrorHandlerRegister() to register a user error handler")
EndIf
Local $iNotifyStatus = _IEErrorNotify()
_IEErrorNotify(False)
Local $sName = String(ObjName($oObject)), $iErrorStatus = $_IESTATUS_InvalidObjectType
Switch $sType
Case "browserdom"
If __IEIsObjType($oObject, "documentcontainer", False) Then
$iErrorStatus = $_IESTATUS_Success
ElseIf __IEIsObjType($oObject, "document", False) Then
$iErrorStatus = $_IESTATUS_Success
Else
Local $oTemp = $oObject.document
If __IEIsObjType($oTemp, "document", False) Then
$iErrorStatus = $_IESTATUS_Success
EndIf
EndIf
Case "browser"
If ($sName = "IWebBrowser2") Or ($sName = "IWebBrowser") Or ($sName = "WebBrowser") Then $iErrorStatus = $_IESTATUS_Success
Case "window"
If $sName = "HTMLWindow2" Then $iErrorStatus = $_IESTATUS_Success
Case "documentContainer"
If __IEIsObjType($oObject, "window", False) Or __IEIsObjType($oObject, "browser", False) Then $iErrorStatus = $_IESTATUS_Success
Case "document"
If $sName = "HTMLDocument" Then $iErrorStatus = $_IESTATUS_Success
Case "table"
If $sName = "HTMLTable" Then $iErrorStatus = $_IESTATUS_Success
Case "form"
If $sName = "HTMLFormElement" Then $iErrorStatus = $_IESTATUS_Success
Case "forminputelement"
If ($sName = "HTMLInputElement") Or ($sName = "HTMLSelectElement") Or ($sName = "HTMLTextAreaElement") Then $iErrorStatus = $_IESTATUS_Success
Case "elementcollection"
If ($sName = "HTMLElementCollection") Then $iErrorStatus = $_IESTATUS_Success
Case "formselectelement"
If $sName = "HTMLSelectElement" Then $iErrorStatus = $_IESTATUS_Success
Case Else
$iErrorStatus = $_IESTATUS_InvalidValue
EndSwitch
_IEErrorNotify($iNotifyStatus)
If $bRegister Then
__IEInternalErrorHandlerDeRegister()
EndIf
If $iErrorStatus = $_IESTATUS_Success Then
Return SetError($_IESTATUS_Success, 0, 1)
Else
Return SetError($iErrorStatus, 1, 0)
EndIf
EndFunc
Func __IEConsoleWriteError($sSeverity, $sFunc, $sMessage = Default, $sStatus = Default)
If $__g_bIEErrorNotify Or $__g_bIEAU3Debug Then
Local $sStr = "--> IE.au3 " & $__gaIEAU3VersionInfo[5] & " " & $sSeverity & " from function " & $sFunc
If Not ($sMessage = Default) Then $sStr &= ", " & $sMessage
If Not ($sStatus = Default) Then $sStr &= " (" & $sStatus & ")"
ConsoleWrite($sStr & @CRLF)
EndIf
Return SetError($sStatus, 0, 1)
EndFunc
Func __IEComErrorUnrecoverable($iError)
Switch $iError
Case -2147352567
Return $_IESTATUS_AccessIsDenied
Case -2147024891
Return $_IESTATUS_AccessIsDenied
Case -2147417848
Return $_IESTATUS_ClientDisconnected
Case -2147023174
Return $_IESTATUS_ClientDisconnected
Case -2147023179
Return $_IESTATUS_ClientDisconnected
Case Else
Return $_IESTATUS_Success
EndSwitch
EndFunc
#EndRegion Internal functions
#Region ProtoType Functions
Func __IENavigate(ByRef $oObject, $sUrl, $iWait = 1, $iFags = 0, $sTarget = "", $sPostdata = "", $sHeaders = "")
__IEConsoleWriteError("Warning", "__IENavigate", "Unsupported function called. Not fully tested.")
If Not IsObj($oObject) Then
__IEConsoleWriteError("Error", "__IENavigate", "$_IESTATUS_InvalidDataType")
Return SetError($_IESTATUS_InvalidDataType, 1, 0)
EndIf
If Not __IEIsObjType($oObject, "documentContainer") Then
__IEConsoleWriteError("Error", "__IENavigate", "$_IESTATUS_InvalidObjectType")
Return SetError($_IESTATUS_InvalidObjectType, 1, 0)
EndIf
$oObject.navigate($sUrl, $iFags, $sTarget, $sPostdata, $sHeaders)
If $iWait Then
_IELoadWait($oObject)
Return SetError(@error, 0, $oObject)
EndIf
Return SetError($_IESTATUS_Success, 0, $oObject)
EndFunc
Func __IEStringToBstr($sString, $sCharSet = "us-ascii")
Local Const $iTypeBinary = 1, $iTypeText = 2
Local $oStream = ObjCreate("ADODB.Stream")
$oStream.type = $iTypeText
$oStream.CharSet = $sCharSet
$oStream.Open
$oStream.WriteText($sString)
$oStream.Position = 0
$oStream.type = $iTypeBinary
$oStream.Position = 0
Return $oStream.Read()
EndFunc
Func __IEBstrToString($oBstr, $sCharSet = "us-ascii")
Local Const $iTypeBinary = 1, $iTypeText = 2
Local $oStream = ObjCreate("ADODB.Stream")
$oStream.type = $iTypeBinary
$oStream.Open
$oStream.Write($oBstr)
$oStream.Position = 0
$oStream.type = $iTypeText
$oStream.CharSet = $sCharSet
$oStream.Position = 0
Return $oStream.ReadText()
EndFunc
Func __IECreateNewIE($sTitle, $sHead = "", $sBody = "")
Local $sTemp = __IETempFile("", "~IE~", ".htm")
If @error Then
__IEConsoleWriteError("Error", "_IECreateHTA", "", "Error creating temporary file in @TempDir or @ScriptDir")
Return SetError($_IESTATUS_GeneralError, 1, 0)
EndIf
Local $sHTML = ''
$sHTML &= '<!DOCTYPE html>' & @CR
$sHTML &= '<html>' & @CR
$sHTML &= '<head>' & @CR
$sHTML &= '<meta content="text/html; charset=UTF-8" http-equiv="content-type">' & @CR
$sHTML &= '<title>' & $sTemp & '</title>' & @CR & $sHead & @CR
$sHTML &= '</head>' & @CR
$sHTML &= '<body>' & @CR & $sBody & @CR
$sHTML &= '</body>' & @CR
$sHTML &= '</html>'
Local $hFile = FileOpen($sTemp, $FO_OVERWRITE)
FileWrite($hFile, $sHTML)
FileClose($hFile)
If @error Then
__IEConsoleWriteError("Error", "_IECreateNewIE", "", "Error creating temporary file in @TempDir or @ScriptDir")
Return SetError($_IESTATUS_GeneralError, 2, 0)
EndIf
Run(@ProgramFilesDir & "\Internet Explorer\iexplore.exe " & $sTemp)
Local $iPID
If WinWait($sTemp, "", 60) Then
$iPID = WinGetProcess($sTemp)
Else
__IEConsoleWriteError("Error", "_IECreateNewIE", "", "Timeout waiting for new IE window creation")
Return SetError($_IESTATUS_GeneralError, 3, 0)
EndIf
If Not FileDelete($sTemp) Then
__IEConsoleWriteError("Warning", "_IECreateNewIE", "", "Could not delete temporary file " & FileGetLongName($sTemp))
EndIf
Local $oObject = _IEAttach($sTemp)
_IELoadWait($oObject)
_IEPropertySet($oObject, "title", $sTitle)
Return SetError($_IESTATUS_Success, $iPID, $oObject)
EndFunc
Func __IETempFile($sDirectoryName = @TempDir, $sFilePrefix = "~", $sFileExtension = ".tmp", $iRandomLength = 7)
Local $sTempName, $iTmp = 0
If Not FileExists($sDirectoryName) Then $sDirectoryName = @TempDir
If Not FileExists($sDirectoryName) Then $sDirectoryName = @ScriptDir
If StringRight($sDirectoryName, 1) <> "\" Then $sDirectoryName = $sDirectoryName & "\"
Do
$sTempName = ""
While StringLen($sTempName) < $iRandomLength
$sTempName = $sTempName & Chr(Random(97, 122, 1))
WEnd
$sTempName = $sDirectoryName & $sFilePrefix & $sTempName & $sFileExtension
$iTmp += 1
If $iTmp > 200 Then
Return SetError($_IESTATUS_GeneralError, 1, 0)
EndIf
Until Not FileExists($sTempName)
Return $sTempName
EndFunc
#EndRegion ProtoType Functions
Global Const $HDF_LEFT = 0x00000000
Global Const $HDF_RIGHT = 0x00000001
Global Const $HDF_CENTER = 0x00000002
Global Const $HDF_JUSTIFYMASK = 0x00000003
Global Const $HDF_BITMAP_ON_RIGHT = 0x00001000
Global Const $HDF_BITMAP = 0x00002000
Global Const $HDF_STRING = 0x00004000
Global Const $HDF_OWNERDRAW = 0x00008000
Global Const $HDF_DISPLAYMASK = 0x0000F000
Global Const $HDF_RTLREADING = 0x00000004
Global Const $HDF_SORTDOWN = 0x00000200
Global Const $HDF_IMAGE = 0x00000800
Global Const $HDF_SORTUP = 0x00000400
Global Const $HDF_FLAGMASK = 0x00000E04
Global Const $HDI_WIDTH = 0x00000001
Global Const $HDI_TEXT = 0x00000002
Global Const $HDI_FORMAT = 0x00000004
Global Const $HDI_PARAM = 0x00000008
Global Const $HDI_BITMAP = 0x00000010
Global Const $HDI_IMAGE = 0x00000020
Global Const $HDI_DI_SETITEM = 0x00000040
Global Const $HDI_ORDER = 0x00000080
Global Const $HDI_FILTER = 0x00000100
Global Const $HHT_NOWHERE = 0x00000001
Global Const $HHT_ONHEADER = 0x00000002
Global Const $HHT_ONDIVIDER = 0x00000004
Global Const $HHT_ONDIVOPEN = 0x00000008
Global Const $HHT_ONFILTER = 0x00000010
Global Const $HHT_ONFILTERBUTTON = 0x00000020
Global Const $HHT_ABOVE = 0x00000100
Global Const $HHT_BELOW = 0x00000200
Global Const $HHT_TORIGHT = 0x00000400
Global Const $HHT_TOLEFT = 0x00000800
Global Const $HDM_FIRST = 0x1200
Global Const $HDM_CLEARFILTER = $HDM_FIRST + 24
Global Const $HDM_CREATEDRAGIMAGE = $HDM_FIRST + 16
Global Const $HDM_DELETEITEM = $HDM_FIRST + 2
Global Const $HDM_EDITFILTER = $HDM_FIRST + 23
Global Const $HDM_GETBITMAPMARGIN = $HDM_FIRST + 21
Global Const $HDM_GETFOCUSEDITEM = $HDM_FIRST + 27
Global Const $HDM_GETIMAGELIST = $HDM_FIRST + 9
Global Const $HDM_GETITEMA = $HDM_FIRST + 3
Global Const $HDM_GETITEMW = $HDM_FIRST + 11
Global Const $HDM_GETITEMCOUNT = $HDM_FIRST + 0
Global Const $HDM_GETITEMDROPDOWNRECT = $HDM_FIRST + 25
Global Const $HDM_GETITEMRECT = $HDM_FIRST + 7
Global Const $HDM_GETORDERARRAY = $HDM_FIRST + 17
Global Const $HDM_GETOVERFLOWRECT = $HDM_FIRST + 26
Global Const $HDM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $HDM_HITTEST = $HDM_FIRST + 6
Global Const $HDM_INSERTITEMA = $HDM_FIRST + 1
Global Const $HDM_INSERTITEMW = $HDM_FIRST + 10
Global Const $HDM_LAYOUT = $HDM_FIRST + 5
Global Const $HDM_ORDERTOINDEX = $HDM_FIRST + 15
Global Const $HDM_SETBITMAPMARGIN = $HDM_FIRST + 20
Global Const $HDM_SETFILTERCHANGETIMEOUT = $HDM_FIRST + 22
Global Const $HDM_SETFOCUSEDITEM = $HDM_FIRST + 28
Global Const $HDM_SETHOTDIVIDER = $HDM_FIRST + 19
Global Const $HDM_SETIMAGELIST = $HDM_FIRST + 8
Global Const $HDM_SETITEMA = $HDM_FIRST + 4
Global Const $HDM_SETITEMW = $HDM_FIRST + 12
Global Const $HDM_SETORDERARRAY = $HDM_FIRST + 18
Global Const $HDM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $HDN_FIRST = -300
Global Const $HDN_BEGINDRAG = $HDN_FIRST - 10
Global Const $HDN_BEGINTRACK = $HDN_FIRST - 6
Global Const $HDN_DIVIDERDBLCLICK = $HDN_FIRST - 5
Global Const $HDN_ENDDRAG = $HDN_FIRST - 11
Global Const $HDN_ENDTRACK = $HDN_FIRST - 7
Global Const $HDN_FILTERBTNCLICK = $HDN_FIRST - 13
Global Const $HDN_FILTERCHANGE = $HDN_FIRST - 12
Global Const $HDN_GETDISPINFO = $HDN_FIRST - 9
Global Const $HDN_ITEMCHANGED = $HDN_FIRST - 1
Global Const $HDN_ITEMCHANGING = $HDN_FIRST - 0
Global Const $HDN_ITEMCLICK = $HDN_FIRST - 2
Global Const $HDN_ITEMDBLCLICK = $HDN_FIRST - 3
Global Const $HDN_TRACK = $HDN_FIRST - 8
Global Const $HDN_BEGINTRACKW = $HDN_FIRST - 26
Global Const $HDN_DIVIDERDBLCLICKW = $HDN_FIRST - 25
Global Const $HDN_ENDTRACKW = $HDN_FIRST - 27
Global Const $HDN_GETDISPINFOW = $HDN_FIRST - 29
Global Const $HDN_ITEMCHANGEDW = $HDN_FIRST - 21
Global Const $HDN_ITEMCHANGINGW = $HDN_FIRST - 20
Global Const $HDN_ITEMCLICKW = $HDN_FIRST - 22
Global Const $HDN_ITEMDBLCLICKW = $HDN_FIRST - 23
Global Const $HDN_TRACKW = $HDN_FIRST - 28
Global Const $HDS_BUTTONS = 0x00000002
Global Const $HDS_CHECKBOXES = 0x00000400
Global Const $HDS_DRAGDROP = 0x00000040
Global Const $HDS_FILTERBAR = 0x00000100
Global Const $HDS_FLAT = 0x00000200
Global Const $HDS_FULLDRAG = 0x00000080
Global Const $HDS_HIDDEN = 0x00000008
Global Const $HDS_HORZ = 0x00000000
Global Const $HDS_HOTTRACK = 0x00000004
Global Const $HDS_NOSIZING = 0x0800
Global Const $HDS_OVERFLOW = 0x1000
Global Const $HDS_DEFAULT = 0x00000046
Global $__g_hHDRLastWnd
Global Const $__HEADERCONSTANT_ClassName = "SysHeader32"
Global Const $__HEADERCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__HEADERCONSTANT_SWP_SHOWWINDOW = 0x0040
Global Const $tagHDHITTESTINFO = $tagPOINT & ";uint Flags;int Item"
Global Const $tagHDLAYOUT = "ptr Rect;ptr WindowPos"
Global Const $tagHDTEXTFILTER = "ptr Text;int TextMax"
Func _GUICtrlHeader_AddItem($hWnd, $sText, $iWidth = 50, $iAlign = 0, $iImage = -1, $bOnRight = False)
Return _GUICtrlHeader_InsertItem($hWnd, _GUICtrlHeader_GetItemCount($hWnd), $sText, $iWidth, $iAlign, $iImage, $bOnRight)
EndFunc
Func _GUICtrlHeader_ClearFilter($hWnd, $iIndex)
Return _SendMessage($hWnd, $HDM_CLEARFILTER, $iIndex) <> 0
EndFunc
Func _GUICtrlHeader_ClearFilterAll($hWnd)
Return _SendMessage($hWnd, $HDM_CLEARFILTER, -1) <> 0
EndFunc
Func _GUICtrlHeader_Create($hWnd, $iStyle = 0x00000046)
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hHeader = _WinAPI_CreateWindowEx(0, $__HEADERCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
Local $tWindowPos = _GUICtrlHeader_Layout($hHeader, $tRECT)
Local $iFlags = BitOR(DllStructGetData($tWindowPos, "Flags"), $__HEADERCONSTANT_SWP_SHOWWINDOW)
_WinAPI_SetWindowPos($hHeader, DllStructGetData($tWindowPos, "InsertAfter"),  DllStructGetData($tWindowPos, "X"), DllStructGetData($tWindowPos, "Y"),  DllStructGetData($tWindowPos, "CX"), DllStructGetData($tWindowPos, "CY"), $iFlags)
_WinAPI_SetFont($hHeader, _WinAPI_GetStockObject($__HEADERCONSTANT_DEFAULT_GUI_FONT))
Return $hHeader
EndFunc
Func _GUICtrlHeader_CreateDragImage($hWnd, $iIndex)
Return Ptr(_SendMessage($hWnd, $HDM_CREATEDRAGIMAGE, $iIndex))
EndFunc
Func _GUICtrlHeader_DeleteItem($hWnd, $iIndex)
Return _SendMessage($hWnd, $HDM_DELETEITEM, $iIndex) <> 0
EndFunc
Func _GUICtrlHeader_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__HEADERCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlHeader_EditFilter($hWnd, $iIndex, $bDiscard = True)
Return _SendMessage($hWnd, $HDM_EDITFILTER, $iIndex, $bDiscard) <> 0
EndFunc
Func _GUICtrlHeader_GetBitmapMargin($hWnd)
Return _SendMessage($hWnd, $HDM_GETBITMAPMARGIN)
EndFunc
Func _GUICtrlHeader_GetImageList($hWnd)
Return Ptr(_SendMessage($hWnd, $HDM_GETIMAGELIST))
EndFunc
Func _GUICtrlHeader_GetItem($hWnd, $iIndex, ByRef $tItem)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$iRet = _SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_GETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_GetItemAlign($hWnd, $iIndex)
Switch BitAND(_GUICtrlHeader_GetItemFormat($hWnd, $iIndex), $HDF_JUSTIFYMASK)
Case $HDF_LEFT
Return 0
Case $HDF_RIGHT
Return 1
Case $HDF_CENTER
Return 2
Case Else
Return -1
EndSwitch
EndFunc
Func _GUICtrlHeader_GetItemBitmap($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_BITMAP)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "hBmp")
EndFunc
Func _GUICtrlHeader_GetItemCount($hWnd)
Return _SendMessage($hWnd, $HDM_GETITEMCOUNT)
EndFunc
Func _GUICtrlHeader_GetItemDisplay($hWnd, $iIndex)
Local $iRet = 0
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
If BitAND($iFormat, $HDF_BITMAP) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iFormat, $HDF_BITMAP_ON_RIGHT) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iFormat, $HDF_OWNERDRAW) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iFormat, $HDF_STRING) <> 0 Then $iRet = BitOR($iRet, 8)
Return $iRet
EndFunc
Func _GUICtrlHeader_GetItemFlags($hWnd, $iIndex)
Local $iRet = 0
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
If BitAND($iFormat, $HDF_IMAGE) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iFormat, $HDF_RTLREADING) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iFormat, $HDF_SORTDOWN) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iFormat, $HDF_SORTUP) <> 0 Then $iRet = BitOR($iRet, 8)
Return $iRet
EndFunc
Func _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_FORMAT)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Fmt")
EndFunc
Func _GUICtrlHeader_GetItemImage($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_IMAGE)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlHeader_GetItemOrder($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_ORDER)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Order")
EndFunc
Func _GUICtrlHeader_GetItemParam($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_PARAM)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Param")
EndFunc
Func _GUICtrlHeader_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlHeader_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlHeader_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
_SendMessage($hWnd, $HDM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT)
_SendMessage($hWnd, $HDM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Return $tRECT
EndFunc
Func _GUICtrlHeader_GetItemText($hWnd, $iIndex)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_TEXT)
DllStructSetData($tItem, "TextMax", 4096)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + DllStructGetSize($tBuffer), $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
_SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $HDM_GETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pText, $tBuffer, DllStructGetSize($tBuffer))
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlHeader_GetItemWidth($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_WIDTH)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "XY")
EndFunc
Func _GUICtrlHeader_GetOrderArray($hWnd)
Local $iItems = _GUICtrlHeader_GetItemCount($hWnd)
Local $tBuffer = DllStructCreate("int[" & $iItems & "]")
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
_SendMessage($hWnd, $HDM_GETORDERARRAY, $iItems, $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_SendMessage($hWnd, $HDM_GETORDERARRAY, $iItems, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Local $aBuffer[$iItems + 1]
$aBuffer[0] = $iItems
For $iI = 1 To $iItems
$aBuffer[$iI] = DllStructGetData($tBuffer, 1, $iI)
Next
Return $aBuffer
EndFunc
Func _GUICtrlHeader_GetUnicodeFormat($hWnd)
Return _SendMessage($hWnd, $HDM_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlHeader_HitTest($hWnd, $iX, $iY)
Local $tTest = DllStructCreate($tagHDHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
Local $aTest[11]
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$aTest[0] = _SendMessage($hWnd, $HDM_HITTEST, 0, $tTest, 0, "wparam", "struct*")
Else
Local $iTest = DllStructGetSize($tTest)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iTest, $tMemMap)
_MemWrite($tMemMap, $tTest)
$aTest[0] = _SendMessage($hWnd, $HDM_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tTest, $iTest)
_MemFree($tMemMap)
EndIf
Local $iFlags = DllStructGetData($tTest, "Flags")
$aTest[1] = BitAND($iFlags, $HHT_NOWHERE) <> 0
$aTest[2] = BitAND($iFlags, $HHT_ONHEADER) <> 0
$aTest[3] = BitAND($iFlags, $HHT_ONDIVIDER) <> 0
$aTest[4] = BitAND($iFlags, $HHT_ONDIVOPEN) <> 0
$aTest[5] = BitAND($iFlags, $HHT_ONFILTER) <> 0
$aTest[6] = BitAND($iFlags, $HHT_ONFILTERBUTTON) <> 0
$aTest[7] = BitAND($iFlags, $HHT_ABOVE) <> 0
$aTest[8] = BitAND($iFlags, $HHT_BELOW) <> 0
$aTest[9] = BitAND($iFlags, $HHT_TORIGHT) <> 0
$aTest[10] = BitAND($iFlags, $HHT_TOLEFT) <> 0
Return $aTest
EndFunc
Func _GUICtrlHeader_InsertItem($hWnd, $iIndex, $sText, $iWidth = 50, $iAlign = 0, $iImage = -1, $bOnRight = False)
Local $aAlign[3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $pBuffer, $iBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
$pBuffer = DllStructGetPtr($tBuffer)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
Local $iFmt = $aAlign[$iAlign]
Local $iMask = BitOR($HDI_WIDTH, $HDI_FORMAT)
If $sText <> "" Then
$iMask = BitOR($iMask, $HDI_TEXT)
$iFmt = BitOR($iFmt, $HDF_STRING)
EndIf
If $iImage <> -1 Then
$iMask = BitOR($iMask, $HDI_IMAGE)
$iFmt = BitOR($iFmt, $HDF_IMAGE)
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $HDF_BITMAP_ON_RIGHT)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "XY", $iWidth)
DllStructSetData($tItem, "Fmt", $iFmt)
DllStructSetData($tItem, "Image", $iImage)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $HDM_INSERTITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tItem, "Text", -1)
EndIf
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_INSERTITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_INSERTITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func _GUICtrlHeader_Layout($hWnd, ByRef $tRECT)
Local $tLayout = DllStructCreate($tagHDLAYOUT)
Local $tWindowPos = DllStructCreate($tagWINDOWPOS)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tLayout, "Rect", DllStructGetPtr($tRECT))
DllStructSetData($tLayout, "WindowPos", DllStructGetPtr($tWindowPos))
_SendMessage($hWnd, $HDM_LAYOUT, 0, $tLayout, 0, "wparam", "struct*")
Else
Local $iLayout = DllStructGetSize($tLayout)
Local $iRect = DllStructGetSize($tRECT)
Local $iWindowPos = DllStructGetSize($tWindowPos)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iLayout + $iRect + $iWindowPos, $tMemMap)
DllStructSetData($tLayout, "Rect", $pMemory + $iLayout)
DllStructSetData($tLayout, "WindowPos", $pMemory + $iLayout + $iRect)
_MemWrite($tMemMap, $tLayout, $pMemory, $iLayout)
_MemWrite($tMemMap, $tRECT, $pMemory + $iLayout, $iRect)
_SendMessage($hWnd, $HDM_LAYOUT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory + $iLayout + $iRect, $tWindowPos, $iWindowPos)
_MemFree($tMemMap)
EndIf
Return $tWindowPos
EndFunc
Func _GUICtrlHeader_OrderToIndex($hWnd, $iOrder)
Return _SendMessage($hWnd, $HDM_ORDERTOINDEX, $iOrder)
EndFunc
Func _GUICtrlHeader_SetBitmapMargin($hWnd, $iWidth)
Return _SendMessage($hWnd, $HDM_SETBITMAPMARGIN, $iWidth)
EndFunc
Func _GUICtrlHeader_SetFilterChangeTimeout($hWnd, $iTimeOut)
Return _SendMessage($hWnd, $HDM_SETFILTERCHANGETIMEOUT, 0, $iTimeOut)
EndFunc
Func _GUICtrlHeader_SetHotDivider($hWnd, $iFlag, $iInputValue)
Return _SendMessage($hWnd, $HDM_SETHOTDIVIDER, $iFlag, $iInputValue)
EndFunc
Func _GUICtrlHeader_SetImageList($hWnd, $hImage)
Return _SendMessage($hWnd, $HDM_SETIMAGELIST, 0, $hImage, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlHeader_SetItem($hWnd, $iIndex, ByRef $tItem)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_SETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetItemAlign($hWnd, $iIndex, $iAlign)
Local $aAlign[3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
$iFormat = BitAND($iFormat, BitNOT($HDF_JUSTIFYMASK))
$iFormat = BitOR($iFormat, $aAlign[$iAlign])
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemBitmap($hWnd, $iIndex, $hBitmap)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", BitOR($HDI_FORMAT, $HDI_BITMAP))
DllStructSetData($tItem, "Fmt", $HDF_BITMAP)
DllStructSetData($tItem, "hBMP", $hBitmap)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemDisplay($hWnd, $iIndex, $iDisplay)
Local $iFormat = BitAND(_GUICtrlHeader_GetItemFormat($hWnd, $iIndex), Not $HDF_DISPLAYMASK)
If BitAND($iDisplay, 1) <> 0 Then $iFormat = BitOR($iFormat, $HDF_BITMAP)
If BitAND($iDisplay, 2) <> 0 Then $iFormat = BitOR($iFormat, $HDF_BITMAP_ON_RIGHT)
If BitAND($iDisplay, 4) <> 0 Then $iFormat = BitOR($iFormat, $HDF_OWNERDRAW)
If BitAND($iDisplay, 8) <> 0 Then $iFormat = BitOR($iFormat, $HDF_STRING)
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemFlags($hWnd, $iIndex, $iFlags)
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
$iFormat = BitAND($iFormat, BitNOT($HDF_FLAGMASK))
If BitAND($iFlags, 1) <> 0 Then $iFormat = BitOR($iFormat, $HDF_IMAGE)
If BitAND($iFlags, 2) <> 0 Then $iFormat = BitOR($iFormat, $HDF_RTLREADING)
If BitAND($iFlags, 4) <> 0 Then $iFormat = BitOR($iFormat, $HDF_SORTDOWN)
If BitAND($iFlags, 8) <> 0 Then $iFormat = BitOR($iFormat, $HDF_SORTUP)
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_FORMAT)
DllStructSetData($tItem, "Fmt", $iFormat)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemImage($hWnd, $iIndex, $iImage)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_IMAGE)
DllStructSetData($tItem, "Image", $iImage)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemOrder($hWnd, $iIndex, $iOrder)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_ORDER)
DllStructSetData($tItem, "Order", $iOrder)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemParam($hWnd, $iIndex, $iParam)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_PARAM)
DllStructSetData($tItem, "Param", $iParam)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemText($hWnd, $iIndex, $sText)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $iBuffer, $pBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
$pBuffer = DllStructGetPtr($tBuffer)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_TEXT)
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tItem, "Text", -1)
EndIf
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_SETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetItemWidth($hWnd, $iIndex, $iWidth)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_WIDTH)
DllStructSetData($tItem, "XY", $iWidth)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetOrderArray($hWnd, ByRef $aOrder)
Local $tBuffer = DllStructCreate("int[" & $aOrder[0] & "]")
For $iI = 1 To $aOrder[0]
DllStructSetData($tBuffer, 1, $aOrder[$iI], $iI)
Next
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$iRet = _SendMessage($hWnd, $HDM_SETORDERARRAY, $aOrder[0], $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer)
$iRet = _SendMessage($hWnd, $HDM_SETORDERARRAY, $aOrder[0], $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetUnicodeFormat($hWnd, $bUnicode)
Return _SendMessage($hWnd, $HDM_SETUNICODEFORMAT, $bUnicode)
EndFunc
Global Const $LVGS_NORMAL = 0x00000000
Global Const $LVGS_COLLAPSED = 0x00000001
Global Const $LVGS_HIDDEN = 0x00000002
Global Const $LVGS_NOHEADER = 0x00000004
Global Const $LVGS_COLLAPSIBLE = 0x00000008
Global Const $LVGS_FOCUSED = 0x00000010
Global Const $LVGS_SELECTED = 0x00000020
Global Const $LVGS_SUBSETED = 0x00000040
Global Const $LVGS_SUBSETLINKFOCUSED = 0x00000080
Global Const $LVGGR_GROUP = 0
Global Const $LVGGR_HEADER = 1
Global Const $LVGGR_LABEL = 2
Global Const $LVGGR_SUBSETLINK = 3
Global Const $LV_ERR = -1
Global Const $LVBKIF_SOURCE_NONE = 0x00000000
Global Const $LVBKIF_SOURCE_HBITMAP = 0x00000001
Global Const $LVBKIF_SOURCE_URL = 0x00000002
Global Const $LVBKIF_SOURCE_MASK = 0x00000003
Global Const $LVBKIF_STYLE_NORMAL = 0x00000000
Global Const $LVBKIF_STYLE_TILE = 0x00000010
Global Const $LVBKIF_STYLE_MASK = 0x00000010
Global Const $LVBKIF_FLAG_TILEOFFSET = 0x00000100
Global Const $LVBKIF_TYPE_WATERMARK = 0x10000000
Global Const $LV_VIEW_DETAILS = 0x0001
Global Const $LV_VIEW_ICON = 0x0000
Global Const $LV_VIEW_LIST = 0x0003
Global Const $LV_VIEW_SMALLICON = 0x0002
Global Const $LV_VIEW_TILE = 0x0004
Global Const $LVA_ALIGNLEFT = 0x0001
Global Const $LVA_ALIGNTOP = 0x0002
Global Const $LVA_DEFAULT = 0x0000
Global Const $LVA_SNAPTOGRID = 0x0005
Global Const $LVCDI_ITEM = 0x00000000
Global Const $LVCDI_GROUP = 0x00000001
Global Const $LVCF_ALLDATA = 0X0000003F
Global Const $LVCF_FMT = 0x0001
Global Const $LVCF_IMAGE = 0x0010
Global Const $LVCFMT_JUSTIFYMASK = 0x0003
Global Const $LVCF_TEXT = 0x0004
Global Const $LVCF_WIDTH = 0x0002
Global Const $LVCFMT_BITMAP_ON_RIGHT = 0x1000
Global Const $LVCFMT_CENTER = 0x0002
Global Const $LVCFMT_COL_HAS_IMAGES = 0x8000
Global Const $LVCFMT_IMAGE = 0x0800
Global Const $LVCFMT_LEFT = 0x0000
Global Const $LVCFMT_RIGHT = 0x0001
Global Const $LVCFMT_LINE_BREAK = 0x100000
Global Const $LVCFMT_FILL = 0x200000
Global Const $LVCFMT_WRAP = 0x400000
Global Const $LVCFMT_NO_TITLE = 0x800000
Global Const $LVCFMT_TILE_PLACEMENTMASK = BitOR($LVCFMT_LINE_BREAK, $LVCFMT_FILL)
Global Const $LVFI_NEARESTXY = 0x0040
Global Const $LVFI_PARAM = 0x0001
Global Const $LVFI_PARTIAL = 0x0008
Global Const $LVFI_STRING = 0x0002
Global Const $LVFI_SUBSTRING = 0x0004
Global Const $LVFI_WRAP = 0x0020
Global Const $LVGA_FOOTER_LEFT = 0x00000008
Global Const $LVGA_FOOTER_CENTER = 0x00000010
Global Const $LVGA_FOOTER_RIGHT = 0x00000020
Global Const $LVGA_HEADER_LEFT = 0x00000001
Global Const $LVGA_HEADER_CENTER = 0x00000002
Global Const $LVGA_HEADER_RIGHT = 0x00000004
Global Const $LVGF_ALIGN = 0x00000008
Global Const $LVGF_DESCRIPTIONTOP = 0x00000400
Global Const $LVGF_DESCRIPTIONBOTTOM = 0x00000800
Global Const $LVGF_EXTENDEDIMAGE = 0x00002000
Global Const $LVGF_FOOTER = 0x00000002
Global Const $LVGF_GROUPID = 0x00000010
Global Const $LVGF_HEADER = 0x00000001
Global Const $LVGF_ITEMS = 0x00004000
Global Const $LVGF_NONE = 0x00000000
Global Const $LVGF_STATE = 0x00000004
Global Const $LVGF_SUBSET = 0x00008000
Global Const $LVGF_SUBSETITEMS = 0x00010000
Global Const $LVGF_SUBTITLE = 0x00000100
Global Const $LVGF_TASK = 0x00000200
Global Const $LVGF_TITLEIMAGE = 0x00001000
Global Const $LVHT_ABOVE = 0x00000008
Global Const $LVHT_BELOW = 0x00000010
Global Const $LVHT_NOWHERE = 0x00000001
Global Const $LVHT_ONITEMICON = 0x00000002
Global Const $LVHT_ONITEMLABEL = 0x00000004
Global Const $LVHT_ONITEMSTATEICON = 0x00000008
Global Const $LVHT_TOLEFT = 0x00000040
Global Const $LVHT_TORIGHT = 0x00000020
Global Const $LVHT_ONITEM = BitOR($LVHT_ONITEMICON, $LVHT_ONITEMLABEL, $LVHT_ONITEMSTATEICON)
Global Const $LVHT_EX_GROUP_HEADER = 0x10000000
Global Const $LVHT_EX_GROUP_FOOTER = 0x20000000
Global Const $LVHT_EX_GROUP_COLLAPSE = 0x40000000
Global Const $LVHT_EX_GROUP_BACKGROUND = 0x80000000
Global Const $LVHT_EX_GROUP_STATEICON = 0x01000000
Global Const $LVHT_EX_GROUP_SUBSETLINK = 0x02000000
Global Const $LVHT_EX_GROUP = BitOR($LVHT_EX_GROUP_BACKGROUND, $LVHT_EX_GROUP_COLLAPSE, $LVHT_EX_GROUP_FOOTER, $LVHT_EX_GROUP_HEADER, $LVHT_EX_GROUP_STATEICON, $LVHT_EX_GROUP_SUBSETLINK)
Global Const $LVHT_EX_ONCONTENTS = 0x04000000
Global Const $LVHT_EX_FOOTER = 0x08000000
Global Const $LVIF_COLFMT = 0x00010000
Global Const $LVIF_COLUMNS = 0x00000200
Global Const $LVIF_GROUPID = 0x00000100
Global Const $LVIF_IMAGE = 0x00000002
Global Const $LVIF_INDENT = 0x00000010
Global Const $LVIF_NORECOMPUTE = 0x00000800
Global Const $LVIF_PARAM = 0x00000004
Global Const $LVIF_STATE = 0x00000008
Global Const $LVIF_TEXT = 0x00000001
Global Const $LVIM_AFTER = 0x00000001
Global Const $LVIR_BOUNDS = 0
Global Const $LVIR_ICON = 1
Global Const $LVIR_LABEL = 2
Global Const $LVIR_SELECTBOUNDS = 3
Global Const $LVIS_CUT = 0x0004
Global Const $LVIS_DROPHILITED = 0x0008
Global Const $LVIS_FOCUSED = 0x0001
Global Const $LVIS_OVERLAYMASK = 0x0F00
Global Const $LVIS_SELECTED = 0x0002
Global Const $LVIS_STATEIMAGEMASK = 0xF000
Global Const $LVS_ALIGNLEFT = 0x0800
Global Const $LVS_ALIGNMASK = 0x0c00
Global Const $LVS_ALIGNTOP = 0x0000
Global Const $LVS_AUTOARRANGE = 0x0100
Global Const $LVS_DEFAULT = 0x0000000D
Global Const $LVS_EDITLABELS = 0x0200
Global Const $LVS_ICON = 0x0000
Global Const $LVS_LIST = 0x0003
Global Const $LVS_NOCOLUMNHEADER = 0x4000
Global Const $LVS_NOLABELWRAP = 0x0080
Global Const $LVS_NOSCROLL = 0x2000
Global Const $LVS_NOSORTHEADER = 0x8000
Global Const $LVS_OWNERDATA = 0x1000
Global Const $LVS_OWNERDRAWFIXED = 0x0400
Global Const $LVS_REPORT = 0x0001
Global Const $LVS_SHAREIMAGELISTS = 0x0040
Global Const $LVS_SHOWSELALWAYS = 0x0008
Global Const $LVS_SINGLESEL = 0x0004
Global Const $LVS_SMALLICON = 0x0002
Global Const $LVS_SORTASCENDING = 0x0010
Global Const $LVS_SORTDESCENDING = 0x0020
Global Const $LVS_TYPEMASK = 0x0003
Global Const $LVS_TYPESTYLEMASK = 0xfc00
Global Const $LVS_EX_AUTOAUTOARRANGE = 0x01000000
Global Const $LVS_EX_AUTOCHECKSELECT = 0x08000000
Global Const $LVS_EX_AUTOSIZECOLUMNS = 0x10000000
Global Const $LVS_EX_BORDERSELECT = 0x00008000
Global Const $LVS_EX_CHECKBOXES = 0x00000004
Global Const $LVS_EX_COLUMNOVERFLOW = 0x80000000
Global Const $LVS_EX_COLUMNSNAPPOINTS = 0x40000000
Global Const $LVS_EX_DOUBLEBUFFER = 0x00010000
Global Const $LVS_EX_FLATSB = 0x00000100
Global Const $LVS_EX_FULLROWSELECT = 0x00000020
Global Const $LVS_EX_GRIDLINES = 0x00000001
Global Const $LVS_EX_HEADERDRAGDROP = 0x00000010
Global Const $LVS_EX_HEADERINALLVIEWS = 0x02000000
Global Const $LVS_EX_HIDELABELS = 0x20000
Global Const $LVS_EX_INFOTIP = 0x00000400
Global Const $LVS_EX_JUSTIFYCOLUMNS = 0x00200000
Global Const $LVS_EX_LABELTIP = 0x00004000
Global Const $LVS_EX_MULTIWORKAREAS = 0x00002000
Global Const $LVS_EX_ONECLICKACTIVATE = 0x00000040
Global Const $LVS_EX_REGIONAL = 0x00000200
Global Const $LVS_EX_SIMPLESELECT = 0x00100000
Global Const $LVS_EX_SNAPTOGRID = 0x00080000
Global Const $LVS_EX_SUBITEMIMAGES = 0x00000002
Global Const $LVS_EX_TRACKSELECT = 0x00000008
Global Const $LVS_EX_TRANSPARENTBKGND = 0x00400000
Global Const $LVS_EX_TRANSPARENTSHADOWTEXT = 0x00800000
Global Const $LVS_EX_TWOCLICKACTIVATE = 0x00000080
Global Const $LVS_EX_UNDERLINECOLD = 0x00001000
Global Const $LVS_EX_UNDERLINEHOT = 0x00000800
Global Const $GUI_SS_DEFAULT_LISTVIEW = BitOR($LVS_SHOWSELALWAYS, $LVS_SINGLESEL)
Global Const $LVM_FIRST = 0x1000
Global Const $LVM_APPROXIMATEVIEWRECT = ($LVM_FIRST + 64)
Global Const $LVM_ARRANGE = ($LVM_FIRST + 22)
Global Const $LVM_CANCELEDITLABEL = ($LVM_FIRST + 179)
Global Const $LVM_CREATEDRAGIMAGE = ($LVM_FIRST + 33)
Global Const $LVM_DELETEALLITEMS = ($LVM_FIRST + 9)
Global Const $LVM_DELETECOLUMN = ($LVM_FIRST + 28)
Global Const $LVM_DELETEITEM = ($LVM_FIRST + 8)
Global Const $LVM_EDITLABELA = ($LVM_FIRST + 23)
Global Const $LVM_EDITLABELW = ($LVM_FIRST + 118)
Global Const $LVM_EDITLABEL = $LVM_EDITLABELA
Global Const $LVM_ENABLEGROUPVIEW = ($LVM_FIRST + 157)
Global Const $LVM_ENSUREVISIBLE = ($LVM_FIRST + 19)
Global Const $LVM_FINDITEM = ($LVM_FIRST + 13)
Global Const $LVM_GETBKCOLOR = ($LVM_FIRST + 0)
Global Const $LVM_GETBKIMAGEA = ($LVM_FIRST + 69)
Global Const $LVM_GETBKIMAGEW = ($LVM_FIRST + 139)
Global Const $LVM_GETCALLBACKMASK = ($LVM_FIRST + 10)
Global Const $LVM_GETCOLUMNA = ($LVM_FIRST + 25)
Global Const $LVM_GETCOLUMNW = ($LVM_FIRST + 95)
Global Const $LVM_GETCOLUMNORDERARRAY = ($LVM_FIRST + 59)
Global Const $LVM_GETCOLUMNWIDTH = ($LVM_FIRST + 29)
Global Const $LVM_GETCOUNTPERPAGE = ($LVM_FIRST + 40)
Global Const $LVM_GETEDITCONTROL = ($LVM_FIRST + 24)
Global Const $LVM_GETEMPTYTEXT = ($LVM_FIRST + 204)
Global Const $LVM_GETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 55)
Global Const $LVM_GETFOCUSEDGROUP = ($LVM_FIRST + 93)
Global Const $LVM_GETFOOTERINFO = ($LVM_FIRST + 206)
Global Const $LVM_GETFOOTERITEM = ($LVM_FIRST + 208)
Global Const $LVM_GETFOOTERITEMRECT = ($LVM_FIRST + 207)
Global Const $LVM_GETFOOTERRECT = ($LVM_FIRST + 205)
Global Const $LVM_GETGROUPCOUNT = ($LVM_FIRST + 152)
Global Const $LVM_GETGROUPINFO = ($LVM_FIRST + 149)
Global Const $LVM_GETGROUPINFOBYINDEX = ($LVM_FIRST + 153)
Global Const $LVM_GETGROUPMETRICS = ($LVM_FIRST + 156)
Global Const $LVM_GETGROUPRECT = ($LVM_FIRST + 98)
Global Const $LVM_GETGROUPSTATE = ($LVM_FIRST + 92)
Global Const $LVM_GETHEADER = ($LVM_FIRST + 31)
Global Const $LVM_GETHOTCURSOR = ($LVM_FIRST + 63)
Global Const $LVM_GETHOTITEM = ($LVM_FIRST + 61)
Global Const $LVM_GETHOVERTIME = ($LVM_FIRST + 72)
Global Const $LVM_GETIMAGELIST = ($LVM_FIRST + 2)
Global Const $LVM_GETINSERTMARK = ($LVM_FIRST + 167)
Global Const $LVM_GETINSERTMARKCOLOR = ($LVM_FIRST + 171)
Global Const $LVM_GETINSERTMARKRECT = ($LVM_FIRST + 169)
Global Const $LVM_GETISEARCHSTRINGA = ($LVM_FIRST + 52)
Global Const $LVM_GETISEARCHSTRINGW = ($LVM_FIRST + 117)
Global Const $LVM_GETITEMA = ($LVM_FIRST + 5)
Global Const $LVM_GETITEMW = ($LVM_FIRST + 75)
Global Const $LVM_GETITEMCOUNT = ($LVM_FIRST + 4)
Global Const $LVM_GETITEMINDEXRECT = ($LVM_FIRST + 209)
Global Const $LVM_GETITEMPOSITION = ($LVM_FIRST + 16)
Global Const $LVM_GETITEMRECT = ($LVM_FIRST + 14)
Global Const $LVM_GETITEMSPACING = ($LVM_FIRST + 51)
Global Const $LVM_GETITEMSTATE = ($LVM_FIRST + 44)
Global Const $LVM_GETITEMTEXTA = ($LVM_FIRST + 45)
Global Const $LVM_GETITEMTEXTW = ($LVM_FIRST + 115)
Global Const $LVM_GETNEXTITEM = ($LVM_FIRST + 12)
Global Const $LVM_GETNEXTITEMINDEX = ($LVM_FIRST + 211)
Global Const $LVM_GETNUMBEROFWORKAREAS = ($LVM_FIRST + 73)
Global Const $LVM_GETORIGIN = ($LVM_FIRST + 41)
Global Const $LVM_GETOUTLINECOLOR = ($LVM_FIRST + 176)
Global Const $LVM_GETSELECTEDCOLUMN = ($LVM_FIRST + 174)
Global Const $LVM_GETSELECTEDCOUNT = ($LVM_FIRST + 50)
Global Const $LVM_GETSELECTIONMARK = ($LVM_FIRST + 66)
Global Const $LVM_GETSTRINGWIDTHA = ($LVM_FIRST + 17)
Global Const $LVM_GETSTRINGWIDTHW = ($LVM_FIRST + 87)
Global Const $LVM_GETSUBITEMRECT = ($LVM_FIRST + 56)
Global Const $LVM_GETTEXTBKCOLOR = ($LVM_FIRST + 37)
Global Const $LVM_GETTEXTCOLOR = ($LVM_FIRST + 35)
Global Const $LVM_GETTILEINFO = ($LVM_FIRST + 165)
Global Const $LVM_GETTILEVIEWINFO = ($LVM_FIRST + 163)
Global Const $LVM_GETTOOLTIPS = ($LVM_FIRST + 78)
Global Const $LVM_GETTOPINDEX = ($LVM_FIRST + 39)
Global Const $LVM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $LVM_GETVIEW = ($LVM_FIRST + 143)
Global Const $LVM_GETVIEWRECT = ($LVM_FIRST + 34)
Global Const $LVM_GETWORKAREAS = ($LVM_FIRST + 70)
Global Const $LVM_HASGROUP = ($LVM_FIRST + 161)
Global Const $LVM_HITTEST = ($LVM_FIRST + 18)
Global Const $LVM_INSERTCOLUMNA = ($LVM_FIRST + 27)
Global Const $LVM_INSERTCOLUMNW = ($LVM_FIRST + 97)
Global Const $LVM_INSERTGROUP = ($LVM_FIRST + 145)
Global Const $LVM_INSERTGROUPSORTED = ($LVM_FIRST + 159)
Global Const $LVM_INSERTITEMA = ($LVM_FIRST + 7)
Global Const $LVM_INSERTITEMW = ($LVM_FIRST + 77)
Global Const $LVM_INSERTMARKHITTEST = ($LVM_FIRST + 168)
Global Const $LVM_ISGROUPVIEWENABLED = ($LVM_FIRST + 175)
Global Const $LVM_ISITEMVISIBLE = ($LVM_FIRST + 182)
Global Const $LVM_MAPIDTOINDEX = ($LVM_FIRST + 181)
Global Const $LVM_MAPINDEXTOID = ($LVM_FIRST + 180)
Global Const $LVM_MOVEGROUP = ($LVM_FIRST + 151)
Global Const $LVM_REDRAWITEMS = ($LVM_FIRST + 21)
Global Const $LVM_REMOVEALLGROUPS = ($LVM_FIRST + 160)
Global Const $LVM_REMOVEGROUP = ($LVM_FIRST + 150)
Global Const $LVM_SCROLL = ($LVM_FIRST + 20)
Global Const $LVM_SETBKCOLOR = ($LVM_FIRST + 1)
Global Const $LVM_SETBKIMAGEA = ($LVM_FIRST + 68)
Global Const $LVM_SETBKIMAGEW = ($LVM_FIRST + 138)
Global Const $LVM_SETCALLBACKMASK = ($LVM_FIRST + 11)
Global Const $LVM_SETCOLUMNA = ($LVM_FIRST + 26)
Global Const $LVM_SETCOLUMNW = ($LVM_FIRST + 96)
Global Const $LVM_SETCOLUMNORDERARRAY = ($LVM_FIRST + 58)
Global Const $LVM_SETCOLUMNWIDTH = ($LVM_FIRST + 30)
Global Const $LVM_SETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 54)
Global Const $LVM_SETGROUPINFO = ($LVM_FIRST + 147)
Global Const $LVM_SETGROUPMETRICS = ($LVM_FIRST + 155)
Global Const $LVM_SETHOTCURSOR = ($LVM_FIRST + 62)
Global Const $LVM_SETHOTITEM = ($LVM_FIRST + 60)
Global Const $LVM_SETHOVERTIME = ($LVM_FIRST + 71)
Global Const $LVM_SETICONSPACING = ($LVM_FIRST + 53)
Global Const $LVM_SETIMAGELIST = ($LVM_FIRST + 3)
Global Const $LVM_SETINFOTIP = ($LVM_FIRST + 173)
Global Const $LVM_SETINSERTMARK = ($LVM_FIRST + 166)
Global Const $LVM_SETINSERTMARKCOLOR = ($LVM_FIRST + 170)
Global Const $LVM_SETITEMA = ($LVM_FIRST + 6)
Global Const $LVM_SETITEMW = ($LVM_FIRST + 76)
Global Const $LVM_SETITEMCOUNT = ($LVM_FIRST + 47)
Global Const $LVM_SETITEMINDEXSTATE = ($LVM_FIRST + 210)
Global Const $LVM_SETITEMPOSITION = ($LVM_FIRST + 15)
Global Const $LVM_SETITEMPOSITION32 = ($LVM_FIRST + 49)
Global Const $LVM_SETITEMSTATE = ($LVM_FIRST + 43)
Global Const $LVM_SETITEMTEXTA = ($LVM_FIRST + 46)
Global Const $LVM_SETITEMTEXTW = ($LVM_FIRST + 116)
Global Const $LVM_SETOUTLINECOLOR = ($LVM_FIRST + 177)
Global Const $LVM_SETSELECTEDCOLUMN = ($LVM_FIRST + 140)
Global Const $LVM_SETSELECTIONMARK = ($LVM_FIRST + 67)
Global Const $LVM_SETTEXTBKCOLOR = ($LVM_FIRST + 38)
Global Const $LVM_SETTEXTCOLOR = ($LVM_FIRST + 36)
Global Const $LVM_SETTILEINFO = ($LVM_FIRST + 164)
Global Const $LVM_SETTILEVIEWINFO = ($LVM_FIRST + 162)
Global Const $LVM_SETTILEWIDTH = ($LVM_FIRST + 141)
Global Const $LVM_SETTOOLTIPS = ($LVM_FIRST + 74)
Global Const $LVM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $LVM_SETVIEW = ($LVM_FIRST + 142)
Global Const $LVM_SETWORKAREAS = ($LVM_FIRST + 65)
Global Const $LVM_SORTGROUPS = ($LVM_FIRST + 158)
Global Const $LVM_SORTITEMS = ($LVM_FIRST + 48)
Global Const $LVM_SORTITEMSEX = ($LVM_FIRST + 81)
Global Const $LVM_SUBITEMHITTEST = ($LVM_FIRST + 57)
Global Const $LVM_UPDATE = ($LVM_FIRST + 42)
Global Const $LVN_FIRST = -100
Global Const $LVN_LAST = -199
Global Const $LVN_BEGINDRAG = ($LVN_FIRST - 9)
Global Const $LVN_BEGINLABELEDITA = ($LVN_FIRST - 5)
Global Const $LVN_BEGINLABELEDITW = ($LVN_FIRST - 75)
Global Const $LVN_BEGINRDRAG = ($LVN_FIRST - 11)
Global Const $LVN_BEGINSCROLL = ($LVN_FIRST - 80)
Global Const $LVN_COLUMNCLICK = ($LVN_FIRST - 8)
Global Const $LVN_COLUMNDROPDOWN = ($LVN_FIRST - 64)
Global Const $LVN_COLUMNOVERFLOWCLICK = ($LVN_FIRST - 66)
Global Const $LVN_DELETEALLITEMS = ($LVN_FIRST - 4)
Global Const $LVN_DELETEITEM = ($LVN_FIRST - 3)
Global Const $LVN_ENDLABELEDITA = ($LVN_FIRST - 6)
Global Const $LVN_ENDLABELEDITW = ($LVN_FIRST - 76)
Global Const $LVN_ENDSCROLL = ($LVN_FIRST - 81)
Global Const $LVN_GETDISPINFOA = ($LVN_FIRST - 50)
Global Const $LVN_GETDISPINFOW = ($LVN_FIRST - 77)
Global Const $LVN_GETDISPINFO = $LVN_GETDISPINFOA
Global Const $LVN_GETEMPTYMARKUP = ($LVN_FIRST - 87)
Global Const $LVN_GETINFOTIPA = ($LVN_FIRST - 57)
Global Const $LVN_GETINFOTIPW = ($LVN_FIRST - 58)
Global Const $LVN_HOTTRACK = ($LVN_FIRST - 21)
Global Const $LVN_INCREMENTALSEARCHA = ($LVN_FIRST - 62)
Global Const $LVN_INCREMENTALSEARCHW = ($LVN_FIRST - 63)
Global Const $LVN_INSERTITEM = ($LVN_FIRST - 2)
Global Const $LVN_ITEMACTIVATE = ($LVN_FIRST - 14)
Global Const $LVN_ITEMCHANGED = ($LVN_FIRST - 1)
Global Const $LVN_ITEMCHANGING = ($LVN_FIRST - 0)
Global Const $LVN_KEYDOWN = ($LVN_FIRST - 55)
Global Const $LVN_LINKCLICK = ($LVN_FIRST - 84)
Global Const $LVN_MARQUEEBEGIN = ($LVN_FIRST - 56)
Global Const $LVN_ODCACHEHINT = ($LVN_FIRST - 13)
Global Const $LVN_ODFINDITEMA = ($LVN_FIRST - 52)
Global Const $LVN_ODFINDITEMW = ($LVN_FIRST - 79)
Global Const $LVN_ODFINDITEM = $LVN_ODFINDITEMA
Global Const $LVN_ODSTATECHANGED = ($LVN_FIRST - 15)
Global Const $LVN_SETDISPINFOA = ($LVN_FIRST - 51)
Global Const $LVN_SETDISPINFOW = ($LVN_FIRST - 78)
Global Const $LVNI_ABOVE = 0x0100
Global Const $LVNI_BELOW = 0x0200
Global Const $LVNI_TOLEFT = 0x0400
Global Const $LVNI_TORIGHT = 0x0800
Global Const $LVNI_ALL = 0x0000
Global Const $LVNI_CUT = 0x0004
Global Const $LVNI_DROPHILITED = 0x0008
Global Const $LVNI_FOCUSED = 0x0001
Global Const $LVNI_SELECTED = 0x0002
Global Const $LVSCW_AUTOSIZE = -1
Global Const $LVSCW_AUTOSIZE_USEHEADER = -2
Global Const $LVSICF_NOINVALIDATEALL = 0x00000001
Global Const $LVSICF_NOSCROLL = 0x00000002
Global Const $LVSIL_NORMAL = 0
Global Const $LVSIL_SMALL = 1
Global Const $LVSIL_STATE = 2
Global $__g_hLVLastWnd
Global $__g_iLListViewSortInfoSize = 11
Global $__g_aListViewSortInfo[1][$__g_iLListViewSortInfoSize]
Global Const $__LISTVIEWCONSTANT_ClassName = "SysListView32"
Global Const $__LISTVIEWCONSTANT_WS_MAXIMIZEBOX = 0x00010000
Global Const $__LISTVIEWCONSTANT_WS_MINIMIZEBOX = 0x00020000
Global Const $__LISTVIEWCONSTANT_GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $__LISTVIEWCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__LISTVIEWCONSTANT_WM_SETFONT = 0x0030
Global Const $__LISTVIEWCONSTANT_WM_NOTIFY = 0x004E
Global Const $__LISTVIEWCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__LISTVIEWCONSTANT_ILD_TRANSPARENT = 0x00000001
Global Const $__LISTVIEWCONSTANT_ILD_BLEND25 = 0x00000002
Global Const $__LISTVIEWCONSTANT_ILD_BLEND50 = 0x00000004
Global Const $__LISTVIEWCONSTANT_ILD_MASK = 0x00000010
Global Const $__LISTVIEWCONSTANT_VK_DOWN = 0x28
Global Const $__LISTVIEWCONSTANT_VK_END = 0x23
Global Const $__LISTVIEWCONSTANT_VK_HOME = 0x24
Global Const $__LISTVIEWCONSTANT_VK_LEFT = 0x25
Global Const $__LISTVIEWCONSTANT_VK_NEXT = 0x22
Global Const $__LISTVIEWCONSTANT_VK_PRIOR = 0x21
Global Const $__LISTVIEWCONSTANT_VK_RIGHT = 0x27
Global Const $__LISTVIEWCONSTANT_VK_UP = 0x26
Global Const $tagLVBKIMAGE = "ulong Flags;hwnd hBmp;ptr Image;uint ImageMax;int XOffPercent;int YOffPercent"
Global Const $tagLVCOLUMN = "uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal"
Global Const $tagLVGROUP = "uint Size;uint Mask;ptr Header;int HeaderMax;ptr Footer;int FooterMax;int GroupID;uint StateMask;uint State;uint Align;" &  "ptr  pszSubtitle;uint cchSubtitle;ptr pszTask;uint cchTask;ptr pszDescriptionTop;uint cchDescriptionTop;ptr pszDescriptionBottom;" &  "uint cchDescriptionBottom;int iTitleImage;int iExtendedImage;int iFirstItem;uint cItems;ptr pszSubsetTitle;uint cchSubsetTitle"
Global Const $tagLVINSERTMARK = "uint Size;dword Flags;int Item;dword Reserved"
Global Const $tagLVSETINFOTIP = "uint Size;dword Flags;ptr Text;int Item;int SubItem"
Func _GUICtrlListView_AddArray($hWnd, ByRef $aItems)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tItem = DllStructCreate($tagLVITEM)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", 4096)
Local $iLastItem = _GUICtrlListView_GetItemCount($hWnd)
_GUICtrlListView_BeginUpdate($hWnd)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, "Text", $aItems[$iI][0])
_SendMessage($hWnd, $LVM_INSERTITEMW, 0, $tItem, 0, "wparam", "struct*")
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, "Text", $aItems[$iI][$iJ])
_SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*")
Next
Next
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI + $iLastItem)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, "Text", $aItems[$iI][0])
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
_SendMessage($hWnd, $LVM_INSERTITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_INSERTITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, "Text", $aItems[$iI][$iJ])
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
_SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
Next
Next
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI + $iLastItem)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, "Text", $aItems[$iI][0])
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_INSERTITEMW, 0, $pItem)
Else
GUICtrlSendMsg($hWnd, $LVM_INSERTITEMA, 0, $pItem)
EndIf
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, "Text", $aItems[$iI][$iJ])
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
Next
Next
EndIf
_GUICtrlListView_EndUpdate($hWnd)
EndFunc
Func _GUICtrlListView_AddColumn($hWnd, $sText, $iWidth = 50, $iAlign = -1, $iImage = -1, $bOnRight = False)
Return _GUICtrlListView_InsertColumn($hWnd, _GUICtrlListView_GetColumnCount($hWnd), $sText, $iWidth, $iAlign, $iImage, $bOnRight)
EndFunc
Func _GUICtrlListView_AddItem($hWnd, $sText, $iImage = -1, $iParam = 0)
Return _GUICtrlListView_InsertItem($hWnd, $sText, -1, $iImage, $iParam)
EndFunc
Func _GUICtrlListView_AddSubItem($hWnd, $iIndex, $sText, $iSubItem, $iImage = -1)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagLVITEM)
Local $iMask = $LVIF_TEXT
If $iImage <> -1 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", $iImage)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_ApproximateViewHeight($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
If IsHWnd($hWnd) Then
Return BitShift((_SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 16)
Else
Return BitShift((GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 16)
EndIf
EndFunc
Func _GUICtrlListView_ApproximateViewRect($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
Local $iView
If IsHWnd($hWnd) Then
$iView = _SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))
Else
$iView = GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))
EndIf
Local $aView[2]
$aView[0] = BitAND($iView, 0xFFFF)
$aView[1] = BitShift($iView, 16)
Return $aView
EndFunc
Func _GUICtrlListView_ApproximateViewWidth($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
If IsHWnd($hWnd) Then
Return BitAND((_SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 0xFFFF)
Else
Return BitAND((GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 0xFFFF)
EndIf
EndFunc
Func _GUICtrlListView_Arrange($hWnd, $iArrange = 0)
Local $aArrange[4] = [$LVA_DEFAULT, $LVA_ALIGNLEFT, $LVA_ALIGNTOP, $LVA_SNAPTOGRID]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ARRANGE, $aArrange[$iArrange]) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ARRANGE, $aArrange[$iArrange], 0) <> 0
EndIf
EndFunc
Func __GUICtrlListView_ArrayDelete(ByRef $avArray, $iElement)
If Not IsArray($avArray) Then Return SetError(1, 0, "")
Local $iUpper = UBound($avArray)
If $iUpper = 1 Then
SetError(2)
Return ""
EndIf
Local $avNewArray[$iUpper - 1][$__g_iLListViewSortInfoSize]
$avNewArray[0][0] = $avArray[0][0]
If $iElement < 0 Then
$iElement = 0
EndIf
If $iElement > ($iUpper - 1) Then
$iElement = ($iUpper - 1)
EndIf
If $iElement > 0 Then
For $iCntr = 0 To $iElement - 1
For $x = 1 To $__g_iLListViewSortInfoSize - 1
$avNewArray[$iCntr][$x] = $avArray[$iCntr][$x]
Next
Next
EndIf
If $iElement < ($iUpper - 1) Then
For $iCntr = ($iElement + 1) To ($iUpper - 1)
For $x = 1 To $__g_iLListViewSortInfoSize - 1
$avNewArray[$iCntr - 1][$x] = $avArray[$iCntr][$x]
Next
Next
EndIf
$avArray = $avNewArray
SetError(0)
Return 1
EndFunc
Func _GUICtrlListView_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlListView_CancelEditLabel($hWnd)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_CANCELEDITLABEL)
Else
GUICtrlSendMsg($hWnd, $LVM_CANCELEDITLABEL, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_ClickItem($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_GUICtrlListView_EnsureVisible($hWnd, $iIndex, False)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $LVIR_LABEL)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
Local $iX, $iY
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
If Not $bMove Then
Local $aPos = MouseGetPos()
_WinAPI_ShowCursor(False)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
MouseMove($aPos[0], $aPos[1], 0)
_WinAPI_ShowCursor(True)
Else
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
EndIf
Opt("MouseCoordMode", $iMode)
EndFunc
Func _GUICtrlListView_CopyItems($hWnd_Source, $hWnd_Destination, $bDelFlag = False)
Local $a_Indices, $tItem = DllStructCreate($tagLVITEM), $iIndex
Local $iCols = _GUICtrlListView_GetColumnCount($hWnd_Source)
Local $iItems = _GUICtrlListView_GetItemCount($hWnd_Source)
_GUICtrlListView_BeginUpdate($hWnd_Source)
_GUICtrlListView_BeginUpdate($hWnd_Destination)
If BitAND(_GUICtrlListView_GetExtendedListViewStyle($hWnd_Source), $LVS_EX_CHECKBOXES) == $LVS_EX_CHECKBOXES Then
For $i = 0 To $iItems - 1
If (_GUICtrlListView_GetItemChecked($hWnd_Source, $i)) Then
If IsArray($a_Indices) Then
ReDim $a_Indices[UBound($a_Indices) + 1]
Else
Local $a_Indices[2]
EndIf
$a_Indices[0] = $a_Indices[0] + 1
$a_Indices[UBound($a_Indices) - 1] = $i
EndIf
Next
If (IsArray($a_Indices)) Then
For $i = 1 To $a_Indices[0]
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
$iIndex = _GUICtrlListView_AddItem($hWnd_Destination, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], 0), DllStructGetData($tItem, "Image"))
_GUICtrlListView_SetItemChecked($hWnd_Destination, $iIndex)
For $x = 1 To $iCols - 1
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", $x)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
_GUICtrlListView_AddSubItem($hWnd_Destination, $iIndex, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], $x), $x, DllStructGetData($tItem, "Image"))
Next
Next
If $bDelFlag Then
For $i = $a_Indices[0] To 1 Step -1
_GUICtrlListView_DeleteItem($hWnd_Source, $a_Indices[$i])
Next
EndIf
EndIf
EndIf
If (_GUICtrlListView_GetSelectedCount($hWnd_Source)) Then
$a_Indices = _GUICtrlListView_GetSelectedIndices($hWnd_Source, 1)
For $i = 1 To $a_Indices[0]
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
$iIndex = _GUICtrlListView_AddItem($hWnd_Destination, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], 0), DllStructGetData($tItem, "Image"))
For $x = 1 To $iCols - 1
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", $x)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
_GUICtrlListView_AddSubItem($hWnd_Destination, $iIndex, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], $x), $x, DllStructGetData($tItem, "Image"))
Next
Next
_GUICtrlListView_SetItemSelected($hWnd_Source, -1, False)
If $bDelFlag Then
For $i = $a_Indices[0] To 1 Step -1
_GUICtrlListView_DeleteItem($hWnd_Source, $a_Indices[$i])
Next
EndIf
EndIf
_GUICtrlListView_EndUpdate($hWnd_Source)
_GUICtrlListView_EndUpdate($hWnd_Destination)
EndFunc
Func _GUICtrlListView_Create($hWnd, $sHeaderText, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x0000000D, $iExStyle = 0x00000000, $bCoInit = False)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sHeaderText) Then Return SetError(2, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = $LVS_DEFAULT
If $iExStyle = -1 Then $iExStyle = 0x00000000
Local Const $S_OK = 0x0
Local Const $S_FALSE = 0x1
Local Const $RPC_E_CHANGED_MODE = 0x80010106
Local Const $E_INVALIDARG = 0x80070057
Local Const $E_OUTOFMEMORY = 0x8007000E
Local Const $E_UNEXPECTED = 0x8000FFFF
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local Const $COINIT_APARTMENTTHREADED = 0x02
Local $iStr_len = StringLen($sHeaderText)
If $iStr_len Then $sHeaderText = StringSplit($sHeaderText, $sSeparatorChar)
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $iStyle)
If $bCoInit Then
Local $aResult = DllCall('ole32.dll', 'long', 'CoInitializeEx', 'ptr', 0, 'dword', $COINIT_APARTMENTTHREADED)
If @error Then Return SetError(@error, @extended, 0)
Switch $aResult[0]
Case $S_OK
Case $S_FALSE
Case $RPC_E_CHANGED_MODE
Case $E_INVALIDARG
Case $E_OUTOFMEMORY
Case $E_UNEXPECTED
EndSwitch
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hList = _WinAPI_CreateWindowEx($iExStyle, $__LISTVIEWCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hList, $__LISTVIEWCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__LISTVIEWCONSTANT_DEFAULT_GUI_FONT), True)
If $iStr_len Then
For $x = 1 To $sHeaderText[0]
_GUICtrlListView_InsertColumn($hList, $x - 1, $sHeaderText[$x], 75)
Next
EndIf
Return $hList
EndFunc
Func _GUICtrlListView_CreateDragImage($hWnd, $iIndex)
Local $aDrag[3]
Local $tPoint = DllStructCreate($tagPOINT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$aDrag[0] = _SendMessage($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, $tPoint, 0, "wparam", "struct*", "handle")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
$aDrag[0] = _SendMessage($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, $pMemory, 0, "wparam", "ptr", "handle")
_MemRead($tMemMap, $pMemory, $tPoint, $iPoint)
_MemFree($tMemMap)
EndIf
Else
$aDrag[0] = Ptr(GUICtrlSendMsg($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, DllStructGetPtr($tPoint)))
EndIf
$aDrag[1] = DllStructGetData($tPoint, "X")
$aDrag[2] = DllStructGetData($tPoint, "Y")
Return $aDrag
EndFunc
Func _GUICtrlListView_CreateSolidBitMap($hWnd, $iColor, $iWidth, $iHeight)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _WinAPI_CreateSolidBitmap($hWnd, $iColor, $iWidth, $iHeight)
EndFunc
Func _GUICtrlListView_DeleteAllItems($hWnd)
If _GUICtrlListView_GetItemCount($hWnd) = 0 Then Return True
Local $vCID = 0
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
If $vCID < $_UDF_STARTID Then
Local $iParam = 0
For $iIndex = _GUICtrlListView_GetItemCount($hWnd) - 1 To 0 Step -1
$iParam = _GUICtrlListView_GetItemParam($hWnd, $iIndex)
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
GUICtrlDelete($iParam)
EndIf
Next
If _GUICtrlListView_GetItemCount($hWnd) = 0 Then Return True
EndIf
Return _SendMessage($hWnd, $LVM_DELETEALLITEMS) <> 0
EndFunc
Func _GUICtrlListView_DeleteColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_DELETECOLUMN, $iCol) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_DELETECOLUMN, $iCol, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_DeleteItem($hWnd, $iIndex)
Local $vCID = 0
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
If $vCID < $_UDF_STARTID Then
Local $iParam = _GUICtrlListView_GetItemParam($hWnd, $iIndex)
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
If GUICtrlDelete($iParam) Then
Return True
EndIf
EndIf
EndIf
Return _SendMessage($hWnd, $LVM_DELETEITEM, $iIndex) <> 0
EndFunc
Func _GUICtrlListView_DeleteItemsSelected($hWnd)
Local $iItemCount = _GUICtrlListView_GetItemCount($hWnd)
If _GUICtrlListView_GetSelectedCount($hWnd) = $iItemCount Then
Return _GUICtrlListView_DeleteAllItems($hWnd)
Else
Local $aSelected = _GUICtrlListView_GetSelectedIndices($hWnd, True)
If Not IsArray($aSelected) Then Return SetError($LV_ERR, $LV_ERR, 0)
_GUICtrlListView_SetItemSelected($hWnd, -1, False)
Local $vCID = 0, $iNative_Delete, $iUDF_Delete
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
For $iIndex = $aSelected[0] To 1 Step -1
If $vCID < $_UDF_STARTID Then
Local $iParam = _GUICtrlListView_GetItemParam($hWnd, $aSelected[$iIndex])
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
$iNative_Delete = GUICtrlDelete($iParam)
If $iNative_Delete Then ContinueLoop
EndIf
EndIf
$iUDF_Delete = _SendMessage($hWnd, $LVM_DELETEITEM, $aSelected[$iIndex])
If $iNative_Delete + $iUDF_Delete = 0 Then
ExitLoop
EndIf
Next
Return Not $iIndex
EndIf
EndFunc
Func _GUICtrlListView_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__LISTVIEWCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func __GUICtrlListView_Draw($hWnd, $iIndex, $hDC, $iX, $iY, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlListView_DrawDragImage(ByRef $hWnd, ByRef $aDrag)
Local $hDC = _WinAPI_GetWindowDC($hWnd)
Local $tPoint = _WinAPI_GetMousePos(True, $hWnd)
_WinAPI_InvalidateRect($hWnd)
__GUICtrlListView_Draw($aDrag[0], 0, $hDC, DllStructGetData($tPoint, "X"), DllStructGetData($tPoint, "Y"))
_WinAPI_ReleaseDC($hWnd, $hDC)
EndFunc
Func _GUICtrlListView_EditLabel($hWnd, $iIndex)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $aResult
If IsHWnd($hWnd) Then
$aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
If $aResult = 0 Then Return 0
If $bUnicode Then
Return _SendMessage($hWnd, $LVM_EDITLABELW, $iIndex, 0, 0, "wparam", "lparam", "hwnd")
Else
Return _SendMessage($hWnd, $LVM_EDITLABEL, $iIndex, 0, 0, "wparam", "lparam", "hwnd")
EndIf
Else
$aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", GUICtrlGetHandle($hWnd))
If @error Then Return SetError(@error, @extended, 0)
If $aResult = 0 Then Return 0
If $bUnicode Then
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_EDITLABELW, $iIndex, 0))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_EDITLABEL, $iIndex, 0))
EndIf
EndIf
EndFunc
Func _GUICtrlListView_EnableGroupView($hWnd, $bEnable = True)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ENABLEGROUPVIEW, $bEnable)
Else
Return GUICtrlSendMsg($hWnd, $LVM_ENABLEGROUPVIEW, $bEnable, 0)
EndIf
EndFunc
Func _GUICtrlListView_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlListView_EnsureVisible($hWnd, $iIndex, $bPartialOK = False)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ENSUREVISIBLE, $iIndex, $bPartialOK)
Else
Return GUICtrlSendMsg($hWnd, $LVM_ENSUREVISIBLE, $iIndex, $bPartialOK)
EndIf
EndFunc
Func _GUICtrlListView_FindInText($hWnd, $sText, $iStart = -1, $bWrapOK = True, $bReverse = False)
Local $iCount = _GUICtrlListView_GetItemCount($hWnd)
Local $iColumns = _GUICtrlListView_GetColumnCount($hWnd)
If $iColumns = 0 Then $iColumns = 1
If $bReverse And $iStart = -1 Then Return -1
Local $sList
If $bReverse Then
For $iI = $iStart - 1 To 0 Step -1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
Else
For $iI = $iStart + 1 To $iCount - 1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
EndIf
If (($iStart = -1) Or Not $bWrapOK) And Not $bReverse Then Return -1
If $bReverse And $bWrapOK Then
For $iI = $iCount - 1 To $iStart + 1 Step -1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
Else
For $iI = 0 To $iStart - 1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
EndIf
Return -1
EndFunc
Func _GUICtrlListView_FindItem($hWnd, $iStart, ByRef $tFindInfo, $sText = "")
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
Local $pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tFindInfo, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_FINDITEM, $iStart, $tFindInfo, 0, "wparam", "struct*")
Else
Local $iFindInfo = DllStructGetSize($tFindInfo)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iFindInfo + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iFindInfo
DllStructSetData($tFindInfo, "Text", $pText)
_MemWrite($tMemMap, $tFindInfo, $pMemory, $iFindInfo)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
$iRet = _SendMessage($hWnd, $LVM_FINDITEM, $iStart, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
DllStructSetData($tFindInfo, "Text", $pBuffer)
$iRet = GUICtrlSendMsg($hWnd, $LVM_FINDITEM, $iStart, DllStructGetPtr($tFindInfo))
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_FindNearest($hWnd, $iX, $iY, $iDir = 0, $iStart = -1, $bWrapOK = True)
Local $aDir[8] = [$__LISTVIEWCONSTANT_VK_LEFT, $__LISTVIEWCONSTANT_VK_RIGHT, $__LISTVIEWCONSTANT_VK_UP, $__LISTVIEWCONSTANT_VK_DOWN, $__LISTVIEWCONSTANT_VK_HOME, $__LISTVIEWCONSTANT_VK_END, $__LISTVIEWCONSTANT_VK_PRIOR, $__LISTVIEWCONSTANT_VK_NEXT]
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
Local $iFlags = $LVFI_NEARESTXY
If $bWrapOK Then $iFlags = BitOR($iFlags, $LVFI_WRAP)
DllStructSetData($tFindInfo, "Flags", $iFlags)
DllStructSetData($tFindInfo, "X", $iX)
DllStructSetData($tFindInfo, "Y", $iY)
DllStructSetData($tFindInfo, "Direction", $aDir[$iDir])
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo)
EndFunc
Func _GUICtrlListView_FindParam($hWnd, $iParam, $iStart = -1)
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
DllStructSetData($tFindInfo, "Flags", $LVFI_PARAM)
DllStructSetData($tFindInfo, "Param", $iParam)
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo)
EndFunc
Func _GUICtrlListView_FindText($hWnd, $sText, $iStart = -1, $bPartialOK = True, $bWrapOK = True)
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
Local $iFlags = $LVFI_STRING
If $bPartialOK Then $iFlags = BitOR($iFlags, $LVFI_PARTIAL)
If $bWrapOK Then $iFlags = BitOR($iFlags, $LVFI_WRAP)
DllStructSetData($tFindInfo, "Flags", $iFlags)
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo, $sText)
EndFunc
Func _GUICtrlListView_GetBkColor($hWnd)
Local $i_Color
If IsHWnd($hWnd) Then
$i_Color = _SendMessage($hWnd, $LVM_GETBKCOLOR)
Else
$i_Color = GUICtrlSendMsg($hWnd, $LVM_GETBKCOLOR, 0, 0)
EndIf
Return __GUICtrlListView_ReverseColorOrder($i_Color)
EndFunc
Func _GUICtrlListView_GetBkImage($hWnd)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tImage = DllStructCreate($tagLVBKIMAGE)
DllStructSetData($tImage, "ImageMax", 4096)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tImage, "Image", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_GETBKIMAGEW, 0, $tImage, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $iImage = DllStructGetSize($tImage)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iImage + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iImage
DllStructSetData($tImage, "Image", $pText)
_MemWrite($tMemMap, $tImage, $pMemory, $iImage)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETBKIMAGEW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_GETBKIMAGEA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tImage, $iImage)
_MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pImage = DllStructGetPtr($tImage)
DllStructSetData($tImage, "Image", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETBKIMAGEW, 0, $pImage)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETBKIMAGEA, 0, $pImage)
EndIf
EndIf
Local $aImage[4]
Switch BitAND(DllStructGetData($tImage, "Flags"), $LVBKIF_SOURCE_MASK)
Case $LVBKIF_SOURCE_HBITMAP
$aImage[0] = 1
Case $LVBKIF_SOURCE_URL
$aImage[0] = 2
EndSwitch
$aImage[1] = DllStructGetData($tBuffer, "Text")
$aImage[2] = DllStructGetData($tImage, "XOffPercent")
$aImage[3] = DllStructGetData($tImage, "YOffPercent")
Return SetError($iRet <> 0, 0, $aImage)
EndFunc
Func _GUICtrlListView_GetCallbackMask($hWnd)
Local $iFlags = 0
Local $iMask = _SendMessage($hWnd, $LVM_GETCALLBACKMASK)
If BitAND($iMask, $LVIS_CUT) <> 0 Then $iFlags = BitOR($iFlags, 1)
If BitAND($iMask, $LVIS_DROPHILITED) <> 0 Then $iFlags = BitOR($iFlags, 2)
If BitAND($iMask, $LVIS_FOCUSED) <> 0 Then $iFlags = BitOR($iFlags, 4)
If BitAND($iMask, $LVIS_SELECTED) <> 0 Then $iFlags = BitOR($iFlags, 8)
If BitAND($iMask, $LVIS_OVERLAYMASK) <> 0 Then $iFlags = BitOR($iFlags, 16)
If BitAND($iMask, $LVIS_STATEIMAGEMASK) <> 0 Then $iFlags = BitOR($iFlags, 32)
Return $iFlags
EndFunc
Func _GUICtrlListView_GetColumn($hWnd, $iIndex)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
DllStructSetData($tColumn, "Mask", $LVCF_ALLDATA)
DllStructSetData($tColumn, "TextMax", 4096)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tColumn, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_GETCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iColumn
DllStructSetData($tColumn, "Text", $pText)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_GETCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tColumn, $iColumn)
_MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
DllStructSetData($tColumn, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
Local $aColumn[9]
Switch BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_JUSTIFYMASK)
Case $LVCFMT_RIGHT
$aColumn[0] = 1
Case $LVCFMT_CENTER
$aColumn[0] = 2
Case Else
$aColumn[0] = 0
EndSwitch
$aColumn[1] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_IMAGE) <> 0
$aColumn[2] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_BITMAP_ON_RIGHT) <> 0
$aColumn[3] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_COL_HAS_IMAGES) <> 0
$aColumn[4] = DllStructGetData($tColumn, "CX")
$aColumn[5] = DllStructGetData($tBuffer, "Text")
$aColumn[6] = DllStructGetData($tColumn, "SubItem")
$aColumn[7] = DllStructGetData($tColumn, "Image")
$aColumn[8] = DllStructGetData($tColumn, "Order")
Return SetError($iRet = 0, 0, $aColumn)
EndFunc
Func _GUICtrlListView_GetColumnCount($hWnd)
Return _SendMessage(_GUICtrlListView_GetHeader($hWnd), 0x1200)
EndFunc
Func _GUICtrlListView_GetColumnOrder($hWnd)
Local $a_Cols = _GUICtrlListView_GetColumnOrderArray($hWnd), $s_Cols = ""
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
For $i = 1 To $a_Cols[0]
$s_Cols &= $a_Cols[$i] & $sSeparatorChar
Next
$s_Cols = StringTrimRight($s_Cols, 1)
Return $s_Cols
EndFunc
Func _GUICtrlListView_GetColumnOrderArray($hWnd)
Local $iColumns = _GUICtrlListView_GetColumnCount($hWnd)
Local $tBuffer = DllStructCreate("int[" & $iColumns & "]")
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_SendMessage($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, DllStructGetPtr($tBuffer))
EndIf
Local $aBuffer[$iColumns + 1]
$aBuffer[0] = $iColumns
For $iI = 1 To $iColumns
$aBuffer[$iI] = DllStructGetData($tBuffer, 1, $iI)
Next
Return $aBuffer
EndFunc
Func _GUICtrlListView_GetColumnWidth($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETCOLUMNWIDTH, $iCol)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNWIDTH, $iCol, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetCounterPage($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETCOUNTPERPAGE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETCOUNTPERPAGE, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetEditControl($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETEDITCONTROL))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETEDITCONTROL, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetEmptyText($hWnd)
Local $tText = DllStructCreate("char[4096]")
Local $iRet
If IsHWnd($hWnd) Then
Local $iText = DllStructGetSize($tText)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iText + 4096, $tMemMap)
Local $pText = $pMemory + $iText
DllStructSetData($tText, "Text", $pText)
_MemWrite($tMemMap, $pText, $pMemory, $iText)
$iRet = _SendMessage($hWnd, $LVM_GETEMPTYTEXT, 4096, $pMemory)
_MemRead($tMemMap, $pText, $tText, 4096)
_MemFree($tMemMap)
If $iRet = 0 Then Return SetError(-1, 0, "")
Return DllStructGetData($tText, 1)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETEMPTYTEXT, 4096, DllStructGetPtr($tText))
If $iRet = 0 Then Return SetError(-1, 0, "")
Return DllStructGetData($tText, 1)
EndIf
EndFunc
Func _GUICtrlListView_GetExtendedListViewStyle($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETEXTENDEDLISTVIEWSTYLE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetFocusedGroup($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETFOCUSEDGROUP)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETFOCUSEDGROUP, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETGROUPCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETGROUPCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupInfo($hWnd, $iGroupID)
Local $tGroup = __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, BitOR($LVGF_HEADER, $LVGF_ALIGN))
Local $iErr = @error
Local $aGroup[2]
$aGroup[0] = _WinAPI_WideCharToMultiByte(DllStructGetData($tGroup, "Header"))
Select
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_CENTER) <> 0
$aGroup[1] = 1
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_RIGHT) <> 0
$aGroup[1] = 2
Case Else
$aGroup[1] = 0
EndSelect
Return SetError($iErr, 0, $aGroup)
EndFunc
Func __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, $iMask)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFO, $iGroupID, $tGroup, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup, $tMemMap)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFO, $iGroupID, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tGroup, $iGroup)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETGROUPINFO, $iGroupID, DllStructGetPtr($tGroup))
EndIf
Return SetError($iRet <> $iGroupID, 0, $tGroup)
EndFunc
Func _GUICtrlListView_GetGroupInfoByIndex($hWnd, $iIndex)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID))
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, $tGroup, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup, $tMemMap)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tGroup, $iGroup)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, DllStructGetPtr($tGroup))
EndIf
Local $aGroup[3]
$aGroup[0] = _WinAPI_WideCharToMultiByte(DllStructGetData($tGroup, "Header"))
Select
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_CENTER) <> 0
$aGroup[1] = 1
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_RIGHT) <> 0
$aGroup[1] = 2
Case Else
$aGroup[1] = 0
EndSelect
$aGroup[2] = DllStructGetData($tGroup, "GroupID")
Return SetError($iRet = 0, 0, $aGroup)
EndFunc
Func _GUICtrlListView_GetGroupRect($hWnd, $iGroupID, $iGet = $LVGGR_GROUP)
Local $tGroup = DllStructCreate($tagRECT)
DllStructSetData($tGroup, "Top", $iGet)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETGROUPRECT, $iGroupID, $tGroup, 0, "wparam", "struct*")
Else
Local $iGroup = DllStructGetSize($tGroup)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup, $tMemMap)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
$iRet = _SendMessage($hWnd, $LVM_GETGROUPRECT, $iGroupID, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tGroup, $iGroup)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETGROUPRECT, $iGroupID, DllStructGetPtr($tGroup))
EndIf
Local $aGroup[4]
For $x = 0 To 3
$aGroup[$x] = DllStructGetData($tGroup, $x + 1)
Next
Return SetError($iRet = 0, 0, $aGroup)
EndFunc
Func _GUICtrlListView_GetGroupState($hWnd, $iGroupID, $iMask)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETGROUPSTATE, $iGroupID, $iMask)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETGROUPSTATE, $iGroupID, $iMask)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupViewEnabled($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ISGROUPVIEWENABLED) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ISGROUPVIEWENABLED, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_GetHeader($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETHEADER))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETHEADER, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetHotCursor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOTCURSOR, 0, 0, 0, "wparam", "lparam", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_GETHOTCURSOR, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetHotItem($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOTITEM)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETHOTITEM, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetHoverTime($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOVERTIME)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETHOVERTIME, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetImageList($hWnd, $iImageList)
Local $aImageList[3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETIMAGELIST, $aImageList[$iImageList], 0, 0, "wparam", "lparam", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_GETIMAGELIST, $aImageList[$iImageList], 0))
EndIf
EndFunc
Func _GUICtrlListView_GetInsertMark($hWnd)
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tMark, "Size", $iMark)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETINSERTMARK, 0, $tMark, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMark, $tMemMap)
_MemWrite($tMemMap, $tMark)
$iRet = _SendMessage($hWnd, $LVM_GETINSERTMARK, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tMark, $iMark)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARK, 0, DllStructGetPtr($tMark))
EndIf
Local $aMark[2]
$aMark[0] = DllStructGetData($tMark, "Flags") = $LVIM_AFTER
$aMark[1] = DllStructGetData($tMark, "Item")
Return SetError($iRet = 0, 0, $aMark)
EndFunc
Func _GUICtrlListView_GetInsertMarkColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetInsertMarkRect($hWnd)
Local $aRect[5]
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$aRect[0] = _SendMessage($hWnd, $LVM_GETINSERTMARKRECT, 0, $tRECT, 0, "wparam", "struct*") <> 0
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
$aRect[0] = _SendMessage($hWnd, $LVM_GETINSERTMARKRECT, 0, $pMemory, 0, "wparam", "ptr") <> 0
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
$aRect[0] = GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARKRECT, 0, DllStructGetPtr($tRECT)) <> 0
EndIf
$aRect[1] = DllStructGetData($tRECT, "Left")
$aRect[2] = DllStructGetData($tRECT, "Top")
$aRect[3] = DllStructGetData($tRECT, "Right")
$aRect[4] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetISearchString($hWnd)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer
If IsHWnd($hWnd) Then
If $bUnicode Then
$iBuffer = _SendMessage($hWnd, $LVM_GETISEARCHSTRINGW) + 1
Else
$iBuffer = _SendMessage($hWnd, $LVM_GETISEARCHSTRINGA) + 1
EndIf
Else
If $bUnicode Then
$iBuffer = GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGW, 0, 0) + 1
Else
$iBuffer = GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGA, 0, 0) + 1
EndIf
EndIf
If $iBuffer = 1 Then Return ""
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETISEARCHSTRINGW, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
If $bUnicode Then
_SendMessage($hWnd, $LVM_GETISEARCHSTRINGW, 0, $pMemory)
Else
_SendMessage($hWnd, $LVM_GETISEARCHSTRINGA, 0, $pMemory)
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pBuffer = DllStructGetPtr($tBuffer)
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGW, 0, $pBuffer)
Else
GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGA, 0, $pBuffer)
EndIf
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlListView_GetItem($hWnd, $iIndex, $iSubItem = 0)
Local $aItem[8]
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Local $iState = DllStructGetData($tItem, "State")
If BitAND($iState, $LVIS_CUT) <> 0 Then $aItem[0] = BitOR($aItem[0], 1)
If BitAND($iState, $LVIS_DROPHILITED) <> 0 Then $aItem[0] = BitOR($aItem[0], 2)
If BitAND($iState, $LVIS_FOCUSED) <> 0 Then $aItem[0] = BitOR($aItem[0], 4)
If BitAND($iState, $LVIS_SELECTED) <> 0 Then $aItem[0] = BitOR($aItem[0], 8)
$aItem[1] = __GUICtrlListView_OverlayImageMaskToIndex($iState)
$aItem[2] = __GUICtrlListView_StateImageMaskToIndex($iState)
$aItem[3] = _GUICtrlListView_GetItemText($hWnd, $iIndex, $iSubItem)
$aItem[4] = DllStructGetData($tItem, "Image")
$aItem[5] = DllStructGetData($tItem, "Param")
$aItem[6] = DllStructGetData($tItem, "Indent")
$aItem[7] = DllStructGetData($tItem, "GroupID")
Return $aItem
EndFunc
Func _GUICtrlListView_GetItemChecked($hWnd, $iIndex)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tLVITEM = DllStructCreate($tagLVITEM)
Local $iSize = DllStructGetSize($tLVITEM)
If @error Then Return SetError($LV_ERR, $LV_ERR, False)
DllStructSetData($tLVITEM, "Mask", $LVIF_STATE)
DllStructSetData($tLVITEM, "Item", $iIndex)
DllStructSetData($tLVITEM, "StateMask", 0xffff)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMW, 0, $tLVITEM, 0, "wparam", "struct*") <> 0
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tLVITEM)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMW, 0, $pMemory, 0, "wparam", "ptr") <> 0
Else
$iRet = _SendMessage($hWnd, $LVM_GETITEMA, 0, $pMemory, 0, "wparam", "ptr") <> 0
EndIf
_MemRead($tMemMap, $pMemory, $tLVITEM, $iSize)
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tLVITEM)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMW, 0, $pItem) <> 0
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMA, 0, $pItem) <> 0
EndIf
EndIf
If Not $iRet Then Return SetError($LV_ERR, $LV_ERR, False)
Return BitAND(DllStructGetData($tLVITEM, "State"), 0x2000) <> 0
EndFunc
Func _GUICtrlListView_GetItemCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETITEMCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETITEMCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetItemCut($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_CUT) <> 0
EndFunc
Func _GUICtrlListView_GetItemDropHilited($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_DROPHILITED) <> 0
EndFunc
Func _GUICtrlListView_GetItemEx($hWnd, ByRef $tItem)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
_SendMessage($hWnd, $LVM_GETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_GETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_GetItemFocused($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_FOCUSED) <> 0
EndFunc
Func _GUICtrlListView_GetItemGroupID($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_GROUPID)
DllStructSetData($tItem, "Item", $iIndex)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "GroupID")
EndFunc
Func _GUICtrlListView_GetItemImage($hWnd, $iIndex, $iSubItem = 0)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_IMAGE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlListView_GetItemIndent($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_INDENT)
DllStructSetData($tItem, "Item", $iIndex)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Indent")
EndFunc
Func __GUICtrlListView_GetItemOverlayImage($hWnd, $iIndex)
Return BitShift(_GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_OVERLAYMASK), 8)
EndFunc
Func _GUICtrlListView_GetItemParam($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_PARAM)
DllStructSetData($tItem, "Item", $iIndex)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Param")
EndFunc
Func _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Local $aPoint[2], $iRet
Local $tPoint = DllStructCreate($tagPOINT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
If Not _SendMessage($hWnd, $LVM_GETITEMPOSITION, $iIndex, $tPoint, 0, "wparam", "struct*") Then Return $aPoint
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
If Not _SendMessage($hWnd, $LVM_GETITEMPOSITION, $iIndex, $pMemory, 0, "wparam", "ptr") Then Return $aPoint
_MemRead($tMemMap, $pMemory, $tPoint, $iPoint)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMPOSITION, $iIndex, DllStructGetPtr($tPoint))
If Not $iRet Then Return $aPoint
EndIf
$aPoint[0] = DllStructGetData($tPoint, "X")
$aPoint[1] = DllStructGetData($tPoint, "Y")
Return $aPoint
EndFunc
Func _GUICtrlListView_GetItemPositionX($hWnd, $iIndex)
Local $aPoint = _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Return $aPoint[0]
EndFunc
Func _GUICtrlListView_GetItemPositionY($hWnd, $iIndex)
Local $aPoint = _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Return $aPoint[1]
EndFunc
Func _GUICtrlListView_GetItemRect($hWnd, $iIndex, $iPart = 3)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart = 3)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iPart)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlListView_GetItemSelected($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_SELECTED) <> 0
EndFunc
Func _GUICtrlListView_GetItemSpacing($hWnd, $bSmall = False)
Local $iSpace
If IsHWnd($hWnd) Then
$iSpace = _SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall)
Else
$iSpace = GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0)
EndIf
Local $aSpace[2]
$aSpace[0] = BitAND($iSpace, 0xFFFF)
$aSpace[1] = BitShift($iSpace, 16)
Return $aSpace
EndFunc
Func _GUICtrlListView_GetItemSpacingX($hWnd, $bSmall = False)
If IsHWnd($hWnd) Then
Return BitAND(_SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 0xFFFF)
Else
Return BitAND(GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 0xFFFF)
EndIf
EndFunc
Func _GUICtrlListView_GetItemSpacingY($hWnd, $bSmall = False)
If IsHWnd($hWnd) Then
Return BitShift(_SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 16)
Else
Return BitShift(GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 16)
EndIf
EndFunc
Func _GUICtrlListView_GetItemState($hWnd, $iIndex, $iMask)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETITEMSTATE, $iIndex, $iMask)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETITEMSTATE, $iIndex, $iMask)
EndIf
EndFunc
Func _GUICtrlListView_GetItemStateImage($hWnd, $iIndex)
Return BitShift(_GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_STATEIMAGEMASK), 12)
EndFunc
Func _GUICtrlListView_GetItemText($hWnd, $iIndex, $iSubItem = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "TextMax", 4096)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
_SendMessage($hWnd, $LVM_GETITEMTEXTW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + 4096, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
_SendMessage($hWnd, $LVM_GETITEMTEXTW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_GETITEMTEXTA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pText, $tBuffer, 4096)
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_GETITEMTEXTW, $iIndex, $pItem)
Else
GUICtrlSendMsg($hWnd, $LVM_GETITEMTEXTA, $iIndex, $pItem)
EndIf
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlListView_GetItemTextArray($hWnd, $iItem = -1)
Local $sItems = _GUICtrlListView_GetItemTextString($hWnd, $iItem)
If $sItems = "" Then
Local $aItems[1] = [0]
Return SetError($LV_ERR, $LV_ERR, $aItems)
EndIf
Return StringSplit($sItems, Opt('GUIDataSeparatorChar'))
EndFunc
Func _GUICtrlListView_GetItemTextString($hWnd, $iItem = -1)
Local $sRow = "", $sSeparatorChar = Opt('GUIDataSeparatorChar'), $iSelected
If $iItem = -1 Then
$iSelected = _GUICtrlListView_GetNextItem($hWnd)
Else
$iSelected = $iItem
EndIf
For $x = 0 To _GUICtrlListView_GetColumnCount($hWnd) - 1
$sRow &= _GUICtrlListView_GetItemText($hWnd, $iSelected, $x) & $sSeparatorChar
Next
Return StringTrimRight($sRow, 1)
EndFunc
Func _GUICtrlListView_GetNextItem($hWnd, $iStart = -1, $iSearch = 0, $iState = 8)
Local $aSearch[5] = [$LVNI_ALL, $LVNI_ABOVE, $LVNI_BELOW, $LVNI_TOLEFT, $LVNI_TORIGHT]
Local $iFlags = $aSearch[$iSearch]
If BitAND($iState, 1) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_CUT)
If BitAND($iState, 2) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_DROPHILITED)
If BitAND($iState, 4) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_FOCUSED)
If BitAND($iState, 8) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_SELECTED)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETNEXTITEM, $iStart, $iFlags)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETNEXTITEM, $iStart, $iFlags)
EndIf
EndFunc
Func _GUICtrlListView_GetNumberOfWorkAreas($hWnd)
Local $tBuffer = DllStructCreate("int Data")
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_SendMessage($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, DllStructGetPtr($tBuffer))
EndIf
Return DllStructGetData($tBuffer, "Data")
EndFunc
Func _GUICtrlListView_GetOrigin($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETORIGIN, 0, $tPoint, 0, "wparam", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
$iRet = _SendMessage($hWnd, $LVM_GETORIGIN, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tPoint, $iPoint)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETORIGIN, 0, DllStructGetPtr($tPoint))
EndIf
Local $aOrigin[2]
$aOrigin[0] = DllStructGetData($tPoint, "X")
$aOrigin[1] = DllStructGetData($tPoint, "Y")
Return SetError(@error, $iRet = 1, $aOrigin)
EndFunc
Func _GUICtrlListView_GetOriginX($hWnd)
Local $aOrigin = _GUICtrlListView_GetOrigin($hWnd)
Return $aOrigin[0]
EndFunc
Func _GUICtrlListView_GetOriginY($hWnd)
Local $aOrigin = _GUICtrlListView_GetOrigin($hWnd)
Return $aOrigin[1]
EndFunc
Func _GUICtrlListView_GetOutlineColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETOUTLINECOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETOUTLINECOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetSelectedColumn($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTEDCOLUMN)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTEDCOLUMN, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetSelectedCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTEDCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTEDCOUNT, 0, 0)
EndIf
EndFunc
Func __GUICtrlListView_GetCheckedIndices($hWnd)
Local $iCount = _GUICtrlListView_GetItemCount($hWnd)
Local $aSelected[$iCount + 1] = [0]
For $i = 0 To $iCount - 1
If _GUICtrlListView_GetItemChecked($hWnd, $i) Then
$aSelected[0] += 1
$aSelected[$aSelected[0]] = $i
EndIf
Next
ReDim $aSelected[$aSelected[0] + 1]
Return $aSelected
EndFunc
Func _GUICtrlListView_GetSelectedIndices($hWnd, $bArray = False)
Local $sIndices, $aIndices[1] = [0]
Local $iRet, $iCount = _GUICtrlListView_GetItemCount($hWnd)
For $iItem = 0 To $iCount
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMSTATE, $iItem, $LVIS_SELECTED)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMSTATE, $iItem, $LVIS_SELECTED)
EndIf
If $iRet Then
If (Not $bArray) Then
If StringLen($sIndices) Then
$sIndices &= "|" & $iItem
Else
$sIndices = $iItem
EndIf
Else
ReDim $aIndices[UBound($aIndices) + 1]
$aIndices[0] = UBound($aIndices) - 1
$aIndices[UBound($aIndices) - 1] = $iItem
EndIf
EndIf
Next
If (Not $bArray) Then
Return String($sIndices)
Else
Return $aIndices
EndIf
EndFunc
Func _GUICtrlListView_GetSelectionMark($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTIONMARK)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTIONMARK, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetStringWidth($hWnd, $sString)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sString) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sString)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETSTRINGWIDTHW, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer, $pMemory, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETSTRINGWIDTHW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_GETSTRINGWIDTHA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pBuffer = DllStructGetPtr($tBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETSTRINGWIDTHW, 0, $pBuffer)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETSTRINGWIDTHA, 0, $pBuffer)
EndIf
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_GetSubItemRect($hWnd, $iIndex, $iSubItem, $iPart = 0)
Local $aPart[2] = [$LVIR_BOUNDS, $LVIR_ICON]
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Top", $iSubItem)
DllStructSetData($tRECT, "Left", $aPart[$iPart])
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETSUBITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_GETSUBITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETSUBITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetTextBkColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTEXTBKCOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTEXTBKCOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetTextColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTEXTCOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTEXTCOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetToolTips($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETTOOLTIPS))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETTOOLTIPS, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetTopIndex($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTOPINDEX)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTOPINDEX, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetUnicodeFormat($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETUNICODEFORMAT) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETUNICODEFORMAT, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_GetView($hWnd)
Local $iView
If IsHWnd($hWnd) Then
$iView = _SendMessage($hWnd, $LVM_GETVIEW)
Else
$iView = GUICtrlSendMsg($hWnd, $LVM_GETVIEW, 0, 0)
EndIf
Switch $iView
Case $LV_VIEW_ICON
Return Int($LV_VIEW_ICON)
Case $LV_VIEW_DETAILS
Return Int($LV_VIEW_DETAILS)
Case $LV_VIEW_LIST
Return Int($LV_VIEW_LIST)
Case $LV_VIEW_SMALLICON
Return Int($LV_VIEW_SMALLICON)
Case $LV_VIEW_TILE
Return Int($LV_VIEW_TILE)
Case Else
Return -1
EndSwitch
EndFunc
Func _GUICtrlListView_GetViewDetails($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_DETAILS
EndFunc
Func _GUICtrlListView_GetViewLarge($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_ICON
EndFunc
Func _GUICtrlListView_GetViewList($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_LIST
EndFunc
Func _GUICtrlListView_GetViewSmall($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_SMALLICON
EndFunc
Func _GUICtrlListView_GetViewTile($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_TILE
EndFunc
Func _GUICtrlListView_GetViewRect($hWnd)
Local $aRect[4] = [0, 0, 0, 0]
Local $iView = _GUICtrlListView_GetView($hWnd)
If ($iView <> 1) And ($iView <> 3) Then Return $aRect
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETVIEWRECT, 0, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $LVM_GETVIEWRECT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETVIEWRECT, 0, DllStructGetPtr($tRECT))
EndIf
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_HideColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCOLUMNWIDTH, $iCol) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_HitTest($hWnd, $iX = -1, $iY = -1)
Local $aTest[10]
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
Local $aResult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] = 0 Then Return 0
If $iX = -1 Then $iX = DllStructGetData($tPoint, "X")
If $iY = -1 Then $iY = DllStructGetData($tPoint, "Y")
Local $tTest = DllStructCreate($tagLVHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$aTest[0] = _SendMessage($hWnd, $LVM_HITTEST, 0, $tTest, 0, "wparam", "struct*")
Else
Local $iTest = DllStructGetSize($tTest)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iTest, $tMemMap)
_MemWrite($tMemMap, $tTest, $pMemory, $iTest)
$aTest[0] = _SendMessage($hWnd, $LVM_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tTest, $iTest)
_MemFree($tMemMap)
EndIf
Else
$aTest[0] = GUICtrlSendMsg($hWnd, $LVM_HITTEST, 0, DllStructGetPtr($tTest))
EndIf
Local $iFlags = DllStructGetData($tTest, "Flags")
$aTest[1] = BitAND($iFlags, $LVHT_NOWHERE) <> 0
$aTest[2] = BitAND($iFlags, $LVHT_ONITEMICON) <> 0
$aTest[3] = BitAND($iFlags, $LVHT_ONITEMLABEL) <> 0
$aTest[4] = BitAND($iFlags, $LVHT_ONITEMSTATEICON) <> 0
$aTest[5] = BitAND($iFlags, $LVHT_ONITEM) <> 0
$aTest[6] = BitAND($iFlags, $LVHT_ABOVE) <> 0
$aTest[7] = BitAND($iFlags, $LVHT_BELOW) <> 0
$aTest[8] = BitAND($iFlags, $LVHT_TOLEFT) <> 0
$aTest[9] = BitAND($iFlags, $LVHT_TORIGHT) <> 0
Return $aTest
EndFunc
Func __GUICtrlListView_IndexToOverlayImageMask($iIndex)
Return BitShift($iIndex, -8)
EndFunc
Func __GUICtrlListView_IndexToStateImageMask($iIndex)
Return BitShift($iIndex, -12)
EndFunc
Func _GUICtrlListView_InsertColumn($hWnd, $iIndex, $sText, $iWidth = 50, $iAlign = -1, $iImage = -1, $bOnRight = False)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
Local $iMask = BitOR($LVCF_FMT, $LVCF_WIDTH, $LVCF_TEXT)
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $iFmt = $aAlign[$iAlign]
If $iImage <> -1 Then
$iMask = BitOR($iMask, $LVCF_IMAGE)
$iFmt = BitOR($iFmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $LVCFMT_BITMAP_ON_RIGHT)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
DllStructSetData($tColumn, "CX", $iWidth)
DllStructSetData($tColumn, "TextMax", $iBuffer)
DllStructSetData($tColumn, "Image", $iImage)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tColumn, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_INSERTCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iColumn
DllStructSetData($tColumn, "Text", $pText)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_INSERTCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_INSERTCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
DllStructSetData($tColumn, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
If $iAlign > 0 Then _GUICtrlListView_SetColumn($hWnd, $iRet, $sText, $iWidth, $iAlign, $iImage, $bOnRight)
Return $iRet
EndFunc
Func _GUICtrlListView_InsertGroup($hWnd, $iIndex, $iGroupID, $sHeader, $iAlign = 0)
Local $aAlign[3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $tHeader = _WinAPI_MultiByteToWideChar($sHeader)
Local $pHeader = DllStructGetPtr($tHeader)
Local $iHeader = StringLen($sHeader)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
Local $iMask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
DllStructSetData($tGroup, "HeaderMax", $iHeader)
DllStructSetData($tGroup, "GroupID", $iGroupID)
DllStructSetData($tGroup, "Align", $aAlign[$iAlign])
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = _SendMessage($hWnd, $LVM_INSERTGROUP, $iIndex, $tGroup, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup + $iHeader, $tMemMap)
Local $pText = $pMemory + $iGroup
DllStructSetData($tGroup, "Header", $pText)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
_MemWrite($tMemMap, $tHeader, $pText, $iHeader)
$iRet = _SendMessage($hWnd, $LVM_INSERTGROUP, $iIndex, $tGroup, 0, "wparam", "struct*")
_MemFree($tMemMap)
EndIf
Else
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTGROUP, $iIndex, DllStructGetPtr($tGroup))
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_InsertItem($hWnd, $sText, $iIndex = -1, $iImage = -1, $iParam = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer, $tBuffer, $iRet
If $iIndex = -1 Then $iIndex = 999999999
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Param", $iParam)
$iBuffer = StringLen($sText) + 1
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iMask = BitOR($LVIF_TEXT, $LVIF_PARAM)
If $iImage >= 0 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Image", $iImage)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Or ($sText = -1) Then
$iRet = _SendMessage($hWnd, $LVM_INSERTITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_INSERTITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_INSERTITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_InsertMarkHitTest($hWnd, $iX = -1, $iY = -1)
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
Local $aResult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] = 0 Then Return 0
If $iX = -1 Then $iX = DllStructGetData($tPoint, "X")
If $iY = -1 Then $iY = DllStructGetData($tPoint, "Y")
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tPoint, "X", $iX)
DllStructSetData($tPoint, "Y", $iY)
DllStructSetData($tMark, "Size", $iMark)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_INSERTMARKHITTEST, $tPoint, $tMark, 0, "struct*", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemM = _MemInit($hWnd, $iPoint + $iMark, $tMemMap)
Local $pMemP = $pMemM + $iPoint
_MemWrite($tMemMap, $tMark, $pMemM, $iMark)
_MemWrite($tMemMap, $tPoint, $pMemP, $iPoint)
_SendMessage($hWnd, $LVM_INSERTMARKHITTEST, $pMemP, $pMemM, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemM, $tMark, $iMark)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_INSERTMARKHITTEST, DllStructGetPtr($tPoint), DllStructGetPtr($tMark))
EndIf
Local $aTest[2]
$aTest[0] = DllStructGetData($tMark, "Flags") = $LVIM_AFTER
$aTest[1] = DllStructGetData($tMark, "Item")
Return $aTest
EndFunc
Func _GUICtrlListView_IsItemVisible($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ISITEMVISIBLE, $iIndex) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ISITEMVISIBLE, $iIndex, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_JustifyColumn($hWnd, $iIndex, $iAlign = -1)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $iMask = $LVCF_FMT
Local $iFmt = $aAlign[$iAlign]
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn, $tMemMap)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_MapIDToIndex($hWnd, $iID)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MAPIDTOINDEX, $iID)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MAPIDTOINDEX, $iID, 0)
EndIf
EndFunc
Func _GUICtrlListView_MapIndexToID($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MAPINDEXTOID, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MAPINDEXTOID, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListView_MoveGroup($hWnd, $iGroupID, $iIndex = -1)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MOVEGROUP, $iGroupID, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MOVEGROUP, $iGroupID, $iIndex)
EndIf
EndFunc
Func __GUICtrlListView_OverlayImageMaskToIndex($iMask)
Return BitShift(BitAND($LVIS_OVERLAYMASK, $iMask), 8)
EndFunc
Func _GUICtrlListView_RedrawItems($hWnd, $iFirst, $iLast)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_REDRAWITEMS, $iFirst, $iLast) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_REDRAWITEMS, $iFirst, $iLast) <> 0
EndIf
EndFunc
Func _GUICtrlListView_RegisterSortCallBack($hWnd, $bNumbers = True, $bArrows = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $hHeader = _GUICtrlListView_GetHeader($hWnd)
ReDim $__g_aListViewSortInfo[UBound($__g_aListViewSortInfo) + 1][$__g_iLListViewSortInfoSize]
$__g_aListViewSortInfo[0][0] = UBound($__g_aListViewSortInfo) - 1
Local $iIndex = $__g_aListViewSortInfo[0][0]
$__g_aListViewSortInfo[$iIndex][1] = $hWnd
$__g_aListViewSortInfo[$iIndex][2] =  DllCallbackRegister("__GUICtrlListView_Sort", "int", "int;int;hwnd")
$__g_aListViewSortInfo[$iIndex][3] = -1
$__g_aListViewSortInfo[$iIndex][4] = -1
$__g_aListViewSortInfo[$iIndex][5] = 1
$__g_aListViewSortInfo[$iIndex][6] = -1
$__g_aListViewSortInfo[$iIndex][7] = 0
$__g_aListViewSortInfo[$iIndex][8] = $bNumbers
$__g_aListViewSortInfo[$iIndex][9] = $bArrows
$__g_aListViewSortInfo[$iIndex][10] = $hHeader
Return $__g_aListViewSortInfo[$iIndex][2] <> 0
EndFunc
Func _GUICtrlListView_RemoveAllGroups($hWnd)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_REMOVEALLGROUPS)
Else
GUICtrlSendMsg($hWnd, $LVM_REMOVEALLGROUPS, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_RemoveGroup($hWnd, $iGroupID)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_REMOVEGROUP, $iGroupID)
Else
Return GUICtrlSendMsg($hWnd, $LVM_REMOVEGROUP, $iGroupID, 0)
EndIf
EndFunc
Func __GUICtrlListView_ReverseColorOrder($iColor)
Local $sH = Hex(String($iColor), 6)
Return '0x' & StringMid($sH, 5, 2) & StringMid($sH, 3, 2) & StringMid($sH, 1, 2)
EndFunc
Func _GUICtrlListView_Scroll($hWnd, $iDX, $iDY)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SCROLL, $iDX, $iDY) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SCROLL, $iDX, $iDY) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetBkColor($hWnd, $iColor)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETBKCOLOR, 0, $iColor)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKCOLOR, 0, $iColor)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetBkImage($hWnd, $sURL = "", $iStyle = 0, $iXOffset = 0, $iYOffset = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
If Not IsHWnd($hWnd) Then Return SetError($LV_ERR, $LV_ERR, False)
Local $aStyle[2] = [$LVBKIF_STYLE_NORMAL, $LVBKIF_STYLE_TILE]
Local $iBuffer = StringLen($sURL) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
If @error Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tImage = DllStructCreate($tagLVBKIMAGE)
Local $iRet = 0
If $sURL <> "" Then $iRet = $LVBKIF_SOURCE_URL
$iRet = BitOR($iRet, $aStyle[$iStyle])
DllStructSetData($tBuffer, "Text", $sURL)
DllStructSetData($tImage, "Flags", $iRet)
DllStructSetData($tImage, "XOffPercent", $iXOffset)
DllStructSetData($tImage, "YOffPercent", $iYOffset)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tImage, "Image", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETBKIMAGEW, 0, $tImage, 0, "wparam", "struct*")
Else
Local $iImage = DllStructGetSize($tImage)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iImage + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iImage
DllStructSetData($tImage, "Image", $pText)
_MemWrite($tMemMap, $tImage, $pMemory, $iImage)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETBKIMAGEW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETBKIMAGEA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pImage = DllStructGetPtr($tImage)
DllStructSetData($tImage, "Image", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKIMAGEW, 0, $pImage)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKIMAGEA, 0, $pImage)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetCallBackMask($hWnd, $iMask)
Local $iFlags = 0
If BitAND($iMask, 1) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_CUT)
If BitAND($iMask, 2) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_DROPHILITED)
If BitAND($iMask, 4) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_FOCUSED)
If BitAND($iMask, 8) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_SELECTED)
If BitAND($iMask, 16) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_OVERLAYMASK)
If BitAND($iMask, 32) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_STATEIMAGEMASK)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCALLBACKMASK, $iFlags) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCALLBACKMASK, $iFlags, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetColumn($hWnd, $iIndex, $sText, $iWidth = -1, $iAlign = -1, $iImage = -1, $bOnRight = False)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
Local $iMask = $LVCF_TEXT
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
$iMask = BitOR($iMask, $LVCF_FMT)
Local $iFmt = $aAlign[$iAlign]
If $iWidth <> -1 Then $iMask = BitOR($iMask, $LVCF_WIDTH)
If $iImage <> -1 Then
$iMask = BitOR($iMask, $LVCF_IMAGE)
$iFmt = BitOR($iFmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
Else
$iImage = 0
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $LVCFMT_BITMAP_ON_RIGHT)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
DllStructSetData($tColumn, "CX", $iWidth)
DllStructSetData($tColumn, "TextMax", $iBuffer)
DllStructSetData($tColumn, "Image", $iImage)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tColumn, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iColumn
DllStructSetData($tColumn, "Text", $pText)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
DllStructSetData($tColumn, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetColumnOrder($hWnd, $sOrder)
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Return _GUICtrlListView_SetColumnOrderArray($hWnd, StringSplit($sOrder, $sSeparatorChar))
EndFunc
Func _GUICtrlListView_SetColumnOrderArray($hWnd, $aOrder)
Local $tBuffer = DllStructCreate("int[" & $aOrder[0] & "]")
For $iI = 1 To $aOrder[0]
DllStructSetData($tBuffer, 1, $aOrder[$iI], $iI)
Next
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer, $pMemory, $iBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], DllStructGetPtr($tBuffer))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetColumnWidth($hWnd, $iCol, $iWidth)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, $iWidth)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, $iWidth)
EndIf
EndFunc
Func _GUICtrlListView_SetExtendedListViewStyle($hWnd, $iExStyle, $iExMask = 0)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iExMask, $iExStyle)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iExMask, $iExStyle)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_SetGroupInfo($hWnd, $iGroupID, $sHeader, $iAlign = 0, $iState = $LVGS_NORMAL)
Local $tGroup = 0
If BitAND($iState, $LVGS_SELECTED) Then
$tGroup = __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, BitOR($LVGF_GROUPID, $LVGF_ITEMS))
If DllStructGetData($tGroup, "GroupId") <> $iGroupID Or DllStructGetData($tGroup, "cItems") = 0 Then Return False
EndIf
Local $aAlign[3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $tHeader = _WinAPI_MultiByteToWideChar($sHeader)
Local $pHeader = DllStructGetPtr($tHeader)
Local $iHeader = StringLen($sHeader)
$tGroup = DllStructCreate($tagLVGROUP)
Local $pGroup = DllStructGetPtr($tGroup)
Local $iGroup = DllStructGetSize($tGroup)
Local $iMask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_STATE)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
DllStructSetData($tGroup, "HeaderMax", $iHeader)
DllStructSetData($tGroup, "Align", $aAlign[$iAlign])
DllStructSetData($tGroup, "State", $iState)
DllStructSetData($tGroup, "StateMask", $iState)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = _SendMessage($hWnd, $LVM_SETGROUPINFO, $iGroupID, $pGroup)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
_SendMessage($hWnd, $LVM_SETGROUPINFO, 0, $pGroup)
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup + $iHeader, $tMemMap)
Local $pText = $pMemory + $iGroup
DllStructSetData($tGroup, "Header", $pText)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
_MemWrite($tMemMap, $tHeader, $pText, $iHeader)
$iRet = _SendMessage($hWnd, $LVM_SETGROUPINFO, $iGroupID, $pMemory)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
_SendMessage($hWnd, $LVM_SETGROUPINFO, 0, $pMemory)
_MemFree($tMemMap)
EndIf
_WinAPI_InvalidateRect($hWnd)
Else
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETGROUPINFO, $iGroupID, $pGroup)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
GUICtrlSendMsg($hWnd, $LVM_SETGROUPINFO, 0, $pGroup)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetHotCursor($hWnd, $hCursor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOTCURSOR, 0, $hCursor, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_SETHOTCURSOR, 0, $hCursor))
EndIf
EndFunc
Func _GUICtrlListView_SetHotItem($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOTITEM, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETHOTITEM, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListView_SetHoverTime($hWnd, $iTime)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOVERTIME, 0, $iTime)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETHOVERTIME, 0, $iTime)
EndIf
EndFunc
Func _GUICtrlListView_SetIconSpacing($hWnd, $iCX, $iCY)
Local $iRet, $aPadding[2]
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETICONSPACING, 0, _WinAPI_MakeLong($iCX, $iCY))
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETICONSPACING, 0, _WinAPI_MakeLong($iCX, $iCY))
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
$aPadding[0] = BitAND($iRet, 0xFFFF)
$aPadding[1] = BitShift($iRet, 16)
Return $aPadding
EndFunc
Func _GUICtrlListView_SetImageList($hWnd, $hHandle, $iType = 0)
Local $aType[3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETIMAGELIST, $aType[$iType], $hHandle, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_SETIMAGELIST, $aType[$iType], $hHandle))
EndIf
EndFunc
Func _GUICtrlListView_SetInfoTip($hWnd, $iIndex, $sText, $iSubItem = 0)
Local $tBuffer = _WinAPI_MultiByteToWideChar($sText)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $iBuffer = StringLen($sText)
Local $tInfo = DllStructCreate($tagLVSETINFOTIP)
Local $iInfo = DllStructGetSize($tInfo)
DllStructSetData($tInfo, "Size", $iInfo)
DllStructSetData($tInfo, "Item", $iIndex)
DllStructSetData($tInfo, "SubItem", $iSubItem)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tInfo, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETINFOTIP, 0, $tInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iInfo + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iInfo
DllStructSetData($tInfo, "Text", $pText)
_MemWrite($tMemMap, $tInfo, $pMemory, $iInfo)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETINFOTIP, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
DllStructSetData($tInfo, "Text", $pBuffer)
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETINFOTIP, 0, DllStructGetPtr($tInfo))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetInsertMark($hWnd, $iIndex, $bAfter = False)
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tMark, "Size", $iMark)
If $bAfter Then DllStructSetData($tMark, "Flags", $LVIM_AFTER)
DllStructSetData($tMark, "Item", $iIndex)
DllStructSetData($tMark, "Reserved", 0)
Local $iRet
If IsHWnd($hWnd) Then
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMark, $tMemMap)
_MemWrite($tMemMap, $tMark, $pMemory, $iMark)
$iRet = _SendMessage($hWnd, $LVM_SETINSERTMARK, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETINSERTMARK, 0, DllStructGetPtr($tMark))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetInsertMarkColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETINSERTMARKCOLOR, 0, $iColor)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETINSERTMARKCOLOR, 0, $iColor)
EndIf
EndFunc
Func _GUICtrlListView_SetItem($hWnd, $sText, $iIndex = 0, $iSubItem = 0, $iImage = -1, $iParam = -1, $iIndent = -1)
Local $pBuffer, $iBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
$pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagLVITEM)
Local $iMask = $LVIF_TEXT
If $iImage <> -1 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
If $iParam <> -1 Then $iMask = BitOR($iMask, $LVIF_PARAM)
If $iIndent <> -1 Then $iMask = BitOR($iMask, $LVIF_INDENT)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Text", $pBuffer)
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Param", $iParam)
DllStructSetData($tItem, "Indent", $iIndent)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemChecked($hWnd, $iIndex, $bCheck = True)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $pMemory, $tMemMap, $iRet
Local $tItem = DllStructCreate($tagLVITEM)
Local $pItem = DllStructGetPtr($tItem)
Local $iItem = DllStructGetSize($tItem)
If @error Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
If $iIndex <> -1 Then
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $iIndex)
If ($bCheck) Then
DllStructSetData($tItem, "State", 0x2000)
Else
DllStructSetData($tItem, "State", 0x1000)
EndIf
DllStructSetData($tItem, "StateMask", 0xf000)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*") <> 0
Else
$pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
Return $iRet <> 0
EndIf
Else
If $bUnicode Then
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem) <> 0
EndIf
EndIf
Else
For $x = 0 To _GUICtrlListView_GetItemCount($hWnd) - 1
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $x)
If ($bCheck) Then
DllStructSetData($tItem, "State", 0x2000)
Else
DllStructSetData($tItem, "State", 0x1000)
EndIf
DllStructSetData($tItem, "StateMask", 0xf000)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
If Not _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*") <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
Else
$pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
If Not $iRet <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
EndIf
Else
If $bUnicode Then
If Not GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem) <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
Else
If Not GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem) <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
EndIf
EndIf
Next
Return True
EndIf
Return False
EndFunc
Func _GUICtrlListView_SetItemCount($hWnd, $iItems)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMCOUNT, $iItems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMCOUNT, $iItems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetItemCut($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_CUT
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_CUT)
EndFunc
Func _GUICtrlListView_SetItemDropHilited($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_DROPHILITED
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_DROPHILITED)
EndFunc
Func _GUICtrlListView_SetItemEx($hWnd, ByRef $tItem)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iRet
If IsHWnd($hWnd) Then
Local $iItem = DllStructGetSize($tItem)
Local $iBuffer = DllStructGetData($tItem, "TextMax")
Local $pBuffer = DllStructGetData($tItem, "Text")
If $bUnicode Then $iBuffer *= 2
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $pBuffer <> 0 Then _MemWrite($tMemMap, $pBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
Else
Local $pItem = DllStructGetPtr($tItem)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemFocused($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_FOCUSED
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_FOCUSED)
EndFunc
Func _GUICtrlListView_SetItemGroupID($hWnd, $iIndex, $iGroupID)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_GROUPID)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "GroupID", $iGroupID)
_GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemImage($hWnd, $iIndex, $iImage, $iSubItem = 0)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_IMAGE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", $iImage)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemIndent($hWnd, $iIndex, $iIndent)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_INDENT)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Indent", $iIndent)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func __GUICtrlListView_SetItemOverlayImage($hWnd, $iIndex, $iImage)
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, __GUICtrlListView_IndexToOverlayImageMask($iImage), $LVIS_OVERLAYMASK)
EndFunc
Func _GUICtrlListView_SetItemParam($hWnd, $iIndex, $iParam)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_PARAM)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Param", $iParam)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemPosition($hWnd, $iIndex, $iCX, $iCY)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMPOSITION, $iIndex, _WinAPI_MakeLong($iCX, $iCY)) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMPOSITION, $iIndex, _WinAPI_MakeLong($iCX, $iCY)) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetItemPosition32($hWnd, $iIndex, $iCX, $iCY)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iCX)
DllStructSetData($tPoint, "Y", $iCY)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMPOSITION32, $iIndex, $tPoint, 0, "wparam", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
_MemWrite($tMemMap, $tPoint)
$iRet = _SendMessage($hWnd, $LVM_SETITEMPOSITION32, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMPOSITION32, $iIndex, DllStructGetPtr($tPoint))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemSelected($hWnd, $iIndex, $bSelected = True, $bFocused = False)
Local $tStruct = DllStructCreate($tagLVITEM)
Local $iRet, $iSelected = 0, $iFocused = 0, $iSize, $tMemMap, $pMemory
If ($bSelected = True) Then $iSelected = $LVIS_SELECTED
If ($bFocused = True And $iIndex <> -1) Then $iFocused = $LVIS_FOCUSED
DllStructSetData($tStruct, "Mask", $LVIF_STATE)
DllStructSetData($tStruct, "Item", $iIndex)
DllStructSetData($tStruct, "State", BitOR($iSelected, $iFocused))
DllStructSetData($tStruct, "StateMask", BitOR($LVIS_SELECTED, $iFocused))
$iSize = DllStructGetSize($tStruct)
If IsHWnd($hWnd) Then
$pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tStruct, $pMemory, $iSize)
$iRet = _SendMessage($hWnd, $LVM_SETITEMSTATE, $iIndex, $pMemory)
_MemFree($tMemMap)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMSTATE, $iIndex, DllStructGetPtr($tStruct))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $iStateMask)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "State", $iState)
DllStructSetData($tItem, "StateMask", $iStateMask)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem) <> 0
EndFunc
Func _GUICtrlListView_SetItemStateImage($hWnd, $iIndex, $iImage)
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, BitShift($iImage, -12), $LVIS_STATEIMAGEMASK)
EndFunc
Func _GUICtrlListView_SetItemText($hWnd, $iIndex, $sText, $iSubItem = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iRet
If $iSubItem = -1 Then
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local $i_Cols = _GUICtrlListView_GetColumnCount($hWnd)
Local $a_Text = StringSplit($sText, $sSeparatorChar)
If $i_Cols > $a_Text[0] Then $i_Cols = $a_Text[0]
For $i = 1 To $i_Cols
$iRet = _GUICtrlListView_SetItemText($hWnd, $iIndex, $a_Text[$i], $i - 1)
If Not $iRet Then ExitLoop
Next
Return $iRet
EndIf
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
DllStructSetData($tItem, "item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetOutlineColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETOUTLINECOLOR, 0, $iColor)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETOUTLINECOLOR, 0, $iColor)
EndIf
EndFunc
Func _GUICtrlListView_SetSelectedColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_SETSELECTEDCOLUMN, $iCol)
_WinAPI_InvalidateRect($hWnd)
Else
GUICtrlSendMsg($hWnd, $LVM_SETSELECTEDCOLUMN, $iCol, 0)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
EndFunc
Func _GUICtrlListView_SetSelectionMark($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETSELECTIONMARK, 0, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETSELECTIONMARK, 0, $iIndex)
EndIf
EndFunc
Func _GUICtrlListView_SetTextBkColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETTEXTBKCOLOR, 0, $iColor) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETTEXTBKCOLOR, 0, $iColor) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetTextColor($hWnd, $iColor)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETTEXTCOLOR, 0, $iColor)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETTEXTCOLOR, 0, $iColor)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetToolTips($hWnd, $hToolTip)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETTOOLTIPS, 0, $hToolTip, 0, "wparam", "hwnd", "hwnd")
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_SETTOOLTIPS, 0, $hToolTip))
EndIf
EndFunc
Func _GUICtrlListView_SetUnicodeFormat($hWnd, $bUnicode)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETUNICODEFORMAT, $bUnicode)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETUNICODEFORMAT, $bUnicode, 0)
EndIf
EndFunc
Func _GUICtrlListView_SetView($hWnd, $iView)
Local $aView[5] = [$LV_VIEW_ICON, $LV_VIEW_DETAILS, $LV_VIEW_LIST, $LV_VIEW_SMALLICON, $LV_VIEW_TILE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETVIEW, $aView[$iView]) <> -1
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETVIEW, $aView[$iView], 0) <> -1
EndIf
EndFunc
Func _GUICtrlListView_SetWorkAreas($hWnd, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_SETWORKAREAS, 1, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_SETWORKAREAS, 1, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_SETWORKAREAS, 1, DllStructGetPtr($tRECT))
EndIf
EndFunc
Func _GUICtrlListView_SimpleSort($hWnd, ByRef $vSortSense, $iCol, $bToggleSense = True)
Local $iItemCount = _GUICtrlListView_GetItemCount($hWnd)
If $iItemCount Then
Local $iDescending = 0
If UBound($vSortSense) Then
$iDescending = $vSortSense[$iCol]
Else
$iDescending = $vSortSense
EndIf
Local $vSeparatorChar = Opt('GUIDataSeparatorChar')
Local $iColumnCount = _GUICtrlListView_GetColumnCount($hWnd)
Local Enum $iIndexValue = $iColumnCount, $iItemParam
Local $aListViewItems[$iItemCount][$iColumnCount + 2]
Local $aSelectedItems = StringSplit(_GUICtrlListView_GetSelectedIndices($hWnd), $vSeparatorChar)
Local $aCheckedItems = __GUICtrlListView_GetCheckedIndices($hWnd)
Local $sItemText, $iFocused = -1
For $i = 0 To $iItemCount - 1
If $iFocused = -1 Then
If _GUICtrlListView_GetItemFocused($hWnd, $i) Then $iFocused = $i
EndIf
_GUICtrlListView_SetItemSelected($hWnd, $i, False)
_GUICtrlListView_SetItemChecked($hWnd, $i, False)
For $j = 0 To $iColumnCount - 1
$sItemText = StringStripWS(_GUICtrlListView_GetItemText($hWnd, $i, $j), $STR_STRIPTRAILING)
If (StringIsFloat($sItemText) Or StringIsInt($sItemText)) Then
$aListViewItems[$i][$j] = Number($sItemText)
Else
$aListViewItems[$i][$j] = $sItemText
EndIf
Next
$aListViewItems[$i][$iIndexValue] = $i
$aListViewItems[$i][$iItemParam] = _GUICtrlListView_GetItemParam($hWnd, $i)
Next
_ArraySort($aListViewItems, $iDescending, 0, 0, $iCol)
For $i = 0 To $iItemCount - 1
For $j = 0 To $iColumnCount - 1
_GUICtrlListView_SetItemText($hWnd, $i, $aListViewItems[$i][$j], $j)
Next
_GUICtrlListView_SetItemParam($hWnd, $i, $aListViewItems[$i][$iItemParam])
For $j = 1 To $aSelectedItems[0]
If $aListViewItems[$i][$iIndexValue] = $aSelectedItems[$j] Then
If $aListViewItems[$i][$iIndexValue] = $iFocused Then
_GUICtrlListView_SetItemSelected($hWnd, $i, True, True)
Else
_GUICtrlListView_SetItemSelected($hWnd, $i, True)
EndIf
ExitLoop
EndIf
Next
For $j = 1 To $aCheckedItems[0]
If $aListViewItems[$i][$iIndexValue] = $aCheckedItems[$j] Then
_GUICtrlListView_SetItemChecked($hWnd, $i, True)
ExitLoop
EndIf
Next
Next
If $bToggleSense Then
If UBound($vSortSense) Then
$vSortSense[$iCol] = Not $iDescending
Else
$vSortSense = Not $iDescending
EndIf
EndIf
EndIf
EndFunc
Func __GUICtrlListView_Sort($nItem1, $nItem2, $hWnd)
Local $iIndex, $sVal1, $sVal2, $nResult
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
$iIndex = $x
ExitLoop
EndIf
Next
If $__g_aListViewSortInfo[$iIndex][3] = $__g_aListViewSortInfo[$iIndex][4] Then
If Not $__g_aListViewSortInfo[$iIndex][7] Then
$__g_aListViewSortInfo[$iIndex][5] *= -1
$__g_aListViewSortInfo[$iIndex][7] = 1
EndIf
Else
$__g_aListViewSortInfo[$iIndex][7] = 1
EndIf
$__g_aListViewSortInfo[$iIndex][6] = $__g_aListViewSortInfo[$iIndex][3]
$sVal1 = _GUICtrlListView_GetItemText($hWnd, $nItem1, $__g_aListViewSortInfo[$iIndex][3])
$sVal2 = _GUICtrlListView_GetItemText($hWnd, $nItem2, $__g_aListViewSortInfo[$iIndex][3])
If $__g_aListViewSortInfo[$iIndex][8] Then
If (StringIsFloat($sVal1) Or StringIsInt($sVal1)) Then $sVal1 = Number($sVal1)
If (StringIsFloat($sVal2) Or StringIsInt($sVal2)) Then $sVal2 = Number($sVal2)
EndIf
$nResult = 0
If $sVal1 < $sVal2 Then
$nResult = -1
ElseIf $sVal1 > $sVal2 Then
$nResult = 1
EndIf
$nResult = $nResult * $__g_aListViewSortInfo[$iIndex][5]
Return $nResult
EndFunc
Func _GUICtrlListView_SortItems($hWnd, $iCol)
Local $iRet, $iIndex, $pFunction, $hHeader, $iFormat
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
$iIndex = $x
ExitLoop
EndIf
Next
$pFunction = DllCallbackGetPtr($__g_aListViewSortInfo[$iIndex][2])
$__g_aListViewSortInfo[$iIndex][3] = $iCol
$__g_aListViewSortInfo[$iIndex][7] = 0
$__g_aListViewSortInfo[$iIndex][4] = $__g_aListViewSortInfo[$iIndex][6]
$iRet = _SendMessage($hWnd, $LVM_SORTITEMSEX, $hWnd, $pFunction, 0, "hwnd", "ptr")
If $iRet <> 0 Then
If $__g_aListViewSortInfo[$iIndex][9] Then
$hHeader = $__g_aListViewSortInfo[$iIndex][10]
For $x = 0 To _GUICtrlHeader_GetItemCount($hHeader) - 1
$iFormat = _GUICtrlHeader_GetItemFormat($hHeader, $x)
If BitAND($iFormat, $HDF_SORTDOWN) Then
_GUICtrlHeader_SetItemFormat($hHeader, $x, BitXOR($iFormat, $HDF_SORTDOWN))
ElseIf BitAND($iFormat, $HDF_SORTUP) Then
_GUICtrlHeader_SetItemFormat($hHeader, $x, BitXOR($iFormat, $HDF_SORTUP))
EndIf
Next
$iFormat = _GUICtrlHeader_GetItemFormat($hHeader, $iCol)
If $__g_aListViewSortInfo[$iIndex][5] = 1 Then
_GUICtrlHeader_SetItemFormat($hHeader, $iCol, BitOR($iFormat, $HDF_SORTUP))
Else
_GUICtrlHeader_SetItemFormat($hHeader, $iCol, BitOR($iFormat, $HDF_SORTDOWN))
EndIf
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func __GUICtrlListView_StateImageMaskToIndex($iMask)
Return BitShift(BitAND($iMask, $LVIS_STATEIMAGEMASK), 12)
EndFunc
Func _GUICtrlListView_SubItemHitTest($hWnd, $iX = -1, $iY = -1)
Local $iTest, $tTest, $pMemory, $tMemMap, $iFlags, $aTest[11]
If $iX = -1 Then $iX = _WinAPI_GetMousePosX(True, $hWnd)
If $iY = -1 Then $iY = _WinAPI_GetMousePosY(True, $hWnd)
$tTest = DllStructCreate($tagLVHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_SUBITEMHITTEST, 0, $tTest, 0, "wparam", "struct*")
Else
$iTest = DllStructGetSize($tTest)
$pMemory = _MemInit($hWnd, $iTest, $tMemMap)
_MemWrite($tMemMap, $tTest)
_SendMessage($hWnd, $LVM_SUBITEMHITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tTest, $iTest)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_SUBITEMHITTEST, 0, DllStructGetPtr($tTest))
EndIf
$iFlags = DllStructGetData($tTest, "Flags")
$aTest[0] = DllStructGetData($tTest, "Item")
$aTest[1] = DllStructGetData($tTest, "SubItem")
$aTest[2] = BitAND($iFlags, $LVHT_NOWHERE) <> 0
$aTest[3] = BitAND($iFlags, $LVHT_ONITEMICON) <> 0
$aTest[4] = BitAND($iFlags, $LVHT_ONITEMLABEL) <> 0
$aTest[5] = BitAND($iFlags, $LVHT_ONITEMSTATEICON) <> 0
$aTest[6] = BitAND($iFlags, $LVHT_ONITEM) <> 0
$aTest[7] = BitAND($iFlags, $LVHT_ABOVE) <> 0
$aTest[8] = BitAND($iFlags, $LVHT_BELOW) <> 0
$aTest[9] = BitAND($iFlags, $LVHT_TOLEFT) <> 0
$aTest[10] = BitAND($iFlags, $LVHT_TORIGHT) <> 0
Return $aTest
EndFunc
Func _GUICtrlListView_UnRegisterSortCallBack($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
DllCallbackFree($__g_aListViewSortInfo[$x][2])
__GUICtrlListView_ArrayDelete($__g_aListViewSortInfo, $x)
$__g_aListViewSortInfo[0][0] -= 1
ExitLoop
EndIf
Next
EndFunc
Global $__g_hTTLastWnd
Global Const $_TOOLTIPCONSTANTS_ClassName = "tooltips_class32"
Global Const $_TT_ghTTDefaultStyle = BitOR($TTS_ALWAYSTIP, $TTS_NOPREFIX)
Global Const $tagNMTTDISPINFO = $tagNMHDR & ";ptr pText;wchar aText[80];ptr Instance;uint Flags;lparam Param"
Global Const $tagTOOLINFO = "uint Size;uint Flags;hwnd hWnd;uint_ptr ID;" & $tagRECT & ";handle hInst;ptr Text;lparam Param;ptr Reserved"
Global Const $tagTTGETTITLE = "dword Size;uint Bitmap;uint TitleMax;ptr Title"
Global Const $tagTTHITTESTINFO = "hwnd Tool;" & $tagPOINT & ";" & $tagTOOLINFO
Func _GUIToolTip_Activate($hWnd)
_SendMessage($hWnd, $TTM_ACTIVATE, True)
EndFunc
Func _GUIToolTip_AddTool($hTool, $hWnd, $sText, $iID = 0, $iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0, $iFlags = Default, $iParam = 0)
Local $iBuffer, $tBuffer, $pBuffer
If $iFlags = Default Then $iFlags = BitOR($TTF_SUBCLASS, $TTF_IDISHWND)
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
$pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "Flags", $iFlags)
DllStructSetData($tToolInfo, "hWnd", $hWnd)
DllStructSetData($tToolInfo, "ID", $iID)
DllStructSetData($tToolInfo, "Left", $iLeft)
DllStructSetData($tToolInfo, "Top", $iTop)
DllStructSetData($tToolInfo, "Right", $iRight)
DllStructSetData($tToolInfo, "Bottom", $iBottom)
DllStructSetData($tToolInfo, "Param", $iParam)
Local $iRet
If _WinAPI_InProcess($hTool, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", $pBuffer)
$iRet = _SendMessage($hTool, $TTM_ADDTOOLW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hTool, $iToolInfo + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tToolInfo, "Text", -1)
EndIf
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
$iRet = _SendMessage($hTool, $TTM_ADDTOOLW, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUIToolTip_AdjustRect($hWnd, ByRef $tRECT, $bLarger = True)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
_SendMessage($hWnd, $TTM_ADJUSTRECT, $bLarger, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT)
_SendMessage($hWnd, $TTM_ADJUSTRECT, $bLarger, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Return $tRECT
EndFunc
Func _GUIToolTip_BitsToTTF($iFlags)
Local $iN = ""
If BitAND($iFlags, $TTF_IDISHWND) <> 0 Then $iN &= "TTF_IDISHWND,"
If BitAND($iFlags, $TTF_CENTERTIP) <> 0 Then $iN &= "TTF_CENTERTIP,"
If BitAND($iFlags, $TTF_RTLREADING) <> 0 Then $iN &= "TTF_RTLREADING,"
If BitAND($iFlags, $TTF_SUBCLASS) <> 0 Then $iN &= "TTF_SUBCLASS,"
If BitAND($iFlags, $TTF_TRACK) <> 0 Then $iN &= "TTF_TRACK,"
If BitAND($iFlags, $TTF_ABSOLUTE) <> 0 Then $iN &= "TTF_ABSOLUTE,"
If BitAND($iFlags, $TTF_TRANSPARENT) <> 0 Then $iN &= "TTF_TRANSPARENT,"
If BitAND($iFlags, $TTF_PARSELINKS) <> 0 Then $iN &= "TTF_PARSELINKS,"
Return StringTrimRight($iN, 1)
EndFunc
Func _GUIToolTip_Create($hWnd, $iStyle = $_TT_ghTTDefaultStyle)
Return _WinAPI_CreateWindowEx(0, $_TOOLTIPCONSTANTS_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd)
EndFunc
Func _GUIToolTip_Deactivate($hWnd)
_SendMessage($hWnd, $TTM_ACTIVATE, False)
EndFunc
Func _GUIToolTip_DelTool($hWnd, $hTool, $iID = 0)
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "ID", $iID)
DllStructSetData($tToolInfo, "hWnd", $hTool)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
_SendMessage($hWnd, $TTM_DELTOOLW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo, $tMemMap)
_MemWrite($tMemMap, $tToolInfo)
_SendMessage($hWnd, $TTM_DELTOOLW, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUIToolTip_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $_TOOLTIPCONSTANTS_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Else
Return SetError(1, 1, False)
EndIf
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUIToolTip_EnumTools($hWnd, $iIndex)
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
Local $bResult
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
$bResult = _SendMessage($hWnd, $TTM_ENUMTOOLSW, $iIndex, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo, $tMemMap)
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
$bResult = _SendMessage($hWnd, $TTM_ENUMTOOLSW, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tToolInfo, $iToolInfo)
_MemFree($tMemMap)
EndIf
Return _GUIToolTip_ToolToArray($hWnd, $tToolInfo, $bResult = True)
EndFunc
Func _GUIToolTip_GetBubbleHeight($hWnd, $hTool, $iID, $iFlags = Default)
If $iFlags = Default Then $iFlags = BitOR($TTF_IDISHWND, $TTF_SUBCLASS)
Return _WinAPI_HiWord(_GUIToolTip_GetBubbleSize($hWnd, $hTool, $iID, $iFlags))
EndFunc
Func _GUIToolTip_GetBubbleSize($hWnd, $hTool, $iID, $iFlags = Default)
If $iFlags = Default Then $iFlags = BitOR($TTF_IDISHWND, $TTF_SUBCLASS)
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "hWnd", $hTool)
DllStructSetData($tToolInfo, "ID", $iID)
DllStructSetData($tToolInfo, "Flags", $iFlags)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
$iRet = _SendMessage($hWnd, $TTM_GETBUBBLESIZE, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo, $tMemMap)
_MemWrite($tMemMap, $tToolInfo)
$iRet = _SendMessage($hWnd, $TTM_GETBUBBLESIZE, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func _GUIToolTip_GetBubbleWidth($hWnd, $hTool, $iID, $iFlags = Default)
If $iFlags = Default Then $iFlags = BitOR($TTF_IDISHWND, $TTF_SUBCLASS)
Return _WinAPI_LoWord(_GUIToolTip_GetBubbleSize($hWnd, $hTool, $iID, $iFlags))
EndFunc
Func _GUIToolTip_GetCurrentTool($hWnd)
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
Local $bResult
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
$bResult = _SendMessage($hWnd, $TTM_GETCURRENTTOOLW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo, $tMemMap)
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
$bResult = _SendMessage($hWnd, $TTM_GETCURRENTTOOLW, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tToolInfo, $iToolInfo)
_MemFree($tMemMap)
EndIf
Return _GUIToolTip_ToolToArray($hWnd, $tToolInfo, $bResult = True)
EndFunc
Func _GUIToolTip_GetDelayTime($hWnd, $iDuration)
Return _SendMessage($hWnd, $TTM_GETDELAYTIME, $iDuration)
EndFunc
Func _GUIToolTip_GetMargin($hWnd)
Local $aMargin[4]
Local $tRECT = _GUIToolTip_GetMarginEx($hWnd)
$aMargin[0] = DllStructGetData($tRECT, "Left")
$aMargin[1] = DllStructGetData($tRECT, "Top")
$aMargin[2] = DllStructGetData($tRECT, "Right")
$aMargin[3] = DllStructGetData($tRECT, "Bottom")
Return $aMargin
EndFunc
Func _GUIToolTip_GetMarginEx($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
_SendMessage($hWnd, $TTM_GETMARGIN, 0, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $TTM_GETMARGIN, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Return $tRECT
EndFunc
Func _GUIToolTip_GetMaxTipWidth($hWnd)
Return _SendMessage($hWnd, $TTM_GETMAXTIPWIDTH)
EndFunc
Func _GUIToolTip_GetText($hWnd, $hTool, $iID)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "hWnd", $hTool)
DllStructSetData($tToolInfo, "ID", $iID)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $TTM_GETTEXTW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo + 4096, $tMemMap)
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
_SendMessage($hWnd, $TTM_GETTEXTW, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pText, $tBuffer, 81)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUIToolTip_GetTipBkColor($hWnd)
Return _SendMessage($hWnd, $TTM_GETTIPBKCOLOR)
EndFunc
Func _GUIToolTip_GetTipTextColor($hWnd)
Return _SendMessage($hWnd, $TTM_GETTIPTEXTCOLOR)
EndFunc
Func _GUIToolTip_GetTitleBitMap($hWnd)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $tTitle = DllStructCreate($tagTTGETTITLE)
Local $iTitle = DllStructGetSize($tTitle)
DllStructSetData($tTitle, "TitleMax", DllStructGetSize($tBuffer))
DllStructSetData($tTitle, "Size", $iTitle)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
DllStructSetData($tTitle, "Title", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $TTM_GETTITLE, 0, $tTitle, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iTitle + 4096, $tMemMap)
Local $pText = $pMemory + $iTitle
DllStructSetData($tTitle, "Title", $pText)
_MemWrite($tMemMap, $tTitle, $pMemory, $iTitle)
_SendMessage($hWnd, $TTM_GETTITLE, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pText, $tBuffer, 4096)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tTitle, "Bitmap")
EndFunc
Func _GUIToolTip_GetTitleText($hWnd)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $tTitle = DllStructCreate($tagTTGETTITLE)
Local $iTitle = DllStructGetSize($tTitle)
DllStructSetData($tTitle, "TitleMax", DllStructGetSize($tBuffer))
DllStructSetData($tTitle, "Size", $iTitle)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
DllStructSetData($tTitle, "Title", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $TTM_GETTITLE, 0, $tTitle, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iTitle + 4096, $tMemMap)
Local $pText = $pMemory + $iTitle
DllStructSetData($tTitle, "Title", $pText)
_MemWrite($tMemMap, $tTitle, $pMemory, $iTitle)
_SendMessage($hWnd, $TTM_GETTITLE, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pText, $tBuffer, 4096)
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUIToolTip_GetToolCount($hWnd)
Return _SendMessage($hWnd, $TTM_GETTOOLCOUNT)
EndFunc
Func _GUIToolTip_GetToolInfo($hWnd, $hTool, $iID)
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "hWnd", $hTool)
DllStructSetData($tToolInfo, "ID", $iID)
Local $bResult
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
$bResult = _SendMessage($hWnd, $TTM_GETTOOLINFOW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo, $tMemMap)
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
$bResult = _SendMessage($hWnd, $TTM_GETTOOLINFOW, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tToolInfo, $iToolInfo)
_MemFree($tMemMap)
EndIf
Return _GUIToolTip_ToolToArray($hWnd, $tToolInfo, $bResult = True)
EndFunc
Func _GUIToolTip_HitTest($hWnd, $hTool, $iX, $iY)
Local $tHitTest = DllStructCreate($tagTTHITTESTINFO)
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tHitTest, "Tool", $hTool)
DllStructSetData($tHitTest, "X", $iX)
DllStructSetData($tHitTest, "Y", $iY)
DllStructSetData($tHitTest, "Size", $iToolInfo)
Local $bResult
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
$bResult = _SendMessage($hWnd, $TTM_HITTESTW, 0, $tHitTest, 0, "wparam", "struct*")
Else
Local $iHitTest = DllStructGetSize($tHitTest)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iHitTest, $tMemMap)
_MemWrite($tMemMap, $tHitTest, $pMemory, $iHitTest)
$bResult = _SendMessage($hWnd, $TTM_HITTESTW, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tHitTest, $iHitTest)
_MemFree($tMemMap)
EndIf
DllStructSetData($tToolInfo, "Size", DllStructGetData($tHitTest, "Size"))
DllStructSetData($tToolInfo, "Flags", DllStructGetData($tHitTest, "Flags"))
DllStructSetData($tToolInfo, "hWnd", DllStructGetData($tHitTest, "hWnd"))
DllStructSetData($tToolInfo, "ID", DllStructGetData($tHitTest, "ID"))
DllStructSetData($tToolInfo, "Left", DllStructGetData($tHitTest, "Left"))
DllStructSetData($tToolInfo, "Top", DllStructGetData($tHitTest, "Top"))
DllStructSetData($tToolInfo, "Right", DllStructGetData($tHitTest, "Right"))
DllStructSetData($tToolInfo, "Bottom", DllStructGetData($tHitTest, "Bottom"))
DllStructSetData($tToolInfo, "hInst", DllStructGetData($tHitTest, "hInst"))
DllStructSetData($tToolInfo, "Param", DllStructGetData($tHitTest, "Param"))
Return _GUIToolTip_ToolToArray($hWnd, $tToolInfo, $bResult = True)
EndFunc
Func _GUIToolTip_NewToolRect($hWnd, $hTool, $iID, $iLeft, $iTop, $iRight, $iBottom)
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "hwnd", $hTool)
DllStructSetData($tToolInfo, "ID", $iID)
DllStructSetData($tToolInfo, "Left", $iLeft)
DllStructSetData($tToolInfo, "Top", $iTop)
DllStructSetData($tToolInfo, "Right", $iRight)
DllStructSetData($tToolInfo, "Bottom", $iBottom)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
_SendMessage($hWnd, $TTM_NEWTOOLRECTW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo, $tMemMap)
_MemWrite($tMemMap, $tToolInfo)
_SendMessage($hWnd, $TTM_NEWTOOLRECTW, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUIToolTip_Pop($hWnd)
_SendMessage($hWnd, $TTM_POP)
EndFunc
Func _GUIToolTip_PopUp($hWnd)
_SendMessage($hWnd, $TTM_POPUP)
EndFunc
Func _GUIToolTip_SetDelayTime($hWnd, $iDuration, $iTime)
_SendMessage($hWnd, $TTM_SETDELAYTIME, $iDuration, $iTime)
EndFunc
Func _GUIToolTip_SetMargin($hWnd, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
_SendMessage($hWnd, $TTM_SETMARGIN, 0, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT)
_SendMessage($hWnd, $TTM_SETMARGIN, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUIToolTip_SetMaxTipWidth($hWnd, $iWidth)
Return _SendMessage($hWnd, $TTM_SETMAXTIPWIDTH, 0, $iWidth)
EndFunc
Func _GUIToolTip_SetTipBkColor($hWnd, $iColor)
_SendMessage($hWnd, $TTM_SETTIPBKCOLOR, $iColor)
EndFunc
Func _GUIToolTip_SetTipTextColor($hWnd, $iColor)
_SendMessage($hWnd, $TTM_SETTIPTEXTCOLOR, $iColor)
EndFunc
Func _GUIToolTip_SetTitle($hWnd, $sTitle, $iIcon = 0)
Local $iBuffer = StringLen($sTitle) + 1
Local $tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
DllStructSetData($tBuffer, "Text", $sTitle)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
$iRet = _SendMessage($hWnd, $TTM_SETTITLEW, $iIcon, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer)
$iRet = _SendMessage($hWnd, $TTM_SETTITLEW, $iIcon, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUIToolTip_SetToolInfo($hWnd, $sText, $iID = 0, $iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0, $iFlags = Default, $iParam = 0)
If $iFlags = Default Then $iFlags = BitOR($TTF_SUBCLASS, $TTF_IDISHWND)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "Flags", $iFlags)
DllStructSetData($tToolInfo, "hWnd", $hWnd)
DllStructSetData($tToolInfo, "ID", $iID)
DllStructSetData($tToolInfo, "Left", $iLeft)
DllStructSetData($tToolInfo, "Top", $iTop)
DllStructSetData($tToolInfo, "Right", $iRight)
DllStructSetData($tToolInfo, "Bottom", $iBottom)
DllStructSetData($tToolInfo, "Param", $iParam)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $TTM_SETTOOLINFOW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo + 4096, $tMemMap)
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
_MemWrite($tMemMap, $pText, $tBuffer, 4096)
_SendMessage($hWnd, $TTM_SETTOOLINFOW, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUIToolTip_SetWindowTheme($hWnd, $sStyle)
Local $tBuffer = _WinAPI_MultiByteToWideChar($sStyle)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
_SendMessage($hWnd, $TTM_SETWINDOWTHEME, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, 4096, $tMemMap)
_MemWrite($tMemMap, $tBuffer)
_SendMessage($hWnd, $TTM_SETWINDOWTHEME, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUIToolTip_ToolExists($hWnd)
Return _SendMessage($hWnd, $TTM_GETCURRENTTOOL) <> 0
EndFunc
Func _GUIToolTip_ToolToArray($hWnd, ByRef $tToolInfo, $iError)
Local $aTool[10]
$aTool[0] = DllStructGetData($tToolInfo, "Flags")
$aTool[1] = DllStructGetData($tToolInfo, "hWnd")
$aTool[2] = DllStructGetData($tToolInfo, "ID")
$aTool[3] = DllStructGetData($tToolInfo, "Left")
$aTool[4] = DllStructGetData($tToolInfo, "Top")
$aTool[5] = DllStructGetData($tToolInfo, "Right")
$aTool[6] = DllStructGetData($tToolInfo, "Bottom")
$aTool[7] = DllStructGetData($tToolInfo, "hInst")
$aTool[8] = _GUIToolTip_GetText($hWnd, $aTool[1], $aTool[2])
$aTool[9] = DllStructGetData($tToolInfo, "Param")
Return SetError($iError, 0, $aTool)
EndFunc
Func _GUIToolTip_TrackActivate($hWnd, $bActivate = True, $hTool = 0, $iID = 0)
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "hWnd", $hTool)
DllStructSetData($tToolInfo, "ID", $iID)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
_SendMessage($hWnd, $TTM_TRACKACTIVATE, $bActivate, $tToolInfo, 0, "wparam", "struct*")
Else
$iToolInfo = DllStructGetSize($tToolInfo)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo, $tMemMap)
_MemWrite($tMemMap, $tToolInfo)
_SendMessage($hWnd, $TTM_TRACKACTIVATE, $bActivate, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Func _GUIToolTip_TrackPosition($hWnd, $iX, $iY)
_SendMessage($hWnd, $TTM_TRACKPOSITION, 0, _WinAPI_MakeLong($iX, $iY))
EndFunc
Func _GUIToolTip_Update($hWnd)
_SendMessage($hWnd, $TTM_UPDATE)
EndFunc
Func _GUIToolTip_UpdateTipText($hWnd, $hTool, $iID, $sText)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Local $tToolInfo = DllStructCreate($tagTOOLINFO)
Local $iToolInfo = DllStructGetSize($tToolInfo)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tToolInfo, "Size", $iToolInfo)
DllStructSetData($tToolInfo, "hWnd", $hTool)
DllStructSetData($tToolInfo, "ID", $iID)
If _WinAPI_InProcess($hWnd, $__g_hTTLastWnd) Then
DllStructSetData($tToolInfo, "Text", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $TTM_UPDATETIPTEXTW, 0, $tToolInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iToolInfo + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iToolInfo
DllStructSetData($tToolInfo, "Text", $pText)
_MemWrite($tMemMap, $tToolInfo, $pMemory, $iToolInfo)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
_SendMessage($hWnd, $TTM_UPDATETIPTEXTW, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
EndFunc
Global Const $PROV_RSA_FULL = 0x1
Global Const $PROV_RSA_AES = 24
Global Const $CRYPT_VERIFYCONTEXT = 0xF0000000
Global Const $HP_HASHSIZE = 0x0004
Global Const $HP_HASHVAL = 0x0002
Global Const $CRYPT_EXPORTABLE = 0x00000001
Global Const $CRYPT_USERDATA = 1
Global Const $CALG_MD2 = 0x00008001
Global Const $CALG_MD4 = 0x00008002
Global Const $CALG_MD5 = 0x00008003
Global Const $CALG_SHA1 = 0x00008004
Global Const $CALG_3DES = 0x00006603
Global Const $CALG_AES_128 = 0x0000660e
Global Const $CALG_AES_192 = 0x0000660f
Global Const $CALG_AES_256 = 0x00006610
Global Const $CALG_DES = 0x00006601
Global Const $CALG_RC2 = 0x00006602
Global Const $CALG_RC4 = 0x00006801
Global Const $CALG_USERKEY = 0
Global Const $KP_ALGID = 0x00000007
Global $__g_aCryptInternalData[3]
Func _Crypt_Startup()
If __Crypt_RefCount() = 0 Then
Local $hAdvapi32 = DllOpen("Advapi32.dll")
If $hAdvapi32 = -1 Then Return SetError(1, 0, False)
__Crypt_DllHandleSet($hAdvapi32)
Local $iProviderID = $PROV_RSA_AES
Local $aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptAcquireContext", "handle*", 0, "ptr", 0, "ptr", 0, "dword", $iProviderID, "dword", $CRYPT_VERIFYCONTEXT)
If @error Or Not $aRet[0] Then
Local $iError = @error + 10, $iExtended = @extended
DllClose(__Crypt_DllHandle())
Return SetError($iError, $iExtended, False)
Else
__Crypt_ContextSet($aRet[1])
EndIf
EndIf
__Crypt_RefCountInc()
Return True
EndFunc
Func _Crypt_Shutdown()
__Crypt_RefCountDec()
If __Crypt_RefCount() = 0 Then
DllCall(__Crypt_DllHandle(), "bool", "CryptReleaseContext", "handle", __Crypt_Context(), "dword", 0)
DllClose(__Crypt_DllHandle())
EndIf
EndFunc
Func _Crypt_DeriveKey($vPassword, $iAlgID, $iHashAlgID = $CALG_MD5)
Local $aRet = 0,  $hBuff = 0, $hCryptHash = 0,  $iError = 0, $iExtended = 0,  $vReturn = 0
_Crypt_Startup()
Do
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptCreateHash", "handle", __Crypt_Context(), "uint", $iHashAlgID, "ptr", 0, "dword", 0, "handle*", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 10
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$hCryptHash = $aRet[5]
$hBuff = DllStructCreate("byte[" & BinaryLen($vPassword) & "]")
DllStructSetData($hBuff, 1, $vPassword)
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptHashData", "handle", $hCryptHash, "struct*", $hBuff, "dword", DllStructGetSize($hBuff), "dword", $CRYPT_USERDATA)
If @error Or Not $aRet[0] Then
$iError = @error + 20
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptDeriveKey", "handle", __Crypt_Context(), "uint", $iAlgID, "handle", $hCryptHash, "dword", $CRYPT_EXPORTABLE, "handle*", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$vReturn = $aRet[5]
Until True
If $hCryptHash <> 0 Then DllCall(__Crypt_DllHandle(), "bool", "CryptDestroyHash", "handle", $hCryptHash)
Return SetError($iError, $iExtended, $vReturn)
EndFunc
Func _Crypt_DestroyKey($hCryptKey)
Local $aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptDestroyKey", "handle", $hCryptKey)
Local $iError = @error, $iExtended = @extended
_Crypt_Shutdown()
If $iError Or Not $aRet[0] Then
Return SetError($iError + 10, $iExtended, False)
Else
Return True
EndIf
EndFunc
Func _Crypt_EncryptData($vData, $vCryptKey, $iAlgID, $bFinal = True)
Switch $iAlgID
Case $CALG_USERKEY
Local $iCalgUsed = __Crypt_GetCalgFromCryptKey($vCryptKey)
If @error Then Return SetError(@error, -1, @extended)
If $iCalgUsed = $CALG_RC4 Then ContinueCase
Case $CALG_RC4
If BinaryLen($vData) = 0 Then Return SetError(0, 0, Binary(''))
EndSwitch
Local $iReqBuffSize = 0,  $aRet = 0,  $hBuff = 0,  $iError = 0, $iExtended = 0,  $vReturn = 0
_Crypt_Startup()
Do
If $iAlgID <> $CALG_USERKEY Then
$vCryptKey = _Crypt_DeriveKey($vCryptKey, $iAlgID)
If @error Then
$iError = @error + 100
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
EndIf
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptEncrypt", "handle", $vCryptKey, "handle", 0, "bool", $bFinal, "dword", 0, "ptr", 0,  "dword*", BinaryLen($vData), "dword", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 20
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$iReqBuffSize = $aRet[6]
$hBuff = DllStructCreate("byte[" & $iReqBuffSize + 1 & "]")
DllStructSetData($hBuff, 1, $vData)
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptEncrypt", "handle", $vCryptKey, "handle", 0, "bool", $bFinal, "dword", 0, "struct*", $hBuff,  "dword*", BinaryLen($vData), "dword", DllStructGetSize($hBuff) - 1)
If @error Or Not $aRet[0] Then
$iError = @error + 30
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$vReturn = BinaryMid(DllStructGetData($hBuff, 1), 1, $iReqBuffSize)
Until True
If $iAlgID <> $CALG_USERKEY Then _Crypt_DestroyKey($vCryptKey)
_Crypt_Shutdown()
Return SetError($iError, $iExtended, $vReturn)
EndFunc
Func _Crypt_DecryptData($vData, $vCryptKey, $iAlgID, $bFinal = True)
Switch $iAlgID
Case $CALG_USERKEY
Local $iCalgUsed = __Crypt_GetCalgFromCryptKey($vCryptKey)
If @error Then Return SetError(@error, -1, @extended)
If $iCalgUsed = $CALG_RC4 Then ContinueCase
Case $CALG_RC4
If BinaryLen($vData) = 0 Then Return SetError(0, 0, Binary(''))
EndSwitch
Local $aRet = 0,  $hBuff = 0, $hTempStruct = 0,  $iError = 0, $iExtended = 0, $iPlainTextSize = 0,  $vReturn = 0
_Crypt_Startup()
Do
If $iAlgID <> $CALG_USERKEY Then
$vCryptKey = _Crypt_DeriveKey($vCryptKey, $iAlgID)
If @error Then
$iError = @error + 100
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
EndIf
$hBuff = DllStructCreate("byte[" & BinaryLen($vData) + 1000 & "]")
If BinaryLen($vData) > 0 Then DllStructSetData($hBuff, 1, $vData)
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptDecrypt", "handle", $vCryptKey, "handle", 0, "bool", $bFinal, "dword", 0, "struct*", $hBuff, "dword*", BinaryLen($vData))
If @error Or Not $aRet[0] Then
$iError = @error + 20
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$iPlainTextSize = $aRet[6]
$hTempStruct = DllStructCreate("byte[" & $iPlainTextSize + 1 & "]", DllStructGetPtr($hBuff))
$vReturn = BinaryMid(DllStructGetData($hTempStruct, 1), 1, $iPlainTextSize)
Until True
If $iAlgID <> $CALG_USERKEY Then _Crypt_DestroyKey($vCryptKey)
_Crypt_Shutdown()
Return SetError($iError, $iExtended, $vReturn)
EndFunc
Func _Crypt_HashData($vData, $iAlgID, $bFinal = True, $hCryptHash = 0)
Local $aRet = 0,  $hBuff = 0,  $iError = 0, $iExtended = 0, $iHashSize = 0,  $vReturn = 0
_Crypt_Startup()
Do
If $hCryptHash = 0 Then
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptCreateHash", "handle", __Crypt_Context(), "uint", $iAlgID, "ptr", 0, "dword", 0, "handle*", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 10
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$hCryptHash = $aRet[5]
EndIf
$hBuff = DllStructCreate("byte[" & BinaryLen($vData) & "]")
DllStructSetData($hBuff, 1, $vData)
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptHashData", "handle", $hCryptHash, "struct*", $hBuff, "dword", DllStructGetSize($hBuff), "dword", $CRYPT_USERDATA)
If @error Or Not $aRet[0] Then
$iError = @error + 20
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
If $bFinal Then
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hCryptHash, "dword", $HP_HASHSIZE, "dword*", 0, "dword*", 4, "dword", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$iHashSize = $aRet[3]
$hBuff = DllStructCreate("byte[" & $iHashSize & "]")
$aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGetHashParam", "handle", $hCryptHash, "dword", $HP_HASHVAL, "struct*", $hBuff, "dword*", DllStructGetSize($hBuff), "dword", 0)
If @error Or Not $aRet[0] Then
$iError = @error + 40
$iExtended = @extended
$vReturn = -1
ExitLoop
EndIf
$vReturn = DllStructGetData($hBuff, 1)
Else
$vReturn = $hCryptHash
EndIf
Until True
If $hCryptHash <> 0 And $bFinal Then DllCall(__Crypt_DllHandle(), "bool", "CryptDestroyHash", "handle", $hCryptHash)
_Crypt_Shutdown()
Return SetError($iError, $iExtended, $vReturn)
EndFunc
Func _Crypt_HashFile($sFilePath, $iAlgID)
Local $bTempData = 0,  $hFile = 0, $hHashObject = 0,  $iError = 0, $iExtended = 0,  $vReturn = 0
_Crypt_Startup()
Do
$hFile = FileOpen($sFilePath, $FO_BINARY)
If $hFile = -1 Then
$iError = 1
$vReturn = -1
ExitLoop
EndIf
Do
$bTempData = FileRead($hFile, 512 * 1024)
If @error Then
$vReturn = _Crypt_HashData($bTempData, $iAlgID, True, $hHashObject)
If @error Then
$iError = @error
$iExtended = @extended
$vReturn = -1
ExitLoop 2
EndIf
ExitLoop 2
Else
$hHashObject = _Crypt_HashData($bTempData, $iAlgID, False, $hHashObject)
If @error Then
$iError = @error + 100
$iExtended = @extended
$vReturn = -1
ExitLoop 2
EndIf
EndIf
Until False
Until True
_Crypt_Shutdown()
If $hFile <> -1 Then FileClose($hFile)
Return SetError($iError, $iExtended, $vReturn)
EndFunc
Func _Crypt_EncryptFile($sSourceFile, $sDestinationFile, $vCryptKey, $iAlgID)
Local $bTempData = 0,  $hInFile = 0, $hOutFile = 0,  $iError = 0, $iExtended = 0, $iFileSize = FileGetSize($sSourceFile), $iRead = 0,  $bReturn = True
_Crypt_Startup()
Do
If $iAlgID <> $CALG_USERKEY Then
$vCryptKey = _Crypt_DeriveKey($vCryptKey, $iAlgID)
If @error Then
$iError = @error
$iExtended = @extended
$bReturn = False
ExitLoop
EndIf
EndIf
$hInFile = FileOpen($sSourceFile, $FO_BINARY)
If @error Then
$iError = 2
$bReturn = False
ExitLoop
EndIf
$hOutFile = FileOpen($sDestinationFile, $FO_OVERWRITE + $FO_CREATEPATH + $FO_BINARY)
If @error Then
$iError = 3
$bReturn = False
ExitLoop
EndIf
Do
$bTempData = FileRead($hInFile, 1024 * 1024)
$iRead += BinaryLen($bTempData)
If $iRead = $iFileSize Then
$bTempData = _Crypt_EncryptData($bTempData, $vCryptKey, $CALG_USERKEY, True)
If @error Then
$iError = @error + 400
$iExtended = @extended
$bReturn = False
EndIf
FileWrite($hOutFile, $bTempData)
ExitLoop 2
Else
$bTempData = _Crypt_EncryptData($bTempData, $vCryptKey, $CALG_USERKEY, False)
If @error Then
$iError = @error + 500
$iExtended = @extended
$bReturn = False
ExitLoop 2
EndIf
FileWrite($hOutFile, $bTempData)
EndIf
Until False
Until True
If $iAlgID <> $CALG_USERKEY Then _Crypt_DestroyKey($vCryptKey)
_Crypt_Shutdown()
If $hInFile <> -1 Then FileClose($hInFile)
If $hOutFile <> -1 Then FileClose($hOutFile)
Return SetError($iError, $iExtended, $bReturn)
EndFunc
Func _Crypt_DecryptFile($sSourceFile, $sDestinationFile, $vCryptKey, $iAlgID)
Local $bTempData = 0,  $hInFile = 0, $hOutFile = 0,  $iError = 0, $iExtended = 0, $iFileSize = FileGetSize($sSourceFile), $iRead = 0,  $bReturn = True
_Crypt_Startup()
Do
If $iAlgID <> $CALG_USERKEY Then
$vCryptKey = _Crypt_DeriveKey($vCryptKey, $iAlgID)
If @error Then
$iError = @error
$iExtended = @extended
$bReturn = False
ExitLoop
EndIf
EndIf
$hInFile = FileOpen($sSourceFile, $FO_BINARY)
If @error Then
$iError = 2
$bReturn = False
ExitLoop
EndIf
$hOutFile = FileOpen($sDestinationFile, $FO_OVERWRITE + $FO_CREATEPATH + $FO_BINARY)
If @error Then
$iError = 3
$bReturn = False
ExitLoop
EndIf
Do
$bTempData = FileRead($hInFile, 1024 * 1024)
$iRead += BinaryLen($bTempData)
If $iRead = $iFileSize Then
$bTempData = _Crypt_DecryptData($bTempData, $vCryptKey, $CALG_USERKEY, True)
If @error Then
$iError = @error + 400
$iExtended = @extended
$bReturn = False
EndIf
FileWrite($hOutFile, $bTempData)
ExitLoop 2
Else
$bTempData = _Crypt_DecryptData($bTempData, $vCryptKey, $CALG_USERKEY, False)
If @error Then
$iError = @error + 500
$iExtended = @extended
$bReturn = False
ExitLoop 2
EndIf
FileWrite($hOutFile, $bTempData)
EndIf
Until False
Until True
If $iAlgID <> $CALG_USERKEY Then _Crypt_DestroyKey($vCryptKey)
_Crypt_Shutdown()
If $hInFile <> -1 Then FileClose($hInFile)
If $hOutFile <> -1 Then FileClose($hOutFile)
Return SetError($iError, $iExtended, $bReturn)
EndFunc
Func _Crypt_GenRandom($pBuffer, $iSize)
_Crypt_Startup()
Local $aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGenRandom", "handle", __Crypt_Context(), "dword", $iSize, "struct*", $pBuffer)
Local $iError = @error, $iExtended = @extended
_Crypt_Shutdown()
If $iError Or (Not $aRet[0]) Then
Return SetError($iError + 10, $iExtended, False)
Else
Return True
EndIf
EndFunc
Func __Crypt_RefCount()
Return $__g_aCryptInternalData[0]
EndFunc
Func __Crypt_RefCountInc()
$__g_aCryptInternalData[0] += 1
EndFunc
Func __Crypt_RefCountDec()
If $__g_aCryptInternalData[0] > 0 Then $__g_aCryptInternalData[0] -= 1
EndFunc
Func __Crypt_DllHandle()
Return $__g_aCryptInternalData[1]
EndFunc
Func __Crypt_DllHandleSet($hAdvapi32)
$__g_aCryptInternalData[1] = $hAdvapi32
EndFunc
Func __Crypt_Context()
Return $__g_aCryptInternalData[2]
EndFunc
Func __Crypt_ContextSet($hCryptContext)
$__g_aCryptInternalData[2] = $hCryptContext
EndFunc
Func __Crypt_GetCalgFromCryptKey($vCryptKey)
Local $tAlgId = DllStructCreate("uint;dword")
DllStructSetData($tAlgId, 2, 4)
Local $aRet = DllCall(__Crypt_DllHandle(), "bool", "CryptGetKeyParam", "handle", $vCryptKey, "dword", $KP_ALGID, "ptr", DllStructGetPtr($tAlgId, 1), "dword*", DllStructGetPtr($tAlgId, 2), "dword", 0)
If @error Or Not $aRet[0] Then
Return SetError(@error, @extended, $CRYPT_USERDATA)
Else
Return DllStructGetData($tAlgId, 1)
EndIf
EndFunc
Global $rgbaExt = GenerateRandom("", True)
Global $shExt = GenerateRandom("", True)
Global $clickExt = GenerateRandom("", True)
Global $scriptExt = GenerateRandom("", True)
Global $geteventExt = GenerateRandom("", True)
Global $moveawayExt = GenerateRandom("", True)
Global $replaceOfBotTitle = GenerateRandom("", False, Random(4, 10, 1), True)
Global $shellScriptInitFileName = GenerateRandom("", False, Random(4, 8, 1), True)
Global $clickDragFileName = GenerateRandom("", False, Random(4, 8, 1), True)
Global $replaceofBluestacks2name = GenerateRandom("", False, Random(4, 8, 1))
Global $replaceofBluestacksname = GenerateRandom("", False, Random(4, 8, 1))
Global $replaceOfDroid4xName = GenerateRandom("", False, Random(4, 8, 1))
Global $replaceofNoxname = GenerateRandom("", False, Random(4, 8, 1))
Global $replaceofLeapDroidname = GenerateRandom("", False, Random(4, 8, 1))
Global $overwatersReplace = GenerateRandom("", False, Random(4, 8, 1))
Global $zoomOutReplace = GenerateRandom("", False, Random(4, 8, 1))
Global $replaceOfMyBotFolder = GenerateRandom("", False, Random(4, 8, 1), True)
Global $pwToDecrypt = GenerateRandom("", False, Random(8, 15, 1), True, True)
CreateSecureMEVars(False)
Global Const $GAME_WIDTH = 860
Global Const $GAME_HEIGHT = 732
Global Const $DEFAULT_HEIGHT = 780
Global Const $DEFAULT_WIDTH = 860
Global Const $midOffsetY = Int(($DEFAULT_HEIGHT - 720) / 2)
Global Const $bottomOffsetY = $DEFAULT_HEIGHT - 720
Global $VILLAGE_OFFSET_X = 0
Global $VILLAGE_OFFSET_Y = 0
Global $CenterVillage[3] = [True, 0, 0]
Global $bMonitorHeight800orBelow = False
Global $ichkDisableSplash = 0
Global $debugSearchArea = 0, $debugOcr = 0, $debugRedArea = 0, $debugSetlog = 0, $debugDeadBaseImage = 0, $debugImageSave = 0, $debugWalls = 0, $debugBuildingPos = 0, $debugVillageSearchImages = 0
Global $debugAttackCSV = 0, $makeIMGCSV = 0
Global $debugMultilanguage = 0
Global $debugsetlogTrain = 0
Global $debugGetLocation = 0
Global $debugOCRdonate = 0
Global $debugAndroidEmbedded = 1
Global $debugWindowMessages = 0
Global Const $COLOR_ORANGE = 0xFF7700
Global Const $COLOR_ERROR = $COLOR_RED
Global Const $COLOR_WARNING = $COLOR_MAROON
Global Const $COLOR_INFO = $COLOR_BLUE
Global Const $COLOR_SUCCESS = 0x006600
Global Const $COLOR_SUCCESS1 = 0x009900
Global Const $COLOR_DEBUG = $COLOR_PURPLE
Global Const $COLOR_DEBUG1 = 0x7a00cc
Global Const $COLOR_DEBUG2 = 0xaa80ff
Global Const $COLOR_DEBUGS = $COLOR_MEDGRAY
Global Const $COLOR_ACTION = 0xFF8000
Global Const $COLOR_ACTION1 = 0xcc80ff
Global Const $bCapturePixel = True, $bNoCapturePixel = False
Global $Compiled
If @Compiled Then
$Compiled = @ScriptName & " Executable"
Else
$Compiled = @ScriptName & " Script"
EndIf
Global $hHBitmapTest = 0
Global $hBitmap
Global $hHBitmap
Global $hHBitmap2
Global Const $64Bit = StringInStr(@OSArch, "64") > 0
Global Const $HKLM = "HKLM" & ($64Bit ? "64" : "")
Global Const $Wow6432Node = ($64Bit ? "\Wow6432Node" : "")
GLobal $AndroidAutoAdjustConfig = True
Global $AndroidGamePackage = "com.supercell.clashofclans"
Global $AndroidGameClass = ".GameApp"
Global $AndroidEmbedEnabled = True
Global $AndroidEmbedded = False
Global $AndroidEmbeddedCtrlTarget[10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $AndroidEmbeddedRedraw = False
Global $AndroidShieldEnabled = True
Global $AndroidShieldPreWin8 = _WinAPI_GetVersion() < 6.2
Global $AndroidShieldStatus[5] = [Default, 0, 0, Default, Default]
Global $AndroidShieldDelay[4] = [0, 0, Default, Default]
Global $AndroidShieldForceDown = False
Global $AndroidShieldColor = $COLOR_WHITE
Global $AndroidShieldTransparency = 48
Global $AndroidActiveColor = $COLOR_BLACK
Global $AndroidActiveTransparency = 1
Global $AndroidInactiveColor = $COLOR_WHITE
Global $AndroidInactiveTransparency = 24
Global $AndroidBackgroundLaunchEnabled = False
Global $AndroidCheckTimeLagEnabled = True
Global $AndroidAdbAutoTerminate = 0
Global $AndroidAdbScreencapEnabled = True
Global $AndroidAdbScreencapPngEnabled = False
Global $AndroidAdbZoomoutEnabled = True
Global $AndroidAdbClickDragEnabled = True
Global $AndroidAdbInputEnabled = True
Global $AndroidAdbInputWordsCharLimit = 0
Global $AndroidAdbClickEnabled = False
Global $AndroidAdbClicksEnabled = False
Global $AndroidAdbClicksTroopDeploySize = 0
Global $AndroidAdbInstanceEnabled = True
Global $AndroidSuspendedEnabled = False
Global $NoFocusTampering = False
Global $__MEmu_Idx = 0
Global $__BS2_Idx = 1
Global $__BS_Idx = 2
Global $__KOPLAYER_Idx = 3
Global $__Droid4X_Idx = 4
GLobal $__LeapDroid_IDx = 5
Global $__Nox_Idx = 6
Global $__BlueStacks_SystemBar = 48
Global $__BlueStacks2Version_2_5_or_later = False
Global $__MEmu_Adjust_Width = 6
Global $__MEmu_ToolBar_Width = 45
Global $__MEmu_SystemBar = 36
Global $__MEmu_PhoneLayout = "0"
Global $__MEmu_Window[3][4] =  [  ["2.6.2",$DEFAULT_WIDTH + 48,$DEFAULT_HEIGHT + 26,40],  ["2.5.0",$DEFAULT_WIDTH + 51,$DEFAULT_HEIGHT + 24,40],  ["2.2.1",$DEFAULT_WIDTH + 51,$DEFAULT_HEIGHT + 24,45]  ]
Global $__Droid4X_Window[3][3] =  [  ["0.10.0",$DEFAULT_WIDTH +  6,$DEFAULT_HEIGHT + 53],  ["0.8.6" ,$DEFAULT_WIDTH + 10,$DEFAULT_HEIGHT + 50]  ]
Global $AndroidAppConfig[7][15] = [  ["MEmu",       "MEmu",          "MEmu ",                "[CLASS:subWin; INSTANCE:1]",       "",           $DEFAULT_WIDTH,     $DEFAULT_HEIGHT - 12,$DEFAULT_WIDTH + 51,$DEFAULT_HEIGHT + 24,0,             "127.0.0.1:21503",0+2+4+8+16+32         ,'# ',               'Microvirt Virtual Input',           0],  ["BlueStacks2","",              "BlueStacks ",          "[CLASS:BlueStacksApp; INSTANCE:1]","_ctl.Window",$DEFAULT_WIDTH,     $DEFAULT_HEIGHT - 48,$DEFAULT_WIDTH,     $DEFAULT_HEIGHT - 48,0,             "127.0.0.1:5555", 1    +8+16+32         ,'$ ',               'BlueStacks Virtual Touch',          0],  ["BlueStacks", "",              "BlueStacks App Player","[CLASS:BlueStacksApp; INSTANCE:1]","_ctl.Window",$DEFAULT_WIDTH,     $DEFAULT_HEIGHT - 48,$DEFAULT_WIDTH,     $DEFAULT_HEIGHT - 48,0,             "127.0.0.1:5555", 1    +8+16+32         ,'$ ',               'BlueStacks Virtual Touch',          0],  ["KOPLAYER",   "KOPLAYER",      "KOPLAYER",             "[CLASS:subWin; INSTANCE:1]",       "",           $DEFAULT_WIDTH,     $DEFAULT_HEIGHT - 48,$DEFAULT_WIDTH + 64,$DEFAULT_HEIGHT -  8,0,             "127.0.0.1:6555" ,0+2+4+8+16+32         ,'# ',               'ttVM Virtual Input',                0],  ["Droid4X",    "droid4x",       "Droid4X ",             "[CLASS:subWin; INSTANCE:1]",       "",           $DEFAULT_WIDTH,     $DEFAULT_HEIGHT - 48,$DEFAULT_WIDTH + 10,$DEFAULT_HEIGHT + 50,0,             "127.0.0.1:26944",0+2+4+8+16+32         ,'# ',               'droid4x Virtual Input',             0],  ["LeapDroid",  "vm1",           "Leapd",                "[CLASS:subWin; INSTANCE:1]",       "",           $DEFAULT_WIDTH,     $DEFAULT_HEIGHT - 48,$DEFAULT_WIDTH     ,$DEFAULT_HEIGHT - 48,0,             "emulator-5554",  1+    8+16+32         ,'# ',               'qwerty2',                           1],  ["Nox",        "nox",           "No",                   "[CLASS:Qt5QWindowIcon;INSTANCE:4]","",           $DEFAULT_WIDTH,     $DEFAULT_HEIGHT - 48,$DEFAULT_WIDTH +  4,$DEFAULT_HEIGHT - 10,0,             "127.0.0.1:62001",0+2+4+8+16+32         ,'# ',               '(nox Virtual Input|Android Input)',-1]  ]
Global $OnlyInstance = True
Global $FoundRunningAndroid = False
Global $FoundInstalledAndroid = False
Global $OpenAndroidActive = 0
Global $OpenAndroidActiveMaxTry = 3
Global $AndroidConfig = 0
Global $AndroidVersion
Global $Android
Global $AndroidInstance
Global $Title
Global $UpdateAndroidWindowTitle = False
Global $AppClassInstance
Global $AppPaneName
Global $AndroidClientWidth
Global $AndroidClientHeight
Global $AndroidWindowWidth
Global $AndroidWindowHeight
Global $ClientOffsetY
Global $AndroidAdbPath
Global $AndroidAdbDevice
Global $AndroidSupportFeature
Global $AndroidShellPrompt
Global $AndroidMouseDevice
Global $AndroidAdbScreencap
Global $AndroidAdbClick
Global $AndroidAdbInput
Global $AndroidAdbInstance
Global $AndroidAdbClickDrag
Global $AndroidEmbed
Global $AndroidEmbedMode
Global $AndroidBackgroundLaunch
Global $AndroidBackgroundLaunched
Func AndroidAdbClickSupported()
Return BitAND($AndroidSupportFeature, 4) = 4
EndFunc
Global $InitAndroidActive = False
Func InitAndroidConfig($bRestart = False)
If $bRestart = False Then
$Android = $AndroidAppConfig[$AndroidConfig][0]
$AndroidInstance = $AndroidAppConfig[$AndroidConfig][1]
$Title = $AndroidAppConfig[$AndroidConfig][2]
EndIf
$AppClassInstance = $AndroidAppConfig[$AndroidConfig][3]
$AppPaneName = $AndroidAppConfig[$AndroidConfig][4]
$AndroidClientWidth = $AndroidAppConfig[$AndroidConfig][5]
$AndroidClientHeight = $AndroidAppConfig[$AndroidConfig][6]
$AndroidWindowWidth = $AndroidAppConfig[$AndroidConfig][7]
$AndroidWindowHeight = $AndroidAppConfig[$AndroidConfig][8]
$ClientOffsetY = $AndroidAppConfig[$AndroidConfig][9]
$AndroidAdbPath = ""
$AndroidAdbDevice = $AndroidAppConfig[$AndroidConfig][10]
$AndroidSupportFeature = $AndroidAppConfig[$AndroidConfig][11]
$AndroidShellPrompt = $AndroidAppConfig[$AndroidConfig][12]
$AndroidMouseDevice = $AndroidAppConfig[$AndroidConfig][13]
$AndroidEmbedMode = $AndroidAppConfig[$AndroidConfig][14]
$AndroidAdbScreencap = $AndroidAdbScreencapEnabled = True And BitAND($AndroidSupportFeature, 2) = 2
$AndroidAdbClick = $AndroidAdbClickEnabled = True And AndroidAdbClickSupported()
$AndroidAdbInput = $AndroidAdbInputEnabled = True And BitAND($AndroidSupportFeature, 8) = 8
$AndroidAdbInstance = $AndroidAdbInstanceEnabled = True And BitAND($AndroidSupportFeature, 16) = 16
$AndroidAdbClickDrag = $AndroidAdbClickDragEnabled = True And BitAND($AndroidSupportFeature, 32) = 32
$AndroidEmbed = $AndroidEmbedEnabled = True And $AndroidEmbedMode > -1
$AndroidBackgroundLaunch = $AndroidBackgroundLaunchEnabled = True
$AndroidBackgroundLaunched = False
$UpdateAndroidWindowTitle = False
If $AndroidAdbScreencap And IsDeclared("chkBackground") Then
chkBackground()
EndIf
EndFunc
InitAndroidConfig()
Global $AndroidProgramPath = ""
Global $AndroidProgramFileVersionInfo = 0
Global $AndroidHasSystemBar = False
Global $AndroidClientWidth_Configured = 0
Global $AndroidClientHeight_Configured = 0
Global $AndroidLaunchWaitSec = 240
Global $AndroidAdbPid = 0
Global $AndroidAdbPrompt = "mybot.run:"
Global $AndroidPicturesPath = ""
Global $AndroidPicturesHostPath = ""
Global $AndroidPicturesHostFolder = $replaceOfMyBotFolder & "\"
Global $AndroidPicturesPathAutoConfig = True
Global $AndroidAdbAutoTerminateCount = 0
Global $AndroidAdbScreencapBuffer = DllStructCreate("byte[" & ($DEFAULT_WIDTH * $DEFAULT_HEIGHT * 4) & "]")
Global $AndroidAdbScreencapBufferPngHandle = 0
Global $AndroidAdbScreencapWaitAdbTimeout = 10000
Global $AndroidAdbScreencapWaitFileTimeout = 10000
Global $AndroidAdbScreencapTimer = 0
Global $AndroidAdbScreencapTimeoutMin = 200
Global $AndroidAdbScreencapTimeoutMax = 1000
Global $AndroidAdbScreencapTimeout = $AndroidAdbScreencapTimeoutMax
Global $AndroidAdbScreencapTimeoutDynamic = 3
Global $AndroidAdbScreencapWidth = 0
Global $AndroidAdbScreencapHeight = 0
Global $AndroidAdbClickGroup = 10
Global $AndroidAdbClickGroupDelay = 50
Global $AndroidAdbKeepClicksActive = False
Global $AndroidAdbClicks[1] = [-1]
Global $AndroidAdbStatsTotal[2][2] = [  [0,0],  [0,0]  ]
Global $AndroidAdbStatsLast[2][12]
$AndroidAdbStatsLast[0][0] = 0
$AndroidAdbStatsLast[0][1] = -1
$AndroidAdbStatsLast[1][0] = 0
$AndroidAdbStatsLast[1][1] = -1
Global $AndroidTimeLag[4]
Func InitAndroidTimeLag()
$AndroidTimeLag[0] = 0
$AndroidTimeLag[1] = 0
$AndroidTimeLag[2] = 0
$AndroidTimeLag[3] = 0
EndFunc
InitAndroidTimeLag()
Global $AndroidTimeLagThreshold = 5
Global $AndroidPageError[2]
Func InitAndroidPageError()
$AndroidPageError[0] = 0
$AndroidPageError[1] = 0
EndFunc
InitAndroidPageError()
Global $iAndroidRebootPageErrorCount = 5
Global $iAndroidRebootPageErrorPerMinutes = 10
Global $SkipFirstZoomout = False
Global $SearchZoomOutCounter[2] = [0, 1]
Global $ForceCapture = False
Global $ScreenshotTime = 0
Global $WinGetAndroidHandleActive = False
Global $HWnD = 0
Global $AndroidSvcPid = 0
Global $AndroidSuspended = False
Global $AndroidQueueReboot = False
Global $AndroidSuspendedTimer = 0
Global $InitAndroid = True
Global $frmBot = 0
Global $FrmBotMinimized = False
Global $iVillageName
Global $sProfilePath = @ScriptDir & "\Profiles"
Global $sPreset = @ScriptDir & "\Strategies"
Global $aTxtLogInitText[0][6] = [[]]
Global $hTimer_SetTime = 0
Global $hTimer_EmptyWorkingSetAndroid = 0
Global $iEmptyWorkingSetAndroid = 60000
Global $iEmptyWorkingSetBot = 60000
Global $hTimer_EmptyWorkingSetBot = 0
Global $bMoveDivider = False
Global $iMoveMouseOutBS = 0
Global $SilentSetLog = False
Global $DevMode = 0
If FileExists(@ScriptDir & "\EnableMBRDebug.txt") Then $DevMode = 1
Global $__BlueStacks_Version
Global $__BlueStacks_Path
Global $__Droid4X_Version
Global $__Droid4X_Path
Global $__MEmu_Path
Global $__LeapDroid_Path
Global $__Nox_Path
Global $__KOPLAYER_Path
Global $__VBoxManage_Path
Global $__VBoxVMinfo
Global $__VBoxGuestProperties
Global $bBotLaunchOption_Restart = False
Global $aCmdLine[1] = [0]
Global $WorkingDir = @WorkingDir
Global $hMutex_BotTitle = 0
Global $hMutex_Profile = 0
Global $hMutex_MyBot = 0
If $CmdLine[0] > 0 Then
Local $i
For $i = 1 To $CmdLine[0]
Switch $CmdLine[$i]
Case "/restart", "/r", "-restart", "-r"
$bBotLaunchOption_Restart = True
Case Else
$aCmdLine[0] += 1
ReDim $aCmdLine[$aCmdLine[0] + 1]
$aCmdLine[$aCmdLine[0]] = $CmdLine[$i]
EndSwitch
Next
EndIf
Global $sCurrProfile
If $aCmdLine[0] > 0 Then
$sCurrProfile = StringRegExpReplace($aCmdLine[1], '[/:*?"<>|]', '_')
ElseIf FileExists($sProfilePath & "\profile.ini") Then
$sCurrProfile = StringRegExpReplace(IniRead($sProfilePath & "\profile.ini", "general", "defaultprofile", ""), '[/:*?"<>|]', '_')
If $sCurrProfile = "" Or Not FileExists($sProfilePath & "\" & $sCurrProfile) Then $sCurrProfile = "<No Profiles>"
Else
$sCurrProfile = "<No Profiles>"
EndIf
Global $aWeakBaseStats
Global	$config = $sProfilePath & "\" & $sCurrProfile & "\config.ini"
Global	$ChartPath = $sProfilePath & "\" & $sCurrProfile & "\Chart\ChartData"
Global	$InputConfigFile = $sProfilePath & "\" & $sCurrProfile & "\InputConfig.ini"
Global	$statChkWeakBase = $sProfilePath & "\" & $sCurrProfile & "\stats_chkweakbase.INI"
Global	$statChkTownHall = $sProfilePath & "\" & $sCurrProfile & "\stats_chktownhall.INI"
Global	$statChkDeadBase = $sProfilePath & "\" & $sCurrProfile & "\stats_chkelixir.INI"
Global	$statChkDeadBase75percent = $sProfilePath & "\" & $sCurrProfile & "\stats_chkelixir75percent.INI"
Global	$statChkDeadBase50percent = $sProfilePath & "\" & $sCurrProfile & "\stats_chkelixir50percent.INI"
Global	$building = $sProfilePath & "\" & $sCurrProfile & "\building.ini"
Global	$dirLogs = $sProfilePath & "\" & $sCurrProfile & "\Logs\"
Global	$dirLoots = $sProfilePath & "\" & $sCurrProfile & "\Loots\"
Global	$dirTemp = $sProfilePath & "\" & $sCurrProfile & "\Temp\"
Global	$dirTempDebug = $sProfilePath & "\" & $sCurrProfile & "\Temp\Debug\"
Func SetupProfileFolder()
$config = $sProfilePath & "\" & $sCurrProfile & "\config.ini"
$ChartPath = $sProfilePath & "\" & $sCurrProfile & "\Chart\ChartData"
$InputConfigFile = $sProfilePath & "\" & $sCurrProfile & "\InputConfig.ini"
$statChkWeakBase = $sProfilePath & "\" & $sCurrProfile & "\stats_chkweakbase.INI"
$statChkTownHall = $sProfilePath & "\" & $sCurrProfile & "\stats_chktownhall.INI"
$statChkDeadBase = $sProfilePath & "\" & $sCurrProfile & "\stats_chkelixir.INI"
$statChkDeadBase75percent = $sProfilePath & "\" & $sCurrProfile & "\stats_chkelixir75percent.INI"
$statChkDeadBase50percent = $sProfilePath & "\" & $sCurrProfile & "\stats_chkelixir50percent.INI"
$building = $sProfilePath & "\" & $sCurrProfile & "\building.ini"
$dirLogs = $sProfilePath & "\" & $sCurrProfile & "\Logs\"
$dirLoots = $sProfilePath & "\" & $sCurrProfile & "\Loots\"
$dirTemp = $sProfilePath & "\" & $sCurrProfile & "\Temp\"
$dirTempDebug = $sProfilePath & "\" & $sCurrProfile & "\Temp\Debug\"
EndFunc
SetupProfileFolder()
Global $LibDir = @ScriptDir & "\lib"
Global $pCurl = $LibDir & "\curl\curl.exe"
Global $AdbScriptsDir = $LibDir & "\adb.scripts"
Global $pImageLib = $LibDir & "\ImageSearchDLL.dll"
Global $pImgLib = $LibDir & "\ImgLoc.dll"
Global $pImgLib2 = $LibDir & "\MyBotRunImgLoc.dll"
Global $pFuncLib = $LibDir & "\MBRFunctions.dll"
Global $hFuncLib = -1
Global $hFuncRedLib = -1
Global $hImgLib
Global $pIconLib = $LibDir & "\MBRBOT.dll"
Global Const $dirTHSnipesAttacks = @ScriptDir & "\CSV\THSnipe"
Global Const $dirAttacksCSV = @ScriptDir & "\CSV\Attack"
Global $RedrawBotWindowMode = 2
Global $bRedrawBotWindow[3] = [True, False, False]
Global Enum $eIcnArcher = 1, $eIcnDonArcher, $eIcnBalloon, $eIcnDonBalloon, $eIcnBarbarian, $eIcnDonBarbarian, $eIcnKingAbility, $eIcnBuilder, $eIcnCC, $eIcnGUI, $eIcnDark, $eIcnDragon, $eIcnDonDragon, $eIcnDrill, $eIcnElixir, $eIcnCollector, $eIcnFreezeSpell, $eIcnGem, $eIcnGiant, $eIcnDonGiant,  $eIcnTrap, $eIcnGoblin, $eIcnDonGoblin, $eIcnGold, $eIcnGolem, $eIcnDonGolem, $eIcnHealer, $eIcnDonHealer, $eIcnHogRider, $eIcnDonHogRider, $eIcnHealSpell, $eIcnInferno, $eIcnJumpSpell, $eIcnLavaHound, $eIcnDonLavaHound, $eIcnLightSpell, $eIcnMinion, $eIcnDonMinion, $eIcnPekka, $eIcnDonPekka,  $eIcnQueenAbility, $eIcnRageSpell, $eIcnTroops, $eIcnHourGlass, $eIcnTH1, $eIcnTH10, $eIcnTrophy, $eIcnValkyrie, $eIcnDonValkyrie, $eIcnWall, $eIcnWallBreaker, $eIcnDonWallBreaker, $eIcnWitch, $eIcnDonWitch, $eIcnWizard, $eIcnDonWizard, $eIcnXbow, $eIcnBarrackBoost, $eIcnMine, $eIcnCamp,  $eIcnBarrack, $eIcnSpellFactory, $eIcnDonBlacklist, $eIcnSpellFactoryBoost, $eIcnMortar, $eIcnWizTower, $eIcnPayPal, $eIcnPushBullet, $eIcnGreenLight, $eIcnLaboratory, $eIcnRedLight, $eIcnBlank, $eIcnYellowLight, $eIcnDonCustom, $eIcnTombstone, $eIcnSilverStar, $eIcnGoldStar, $eIcnDarkBarrack,  $eIcnCollectorLocate, $eIcnDrillLocate, $eIcnMineLocate, $eIcnBarrackLocate, $eIcnDarkBarrackLocate, $eIcnDarkSpellFactoryLocate, $eIcnDarkSpellFactory, $eIcnEarthQuakeSpell, $eIcnHasteSpell, $eIcnPoisonSpell, $eIcnBldgTarget, $eIcnBldgX, $eIcnRecycle, $eIcnHeroes,  $eIcnBldgElixir, $eIcnBldgGold, $eIcnMagnifier, $eIcnWallElixir, $eIcnWallGold, $eIcnQueen, $eIcnKing, $eIcnDarkSpellBoost, $eIcnQueenBoostLocate, $eIcnKingBoostLocate, $eIcnKingUpgr, $eIcnQueenUpgr, $eIcnWardenAbility, $eIcnWarden, $eIcnWardenBoostLocate, $eIcnKingBoost,  $eIcnQueenBoost, $eIcnWardenBoost, $eIcnWardenUpgr, $eIcnReload, $eIcnCopy, $eIcnAddcvs, $eIcnEdit, $eIcnTreeSnow, $eIcnSleepingQueen, $eIcnSleepingKing, $eIcnGoldElixir, $eIcnBowler, $eIcnDonBowler, $eIcnCCDonate, $eIcnEagleArt, $eIcnGembox, $eIcnInferno4, $eIcnInfo, $eIcnMain,  $eIcnTree, $eIcnProfile, $eIcnCCRequest, $eIcnTelegram, $eIcnTiles, $eIcnXbow3, $eIcnBark, $eIcnDailyProgram, $eIcnLootCart, $eIcnSleepMode, $eIcnTH11, $eIcnTrainMode, $eIcnSleepingWarden, $eIcnCloneSpell, $eIcnSkeletonSpell, $eIcnBabyDragon, $eIcnDonBabyDragon, $eIcnMiner, $eIcnDonMiner,  $eIcnNoShield, $eIcnDonCustomB, $eIcnDarkBarrackBoost, $eIcnAirDefense = 150, $eIcnBrain, $eIcnChat, $eIcnSwords, $eIcnLoop, $eIcnRepeat, $eIcnClan, $eIcnNewSmartZap1 , $eIcnNewSmartZap2, $eIcnPBNotify
Global $eIcnDonBlank = $eIcnDonBlacklist
Global $eIcnOptions = $eIcnDonBlacklist
Global $eIcnAchievements = $eIcnMain
Global $eIcnStrategies = $eIcnBlank
Global $sLogPath
Global $sAttackLogPath
Global $hLogFileHandle
Global $hLogFileTrain
Global $hAttackLogFileHandle
Global $iCmbLog = 0
Global $Restart = False
Global $RunState = False
Global $TakeLootSnapShot = True
Global $ScreenshotLootInfo = False
Global $AlertSearch = True
Global $iChkAttackNow, $iAttackNowDelay, $bBtnAttackNowPressed = False
Global Enum $DB, $LB, $TS, $MA, $TB, $DT
Global $iModeCount = 3
Global $isModeActive[$iModeCount]
Global $iMatchMode
Global $sModeText[6]
$sModeText[$DB] = "Dead Base"
$sModeText[$LB] = "Live Base"
$sModeText[$TS] = "TH Snipe"
$sModeText[$TB] = "TH Bully"
$sModeText[$DT] = "Drop Trophy"
$sModeText[$MA] = "Milking Attack"
Global $NotifyVersion = "Revamp v1.5"
Global $NotifyPBEnabled = 0
Global $NotifyPBToken = ""
Global $NotifyTGEnabled = 0
Global $NotifyTGToken = ""
Global $NotifyRemoteEnable = 0
Global $NotifyOrigin = ""
Global $NotifyForced = 0
Global $NotifyDeleteAllPushesOnStart = 0
Global $NotifyDeleteAllPushesNow = 0
Global $NotifyDeletePushesOlderThan = 0
Global $NotifyDeletePushesOlderThanHours = 4
Global $NotifyAlertMatchFound = 0
Global $NotifyAlerLastRaidIMG = 0
Global $NotifyAlerLastRaidTXT = 0
Global $NotifyAlertCampFull = 0
Global $NotifyAlertUpgradeWalls = 0
Global $NotifyAlertOutOfSync = 0
Global $NotifyAlertTakeBreak = 0
Global $NotifyAlertBulderIdle = 0
Global $NotifyAlertVillageReport = 0
Global $NotifyAlertLastAttack = 0
Global $NotifyAlertAnotherDevice = 0
Global $NotifyAlertMaintenance = 1
Global $NotifyAlertBAN = 1
Global $NotifyAlertBOTUpdate = 1
Global $iReportIdleBuilder = 0
Global $NotifyScheduleHoursEnable
Global $NotifyScheduleWeekDaysEnable
Global $NotifyScheduleHours[24]
Global $NotifyScheduleWeekDays[7]
Global $PBRemoteControlInterval = 60000
Global $PBDeleteOldPushesInterval = 1800000
Global $hTimer_PBRemoteControlInterval = 0
Global $hTimer_PBDeleteOldPushesInterval = 0
Global $TGChatID = ""
Global $NotifyTroopSpellStats[0][2] = [[]]
Global $PBRequestScreenshot = 0
Global $PBRequestScreenshotHD = 0
Global $PBRequestBuilderInfo = 0
Global $PBRequestShieldInfo = 0
Global $TGRequestScreenshot = 0
Global $TGRequestScreenshotHD = 0
Global $TGRequestBuilderInfo = 0
Global $TGRequestShieldInfo = 0
Global $TGLastRemote = 0
Global $TGLast_UID = ""
Global $TGLastMessage = ""
Global $grpNotify, $chkNotifyPBEnabled,$chkNotifyRemote,$chkNotifyDeleteAllPBPushes,$btnNotifyDeleteMessages,$chkNotifyDeleteOldPBPushes,$cmbNotifyPushHours
Global $txbNotifyPBToken, $txbNotifyTGToken, $txbNotifyOrigin, $chkNotifyAlertMatchFound, $chkNotifyAlertLastRaidIMG, $chkNotifyAlertLastRaidTXT, $chkNotifyAlertCampFull
Global $chkNotifyAlertUpgradeWall, $chkNotifyAlertOutOfSync, $chkNotifyAlertTakeBreak, $chkNotifyAlertBuilderIdle, $chkNotifyAlertVillageStats, $chkNotifyAlertLastAttack
Global $chkNotifyAlertAnotherDevice, $chkNotifyAlertMaintenance, $chkNotifyAlertBAN, $chkNotifyBOTUpdate
Global $iAtkAlgorithm[$iModeCount]
Global $sLogFName
Global $sAttackLogFName
Global $AttackFile
Global $Result
Global $Result2
Global $iCollectCounter = 0
Global $COLLECTATCOUNT = 10
Global $BSpos[2]
Global $BSrpos[2]
Global $iFreeBuilderCount, $iTotalBuilderCount, $iGemAmount
Global $iGoldStart, $iElixirStart, $iDarkStart, $iTrophyStart
Global $iGoldTotal, $iElixirTotal, $iDarkTotal, $iTrophyTotal
Global $iGoldCurrent, $iElixirCurrent, $iDarkCurrent, $iTrophyCurrent
Global $iGoldLast, $iElixirLast, $iDarkLast, $iTrophyLast
Global $iGoldLastBonus, $iElixirLastBonus, $iDarkLastBonus
Global $iBonusLast = 0
Global $iskipped
Global $iSkippedVillageCount, $iDroppedTrophyCount
Global $iCostGoldWall, $iCostElixirWall, $iCostGoldBuilding, $iCostElixirBuilding, $iCostDElixirHero
Global $iNbrOfWallsUppedGold, $iNbrOfWallsUppedElixir, $iNbrOfBuildingsUppedGold, $iNbrOfBuildingsUppedElixir, $iNbrOfHeroesUpped
Global $iSearchCost, $iTrainCostElixir, $iTrainCostDElixir
Global $iNbrOfOoS
Global $iNbrOfTHSnipeFails, $iNbrOfTHSnipeSuccess
Global $iGoldFromMines, $iElixirFromCollectors, $iDElixirFromDrills
Global $iAttackedVillageCount[$iModeCount + 3]
Global $iTotalGoldGain[$iModeCount + 3], $iTotalElixirGain[$iModeCount + 3], $iTotalDarkGain[$iModeCount + 3], $iTotalTrophyGain[$iModeCount + 3]
Global $iNbrOfDetectedMines[$iModeCount + 3], $iNbrOfDetectedCollectors[$iModeCount + 3], $iNbrOfDetectedDrills[$iModeCount + 3]
Global $lblAttacked[$iModeCount + 3], $lblTotalGoldGain[$iModeCount + 3], $lblTotalElixirGain[$iModeCount + 3], $lblTotalDElixirGain[$iModeCount + 3], $lblTotalTrophyGain[$iModeCount + 3]
Global $lblNbrOfDetectedMines[$iModeCount + 3], $lblNbrOfDetectedCollectors[$iModeCount + 3], $lblNbrOfDetectedDrills[$iModeCount + 3]
Global $ArmyCapacity = 0
Global $iLaboratoryElixirCost
Global $iAttackedCount = 0
Global $bSearchMode = False
Global $Is_ClientSyncError = False
Global $searchGold, $searchElixir, $searchDark, $searchTrophy, $searchTH
Global $SearchGold2 = 0, $SearchElixir2 = 0, $iStuck = 0, $iNext = 0
Global $iMinGold[$iModeCount], $iMinElixir[$iModeCount], $iMinGoldPlusElixir[$iModeCount], $iMinDark[$iModeCount], $iMinTrophy[$iModeCount], $iMaxTH[$iModeCount], $iEnableAfterCount[$iModeCount], $iEnableBeforeCount[$iModeCount]
Global $ChkMaxMortar[$iModeCount], $ChkMaxWizTower[$iModeCount], $chkMaxAirDefense[$iModeCount], $ChkMaxXBow[$iModeCount], $ChkMaxInferno[$iModeCount], $ChkMaxEagle[$iModeCount]
Global $iChkMaxMortar[$iModeCount], $iChkMaxWizTower[$iModeCount], $iChkMaxAirDefense[$iModeCount], $iChkMaxXBow[$iModeCount], $iChkMaxInferno[$iModeCount], $iChkMaxEagle[$iModeCount]
Global $CmbWeakMortar[$iModeCount], $CmbWeakWizTower[$iModeCount], $CmbWeakAirDefense[$iModeCount], $CmbWeakXBow[$iModeCount], $CmbWeakInferno[$iModeCount], $cmbWeakEagle[$iModeCount]
Global $iCmbWeakMortar[$iModeCount], $iCmbWeakWizTower[$iModeCount], $iCmbWeakAirDefense[$iModeCount], $iCmbWeakXBow[$iModeCount], $iCmbWeakInferno[$iModeCount], $iCmbWeakEagle[$iModeCount]
Global $iEnableAfterTropies[$iModeCount], $iEnableBeforeTropies[$iModeCount], $iEnableAfterArmyCamps[$iModeCount]
Global $iAimGold[$iModeCount], $iAimElixir[$iModeCount], $iAimGoldPlusElixir[$iModeCount], $iAimDark[$iModeCount], $iAimTrophy[$iModeCount], $iAimTHtext[$iModeCount]
Global $iEnableSearchSearches[$iModeCount], $iEnableSearchTropies[$iModeCount], $iEnableSearchCamps[$iModeCount]
Global $iDBcheck = 1
Global $iABcheck = 0
Global $iTScheck = 0
$iEnableSearchSearches[$DB] = 1
$iCmbWeakMortar[$DB] = 5
$iCmbWeakMortar[$LB] = 5
$iCmbWeakWizTower[$DB] = 4
$iCmbWeakWizTower[$LB] = 4
Global $iChkSearchReduction = 0
Global $ReduceCount = 20, $ReduceGold = 2000, $ReduceElixir = 2000, $ReduceGoldPlusElixir = 4000, $ReduceDark = 100, $ReduceTrophy = 2
Global $iChkEnableAfter[$iModeCount], $iCmbMeetGE[$iModeCount], $iChkMeetDE[$iModeCount], $iChkMeetTrophy[$iModeCount], $iChkMeetTH[$iModeCount], $iChkMeetTHO[$iModeCount], $iChkMeetOne[$iModeCount], $iCmbTH[$iModeCount]
Global $chkDBMeetTHO, $chkABMeetTHO
Global $THLocation
Global $THx = 0, $THy = 0
Global $THText[6]
$THText[0] = "4-6"
$THText[1] = "7"
$THText[2] = "8"
$THText[3] = "9"
$THText[4] = "10"
$THText[5] = "11"
Global $maxElixirLevel = 6
Global $ElixirImages0, $ElixirImages1, $ElixirImages2, $ElixirImages3, $ElixirImages4, $ElixirImages5, $ElixirImages6
Global $ElixirImagesStat0, $ElixirImagesStat1, $ElixirImagesStat2, $ElixirImagesStat3, $ElixirImagesStat4, $ElixirImagesStat5, $ElixirImagesStat6
Global $ElixirImages0_75percent, $ElixirImages1_75percent, $ElixirImages2_75percent, $ElixirImages3_75percent, $ElixirImages4_75percent, $ElixirImages5_75percent, $ElixirImages6_75percent
Global $ElixirImagesStat0_75percent, $ElixirImagesStat1_75percent, $ElixirImagesStat2_75percent, $ElixirImagesStat3_75percent, $ElixirImagesStat4_75percent, $ElixirImagesStat5_75percent, $ElixirImagesStat6_75percent
Global $ElixirImages0_50percent, $ElixirImages1_50percent, $ElixirImages2_50percent, $ElixirImages3_50percent, $ElixirImages4_50percent, $ElixirImages5_50percent, $ElixirImages6_50percent
Global $ElixirImagesStat0_50percent, $ElixirImagesStat1_50percent, $ElixirImagesStat2_50percent, $ElixirImagesStat3_50percent, $ElixirImagesStat4_50percent, $ElixirImagesStat5_50percent, $ElixirImagesStat6_50percent
Global $SearchCount = 0
Global $THaddtiles, $THside, $THi
Global $SearchTHLResult = 0
Global $BullySearchCount = 0
Global $OptBullyMode = 0
Global $ATBullyMode = 150
Global $YourTH
Global $iTHBullyAttackMode
Global $scmbAttackTHType = "Bam"
Global $txtAttackTHType
Global $iNbOfSpots
Global $iAtEachSpot
Global $Sleep
Global $waveNb
Global $DelayInSec
Global $Log
Global $CheckHeroes
Global $KingSlotTH
Global $QueenSlotTH
Global $icmbDeployBtmTHType
Global $ichkUseKingTH = 0
Global $ichkUseQueenTH = 0
Global $ichkUseWardenTH = 0
Global $ichkUseClastleTH = 0
Global $ichkUseClastleTH = 0
Global $ichkUseLSpellsTH = 0
Global $ichkUseRSpellsTH = 0
Global $ichkUseHSpellsTH = 0
Global $THusedKing = 0
Global $THusedQueen = 0
Global $THusedWarden = 0
Global $TrainSpecial = 1
Global $cBarbarian = 0, $cArcher = 0, $cGoblin = 0, $cGiant = 0, $cWallbreaker = 0, $cWizard = 0, $cBalloon = 0, $cDragon = 0, $cPekka = 0, $cBabyDragon = 0, $cMiner = 0, $cMinion = 0, $cHogs = 0, $cValkyrie = 0, $cGolem = 0, $cWitch = 0, $cLavaHound = 0, $cBowl = 0
Global Enum $eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine,  $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl, $eKing, $eQueen, $eWarden, $eCastle,  $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell
Global $WallCost = 0
Global $WallCosts[7] = [30000, 75000, 200000, 500000, 1000000, 3000000, 4000000]
Global $WallX = 0, $WallY = 0
Global $Wall[8]
Global $iMaxNbWall = 4
Global $ichkUpgradeContinually
Global $TopLeft[5][2] = [[56, 307], [165, 236], [236, 185], [300, 137], [390, 71]]
Global $TopRight[5][2] = [[458, 72], [543, 136], [609, 187], [684, 244], [779, 300]]
Global $BottomLeft[5][2] = [[56, 418], [165, 495], [236, 547], [300, 592], [315, 629]]
Global $BottomRight[5][2] = [[505, 629], [561, 592], [620, 547], [680, 495], [780, 418]]
Global $eThing[1] = [101]
Global $Edges[4] = [$BottomRight, $TopLeft, $BottomLeft, $TopRight]
Global $atkTroops[12][2]
Global $fullArmy
Global $bFullSpell
Global $iChkDeploySettings[$iModeCount+1]
$iChkDeploySettings[$DB] = 3
$iChkDeploySettings[$LB] = 3
$iChkDeploySettings[$MA] = 1
Global $iChkRedArea[$iModeCount+3], $iCmbSmartDeploy[$iModeCount+3], $iChkSmartAttack[$iModeCount+3][3], $iCmbSelectTroop[$iModeCount+3]
$iChkRedArea[$DB] = 1
$iChkRedArea[$LB] = 1
$iChkRedArea[$MA] = 1
Global $troopsToBeUsed[12]
Global $useAllTroops[33] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell]
Global $useBarracks[26] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $useBarbs[15] = [$eBarb, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $useArchs[15] = [$eArch, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $useBarcher[16] = [$eBarb, $eArch, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $useBarbGob[16] = [$eBarb, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $useArchGob[16] = [$eArch, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $useBarcherGiant[17] = [$eBarb, $eArch, $eGiant, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $useBarcherGobGiant[18] = [$eBarb, $eArch, $eGiant, $eGobl, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $useBarcherHog[17] = [$eBarb, $eArch, $eHogs, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $useBarcherMinion[17] = [$eBarb, $eArch, $eMini, $eKing, $eQueen, $eWarden, $eCastle, $eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Global $usegoblin[1] = [$eGobl]
$troopsToBeUsed[0] = $useAllTroops
$troopsToBeUsed[1] = $useBarracks
$troopsToBeUsed[2] = $useBarbs
$troopsToBeUsed[3] = $useArchs
$troopsToBeUsed[4] = $useBarcher
$troopsToBeUsed[5] = $useBarbGob
$troopsToBeUsed[6] = $useArchGob
$troopsToBeUsed[7] = $useBarcherGiant
$troopsToBeUsed[8] = $useBarcherGobGiant
$troopsToBeUsed[9] = $useBarcherHog
$troopsToBeUsed[10] = $useBarcherMinion
Global $KingAttack[$iModeCount]
Global $QueenAttack[$iModeCount]
Global $WardenAttack[$iModeCount]
Global Const $HERO_NOHERO = 0x00
Global Const $HERO_KING = 0x01
Global Const $HERO_QUEEN = 0x02
Global Const $HERO_WARDEN = 0x04
Global $iHeroAttack[$iModeCount]
Global $iHeroWait[$iModeCount]
Global $iHeroAvailable = $HERO_NOHERO
Global $bFullArmyHero = False
Global $KingAttackCSV[$iModeCount]
Global $QueenAttackCSV[$iModeCount]
Global $WardenAttackCSV[$iModeCount]
Global $ichkLightSpell[$iModeCount]
Global $ichkHealSpell[$iModeCount]
Global $ichkRageSpell[$iModeCount]
Global $ichkJumpSpell[$iModeCount]
Global $ichkFreezeSpell[$iModeCount]
Global $ichkPoisonSpell[$iModeCount]
Global $ichkEarthquakeSpell[$iModeCount]
Global $ichkHasteSpell[$iModeCount]
Global $checkKPower = False
Global $checkQPower = False
Global $checkWPower = False
Global $iActivateKQCondition
Global $iActivateWardenCondition
Global $delayActivateKQ
Global $delayActivateW
Global $iActivateKQConditionCSV
Global $iActivateWardenConditionCSV
Global $delayActivateKQCSV
Global $iDropCC[$iModeCount]
Global $iChkUseCCBalanced
Global $iCmbCCDonated, $iCmbCCReceived
Global $iDropCCCSV[$iModeCount]
Global $iChkUseCCBalancedCSV
Global $iCmbCCDonatedCSV, $iCmbCCReceivedCSV
Global $THLoc
Global $King, $Queen, $CC, $Barb, $Arch, $LSpell, $LSpellQ, $Warden
Global $LeftTHx, $RightTHx, $BottomTHy, $TopTHy
Global $AtkTroopTH
Global $GetTHLoc
Global $iUnbreakableMode = 0
Global $iUnbreakableWait = 5
Global $iUnBrkMinGold = 50000
Global $iUnBrkMinElixir = 50000
Global $iUnBrkMaxGold = 600000
Global $iUnBrkMaxElixir = 600000
Global $iUnBrkMinDark = 5000
Global $iUnBrkMaxDark = 6000
Global $OutOfGold = 0
Global $OutOfElixir = 0
Global $zoomedin = False, $zCount = 0, $sCount = 0
Global $boostsEnabled = 1
Global $icmbBoostBarracks = 0
Global $icmbBoostSpellFactory = 0
Global $icmbBoostBarbarianKing = 0
Global $icmbBoostArcherQueen = 0
Global $icmbBoostWarden = 0
Global $TownHallPos[2] = [-1, -1]
Global $iTownHallLevel = 0
Global $KingAltarPos[2] = [-1, -1]
Global $QueenAltarPos[2] = [-1, -1]
Global $WardenAltarPos[2] = [-1, -1]
Global $aCCPos[2] = [-1, -1]
Global $IsCCAutoLocated[4] = [0, 0, 33, 2]
Global $LastDonateBtn1 = -1, $LastDonateBtn2 = -1
Global $DonatePixel
Global $iClanLevel
Global $sTxtRequest = ""
Global $ichkDonateAllBarbarians, $ichkDonateBarbarians, $sTxtDonateBarbarians, $sTxtBlacklistBarbarians, $aDonBarbarians, $aBlkBarbarians
Global $ichkDonateAllArchers, $ichkDonateArchers, $sTxtDonateArchers, $sTxtBlacklistArchers, $aDonArchers, $aBlkArchers
Global $ichkDonateAllGiants, $ichkDonateGiants, $sTxtDonateGiants, $sTxtBlacklistGiants, $aDonGiants, $aBlkGiants
Global $ichkDonateAllGoblins, $ichkDonateGoblins, $sTxtDonateGoblins, $sTxtBlacklistGoblins, $aDonGoblins, $aBlkGoblins
Global $ichkDonateAllWallBreakers, $ichkDonateWallBreakers, $sTxtDonateWallBreakers, $sTxtBlacklistWallBreakers, $aDonWallBreakers, $aBlkWallBreakers
Global $ichkDonateAllBalloons, $ichkDonateBalloons, $sTxtDonateBalloons, $sTxtBlacklistBalloons, $aDonBalloons, $aBlkBalloons
Global $ichkDonateAllWizards, $ichkDonateWizards, $sTxtDonateWizards, $sTxtBlacklistWizards, $aDonWizards, $aBlkWizards
Global $ichkDonateAllHealers, $ichkDonateHealers, $sTxtDonateHealers, $sTxtBlacklistHealers, $aDonHealers, $aBlkHealers
Global $ichkDonateAllDragons, $ichkDonateDragons, $sTxtDonateDragons, $sTxtBlacklistDragons, $aDonDragons, $aBlkDragons
Global $ichkDonateAllPekkas, $ichkDonatePekkas, $sTxtDonatePekkas, $sTxtBlacklistPekkas, $aDonPekkas, $aBlkPekkas
Global $ichkDonateAllBabyDragons, $ichkDonateBabyDragons, $sTxtDonateBabyDragons, $sTxtBlacklistBabyDragons, $aDonBabyDragons, $aBlkBabyDragons
Global $ichkDonateAllMiners, $ichkDonateMiners, $sTxtDonateMiners, $sTxtBlacklistMiners, $aDonMiners, $aBlkMiners
Global $ichkDonateAllMinions, $ichkDonateMinions, $sTxtDonateMinions, $sTxtBlacklistMinions, $aDonMinions, $aBlkMinions
Global $ichkDonateAllHogRiders, $ichkDonateHogRiders, $sTxtDonateHogRiders, $sTxtBlacklistHogRiders, $aDonHogRiders, $aBlkHogRiders
Global $ichkDonateAllValkyries, $ichkDonateValkyries, $sTxtDonateValkyries, $sTxtBlacklistValkyries, $aDonValkyries, $aBlkValkyries
Global $ichkDonateAllGolems, $ichkDonateGolems, $sTxtDonateGolems, $sTxtBlacklistGolems, $aDonGolems, $aBlkGolems
Global $ichkDonateAllWitches, $ichkDonateWitches, $sTxtDonateWitches, $sTxtBlacklistWitches, $aDonWitches, $aBlkWitches
Global $ichkDonateAllLavaHounds, $ichkDonateLavaHounds, $sTxtDonateLavaHounds, $sTxtBlacklistLavaHounds, $aDonLavaHounds, $aBlkLavaHounds
Global $ichkDonateAllBowlers, $ichkDonateBowlers, $sTxtDonateBowlers, $sTxtBlacklistBowlers, $aDonBowlers, $aBlkBowlers
Global $ichkDonateAllPoisonSpells, $ichkDonatePoisonSpells, $sTxtDonatePoisonSpells, $sTxtBlacklistPoisonSpells, $aDonPoisonSpells, $aBlkPoisonSpells
Global $ichkDonateAllEarthQuakeSpells, $ichkDonateEarthQuakeSpells, $sTxtDonateEarthQuakeSpells, $sTxtBlacklistEarthQuakeSpells, $aDonEarthQuakeSpells, $aBlkEarthQuakeSpells
Global $ichkDonateAllHasteSpells, $ichkDonateHasteSpells, $sTxtDonateHasteSpells, $sTxtBlacklistHasteSpells, $aDonHasteSpells, $aBlkHasteSpells
Global $ichkDonateAllSkeletonSpells, $ichkDonateSkeletonSpells, $sTxtDonateSkeletonSpells, $sTxtBlacklistSkeletonSpells, $aDonSkeletonSpells, $aBlkSkeletonSpells
Global $ichkDonateAllCustomA, $ichkDonateCustomA, $sTxtDonateCustomA,$sTxtBlacklistCustomA, $aDonCustomA, $aBlkCustomA, $varDonateCustomA[3][2]
Global $ichkDonateAllCustomB, $ichkDonateCustomB, $sTxtDonateCustomB, $sTxtBlacklistCustomB, $aDonCustomB, $aBlkCustomB, $varDonateCustomB[3][2]
Global $sTxtBlacklist, $aBlacklist
Global $ichkExtraAlphabets = 0
Global $DonBarb = 0, $DonArch = 0, $DonGiant = 0, $DonGobl = 0, $DonWall = 0, $DonBall = 0, $DonWiza = 0, $DonHeal = 0
Global $DonMini = 0, $DonHogs = 0, $DonValk = 0, $DonGole = 0, $DonWitc = 0, $DonLava = 0, $DonBowl = 0, $DonDrag = 0, $DonPekk = 0, $DonBabyD = 0, $DonMine = 0
Global $BarbComp = 0, $ArchComp = 0, $GoblComp = 0, $GiantComp = 0, $WallComp = 0, $WizaComp = 0, $MiniComp = 0, $HogsComp = 0
Global $DragComp = 0, $BallComp = 0, $PekkComp = 0, $HealComp = 0, $ValkComp = 0, $GoleComp = 0, $WitcComp = 0, $LavaComp = 0, $BowlComp = 0
Global $BabyDComp = 0, $MineComp = 0
Global $CurBarb = 0, $CurArch = 0, $CurGiant = 0, $CurGobl = 0, $CurWall = 0, $CurBall = 0, $CurWiza = 0, $CurHeal = 0
Global $CurMini = 0, $CurHogs = 0, $CurValk = 0, $CurGole = 0, $CurWitc = 0, $CurLava = 0, $CurBowl = 0, $CurDrag = 0, $CurPekk = 0, $CurBabyD = 0, $CurMine = 0
Global $QueuedBarb = 0, $QueuedArch = 0, $QueuedGiant = 0, $QueuedGobl = 0, $QueuedWall = 0, $QueuedBall = 0, $QueuedWiza = 0, $QueuedHeal = 0, $QueuedDrag = 0, $QueuedPekk = 0, $QueuedBabyD = 0, $QueuedMine = 0
Global $QueuedMini = 0, $QueuedHogs = 0, $QueuedValk = 0, $QueuedGole = 0, $QueuedWitc = 0, $QueuedLava = 0, $QueuedBowl = 0
Global $A[4] = [112, 111, 116, 97]
Global $B[6] = [116, 111, 98, 111, 116, 46]
Global $C[6] = [98, 117, 103, 115, 51, 46]
Global $D[4] = [99, 111, 109, 47]
Global $F[8] = [112, 58, 47, 47, 119, 119, 119, 46]
Global $G[3] = [104, 116, 116]
Global $T[1] = [97]
Global $Y[4] = [46, 116, 120, 116]
Global $DonPois = 0, $DonEart = 0, $DonHast = 0, $DonSkel
Global $CurTotalSpell = False
Global $iTotalCountSpell = 0
Global $iTotalTrainSpaceSpell = 0
Global $CurTotalDarkSpell = 0
Global $LSpellComp = 0, $HSpellComp = 0, $RSpellComp = 0, $JSpellComp = 0, $FSpellComp = 0, $CSpellComp = 0, $PSpellComp = 0, $ESpellComp = 0, $HaSpellComp = 0, $SkSpellComp = 0
Global $CurLSpell = 0, $CurHSpell = 0, $CurRSpell = 0, $CurJSpell = 0, $CurFSpell = 0, $CurCSpell = 0, $CurPSpell = 0, $CurESpell = 0, $CurHaSpell = 0, $CurSkSpell = 0
Global $DonLSpell = 0, $DonHSpell = 0, $DonRSpell = 0, $DonJSpell = 0, $DonFSpell = 0, $DonCSpell = 0, $DonPSpell = 0, $DonESpell = 0, $DonHaSpell = 0, $DonSkSpell = 0
Global $QueuedLSpell = 0, $QueuedHSpell = 0, $QueuedRSpell = 0, $QueuedJSpell = 0, $QueuedFSpell = 0, $QueuedCSpell = 0, $QueuedPSpell = 0, $QueueESpell = 0, $QueuedHaSpell = 0, $QueuedSkSpell = 0
Global $iEnableSpellsWait[$iModeCount]
Global $bFullArmySpells = False
Global $bFullCastle = False
Global $barrackPos[4][2]
Global $DarkbarrackPos[2][2]
Global $CheckIfWasBoostedOnBarrack[4]
Global $CheckIfWasBoostedOnDarkBarrack[2]
Global $barrackTroop[5]
Global $darkBarrackTroop[2]
Global $ArmyPos[2] = [-1, -1]
Global $ichkWalls
Global $icmbWalls = 6
Global $iUseStorage
Global $itxtWallMinGold = 250000
Global $itxtWallMinElixir = 250000
Global $iVSDelay = 0
Global $iMaxVSDelay = 0
Global $isldTrainITDelay = 40
Global $ichkTrap, $iChkCollect, $ichkTombstones, $ichkCleanYard, $ichkTrapAfter
Global $ichkGemsBox
Global $iCmbUnitDelay[$iModeCount+1], $iCmbWaveDelay[$iModeCount+1], $iChkRandomspeedatk[$iModeCount+1], $icmbStandardAlgorithm[$iModeCount+1]
$iCmbUnitDelay[$DB] = 4
$iCmbWaveDelay[$DB] = 4
$iCmbUnitDelay[$LB] = 4
$iCmbWaveDelay[$LB] = 4
$iCmbUnitDelay[$MA] = 4
$iCmbWaveDelay[$MA] = 4
$iChkRandomspeedatk[$DB] = 1
$iChkRandomspeedatk[$LB] = 1
$iChkRandomspeedatk[$MA] = 1
Global $iTimeTroops = 0
Global $iTimeGiant = 120
Global $iTimeWall = 120
Global $iTimeArch = 25
Global $iTimeGoblin = 30
Global $iTimeBarba = 20
Global $iTimeWizard = 480
Global $iChkTrophyHeroes, $iChkTrophyAtkDead, $itxtDTArmyMin = 70
Global $Walltolerance[7] = [35, 35, 45, 35, 45, 40, 35]
Global $frmBotPosX = -1
Global $frmBotPosY = -1
Global $AndroidPosX = -1
Global $AndroidPosY = -1
Global $frmBotDockedPosX = -1
Global $frmBotDockedPosY = -1
Global $iUpdatingWhenMinimized = 1
Global $chkUpdatingWhenMinimized
Global $iHideWhenMinimized = 0
Global $chkHideWhenMinimized
Global $frmBotAddH = 0
Global $Hide = False
Global $iDividerY = 243
Global $iDividerHeight = 4
Global $ichkBotStop, $icmbBotCommand, $icmbBotCond, $icmbHoursStop
Global $CommandStop = -1
Global $MeetCondStop = False
Global $bTrainEnabled = True
Global $bDonationEnabled = True
Global $UseTimeStop = -1
Global $TimeToStop = -1
Global $iChkTrophyRange = 0
Global $itxtMaxTrophy = 1200
Global $itxtdropTrophy = 800
Global $bDisableDropTrophy = False
Global $aDTtroopsToBeUsed[6][2] = [["Barb", 0], ["Arch", 0], ["Giant", 0], ["Wall", 0], ["Gobl", 0], ["Mini", 0]]
Global $ichkAutoStart
Global $ichkAutoStartDelay
Global $restarted
Global $ichkBackground
Global $collectorPos[17][2]
Global $break = @ScriptDir & "\images\break.bmp"
Global $device = @ScriptDir & "\images\device.bmp"
Global $CocStopped = @ScriptDir & "\images\CocStopped.bmp"
Global $imgDivider = @ScriptDir & "\images\divider.bmp"
Global $iDividerY = 385
Global $resArmy = 0
Global $FirstRun = 1
Global $FirstAttack = 0
Global $CurTrophy = 0
Global $brrNum
Global $sTimer, $iTimePassed, $hour, $min, $sec, $sTimeWakeUp = 120
Global $fulltroop = 100
Global $CurCamp, $TotalCamp = 0
Global $NoLeague
Global $FirstStart = True
Global $TPaused, $BlockInputPause = 0
Global $TogglePauseUpdateState = False
Global $TogglePauseAllowed = True
Global $itxtRestartGold = 10000
Global $itxtRestartElixir = 25000
Global $itxtRestartDark = 500
Global $DefaultTroopGroup[19][3] = [ ["Arch", 1, 1], ["Giant", 2, 5], ["Wall", 4, 2], ["Barb", 0, 1], ["Gobl", 3, 1], ["Heal", 7, 14], ["Pekk", 9, 25],   ["Ball", 5, 5], ["Wiza", 6, 4], ["Drag", 8, 20], ["BabyD", 10, 10],["Mine", 11, 5],  ["Mini", 0, 2], ["Hogs", 1, 5], ["Valk", 2, 8], ["Gole", 3, 30], ["Witc", 4, 12], ["Lava", 5, 30], ["Bowl", 6, 6]]
Global $MergedTroopGroup[19][5] = [ ["Lava", 5, 30, 0, "d"], ["Gole", 3, 30, 0, "d"], ["Pekk", 9, 25, 0, "e"], ["Drag", 8, 20, 0, "e"], ["Heal", 7, 14, 0, "e"], ["Witc", 4, 12, 0, "d"],  ["BabyD", 10, 10, 0, "e"], ["Valk", 2, 8, 0, "d"], ["Bowl", 6, 6, 0, "d"], ["Hogs", 1, 5, 0, "d"], ["Ball", 5, 5, 0, "e"], ["Giant", 2, 5, 0, "e"],  ["Mine", 11, 5, 0, "e"], ["Wiza", 6, 4, 0, "e"], ["Mini", 0, 2, 0, "d"], ["Wall", 4, 2, 0, "e"], ["Arch", 1, 1, 0, "e"], ["Barb", 0, 1, 0, "e"],  ["Gobl", 3, 1, 0, "e"] ]
Global $TroopGroup1[19][3] = [  ["Gole", 3, 30], ["Lava", 5, 30], ["Pekk", 9, 25], ["Drag", 8, 20], ["Heal", 7, 14], ["Witc", 4, 12], ["BabyD", 10, 10], ["Valk", 2, 8], ["Bowl", 6, 6], ["Hogs", 1, 5], ["Ball", 5, 5], ["Giant", 2, 5], ["Mine", 11, 5],  ["Wiza", 6, 4], ["Mini", 0, 2], ["Wall", 4, 2], ["Arch", 1, 1], ["Barb", 0, 1], ["Gobl", 3, 1]]
Global $TroopGroup[19][3]
Global $TroopName[UBound($TroopGroup, 1)]
Global $TroopNamePosition[UBound($TroopGroup, 1)]
Global $TroopHeight[UBound($TroopGroup, 1)]
SetDefaultTroopGroup(False)
Global $chkTroopOrder, $ichkTroopOrder, $btnTroopOrderSet
Global $aTroopOrderIcon[21] = [$eIcnOptions, $eIcnBarbarian, $eIcnArcher, $eIcnGiant, $eIcnGoblin, $eIcnWallBreaker, $eIcnBalloon, $eIcnWizard, $eIcnHealer, $eIcnDragon, $eIcnPekka, $eIcnBabyDragon, $eIcnMiner, $eIcnMinion, $eIcnHogRider, $eIcnValkyrie, $eIcnGolem, $eIcnWitch, $eIcnLavaHound, $eIcnBowler]
Global $cmbTroopOrder[UBound($aTroopOrderIcon)], $icmbTroopOrder[UBound($aTroopOrderIcon)], $lblTroopOrder[UBound($aTroopOrderIcon)], $ImgTroopOrder[UBound($aTroopOrderIcon)]
Global $chkDarkTroopOrder, $ichkDarkTroopOrder, $btnDarkTroopOrderSet
Global $aDarkTroopOrderIcon[8] = [$eIcnOptions, $eIcnMinion, $eIcnHogRider, $eIcnValkyrie, $eIcnGolem, $eIcnWitch, $eIcnLavaHound, $eIcnBowler]
Global $cmbDarkTroopOrder[UBound($aDarkTroopOrderIcon)], $icmbDarkTroopOrder[UBound($aDarkTroopOrderIcon)], $lblDarkTroopOrder[UBound($aDarkTroopOrderIcon)], $ImgDarkTroopOrder[UBound($aDarkTroopOrderIcon)]
Global $DefaultTroopGroupDark[7][3] = [["Mini", 0, 2], ["Hogs", 1, 5], ["Valk", 2, 8], ["Gole", 3, 30], ["Witc", 4, 12], ["Lava", 5, 30], ["Bowl", 6, 6]]
Global $TroopGroupDark[7][3]
Global $TroopDarkName[UBound($TroopGroupDark, 1)]
Global $TroopDarkNamePosition[UBound($TroopGroupDark, 1)]
Global $TroopDarkHeight[UBound($TroopGroupDark, 1)]
SetDefaultTroopGroupDark(False)
Global $TxtNameSpell[10] = ["LightningSpell", "HealSpell", "RageSpell", "JumpSpell", "FreezeSpell", "CloneSpell", "PoisonSpell", "EarthSpell", "HasteSpell", "SkeletonSpell"]
Global $SpellGroup[10][3] = [["LSpell", 0, 2], ["HSpell", 1, 2], ["RSpell", 2, 2], ["JSpell", 3, 2], ["FSpell", 4, 2], ["CSpell", 5, 4], ["PSpell", 6, 1], ["ESpell", 7, 1], ["HaSpell", 8, 1], ["SkSpell", 9, 1]]
Global $SpellName[UBound($SpellGroup, 1)]
Global $SpellNamePosition[UBound($SpellGroup, 1)]
Global $SpellHeight[UBound($SpellGroup, 1)]
Global $BarrackStatus[4] = [False, False, False, False]
Global $BarrackFull[4] = [False, False, False, False]
Global $BarrackDarkStatus[2] = [False, False]
Global $BarrackDarkFull[2] = [False, False]
Global $listResourceLocation = ""
Global $isNormalBuild = ""
Global $isDarkBuild = ""
Global $TotalTrainedTroops = 0
For $i = 0 To UBound($SpellGroup, 1) - 1
$SpellName[$i] = $SpellGroup[$i][0]
$SpellNamePosition[$i] = $SpellGroup[$i][1]
$SpellHeight[$i] = $SpellGroup[$i][2]
Next
Global $iTotalSpellSpace = 0
Global $PixelTopLeft[0]
Global $PixelBottomLeft[0]
Global $PixelTopRight[0]
Global $PixelBottomRight[0]
Global $PixelTopLeftFurther[0]
Global $PixelBottomLeftFurther[0]
Global $PixelTopRightFurther[0]
Global $PixelBottomRightFurther[0]
Global $PixelMine[0]
Global $PixelElixir[0]
Global $PixelDarkElixir[0]
Global $PixelNearCollector[0]
Global $PixelRedArea[0]
Global $PixelRedAreaFurther[0]
Global Enum $eVectorLeftTop, $eVectorRightTop, $eVectorLeftBottom, $eVectorRightBottom
Global $isCCDropped = False
Global $isHeroesDropped = False
Global $DeployCCPosition[2] = [-1, -1]
Global $DeployHeroesPosition[2] = [-1, -1]
Global $debugClick = 0
Global $DESTOLoc = ""
Global $dropAllOnSide = 1
Global $AttacksWon = 0
Global $DefensesWon = 0
Global $TroopsDonated = 0
Global $TroopsReceived = 0
Global $LootFileName = ""
Global $sTimeStopAtk[$iModeCount]
Global $sTimeStopAtk2[$iModeCount]
Global $ichkTimeStopAtk[$iModeCount]
Global $ichkTimeStopAtk2[$iModeCount]
Global $ichkEndNoResources[$iModeCount]
Global $ichkTimeStopAtk[$iModeCount]
Global $ichkTimeStopAtk2[$iModeCount]
Global $stxtMinGoldStopAtk2[$iModeCount]
Global $stxtMinElixirStopAtk2[$iModeCount]
Global $stxtMinDarkElixirStopAtk2[$iModeCount]
Global $ichkEndOneStar[$iModeCount]
Global $ichkEndTwoStars[$iModeCount]
Global $iUpgradeSlots = 12
Global $aUpgrades[$iUpgradeSlots][8]
For $i = 0 To $iUpgradeSlots - 1
$aUpgrades[$i][0] = -1
$aUpgrades[$i][1] = -1
$aUpgrades[$i][2] = -1
$aUpgrades[$i][3] = ""
$aUpgrades[$i][4] = ""
$aUpgrades[$i][5] = ""
$aUpgrades[$i][6] = ""
$aUpgrades[$i][7] = ""
Next
Global $picUpgradeStatus[$iUpgradeSlots], $ipicUpgradeStatus[$iUpgradeSlots]
Global $picUpgradeType[$iUpgradeSlots], $txtUpgradeX[$iUpgradeSlots], $txtUpgradeY[$iUpgradeSlots], $chkbxUpgrade[$iUpgradeSlots]
Global $txtUpgradeValue[$iUpgradeSlots], $chkUpgrdeRepeat[$iUpgradeSlots], $ichkUpgrdeRepeat[$iUpgradeSlots],$txtUpgradeLevel[$iUpgradeSlots]
Global $itxtUpgradeLevel[$iUpgradeSlots], $ichkbxUpgrade[$iUpgradeSlots ], $txtUpgradeName[$iUpgradeSlots ],$txtUpgradeTime[$iUpgradeSlots]
Global $txtUpgradeEndTime[$iUpgradeSlots]
Global $itxtUpgrMinGold, $itxtUpgrMinElixir, $txtUpgrMinDark, $itxtUpgrMinDark
$itxtUpgrMinGold = 250000
$itxtUpgrMinElixir = 250000
$itxtUpgrMinDark = 3000
Global $chkSaveWallBldr, $iSaveWallBldr
Global $pushLastModified = 0
Global $aLabPos[2] = [-1, -1]
Global $iChkLab, $iCmbLaboratory, $iFirstTimeLab
Global $sLabUpgradeTime = ""
Global Const $aSearchCost[11] =  [10,  50,  75,  110,  170,  250,  380,  580,  750,  900,  1000]
Global $ichkDeleteLogs = 1
Global $iDeleteLogsDays = 2
Global $ichkDeleteTemp = 1
Global $iDeleteTempDays = 2
Global $ichkDeleteLoots = 1
Global $iDeleteLootsDays = 2
Global $idisposewindows
Global $icmbDisposeWindowsPos
Global $iWAOffsetX = 0
Global $iWAOffsetY = 0
Global $iPlannedDonateHours[24]
Global $iPlannedRequestCCHours[24]
Global $iPlannedDropCCHours[24]
Global $iPlannedDonateHoursEnable
Global $iPlannedRequestCCHoursEnable
Global $iPlannedDropCCHoursEnable
Global $iPlannedBoostBarracksHours[24]
For $i = 0 To 23
$iPlannedBoostBarracksHours[$i] = 1
Next
Global $ichkbtnScheduler
Global $iPlannedattackHours[24]
For $i = 0 To 23
$iPlannedattackHours[$i] = 1
Next
Global $iPlannedAttackWeekDays[7]
For $i = 0 To 6
$iPlannedAttackWeekDays[$i] = 1
Next
Global $hourLoot
Global $fullArmy1 = False
Global $iShareAttack = 0
Global $iShareminGold = 300000
Global $iShareminElixir = 300000
Global $iSharemindark = 0
Global $sShareMessage = StringReplace("Nice|Good|Thanks|Wowwww", "|", @CRLF)
Global $iShareMessageEnable = 0
Global $iShareMessageSearch = 0
Global $iShareAttackNow = 0
Global $dLastShareDateApp = _Date_Time_GetLocalTime()
Global $dLastShareDate = _DateAdd("n", -60, _Date_Time_SystemTimeToDateTimeStr($dLastShareDateApp, 1))
Global $iUseRandomClick = 0
Global $iScreenshotType = 0
Global $ichkScreenshotHideName = 1
Global $ichkTotalCampForced = 0
Global $iValueTotalCampForced = 200
Global $ichkSinglePBTForced = 0
Global $iValueSinglePBTimeForced = 18
Global $iValuePBTimeForcedExit = 15
Global $bWaitShield = False
Global $bGForcePBTUpdate = False
Global $iMakeScreenshotNow = False
Global $lastversion = ""
Global $lastmessage = ""
Global $ichkVersion = 1
Global $oldversmessage = ""
Global $numBarracks = 0
Global $numBarracksAvaiables = 0
Global $numDarkBarracks = 0
Global $numDarkBarracksAvaiables = 0
Global $numFactorySpell = 0
Global $numFactorySpellAvaiables = 0
Global $numFactoryDarkSpell = 0
Global $numFactoryDarkSpellAvaiables = 0
Global $btnpos = [[114, 535 + $midOffsetY], [228, 535 + $midOffsetY], [288, 535 + $midOffsetY], [348, 535 + $midOffsetY], [409, 535 + $midOffsetY], [494, 535 + $midOffsetY], [555, 535 + $midOffsetY], [637, 535 + $midOffsetY], [698, 535 + $midOffsetY]]
Global $Trainavailable = [1, 0, 0, 0, 0, 0, 0, 0, 0]
Global $BonusLeagueG, $BonusLeagueE, $BonusLeagueD, $LeagueShort
Global $League[22][4] = [  ["0", "Bronze III", "0", "B3"], ["1000", "Bronze II", "0", "B2"], ["1300", "Bronze I", "0", "B1"],  ["2600", "Silver III", "0", "S3"], ["3700", "Silver II", "0", "S2"], ["4800", "Silver I", "0", "S1"],  ["10000", "Gold III", "0", "G3"], ["13500", "Gold II", "0", "G2"], ["17000", "Gold I", "0", "G1"],  ["40000", "Crystal III", "120", "c3"], ["55000", "Crystal II", "220", "c2"], ["70000", "Crystal I", "320", "c1"],  ["110000", "Master III", "560", "M3"], ["135000", "Master II", "740", "M2"], ["160000", "Master I", "920", "M1"],  ["200000", "Champion III", "1220", "C3"], ["225000", "Champion II", "1400", "C2"], ["250000", "Champion I", "1580", "C1"],  ["280000", "Titan III", "1880", "T3"], ["300000", "Titan II", "2060", "T2"], ["320000", "Titan I", "2240", "T1"],  ["340000", "Legend", "2400", "LE"]]
Global $iTaBChkAttack = 0x01
Global $iTaBChkIdle = 0x02
Global $iTaBChkTime = 0x04
Global $bDisableBreakCheck = False
Global $sPBStartTime = ""
Global $aShieldStatus = ["", "", ""]
Global Enum $eSideBuildingDES, $eSideBuildingTH
Global $BuildingLoc, $BuildingLocX = 0, $BuildingLocY = 0
Global $dropQueen, $dropKing, $dropWarden
Global $BuildingEdge, $BuildingToLoc = ""
Global $saveiChkTimeStopAtk[$iModeCount], $saveiChkTimeStopAtk2[$iModeCount], $saveichkEndOneStar[$iModeCount], $saveichkEndTwoStars[$iModeCount]
Global $DarkLow
Global $DESideEB, $DELowEndMin = 25, $DisableOtherEBO
Global $DEEndAq, $DEEndBk, $DEEndOneStar
Global $SpellDP[2] = [0, 0]
Global $PixelMine[0]
Global $PixelElixir[0]
Global $PixelDarkElixir[0]
Global $PixelNearCollectorTopLeft[0]
Global $PixelNearCollectorBottomLeft[0]
Global $PixelNearCollectorTopRight[0]
Global $PixelNearCollectorBottomRight[0]
Global $GoldStoragePos
Global $ElixirStoragePos
Global $darkelixirStoragePos
Global $isSnipeWhileTrain = False
Global $SnipeChangedSettings = False
Global $tempSnipeWhileTrain[8] = [0, 0, 0, 0, 0, 0, 0, 0]
Global $iChkSnipeWhileTrain = 0
Global $itxtSearchlimit = 15
Global $itxtminArmyCapacityTHSnipe = 35
Global $itxtSWTtiles = 1
Global $iChkRestartSearchLimit = 1
Global $iRestartSearchlimit = 25
Global $Is_SearchLimit = False
Global $canRequestCC = True
Global $ichkUpgradeKing = 0
Global $ichkUpgradeQueen = 0
Global $ichkUpgradeWarden = 0
Global $aKingUpgCost[40] = [10, 12.5, 15, 17.5, 20, 22.5, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180, 185, 190]
Global $aQueenUpgCost[40] = [40, 22.5, 25, 27.5, 30, 32.5, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180, 185, 190, 195, 200]
Global $aWardenUpgCost[20] = [6, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.4, 8.8, 9.1, 9.4, 9.6, 9.8, 10]
Global $MinorObstacle = False
Global Const $dirLanguages = @ScriptDir & "\Languages\"
Global $sLanguage = "English"
Global $aLanguageFile[1][2]
Global Const $sDefaultLanguage = "English"
Global $aLanguage[1][1]
Global $iDetectedImageType = 0
Global $iDeadBase75percent = 1
Global $iDeadBase75percentStartLevel = 4
Global $scmbDBScriptName = "Barch four fingers"
Global $scmbABScriptName = "Barch four fingers"
Global $ichkUseAttackDBCSV = 0
Global $ichkUseAttackABCSV = 0
Global $attackcsv_locate_mine = 0
Global $attackcsv_locate_elixir = 0
Global $attackcsv_locate_drill = 0
Global $attackcsv_locate_gold_storage = 0
Global $attackcsv_locate_elixir_storage = 0
Global $attackcsv_locate_dark_storage = 0
Global $attackcsv_locate_townhall = 0
Global $debugresourcesoffset = 0
Global $continuesearchelixirdebug = 0
Global $MilkingAttackDropGoblinAlgorithm = 1
Global $MilkingAttackCheckStructureDestroyedAfterAttack = 0
Global $MilkingAttackCheckStructureDestroyedBeforeAttack = 0
Global $MilkFarmLocateMine = 1
Global $MilkFarmLocateElixir = 1
Global $MilkFarmLocateDrill = 1
Global $MilkFarmElixirParam = StringSplit("-1|-1|-1|-1|-1|-1|2|2|2", "|", 2)
Global $MilkFarmMineParam = 5
Global $MilkFarmDrillParam = 1
Global $MilkFarmAttackElixirExtractors = 1
Global $MilkFarmAttackGoldMines = 1
Global $MilkFarmAttackDarkDrills = 1
Global $MilkFarmLimitGold = 9995000
Global $MilkFarmLimitElixir = 9995000
Global $MilkFarmLimitDark = 200000
Global $MilkFarmResMaxTilesFromBorder = 0
Global $MilkFarmTroopForWaveMin = 4
Global $MilkFarmTroopForWaveMax = 6
Global $MilkFarmTroopMaxWaves = 3
Global $MilkFarmDelayFromWavesMin = 3000
Global $MilkFarmDelayFromWavesMax = 5000
Global $MilkFarmTHMaxTilesFromBorder = 1
Global $MilkFarmAlgorithmTh = "Queen&GobTakeTH"
Global $MilkFarmSnipeEvenIfNoExtractorsFound = 0
Global $MilkFarmOffsetX = 56
Global $MilkFarmOffsetY = 41
Global $MilkFarmOffsetXStep = 35
Global $MilkFarmOffsetYStep = 26
Global $CapacityStructureElixir0, $CapacityStructureElixir1, $CapacityStructureElixir2, $CapacityStructureElixir3, $CapacityStructureElixir4, $CapacityStructureElixir5, $CapacityStructureElixir6, $CapacityStructureElixir7, $CapacityStructureElixir8
Global $DestroyedMineIMG0, $DestroyedMineIMG1, $DestroyedMineIMG2, $DestroyedMineIMG3, $DestroyedMineIMG4, $DestroyedMineIMG5, $DestroyedMineIMG6, $DestroyedMineIMG7, $DestroyedMineIMG8
Global $DestroyedElixirIMG0, $DestroyedElixirIMG1, $DestroyedElixirIMG2, $DestroyedElixirIMG3, $DestroyedElixirIMG4, $DestroyedElixirIMG5, $DestroyedElixirIMG6, $DestroyedElixirIMG7, $DestroyedElixirIMG8
Global $DestroyedDarkIMG0, $DestroyedDarkIMG1, $DestroyedDarkIMG2, $DestroyedDarkIMG3, $DestroyedDarkIMG4, $DestroyedDarkIMG5, $DestroyedDarkIMG6, $DestroyedDarkIMG7, $DestroyedDarkIMG8
Global $MilkFarmForcetolerance = 0
Global $MilkFarmForcetolerancenormal = 31
Global $MilkFarmForcetoleranceboosted = 31
Global $MilkFarmForcetolerancedestroyed = 31
Global $MilkAttackType=1
Global $MilkQuicklyRestart= 150
Global $duringMilkingAttack = 0
Global $MilkingAttackStructureOrder = 1
Global $MilkAttackAfterTHSnipe = 0
Global $MilkAttackAfterScriptedAtk = 0
Global $debugMilkingIMGmake = 0
Global $MilkAttackCSVscript = "Barch four fingers"
Global $MilkFarmOffsetMine[9] = ["1-1", "1-1", "0-2", "0-4", "1-2", "1-1", "3-5", "3-6", "3-5"]
Global $MilkFarmOffsetElixir[9] = ["1-11", "1-11", "1-9", "1-13", "0-11", "0-11", "0-13", "0-11", "0-14"]
Global $MilkFarmOffsetDark[7] = ["0-0", "1-4", "1-3", "0-5", "4-8", "0-4", "0-3"]
Global $iGUIStyle = 1
Global $color1 = 0xd0dfd7
Global $color2 = 0xb8cec4
Global $color3 = 0x9bbbb0
Global $color4 = 0x7ba296
Global $color0 = 0x707070
Global $MilkFarmObjectivesSTR = ""
Global $milkingAttackOutside = 0
Global $hCollectorGUI = 0
Global $iDeadBase75percent = 1
Global $iDeadBase75percentStartLevel = 4
Global $hMilkGUI
Global $hSearchReductionGUI
Global $hTHBullyGUI
Global $hWeakBaseGUI
Global $hAlgorithmAllTroopsConfigGUI
Global $hAlgorithmAttackCSVConfigGUI
Global $hUnbreakableGUI
Global $hNotifyGUI
Global $hUpgradeGUI
Global $hUpgradeWallGUI
Global $hDonateGUI
Global $hHaltAndResumeGUI
Global $hBotOptionsGUI
Global $hGUI_BotDebug
Global $hLocateManuallyGUI
Global $hBoostBarracksGUI
Global $hAttHSchedGUI
Global $hExtra1GUI
Global $hExtra2GUI
Global $hShareReplayGUI
Global $hSkipTrappedTHGUI
Global $hTrophiesGUI
Global $hEndbattleABGUI
Global $hEndbattleDBGUI
Global $hEndbattleTSGUI
Global $hPresetGUI
Global $gui3open = 0
Global $guiSearchReductionopen = 0
Global $guiTHBullyOpen = 0
Global $guiWeakBaseOpen = 0
Global $guiAlgorithmAllTroopsConfigOpen = 0
Global $guiAlgorithmAttackCSVConfigOpen = 0
Global $guiUnbreakableOpen = 0
Global $guiNotifyOpen = 0
Global $guiUpgradeOpen = 0
Global $guiUpgradeWallOpen = 0
Global $guiDonateOpen = 0
Global $guiHaltAndResumeOpen = 0
Global $guiBotOptionsOpen = 0
Global $guiLocateManuallyOpen = 0
Global $guiBoostBarracksOpen = 0
Global $guiAttHSchedOpen = 0
Global $guiExtra1Open = 0
Global $guiExtra2Open = 0
Global $guiReplayShareOpen = 0
Global $guiSkipTrappedTHOpen = 0
Global $guiTrophiesOpen = 0
Global $guiEndBattleABOpen = 0
Global $guiEndBattleDBOpen = 0
Global $guiEndBattleTSOpen = 0
Global $guiPresetOpen = 0
SetDebugLog("@AutoItExe: " & @AutoItExe)
SetDebugLog("@ScriptFullPath: " & @ScriptFullPath)
SetDebugLog("@WorkingDir: " & @WorkingDir)
SetDebugLog("@AutoItPID: " & @AutoItPID)
SetDebugLog("@OSArch: " & @OSArch)
SetDebugLog("@OSVersion: " & @OSVersion)
SetDebugLog("@OSBuild: " & @OSBuild)
SetDebugLog("@OSServicePack: " & @OSServicePack)
SetDebugLog("Primary Display: " & @DesktopWidth & " x " & @DesktopHeight & " - " & @DesktopDepth & "bit")
Global $__TEST_ERROR_ADB_DEVICE_NOT_FOUND = False
Global $__TEST_ERROR = $__TEST_ERROR_ADB_DEVICE_NOT_FOUND
Global $__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY = 0
Global $__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY = 0
Global $__TEST_ERROR_SLOW_ADB_CLICK_DELAY = 0
Global $DefaultCocDiamond = "430,70|787,335|430,605|67,333"
Global $ExtendedCocDiamond = "430,25|840,335|430,645|15,333"
Global $DefaultCocSearchArea = "70|70|720|540"
Global $ExtendedCocSearchArea = "15|25|825|625"
Global $ToleranceImgLoc = 0.95
Global $SecondaryInputFile = ""
Global $SecondaryOutputFile = ""
Global $quicklyfirststart = true
Global $configLoaded = false
Global $chkMakeIMGCSV
Global $THSnipeBeforeDBEnable = 0 , $THSnipeBeforeLBEnable = 0
Global $THSnipeBeforeDBTiles = 0 , $THSnipeBeforeLBTiles = 0
Global $THSnipeBeforeDBScript = 0 , $THSnipeBeforeLBScript = 0
Global $ichkCloseWaitTrain = 0, $ichkCloseWaitSpell, $ichkCloseWaitHero, $ibtnCloseWaitStop = 0, $ibtnCloseWaitStopRandom, $ibtnCloseWaitExact, $ibtnCloseWaitRandom, $icmbCloseWaitRdmPercent, $ichkCloseWaitEnable = 1
Global $icmbMinimumTimeClose = 2, $lblCloseWaitingTroops, $lblSymbolWaiting, $lblWaitingInMinutes
Global $aTimeTrain[3] = [0, 0, 0]
Global $iCCRemainTime = 0
Global $iNbrOfWallsUpped = 0
Global $itxtWall04ST=0, $itxtWall05ST=0, $itxtWall06ST=0, $itxtWall07ST=0, $itxtWall08ST=0, $itxtWall09ST=0, $itxtWall10ST=0, $itxtWall11ST=0
Global $chkLvl6Enabled = 1
Global $chkLvl7Enabled = 1
Global $chkLvl8Enabled = 1
Global $chkLvl9Enabled = 1
Global $chkLvl10Enabled = 1
Global $chkLvl11Enabled = 1
Global $chkLvl12Enabled = 1
Global $cmbLvl6Fill
Global $cmbLvl7Fill
Global $cmbLvl8Fill
Global $cmbLvl9Fill
Global $cmbLvl10Fill
Global $cmbLvl11Fill
Global $cmbLvl12Fill
Global $toleranceOffset
Global $ichkTSActivateCamps2, $iEnableAfterArmyCamps2
Global $iShouldRearm = True
Global $BoostedButtonX = 0
Global $BoostedButtonY = 0
Global $IsFullArmywithHeroesAndSpells = False
Global $BarrackCapacity[4]
Global $DarkBarrackCapacity[2]
Global $InitBoostTime[4][2] = [[0, 0], [0, 0], [0, 0], [0, 0]]
Global $InitBoostTimeDark[2][2] = [[0, 0], [0, 0]]
Global $BarrackTimeRemain[4]
Global $DarkBarrackTimeRemain[2]
Global $ichkWASCloseWaitEnable = 0
Global $LetsSortNB = False
Global $LetsSortDB = False
Global $totalPossibleBoostTimes = 0
Global $totalPossibleBoostBarrackses = 0
Global $BoostedBarrackses = 0
Global $totalPossibleBoostTimesDARK = 0
Global $totalPossibleBoostBarracksesDARK = 0
Global $BoostedBarracksesDARK = 0
Global $Form1, $btnValidateLevels, $btnCalcTotals
Global $PixelEaglePos[2] = [-2, -2]
Global $PixelInfernoPos[2] = [-2, -2]
Global $PixelADefensePos[2] = [-2, -2]
Global $AllPixelEaglePos[1][3] = [[-2, -2, -2]]
Global $AllPixelInfernoPos[1][3] = [[-2, -2, -2]]
Global $AllPixelADefensePos[1][3] = [[-2, -2, -2]]
Global $ichkUseQTrain = 1
Global 	$iRadio_Army1, $iRadio_Army2, $iRadio_Army3
Global $ichkSmartZap = 0
Global $ichkSmartZapDB = 1
Global $ichkSmartZapSaveHeroes = 1
Global $itxtMinDE = 250
Global $ichkNoobZap = 0
Global $itxtExpectedDE = 95
Global $smartZapGain = 0
Global $numLSpellsUsed = 0
Global $iOldsmartZapGain = 0, $iOldNumLTSpellsUsed = 0
Global Const $drillLevelHold[6] = [120, 225, 405, 630, 960, 1350]
Global Const $drillLevelSteal[6] = [59, 102, 172, 251, 343, 479]
Global $DebugSmartZap = 0
Global $sMinTimeCloseATK = 15
Global $iGUIEnabled = True
Global $lastModversion = ""
Global $lastModmessage = ""
Global $oldModversmessage = ""
Global $MinimumPriority, $MaxActionsNumber, $ActionToDo
Global $SetActionPriority[13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $FrequenceChain = "Never|Sometimes|Frequently|Often|Very Often"
Global $ReplayChain = "1|2|4"
Global $ichkUseBotHumanization, $ichkUseAltRClick, $icmbMaxActionsNumber, $ichkCollectAchievements, $ichkLookAtRedNotifications
Global $icmbPriority[13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $icmbMaxSpeed[2] = [0, 0]
Global $icmbPause[2] = [0, 0]
Global $ihumanMessage[2] = ["", ""]
Global $cmbPriority[13] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Global $cmbMaxSpeed[2] = [0, 0]
Global $cmbPause[2] = [0, 0]
Global $humanMessage[2] = ["", ""]
Global $ReplayDuration[2] = [0, 0]
Global $OnReplayWindow, $ReplayToPause
Global $QuickMISX = 0, $QuickMISY = 0
Global $LastLayout = 0
Global $iChkWaitForCastleSpell[$iModeCount]
Global $iCmbWaitForCastleSpell[$iModeCount]
Global $iChkWaitForCastleTroops[$iModeCount]
Global $RunModeChart = 0
Global $iNameMyBot = ""
Global $ichkEnableSuperXP = 0, $irbSXTraining = 1, $ichkSXBK = 0, $ichkSXAQ = 0, $ichkSXGW = 0, $iStartXP = 0, $iCurrentXP = 0, $iGainedXP = 0, $iGainedXPHour = 0
Global $ichkForceBrewBeforeAttack = 0
Global $CurBaseRedLine[2] = ["", ""]
Global $DCD = "440,70|825,344|440,640|55,344"
Global $ECD = "440,22|860,344|440,670|2,344"
If FileExists($config) Or FileExists($building) Then
readConfig()
EndIf
_GDIPlus_Startup()
Global $hSplash = 0, $hSplashProgress, $lSplashStatus, $lSplashTitle
Global $iTotalSteps = 11, $iCurrentStep = 0
#Region Splash
Local $sSplashImg = @ScriptDir & "\Images\logo.jpg"
Local $hImage, $iX, $iY
Local $iT = 20
Local $iB = 10
If $ichkDisableSplash = 0 Then
Local $hSplashImg = _GDIPlus_BitmapCreateFromFile($sSplashImg)
$iX = _GDIPlus_ImageGetWidth($hSplashImg)
$iY = _GDIPlus_ImageGetHeight($hSplashImg)
$hSplash = GUICreate("", $iX, $iY + $iT + $iB + 60, -1, -1, BitOR($WS_POPUP, $WS_BORDER), BitOR($WS_EX_TOPMOST, $WS_EX_WINDOWEDGE, $WS_EX_TOOLWINDOW))
GUISetBkColor($COLOR_WHITE, $hSplash)
_GUICtrlCreatePic($hSplashImg, 0, $iT)
$lSplashTitle = GUICtrlCreateLabel($sBotTitle, 15, $iY + $iT + $iB + 3, $iX - 30, 15, $SS_CENTER)
$hSplashProgress = GUICtrlCreateProgress(15, $iY + $iT + $iB + 20, $iX - 30, 10, $PBS_SMOOTH, BitOR($WS_EX_TOPMOST, $WS_EX_WINDOWEDGE, $WS_EX_TOOLWINDOW))
$lSplashStatus = GUICtrlCreateLabel("", 15, $iY + $iT + $iB + 38, $iX - 30, 15, $SS_CENTER)
_GDIPlus_BitmapDispose($hSplashImg)
GUISetState(@SW_SHOWNOACTIVATE, $hSplash)
EndIf
#EndRegion
Global $aIsReloadError[4] = [457, 301 + $midOffsetY, 0x33B5E5, 10]
Global $aIsMain[4] = [283, 29, 0x4693bd, 20]
Global $aIsDPI125[4] = [355, 35, 0x399CB8, 15]
Global $aIsDPI150[4] = [426, 42, 0x348FAA, 15]
Global $aIsMainGrayed[4] = [283, 29, 0x244A5F, 15]
Global $aTopLeftClient[4] = [1, 1, 0x000000, 0]
Global $aTopMiddleClient[4] = [475, 1, 0x000000, 0]
Global $aTopRightClient[4] = [850, 1, 0x000000, 0]
Global $aBottomRightClient[4] = [850, 675 + $bottomOffsetY, 0x000000, 0]
Global $aIsInactive[4] = [457, 300 + $midOffsetY, 0x33B5E5, 20]
Global $aIsConnectLost[4] = [255, 271 + $midOffsetY, 0x33B5E5, 20]
Global $aIsCheckOOS[4] = [223, 272 + $midOffsetY, 0x33B5E5, 20]
Global $aIsMaintenance[4] = [350, 273 + $midOffsetY, 0x33B5E5, 20]
Global $aReloadButton[4] = [443, 408 + $midOffsetY, 0x282828, 10]
Global $aAttackButton[2] = [60, 614 + $bottomOffsetY]
Global $aFindMatchButton[4] = [195, 480 + $bottomOffsetY, 0xF0B028, 10]
Global $aFindMatchButton2[4] = [195, 480 + $bottomOffsetY, 0xD84D00, 10]
Global $aIsAttackShield[4] = [250, 415 + $midOffsetY, 0xE8E8E0, 10]
Global $aAway[2] = [1, 40]
Global $aRemoveShldButton[4] = [470, 18, 0xA80408, 10]
Global $aNoShield[4] = [448, 20, 0x43484B, 15]
Global $aHaveShield[4] = [455, 19, 0xF0F8FB, 15]
Global $aHavePerGuard[4] = [455, 19, 0x12120E, 15]
Global $aShieldInfoButton[4] = [472, 11, 0x6DB0D3, 10]
Global $aIsShieldInfo[4] = [645, 195, 0xE00408, 20]
Global $aSurrenderButton[4] = [70, 546 + $bottomOffsetY, 0xC00000, 20]
Global $aConfirmSurrender[4] = [500, 415 + $midOffsetY, 0x60AC10, 20]
Global $aCancelFight[4] = [822, 48, 0xD80408, 20]
Global $aCancelFight2[4] = [830, 59, 0xD80408, 20]
Global $aEndFightSceneBtn[4] = [429, 519 + $midOffsetY, 0xB8E35F, 20]
Global $aEndFightSceneAvl[4] = [241, 196 + $midOffsetY, 0xFFF090, 20]
Global $aReturnHomeButton[4] = [376, 567 + $midOffsetY, 0x60AC10, 20]
Global $aChatTab[4] = [330, 351 + $midOffsetY, 0xFFFFFF, 20]
Global $aOpenChat[2] = [20, 350 + $midOffsetY]
Global $aClanTab[2] = [220, 20]
Global $aClanInfo[2] = [100, 60]
Global $aArmyCampSize[2] = [192, 144 + $midOffsetY]
Global $aArmySpellSize[2] = [184, 391 + $midOffsetY]
Global $aArmyCCRemainTime[2] = [652, 266 + $midOffsetY]
Global $aIsCampNotFull[4] = [149, 150 + $midOffsetY, 0x761714, 20]
Global $aIsCampFull[4] = [128, 151 + $midOffsetY, 0xFFFFFF, 10]
Global $aBarrackFull[4] = [388, 154 + $midOffsetY, 0xE84D50, 20]
Global $aBuildersDigits[2] = [324, 21]
Global $aLanguageCheck1[4] = [326, 8, 0xF9FAF9, 20]
Global $aLanguageCheck2[4] = [329, 9, 0x060706, 20]
Global $aLanguageCheck3[4] = [348, 12, 0x040403, 20]
Global $aLanguageCheck4[4] = [354, 11, 0x090908, 20]
Global $aTrophies[2] = [65, 74]
Global $aNoCloudsAttack[4] = [757, 1, 0xFDFEFF, 30]
Global $aNoCloudsAttack2[4] = [25, 606, 0xC00000, 10]
Global $aMessageButton[2] = [38, 143]
Global $aArmyTrainButton[2] = [40, 525 + $bottomOffsetY]
Global $aWonOneStar[4] = [714, 538 + $bottomOffsetY, 0xC0C8C0, 20]
Global $aWonTwoStar[4] = [739, 538 + $bottomOffsetY, 0xC0C8C0, 20]
Global $aWonThreeStar[4] = [763, 538 + $bottomOffsetY, 0xC0C8C0, 20]
Global $aArmyOverviewTest[4] = [530, 463 + $midOffsetY, 0x878782, 20]
Global $aCancRequestCCBtn[4] = [340, 250, 0xCC4010, 20]
Global $aSendRequestCCBtn[2] = [524, 250]
Global $atxtRequestCCBtn[2] = [430, 140]
Global $aIsDarkElixirFull[4] = [709, 134, 0x1A0026, 10]
Global $aIsGoldFull[4] = [660, 33, 0xD4B100, 6]
Global $aIsElixirFull[4] = [660, 84, 0xAE1AB3, 6]
Global $aConfirmCoCExit[2] = [515, 410 + $midOffsetY]
Global $aPerkBtn[4] = [95, 243 + $midOffsetY, 0x7cd8e8, 10]
Global $aIsGemWindow1[4] = [573, 256 + $midOffsetY, 0xDD0408, 20]
Global $aIsGemWindow2[4] = [577, 266 + $midOffsetY, 0xBF1218, 20]
Global $aIsGemWindow3[4] = [586, 266 + $midOffsetY, 0xBC1218, 20]
Global $aIsGemWindow4[4] = [595, 266 + $midOffsetY, 0xBC1218, 20]
Global $aLootCartBtn[2] = [430, 640 + $bottomOffsetY]
Global $aCleanYard[4] = [418, 587 + $bottomOffsetY, 0xE1debe, 20]
Global $aIsTrainPgChk1[4]	  = [717, 120 + $midOffsetY, 0xE0070A, 10]
Global $aIsTrainPgChk2[4]	  = [762, 328 + $midOffsetY, 0xF18439, 10]
Global $aRtnHomeCloud1[4]	  = [56, 592 + $bottomOffsetY, 0x0A223F, 15]
Global $aRtnHomeCloud2[4]	  = [72, 592 + $bottomOffsetY, 0x103F7E, 15]
Global $aKingHealth = [-1, 572 + $bottomOffsetY, 0x00b29e, 15]
Global $aQueenHealth = [-1, 572 + $bottomOffsetY, 0x008227, 15]
Global $aWardenHealth = [-1, 568 + $bottomOffsetY, 0x472b63, 15]
Global $aWonOneStarAtkRprt[4] = [325, 180 + $midOffsetY, 0xC8CaC4, 30]
Global $aWonTwoStarAtkRprt[4] = [398, 180 + $midOffsetY, 0xD0D6D0, 30]
Global $aWonThreeStarAtkRprt[4] = [534, 180 + $midOffsetY, 0xC8CAC7, 30]
Global Const $TrainBarb[4]  = [87, 372 + $midOffsetY, 0xFFD028, 40]
Global Const $TrainArch[4]  = [72, 474 + $midOffsetY, 0xE03E68, 40]
Global Const $TrainGiant[4] = [155, 372 + $midOffsetY, 0xF07908, 40]
Global Const $TrainGobl[4]  = [166, 476 + $midOffsetY, 0x407428, 40]
Global Const $TrainWall[4]  = [264, 377 + $midOffsetY, 0x564B58, 40]
Global Const $TrainBall[4]  = [284, 491 + $midOffsetY, 0x564952, 40]
Global Const $TrainWiza[4]  = [366, 364 + $midOffsetY, 0xFFECD0, 40]
Global Const $TrainHeal[4]  = [374, 482 + $midOffsetY, 0xB8FCFE, 40]
Global Const $TrainDrag[4]  = [470, 373 + $midOffsetY, 0x483D68, 40]
Global Const $TrainPekk[4]  = [470, 473 + $midOffsetY, 0xD8E7E8, 40]
Global Const $TrainBabyD[4] = [552, 375 + $midOffsetY, 0x88BC40, 40]
Global Const $TrainMine[4]  = [562, 518 + $midOffsetY, 0x403430, 40]
Global Const $TrainMini[4] = [477, 384 + $midOffsetY, 0x30689F, 40]
Global Const $TrainHogs[4] = [491, 467 + $midOffsetY, 0x603C30, 40]
Global Const $TrainValk[4] = [578, 352 + $midOffsetY, 0xFF5E14, 40]
Global Const $TrainGole[4] = [579, 518 + $midOffsetY, 0x706458, 40]
Global Const $TrainWitc[4] = [674, 354 + $midOffsetY, 0x6864B3, 40]
Global Const $TrainLava[4] = [702, 497 + $midOffsetY, 0x5F5849, 40]
Global Const $TrainBowl[4] = [784, 365 + $midOffsetY, 0x9084F4, 40]
Global $TrainLSpell[4] = [ 70, 405 + $midOffsetY, 0x0A47EE, 40]
Global $TrainRSpell[4] = [170, 405 + $midOffsetY, 0x501886, 40]
Global $TrainFSpell[4] = [270, 405 + $midOffsetY, 0x29ADD0, 40]
Global $TrainHSpell[4] = [ 70, 505 + $midOffsetY, 0xDAAF48, 40]
Global $TrainJSpell[4] = [170, 505 + $midOffsetY, 0x4CCC08, 40]
Global $TrainCSpell[4] = [270, 505 + $midOffsetY, 0x20DDD8, 40]
Global $TrainPSpell[4] = [375, 405 + $midOffsetY, 0xF88010, 40]
Global $TrainESpell[4] = [375, 505 + $midOffsetY, 0xBF8B58, 40]
Global $TrainHaSpell[4] = [469, 409 + $midOffsetY, 0xf267a7, 40]
Global $TrainSkSpell[4] = [475, 505 + $midOffsetY, 0xE01800, 40]
Global $FullLSpell[4] = [74, 392 + $midOffsetY, 0x515151, 40]
Global $FullRSpell[4] = [186, 405 + $midOffsetY, 0x696969, 40]
Global $FullFSpell[4] = [266, 395 + $midOffsetY, 0x929292, 40]
Global $FullHSpell[4] = [70, 505 + $midOffsetY, 0xB1B1B1, 40]
Global $FullJSpell[4] = [170, 495 + $midOffsetY, 0xABABAB, 40]
Global $FullCSpell[4] = [269, 502 + $midOffsetY, 0xA4A4A4, 40]
Global $FullPSpell[4] = [375, 410 + $midOffsetY, 0x929292, 40]
Global $FullESpell[4] = [370, 510 + $midOffsetY, 0x858585, 40]
Global $FullHaSpell[4] = [470, 410 + $midOffsetY, 0x929292, 40]
Global $FullSkSpell[4] = [475, 510 + $midOffsetY, 0x4A4A4A, 40]
Global $GemLSpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $GemRSpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $GemFSpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $GemHSpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $GemJSpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $GemCSpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $GemPSpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $GemESpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $GemHaSpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $GemSkSpell[4] = [25, 340 + $midOffsetY, 0x030300, 1]
Global $NextBtn[4] = [780, 546 + $bottomOffsetY, 0xD34300, 20]
Global $aRequestTroopsAO[6] = [680, 574, 0x70BC20, 0x000000, 0x989898, 20]
Global Const $FullBarb[4] = [100, 423 + $midOffsetY, 0x7A7A7A, 45]
Global Const $FullArch[4] = [100, 529 + $midOffsetY, 0x8E8E8E, 45]
Global Const $FullGiant[4] = [199, 422 + $midOffsetY, 0x6E6E6E, 45]
Global Const $FullGobl[4] = [199, 523 + $midOffsetY, 0x6B6B6B, 45]
Global Const $FullWall[4] = [297, 429 + $midOffsetY, 0x8B8B8B, 45]
Global Const $FullBall[4] = [296, 531 + $midOffsetY, 0x878787, 45]
Global Const $FullWiza[4] = [397, 421 + $midOffsetY, 0x676767, 45]
Global Const $FullHeal[4] = [397, 522 + $midOffsetY, 0x676767, 45]
Global Const $FullDrag[4] = [496, 421 + $midOffsetY, 0x676767, 45]
Global Const $FullPekk[4] = [493, 526 + $midOffsetY, 0x818181, 45]
Global Const $FullBabyD[4] = [589, 423 + $midOffsetY, 0x747474, 40]
Global Const $FullMine[4] = [592, 523 + $midOffsetY, 0x6B6B6B, 40]
Global Const $FullMini[4] = [497, 352 + $midOffsetY, 0x787878, 15]
Global Const $FullHogs[4] = [500, 477 + $midOffsetY, 0x919191, 30]
Global Const $FullValk[4] = [573, 367 + $midOffsetY, 0x8E8E8E, 30]
Global Const $FullGole[4] = [574, 462 + $midOffsetY, 0xA9A9A9, 30]
Global Const $FullWitc[4] = [677, 392 + $midOffsetY, 0x888888, 30]
Global Const $FullLava[4] = [724, 505 + $midOffsetY, 0x969696, 30]
Global Const $FullBowl[4] = [800, 379 + $midOffsetY, 0x585858, 20]
Global Const $GemBarb[4] = [187, 372 + $midOffsetY, 0xE70A12, 30]
Global Const $GemArch[4] = [290, 372 + $midOffsetY, 0xE70A12, 30]
Global Const $GemGiant[4] = [392, 372 + $midOffsetY, 0xE70A12, 30]
Global Const $GemGobl[4] = [495, 372 + $midOffsetY, 0xE70A12, 30]
Global Const $GemWall[4] = [597, 372 + $midOffsetY, 0xE70A12, 30]
Global Const $GemBall[4] = [700, 372 + $midOffsetY, 0xE70A12, 30]
Global Const $GemWiza[4] = [346, 478 + $midOffsetY, 0xE70A12, 30]
Global Const $GemHeal[4] = [453, 478 + $midOffsetY, 0xE70A12, 30]
Global Const $GemDrag[4] = [559, 478 + $midOffsetY, 0xE70A12, 30]
Global Const $GemPekk[4] = [666, 478 + $midOffsetY, 0xE70A12, 30]
Global Const $GemBabyD[4] = [597, 478 + $midOffsetY, 0xE70A12, 30]
Global Const $GemMine[4] = [700, 478 + $midOffsetY, 0xE70A12, 30]
Global Const $GemMini[4] = [239, 378 + $midOffsetY, 0xE70A12, 30]
Global Const $GemHogs[4] = [346, 379 + $midOffsetY, 0xE70A12, 30]
Global Const $GemValk[4] = [453, 372 + $midOffsetY, 0xE70A12, 30]
Global Const $GemGole[4] = [559, 378 + $midOffsetY, 0xE70A12, 30]
Global Const $GemWitc[4] = [666, 372 + $midOffsetY, 0xE70A12, 30]
Global Const $GemLava[4] = [239, 482 + $midOffsetY, 0xE70A12, 30]
Global Const $GemBowl[4] = [342, 479 + $midOffsetY, 0xE70A12, 30]
Global Const $aOpenChatTab[4] = [19, 335 + $midOffsetY, 0xE88D27, 20]
Global Const $aCloseChat[4] = [331, 330 + $midOffsetY, 0xF0951D, 20]
Global Const $aChatDonateBtnColors[4][4] = [[0x050505, 0, -4, 30], [0x89CA31, 0, 13, 15], [0x89CA31, 0, 16, 15], [0xFFFFFF, 21, 7, 5]]
Global Const $aAtkRprtDECheck[4] = [459, 372 + $midOffsetY, 0x433350, 20]
Global Const $aAtkRprtTrophyCheck[4] = [327, 189 + $midOffsetY, 0x3B321C, 30]
Global Const $aAtkRprtDECheck2[4] = [678, 418 + $midOffsetY, 0x030000, 30]
Global Const $aRtnHomeCheck1[4] = [363, 548 + $midOffsetY, 0x78C11C, 20]
Global Const $aRtnHomeCheck2[4] = [497, 548 + $midOffsetY, 0x79C326, 20]
Global Const $aSearchLimit[6] = [19, 565, 104, 580, 0xD9DDCF, 10]
Global Const $aIsAttackPage[4] = [70, 548 + $bottomOffsetY, 0xC80000, 20]
Global Const $aImageTypeN1[4] = [237, 161, 0xD5A849, 30]
Global Const $aImageTypeN2[4] = [205, 180, 0x86A533, 30]
Global Const $aImageTypeS1[4] = [237, 161, 0xFEFDFD, 30]
Global Const $aImageTypeS2[4] = [205, 180, 0xFEFEFE, 30]
Global Const $ProfileRep01[4] = [600, 260, 0x71769F, 20]
Global $xBtnTrain = 94
Global $yBtnTrain = 30
Global $xTrainOffset = 103
Global $yTrainOffset = 103
Global $xTrain = 126
Global $yTrain = 355
Global $TrainBarbRND[4] = [$xTrain + ($xTrainOffset * 0), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 0), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainArchRND[4] = [$xTrain + ($xTrainOffset * 1), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 1), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainGiantRND[4]= [$xTrain + ($xTrainOffset * 2), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 2), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainGoblRND[4] = [$xTrain + ($xTrainOffset * 3), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 3), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainWallRND[4] = [$xTrain + ($xTrainOffset * 4), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 4), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainBallRND[4] = [$xTrain + ($xTrainOffset * 5), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 5), $yTrain + $yBtnTrain + $midOffsetY]
$yTrain = $yTrain + $yTrainOffset
Global $TrainWizaRND[4] = [$xTrain + ($xTrainOffset * 0), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 0), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainHealRND[4] = [$xTrain + ($xTrainOffset * 1), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 1), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainDragRND[4] = [$xTrain + ($xTrainOffset * 2), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 2), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainPekkRND[4] = [$xTrain + ($xTrainOffset * 3), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 3), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainBabyDRND[4] = [$xTrain + ($xTrainOffset * 4), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 4), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainMineRND[4] = [$xTrain + ($xTrainOffset * 5), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 5), $yTrain + $yBtnTrain + $midOffsetY]
Global $xTrain = 180
Global $yTrain = 355
Global $xTrainOffset = 105
Global $yTrainOffset = 105
Global $TrainMiniRND[4] = [$xTrain + ($xTrainOffset * 0), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 0), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainHogsRND[4] = [$xTrain + ($xTrainOffset * 1), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 1), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainValkRND[4] = [$xTrain + ($xTrainOffset * 2), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 2), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainGoleRND[4] = [$xTrain + ($xTrainOffset * 3), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 3), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainWitcRND[4] = [$xTrain + ($xTrainOffset * 4), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 4), $yTrain + $yBtnTrain + $midOffsetY]
$yTrain = $yTrain + $yTrainOffset
Global $TrainLavaRND[4] = [$xTrain + ($xTrainOffset * 0), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 0), $yTrain + $yBtnTrain + $midOffsetY]
Global $TrainBowlRND[4] = [$xTrain + ($xTrainOffset * 1), $yTrain + $midOffsetY, $xTrain + $xBtnTrain + ($xTrainOffset * 1), $yTrain + $yBtnTrain + $midOffsetY]
Global $aArmyTrainButtonRND[4] = [20, 540 + $midOffsetY, 55, 570 + $midOffsetY]
Global $aAttackButtonRND[4] = [20, 610 + $midOffsetY, 100, 670 + $midOffsetY]
Global $aFindMatchButtonRND[4] = [200, 510 + $midOffsetY, 300, 530 + $midOffsetY]
Global $NextBtnRND[4] = [710, 530 + $midOffsetY, 830, 570 + $midOffsetY]
Func _StringSize($sText, $iSize = 8.5, $iWeight = 400, $iAttrib = 0, $sName = "", $iMaxWidth = 0, $hWnd = 0)
If $iSize = Default Then $iSize = 8.5
If $iWeight = Default Then $iWeight = 400
If $iAttrib = Default Then $iAttrib = 0
If $sName = "" Or $sName = Default Then	$sName = _StringSize_DefaultFontName()
If Not IsString($sText) Then Return SetError(1, 1, 0)
If Not IsNumber($iSize) Then Return SetError(1, 2, 0)
If Not IsInt($iWeight) Then Return SetError(1, 3, 0)
If Not IsInt($iAttrib) Then Return SetError(1, 4, 0)
If Not IsString($sName) Then Return SetError(1, 5, 0)
If Not IsNumber($iMaxWidth) Then Return SetError(1, 6, 0)
If Not IsHwnd($hWnd) And $hWnd <> 0 Then Return SetError(1, 7, 0)
Local $aRet, $hDC, $hFont, $hLabel = 0, $hLabel_Handle
Local $iExpTab = BitAnd($iAttrib, 1)
$iAttrib = BitAnd($iAttrib, BitNot(1))
If IsHWnd($hWnd) Then
$hLabel = GUICtrlCreateLabel("", -10, -10, 10, 10)
$hLabel_Handle = GUICtrlGetHandle(-1)
GUICtrlSetFont(-1, $iSize, $iWeight, $iAttrib, $sName)
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hLabel_Handle)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, 1, 0)
EndIf
$hDC = $aRet[0]
$aRet = DllCall("user32.dll", "lparam", "SendMessage", "hwnd", $hLabel_Handle, "int", 0x0031, "wparam", 0, "lparam", 0)
If @error Or $aRet[0] = 0 Then
GUICtrlDelete($hLabel)
Return SetError(2, _StringSize_Error_Close(2, $hDC), 0)
EndIf
$hFont = $aRet[0]
Else
$aRet = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Or $aRet[0] = 0 Then Return SetError(2, 1, 0)
$hDC = $aRet[0]
$aRet = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", 90)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(3, $hDC), 0)
Local $iInfo = $aRet[0]
$aRet = DllCall("gdi32.dll", "handle", "CreateFontW", "int", -$iInfo * $iSize / 72, "int", 0, "int", 0, "int", 0,  "int", $iWeight, "dword", BitAND($iAttrib, 2), "dword", BitAND($iAttrib, 4), "dword", BitAND($iAttrib, 8), "dword", 0, "dword", 0,  "dword", 0, "dword", 5, "dword", 0, "wstr", $sName)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(4, $hDC), 0)
$hFont = $aRet[0]
EndIf
$aRet = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hFont)
If @error Or $aRet[0] = 0 Then Return SetError(2, _StringSize_Error_Close(5, $hDC, $hFont, $hLabel), 0)
Local $hPrevFont = $aRet[0]
Local $avSize_Info[4], $iLine_Length, $iLine_Height = 0, $iLine_Count = 0, $iLine_Width = 0, $iWrap_Count, $iLast_Word, $sTest_Line
Local $tSize = DllStructCreate("int X;int Y")
DllStructSetData($tSize, "X", 0)
DllStructSetData($tSize, "Y", 0)
$sText = StringRegExpReplace($sText, "((?<!\x0d)\x0a|\x0d(?!\x0a))", @CRLF)
Local $asLines = StringSplit($sText, @CRLF, 1)
For $i = 1 To $asLines[0]
If $iExpTab Then
$asLines[$i] = StringReplace($asLines[$i], @TAB, " XXXXXXXX")
EndIf
$iLine_Length = StringLen($asLines[$i])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$i], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") > $iLine_Width Then $iLine_Width = DllStructGetData($tSize, "X")
If DllStructGetData($tSize, "Y") > $iLine_Height Then $iLine_Height = DllStructGetData($tSize, "Y")
Next
If $iMaxWidth <> 0 And $iLine_Width > $iMaxWidth Then
For $j = 1 To $asLines[0]
$iLine_Length = StringLen($asLines[$j])
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $asLines[$j], "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
If DllStructGetData($tSize, "X") < $iMaxWidth - 4 Then
$iLine_Count += 1
$avSize_Info[0] &= $asLines[$j] & @CRLF
Else
$iWrap_Count = 0
While 1
$iLine_Width = 0
$iLast_Word = 0
For $i = 1 To StringLen($asLines[$j])
If StringMid($asLines[$j], $i, 1) = " " Then $iLast_Word = $i - 1
$sTest_Line = StringMid($asLines[$j], 1, $i)
$iLine_Length = StringLen($sTest_Line)
DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $sTest_Line, "int", $iLine_Length, "ptr", DllStructGetPtr($tSize))
If @error Then Return SetError(2, _StringSize_Error_Close(6, $hDC, $hFont, $hLabel), 0)
$iLine_Width = DllStructGetData($tSize, "X")
If $iLine_Width >= $iMaxWidth - 4 Then ExitLoop
Next
If $i > StringLen($asLines[$j]) Then
$iWrap_Count += 1
$avSize_Info[0] &= $sTest_Line & @CRLF
ExitLoop
Else
$iWrap_Count += 1
If $iLast_Word = 0 Then Return SetError(3, _StringSize_Error_Close(0, $hDC, $hFont, $hLabel), 0)
$avSize_Info[0] &= StringLeft($sTest_Line, $iLast_Word) & @CRLF
$asLines[$j] = StringTrimLeft($asLines[$j], $iLast_Word)
$asLines[$j] = StringStripWS($asLines[$j], 1)
EndIf
WEnd
$iLine_Count += $iWrap_Count
EndIf
Next
If $iExpTab Then
$avSize_Info[0] = StringRegExpReplace($avSize_Info[0], "\x20?XXXXXXXX", @TAB)
EndIf
$avSize_Info[1] = $iLine_Height
$avSize_Info[2] = $iMaxWidth
$avSize_Info[3] = ($iLine_Count * $iLine_Height) + 4
Else
Local $avSize_Info[4] = [$sText, $iLine_Height, $iLine_Width, ($asLines[0] * $iLine_Height) + 4]
EndIf
DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hPrevFont)
DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
Return $avSize_Info
EndFunc
Func _StringSize_Error_Close($iExtCode, $hDC = 0, $hFont = 0, $hLabel = 0)
If $hFont <> 0 Then DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hFont)
If $hDC <> 0 Then DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hDC)
If $hLabel Then GUICtrlDelete($hLabel)
Return $iExtCode
EndFunc
Func _StringSize_DefaultFontName()
Local $tNONCLIENTMETRICS = DllStructCreate("uint;int;int;int;int;int;byte[60];int;int;byte[60];int;int;byte[60];byte[60];byte[60]")
DLLStructSetData($tNONCLIENTMETRICS, 1, DllStructGetSize($tNONCLIENTMETRICS))
DLLCall("user32.dll", "int", "SystemParametersInfo", "int", 41, "int", DllStructGetSize($tNONCLIENTMETRICS), "ptr", DllStructGetPtr($tNONCLIENTMETRICS), "int", 0)
Local $tLOGFONT = DllStructCreate("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;char[32]", DLLStructGetPtr($tNONCLIENTMETRICS, 13))
If IsString(DllStructGetData($tLOGFONT, 14)) Then
Return DllStructGetData($tLOGFONT, 14)
Else
Return "Tahoma"
EndIf
EndFunc
Global Const $EMB_ICONSTOP = 16
Global Const $EMB_ICONQUERY = 32
Global Const $EMB_ICONEXCLAM = 48
Global Const $EMB_ICONINFO = 64
Global $g_aEMB_Settings[13]
Global $g_aEMB_TempArray = __EMB_GetDefaultFont()
$g_aEMB_Settings[10] = $g_aEMB_TempArray[0]
$g_aEMB_Settings[11] = $g_aEMB_TempArray[1]
$g_aEMB_TempArray = DllCall("User32.dll", "int", "GetSysColor", "int", 15)
$g_aEMB_Settings[8] = BitAND(BitShift(String(Binary($g_aEMB_TempArray[0])), 8), 0xFFFFFF)
$g_aEMB_TempArray = DllCall("User32.dll", "int", "GetSysColor", "int", 8)
$g_aEMB_Settings[9] = BitAND(BitShift(String(Binary($g_aEMB_TempArray[0])), 8), 0xFFFFFF)
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 11)
$g_aEMB_Settings[12] = $g_aEMB_TempArray[0]
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 30)
$g_aEMB_Settings[12] += ( ($g_aEMB_TempArray[0] < 30) ? ($g_aEMB_TempArray[0] * 3) : ($g_aEMB_TempArray[0]) )
$g_aEMB_TempArray = 0
$g_aEMB_TempArray = DllCall("dwmapi.dll", "uint", "DwmIsCompositionEnabled", "int*", $g_aEMB_TempArray)
If Not @error And $g_aEMB_TempArray[1] = True Then
$g_aEMB_TempArray = DllCall("user32.dll", "int", "GetSystemMetrics", "int", 7)
$g_aEMB_Settings[12] += ($g_aEMB_TempArray[0] * 4)
EndIf
$g_aEMB_TempArray = 0
$g_aEMB_Settings[0] = 0
$g_aEMB_Settings[1] = 0
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
$g_aEMB_Settings[6] = 370
$g_aEMB_Settings[7] = 500
Func _ExtMsgBoxSet($iStyle = -1, $iJust = -1, $iBkCol = -1, $iCol = -1, $iFont_Size = -1, $sFont_Name = -1, $iWidth = -1, $iWidth_Abs = -1)
Switch $iStyle
Case Default
$g_aEMB_Settings[0] = 0
$g_aEMB_Settings[1] = 0
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
$g_aEMB_Settings[6] = 370
$g_aEMB_Settings[7] = 370
Return
Case -1
Case 0 To 127
$g_aEMB_Settings[0] = Int($iStyle)
Case Else
Return SetError(1, 1, 0)
EndSwitch
Switch $iJust
Case Default
$g_aEMB_Settings[1] = 0
Case -1
Case 0, 1, 2, 4, 5, 6
$g_aEMB_Settings[1] = $iJust
Case Else
Return SetError(1, 2, 0)
EndSwitch
Switch $iBkCol
Case Default
$g_aEMB_Settings[2] = $g_aEMB_Settings[8]
Case -1
Case 0 To 0xFFFFFF
$g_aEMB_Settings[2] = Int($iBkCol)
Case Else
Return SetError(1, 3, 0)
EndSwitch
Switch $iCol
Case Default
$g_aEMB_Settings[3] = $g_aEMB_Settings[9]
Case -1
Case 0 To 0xFFFFFF
$g_aEMB_Settings[3] = Int($iCol)
Case Else
Return SetError(1, 4, 0)
EndSwitch
Switch $iFont_Size
Case Default
$g_aEMB_Settings[4] = $g_aEMB_Settings[10]
Case -1
Case 8 To 72
$g_aEMB_Settings[4] = Int($iFont_Size)
Case Else
Return SetError(1, 5, 0)
EndSwitch
Switch $sFont_Name
Case Default
$g_aEMB_Settings[5] = $g_aEMB_Settings[11]
Case -1
Case Else
If IsString($sFont_Name) Then
$g_aEMB_Settings[5] = $sFont_Name
Else
Return SetError(1, 6, 0)
EndIf
EndSwitch
Switch $iWidth
Case Default
$g_aEMB_Settings[6] = 370
Case -1
Case 370 To @DesktopWidth - 20
$g_aEMB_Settings[6] = Int($iWidth)
Case Else
Return SetError(1, 7, 0)
EndSwitch
Switch $iWidth_Abs
Case Default
$g_aEMB_Settings[7] = 370
Case -1
Case 370 To @DesktopWidth - 20
$g_aEMB_Settings[7] = Int($iWidth_Abs)
Case Else
Return SetError(1, 8, 0)
EndSwitch
If $g_aEMB_Settings[7] < $g_aEMB_Settings[6] Then
$g_aEMB_Settings[7] = $g_aEMB_Settings[6]
EndIf
Return 1
EndFunc
Func _ExtMsgBox($vIcon, $vButton, $sTitle, $sText, $iTimeOut = 0, $hWin = "", $iVPos = 0, $bMain = True)
Local $iMsg_Width_Max = $g_aEMB_Settings[6], $iMsg_Width_Min = 150, $iMsg_Width_Abs = $g_aEMB_Settings[7]
Local $iMsg_Height_Min = 100
Local $iButton_Width_Def = 80, $iButton_Width_Min = 50
Local $iParent_Win = 0, $fCountdown = False, $cCheckbox, $aLabel_Size, $aRet, $iRet_Value, $iHpos
Local $sButton_Text, $iButton_Width, $iButton_Xpos
$iTimeOut = Int(Number($iTimeOut))
If $vButton == " " And $iTimeOut = 0 Then
$iTimeOut = 5
EndIf
Local $iIcon_Style = 0
Local $iIcon_Reduction = 50
Local $sDLL = "user32.dll"
If StringIsDigit($vIcon) Then
Switch $vIcon
Case 0
$iIcon_Reduction = 0
Case 8
$sDLL = "imageres.dll"
$iIcon_Style = 78
Case 16
$iIcon_Style = -4
Case 32
$iIcon_Style = -3
Case 48
$iIcon_Style = -2
Case 64
$iIcon_Style = -5
Case 128
If $iTimeOut > 0 Then
$fCountdown = True
Else
ContinueCase
EndIf
Case Else
Return SetError(1, 0, -1)
EndSwitch
Else
$sDLL = $vIcon
$iIcon_Style = 0
EndIf
StringRegExpReplace($vButton, "((?<!&)&)(?!&)", "*")
If @extended > 1 Then
Return SetError(2, 0, -1)
EndIf
If IsNumber($vButton) Then
Switch $vButton
Case 0
$vButton = "OK"
Case 1
$vButton = "&OK|Cancel"
Case 2
$vButton = "&Abort|Retry|Ignore"
Case 3
$vButton = "&Yes|No|Cancel"
Case 4
$vButton = "&Yes|No"
Case 5
$vButton = "&Retry|Cancel"
Case 6
$vButton = "&Cancel|Try Again|Continue"
Case Else
Return SetError(3, 0, -1)
EndSwitch
EndIf
Local $aButton_Text[1] = [0]
Local $iButton_Width_Req = 0
If $vButton <> " " Then
$aButton_Text = StringSplit($vButton, "|")
Local $iButton_Width_Abs = Floor((($iMsg_Width_Max - 10) / $aButton_Text[0]) - 10)
If $iButton_Width_Abs < $iButton_Width_Min Then
Return SetError(4, 0, -1)
EndIf
Local $iButton_Width_Text = 0
For $i = 1 To $aButton_Text[0]
$sButton_Text = StringRegExpReplace($aButton_Text[$i], "^&?(.*)$", "$1")
If BitAND($g_aEMB_Settings[0], 4) Then
$aRet = _StringSize($sButton_Text, $g_aEMB_Settings[10], Default, Default, $g_aEMB_Settings[11])
Else
$aRet = _StringSize($sButton_Text, $g_aEMB_Settings[4], Default, Default, $g_aEMB_Settings[5])
EndIf
If IsArray($aRet) And $aRet[2] + 10 > $iButton_Width_Text Then
$iButton_Width_Text = $aRet[2] + 10
EndIf
Next
If $iButton_Width_Text > $iButton_Width_Abs Then
Return SetError(5, 0, -1)
EndIf
$iButton_Width = $iButton_Width_Def
If $iButton_Width_Text > $iButton_Width_Def Then
$iButton_Width = $iButton_Width_Text
EndIf
If $iButton_Width_Abs < $iButton_Width_Def Then
If $iButton_Width_Text > $iButton_Width_Min Then
$iButton_Width = $iButton_Width_Text
Else
$iButton_Width = $iButton_Width_Min
EndIf
EndIf
$iButton_Width_Req = (($iButton_Width + 10) * $aButton_Text[0]) + 10
EndIf
Local $iExpTab = Default
If BitAND($g_aEMB_Settings[0], 8) Then
$iExpTab = 1
EndIf
While 1
Local $aLabel_Pos = _StringSize($sText, $g_aEMB_Settings[4], Default, $iExpTab, $g_aEMB_Settings[5], $iMsg_Width_Max - 20 - $iIcon_Reduction)
If @error Then
If $iMsg_Width_Max >= $iMsg_Width_Abs Then
Return SetError(6, 0, -1)
Else
$iMsg_Width_Max += 10
EndIf
Else
ExitLoop
EndIf
WEnd
$sText = $aLabel_Pos[0]
Local $iLabel_Width = $aLabel_Pos[2]
Local $iLabel_Height = $aLabel_Pos[3]
Local $iMsg_Width = $iLabel_Width + 20 + $iIcon_Reduction
If $iButton_Width_Req > $iMsg_Width Then $iMsg_Width = $iButton_Width_Req
If $iMsg_Width < $iMsg_Width_Min Then
$iMsg_Width = $iMsg_Width_Min
$iLabel_Width = $iMsg_Width_Min - 20
EndIf
Local $iDialog_Width = $iMsg_Width
Local $aTitleSize = _StringSize($sTitle, $g_aEMB_Settings[10], Default, Default, $g_aEMB_Settings[11])
If $aTitleSize[2] > ($iMsg_Width - 70) Then
$iDialog_Width = ( ($aTitleSize[2] < ($g_aEMB_Settings[7] - $g_aEMB_Settings[12])) ? ($aTitleSize[2] + $g_aEMB_Settings[12]) : ($g_aEMB_Settings[7]) )
EndIf
Local $iMsg_Height = $iLabel_Height + 35
If $vButton <> " " Then
$iMsg_Height += 30
EndIf
If BitAND($g_aEMB_Settings[0], 16) Then
$iMsg_Height += 40
EndIf
If $iMsg_Height < $iMsg_Height_Min Then $iMsg_Height = $iMsg_Height_Min
Local $iLabel_Vert = 20
If StringInStr($sText, @CRLF) = 0 Then $iLabel_Vert = 27
If Mod($g_aEMB_Settings[0], 2) = 1 Then
If IsHWnd($hWin) Then
$iParent_Win = $hWin
Else
$iParent_Win = WinGetHandle(AutoItWinGetTitle())
EndIf
EndIf
If $hWin = "" Then
$iHpos = (@DesktopWidth - $iDialog_Width) / 2
$iVPos = (@DesktopHeight - $iMsg_Height) / 2
Else
If IsHWnd($hWin) Then
If BitAND(WinGetState($hWin), 2) Then
Local $aPos = WinGetPos($hWin)
$iHpos = ($aPos[2] - $iDialog_Width) / 2 + $aPos[0] - 3
$iVPos = ($aPos[3] - $iMsg_Height) / 2 + $aPos[1] - 20
Else
$iHpos = (@DesktopWidth - $iDialog_Width) / 2
$iVPos = (@DesktopHeight - $iMsg_Height) / 2
EndIf
Else
$iHpos = $hWin
EndIf
EndIf
If $bMain Then
If $iHpos < 10 Then $iHpos = 10
If $iHpos + $iDialog_Width > @DesktopWidth - 20 Then $iHpos = @DesktopWidth - 20 - $iDialog_Width
If $iVPos < 10 Then $iVPos = 10
If $iVPos + $iMsg_Height > @DesktopHeight - 60 Then $iVPos = @DesktopHeight - 60 - $iMsg_Height
EndIf
Local $iExtStyle = 0x00000008
If BitAND($g_aEMB_Settings[0], 2) Then $iExtStyle = -1
Local $hMsgGUI = GUICreate($sTitle, $iDialog_Width, $iMsg_Height, $iHpos, $iVPos, BitOR(0x80880000, 0x00C00000), $iExtStyle, $iParent_Win)
If @error Then
Return SetError(7, 0, -1)
EndIf
If BitAND($g_aEMB_Settings[0], 32) Then
If @Compiled Then
GUISetIcon(@ScriptName, -2, $hMsgGUI)
Else
GUISetIcon(@AutoItExe, -2, $hMsgGUI)
EndIf
EndIf
If $g_aEMB_Settings[2] <> Default Then GUISetBkColor($g_aEMB_Settings[2])
If BitAND($g_aEMB_Settings[0], 64) Then
$aRet = DllCall("User32.dll", "hwnd", "GetSystemMenu", "hwnd", $hMsgGUI, "int", 0)
Local $hSysMenu = $aRet[0]
DllCall("User32.dll", "int", "RemoveMenu", "hwnd", $hSysMenu, "int", 0xF060, "int", 0)
DllCall("User32.dll", "int", "DrawMenuBar", "hwnd", $hMsgGUI)
EndIf
Local $iLabel_Style = 0
If BitAND($g_aEMB_Settings[1], 1) = 1 Then
$iLabel_Style = 1
ElseIf BitAND($g_aEMB_Settings[1], 2) = 2 Then
$iLabel_Style = 2
EndIf
GUICtrlCreateLabel($sText, 10 + $iIcon_Reduction, $iLabel_Vert, $iLabel_Width, $iLabel_Height, $iLabel_Style)
GUICtrlSetFont(-1, $g_aEMB_Settings[4], Default, Default, $g_aEMB_Settings[5])
If $g_aEMB_Settings[3] <> Default Then GUICtrlSetColor(-1, $g_aEMB_Settings[3])
If BitAND($g_aEMB_Settings[0], 16) Then
Local $sAgain = " Do not show again"
Local $iY = $iLabel_Vert + $iLabel_Height + 10
$cCheckbox = GUICtrlCreateCheckbox("", 10 + $iIcon_Reduction, $iY, 20, 20)
Local $cCheckLabel = GUICtrlCreateLabel($sAgain, 20, 20, 20, 20)
GUICtrlSetColor($cCheckLabel, $g_aEMB_Settings[3])
GUICtrlSetBkColor($cCheckLabel, $g_aEMB_Settings[2])
If BitAND($g_aEMB_Settings[0], 4) Then
$aLabel_Size = _StringSize($sAgain)
Else
$aLabel_Size = _StringSize($sAgain, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
GUICtrlSetFont($cCheckLabel, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
EndIf
$iY = ($iY + 10) - ($aLabel_Size[3] - 4) / 2
ControlMove($hMsgGUI, "", $cCheckLabel, 30 + $iIcon_Reduction, $iY, $iMsg_Width - (30 + $iIcon_Reduction), $aLabel_Size[3])
EndIf
If $fCountdown = True Then
Local $cCountdown_Label = GUICtrlCreateLabel(StringFormat("%2s", $iTimeOut), 10, 20, 32, 32)
GUICtrlSetFont(-1, 18, Default, Default, $g_aEMB_Settings[5])
GUICtrlSetColor(-1, $g_aEMB_Settings[3])
Else
If $iIcon_Reduction Then GUICtrlCreateIcon($sDLL, $iIcon_Style, 10, 20)
EndIf
Local $aButtonCID[$aButton_Text[0] + 1] = [9999]
If $vButton <> " " Then
$aButtonCID[0] = GUICtrlCreateDummy()
Local $aAccel_Key[1][2] = [["{SPACE}", $aButtonCID[0]]]
GUISetAccelerators($aAccel_Key)
If $aButton_Text[0] = 1 Then
If BitAND($g_aEMB_Settings[1], 4) = 4 Then
$iButton_Xpos = ($iMsg_Width - $iButton_Width) / 2
Else
$iButton_Xpos = $iMsg_Width - $iButton_Width - 10
EndIf
Else
$iButton_Xpos = ($iMsg_Width - ($iButton_Width_Req - 20)) / 2
EndIf
Local $iDefButton_Code = 0
Local $iDef_Button_Style = 0
For $i = 0 To $aButton_Text[0] - 1
Local $iButton_Text = $aButton_Text[$i + 1]
If $aButton_Text[0] = 1 Then
$iDef_Button_Style = 0x0001
ElseIf StringLeft($iButton_Text, 1) = "&" Then
$iDef_Button_Style = 0x0001
$aButton_Text[$i + 1] = StringTrimLeft($iButton_Text, 1)
$iDefButton_Code = $i + 1
EndIf
$aButtonCID[$i + 1] = GUICtrlCreateButton($aButton_Text[$i + 1], $iButton_Xpos + ($i * ($iButton_Width + 10)), $iMsg_Height - 35, $iButton_Width, 25, $iDef_Button_Style)
If Not BitAND($g_aEMB_Settings[0], 4) Then GUICtrlSetFont(-1, $g_aEMB_Settings[4], 400, 0, $g_aEMB_Settings[5])
$iDef_Button_Style = 0
Next
EndIf
GUISetState(@SW_SHOW, $hMsgGUI)
Local $iTimeout_Begin = TimerInit()
Local $iCounter = 0
Local $aMsg
Local $iOrgMode = Opt('GUIOnEventMode', 0)
While 1
$aMsg = GUIGetMsg(1)
If $aMsg[1] = $hMsgGUI Then
Select
Case $aMsg[0] = -3
$iRet_Value = 0
ExitLoop
Case $aMsg[0] = $aButtonCID[0]
If $iDefButton_Code Then
$iRet_Value = $iDefButton_Code
ExitLoop
EndIf
Case Else
For $i = 1 To UBound($aButtonCID) - 1
If $aMsg[0] = $aButtonCID[$i] Then
$iRet_Value = $i
ExitLoop 2
EndIf
Next
EndSelect
EndIf
If TimerDiff($iTimeout_Begin) / 1000 >= $iTimeOut And $iTimeOut > 0 Then
$iRet_Value = 9
ExitLoop
EndIf
If $fCountdown = True Then
Local $iTimeRun = Int(TimerDiff($iTimeout_Begin) / 1000)
If $iTimeRun <> $iCounter Then
$iCounter = $iTimeRun
GUICtrlSetData($cCountdown_Label, StringFormat("%2s", $iTimeOut - $iCounter))
EndIf
EndIf
WEnd
Opt('GUIOnEventMode', $iOrgMode)
If GUICtrlRead($cCheckbox) = 1 Then
$iRet_Value *= -1
EndIf
GUIDelete($hMsgGUI)
Return $iRet_Value
EndFunc
Func __EMB_GetDefaultFont()
Local $aDefFontData[2] = [9, "Tahoma"]
Local $hWnd = WinGetHandle(AutoItWinGetTitle())
Local $hThemeDLL = DllOpen("uxtheme.dll")
Local $hTheme = DllCall($hThemeDLL, 'ptr', 'OpenThemeData', 'hwnd', $hWnd, 'wstr', "Static")
If @error Then Return $aDefFontData
$hTheme = $hTheme[0]
Local $tFont = DllStructCreate("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;wchar[32]")
Local $pFont = DllStructGetPtr($tFont)
DllCall($hThemeDLL, 'long', 'GetThemeSysFont', 'HANDLE', $hTheme, 'int', 805, 'ptr', $pFont)
If @error Then Return $aDefFontData
Local $hDC = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return $aDefFontData
$hDC = $hDC[0]
Local $iPixel_Y = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", 90)
If Not @error Then
$iPixel_Y = $iPixel_Y[0]
$aDefFontData[0] = Int(2 * (.25 - DllStructGetData($tFont, 1) * 72 / $iPixel_Y)) / 2
EndIf
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
$aDefFontData[1] = DllStructGetData($tFont, 14)
Return $aDefFontData
EndFunc
Opt("GUIResizeMode", $GUI_DOCKALL)
Opt("GUIEventOptions", 1)
Opt("GUICloseOnESC", 0)
Opt("WinTitleMatchMode", 3)
If Not FileExists(@ScriptDir & "\License.txt") Then
$license = InetGet("http://www.gnu.org/licenses/gpl-3.0.txt", @ScriptDir & "\License.txt")
EndIf
Func GetTranslated($iSection = -1, $iKey = -1, $sText = "", $var1 = Default, $var2 = Default, $var3 = Default)
Local $sDefaultText, $sLanguageText
If $debugMultilanguage = 1 Then Return ($iSection & "-" & $iKey)
If $iSection = -1 Or $iKey = -1 Or $sText = "" Then Return "-2"
Local $bOutBound = False
If $iSection >= UBound($aLanguage, $UBOUND_ROWS) Or $iKey >= UBound($aLanguage, $UBOUND_COLUMNS) Then $bOutBound = True
If $bOutBound = True Then ReDim $aLanguage[$iSection + 1][$iKey + 1]
If $aLanguage[$iSection][$iKey] <> "" Then Return $aLanguage[$iSection][$iKey]
If $sLanguage = $sDefaultLanguage Then
$sDefaultText = IniRead($dirLanguages & $sDefaultLanguage & ".ini", $iSection, $iKey, "-3")
If $sText = "-1" Then
If $sDefaultText <> "-3" Then
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sDefaultText
Return $sDefaultText
Else
Return "-3"
EndIf
EndIf
If $sDefaultText <> $sText Then
IniWrite($dirLanguages & $sDefaultLanguage & ".ini", $iSection, $iKey, $sText)
$sText = GetTranslatedParsedText($sText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sText
Return $sText
Else
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sDefaultText
Return $sDefaultText
EndIf
Else
$sLanguageText = IniRead($dirLanguages & $sLanguage & ".ini", $iSection, $iKey, "-3")
If $sText = "-1" Then
If $sLanguageText = "-3" Then
$sDefaultText = IniRead($dirLanguages & $sDefaultLanguage & ".ini", $iSection, $iKey, $sText)
$sDefaultText = GetTranslatedParsedText($sDefaultText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sDefaultText
Return $sDefaultText
Else
$sLanguageText = GetTranslatedParsedText($sLanguageText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sLanguageText
Return $sLanguageText
EndIf
EndIf
If $sLanguageText = "-3" Then
IniWrite($dirLanguages & $sLanguage & ".ini", $iSection, $iKey, $sText)
$sText = GetTranslatedParsedText($sText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sText
Return $sText
EndIf
$sLanguageText = GetTranslatedParsedText($sLanguageText, $var1, $var2, $var3)
$aLanguage[$iSection][$iKey] = $sLanguageText
Return $sLanguageText
EndIf
EndFunc
Func GetTranslatedParsedText($sText, $var1 = Default, $var2 = Default, $var3 = Default)
Local $s = StringReplace($sText, "\r\n", @CRLF)
If $var1 = Default Then Return $s
If $var2 = Default Then Return StringFormat($sText, $var1)
If $var3 = Default Then Return StringFormat($sText, $var1, $var2)
Return StringFormat($sText, $var1, $var2, $var3)
EndFunc
Func DetectLanguage()
$sLanguage = IniRead($config, "other", "language", "")
If $sLanguage = "" Then
$OSLang = @OSLang
If $debugSetLog Then SetLog("Detected language code: " & $OSLang)
Switch $OSLang
Case Hex(0x0004, 4)
$decimalCode = '4'
$countryCode = 'zh-CHS'
$langName = 'Chinese'
Case Hex(0x0401, 4)
$decimalCode = '1025'
$countryCode = 'ar-SA'
$langName = 'Arabic'
Case Hex(0x0402, 4)
$decimalCode = '1026'
$countryCode = 'bg-BG'
$langName = 'Bulgarian'
Case Hex(0x0403, 4)
$decimalCode = '1027'
$countryCode = 'ca-ES'
$langName = 'Catalan'
Case Hex(0x0404, 4)
$decimalCode = '1028'
$countryCode = 'zh-TW'
$langName = 'Chinese'
Case Hex(0x0405, 4)
$decimalCode = '1029'
$countryCode = 'cs-CZ'
$langName = 'Czech'
Case Hex(0x0406, 4)
$decimalCode = '1030'
$countryCode = 'da-DK'
$langName = 'Danish'
Case Hex(0x0407, 4)
$decimalCode = '1031'
$countryCode = 'de-DE'
$langName = 'German'
Case Hex(0x0408, 4)
$decimalCode = '1032'
$countryCode = 'el-GR'
$langName = 'Greek'
Case Hex(0x0409, 4)
$decimalCode = '1033'
$countryCode = 'en-US'
$langName = 'English'
Case Hex(0x040A, 4)
$decimalCode = '1034'
$countryCode = 'es-ES_tradnl'
$langName = 'Spanish'
Case Hex(0x040B, 4)
$decimalCode = '1035'
$countryCode = 'fi-FI'
$langName = 'Finnish'
Case Hex(0x040C, 4)
$decimalCode = '1036'
$countryCode = 'fr-FR'
$langName = 'French'
Case Hex(0x040D, 4)
$decimalCode = '1037'
$countryCode = 'he-IL'
$langName = 'Hebrew'
Case Hex(0x040E, 4)
$decimalCode = '1038'
$countryCode = 'hu-HU'
$langName = 'Hungarian'
Case Hex(0x040F, 4)
$decimalCode = '1039'
$countryCode = 'is-IS'
$langName = 'Icelandic'
Case Hex(0x0410, 4)
$decimalCode = '1040'
$countryCode = 'it-IT'
$langName = 'Italian'
Case Hex(0x0411, 4)
$decimalCode = '1041'
$countryCode = 'ja-JP'
$langName = 'Japanese'
Case Hex(0x0412, 4)
$decimalCode = '1042'
$countryCode = 'ko-KR'
$langName = 'Korean'
Case Hex(0x0413, 4)
$decimalCode = '1043'
$countryCode = 'nl-NL'
$langName = 'Dutch'
Case Hex(0x0414, 4)
$decimalCode = '1044'
$countryCode = 'nb-NO'
$langName = 'Norwegian'
Case Hex(0x0415, 4)
$decimalCode = '1045'
$countryCode = 'pl-PL'
$langName = 'Polish'
Case Hex(0x0416, 4)
$decimalCode = '1046'
$countryCode = 'pt-BR'
$langName = 'Portuguese'
Case Hex(0x0417, 4)
$decimalCode = '1047'
$countryCode = 'rm-CH'
$langName = 'Romansh'
Case Hex(0x0418, 4)
$decimalCode = '1048'
$countryCode = 'ro-RO'
$langName = 'Romanian'
Case Hex(0x0419, 4)
$decimalCode = '1049'
$countryCode = 'ru-RU'
$langName = 'Russian'
Case Hex(0x041A, 4)
$decimalCode = '1050'
$countryCode = 'hr-HR'
$langName = 'Croatian'
Case Hex(0x041B, 4)
$decimalCode = '1051'
$countryCode = 'sk-SK'
$langName = 'Slovak'
Case Hex(0x041C, 4)
$decimalCode = '1052'
$countryCode = 'sq-AL'
$langName = 'Albanian'
Case Hex(0x041D, 4)
$decimalCode = '1053'
$countryCode = 'sv-SE'
$langName = 'Swedish'
Case Hex(0x041E, 4)
$decimalCode = '1054'
$countryCode = 'th-TH'
$langName = 'Thai'
Case Hex(0x041F, 4)
$decimalCode = '1055'
$countryCode = 'tr-TR'
$langName = 'Turkish'
Case Hex(0x0420, 4)
$decimalCode = '1056'
$countryCode = 'ur-PK'
$langName = 'Urdu'
Case Hex(0x0421, 4)
$decimalCode = '1057'
$countryCode = 'id-ID'
$langName = 'Indonesian'
Case Hex(0x0422, 4)
$decimalCode = '1058'
$countryCode = 'uk-UA'
$langName = 'Ukrainian'
Case Hex(0x0423, 4)
$decimalCode = '1059'
$countryCode = 'be-BY'
$langName = 'Belarusian'
Case Hex(0x0424, 4)
$decimalCode = '1060'
$countryCode = 'sl-SI'
$langName = 'Slovenian'
Case Hex(0x0425, 4)
$decimalCode = '1061'
$countryCode = 'et-EE'
$langName = 'Estonian'
Case Hex(0x0426, 4)
$decimalCode = '1062'
$countryCode = 'lv-LV'
$langName = 'Latvian'
Case Hex(0x0427, 4)
$decimalCode = '1063'
$countryCode = 'lt-LT'
$langName = 'Lithuanian'
Case Hex(0x0428, 4)
$decimalCode = '1064'
$countryCode = 'tg-Cyrl-TJ'
$langName = 'Tajik'
Case Hex(0x0429, 4)
$decimalCode = '1065'
$countryCode = 'fa-IR'
$langName = 'Persian'
Case Hex(0x042A, 4)
$decimalCode = '1066'
$countryCode = 'vi-VN'
$langName = 'Vietnamese'
Case Hex(0x042B, 4)
$decimalCode = '1067'
$countryCode = 'hy-AM'
$langName = 'Armenian'
Case Hex(0x042C, 4)
$decimalCode = '1068'
$countryCode = 'az-Latn-AZ'
$langName = 'Azeri'
Case Hex(0x042D, 4)
$decimalCode = '1069'
$countryCode = 'eu-ES'
$langName = 'Basque'
Case Hex(0x042E, 4)
$decimalCode = '1070'
$countryCode = 'hsb-DE'
$langName = 'Upper'
Case Hex(0x042F, 4)
$decimalCode = '1071'
$countryCode = 'mk-MK'
$langName = 'Macedonian'
Case Hex(0x0432, 4)
$decimalCode = '1074'
$countryCode = 'tn-ZA'
$langName = 'Setswana'
Case Hex(0x0434, 4)
$decimalCode = '1076'
$countryCode = 'xh-ZA'
$langName = 'isiXhosa'
Case Hex(0x0435, 4)
$decimalCode = '1077'
$countryCode = 'zu-ZA'
$langName = 'isiZulu'
Case Hex(0x0436, 4)
$decimalCode = '1078'
$countryCode = 'af-ZA'
$langName = 'Afrikaans'
Case Hex(0x0437, 4)
$decimalCode = '1079'
$countryCode = 'ka-GE'
$langName = 'Georgian'
Case Hex(0x0438, 4)
$decimalCode = '1080'
$countryCode = 'fo-FO'
$langName = 'Faroese'
Case Hex(0x0439, 4)
$decimalCode = '1081'
$countryCode = 'hi-IN'
$langName = 'Hindi'
Case Hex(0x043A, 4)
$decimalCode = '1082'
$countryCode = 'mt-MT'
$langName = 'Maltese'
Case Hex(0x043B, 4)
$decimalCode = '1083'
$countryCode = 'se-NO'
$langName = 'Sami'
Case Hex(0x043e, 4)
$decimalCode = '1086'
$countryCode = 'ms-MY'
$langName = 'Malay'
Case Hex(0x043F, 4)
$decimalCode = '1087'
$countryCode = 'kk-KZ'
$langName = 'Kazakh'
Case Hex(0x0440, 4)
$decimalCode = '1088'
$countryCode = 'ky-KG'
$langName = 'Kyrgyz'
Case Hex(0x0441, 4)
$decimalCode = '1089'
$countryCode = 'sw-KE'
$langName = 'Swahili'
Case Hex(0x0442, 4)
$decimalCode = '1090'
$countryCode = 'tk-TM'
$langName = 'Turkmen'
Case Hex(0x0443, 4)
$decimalCode = '1091'
$countryCode = 'uz-Latn-UZ'
$langName = 'Uzbek'
Case Hex(0x0444, 4)
$decimalCode = '1092'
$countryCode = 'tt-RU'
$langName = 'Tatar'
Case Hex(0x0445, 4)
$decimalCode = '1093'
$countryCode = 'bn-IN'
$langName = 'Bangla'
Case Hex(0x0446, 4)
$decimalCode = '1094'
$countryCode = 'pa-IN'
$langName = 'Punjabi'
Case Hex(0x0447, 4)
$decimalCode = '1095'
$countryCode = 'gu-IN'
$langName = 'Gujarati'
Case Hex(0x0448, 4)
$decimalCode = '1096'
$countryCode = 'or-IN'
$langName = 'Oriya'
Case Hex(0x0449, 4)
$decimalCode = '1097'
$countryCode = 'ta-IN'
$langName = 'Tamil'
Case Hex(0x044A, 4)
$decimalCode = '1098'
$countryCode = 'te-IN'
$langName = 'Telugu'
Case Hex(0x044B, 4)
$decimalCode = '1099'
$countryCode = 'kn-IN'
$langName = 'Kannada'
Case Hex(0x044C, 4)
$decimalCode = '1100'
$countryCode = 'ml-IN'
$langName = 'Malayalam'
Case Hex(0x044D, 4)
$decimalCode = '1101'
$countryCode = 'as-IN'
$langName = 'Assamese'
Case Hex(0x044E, 4)
$decimalCode = '1102'
$countryCode = 'mr-IN'
$langName = 'Marathi'
Case Hex(0x044F, 4)
$decimalCode = '1103'
$countryCode = 'sa-IN'
$langName = 'Sanskrit'
Case Hex(0x0450, 4)
$decimalCode = '1104'
$countryCode = 'mn-MN'
$langName = 'Mongolian'
Case Hex(0x0451, 4)
$decimalCode = '1105'
$countryCode = 'bo-CN'
$langName = 'Tibetan'
Case Hex(0x0452, 4)
$decimalCode = '1106'
$countryCode = 'cy-GB'
$langName = 'Welsh'
Case Hex(0x0453, 4)
$decimalCode = '1107'
$countryCode = 'km-KH'
$langName = 'Khmer'
Case Hex(0x0454, 4)
$decimalCode = '1108'
$countryCode = 'lo-LA'
$langName = 'Lao'
Case Hex(0x0456, 4)
$decimalCode = '1110'
$countryCode = 'gl-ES'
$langName = 'Galician'
Case Hex(0x0457, 4)
$decimalCode = '1111'
$countryCode = 'kok-IN'
$langName = 'Konkani'
Case Hex(0x0459, 4)
$decimalCode = '1113'
$countryCode = 'sd-Deva-IN'
$langName = '(reserved)'
Case Hex(0x045A, 4)
$decimalCode = '1114'
$countryCode = 'syr-SY'
$langName = 'Syriac'
Case Hex(0x045B, 4)
$decimalCode = '1115'
$countryCode = 'si-LK'
$langName = 'Sinhala'
Case Hex(0x045C, 4)
$decimalCode = '1116'
$countryCode = 'chr-Cher-US'
$langName = 'Cherokee'
Case Hex(0x045D, 4)
$decimalCode = '1117'
$countryCode = 'iu-Cans-CA'
$langName = 'Inuktitut'
Case Hex(0x045E, 4)
$decimalCode = '1118'
$countryCode = 'am-ET'
$langName = 'Amharic'
Case Hex(0x0461, 4)
$decimalCode = '1121'
$countryCode = 'ne-NP'
$langName = 'Nepali'
Case Hex(0x0462, 4)
$decimalCode = '1122'
$countryCode = 'fy-NL'
$langName = 'Frisian'
Case Hex(0x0463, 4)
$decimalCode = '1123'
$countryCode = 'ps-AF'
$langName = 'Pashto'
Case Hex(0x0464, 4)
$decimalCode = '1124'
$countryCode = 'fil-PH'
$langName = 'Filipino'
Case Hex(0x0465, 4)
$decimalCode = '1125'
$countryCode = 'dv-MV'
$langName = 'Divehi'
Case Hex(0x0468, 4)
$decimalCode = '1128'
$countryCode = 'ha-Latn-NG'
$langName = 'Hausa'
Case Hex(0x046A, 4)
$decimalCode = '1130'
$countryCode = 'yo-NG'
$langName = 'Yoruba'
Case Hex(0x046B, 4)
$decimalCode = '1131'
$countryCode = 'quz-BO'
$langName = 'Quechua'
Case Hex(0x046C, 4)
$decimalCode = '1132'
$countryCode = 'nso-ZA'
$langName = 'Sesotho'
Case Hex(0x046D, 4)
$decimalCode = '1133'
$countryCode = 'ba-RU'
$langName = 'Bashkir'
Case Hex(0x046E, 4)
$decimalCode = '1134'
$countryCode = 'lb-LU'
$langName = 'Luxembourgish'
Case Hex(0x046F, 4)
$decimalCode = '1135'
$countryCode = 'kl-GL'
$langName = 'Greenlandic'
Case Hex(0x0470, 4)
$decimalCode = '1136'
$countryCode = 'ig-NG'
$langName = 'Igbo'
Case Hex(0x0473, 4)
$decimalCode = '1139'
$countryCode = 'ti-ET'
$langName = 'Tigrinya'
Case Hex(0x0475, 4)
$decimalCode = '1141'
$countryCode = 'haw-US'
$langName = 'Hawiian'
Case Hex(0x0478, 4)
$decimalCode = '1144'
$countryCode = 'ii-CN'
$langName = 'Yi'
Case Hex(0x047A, 4)
$decimalCode = '1146'
$countryCode = 'arn-CL'
$langName = 'Mapudungun'
Case Hex(0x047C, 4)
$decimalCode = '1148'
$countryCode = 'moh-CA'
$langName = 'Mohawk'
Case Hex(0x047E, 4)
$decimalCode = '1150'
$countryCode = 'br-FR'
$langName = 'Breton'
Case Hex(0x0480, 4)
$decimalCode = '1152'
$countryCode = 'ug-CN'
$langName = 'Uyghur'
Case Hex(0x0481, 4)
$decimalCode = '1153'
$countryCode = 'mi-NZ'
$langName = 'Maori'
Case Hex(0x0482, 4)
$decimalCode = '1154'
$countryCode = 'oc-FR'
$langName = 'Occitan'
Case Hex(0x0483, 4)
$decimalCode = '1155'
$countryCode = 'co-FR'
$langName = 'Corsican'
Case Hex(0x0484, 4)
$decimalCode = '1156'
$countryCode = 'gsw-FR'
$langName = 'Alsatian'
Case Hex(0x0485, 4)
$decimalCode = '1157'
$countryCode = 'sah-RU'
$langName = 'Sakha'
Case Hex(0x0486, 4)
$decimalCode = '1158'
$countryCode = 'quc-Latn-GT'
$langName = "K'iche"
Case Hex(0x0487, 4)
$decimalCode = '1159'
$countryCode = 'rw-RW'
$langName = 'Kinyarwanda'
Case Hex(0x0488, 4)
$decimalCode = '1160'
$countryCode = 'wo-SN'
$langName = 'Wolof'
Case Hex(0x048C, 4)
$decimalCode = '1164'
$countryCode = 'prs-AF'
$langName = 'Dari'
Case Hex(0x0491, 4)
$decimalCode = '1169'
$countryCode = 'gd-GB'
$langName = 'Scottish'
Case Hex(0x0492, 4)
$decimalCode = '1170'
$countryCode = 'ku-Arab-IQ'
$langName = 'Central'
Case Hex(0x0801, 4)
$decimalCode = '2049'
$countryCode = 'ar-IQ'
$langName = 'Arabic'
Case Hex(0x0803, 4)
$decimalCode = '2051'
$countryCode = 'ca-ES-valencia'
$langName = 'Valencian'
Case Hex(0x0804, 4)
$decimalCode = '2052'
$countryCode = 'zh-CN'
$langName = 'Chinese'
Case Hex(0x0807, 4)
$decimalCode = '2055'
$countryCode = 'de-CH'
$langName = 'German'
Case Hex(0x0809, 4)
$decimalCode = '2057'
$countryCode = 'en-GB'
$langName = 'English'
Case Hex(0x080A, 4)
$decimalCode = '2058'
$countryCode = 'es-MX'
$langName = 'Spanish'
Case Hex(0x080C, 4)
$decimalCode = '2060'
$countryCode = 'fr-BE'
$langName = 'French'
Case Hex(0x0810, 4)
$decimalCode = '2064'
$countryCode = 'it-CH'
$langName = 'Italian'
Case Hex(0x0813, 4)
$decimalCode = '2067'
$countryCode = 'nl-BE'
$langName = 'Dutch'
Case Hex(0x0814, 4)
$decimalCode = '2068'
$countryCode = 'nn-NO'
$langName = 'Norwegian'
Case Hex(0x0816, 4)
$decimalCode = '2070'
$countryCode = 'pt-PT'
$langName = 'Portuguese'
Case Hex(0x081A, 4)
$decimalCode = '2074'
$countryCode = 'sr-Latn-CS'
$langName = 'Serbian'
Case Hex(0x081D, 4)
$decimalCode = '2077'
$countryCode = 'sv-FI'
$langName = 'Swedish'
Case Hex(0x0820, 4)
$decimalCode = '2080'
$countryCode = 'ur-IN'
$langName = 'Urdu'
Case Hex(0x082C, 4)
$decimalCode = '2092'
$countryCode = 'az-Cyrl-AZ'
$langName = 'Azeri'
Case Hex(0x082E, 4)
$decimalCode = '2094'
$countryCode = 'dsb-DE'
$langName = 'Lower'
Case Hex(0x0832, 4)
$decimalCode = '2098'
$countryCode = 'tn-BW'
$langName = 'Setswana'
Case Hex(0x083B, 4)
$decimalCode = '2107'
$countryCode = 'se-SE'
$langName = 'Sami'
Case Hex(0x083C, 4)
$decimalCode = '2108'
$countryCode = 'ga-IE'
$langName = 'Irish'
Case Hex(0x083E, 4)
$decimalCode = '2110'
$countryCode = 'ms-BN'
$langName = 'Malay'
Case Hex(0x0843, 4)
$decimalCode = '2115'
$countryCode = 'uz-Cyrl-UZ'
$langName = 'Uzbek'
Case Hex(0x0845, 4)
$decimalCode = '2117'
$countryCode = 'bn-BD'
$langName = 'Bangla'
Case Hex(0x0846, 4)
$decimalCode = '2118'
$countryCode = 'pa-Arab-PK'
$langName = 'Punjabi'
Case Hex(0x0849, 4)
$decimalCode = '2121'
$countryCode = 'ta-LK'
$langName = 'Tamil'
Case Hex(0x0850, 4)
$decimalCode = '2128'
$countryCode = 'mn-Mong-CN'
$langName = 'Mongolian'
Case Hex(0x0859, 4)
$decimalCode = '2137'
$countryCode = 'sd-Arab-PK'
$langName = 'Sindhi'
Case Hex(0x085D, 4)
$decimalCode = '2141'
$countryCode = 'iu-Latn-CA'
$langName = 'Inuktitut'
Case Hex(0x085F, 4)
$decimalCode = '2143'
$countryCode = 'tzm-Latn-DZ'
$langName = 'Tamazight'
Case Hex(0x0867, 4)
$decimalCode = '2151'
$countryCode = 'ff-Latn-SN'
$langName = 'Pular'
Case Hex(0x086B, 4)
$decimalCode = '2155'
$countryCode = 'quz-EC'
$langName = 'Quechua'
Case Hex(0x0873, 4)
$decimalCode = '2163'
$countryCode = 'ti-ER'
$langName = '(reserved)'
Case Hex(0x0873, 4)
$decimalCode = '2163'
$countryCode = 'ti-ER'
$langName = 'Tigrinya'
Case Hex(0x0C01, 4)
$decimalCode = '3073'
$countryCode = 'ar-EG'
$langName = 'Arabic'
Case Hex(0x0C04, 4)
$decimalCode = '3076'
$countryCode = 'zh-HK'
$langName = 'Chinese'
Case Hex(0x0C07, 4)
$decimalCode = '3079'
$countryCode = 'de-AT'
$langName = 'German'
Case Hex(0x0C09, 4)
$decimalCode = '3081'
$countryCode = 'en-AU'
$langName = 'English'
Case Hex(0x0C0A, 4)
$decimalCode = '3082'
$countryCode = 'es-ES'
$langName = 'Spanish'
Case Hex(0x0C0C, 4)
$decimalCode = '3084'
$countryCode = 'fr-CA'
$langName = 'French'
Case Hex(0x0C1A, 4)
$decimalCode = '3098'
$countryCode = 'sr-Cyrl-CS'
$langName = 'Serbian'
Case Hex(0x0C3B, 4)
$decimalCode = '3131'
$countryCode = 'se-FI'
$langName = 'Sami'
Case Hex(0x0C6B, 4)
$decimalCode = '3179'
$countryCode = 'quz-PE'
$langName = 'Quechua'
Case Hex(0x1001, 4)
$decimalCode = '4097'
$countryCode = 'ar-LY'
$langName = 'Arabic'
Case Hex(0x1004, 4)
$decimalCode = '4100'
$countryCode = 'zh-SG'
$langName = 'Chinese'
Case Hex(0x1007, 4)
$decimalCode = '4103'
$countryCode = 'de-LU'
$langName = 'German'
Case Hex(0x1009, 4)
$decimalCode = '4105'
$countryCode = 'en-CA'
$langName = 'English'
Case Hex(0x100A, 4)
$decimalCode = '4106'
$countryCode = 'es-GT'
$langName = 'Spanish'
Case Hex(0x100C, 4)
$decimalCode = '4108'
$countryCode = 'fr-CH'
$langName = 'French'
Case Hex(0x101A, 4)
$decimalCode = '4122'
$countryCode = 'hr-BA'
$langName = 'Croatian'
Case Hex(0x103B, 4)
$decimalCode = '4155'
$countryCode = 'smj-NO'
$langName = 'Sami'
Case Hex(0x105F, 4)
$decimalCode = '4191'
$countryCode = 'tzm-Tfng-MA'
$langName = 'Central'
Case Hex(0x1401, 4)
$decimalCode = '5121'
$countryCode = 'ar-DZ'
$langName = 'Arabic'
Case Hex(0x1404, 4)
$decimalCode = '5124'
$countryCode = 'zh-MO'
$langName = 'Chinese'
Case Hex(0x1407, 4)
$decimalCode = '5127'
$countryCode = 'de-LI'
$langName = 'German'
Case Hex(0x1409, 4)
$decimalCode = '5129'
$countryCode = 'en-NZ'
$langName = 'English'
Case Hex(0x140A, 4)
$decimalCode = '5130'
$countryCode = 'es-CR'
$langName = 'Spanish'
Case Hex(0x140C, 4)
$decimalCode = '5132'
$countryCode = 'fr-LU'
$langName = 'French'
Case Hex(0x141A, 4)
$decimalCode = '5146'
$countryCode = 'bs-Latn-BA'
$langName = 'Bosnian'
Case Hex(0x143B, 4)
$decimalCode = '5179'
$countryCode = 'smj-SE'
$langName = 'Sami'
Case Hex(0x1801, 4)
$decimalCode = '6145'
$countryCode = 'ar-MA'
$langName = 'Arabic'
Case Hex(0x1809, 4)
$decimalCode = '6153'
$countryCode = 'en-IE'
$langName = 'English'
Case Hex(0x180A, 4)
$decimalCode = '6154'
$countryCode = 'es-PA'
$langName = 'Spanish'
Case Hex(0x180C, 4)
$decimalCode = '6156'
$countryCode = 'fr-MC'
$langName = 'French'
Case Hex(0x181A, 4)
$decimalCode = '6170'
$countryCode = 'sr-Latn-BA'
$langName = 'Serbian'
Case Hex(0x183B, 4)
$decimalCode = '6203'
$countryCode = 'sma-NO'
$langName = 'Sami'
Case Hex(0x1C01, 4)
$decimalCode = '7169'
$countryCode = 'ar-TN'
$langName = 'Arabic'
Case Hex(0x1c09, 4)
$decimalCode = '7177'
$countryCode = 'en-ZA'
$langName = 'English'
Case Hex(0x1C0A, 4)
$decimalCode = '7178'
$countryCode = 'es-DO'
$langName = 'Spanish'
Case Hex(0x1C1A, 4)
$decimalCode = '7194'
$countryCode = 'sr-Cyrl-BA'
$langName = 'Serbian'
Case Hex(0x1C3B, 4)
$decimalCode = '7227'
$countryCode = 'sma-SE'
$langName = 'Sami'
Case Hex(0x2001, 4)
$decimalCode = '8193'
$countryCode = 'ar-OM'
$langName = 'Arabic'
Case Hex(0x2009, 4)
$decimalCode = '8201'
$countryCode = 'en-JM'
$langName = 'English'
Case Hex(0x200A, 4)
$decimalCode = '8202'
$countryCode = 'es-VE'
$langName = 'Spanish'
Case Hex(0x201A, 4)
$decimalCode = '8218'
$countryCode = 'bs-Cyrl-BA'
$langName = 'Bosnian'
Case Hex(0x203B, 4)
$decimalCode = '8251'
$countryCode = 'sms-FI'
$langName = 'Sami'
Case Hex(0x2401, 4)
$decimalCode = '9217'
$countryCode = 'ar-YE'
$langName = 'Arabic'
Case Hex(0x2409, 4)
$decimalCode = '9225'
$countryCode = 'en-029'
$langName = 'English'
Case Hex(0x240A, 4)
$decimalCode = '9226'
$countryCode = 'es-CO'
$langName = 'Spanish'
Case Hex(0x241A, 4)
$decimalCode = '9242'
$countryCode = 'sr-Latn-RS'
$langName = 'Serbian'
Case Hex(0x243B, 4)
$decimalCode = '9275'
$countryCode = 'smn-FI'
$langName = 'Sami'
Case Hex(0x2801, 4)
$decimalCode = '10241'
$countryCode = 'ar-SY'
$langName = 'Arabic'
Case Hex(0x2809, 4)
$decimalCode = '10249'
$countryCode = 'en-BZ'
$langName = 'English'
Case Hex(0x280A, 4)
$decimalCode = '10250'
$countryCode = 'es-PE'
$langName = 'Spanish'
Case Hex(0x281A, 4)
$decimalCode = '10266'
$countryCode = 'sr-Cyrl-RS'
$langName = 'Serbian'
Case Hex(0x2C01, 4)
$decimalCode = '11265'
$countryCode = 'ar-JO'
$langName = 'Arabic'
Case Hex(0x2C09, 4)
$decimalCode = '11273'
$countryCode = 'en-TT'
$langName = 'English'
Case Hex(0x2C0A, 4)
$decimalCode = '11274'
$countryCode = 'es-AR'
$langName = 'Spanish'
Case Hex(0x2C1A, 4)
$decimalCode = '11290'
$countryCode = 'sr-Latn-ME'
$langName = 'Serbian'
Case Hex(0x3001, 4)
$decimalCode = '12289'
$countryCode = 'ar-LB'
$langName = 'Arabic'
Case Hex(0x3009, 4)
$decimalCode = '12297'
$countryCode = 'en-ZW'
$langName = 'English'
Case Hex(0x300A, 4)
$decimalCode = '12298'
$countryCode = 'es-EC'
$langName = 'Spanish'
Case Hex(0x301A, 4)
$decimalCode = '12314'
$countryCode = 'sr-Cyrl-ME'
$langName = 'Serbian'
Case Hex(0x3401, 4)
$decimalCode = '13313'
$countryCode = 'ar-KW'
$langName = 'Arabic'
Case Hex(0x3409, 4)
$decimalCode = '13321'
$countryCode = 'en-PH'
$langName = 'English'
Case Hex(0x340A, 4)
$decimalCode = '13322'
$countryCode = 'es-CL'
$langName = 'Spanish'
Case Hex(0x3801, 4)
$decimalCode = '14337'
$countryCode = 'ar-AE'
$langName = 'Arabic'
Case Hex(0x380A, 4)
$decimalCode = '14346'
$countryCode = 'es-UY'
$langName = 'Spanish'
Case Hex(0x3C01, 4)
$decimalCode = '15361'
$countryCode = 'ar-BH'
$langName = 'Arabic'
Case Hex(0x3C0A, 4)
$decimalCode = '15370'
$countryCode = 'es-PY'
$langName = 'Spanish'
Case Hex(0x4001, 4)
$decimalCode = '16385'
$countryCode = 'ar-QA'
$langName = 'Arabic'
Case Hex(0x4009, 4)
$decimalCode = '16393'
$countryCode = 'en-IN'
$langName = 'English'
Case Hex(0x400A, 4)
$decimalCode = '16394'
$countryCode = 'es-BO'
$langName = 'Spanish'
Case Hex(0x4409, 4)
$decimalCode = '17417'
$countryCode = 'en-MY'
$langName = 'English'
Case Hex(0x440A, 4)
$decimalCode = '17418'
$countryCode = 'es-SV'
$langName = 'Spanish'
Case Hex(0x4809, 4)
$decimalCode = '18441'
$countryCode = 'en-SG'
$langName = 'English'
Case Hex(0x480A, 4)
$decimalCode = '18442'
$countryCode = 'es-HN'
$langName = 'Spanish'
Case Hex(0x4C0A, 4)
$decimalCode = '19466'
$countryCode = 'es-NI'
$langName = 'Spanish'
Case Hex(0x500A, 4)
$decimalCode = '20490'
$countryCode = 'es-PR'
$langName = 'Spanish'
Case Hex(0x540A, 4)
$decimalCode = '21514'
$countryCode = 'es-US'
$langName = 'Spanish'
Case Hex(0x7C04, 4)
$decimalCode = '31748'
$countryCode = 'zh-CHT'
$langName = 'Chinese'
Case Else
SetLog("Your computer's language was not recognized.")
$langName = "NONE"
EndSwitch
SetLog("Detected System Locale: " & $langName, $COLOR_BLUE)
If FileExists($dirLanguages & "/" & $langName & ".ini") Then
SetLog("Language file " & $langName & ".ini found in " & $dirLanguages)
$sLanguage = $langName
IniWrite($config, "other", "language", $sLanguage)
Else
SetLog("Language file for " & $langName & " not found! Defaulting to English", $COLOR_RED)
$sLanguage = $sDefaultLanguage
EndIf
Else
$sLanguage = IniRead($config, "other", "language", $sDefaultLanguage)
EndIf
EndFunc
DetectLanguage()
Local $sMsg
$sMsg = GetTranslated(500, 1, "Don't Run/Compile the Script as (x64)! Try to Run/Compile the Script as (x86) to get the bot to work.\r\n" & "If this message still appears, try to re-install AutoIt.")
If @AutoItX64 = 1 Then
If IsHWnd($hSplash) Then GUIDelete($hSplash)
MsgBox(0, "", $sMsg)
_GDIPlus_Shutdown()
Exit
EndIf
Func MBRFunc($Start = True)
Switch $Start
Case True
$hFuncLib = DllOpen($pFuncLib)
$hImgLib = DllOpen($pImgLib)
If $hFuncLib = -1 Then
Setlog("MBRfunctions.dll not found.", $COLOR_RED)
Return False
EndIf
SetDebugLog("MBRfunctions.dll opened.")
Case False
DllClose($hFuncLib)
DllClose($hImgLib)
SetDebugLog("MBRfunctions.dll closed.")
EndSwitch
EndFunc
Func debugMBRFunctions($debugSearchArea = 0, $debugRedArea = 0, $debugOcr = 0)
SetDebugLog("debugMBRFunctions: $debugSearchArea=" & $debugSearchArea & ", $debugRedArea=" & $debugRedArea & ", $debugOcr=" & $debugOcr)
Local $activeHWnD = WinGetHandle("")
Local $result = DllCall($hFuncLib, "str", "setGlobalVar", "int", $debugSearchArea, "int", $debugRedArea, "int", $debugOcr)
If @error Then
_logErrorDLLCall($pFuncLib & ", setGlobalVar:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $debugSetlog = 1 And $result[0] = -1 Then SetLog("MBRfunctions.dll error setting Global vars.", $COLOR_DEBUG)
Else
SetDebugLog("MBRfunctions.dll not found.", $COLOR_RED)
EndIf
WinActivate($activeHWnD)
EndFunc
Func setAndroidPID($pid)
SetDebugLog("setAndroidPID: $pid=" & $pid)
Local $result = DllCall($hFuncLib, "str", "setAndroidPID", "int", $pid)
If @error Then
_logErrorDLLCall($pFuncLib & ", setAndroidPID:", @error)
Return SetError(@error)
EndIf
If IsArray($result) Then
If $result[0] = "" Then
SetDebugLog("MBRfunctions.dll error setting Android PID.")
Else
SetDebugLog("Android PID=" & $pid & " initialized: " & $result[0])
debugMBRFunctions($debugSearchArea, $debugRedArea, $debugOcr)
EndIf
Else
SetDebugLog("MBRfunctions.dll not found.", $COLOR_RED)
EndIf
EndFunc
If CheckPrerequisites() Then
MBRFunc(True)
EndIf
SplashStep(GetTranslated(500, 21, "Initializing Android..."))
InitAndroidConfig(True)
If $aCmdLine[0] > 1 Then
Local $i
For $i = 0 To UBound($AndroidAppConfig) - 1
If StringCompare($AndroidAppConfig[$i][0], $aCmdLine[2]) = 0 Then
$AndroidConfig = $i
If $AndroidAppConfig[$i][1] <> "" And $aCmdLine[0] > 2 Then
UpdateAndroidConfig($aCmdLine[3])
Else
UpdateAndroidConfig()
EndIf
EndIf
Next
EndIf
SplashStep(GetTranslated(500, 22, "Detecting Android..."))
If $aCmdLine[0] < 2 Then
DetectRunningAndroid()
If Not $FoundRunningAndroid Then DetectInstalledAndroid()
EndIf
Func UpdateAndroidConfig($instance = Default)
If $instance = "" Then $instance = Default
If $instance = Default Then $instance = $AndroidAppConfig[$AndroidConfig][1]
SetDebugLog("UpdateAndroidConfig(""" & $instance & """)")
InitAndroidConfig()
$AndroidInstance = $instance
Local $Result = InitAndroid()
SetDebugLog("UpdateAndroidConfig(""" & $instance & """) END")
Return $Result
EndFunc
Func UpdateAndroidWindowState()
Local $bChanged = Execute("Update" & $Android & "WindowState()")
If $bChanged = "" And @error <> 0 Then Return False
Return $bChanged
EndFunc
Func WinGetAndroidHandle($bInitAndroid = Default, $bTestPid = False)
If $bInitAndroid = Default Then $bInitAndroid = $InitAndroidActive = False
If $WinGetAndroidHandleActive = True Then
Return $HWnD
EndIf
$WinGetAndroidHandleActive = True
Local $currHWnD = $HWnD
If $HWnD = 0 Or $AndroidBackgroundLaunched = False Then _WinGetAndroidHandle()
If IsHWnd($HWnD) = 1 Then
Local $aPos = WinGetPos($HWnD)
AndroidQueueReboot(False)
If $currHWnD = 0 Or $currHWnD <> $HWnD Then
If $AndroidEmbedded = False And IsArray($aPos) = 1 And ($Hide = False Or ($aPos[0] > -30000 Or $aPos[1] > -30000)) Then
SetDebugLog("Move Android Window '" & $Title & "' to position: " & $AndroidPosX & ", " & $AndroidPosY)
WinMove2($HWnD, "", $AndroidPosX, $AndroidPosY)
$aPos[0] = $AndroidPosX
$aPos[1] = $AndroidPosY
EndIf
Local $instance = ($AndroidInstance = "" ? "" : " (" & $AndroidInstance & ")")
SetLog($Android & $instance & " running in window mode", $COLOR_ACTION)
If $currHWnD <> 0 And $currHWnD <> $HWnD Then
$InitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
EndIf
If $AndroidEmbedded = False And IsArray($aPos) = 1 Then
Local $posX = $AndroidPosX
Local $posY = $AndroidPosY
$AndroidPosX = ($aPos[0] > -30000 ? $aPos[0] : $AndroidPosX)
$AndroidPosY = ($aPos[1] > -30000 ? $aPos[1] : $AndroidPosY)
If $posX <> $AndroidPosX Or $posY <> $AndroidPosY Then
SetDebugLog("Updating Android Window '" & $Title & "' position: " & $AndroidPosX & ", " & $AndroidPosY)
EndIf
If $Hide = True And ($aPos[0] > -30000 Or $aPos[1] > -30000) Then
WinMove2($HWnD, "", -32000, -32000)
EndIf
EndIf
$WinGetAndroidHandleActive = False
Return $HWnD
EndIf
If $AndroidBackgroundLaunch = False And $bTestPid = False Then
$WinGetAndroidHandleActive = False
Return $HWnD
EndIf
If $HWnD <> 0 Then
If $HWnD = ProcessExists2($HWnD) Then
Else
Local $instance = ($AndroidInstance = "" ? "" : " (" & $AndroidInstance & ")")
SetDebugLog($Android & $instance & " process with PID = " & $HWnD & " not found")
$HWnD = 0
EndIf
EndIf
If $HWnD = 0 Then
If $AndroidProgramPath <> "" Then
Local $parameter = GetAndroidProgramParameter(False)
Local $parameter2 = GetAndroidProgramParameter(True)
Local $pid = ProcessExists2($AndroidProgramPath, $parameter, 0, 0, "Is" & $Android & "CommandLine")
If $pid = 0 And $parameter <> $parameter2 Then
$parameter = $parameter2
$pid = ProcessExists2($AndroidProgramPath, $parameter, 0, 0, "Is" & $Android & "CommandLine")
EndIf
Local $commandLine = $AndroidProgramPath & ($parameter = "" ? "" : " " & $parameter)
Local $instance = ($AndroidInstance = "" ? "" : " (" & $AndroidInstance & ")")
If $pid <> 0 Then
SetDebugLog("Found " & $Android & $instance & " process " & $pid & " ('" & $commandLine & "')")
If $bTestPid = True Then
$WinGetAndroidHandleActive = False
Return $pid
EndIf
If $AndroidAdbScreencap = True And $AndroidAdbClick = False And AndroidAdbClickSupported() = True Then
SetLog("Enabled ADB Click to support background mode", $COLOR_ACTION)
$AndroidAdbClick = True
EndIf
If $AndroidAdbClick = False Or $AndroidAdbScreencap = False Then
If $AndroidQueueReboot = False Then
SetLog("Headless Android not supported because", $COLOR_ERROR)
Local $reason = ""
If $AndroidAdbClick = False Then $reason &= "ADB Click " & ($AndroidAdbScreencap = False ? "and " : "")
If $AndroidAdbScreencap = False Then $reason &= "ADB Screencap "
$reason &= "not available!"
SetLog($reason, $COLOR_ERROR)
AndroidQueueReboot(True)
EndIf
$HWnD = $pid
If $currHWnD <> 0 And $currHWnD <> $HWnD Then
$InitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
Else
SetLog($Android & $instance & " running in headless mode", $COLOR_ACTION)
$HWnD = $pid
If $currHWnD <> 0 And $currHWnD <> $HWnD Then
$InitAndroid = True
If $bInitAndroid = True Then InitAndroid(True)
EndIf
$AndroidBackgroundLaunched = True
EndIf
setAndroidPID($pid)
Else
SetDebugLog($Android & $instance & " process not found")
EndIf
EndIf
EndIf
If $HWnD = 0 Then
$InitAndroid = True
$AndroidBackgroundLaunched = False
EndIf
$WinGetAndroidHandleActive = False
Return $HWnD
EndFunc
Func GetAndroidPid()
Local $h = WinGetAndroidHandle(Default, True)
If IsHWnd($h) Then Return WinGetProcess($h)
Return $h
EndFunc
Func _WinGetAndroidHandle($bFindByTitle = False)
Local $hWin = WinGetHandle($HWnD)
If $hWin > 0 And $hWin = $HWnD Then Return $HWnD
Local $i
Local $t
Local $ReInitAndroid = $HWnD <> 0
SetDebugLog("Searching " & $Android & " Window: Title = '" & $Title & "', Class = '" & $AppClassInstance & "', Text = '" & $AppPaneName & "'")
Local $aWinList
If $bFindByTitle = True Then
$aWinList = WinList($Title)
If $aWinList[0][0] > 0 Then
For $i = 1 To $aWinList[0][0]
$hWin = $aWinList[$i][1]
$t = $aWinList[$i][0]
If $Title = $t Then
Local $hCtrl = ControlGetHandle($hWin, $AppPaneName, $AppClassInstance)
If $hCtrl <> 0 Then
SetDebugLog("Found " & $Android & " Window '" & $t & "' (" & $hWin & ") by matching title '" & $Title & "' (#1)")
$HWnD = $hWin
$Title = UpdateAndroidWindowTitle($HWnD, $t)
If $ReInitAndroid = True And $InitAndroid = False Then
$InitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
EndIf
Next
EndIf
Local $iMode = Opt("WinTitleMatchMode", -1)
$hWin = WinGetHandle($Title)
Local $error = @error
Opt("WinTitleMatchMode", $iMode)
If $error = 0 Then
$t = WinGetTitle($hWin)
If $Title = $t And ControlGetHandle($hWin, $AppPaneName, $AppClassInstance) <> 0 Then
If $HWnD <> $hWin Then SetDebugLog("Found " & $Android & " Window '" & $t & "' (" & $hWin & ") by matching title '" & $Title & "' (#2)")
$HWnD = $hWin
$Title = UpdateAndroidWindowTitle($HWnD, $t)
If $ReInitAndroid = True And $InitAndroid = False Then
$InitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
Else
SetDebugLog($Android & " Window title '" & $t & "' not matching '" & $Title & "' or control")
EndIf
EndIf
$iMode = Opt("WinTitleMatchMode", -1)
$aWinList = WinList($Title)
Opt("WinTitleMatchMode", $iMode)
If $aWinList[0][0] = 0 Then
SetDebugLog($Android & " Window not found")
If $ReInitAndroid = True Then $InitAndroid = True
$HWnD = 0
AndroidEmbed(False, False)
Return 0
EndIf
SetDebugLog("Found " & $aWinList[0][0] & " possible " & $Android & " windows by title '" & $Title & "':")
For $i = 1 To $aWinList[0][0]
SetDebugLog($aWinList[$i][1] & ": " & $aWinList[$i][0])
Next
If $AndroidInstance <> "" Then
For $i = 1 To $aWinList[0][0]
$t = $aWinList[$i][0]
$hWin = $aWinList[$i][1]
If StringRight($t, StringLen($AndroidInstance)) = $AndroidInstance And ControlGetHandle($hWin, $AppPaneName, $AppClassInstance) <> 0 Then
SetDebugLog("Found " & $Android & " Window '" & $t & "' (" & $hWin & ") for instance " & $AndroidInstance)
$HWnD = $hWin
$Title = UpdateAndroidWindowTitle($HWnD, $t)
If $ReInitAndroid = True And $InitAndroid = False Then
$InitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
Next
EndIf
EndIf
If $AndroidProgramPath <> "" Then
Local $parameter = GetAndroidProgramParameter(False)
Local $parameter2 = GetAndroidProgramParameter(True)
Local $pid = ProcessExists2($AndroidProgramPath, $parameter, 0, 0, "Is" & $Android & "CommandLine")
If $pid = 0 And $parameter <> $parameter2 Then
$parameter = $parameter2
$pid = ProcessExists2($AndroidProgramPath, $parameter, 0, 0, "Is" & $Android & "CommandLine")
EndIf
Local $commandLine = $AndroidProgramPath & ($parameter = "" ? "" : " " & $parameter)
If $pid <> 0 Then
If IsArray($aWinList) = 0 Then
Local $aWinList2 = _WinAPI_EnumProcessWindows($pid, True)
If IsArray($aWinList2) = 1 And $aWinList2[0][0] > 0 Then
Local $aWinList[$aWinList2[0][0] + 1][2]
$aWinList[0][0] = $aWinList2[0][0]
For $i = 1 To $aWinList2[0][0]
$aWinList[$i][0] = WinGetTitle($aWinList2[$i][0])
$aWinList[$i][1] = $aWinList2[$i][0]
Next
EndIf
EndIf
If IsArray($aWinList) = 1 Then
For $i = 1 To $aWinList[0][0]
$t = $aWinList[$i][0]
$hWin = $aWinList[$i][1]
If $pid = WinGetProcess($hWin) And ControlGetHandle($hWin, $AppPaneName, $AppClassInstance) <> 0 Then
SetDebugLog("Found " & $Android & " Window '" & $t & "' (" & $hWin & ") by PID " & $pid & " ('" & $commandLine & "')")
$HWnD = $hWin
$Title = UpdateAndroidWindowTitle($HWnD, $t)
If $ReInitAndroid = True And $InitAndroid = False Then
$InitAndroid = True
InitAndroid()
EndIf
AndroidEmbed(False, False)
setAndroidPID(GetAndroidPid())
Return $hWin
EndIf
Next
EndIf
SetDebugLog($Android & ($AndroidInstance = "" ? "" : " (" & $AndroidInstance & ")") & " Window not found for PID " & $pid)
EndIf
EndIf
SetDebugLog($Android & ($AndroidInstance = "" ? "" : " (" & $AndroidInstance & ")") & " Window not found in list")
If $ReInitAndroid = True Then $InitAndroid = True
$HWnD = 0
AndroidEmbed(False, False)
Return 0
EndFunc
Func UpdateAndroidWindowTitle($hWin, $t)
If $UpdateAndroidWindowTitle = True And $AndroidInstance <> "" And StringInStr($t, $AndroidInstance) = 0 Then
$t &= " (" & $AndroidInstance & ")"
_WinAPI_SetWindowText($hWin, $t)
EndIf
Return $t
EndFunc
Func AndroidControlAvailable()
If $AndroidBackgroundLaunched = True Then
Return 0
EndIf
Return IsArray(GetAndroidPos(True))
EndFunc
Func GetAndroidSvcPid()
If $AndroidSvcPid <> 0 And $AndroidSvcPid = ProcessExists2($AndroidSvcPid) Then
Return $AndroidSvcPid
EndIf
SetError(0, 0, 0)
Local $pid = Execute("Get" & $Android & "SvcPid()")
If $pid = "" And @error <> 0 Then $pid = GetVBoxAndroidSvcPid()
If $pid <> 0 Then
SetDebugLog("Found " & $Android & " Service PID = " & $pid)
Else
SetDebugLog("Cannot find " & $Android & " Service PID", $COLOR_ERROR)
EndIf
$AndroidSvcPid = $pid
Return $pid
EndFunc
Func GetVBoxAndroidSvcPid()
Local $aRegExResult = StringRegExp($__VBoxVMinfo, "UUID:\s+(.+)", $STR_REGEXPARRAYMATCH)
Local $uuid = ""
If Not @error Then $uuid = $aRegExResult[0]
If StringLen($uuid) < 32 Then
SetDebugLog("Cannot find VBox UUID", $COLOR_ERROR)
Return 0
EndIf
Local $pid = ProcessExists2("", $uuid, 1, 1)
Return $pid
EndFunc
Func GetAndroidRunningInstance($bStrictCheck = True)
Local $runningInstance = Execute("Get" & $Android & "RunningInstance(" & $bStrictCheck & ")")
Local $i
If $runningInstance = "" And @error <> 0 Then
Local $a[2] = [0, ""]
SetDebugLog("GetAndroidRunningInstance: Try to find """ & $AndroidProgramPath & """")
Local $pids = ProcessesExist($AndroidProgramPath, "", 1)
If UBound($pids) > 0 Then
Local $currentInstance = $AndroidInstance
For $i = 0 To UBound($pids) - 1
Local $pid = $pids[$i]
Local $commandLine = ProcessGetCommandLine($pid)
SetDebugLog("GetAndroidRunningInstance: Found """ & $commandLine & """ by PID=" & $pid)
Local $lastSpace = StringInStr($commandLine, " ", 0, -1)
If $lastSpace > 0 Then
$AndroidInstance = StringStripWS(StringMid($commandLine, $lastSpace + 1), 3)
If $AndroidInstance = "" Then $AndroidInstance = $AndroidAppConfig[$AndroidConfig][1]
EndIf
If WinGetAndroidHandle() <> 0 Then
SetDebugLog("Running " & $Android & " instance found: """ & $AndroidInstance & """")
If $a[0] = 0 Or $AndroidInstance = $currentInstance Then
$a[0] = $HWnD
$a[1] = $AndroidInstance
If $AndroidInstance = $currentInstance Then ExitLoop
EndIf
Else
$AndroidInstance = $currentInstance
EndIf
Next
EndIf
If $a[0] <> 0 Then SetDebugLog("Running " & $Android & " instance is """ & $AndroidInstance & """")
Return $a
EndIf
Return $runningInstance
EndFunc
Func DetectRunningAndroid()
SetDebugLog("DetectRunningAndroid()")
$FoundRunningAndroid = False
Local $i, $CurrentConfig = $AndroidConfig
$SilentSetLog = True
For $i = 0 To UBound($AndroidAppConfig) - 1
$AndroidConfig = $i
$InitAndroid = True
If UpdateAndroidConfig() = True Then
Local $aRunning = GetAndroidRunningInstance(False)
If $aRunning[0] = 0 Then
Else
$FoundRunningAndroid = True
$SilentSetLog = False
$InitAndroid = True
If InitAndroid() = True Then
SetDebugLog("Found running " & $Android & " " & $AndroidVersion)
EndIf
Return
EndIf
EndIf
Next
$InitAndroid = True
$AndroidConfig = $CurrentConfig
UpdateAndroidConfig()
$SilentSetLog = False
SetDebugLog("Found no running Android Emulator")
EndFunc
Func DetectInstalledAndroid()
SetDebugLog("DetectInstalledAndroid()")
Local $i, $CurrentConfig = $AndroidConfig
$SilentSetLog = True
For $i = 0 To UBound($AndroidAppConfig) - 1
$AndroidConfig = $i
$InitAndroid = True
If UpdateAndroidConfig() Then
$FoundInstalledAndroid = True
$SilentSetLog = False
SetDebugLog("Found installed " & $Android & " " & $AndroidVersion)
Return
EndIf
Next
$AndroidConfig = $CurrentConfig
$InitAndroid = True
UpdateAndroidConfig()
$SilentSetLog = False
SetDebugLog("Found no installed Android Emulator")
EndFunc
Func FindPreferredAdbPath()
Local $adbPath, $i
For $i = 0 To UBound($AndroidAppConfig) - 1
$adbPath = Execute("Get" & $AndroidAppConfig[$i][0] & "AdbPath()")
If $adbPath <> "" Then Return $adbPath
Next
Return ""
EndFunc
Func InitAndroid($bCheckOnly = False)
If $bCheckOnly = False And $InitAndroid = False Then
Return True
EndIf
$InitAndroidActive = True
SetDebugLog("InitAndroid(" & $bCheckOnly & "): " & $Android)
If Not $bCheckOnly Then
If $AndroidInstance = "" Then $AndroidInstance = $AndroidAppConfig[$AndroidConfig][1]
EndIf
Local $Result = Execute("Init" & $Android & "(" & $bCheckOnly & ")")
If $Result = "" And @error <> 0 Then
SetLog("Android support for " & $Android & " is not available", $COLOR_ERROR)
EndIf
Local $successful = @error = 0
If Not $bCheckOnly And $Result Then
Local $pAndroidFileVersionInfo
If _WinAPI_GetFileVersionInfo($AndroidProgramPath, $pAndroidFileVersionInfo) Then
$AndroidProgramFileVersionInfo = _WinAPI_VerQueryValue($pAndroidFileVersionInfo)
Else
$AndroidProgramFileVersionInfo = 0
EndIf
SetDebugLog("Android: " & $Android)
SetDebugLog("Android Config: " & $AndroidConfig)
SetDebugLog("Android Version: " & $AndroidVersion)
SetDebugLog("Android Instance: " & $AndroidInstance)
SetDebugLog("Android Window Title: " & $Title)
SetDebugLog("Android Program Path: " & $AndroidProgramPath)
SetDebugLog("Android Program Parameter: " & GetAndroidProgramParameter())
SetDebugLog("Android Program FileVersionInfo: " & ((IsArray($AndroidProgramFileVersionInfo) ? _ArrayToString($AndroidProgramFileVersionInfo, ",", 1) : "not available")))
SetDebugLog("Android ADB Path: " & $AndroidAdbPath)
SetDebugLog("Android ADB Device: " & $AndroidAdbDevice)
SetDebugLog("Android ADB Shared Folder: " & $AndroidPicturesPath)
If FileExists($AndroidPicturesHostPath) Then
DirCreate($AndroidPicturesHostPath & $AndroidPicturesHostFolder)
AddFolderToInUseList()
ElseIf $AndroidPicturesHostPath <> "" Then
SetLog("Shared Folder doesn't exist, please fix:", $COLOR_ERROR)
SetLog($AndroidPicturesHostPath, $COLOR_ERROR)
EndIf
SetDebugLog("Android ADB Shared Folder on Host: " & $AndroidPicturesHostPath)
SetDebugLog("Android ADB Shared SubFolder: " & $AndroidPicturesHostFolder)
SetDebugLog("Android Mouse Device: " & $AndroidMouseDevice)
SetDebugLog("Android ADB screencap command enabled: " & $AndroidAdbScreencap)
SetDebugLog("Android ADB input command enabled: " & $AndroidAdbInput)
SetDebugLog("Android ADB Mouse Click enabled: " & $AndroidAdbClick)
SetDebugLog("Android ADB Click Drag enabled: " & $AndroidAdbClickDrag)
SetDebugLog("Bot Background Mode for screen capture: " & ($ichkBackground = 1 ? "enabled" : "disabled"))
SetDebugLog("No Focus Tampering: " & $NoFocusTampering)
WinGetAndroidHandle()
InitAndroidTimeLag()
InitAndroidPageError()
$InitAndroid = Not $successful
Else
If $bCheckOnly = False Then $InitAndroid = True
EndIf
SetDebugLog("InitAndroid(" & $bCheckOnly & "): " & $Android & " END, initialization successful = " & $successful & ", result = " & $Result)
$InitAndroidActive = False
Return $Result
EndFunc
Func GetAndroidProgramParameter($bAlternative = False)
Local $parameter = Execute("Get" & $Android & "ProgramParameter(" & $bAlternative & ")")
If $parameter = "" And @error <> 0 Then $parameter = ""
Return $parameter
EndFunc
Func AndroidBotStartEvent()
reHide()
Local $Result = Execute($Android & "BotStartEvent()")
If $Result = "" And @error <> 0 Then $Result = ""
Return $Result
EndFunc
Func AndroidBotStopEvent()
Local $Result = Execute($Android & "BotStopEvent()")
If $Result = "" And @error <> 0 Then $Result = ""
Return $Result
EndFunc
Func OpenAndroid($bRestart = False)
If $OpenAndroidActive >= $OpenAndroidActiveMaxTry Then
SetLog("Cannot open " & $Android & ", tried " & $OpenAndroidActive & " times...", $COLOR_ERROR)
btnStop()
Return False
EndIf
$OpenAndroidActive += 1
If $OpenAndroidActive > 1 Then
SetDebugLog("Opening " & $Android & " recursively " & $OpenAndroidActive & ". time...")
EndIf
Local $Result = _OpenAndroid($bRestart)
WinGetAndroidHandle()
$OpenAndroidActive -= 1
Return $Result
EndFunc
Func _OpenAndroid($bRestart = False)
ResumeAndroid()
If Not InitAndroid() Then
SetLog("Unable to open " & $Android & ($AndroidInstance = "" ? "" : " instance '" & $AndroidInstance & "'"), $COLOR_ERROR)
SetLog("Please check emulator/installation", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_ERROR)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
AndroidAdbTerminateShellInstance()
If Not $RunState Then Return False
WerFaultClose($AndroidProgramPath)
If $AndroidBackgroundLaunch = False And WinGetAndroidHandle(Default, True) <> 0 Then
CloseAndroid()
EndIf
If Not Execute("Open" & $Android & "(" & $bRestart & ")") Then Return False
If Not InitiateLayout() Then Return False
WinGetAndroidHandle(False)
If Not $RunState Then Return False
AndroidBotStartEvent()
If Not $RunState Then Return False
If Not StartAndroidCoC() Then Return False
If $bRestart = False Then
waitMainScreenMini()
If Not $RunState Then Return False
Zoomout()
Else
WaitMainScreenMini()
If Not $RunState Then Return False
If @error = 1 Then
$Restart = True
$Is_ClientSyncError = False
Return False
EndIf
Zoomout()
EndIf
If Not $RunState Then Return False
Return True
EndFunc
Func StartAndroidCoC()
Return RestartAndroidCoC(False, False)
EndFunc
Func RestartAndroidCoC($bInitAndroid = True, $bRestart = True)
$SkipFirstZoomout = False
ResumeAndroid()
If Not $RunState Then Return False
If $bInitAndroid Then
If Not InitAndroid() Then Return False
EndIf
Local $cmdOutput, $process_killed, $connected_to
Local $sRestart = ""
If $bRestart = True Then
SetLog("Please wait for CoC restart......", $COLOR_INFO)
$sRestart = "-S "
Else
SetLog("Launch Clash of Clans now...", $COLOR_SUCCESS)
EndIf
ConnectAndroidAdb()
If Not $RunState Then Return False
AndroidAdbTerminateShellInstance()
If Not $RunState Then Return False
$cmdOutput = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " shell am start " & $sRestart & "-n " & $AndroidGamePackage & "/" & $AndroidGameClass, $process_killed, 30 * 1000)
If StringInStr($cmdOutput, "Error:") > 0 And StringInStr($cmdOutput, $AndroidGamePackage) > 0 Then
SetLog("Unable to load Clash of Clans, install/reinstall the game.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
If Not IsAdbConnected($cmdOutput) Then
If Not ConnectAndroidAdb() Then Return False
EndIf
If Not $RunState Then Return False
AndroidAdbLaunchShellInstance()
Return True
EndFunc
Func CloseAndroid()
ResumeAndroid()
SetLog("Stopping " & $Android & "....", $COLOR_INFO)
AndroidAdbTerminateShellInstance()
If Not $RunState Then Return False
SetLog("Please wait for full " & $Android & " shutdown...", $COLOR_SUCCESS)
Local $pid = GetAndroidPid()
If ProcessExists2($pid) Then
KillProcess($pid, "CloseAndroid")
If _SleepStatus(1000) Then Return False
EndIf
Local $Result = Execute("Close" & $Android & "()")
If Not $RunState Then Return False
If ProcessExists2($pid) Then
SetLog("Failed to stop " & $Android, $COLOR_ERROR)
Else
SetLog($Android & " stopped successfully", $COLOR_SUCCESS)
EndIf
If Not $RunState Then Return False
RemoveGhostTrayIcons()
EndFunc
Func CloseVboxAndroidSvc()
Local $process_killed
If Not $RunState Then Return
LaunchConsole($__VBoxManage_Path, "controlvm " & $AndroidInstance & " poweroff", $process_killed)
If _SleepStatus(3000) Then Return
EndFunc
Func CheckAndroidRunning($bQuickCheck = True, $bStartIfRequired = True)
Local $hWin = $HWnD
If WinGetAndroidHandle() = 0 Or ($bQuickCheck = False And $AndroidBackgroundLaunched = False And AndroidControlAvailable() = 0) Then
SetDebugLog($Android & " not running")
If $bStartIfRequired = True Then
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
EndIf
Return False
EndIf
Return True
EndFunc
Func SetScreenAndroid()
ResumeAndroid()
If Not $RunState Then Return False
SetLog("Set " & $Android & " screen resolution to " & $AndroidClientWidth & " x " & $AndroidClientHeight, $COLOR_INFO)
Local $Result = Execute("SetScreen" & $Android & "()")
If $Result Then
SetLog("A restart of your computer might be required", $COLOR_ACTION)
SetLog("for the applied changes to take effect.", $COLOR_ACTION)
EndIf
Return $Result
EndFunc
Func CloseUnsupportedAndroid()
ResumeAndroid()
If Not $RunState Then Return False
SetError(0, 0, 0)
Local $Closed = Execute("CloseUnsupported" & $Android & "()")
If $Closed = "" And @error <> 0 Then Return False
Return $Closed
EndFunc
Func RebootAndroidSetScreen()
ResumeAndroid()
If Not $RunState Then Return False
Return Execute("Reboot" & $Android & "SetScreen()")
EndFunc
Func IsAdbTCP()
Return StringInStr($AndroidAdbDevice, ":") > 0
EndFunc
Func WaitForRunningVMS($WaitInSec = 120, $hTimer = 0)
ResumeAndroid()
If Not $RunState Then Return True
Local $cmdOutput, $connected_to, $running, $process_killed, $hMyTimer
$hMyTimer = ($hTimer = 0 ? TimerInit() : $hTimer)
While True
If Not $RunState Then Return True
$cmdOutput = LaunchConsole($__VBoxManage_Path, "list runningvms", $process_killed)
If Not $RunState Then Return True
$running = StringInStr($cmdOutput, """" & $AndroidInstance & """") > 0
If $running = True Then ExitLoop
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
_Sleep(3000)
If TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($Android & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for boot completed", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
WEnd
Return False
EndFunc
Func WaitForAndroidBootCompleted($WaitInSec = 120, $hTimer = 0)
ResumeAndroid()
If Not $RunState Then Return True
Local $cmdOutput, $connected_to, $booted, $process_killed, $hMyTimer
$hMyTimer = ($hTimer = 0 ? TimerInit() : $hTimer)
While True
If Not $RunState Then Return True
$cmdOutput = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " shell getprop sys.boot_completed", $process_killed)
If Not $RunState Then Return True
$connected_to = IsAdbConnected($cmdOutput)
If Not $RunState Then Return True
If Not $connected_to Then ConnectAndroidAdb(False)
If Not $RunState Then Return True
$booted = StringLeft($cmdOutput, 1) = "1"
If $booted = True Then ExitLoop
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
If _Sleep(3000) Then Return True
If TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($Android & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for boot completed", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
WEnd
Return False
EndFunc
Func IsAdbConnected($cmdOutput = Default)
ResumeAndroid()
If $__TEST_ERROR_ADB_DEVICE_NOT_FOUND Then Return False
Local $process_killed, $connected_to
If $cmdOutput = Default Then
If IsAdbTCP() Then
$cmdOutput = LaunchConsole($AndroidAdbPath, "connect " & $AndroidAdbDevice, $process_killed)
$connected_to = StringInStr($cmdOutput, "connected to") > 0
If $connected_to Then
$cmdOutput = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " shell whoami", $process_killed)
$connected_to = StringInStr($cmdOutput, "device ") = 0
EndIf
Else
$cmdOutput = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " shell whoami", $process_killed)
$connected_to = StringInStr($cmdOutput, " not ") = 0
EndIf
Else
$connected_to = StringInStr($cmdOutput, " not ") = 0
EndIf
Return $connected_to
EndFunc
Func AquireAdbDaemonMutex($timout = 30000)
Local $timer = TimerInit()
Local $hMutex_MyBot = 0
While $hMutex_MyBot = 0 And TimerDiff($timer) < $timout
$hMutex_MyBot = _Singleton("MyBot.run/AdbDaemonLaunch", 1)
If $hMutex_MyBot <> 0 Then ExitLoop
If _Sleep(250) Then ExitLoop
WEnd
Return $hMutex_MyBot
EndFunc
Func ReleaseAdbDaemonMutex($hMutex, $ReturnValue = Default)
_WinAPI_CloseHandle($hMutex)
If $ReturnValue = Default Then Return
Return $ReturnValue
EndFunc
Func ConnectAndroidAdb($rebootAndroidIfNeccessary = $RunState, $timeout = 15000)
If $AndroidAdbPath = "" Or FileExists($AndroidAdbPath) = 0 Then
SetLog($Android & " ADB Path not valid: " & $AndroidAdbPath, $COLOR_ERROR)
Return False
EndIf
ResumeAndroid()
If $rebootAndroidIfNeccessary = True Then
WinGetAndroidHandle()
If AndroidInvalidState() Then
RebootAndroid()
EndIf
EndIf
Local $hMutex = AquireAdbDaemonMutex()
Local $process_killed, $cmdOutput
Local $connected_to = False
Local $timer = TimerInit()
While TimerDiff($timer) < $timeout
$connected_to = IsAdbConnected()
If $connected_to Then Return ReleaseAdbDaemonMutex($hMutex, True)
Local $ms = $timeout - TimerDiff($timer)
If $ms > 3000 Then $ms = 3000
If _Sleep($ms) Then Return ReleaseAdbDaemonMutex($hMutex, False)
WEnd
SetDebugLog("Stop ADB daemon!", $COLOR_ERROR)
LaunchConsole($AndroidAdbPath, "kill-server", $process_killed)
Local $pids = ProcessesExist($AndroidAdbPath, "", 1)
For $i = 0 To UBound($pids) - 1
KillProcess($pids[$i], $AndroidAdbPath)
Next
$connected_to = IsAdbConnected()
ReleaseAdbDaemonMutex($hMutex)
If Not $connected_to And $RunState = True And $rebootAndroidIfNeccessary = True Then
SetLog("ADB cannot connect to " & $Android & ", restart emulator now...", $COLOR_ERROR)
If Not RebootAndroid() Then Return False
$connected_to = ConnectAndroidAdb(False)
If Not $connected_to Then
If Not $RunState Then Return False
SetLog("ADB really cannot connect to " & $Android & "!", $COLOR_ERROR)
SetLog("Please restart bot, emulator and/or PC...", $COLOR_ERROR)
EndIf
EndIf
Return $connected_to
EndFunc
Func RebootAndroid($bRestart = True)
ResumeAndroid()
If Not $RunState Then Return False
If CloseUnsupportedAndroid() Then
Else
CloseAndroid()
EndIf
If _Sleep(1000) Then Return False
Return OpenAndroid($bRestart)
EndFunc
Func RebootAndroidSetScreenDefault()
ResumeAndroid()
If Not $RunState Then Return False
AndroidSetFontSizeNormal()
If Not $RunState Then Return False
CloseAndroid()
If _Sleep(1000) Then Return False
SetScreenAndroid()
If Not $RunState Then Return False
Return OpenAndroid(True)
EndFunc
Func CheckScreenAndroid($ClientWidth, $ClientHeight, $bSetLog = True)
ResumeAndroid()
If Not $RunState Then Return True
AndroidAdbLaunchShellInstance()
If Not $RunState Then Return True
Local $AndroidWinPos = WinGetPos($HWnD)
If IsArray($AndroidWinPos) = 1 Then
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
If $WinWidth <> $AndroidWindowWidth Or $WinHeight <> $AndroidWindowHeight Then
SetDebugLog("CheckScreenAndroid: Window size " & $WinWidth & " x " & $WinHeight & " <> " & $AndroidWindowWidth & " x " & $AndroidWindowHeight, $COLOR_ERROR)
Else
SetDebugLog("CheckScreenAndroid: Window size " & $WinWidth & " x " & $WinHeight)
EndIf
EndIf
Local $ok = ($ClientWidth = $AndroidClientWidth) And ($ClientHeight = $AndroidClientHeight)
If Not $ok Then
If $bSetLog Then SetLog("MyBot doesn't work with " & $Android & " screen resolution of " & $ClientWidth & " x " & $ClientHeight & "!", $COLOR_ERROR)
SetDebugLog("CheckScreenAndroid: " & $ClientWidth & " x " & $ClientHeight & " <> " & $AndroidClientWidth & " x " & $AndroidClientHeight)
Return False
EndIf
AndroidAdbLaunchShellInstance()
Local $s_font_scale = AndroidAdbSendShellCommand("settings get system font_scale")
Local $font_scale = Number($s_font_scale)
If $font_scale > 0 Then
SetDebugLog($Android & " font_scale = " & $font_scale)
If $font_scale <> 1 Then
SetLog("MyBot doesn't work with Display Font Scale of " & $font_scale, $COLOR_ERROR)
Return False
EndIf
Else
Switch $Android
Case "BlueStacks", "BlueStacks2"
Case Else
SetDebugLog($Android & " Display Font Scale cannot be verified", $COLOR_ERROR)
EndSwitch
EndIf
SetError(0, 0, 0)
$ok = Execute("CheckScreen" & $Android & "(" & $bSetLog & ")")
If $ok = "" And @error <> 0 Then Return True
Return $ok
EndFunc
Func AndroidSetFontSizeNormal()
ResumeAndroid()
AndroidAdbLaunchShellInstance($RunState, False)
SetLog("Set " & $Android & " Display Font Scale to normal", $COLOR_INFO)
AndroidAdbSendShellCommand("settings put system font_scale 1.0")
EndFunc
Func AndroidAdbLaunchShellInstance($wasRunState = $RunState, $rebootAndroidIfNeccessary = $RunState)
If $AndroidAdbPid = 0 Or ProcessExists2($AndroidAdbPid) <> $AndroidAdbPid Then
Local $SuspendMode = ResumeAndroid()
InitAndroid()
Local $s
Local $hostFolder = $AndroidPicturesHostPath & $AndroidPicturesHostFolder
If FileExists($hostFolder) = 1 Then
SetDebugLog($hostFolder & " exists")
Local $aTools[1] = ["sleep"]
Local $tool
For $tool in $aTools
Local $srcFile = $AdbScriptsDir & "\" & $tool
Local $dstFile = $hostFolder & $tool
SetDebugLog($srcFile & " -> " & $dstFile)
If FileGetTime($srcFile, $FT_MODIFIED, $FT_STRING) <> FileGetTime($dstFile, $FT_MODIFIED, $FT_STRING) Then
FileCopy($srcFile, $dstFile, $FC_OVERWRITE)
EndIf
Next
EndIf
If $AndroidAdbInstance = True Then
If ConnectAndroidAdb($rebootAndroidIfNeccessary) = False Then
Return SetError(3, 0)
EndIf
$AndroidAdbPid = Run($AndroidAdbPath & " -s " & $AndroidAdbDevice & " shell", "", @SW_HIDE, BitOR($STDIN_CHILD, $STDERR_MERGED))
If $AndroidAdbPid = 0 Or ProcessExists2($AndroidAdbPid) <> $AndroidAdbPid Then
SetLog($Android & " error launching ADB for background mode, zoom-out, mouse click and input", $COLOR_ERROR)
$AndroidAdbScreencap = False
$AndroidAdbClick = False
$AndroidAdbInput = False
If BitAND($AndroidSupportFeature, 1) = 0 Then $ichkBackground = 0
SetError(1, 0)
EndIf
$s = AndroidAdbSendShellCommand("PS1=" & $AndroidAdbPrompt, Default, $wasRunState, False)
Local $scriptFile = ""
If $scriptFile = "" And FileExists($AdbScriptsDir & "\shell.init." & $Android & ".script") = 1 Then $scriptFile = "shell.init." & $Android & ".script"
If $scriptFile = "" Then $scriptFile = "shell.init.script"
$s &= AndroidAdbSendShellCommandScript($scriptFile, Default, Default, Default, $wasRunState, False)
Local $error = @error
SetDebugLog("ADB shell launched, PID = " & $AndroidAdbPid & ": " & $s)
If $error <> 0 Then
SuspendAndroid($SuspendMode)
Return
EndIf
EndIf
If StringLen($AndroidMouseDevice) > 0 And $AndroidMouseDevice = $AndroidAppConfig[$AndroidConfig][13] Then
If ConnectAndroidAdb() = False Then
Return SetError(3, 0)
EndIf
If StringInStr($AndroidMouseDevice, "/dev/input/event") = 0 Then
$s = AndroidAdbSendShellCommand("getevent -p", Default, $wasRunState, False)
SetDebugLog($Android & " getevent -p: " & $s)
Local $aRegExResult = StringRegExp($s, "(\/dev\/input\/event\d+)[\r\n]+.+""" & $AndroidMouseDevice & """((?!\/dev\/input\/event)[\s\S])+ABS", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$AndroidMouseDevice = $aRegExResult[0]
SetDebugLog("Using " & $AndroidMouseDevice & " for mouse events")
Else
$AndroidAdbClick = False
SetLog($Android & " cannot use ADB for mouse events, """ & $AndroidMouseDevice & """ not found", $COLOR_ERROR)
SuspendAndroid($SuspendMode)
Return SetError(2, 1)
EndIf
EndIf
SuspendAndroid($SuspendMode)
Return SetError(0, 1)
Else
SetDebugLog($Android & " ADB use " & $AndroidMouseDevice & " for mouse events")
EndIf
EndIf
SetError(0, 0)
EndFunc
Func AndroidAdbTerminateShellInstance()
Local $SuspendMode = ResumeAndroid()
If $AndroidAdbPid <> 0 Then
If ProcessClose($AndroidAdbPid) = 1 Then
SetDebugLog("ADB shell terminated, PID = " & $AndroidAdbPid)
Else
SetDebugLog("ADB shell not terminated, PID = " & $AndroidAdbPid, $COLOR_ERROR)
EndIf
$AndroidAdbPid = 0
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func AndroidAdbSendShellCommand($cmd = Default, $timeout = Default, $wasRunState = Default, $EnsureShellInstance = True)
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
Local $Result = _AndroidAdbSendShellCommand($cmd, $timeout, $wasRunState, $EnsureShellInstance)
$TogglePauseAllowed = $wasAllowed
Return SetError(@error, @extended, $Result)
EndFunc
Func _AndroidAdbSendShellCommand($cmd = Default, $timeout = Default, $wasRunState = Default, $EnsureShellInstance = True)
Local $_SilentSetLog = $SilentSetLog
If $timeout = Default Then $timeout = 3000
If $wasRunState = Default Then $wasRunState = $RunState
Local $sentBytes = 0
Local $SuspendMode = ResumeAndroid()
SetError(0, 0, 0)
If $EnsureShellInstance = True Then
AndroidAdbLaunchShellInstance($wasRunState)
EndIf
If @error <> 0 Then Return SetError(@error, 0, "")
Local $hTimer = TimerInit()
Local $s = ""
Local $loopCount = 0
Local $cleanOutput = True
If $AndroidAdbInstance = True Then
StdoutRead($AndroidAdbPid)
If $cmd = Default Then
Else
If $debugSetlog = 1 Then
$SilentSetLog = True
SetDebugLog("Send ADB shell command: " & $cmd, $COLOR_DEBUG)
$SilentSetLog = $_SilentSetLog
EndIf
$sentBytes = StdinWrite($AndroidAdbPid, $cmd & @LF)
EndIf
While $timeout > 0 And @error = 0 And StringRight($s, StringLen($AndroidAdbPrompt) + 1) <> @LF & $AndroidAdbPrompt And TimerDiff($hTimer) < $timeout
Sleep(10)
$s &= StdoutRead($AndroidAdbPid)
$loopCount += 1
If $wasRunState = True And $RunState = False Then ExitLoop
WEnd
Else
$cleanOutput = False
If $cmd = Default Then
Else
Local $process_killed
If $debugSetlog = 1 Then
$SilentSetLog = True
SetDebugLog("Execute ADB shell command: " & $cmd, $COLOR_DEBUG)
$SilentSetLog = $_SilentSetLog
EndIf
$s = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " shell " & $cmd, $process_killed, $timeout)
EndIf
EndIf
If $cleanOutput = True Then
Local $i = StringInStr($s, @LF)
If $i > 0 Then $s = StringMid($s, $i)
If StringRight($s, StringLen($AndroidAdbPrompt) + 1) = @LF & $AndroidAdbPrompt Then $s = StringLeft($s, StringLen($s) - StringLen($AndroidAdbPrompt) - 1)
CleanLaunchOutput($s)
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
EndIf
Local $sRemove = "WARNING: linker: libdvm.so has text relocations. This is wasting memory and is a security risk. Please fix."
If StringLen($s) >= StringLen($sRemove) And StringLeft($s, StringLen($sRemove)) = $sRemove Then
$s = StringMid($s, StringLen($sRemove) + 1)
If StringLeft($s, 1) = @LF Then $s = StringMid($s, 2)
EndIf
If $AndroidAdbInstance = True And $debugSetlog = 1 And StringLen($s) > 0 Then SetDebugLog("ADB shell command output: " & $s, $COLOR_DEBUG)
SuspendAndroid($SuspendMode)
Local $error = (($RunState = False Or TimerDiff($hTimer) < $timeout Or $timeout < 1) ? 0 : 1)
If $error <> 0 Then SetDebugLog("ADB shell command error " & $error & ": " & $s)
If $__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_SHELL_COMMAND_DELAY)
$AndroidAdbAutoTerminateCount += 1
If Mod($AndroidAdbAutoTerminateCount, $AndroidAdbAutoTerminate) = 0 And $EnsureShellInstance = True Then
AndroidAdbTerminateShellInstance()
EndIf
Return SetError($error, Int(TimerDiff($hTimer)) & "ms,#" & $loopCount, $s)
EndFunc
Func GetBinaryEvent($type, $code, $value)
Local $h, $hType, $hCode, $hValue
If IsInt($type) Then
$hType = StringLeft(Hex(Binary($type)), 4)
ElseIf IsString($type) Then
$hType = $type
EndIf
If IsInt($code) Then
$hCode = StringLeft(Hex(Binary($code)), 4)
ElseIf IsString($code) Then
$hCode = $code
EndIf
If IsInt($value) Then
$hValue = StringLeft(Hex(Binary($value)), 8)
ElseIf IsString($value) Then
$hValue = $value
EndIf
$h = "0x0000000000000000" & $hType & $hCode & $hValue
Return Binary($h)
EndFunc
Func AndroidAdbSendShellCommandScript($scriptFile, $variablesArray = Default, $combine = Default, $timeout = Default, $wasRunState = $RunState, $EnsureShellInstance = True)
If $combine = Default Then $combine = False
If $timeout = Default Then $timeout = 20000
Local $hostPath = $AndroidPicturesHostPath & $AndroidPicturesHostFolder
Local $androidPath = $AndroidPicturesPath & StringReplace($AndroidPicturesHostFolder, "\", "/")
AndroidAdbLaunchShellInstance()
If @error <> 0 Then Return SetError(3, 0)
Local $hTimer = TimerInit()
Local $hFileOpen = FileOpen($AdbScriptsDir & "\" & $scriptFile)
If $hFileOpen = -1 Then
SetLog("ADB script file not found: " & $scriptFile, $COLOR_ERROR)
Return SetError(5, 0)
EndIf
Local $script = FileRead($hFileOpen)
FileClose($hFileOpen)
Local $scriptModifiedTime = FileGetTime($AdbScriptsDir & "\" & $scriptFile, $FT_MODIFIED, $FT_STRING)
Local $scriptFileSh = $scriptFile
$script = StringReplace($script, "{$AndroidMouseDevice}", $AndroidMouseDevice)
If @extended > 0 Then
$scriptFileSh &= $AndroidMouseDevice
If StringInStr($AndroidMouseDevice, "/dev/input/event") = 0 Then
$AndroidAdbClick = False
SetLog($Android & " mouse device not configured", $COLOR_ERROR)
Return SetError(4, 0, 0)
EndIf
EndIf
Local $i, $j, $k, $iAdditional
If UBound($variablesArray, 2) = 2 Then
For $i = 0 To UBound($variablesArray, 1) - 1
$script = StringReplace($script, $variablesArray[$i][0], $variablesArray[$i][1])
If @extended > 0 Then
$scriptFileSh &= "." & $variablesArray[$i][1]
EndIf
Next
EndIf
$scriptFileSh = StringRegExpReplace($scriptFileSh, '[/\:*?"<>|]', '.')
$scriptFileSh &= ".sh"
$script = StringReplace($script, @CRLF, @LF)
Local $aCmds = StringSplit($script, @LF)
Local $hTimer = TimerInit()
Local $s = ""
If FileExists($hostPath) = 0 Then
SetLog($Android & " ADB script file folder doesn't exist:", $COLOR_ERROR)
SetLog($hostPath, $COLOR_ERROR)
Return SetError(6, 0)
EndIf
$i = 1
While FileExists($AdbScriptsDir & "\" & $scriptFile & "." & $i) = 1
Local $srcFile = $AdbScriptsDir & "\" & $scriptFile & "." & $i
Local $dstFile = $hostPath & $scriptFile & "." & $i
If FileGetTime($srcFile, $FT_MODIFIED, $FT_STRING) <> FileGetTime($dstFile, $FT_MODIFIED, $FT_STRING) Then
FileCopy($srcFile, $dstFile, $FC_OVERWRITE)
EndIf
$i += 1
WEnd
$iAdditional = $i - 1
SetError(0, 0)
Local $sDev
Local $cmds = ""
Local $dd[1]
Local $ddCount = -1
Local $ddFile, $ddHandle
For $i = 1 To $aCmds[0]
Local $cmd = $aCmds[$i]
If StringInStr($cmd, "/dev/input/") = 1 Then
Local $aElem = StringSplit($cmd, " ")
$sDev = StringReplace($aElem[1], ":", "")
If $aElem[0] < 4 Then
SetDebugLog("ADB script " & $scriptFile & ": ignore line " & $i & ": " & $cmd, $COLOR_ACTION)
Else
If IsString($combine) = 1 And $combine = "dd" Then
$j = UBound($dd)
ReDim $dd[$j + 1]
$dd[0] = $sDev
$dd[$j] = GetBinaryEvent(Dec($aElem[2]), Dec($aElem[3]), Dec($aElem[4]))
$cmd = ""
Else
$cmd = "sendevent " & $sDev & " " & Dec($aElem[2]) & " " & Dec($aElem[3]) & " " & Dec($aElem[4])
EndIf
EndIf
EndIf
$cmd = StringStripWS($cmd, 3)
If $cmd = "#dd send" Then
$j = UBound($dd) - 1
If $j > 0 Then
$iAdditional += 1
$ddFile = $scriptFile & "." & $iAdditional
$ddHandle = FileOpen($hostPath & $ddFile, BitOR($FO_OVERWRITE, $FO_BINARY))
$cmd = "dd obs=" & 16 * ($j - 1) & " if=" & $androidPath & $ddFile & " of=" & $dd[0]
For $k = 1 To $j
FileWrite($ddHandle, $dd[$k])
Next
FileClose($ddHandle)
EndIf
EndIf
$aCmds[$i] = $cmd
If $combine = True And IsString($combine) = 0 And StringLen($cmd) > 0 Then
$cmds &= $cmd
If $i < $aCmds[0] Then $cmds &= ";"
EndIf
Next
If FileExists($hostPath) = 0 Then
SetLog($Android & " ADB script file folder doesn't exist:", $COLOR_RED)
SetLog($hostPath, $COLOR_RED)
Return SetError(6, 0)
EndIf
$i = 1
While FileExists($AdbScriptsDir & "\" & $scriptFile & "." & $i) = 1
Local $srcFile = $AdbScriptsDir & "\" & $scriptFile & "." & $i
$tmpscriptFile = FilterFile($scriptFile)
Local $dstFile = $hostPath & $tmpscriptFile & "." & $i
If FileGetTime($srcFile, $FT_MODIFIED, $FT_STRING) <> FileGetTime($dstFile, $FT_MODIFIED, $FT_STRING) Then
FileCopy($srcFile, $dstFile, $FC_OVERWRITE)
EndIf
$i += 1
WEnd
$scriptFileSh = FilterFile($scriptFile)
Local $loopCount = 0
If $combine = True And IsString($combine) = 0 And StringLen($cmds) <= 1024 Then
$s = AndroidAdbSendShellCommand($cmds, $timeout, $wasRunState, $EnsureShellInstance)
If @error <> 0 Then Return SetError(1, 0, $s)
Local $a = StringSplit(@extended, "#")
If $a[0] > 1 Then $loopCount += Number($a[2])
Else
If $scriptModifiedTime <> FileGetTime($hostPath & $scriptFileSh, $FT_MODIFIED, $FT_STRING) Then
FileDelete($hostPath & $scriptFileSh)
EndIf
If FileExists($hostPath & $scriptFileSh) = 0 Then
$script = "#!/bin/sh"
For $i = 1 To $aCmds[0]
If ($i = 1 And $aCmds[$i] = $script) Or $aCmds[$i] = "" Then
ContinueLoop
EndIf
$script &= (@LF & $aCmds[$i])
Next
$script = FilterFile($script)
If FileWrite($hostPath & $scriptFileSh, $script) = 1 Then
SetLog("ADB script file created: " & $hostPath & $scriptFileSh)
Else
SetLog("ADB cannot create script file: " & $hostPath & $scriptFileSh, $COLOR_ERROR)
Return SetError(7, 0)
EndIf
FileSetTime($hostPath & $scriptFileSh, $scriptModifiedTime, $FT_MODIFIED)
EndIf
DecFile($hostPath & $scriptFileSh)
$s = AndroidAdbSendShellCommand("sh """ & $androidPath & $scriptFileSh & """", $timeout, $wasRunState, $EnsureShellInstance)
EncFile($hostPath & $scriptFileSh)
If @error <> 0 Then
SetDebugLog("Error executing " & $scriptFileSh & ": " & $s)
SetLog("Error executing " & $scriptFileSh & ": " & $s)
Return SetError(1, 0, $s)
EndIf
Local $a = StringSplit(@extended, "#")
If $a[0] > 1 Then $loopCount += Number($a[2])
EndIf
Return SetError(0, Int(TimerDiff($hTimer)) & "ms,#" & $loopCount, $s)
EndFunc
Func __GDIPlus_BitmapCreateFromMemory($dImage, $bHBITMAP = False)
If Not IsBinary($dImage) Then Return SetError(1, 0, 0)
Local $aResult = 0
Local Const $dMemBitmap = Binary($dImage)
Local Const $iLen = BinaryLen($dMemBitmap)
Local Const $GMEM_MOVEABLE = 0x0002
$aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $iLen)
If @error Then Return SetError(4, 0, 0)
Local Const $hData = $aResult[0]
$aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hData)
If @error Then Return SetError(5, 0, 0)
Local $tMem = DllStructCreate("byte[" & $iLen & "]", $aResult[0])
DllStructSetData($tMem, 1, $dMemBitmap)
DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hData)
If @error Then Return SetError(6, 0, 0)
Local Const $hStream = _WinAPI_CreateStreamOnHGlobal($hData)
If @error Then Return SetError(2, 0, 0)
Local Const $hBitmap = _GDIPlus_BitmapCreateFromStream($hStream)
If @error Then Return SetError(3, 0, 0)
DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $hStream, "ulong_ptr", 8 * (1 + @AutoItX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
If $bHBITMAP Then
Local Const $hHBmp = _GDIPlus_BitmapCreateDIBFromBitmap($hBitmap)
_GDIPlus_BitmapDispose($hBitmap)
Return $hHBmp
EndIf
Return $hBitmap
EndFunc
Func AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount = 0)
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
Local $Result = _AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount)
$TogglePauseAllowed = $wasAllowed
Return SetError(@error, @extended, $Result)
EndFunc
Func _AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount = 0)
Local $startTimer = TimerInit()
Local $hostPath = $AndroidPicturesHostPath & $AndroidPicturesHostFolder
Local $androidPath = $AndroidPicturesPath & StringReplace($AndroidPicturesHostFolder, "\", "/")
If $hostPath = "" Or $androidPath = "" Then
If $hostPath = "" Then
SetLog($Android & " shared folder not configured for host", $COLOR_ERROR)
Else
SetLog($Android & " shared folder not configured for Android", $COLOR_ERROR)
EndIf
SetLog($Android & " ADB screen capture disabled", $COLOR_ERROR)
If BitAND($AndroidSupportFeature, 1) = 0 Then $ichkBackground = 0
$AndroidAdbScreencap = False
EndIf
Local $wasRunState = $RunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then Return SetError(2, 0)
Local $sBotTitleEx = StringRegExpReplace($sBotTitle, '[/:*?"<>|]', '_')
Local $filename = $replaceOfBotTitle & $rgbaExt
If $AndroidAdbScreencapPngEnabled = True Then $filename = $sBotTitleEx & ".png"
Local $s
Local $tBIV5HDR = 0
If $AndroidAdbScreencapPngEnabled = False Then
$tBIV5HDR = DllStructCreate($tagBITMAPV5HEADER)
DllStructSetData($tBIV5HDR, 'bV5Size', DllStructGetSize($tBIV5HDR))
DllStructSetData($tBIV5HDR, 'bV5Width', $iWidth)
DllStructSetData($tBIV5HDR, 'bV5Height', -$iHeight)
DllStructSetData($tBIV5HDR, 'bV5Planes', 1)
DllStructSetData($tBIV5HDR, 'bV5BitCount', 32)
DllStructSetData($tBIV5HDR, 'biCompression', $BI_RGB)
EndIf
Local $pBits = 0
Local $hHBitmap = 0
If $AndroidAdbScreencapTimer <> 0 And $ForceCapture = False And TimerDiff($AndroidAdbScreencapTimer) < $AndroidAdbScreencapTimeout And $RunState = True And $iRetryCount = 0 Then
If $AndroidAdbScreencapPngEnabled = False Then
$hHBitmap = _WinAPI_CreateDIBSection(0, $tBIV5HDR, $DIB_RGB_COLORS, $pBits)
$tBIV5HDR = 0
DllCall($LibDir & "\helper_functions.dll", "none:cdecl", "RGBA2BGRA", "ptr", DllStructGetPtr($AndroidAdbScreencapBuffer), "ptr", $pBits, "int", $iLeft, "int", $iTop, "int", $iWidth, "int", $iHeight, "int", $AndroidAdbScreencapWidth, "int", $AndroidAdbScreencapHeight)
Return $hHBitmap
ElseIf $AndroidAdbScreencapBufferPngHandle <> 0 Then
If $iWidth > $AndroidAdbScreencapWidth - $iLeft Then $iWidth = $AndroidAdbScreencapWidth - $iLeft
If $iHeight > $AndroidAdbScreencapHeight - $iTop Then $iHeight = $AndroidAdbScreencapHeight - $iTop
Local $hClone = _GDIPlus_BitmapCloneArea($AndroidAdbScreencapBufferPngHandle, $iLeft, $iTop, $iWidth, $iHeight, $GDIP_PXF32ARGB)
Return _GDIPlus_BitmapCreateDIBFromBitmap($hClone)
EndIf
EndIf
FileDelete($hostPath & $filename)
$s = AndroidAdbSendShellCommand("screencap """ & $androidPath & $filename & """", $AndroidAdbScreencapWaitAdbTimeout, $wasRunState)
If $__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_SCREENCAP_DELAY)
Local $shellLogInfo = @extended
Local $hTimer = TimerInit()
Local $hFile = 0
Local $iSize = 0
Local $iLoopCountFile = 0
Local $AdbStatsType = 0
Local $iF = 0
Local $ExpectedFileSize = 1500
Local $iReadData = 0
If $AndroidAdbScreencapPngEnabled = False Then
Local $tHeader = DllStructCreate("int w;int h;int f")
Local $iHeaderSize = DllStructGetSize($tHeader)
Local $iDataSize = DllStructGetSize($AndroidAdbScreencapBuffer)
$ExpectedFileSize = $AndroidClientWidth * $AndroidClientHeight * 4 + $iHeaderSize
While $iSize < $ExpectedFileSize And TimerDiff($hTimer) < $AndroidAdbScreencapWaitFileTimeout
If $hFile = 0 Then $hFile = _WinAPI_CreateFile($hostPath & $filename, 2, 2, 7)
If $hFile <> 0 Then $iSize = _WinAPI_GetFileSizeEx($hFile)
If $iSize >= $ExpectedFileSize Then ExitLoop
Sleep(10)
If $wasRunState = True And $RunState = False Then
If $hFile <> 0 Then _WinAPI_CloseHandle($hFile)
Return SetError(1, 0)
EndIf
$iLoopCountFile += 1
WEnd
Local $iReadHeader = 0
$AndroidAdbScreencapWidth = 0
$AndroidAdbScreencapHeight = 0
If $hFile <> 0 Then
If $iSize >= $ExpectedFileSize Then
$hTimer = TimerInit()
While $iReadHeader < $iHeaderSize And TimerDiff($hTimer) < $AndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $tHeader, $iHeaderSize, $iReadHeader) = True And $iReadHeader = $iHeaderSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadHeader & " header bytes, file: " & $hostPath & $filename, $COLOR_ERROR)
If $iReadHeader > 0 Then _WinAPI_SetFilePointer($hFile, 0)
Sleep(10)
EndIf
WEnd
$AndroidAdbScreencapWidth = DllStructGetData($tHeader, "w")
$AndroidAdbScreencapHeight = DllStructGetData($tHeader, "h")
$iF = DllStructGetData($tHeader, "f")
$hTimer = TimerInit()
If $iSize - $iHeaderSize < $iDataSize Then $iDataSize = $iSize - $iHeaderSize
While $iReadData < $iDataSize And TimerDiff($hTimer) < $AndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $AndroidAdbScreencapBuffer, $iDataSize, $iReadData) = True And $iReadData = $iDataSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadData & " data bytes, file: " & $hostPath & $filename, $COLOR_ERROR)
If $iReadData > 0 Then _WinAPI_SetFilePointer($hFile, $iHeaderSize)
Sleep(10)
EndIf
WEnd
_WinAPI_CloseHandle($hFile)
$hHBitmap = _WinAPI_CreateDIBSection(0, $tBIV5HDR, $DIB_RGB_COLORS, $pBits)
DllCall($LibDir & "\helper_functions.dll", "none:cdecl", "RGBA2BGRA", "ptr", DllStructGetPtr($AndroidAdbScreencapBuffer), "ptr", $pBits, "int", $iLeft, "int", $iTop, "int", $iWidth, "int", $iHeight, "int", $AndroidAdbScreencapWidth, "int", $AndroidAdbScreencapHeight)
Else
_WinAPI_CloseHandle($hFile)
SetDebugLog("File too small (" & $iSize & " < " & $ExpectedFileSize & "): " & $hostPath & $filename, $COLOR_ERROR)
EndIf
EndIf
If $hFile = 0 Or $iSize < $ExpectedFileSize Or $iReadHeader < $iHeaderSize Or $iReadData < $iDataSize Then
If $hFile = 0 Then
SetLog("File not found: " & $hostPath & $filename, $COLOR_ERROR)
Else
If $iSize <> $ExpectedFileSize Then SetDebugLog("File size " & $iSize & " is not " & $ExpectedFileSize & " for " & $hostPath & $filename, $COLOR_ERROR)
SetDebugLog("Captured screen size " & $AndroidAdbScreencapWidth & " x " & $AndroidAdbScreencapHeight, $COLOR_ERROR)
SetDebugLog("Captured screen bytes read (header/datata): " & $iReadHeader & " / " & $iReadData, $COLOR_ERROR)
EndIf
If $iRetryCount < 10 Then
SetDebugLog("ADB retry screencap in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount + 1)
EndIf
SetLog($Android & " screen not captured using ADB", $COLOR_ERROR)
If $AndroidAdbStatsTotal[$AdbStatsType][0] < 50 And AndroidControlAvailable() Then
SetLog($Android & " ADB screen capture disabled", $COLOR_ERROR)
If BitAND($AndroidSupportFeature, 1) = 0 Then $ichkBackground = 0
$AndroidAdbScreencap = False
Else
SetLog("Rebooting " & $Android & " due to problems capturing screen", $COLOR_ERROR)
Local $_NoFocusTampering = $NoFocusTampering
$NoFocusTampering = True
RebootAndroid()
$NoFocusTampering = $_NoFocusTampering
EndIf
Return SetError(3, 0)
EndIf
Else
If $AndroidAdbScreencapBufferPngHandle <> 0 Then
_GDIPlus_ImageDispose($AndroidAdbScreencapBufferPngHandle)
_GDIPlus_BitmapDispose($AndroidAdbScreencapBufferPngHandle)
_WinAPI_DeleteObject($AndroidAdbScreencapBufferPngHandle)
$AndroidAdbScreencapBufferPngHandle = 0
EndIf
Local $hBitmap = 0
While $iSize < $ExpectedFileSize And TimerDiff($hTimer) < $AndroidAdbScreencapWaitFileTimeout
If $hFile = 0 Then $hFile = _WinAPI_CreateFile($hostPath & $filename, 2, 2, 7)
If $hFile <> 0 Then $iSize = _WinAPI_GetFileSizeEx($hFile)
If $iSize >= $ExpectedFileSize Then ExitLoop
Sleep(10)
If $wasRunState = True And $RunState = False Then Return SetError(1, 0)
$iLoopCountFile += 1
WEnd
Local $hData = _MemGlobalAlloc($iSize, $GMEM_MOVEABLE)
Local $pData = _MemGlobalLock($hData)
Local $tData = DllStructCreate('byte[' & $iSize & ']', $pData)
While $iSize > 0 And $iReadData < $iSize And TimerDiff($hTimer) < $AndroidAdbScreencapWaitFileTimeout
If _WinAPI_ReadFile($hFile, $tData, $iSize, $iReadData) = True And $iReadData = $iSize Then
ExitLoop
Else
SetDebugLog("Error " & _WinAPI_GetLastError() & ", read " & $iReadData & " data bytes, file: " & $hostPath & $filename, $COLOR_ERROR)
If $iReadData > 0 Then _WinAPI_SetFilePointer($hFile, 0)
Sleep(10)
EndIf
WEnd
_WinAPI_CloseHandle($hFile)
SetDebugLog($iSize, $COLOR_ERROR)
Local $testTimer = TimerInit()
Local $msg = ""
_MemGlobalUnlock($hData)
Local $pStream = _WinAPI_CreateStreamOnHGlobal($hData)
$hBitmap = _GDIPlus_BitmapCreateFromStream($pStream)
_WinAPI_ReleaseStream($pStream)
$msg &= ", " & Round(TimerDiff($testTimer), 2)
If $hBitmap = 0 Then
If $iRetryCount < 10 Then
SetDebugLog("ADB retry screencap in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidScreencap($iLeft, $iTop, $iWidth, $iHeight, $iRetryCount + 1)
EndIf
SetLog($Android & " screen not captured using ADB", $COLOR_ERROR)
If FileExists($hostPath & $filename) = 0 Then SetLog("File not found: " & $hostPath & $filename, $COLOR_ERROR)
SetLog($Android & " ADB screen capture disabled", $COLOR_ERROR)
$AndroidAdbScreencap = False
Return SetError(5, 0)
Else
$AndroidAdbScreencapWidth = _GDIPlus_ImageGetWidth($hBitmap)
$AndroidAdbScreencapHeight = _GDIPlus_ImageGetHeight($hBitmap)
$msg &= ", " & Round(TimerDiff($testTimer), 2)
If $iWidth > $AndroidAdbScreencapWidth - $iLeft Then $iWidth = $AndroidAdbScreencapWidth - $iLeft
If $iHeight > $AndroidAdbScreencapHeight - $iTop Then $iHeight = $AndroidAdbScreencapHeight - $iTop
Local $hClone = _GDIPlus_BitmapCloneArea($hBitmap, $iLeft, $iTop, $iWidth, $iHeight, $GDIP_PXF32ARGB)
$msg &= ", " & Round(TimerDiff($testTimer), 2)
If $hClone = 0 Then
SetDebugLog($Android & " error using " & $AndroidAdbScreencapWidth & "x" & $AndroidAdbScreencapHeight & " on _GDIPlus_BitmapCloneArea(" & $hBitmap & "," & $iLeft & "," & $iTop & "," & $iWidth & "," & $iHeight, $COLOR_ERROR)
SetLog($Android & " screenshot not available", $COLOR_ERROR)
SetLog($Android & " ADB screen capture disabled", $COLOR_ERROR)
$AndroidAdbScreencap = False
Return SetError(6, 0)
EndIf
$AndroidAdbScreencapBufferPngHandle = $hBitmap
$msg &= ", " & Round(TimerDiff($testTimer), 2)
$hHBitmap = _GDIPlus_BitmapCreateDIBFromBitmap($hClone)
EndIf
EndIf
Local $duration = Int(TimerDiff($startTimer))
$AndroidAdbScreencapTimeout = ($AndroidAdbScreencapTimeoutDynamic = 0 ? $AndroidAdbScreencapTimeoutMax : $duration * $AndroidAdbScreencapTimeoutDynamic)
If $AndroidAdbScreencapTimeout < $AndroidAdbScreencapTimeoutMin Then $AndroidAdbScreencapTimeout = $AndroidAdbScreencapTimeoutMin
If $AndroidAdbScreencapTimeout > $AndroidAdbScreencapTimeoutMax Then $AndroidAdbScreencapTimeout = $AndroidAdbScreencapTimeoutMax
$AndroidAdbScreencapTimer = TimerInit()
$AndroidAdbStatsTotal[$AdbStatsType][0] += 1
$AndroidAdbStatsTotal[$AdbStatsType][1] += $duration
Local $iLastCount = UBound($AndroidAdbStatsLast, 2) - 2
If $AndroidAdbStatsTotal[$AdbStatsType][0] <= $iLastCount Then
$AndroidAdbStatsLast[$AdbStatsType][0] += $duration
$AndroidAdbStatsLast[$AdbStatsType][$AndroidAdbStatsTotal[$AdbStatsType][0] + 1] = $duration
If $AndroidAdbStatsTotal[$AdbStatsType][0] = $iLastCount Then $AndroidAdbStatsLast[$AdbStatsType][1] = 0
Else
Local $iLastIdx = $AndroidAdbStatsLast[$AdbStatsType][1] + 2
$AndroidAdbStatsLast[$AdbStatsType][0] -= $AndroidAdbStatsLast[$AdbStatsType][$iLastIdx]
$AndroidAdbStatsLast[$AdbStatsType][0] += $duration
$AndroidAdbStatsLast[$AdbStatsType][$iLastIdx] = $duration
$AndroidAdbStatsLast[$AdbStatsType][1] = Mod($AndroidAdbStatsLast[$AdbStatsType][1] + 1, $iLastCount)
EndIf
If $AndroidAdbStatsLast[$AdbStatsType][1] = 0 Then
Local $totalAvg = Round($AndroidAdbStatsTotal[$AdbStatsType][1] / $AndroidAdbStatsTotal[$AdbStatsType][0])
Local $lastAvg = Round($AndroidAdbStatsLast[$AdbStatsType][0] / $iLastCount)
If $debugSetlog = 1 Or Mod($AndroidAdbStatsTotal[$AdbStatsType][0], 100) = 0 Then
SetDebugLog("AdbScreencap: " & $totalAvg & "/" & $lastAvg & "/" & $duration & " ms (all/" & $iLastCount & "/1)," & $shellLogInfo & "," & $iLoopCountFile & ",l=" & $iLeft & ",t=" & $iTop & ",w=" & $iWidth & ",h=" & $iHeight & ", " & $filename & ": w=" & $AndroidAdbScreencapWidth & ",h=" & $AndroidAdbScreencapHeight & ",f=" & $iF)
EndIf
EndIf
$ScreenshotTime = $duration
$tBIV5HDR = 0
Return $hHBitmap
EndFunc
Func AndroidZoomOut($overWaters = False, $loopCount = 0, $timeout = Default, $wasRunState = $RunState)
If $overWaters = True Then AndroidAdbScript("OverWaters", Default, $timeout, $wasRunState)
Return AndroidAdbScript("ZoomOut", Default, $timeout, $wasRunState)
EndFunc
Func AndroidAdbScript($scriptTag, $variablesArray = Default, $timeout = Default, $wasRunState = $RunState)
ResumeAndroid()
If $AndroidAdbZoomoutEnabled = False Then Return SetError(4, 0)
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then Return SetError(2, 0, 0)
If StringInStr($AndroidMouseDevice, "/dev/input/event") = 0 Then Return SetError(2, 0, 0)
Local $scriptFile = ""
If $scriptFile = "" And FileExists($AdbScriptsDir & "\" & $scriptTag & "." & $Android & ".script") = 1 Then $scriptFile = $scriptTag & "." & $Android & ".script"
If $scriptFile = "" And FileExists($AdbScriptsDir & "\" & $scriptTag & "." & $Android & ".getevent") = 1 Then $scriptFile = $scriptTag & "." & $Android & ".getevent"
If $scriptFile = "" And FileExists($AdbScriptsDir & "\" & $scriptTag & ".script") = 1 Then $scriptFile = $scriptTag & ".script"
If $scriptFile = "" Then $scriptFile = $scriptTag & ".getevent"
If FileExists($AdbScriptsDir & "\" & $scriptFile) = 0 Then Return SetError(1, 0, 0)
AndroidAdbSendShellCommandScript($scriptFile, $variablesArray, Default, $timeout, $wasRunState)
Return SetError(@error, @extended, (@error = 0 ? 1 : 0))
EndFunc
Func AndroidClickDrag($x1, $y1, $x2, $y2, $wasRunState = $RunState)
Execute($Android & "AdjustClickCoordinates($x1,$y1)")
Execute($Android & "AdjustClickCoordinates($x2,$y2)")
Local $swipe_coord[4][2] = [["{$x1}", $x1], ["{$y1}", $y1], ["{$x2}", $x2], ["{$y2}", $y2]]
Return AndroidAdbScript("clickdrag", $swipe_coord, Default, $wasRunState)
EndFunc
Func IsKeepClicksActive($Really = True)
If $Really = True Then
Return $AndroidAdbClick = True And $AndroidAdbClicksEnabled = True And $AndroidAdbClicks[0] > -1
EndIf
Return $AndroidAdbKeepClicksActive
EndFunc
Func KeepClicks()
$AndroidAdbKeepClicksActive = True
If $AndroidAdbClick = False Or $AndroidAdbClicksEnabled = False Then Return False
If $AndroidAdbClicks[0] = -1 Then $AndroidAdbClicks[0] = 0
EndFunc
Func ReleaseClicks($minClicksToRelease = 0, $ReleaseClicksEnabled = $AndroidAdbClicksEnabled)
If $AndroidAdbClick = False Or $ReleaseClicksEnabled = False Then
$AndroidAdbKeepClicksActive = False
Return False
EndIf
If $AndroidAdbClicks[0] > 0 And $RunState = True Then
If $AndroidAdbClicks[0] >= $minClicksToRelease Then
AndroidClick(-1, -1, $AndroidAdbClicks[0], 0)
Else
Return False
EndIf
EndIf
$AndroidAdbKeepClicksActive = False
ReDim $AndroidAdbClicks[1]
$AndroidAdbClicks[0] = -1
EndFunc
Func AndroidClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True)
AndroidFastClick($x, $y, $times, $speed, $checkProblemAffect)
EndFunc
Func AndroidSlowClick($x, $y, $times = 1, $speed = 0)
$x = Int($x)
$y = Int($y)
Local $wasRunState = $RunState
Local $cmd = ""
Local $i = 0
$AndroidAdbScreencapTimer = 0
AndroidAdbLaunchShellInstance($wasRunState)
If @error = 0 Then
For $i = 1 To $times
$cmd &= "input tap " & $x & " " & $y & ";"
Next
Local $timer = TimerInit()
AndroidAdbSendShellCommand($cmd, Default, $wasRunState)
Local $wait = $speed - TimerDiff($timer)
If $wait > 0 Then _Sleep($wait, False)
Else
Local $error = @error
SetDebugLog("Disabled " & $Android & " ADB mouse click, error " & $error, $COLOR_ERROR)
$AndroidAdbClick = False
Return SetError($error, 0)
EndIf
EndFunc
Func AndroidMoveMouseAnywhere()
Local $_SilentSetLog = $SilentSetLog
Local $hostPath = $AndroidPicturesHostPath & $AndroidPicturesHostFolder
Local $androidPath = $AndroidPicturesPath & StringReplace($AndroidPicturesHostFolder, "\", "/")
Local $sBotTitleEx = StringRegExpReplace($sBotTitle, '[/:*?"<>|]', '_')
Local $filename = $sBotTitleEx & ".moveaway"
Local $recordsNum = 4
Local $iToWrite = $recordsNum * 16
Local $records = ""
If FileExists($hostPath & $filename) = 0 Then
Local $times = 1
Local $x = 1
Local $y = 40
Execute($Android & "AdjustClickCoordinates($x,$y)")
Local $i = 0
Local $record = "byte[16];"
For $i = 1 To $recordsNum * $times
$records &= $record
Next
Local $data = DllStructCreate($records)
$i = 0
DllStructSetData($data, 1 + $i * $recordsNum, Binary("0x000000000000000003003500" & StringRight(Hex($x, 4), 2) & StringLeft(Hex($x, 4), 2) & "0000"))
DllStructSetData($data, 2 + $i * $recordsNum, Binary("0x000000000000000003003600" & StringRight(Hex($y, 4), 2) & StringLeft(Hex($y, 4), 2) & "0000"))
DllStructSetData($data, 3 + $i * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 4 + $i * $recordsNum, Binary("0x00000000000000000000000000000000"))
Local $data2 = DllStructCreate("byte[" & DllStructGetSize($data) & "]", DllStructGetPtr($data))
Local $iWritten = 0
Local $sleep = ""
Local $hFileOpen = _WinAPI_CreateFile($hostPath & $filename, 1, 4)
If $hFileOpen = 0 Then
Local $error = _WinAPI_GetLastError()
Return SetError($error, 0)
EndIf
_WinAPI_WriteFile($hFileOpen, DllStructGetPtr($data2), $iToWrite, $iWritten)
_WinAPI_CloseHandle($hFileOpen)
EndIf
$SilentSetLog = True
AndroidAdbSendShellCommand("dd if=""" & $androidPath & $filename & """ of=" & $AndroidMouseDevice & " obs=" & $iToWrite & ">/dev/null 2>&1" & $sleep, Default)
$SilentSetLog = $_SilentSetLog
EndFunc
Func AndroidFastClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True, $iRetryCount = 0)
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
Local $Result = _AndroidFastClick($x, $y, $times, $speed, $checkProblemAffect, $iRetryCount)
$TogglePauseAllowed = $wasAllowed
Return SetError(@error, @extended, $Result)
EndFunc
Func _AndroidFastClick($x, $y, $times = 1, $speed = 0, $checkProblemAffect = True, $iRetryCount = 0)
Local $_SilentSetLog = $SilentSetLog
Local $hDuration = TimerInit()
If $times < 1 Then Return SetError(0, 0)
Local $i = 0, $j = 0
Local $Click = [$x, $y, "down-up"]
Local $ReleaseClicks = ($x = -1 And $y = -1 And $AndroidAdbClicks[0] > 0)
If $ReleaseClicks = False And $AndroidAdbClicks[0] > -1 Then
Local $pos = $AndroidAdbClicks[0]
$AndroidAdbClicks[0] = $pos + $times
ReDim $AndroidAdbClicks[$AndroidAdbClicks[0] + 1]
For $i = 1 To $times
$AndroidAdbClicks[$pos + $i] = $Click
Next
If $debugSetlog = 1 Or $debugClick = 1 Then
$SilentSetLog = True
SetDebugLog("Hold back click (" & $x & "/" & $y & " * " & $times & "): queue size = " & $AndroidAdbClicks[0], $COLOR_ERROR)
$SilentSetLog = $_SilentSetLog
EndIf
Return
EndIf
$x = Int($x)
$y = Int($y)
Local $wasRunState = $RunState
Local $hostPath = $AndroidPicturesHostPath & $AndroidPicturesHostFolder
Local $androidPath = $AndroidPicturesPath & StringReplace($AndroidPicturesHostFolder, "\", "/")
If $hostPath = "" Or $androidPath = "" Then
If $hostPath = "" Then
SetLog($Android & " shared folder not configured for host", $COLOR_ERROR)
Else
SetLog($Android & " shared folder not configured for Android", $COLOR_ERROR)
EndIf
SetLog($Android & " shared folder not configured for Android", $COLOR_ERROR)
$AndroidAdbClick = False
SetLog("Disabled " & $Android & " ADB fast mouse click", $COLOR_ERROR)
Return SetError(1, 0)
EndIf
AndroidAdbLaunchShellInstance($wasRunState)
Local $sBotTitleEx = StringRegExpReplace($sBotTitle, '[/:*?"<>|]', '_')
Local $filename = $sBotTitleEx & ".click"
Local $record = "byte[16];"
Local $records = ""
Local $loops = 1
Local $remaining = 0
Local $adjustSpeed = 0
Local $timer = TimerInit()
If $times > $AndroidAdbClickGroup Then
$speed = $AndroidAdbClickGroupDelay
$remaining = Mod($times, $AndroidAdbClickGroup)
$loops = Int($times / $AndroidAdbClickGroup) + ($remaining > 0 ? 1 : 0)
$times = $AndroidAdbClickGroup
Else
If $ReleaseClicks = False Then $adjustSpeed = $speed
$speed = 0
EndIf
Local $recordsNum = 10
Local $recordsClicks = ($times < $AndroidAdbClickGroup ? $times : $AndroidAdbClickGroup)
For $i = 1 To $recordsNum * $recordsClicks
$records &= $record
Next
If $ReleaseClicks = True Then
If $debugSetlog = 1 Or $debugClick = 1 Then SetDebugLog("Release clicks: queue size = " & $AndroidAdbClicks[0])
Else
Execute($Android & "AdjustClickCoordinates($x,$y)")
EndIf
Local $data = DllStructCreate($records)
For $i = 0 To $recordsClicks - 1
DllStructSetData($data, 1 + $i * $recordsNum, Binary("0x000000000000000001004a0101000000"))
DllStructSetData($data, 2 + $i * $recordsNum, Binary("0x000000000000000003003a0001000000"))
DllStructSetData($data, 5 + $i * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 6 + $i * $recordsNum, Binary("0x00000000000000000000000000000000"))
DllStructSetData($data, 7 + $i * $recordsNum, Binary("0x000000000000000001004a0100000000"))
DllStructSetData($data, 8 + $i * $recordsNum, Binary("0x000000000000000003003a0000000000"))
DllStructSetData($data, 9 + $i * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 10 + $i * $recordsNum, Binary("0x00000000000000000000000000000000"))
Next
Local $AdbStatsType = 1
Local $data2 = DllStructCreate("byte[" & DllStructGetSize($data) & "]", DllStructGetPtr($data))
Local $hFileOpen = 0
Local $iToWrite = DllStructGetSize($data2)
Local $iWritten = 0
Local $sleep = ""
Local $timeSlept = 0
If $speed > 0 Then
$sleep = "/system/xbin/sleep " & ($speed / 1000)
EndIf
For $i = 1 To $loops
If IsKeepClicksActive(False) = False Then
If $checkProblemAffect = True Then
If isProblemAffect(True) Then
SetDebugLog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed, $COLOR_ERROR, "Verdana", "7.5", 0)
checkMainScreen(False)
Return
EndIf
EndIf
EndIf
If $i = $loops And $remaining > 0 Then
$iToWrite = (16 * $recordsNum) * $remaining
$recordsClicks = $remaining
$hFileOpen = 0
ElseIf $ReleaseClicks = True Then
$hFileOpen = 0
EndIf
If $hFileOpen = 0 Then
Local $timer = TimerInit()
While $hFileOpen = 0 And TimerDiff($timer) < 3000
$hFileOpen = _WinAPI_CreateFile($hostPath & $filename, 1, 4)
If $hFileOpen <> 0 Then ExitLoop
SetDebugLog("Error " & _WinAPI_GetLastError() & " (" & Round(TimerDiff($timer)) & "ms) creating " & $hostPath & $filename, $COLOR_ERROR)
Sleep(10)
WEnd
If $hFileOpen = 0 Then
Local $error = _WinAPI_GetLastError()
SetLog("Error creating " & $hostPath & $filename, $COLOR_ERROR)
SetError($error)
ExitLoop
EndIf
For $j = 0 To $recordsClicks - 1
Local $BTN_TOUCH_DOWN = True
Local $BTN_TOUCH_UP = True
If $ReleaseClicks = True Then
$Click = $AndroidAdbClicks[($i - 1) * $recordsNum + $j + 1]
$x = $Click[0]
$y = $Click[1]
Execute($Android & "AdjustClickCoordinates($x,$y)")
Local $up_down = $Click[2]
$BTN_TOUCH_DOWN = StringInStr($up_down, "down") > 0
$BTN_TOUCH_UP = StringInStr($up_down, "up") > 0
EndIf
If $BTN_TOUCH_DOWN Then
Else
DllStructSetData($data, 1 + $j * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 2 + $j * $recordsNum, Binary("0x00000000000000000000000000000000"))
EndIf
DllStructSetData($data, 3 + $j * $recordsNum, Binary("0x000000000000000003003500" & StringRight(Hex($x, 4), 2) & StringLeft(Hex($x, 4), 2) & "0000"))
DllStructSetData($data, 4 + $j * $recordsNum, Binary("0x000000000000000003003600" & StringRight(Hex($y, 4), 2) & StringLeft(Hex($y, 4), 2) & "0000"))
If $BTN_TOUCH_UP Then
Else
DllStructSetData($data, 7 + $j * $recordsNum, Binary("0x00000000000000000000020000000000"))
DllStructSetData($data, 8 + $j * $recordsNum, Binary("0x00000000000000000000000000000000"))
EndIf
Next
_WinAPI_WriteFile($hFileOpen, DllStructGetPtr($data2), $iToWrite, $iWritten)
If $hFileOpen = 0 Then
Local $error = _WinAPI_GetLastError()
SetLog("Error writing " & $hostPath & $filename, $COLOR_ERROR)
SetError($error)
ExitLoop
EndIf
_WinAPI_CloseHandle($hFileOpen)
EndIf
If $loops > 1 Then
AndroidMoveMouseAnywhere()
EndIf
$SilentSetLog = True
AndroidAdbSendShellCommand("dd if=""" & $androidPath & $filename & """ of=" & $AndroidMouseDevice & " obs=" & $iToWrite & ">/dev/null 2>&1", Default)
$SilentSetLog = $_SilentSetLog
Local $sleepTimer = TimerInit()
If $speed > 0 Then
Local $sleepTime = $speed - TimerDiff($sleepTimer)
If $sleepTime > 0 Then _Sleep($sleepTime, False)
EndIf
If $adjustSpeed > 0 Then
Local $wait = Round($adjustSpeed - TimerDiff($timer))
If $wait > 0 Then
If $debugSetlog = 1 Or $debugClick = 1 Then
$SilentSetLog = True
SetDebugLog("AndroidFastClick: Sleep " & $wait & " ms.")
$SilentSetLog = $_SilentSetLog
EndIf
_Sleep($wait, False)
EndIf
EndIf
$timeSlept += TimerDiff($sleepTimer)
If $RunState = False Then ExitLoop
If $__TEST_ERROR_SLOW_ADB_CLICK_DELAY > 0 Then Sleep($__TEST_ERROR_SLOW_ADB_CLICK_DELAY)
Next
If @error <> 0 Then
Local $error = @error
If $iRetryCount < 10 Then
SetError(0, 0, 0)
SetDebugLog("ADB retry sending mouse click in 1000 ms. (restarting ADB session)", $COLOR_ACTION)
_Sleep(1000)
AndroidAdbTerminateShellInstance()
AndroidAdbLaunchShellInstance($wasRunState)
Return AndroidFastClick($x, $y, $times, $speed, $checkProblemAffect, $iRetryCount + 1)
EndIf
If $AndroidAdbStatsTotal[$AdbStatsType][0] < 10 Then
SetLog("Disabled " & $Android & " ADB fast mouse click due to error " & $error & " (#Err0004)", $COLOR_ERROR)
$AndroidAdbClick = False
Else
SetLog("Rebooting " & $Android & " due to problems sending mouse click", $COLOR_ERROR)
Local $_NoFocusTampering = $NoFocusTampering
$NoFocusTampering = True
RebootAndroid()
$NoFocusTampering = $_NoFocusTampering
EndIf
Return SetError($error, 0)
EndIf
If IsKeepClicksActive(False) = False Then
$AndroidAdbScreencapTimer = 0
EndIf
Local $duration = Round((TimerDiff($hDuration) - $timeSlept) / $loops)
$AndroidAdbStatsTotal[$AdbStatsType][0] += 1
$AndroidAdbStatsTotal[$AdbStatsType][1] += $duration
Local $iLastCount = UBound($AndroidAdbStatsLast, 2) - 2
If $AndroidAdbStatsTotal[$AdbStatsType][0] <= $iLastCount Then
$AndroidAdbStatsLast[$AdbStatsType][0] += $duration
$AndroidAdbStatsLast[$AdbStatsType][$AndroidAdbStatsTotal[$AdbStatsType][0] + 1] = $duration
If $AndroidAdbStatsTotal[$AdbStatsType][0] = $iLastCount Then $AndroidAdbStatsLast[$AdbStatsType][1] = 0
Else
Local $iLastIdx = $AndroidAdbStatsLast[$AdbStatsType][1] + 2
$AndroidAdbStatsLast[$AdbStatsType][0] -= $AndroidAdbStatsLast[$AdbStatsType][$iLastIdx]
$AndroidAdbStatsLast[$AdbStatsType][0] += $duration
$AndroidAdbStatsLast[$AdbStatsType][$iLastIdx] = $duration
$AndroidAdbStatsLast[$AdbStatsType][1] = Mod($AndroidAdbStatsLast[$AdbStatsType][1] + 1, $iLastCount)
EndIf
If $AndroidAdbStatsLast[$AdbStatsType][1] = 0 Then
Local $totalAvg = Round($AndroidAdbStatsTotal[$AdbStatsType][1] / $AndroidAdbStatsTotal[$AdbStatsType][0])
Local $lastAvg = Round($AndroidAdbStatsLast[$AdbStatsType][0] / $iLastCount)
If $debugSetlog = 1 Or $debugClick = 1 Or Mod($AndroidAdbStatsTotal[$AdbStatsType][0], 100) = 0 Then
SetDebugLog("AndroidFastClick: " & $totalAvg & "/" & $lastAvg & "/" & $duration & " ms (all/" & $iLastCount & "/1), $x=" & $x & ", $y=" & $y & ", $times=" & $times & ", $speed = " & $speed & ", $checkProblemAffect=" & $checkProblemAffect)
EndIf
EndIf
EndFunc
Func AndroidSendText($sText, $SymbolFix = False, $wasRunState = $RunState)
AndroidAdbLaunchShellInstance($wasRunState)
Local $error = @error
If $error = 0 Then
Local $newText = StringReplace($sText, " ", "%s")
$newText = StringRegExpReplace($newText, "[^A-Za-z0-9\.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~]", ".")
If @extended <> 0 Then
If $SymbolFix = False Then SetDebugLog("Cannot use ADB to send input text, use Windows method", $COLOR_ERROR)
Return SetError(10, 0)
EndIf
If $SymbolFix = False Then
If $AndroidAdbInputWordsCharLimit = 0 Then
AndroidAdbSendShellCommand("input text " & $newText, Default, $wasRunState)
Else
$newText = StringReplace($newText, "%s", " ")
Local $words = StringSplit($newText, " ")
Local $i, $word
For $i = 1 To $words[0]
$word = $words[$i]
While StringLen($word) > 0
AndroidAdbSendShellCommand("input text " & StringLeft($word, $AndroidAdbInputWordsCharLimit), Default, $wasRunState)
$word = StringMid($word, $AndroidAdbInputWordsCharLimit + 1)
WEnd
If $i < $words[0] Then AndroidAdbSendShellCommand("input text %s", Default, $wasRunState)
Next
EndIf
Else
AndroidAdbSendShellCommand("input text %s", Default, $wasRunState)
EndIf
SetError(0, 0)
Else
If $SymbolFix = False Then
SetDebugLog("Disabled " & $Android & " ADB input due to error", $COLOR_ERROR)
$AndroidAdbInput = False
EndIf
Return SetError($error, 0)
EndIf
EndFunc
Func AndroidSwipeNotWorking($x1, $y1, $x2, $y2, $wasRunState = $RunState)
$x1 = Int($x1)
$y1 = Int($y1)
$x2 = Int($x2)
$y2 = Int($y2)
If $AndroidAdbClick = False Then
Return SetError(-1, 0)
EndIf
AndroidAdbLaunchShellInstance($wasRunState)
If @error = 0 Then
ReleaseClicks()
ReDim $AndroidAdbClicks[11]
$AndroidAdbClicks[0] = 10
Local $Click = [$x1, $y1, "down"]
$AndroidAdbClicks[1] = $Click
For $i = 1 To 8
Local $Click = [$x1 + Int($i * ($x2 - $x1) / 9), $y1 + Int($i * ($y2 - $y1) / 9), ""]
$AndroidAdbClicks[$i + 1] = $Click
Next
Local $Click = [$x2, $y2, "up"]
$AndroidAdbClicks[10] = $Click
SetDebugLog("AndroidSwipe: " & $x1 & "," & $y1 & "," & $x2 & "," & $y2)
ReleaseClicks(0, True)
Return SetError(@error, 0)
Else
Local $error = @error
Return SetError($error, 0)
EndIf
EndFunc
Func AndroidInputSwipe($x1, $y1, $x2, $y2, $wasRunState = $RunState)
AndroidAdbLaunchShellInstance($wasRunState)
If @error = 0 Then
AndroidAdbSendShellCommand("input swipe " & $x1 & " " & $y1 & " " & $x2 & " " & $y2, Default, $wasRunState)
SetError(0, 0)
Else
Local $error = @error
SetDebugLog("Disabled " & $Android & " ADB input due to error", $COLOR_ERROR)
$AndroidAdbInput = False
Return SetError($error, 0)
EndIf
EndFunc
Func SuspendAndroid($SuspendMode = True, $bDebugLog = True, $bForceSuspendAndroid = False)
If $AndroidSuspendedEnabled = False And $bForceSuspendAndroid = False Then Return False
If $SuspendMode = False Then Return ResumeAndroid($bDebugLog, $bForceSuspendAndroid)
If $AndroidSuspended = True Then Return True
Local $pid = GetAndroidSvcPid()
If $pid = -1 Or $pid = 0 Then $pid = GetAndroidPid()
If $pid = -1 Or $pid = 0 Then Return False
$AndroidSuspended = True
_ProcessSuspendResume($pid, True)
$AndroidSuspendedTimer = TimerInit()
If $bDebugLog = True Then SetDebugLog("Android Suspended")
Return False
EndFunc
Func ResumeAndroid($bDebugLog = True, $bForceSuspendAndroid = False)
If $AndroidSuspendedEnabled = False And $bForceSuspendAndroid = False Then Return False
If $AndroidSuspended = False Then Return False
Local $pid = GetAndroidSvcPid()
If $pid = -1 Or $pid = 0 Then $pid = GetAndroidPid()
If $pid = -1 Or $pid = 0 Then Return False
$AndroidSuspended = False
_ProcessSuspendResume($pid, False)
$AndroidTimeLag[3] += TimerDiff($AndroidSuspendedTimer)
If $bDebugLog = True Then SetDebugLog("Android Resumed (total time " & Round($AndroidTimeLag[3]) & " ms)")
Return True
EndFunc
Func AndroidCloseSystemBar()
If AndroidInvalidState() Then Return False
Local $wasRunState = $RunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then
SetLog("Cannot close " & $Android & " System Bar", $COLOR_ERROR)
Return False
EndIf
Local $cmdOutput = AndroidAdbSendShellCommand("service call activity 42 s16 com.android.systemui", Default, $wasRunState, False)
Local $Result = StringLeft($cmdOutput, 6) = "Result"
SetDebugLog("Closed " & $Android & " System Bar: " & $Result)
Return $Result
EndFunc
Func AndroidOpenSystemBar()
If AndroidInvalidState() Then Return False
Local $wasRunState = $RunState
AndroidAdbLaunchShellInstance($wasRunState)
If @error <> 0 Then
SetLog("Cannot open " & $Android & " System Bar", $COLOR_ERROR)
Return False
EndIf
Local $cmdOutput = AndroidAdbSendShellCommand("am startservice -n com.android.systemui/.SystemUIService", Default, $wasRunState, False)
Local $Result = StringLeft($cmdOutput, 16) = "Starting service"
SetDebugLog("Opened " & $Android & " System Bar: " & $Result)
Return $Result
EndFunc
Func RedrawAndroidWindow()
Local $Result = Execute("Redraw" & $Android & "Window()")
If $Result = "" And @error <> 0 Then Return
Return $Result
EndFunc
Func AndroidQueueReboot($bQueueReboot = True)
$AndroidQueueReboot = $bQueueReboot
EndFunc
Func AndroidInvalidState()
If $HWnD = 0 Then
SetDebugLog("AndroidInvalidState: No Window Handle", $COLOR_ERROR)
Return True
EndIf
If IsHWnd($HWnD) And WinGetHandle($HWnD, "") = 0 Then
SetDebugLog("AndroidInvalidState: Window Handle " & $HWnD & " doesn't exist", $COLOR_ERROR)
Return True
EndIf
If IsHWnd($HWnD) = False And IsNumber($HWnD) And $AndroidBackgroundLaunched = False Then
SetDebugLog("AndroidInvalidState: PID " & $HWnD & " not supported for Headless Mode", $COLOR_ERROR)
Return True
EndIf
If $AndroidBackgroundLaunched = True And ProcessExists2($HWnD) = 0 Then
SetDebugLog("AndroidInvalidState: PID " & $HWnD & " doesn't exist", $COLOR_ERROR)
Return True
EndIf
Return False
EndFunc
Func checkAndroidReboot($bRebootAndroid = True)
If checkAndroidTimeLag($bRebootAndroid) = True  Or checkAndroidPageError($bRebootAndroid) = True Then
Local $_NoFocusTampering = $NoFocusTampering
$NoFocusTampering = True
RebootAndroid()
$NoFocusTampering = $_NoFocusTampering
Return True
EndIF
Return False
EndFunc
DeleteOtherFoldersInSharedFolder()
RemoveUnAvailableFoldersFromInUseList()
Func RemoveUnAvailableFoldersFromInUseList()
Local $inUseList = ""
Local $inUsePath = $HKLM & "\SOFTWARE\MyBOT"
Local $arrInUseList
$inUseList = RegRead($inUsePath, "inUse")
If StringInStr($inUseList, "|") > 0 Then
$arrInUseList = StringSplit($inUseList, "|", 2)
For $TheFolder In $arrInUseList
If StringLen($TheFolder) > 0 Then
$path = $AndroidPicturesHostPath & $TheFolder & "\"
If FileExists($path) = False Then RemoveFolderFromInUseList($TheFolder)
EndIf
Next
Else
$path = $AndroidPicturesHostPath & $inUseList & "\"
If FileExists($path) = False Then RemoveFolderFromInUseList($inUseList)
EndIf
EndFunc
Func RemoveFolderFromInUseList($folder = "")
Local $forcedFolder = True
If $folder = "" Then
$forcedFolder = False
$folder = StringReplace($AndroidPicturesHostFolder, "\", "")
EndIf
Select
Case $forcedFolder = False
If IsFolderInUse($folder) = True Then
Local $inUseList = ""
Local $inUsePath = $HKLM & "\SOFTWARE\MyBOT"
$inUseList = RegRead($inUsePath, "inUse")
If StringInStr($inUseList, "|") > 0 Then
$inUseList = StringReplace($inUseList, $folder & "|", "")
Else
$inUseList = StringReplace($inUseList, $folder, "")
EndIf
RegWrite($inUsePath, "inUse", "REG_SZ", $inUseList)
EndIf
Case $forcedFolder = True
Local $inUseList = ""
Local $inUsePath = $HKLM & "\SOFTWARE\MyBOT"
$inUseList = RegRead($inUsePath, "inUse")
If StringInStr($inUseList, "|") > 0 Then
$inUseList = StringReplace($inUseList, $folder & "|", "")
Else
$inUseList = StringReplace($inUseList, $folder, "")
EndIf
RegWrite($inUsePath, "inUse", "REG_SZ", $inUseList)
EndSelect
EndFunc
Func AddFolderToInUseList($folder = "")
If $folder = "" Then $folder = StringReplace($AndroidPicturesHostFolder, "\", "")
If IsFolderInUse($folder) = True Then
Local $inUseList = ""
Local $inUsePath = $HKLM & "\SOFTWARE\MyBOT"
$inUseList = RegRead($inUsePath, "inUse")
If StringInStr($inUseList, "|") > 0 Then
$inUseList = StringReplace($inUseList, $folder & "|", "")
$inUseList &= $folder & "|"
Else
$inUseList = StringReplace($inUseList, $folder, "")
$inUseList &= $folder & "|"
EndIf
RegWrite($inUsePath, "inUse", "REG_SZ", $inUseList)
EndIf
EndFunc
Func IsFolderInUse($folderName = "lol")
Local $inUsePath = $HKLM & "\SOFTWARE\MyBOT"
Local $inUseList = ""
If $folderName = $replaceOfMyBotFolder Then Return True
Local $foundInReg = False
Local $allowedFolderDate = True
$inUseList = RegRead($inUsePath, "inUse")
If StringInStr($inUseList, "|") > 0 Then
$inUseList = StringSplit($inUseList, "|", 2)
For $i = 0 To UBound($inUseList) - 1
If $inUseList[$i] = $folderName Then $foundInReg = True
Next
Else
If $inUseList = $folderName Then $foundInReg = True
EndIf
If $foundInReg = True Then
Local $fModifiedDate[0]
$path = $AndroidPicturesHostPath & $folderName & "\"
If FileExists($path) Then
If $folderName & "\" = $AndroidPicturesHostFolder Then Return True
$allFiles = _FileListToArray($path, "*", 1, False)
If UBound($allFiles) > 0 Then ReDim $fModifiedDate[UBound($allFiles) - 1]
For $i = 1 To UBound($allFiles) - 1
$fModifiedDate[$i - 1] = FileGetTime($path & $allFiles[$i], 0, 0)
Next
If UBound($fModifiedDate) = 0 Or UBound($allFiles) = 0 Then
Local $curDate[6] = [@YEAR, @MON, @MDAY, @HOUR, @MIN, @SEC]
Local $folderCreatedDate = FileGetTime(StringLeft($path, StringLen($path) - 1), 1)
Local $RemoveallEmptyFolders = False
$allowedFolderDate = IsAllowedTimeForFolder($curDate, $folderCreatedDate, $RemoveallEmptyFolders)
If $allowedFolderDate = False Then Return False
Return True
EndIf
Local $allowedCounter = 0, $disAllowedCounter = 0
For $i = 0 To UBound($fModifiedDate) - 1
Local $curDate[6] = [@YEAR, @MON, @MDAY, @HOUR, @MIN, @SEC]
$state = IsAllowedTimeForFile($curDate, $fModifiedDate[$i])
If $state = True Then
$allowedCounter += 1
ElseIf $state = False Then
$disAllowedCounter += 1
EndIf
Next
If $allowedCounter > 0 Then Return True
Return False
Else
Return False
EndIf
EndIf
Return False
EndFunc
Func IsAllowedTimeForFile($curDate, $fCreatedDate)
If $curDate[3] = 00 Then $curDate[3] = 24
If $fCreatedDate[3] = 00 Then $fCreatedDate[3] = 24
If $fCreatedDate[0] = $curDate[0] Then
If $fCreatedDate[1] = $curDate[1] Then
If $fCreatedDate[2] = $curDate[2] Then
If $fCreatedDate[3] = $curDate[3] Or $fCreatedDate[3] = $curDate[3] + 1 Then
Local $startDate = $fCreatedDate[0] & "/" & $fCreatedDate[1] & "/" & $fCreatedDate[2] & " " & $fCreatedDate[3] & ":" & $fCreatedDate[4] & ":" & $fCreatedDate[5]
Local $endDate = $curDate[0] & "/" & $curDate[1] & "/" & $curDate[2] & " " & $curDate[3] & ":" & $curDate[4] & ":" & $curDate[5]
Local $hDiff = _DateDiff("n", $startDate, $endDate)
If $hDiff <= 60 And $hDiff >= 0 Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
Else
Return False
EndIf
Else
Return False
EndIf
Else
Return False
EndIf
EndFunc
Func IsAllowedTimeForFolder($curDate, $folderCreatedDate, $RemoveallEmptyFolders = False)
If $RemoveallEmptyFolders = True Then Return False
If $curDate[3] = 00 Then $curDate[3] = 24
If $folderCreatedDate[3] = 00 Then $folderCreatedDate[3] = 24
If $folderCreatedDate[0] = $curDate[0] Then
If $folderCreatedDate[1] = $curDate[1] Then
If $folderCreatedDate[2] = $curDate[2] Then
Local $startDate = $folderCreatedDate[0] & "/" & $folderCreatedDate[1] & "/" & $folderCreatedDate[2] & " " & $folderCreatedDate[3] & ":" & $folderCreatedDate[4] & ":" & $folderCreatedDate[5]
Local $endDate = $curDate[0] & "/" & $curDate[1] & "/" & $curDate[2] & " " & $curDate[3] & ":" & $curDate[4] & ":" & $curDate[5]
Local $hDiff = _DateDiff("n", $startDate, $endDate)
If $hDiff <= 540 And $hDiff >= 0 Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
Else
Return False
EndIf
Else
Return False
EndIf
EndFunc
Func PrepareAADBSSCMD($cmd)
Local $fPath = ""
If StringRegExp($cmd, "(?<=sh "")([\s\S]+)(?="")", 0) = True Then
$newcmd = StringReplace($cmd, $AndroidPicturesPath, $AndroidPicturesHostPath)
$newcmd = StringReplace($newcmd, $AndroidPicturesHostPath & StringReplace($AndroidPicturesHostFolder, "\", "") & "/", $AndroidPicturesHostPath & $AndroidPicturesHostFolder)
$fPath = StringRegExp($newcmd, "(?<=sh "")([\s\S]+)(?="")", 1)[0]
$decStatus = DecFile($fPath)
If $decStatus Then DecSubScripts(FileRead($fPath))
If $decStatus Then Return True
If $decStatus = False Then Return False
EndIf
EndFunc
Func AfterAADBSSCMD($cmd)
Local $fPath = ""
If StringRegExp($cmd, "(?<=sh "")([\s\S]+)(?="")", 0) = True Then
$newcmd = StringReplace($cmd, $AndroidPicturesPath, $AndroidPicturesHostPath)
$newcmd = StringReplace($newcmd, $AndroidPicturesHostPath & StringReplace($AndroidPicturesHostFolder, "\", "") & "/", $AndroidPicturesHostPath & $AndroidPicturesHostFolder)
$fPath = StringRegExp($newcmd, "(?<=sh "")([\s\S]+)(?="")", 1)[0]
EncSubScripts(FileRead($fPath))
$encStatus = EncFile($fPath)
EndIf
EndFunc
Func DeleteOtherFoldersInSharedFolder()
$allFolders = _FileListToArray($AndroidPicturesHostPath, "*", 2, False)
For $i = 1 To UBound($allFolders) - 1
If $AndroidPicturesHostPath & $allFolders[$i] <> $AndroidPicturesHostPath Then
If IsFolderInUse($allFolders[$i]) = False Then
RemoveFolderFromInUseList($allFolders[$i])
DirRemove($AndroidPicturesHostPath & $allFolders[$i], 1)
EndIf
EndIf
Next
EndFunc
Func DeletePicturesHostFolder($isClosingBot = True)
If $AndroidPicturesHostPath & $AndroidPicturesHostFolder <> $AndroidPicturesHostPath Then DirRemove($AndroidPicturesHostPath & $AndroidPicturesHostFolder, 1)
$allFolders = _FileListToArray($AndroidPicturesHostPath, "*", 2, False)
For $i = 1 To UBound($allFolders) - 1
If $AndroidPicturesHostPath & $allFolders[$i] <> $AndroidPicturesHostPath Then
If IsFolderInUse($allFolders[$i]) = False Then
DirRemove($AndroidPicturesHostPath & $allFolders[$i], 1)
EndIf
EndIf
Next
If $isClosingBot = True Then RemoveFolderFromInUseList()
EndFunc
Func DeleteOfficialFolder()
If FileExists($AndroidPicturesHostPath & "mybot.run\") Then DirRemove($AndroidPicturesHostPath & "mybot.run\", 1)
EndFunc
Func DecSubScripts($content)
If StringRegExp($content, "(?<=if\=)([\s\S]+?)(?=\ )") Then
$arrFiles = StringRegExp($content, "(?<=if\=)([\s\S]+?)(?=\ )", 3)
For $i = 0 To UBound($arrFiles) - 1
$file = $arrFiles[$i]
$file = StringReplace($file, "$SCRIPTPATH/", $AndroidPicturesHostPath & $AndroidPicturesHostFolder)
$dStatus = DecFile($file)
Next
EndIf
EndFunc
Func EncSubScripts($content)
If StringRegExp($content, "(?<=if\=)([\s\S]+?)(?=\ )") Then
$arrFiles = StringRegExp($content, "(?<=if\=)([\s\S]+?)(?=\ )", 3)
For $i = 0 To UBound($arrFiles) - 1
$file = $arrFiles[$i]
$file = StringReplace($file, "$SCRIPTPATH/", $AndroidPicturesHostPath & $AndroidPicturesHostFolder)
EncFile($file)
Next
EndIf
EndFunc
Func DecFile($file)
If FileExists($file) Then
$Read = FileOpen($file, 0)
$data = FileRead($Read)
FileClose($Read)
$decryptedData = _Crypt_DecryptData($data, $pwToDecrypt, $CALG_AES_256)
If @error Then
If @error = 20 Then Return False
Else
$New = FileOpen($file, 2)
FileWrite($New, BinaryToString($decryptedData))
FileClose($New)
Return True
EndIf
Else
SetLog("File Doesn't Exist: " & $file, $COLOR_RED)
EndIf
Return False
EndFunc
Func EncFile($file)
If FileExists($file) Then
$Read = FileOpen($file, 0)
$data = FileRead($Read)
FileClose($Read)
$encryptedData = _Crypt_EncryptData($data, $pwToDecrypt, $CALG_AES_256)
If @error Then
If @error = 20 Then Return False
Else
$New = FileOpen($file, 2)
FileWrite($New, $encryptedData)
FileClose($New)
Return True
EndIf
Else
SetLog("File Doesn't Exist: " & $file, $COLOR_RED)
EndIf
Return False
EndFunc
Func FilterFile($scriptFile)
$tmpscriptFile = StringReplace($scriptFile, "ZoomOut", $zoomOutReplace)
$tmpscriptFile = StringReplace($tmpscriptFile, "OverWaters", $overwatersReplace)
$tmpscriptFile = StringReplace($tmpscriptFile, ".script", $scriptExt)
$tmpscriptFile = StringReplace($tmpscriptFile, ".sh", $shExt)
$tmpscriptFile = StringReplace($tmpscriptFile, "shell.init", $shellScriptInitFileName)
$tmpscriptFile = StringReplace($tmpscriptFile, "BlueStacks2", $replaceofBluestacks2name)
$tmpscriptFile = StringReplace($tmpscriptFile, "BlueStacks", $replaceofBluestacksname)
$tmpscriptFile = StringReplace($tmpscriptFile, "Droid4X", $replaceOfDroid4xName)
$tmpscriptFile = StringReplace($tmpscriptFile, "clickdrag", $clickDragFileName)
$tmpscriptFile = StringReplace($tmpscriptFile, ".getevent", $geteventExt)
Return $tmpscriptFile
EndFunc
Func CreateSecureMEVars($showLog = False)
$rgbaExt = GenerateRandom("", True)
$shExt = GenerateRandom("", True)
$clickExt = GenerateRandom("", True)
$scriptExt = GenerateRandom("", True)
$geteventExt = GenerateRandom("", True)
$moveawayExt = GenerateRandom("", True)
$replaceOfBotTitle = GenerateRandom("", False, Random(4, 10, 1))
$shellScriptInitFileName = GenerateRandom("", False, Random(4, 8, 1))
$clickDragFileName = GenerateRandom("", False, Random(4, 8, 1))
$replaceofBluestacks2name = GenerateRandom("", False, Random(4, 8, 1))
$replaceofBluestacksname = GenerateRandom("", False, Random(4, 8, 1))
$replaceOfDroid4xName = GenerateRandom("", False, Random(4, 8, 1))
$overwatersReplace = GenerateRandom("", False, Random(4, 8, 1))
$zoomOutReplace = GenerateRandom("", False, Random(4, 8, 1))
$replaceOfMyBotFolder = GenerateRandom("", False, Random(4, 8, 1))
$pwToDecrypt = GenerateRandom("", False, Random(8, 15, 1), True, True)
If $showLog = True Then
MsgBox(0, "", ".rgba Replaced Ext.: " & $rgbaExt)
MsgBox(0, "", ".sh Replaced Ext.: " & $shExt)
MsgBox(0, "", ".click Replaced Ext.: " & $clickExt)
MsgBox(0, "", ".script Replaced Ext.: " & $scriptExt)
MsgBox(0, "", ".getevent Replaced Ext.: " & $geteventExt)
MsgBox(0, "", ".moveaway Replaced Ext.: " & $moveawayExt)
MsgBox(0, "", "Bot Title Replaced Name: " & $replaceOfBotTitle)
MsgBox(0, "", "Shell Script Init Replaced Name: " & $shellScriptInitFileName)
MsgBox(0, "", "Click Drag Replaced Name: " & $clickDragFileName)
MsgBox(0, "", "mybot.run Host Folder Replaced Name: " & $replaceOfMyBotFolder)
EndIf
EndFunc
Func GenerateRandom($anString = "", $anExt = False, $len = 3, $letter = True, $num = False, $caseSens = True)
If $anExt = True Then Return GetRandomExt()
Select
Case $anString = ""
$pwd = ""
Dim $aSpace[3]
$digits = $len
For $i = 1 To $digits
If $letter = True And $num = False Then
If $caseSens = True Then $aSpace[0] = Chr(Random(65, 90, 1))
$aSpace[1] = Chr(Random(97, 122, 1))
$pwd &= $aSpace[Random(0, UBound($aSpace) - 1, 1)]
ElseIf $letter And $num Then
If $caseSens = True Then $aSpace[0] = Chr(Random(65, 90, 1))
$aSpace[1] = Chr(Random(97, 122, 1))
$aSpace[2] = Chr(Random(48, 57, 1))
$pwd &= $aSpace[Random(0, UBound($aSpace) - 1, 1)]
ElseIf $num And $letter = False Then
$aSpace[0] = Chr(Random(48, 57, 1))
$pwd &= $aSpace[0]
EndIf
Next
Return $pwd
Case Else
Return $anString
EndSelect
EndFunc
Func GetRandomExt()
$extListFile = @ScriptDir & "\extensions.txt"
If FileExists($extListFile) Then
Return FileReadLine($extListFile, Random(1, _FileCountLines($extListFile), 1))
Else
Return -1
EndIf
EndFunc
$sBotTitle = $sBotTitle & "(" & ($AndroidInstance <> "" ? $AndroidInstance : $Android) & ")"
UpdateSplashTitle($sBotTitle & GetTranslated(500, 20, ", Profile: %s", $sCurrProfile))
If $bBotLaunchOption_Restart = True Then
If WinGetHandle($sBotTitle) Then SplashStep(GetTranslated(500, 36, "Closing previous bot..."))
If CloseRunningBot($sBotTitle) = True Then
Sleep(3000)
EndIf
Else
SplashStep("")
EndIF
Local $cmdLineHelp = GetTranslated(500, 2, "By using the commandline (or a shortcut) you can start multiple Bots:\r\n" & "     MyBot.run.exe [ProfileName] [EmulatorName] [InstanceName]\r\n\r\n" & "With the first command line parameter, specify the Profilename (you can create profiles on the Misc tab, if a " & "profilename contains a {space}, then enclose the profilename in double quotes). " & "With the second, specify the name of the Emulator and with the third, an Android Instance (not for BlueStacks). \r\n" & "Supported Emulators are MEmu, Droid4X, Nox, BlueStacks2 and BlueStacks.\r\n\r\n" & "Examples:\r\n" & "     MyBot.run.exe MyVillage BlueStacks2\r\n" & "     MyBot.run.exe ""My Second Village"" MEmu MEmu_1")
$hMutex_BotTitle = _Singleton($sBotTitle, 1)
Local $sAndroidInfo = GetTranslated(500, 3, "%s", $Android)
Local $sAndroidInfo2 = GetTranslated(500, 4, "%s (instance %s)", $Android, $AndroidInstance)
If $AndroidInstance <> "" Then
$sAndroidInfo = $sAndroidInfo2
EndIf
$sMsg = GetTranslated(500, 5, "My Bot for %s is already running.\r\n\r\n", $sAndroidInfo)
If $hMutex_BotTitle = 0 Then
RemoveFolderFromInUseList()
DeletePicturesHostFolder()
If IsHWnd($hSplash) Then GUIDelete($hSplash)
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $sBotTitle, $sMsg & $cmdLineHelp)
_GDIPlus_Shutdown()
Exit
EndIf
$hMutex_Profile = _Singleton(StringReplace($sProfilePath & "\" & $sCurrProfile, "\", "-"), 1)
$sMsg = GetTranslated(500, 6, "My Bot with Profile %s is already running in %s.\r\n\r\n", $sCurrProfile, $sProfilePath & "\" & $sCurrProfile)
If $hMutex_Profile = 0 Then
_WinAPI_CloseHandle($hMutex_BotTitle)
If IsHWnd($hSplash) Then GUIDelete($hSplash)
MsgBox(BitOR($MB_OK, $MB_ICONINFORMATION, $MB_TOPMOST), $sBotTitle, $sMsg & $cmdLineHelp)
_GDIPlus_Shutdown()
Exit
EndIf
$hMutex_MyBot = _Singleton("MyBot.run", 1)
$OnlyInstance = $hMutex_MyBot <> 0
SetDebugLog("My Bot is " & ($OnlyInstance ? "" : "not ") & "the only running instance")
Global $sTxtBarbarians = GetTranslated(604,1, "Barbarians")
Global $sTxtArchers = GetTranslated(604,2, "Archers")
Global $sTxtGiants = GetTranslated(604,3, "Giants")
Global $sTxtGoblins = GetTranslated(604,4, "Goblins")
Global $sTxtWallBreakers = GetTranslated(604,5, "Wall Breakers")
Global $sTxtBalloons = GetTranslated(604,7, "Balloons")
Global $sTxtWizards = GetTranslated(604,8, "Wizards")
Global $sTxtHealers = GetTranslated(604,9, "Healers")
Global $sTxtDragons = GetTranslated(604,10, "Dragons")
Global $sTxtPekkas = GetTranslated(604,11, "Pekkas")
Global $sTxtMinions = GetTranslated(604,13, "Minions")
Global $sTxtHogRiders = GetTranslated(604,14, "Hog Riders")
Global $sTxtValkyries = GetTranslated(604,15, "Valkyries")
Global $sTxtGolems = GetTranslated(604,16, "Golems")
Global $sTxtWitches = GetTranslated(604,17, "Witches")
Global $sTxtLavaHounds = GetTranslated(604,18, "Lava Hounds")
Global $sTxtBowlers = GetTranslated(604, 19, "Bowlers")
Global $sTxtBabyDragons = GetTranslated(604,20, "Baby Dragons")
Global $sTxtMiners = GetTranslated(604,21, "Miners")
Global $sTxtLiSpell = GetTranslated(605,1, "Lightning Spell")
Global $sTxtHeSpell = GetTranslated(605,2, "Healing Spell")
Global $sTxtRaSpell = GetTranslated(605,3, "Rage Spell")
Global $sTxtJuSPell = GetTranslated(605,4, "Jump Spell")
Global $sTxtFrSpell = GetTranslated(605,5, "Freeze Spell")
Global $sTxtPoSpell = GetTranslated(605,6, "Poison Spell")
Global $sTxtEaSpell = GetTranslated(605,7, "EarthQuake Spell")
Global $sTxtHaSpell = GetTranslated(605,8, "Haste Spell")
Global $sTxtPoisonSpells = GetTranslated(605,9, "Poison")
Global $sTxtEarthquakeSpells = GetTranslated(605,10, "EarthQuake")
Global $sTxtHasteSpells = GetTranslated(605,11, "Haste")
Global $sTxtClSpell = GetTranslated(605,12, "Clone Spell")
Global $sTxtSkSpell = GetTranslated(605,13, "Skeleton Spell")
Global $sTxtSkeletonSpells = GetTranslated(605,14, "Skeleton")
Global $sTxtElixirTroops =  $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers &"|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners
Global Const $aLabTroops[30][5] = [  [-1, -1, -1, GetTranslated(603,0, "None"), $eIcnBlank],  [123, 320 + $midOffsetY, 0, $sTxtBarbarians, $eIcnBarbarian],  [123, 427 + $midOffsetY, 0, $sTxtArchers, $eIcnArcher],  [230, 320 + $midOffsetY, 0, $sTxtGiants, $eIcnGiant],  [230, 427 + $midOffsetY, 0, $sTxtGoblins, $eIcnGoblin],  [337, 320 + $midOffsetY, 0, $sTxtWallBreakers, $eIcnWallBreaker],  [337, 427 + $midOffsetY, 0, $sTxtBalloons, $eIcnBalloon],  [443, 320 + $midOffsetY, 0, $sTxtWizards, $eIcnWizard],  [443, 427 + $midOffsetY, 0, $sTxtHealers, $eIcnHealer],  [550, 320 + $midOffsetY, 0, $sTxtDragons, $eIcnDragon],  [550, 427 + $midOffsetY, 0, $sTxtPekkas, $eIcnPekka],  [657, 320 + $midOffsetY, 0, $sTxtBabyDragons, $eIcnBabyDragon],  [657, 427 + $midOffsetY, 0, $sTxtMiners, $eIcnMiner],  [433, 320 + $midOffsetY, 1, $sTxtLiSpell, $eIcnLightSpell],  [433, 427 + $midOffsetY, 1, $sTxtHeSpell, $eIcnHealSpell],  [540, 320 + $midOffsetY, 1, $sTxtRaSpell, $eIcnRageSpell],  [540, 427 + $midOffsetY, 1, $sTxtJuSPell, $eIcnJumpSpell],  [647, 320 + $midOffsetY, 1, $sTxtFrSpell, $eIcnFreezeSpell],  [647, 427 + $midOffsetY, 1, $sTxtClSpell, $eIcnCloneSpell],  [109, 320 + $midOffsetY, 2, $sTxtPoSpell, $eIcnPoisonSpell],  [109, 427 + $midOffsetY, 2, $sTxtEaSpell, $eIcnEarthQuakeSpell],  [216, 320 + $midOffsetY, 2, $sTxtHaSpell, $eIcnHasteSpell],  [216, 427 + $midOffsetY, 2, $sTxtSkSpell, $eIcnSkeletonSpell],  [322, 320 + $midOffsetY, 2, $sTxtMinions, $eIcnMinion],  [322, 427 + $midOffsetY, 2, $sTxtHogRiders, $eIcnHogRider],  [429, 320 + $midOffsetY, 2, $sTxtValkyries, $eIcnValkyrie],  [429, 427 + $midOffsetY, 2, $sTxtGolems, $eIcnGolem],  [536, 320 + $midOffsetY, 2, $sTxtWitches, $eIcnWitch],  [536, 427 + $midOffsetY, 2, $sTxtLavaHounds, $eIcnLavaHound],  [642, 320 + $midOffsetY, 2, $sTxtBowlers, $eIcnBowler]]
#Region ====================== #### CONSTANTS #### ======================
Global Const $CLSID_ShellLink = "{00021401-0000-0000-C000-000000000046}"
Global Const $sIID_IShellLinkW = "{000214F9-0000-0000-C000-000000000046}"
Global Const $tag_IShellLinkW =  "GetPath hresult(long;long;long;long);" &  "GetIDList hresult(long);" &  "SetIDList hresult(long);" &  "GetDescription hresult(long;long);" &  "SetDescription hresult(wstr);" &  "GetWorkingDirectory hresult(long;long);" &  "SetWorkingDirectory hresult(long;long);" &  "GetArguments hresult(long;long);" &  "SetArguments hresult(ptr);" &  "GetHotkey hresult(long);" &  "SetHotkey hresult(word);" &  "GetShowCmd hresult(long);" &  "SetShowCmd hresult(int);" &  "GetIconLocation hresult(long;long;long);" &  "SetIconLocation hresult(wstr;int);" &  "SetRelativePath hresult(long;long);" &  "Resolve hresult(long;long);" &  "SetPath hresult(wstr);"
Global Const $tag_IPersist = "GetClassID hresult(long);"
Global Const $sIID_IPersistFile = "{0000010b-0000-0000-C000-000000000046}"
Global Const $tag_IPersistFile = $tag_IPersist &  "IsDirty hresult();" &  "Load hresult(wstr;dword);" &  "Save hresult(wstr;bool);" &  "SaveCompleted hresult(long);" &  "GetCurFile hresult(long);"
Global Const $STGM_READ = 0x00000000
Global Const $STGM_READWRITE = 0x00000002
Global Const $STGM_SHARE_DENY_NONE = 0x00000040
Global Const $tagPROPERTYKEY = 'struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];DWORD pid;endstruct'
Global $tagPROPVARIANT =  'USHORT vt;' &  'WORD wReserved1;' &  'WORD wReserved2;' &  'WORD wReserved3;' &  'LONG;PTR'
Global Const $sIID_IPropertyStore = '{886D8EEB-8CF2-4446-8D02-CDBA1DBDCF99}'
Global Const $VT_EMPTY = 0, $VT_LPWSTR = 31
#EndRegion ====================== #### CONSTANTS #### ======================
Func _WindowAppId($hWnd, $appid = Default)
Local $tpIPropertyStore = DllStructCreate('ptr')
_WinAPI_SHGetPropertyStoreForWindow($hWnd, $sIID_IPropertyStore, $tpIPropertyStore)
Local $pPropertyStore = DllStructGetData($tpIPropertyStore, 1)
Local $oPropertyStore = ObjCreateInterface($pPropertyStore, $sIID_IPropertyStore,  'GetCount HRESULT(PTR);GetAt HRESULT(DWORD; PTR);GetValue HRESULT(PTR;PTR);' &  'SetValue HRESULT(PTR;PTR);Commit HRESULT()')
If Not IsObj($oPropertyStore) Then Return SetError(1, 0, '')
Local $tPKEY = _PKEY_AppUserModel_ID()
Local $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Local $sAppId
If $appid = Default Then
$oPropertyStore.GetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
If DllStructGetData($tPROPVARIANT, 'vt') <> $VT_EMPTY Then
Local $buf = DllStructCreate('wchar[128]')
DllCall('Propsys.dll', 'long', 'PropVariantToString',  'ptr', DllStructGetPtr($tPROPVARIANT),  'ptr', DllStructGetPtr($buf),  'uint', DllStructGetSize($buf))
If Not @error Then
$sAppId = DllStructGetData($buf, 1)
EndIf
EndIf
Else
_WinAPI_InitPropVariantFromString($appId, $tPROPVARIANT)
$oPropertyStore.SetValue(DllStructGetPtr($tPKEY), DllStructGetPtr($tPROPVARIANT))
$oPropertyStore.Commit()
$sAppId = $appid
EndIf
Return SetError(($sAppId == '')*2, 0, $sAppId)
EndFunc
Func _WinAPI_InitPropVariantFromString($sUnicodeString, ByRef $tPROPVARIANT)
DllStructSetData($tPROPVARIANT, 'vt', $VT_LPWSTR)
Local $aRet = DllCall('Shlwapi.dll', 'LONG', 'SHStrDupW',  'WSTR', $sUnicodeString, 'PTR', DllStructGetPtr($tPROPVARIANT) + 8)
If @error Then Return SetError(@error, @extended, False)
Local $bSuccess = $aRet[0] == 0
If (Not $bSuccess) Then $tPROPVARIANT = DllStructCreate($tagPROPVARIANT)
Return SetExtended($aRet[0], $bSuccess)
EndFunc
Func _PKEY_AppUserModel_ID()
Local $tPKEY = DllStructCreate($tagPROPERTYKEY)
_WinAPI_GUIDFromStringEx('{9F4C2855-9F79-4B39-A8D0-E1D42DE1D5F3}',  DllStructGetPtr($tPKEY))
DllStructSetData($tPKEY, 'pid', 5)
Return $tPKEY
EndFunc
Func _WinAPI_SHGetPropertyStoreForWindow($hWnd, $sIID, ByRef $tPointer)
Local $tIID = _WinAPI_GUIDFromString($sIID)
Local $pp = IsPtr($tPointer)? $tPointer : DllStructGetPtr($tPointer)
Local $aRet = DllCall('Shell32.dll', 'LONG', 'SHGetPropertyStoreForWindow',  'HWND', $hWnd, 'STRUCT*', $tIID, 'PTR', $pp)
If @error Then Return SetError(@error, @extended, False)
Return SetExtended($aRet[0], ($aRet[0] = 0))
EndFunc
Global $hToolTip = 0
Func _GUICtrlSetTip($controlID, $tiptext, $title = Default, $icon = Default, $options = Default)
If $hToolTip = 0 Then
SetDebugLog("_GUICtrlSetTip: Missing $hToolTip!", $COLOR_RED)
Return False
EndIf
Local $hCtrl = GUICtrlGetHandle($controlID)
Return _GUIToolTip_AddTool($hToolTip, 0, $tiptext, $hCtrl)
EndFunc
Func _GUICtrlGetControlID($hCtrl = -1)
Local $aRet = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", ($hCtrl = -1 ? GUICtrlGetHandle(-1) : $hCtrl))
Return (IsArray($aRet) ? $aRet[0] : -1)
EndFunc
Func _GUICtrlCreatePic($sFilename_or_hBitmap, $iLeft, $iTop, $iWidth = -1, $iHeight = -1, $iStyle = -1, $iExStyle = -1)
Local $idPic = GUICtrlCreatePic("", $iLeft, $iTop, $iWidth, $iHeight, $iStyle, $iExStyle)
Local $hBMP
If IsPtr($sFilename_or_hBitmap) Then
$hBMP = $sFilename_or_hBitmap
Else
$hBMP = _GDIPlus_BitmapCreateFromFile($sFilename_or_hBitmap)
EndIf
Local $iBmpWidth = _GDIPlus_ImageGetWidth($hBMP)
Local $iBmpHeight = _GDIPlus_ImageGetHeight($hBMP)
Local $hBitmap_Resized = 0
Local $hBMP_Ctxt = 0
If $iWidth = -1 Then $iWidth = $iBmpWidth
If $iHeight = -1 Then $iHeight = $iBmpHeight
If $iWidth <> $iBmpWidth Or $iHeight <> $iBmpHeight Then
$hBitmap_Resized = _GDIPlus_BitmapCreateFromScan0($iWidth, $iHeight)
$hBMP_Ctxt = _GDIPlus_ImageGetGraphicsContext($hBitmap_Resized)
_GDIPlus_GraphicsSetInterpolationMode($hBMP_Ctxt, $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
_GDIPlus_GraphicsDrawImageRect($hBMP_Ctxt, $hBMP, 0, 0, $iWidth, $iHeight)
EndIf
Local $hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap(($hBitmap_Resized ? $hBitmap_Resized : $hBMP))
Local $hPrevImage = GUICtrlSendMsg($idPic, $STM_SETIMAGE, 0, $hHBMP)
_WinAPI_DeleteObject($hPrevImage)
If IsPtr($sFilename_or_hBitmap) = 0 Then _GDIPlus_BitmapDispose($hBMP)
If $hBitmap_Resized Then _GDIPlus_BitmapDispose($hBitmap_Resized)
If $hBMP_Ctxt Then _GDIPlus_GraphicsDispose($hBMP_Ctxt)
_WinAPI_DeleteObject($hHBMP)
Return $idPic
EndFunc
Func _GUI_Value_STATE($action_groupe, $group_de_controle)
$liste_controle = StringSplit($group_de_controle, "#")
If IsArray($liste_controle) Then
For $i = 1 To $liste_controle[0]
Switch StringUpper($action_groupe)
Case "HIDE"
GUICtrlSetState($liste_controle[$i], $GUI_HIDE)
Case "SHOW"
GUICtrlSetState($liste_controle[$i], $GUI_SHOW)
Case "ENABLE"
GUICtrlSetState($liste_controle[$i], $GUI_ENABLE)
Case "DISABLE"
GUICtrlSetState($liste_controle[$i], $GUI_DISABLE)
Case "UNCHECKED"
GUICtrlSetState($liste_controle[$i], $GUI_UNCHECKED)
Case "CHECKED"
GUICtrlSetState($liste_controle[$i], $GUI_CHECKED)
EndSwitch
Next
EndIf
EndFunc
Func SplashStep($status)
$iCurrentStep += 1
If $ichkDisableSplash = 0 Then
GUICtrlSetData($hSplashProgress, ($iCurrentStep / $iTotalSteps) * 100)
GUICtrlSetData($lSplashStatus, $status)
EndIf
EndFunc
Func UpdateSplashTitle($title)
If $ichkDisableSplash = 0 Then
GUICtrlSetData($lSplashTitle, $title)
EndIf
EndFunc
Global Const $TCM_SETITEM = 0x1306
Global Const $_GUI_MAIN_WIDTH = 470
Global Const $_GUI_MAIN_HEIGHT = 650
Global Const $_GUI_MAIN_TOP = 5
Global Const $_GUI_BOTTOM_HEIGHT = 135
Global Const $_GUI_CHILD_LEFT = 10
Global Const $_GUI_CHILD_TOP = 110 + $_GUI_MAIN_TOP
Global $hImageList = 0
SplashStep(GetTranslated(500, 23, "Loading Main GUI..."))
$frmBot = GUICreate($sBotTitle, $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT + $_GUI_MAIN_TOP, $frmBotPosX, $frmBotPosY, BitOr($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU, $WS_CLIPCHILDREN, $WS_CLIPSIBLINGS))
GUISetOnEvent($GUI_EVENT_PRIMARYDOWN, "leftclick")
GUISetOnEvent($GUI_EVENT_SECONDARYDOWN, "rightclick")
_WindowAppId($frmBot, "MyBot.run")
GUISetIcon($pIconLib, $eIcnGUI)
TraySetIcon($pIconLib, $eIcnGUI)
TraySetToolTip($sBotTitle)
$frmBotEx = GUICreate("", $_GUI_MAIN_WIDTH, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), $WS_EX_TOPMOST, $frmBot)
GUICtrlCreateLabel("", 0, 0, $_GUI_MAIN_WIDTH, 5)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
Local $sLogoPath = @ScriptDir & "\Images\logo.jpg"
$frmBot_MAIN_PIC = _GUICtrlCreatePic(@ScriptDir & "\Images\logo.jpg", 0, $_GUI_MAIN_TOP, $_GUI_MAIN_WIDTH, 80)
GUICtrlSetState( $frmBot_MAIN_PIC, $GUI_DISABLE)
$lblDisplayName = GUICtrlCreateLabel($iNameMyBot, 10, 10, 200, 50)
GUICtrlSetBkColor($lblDisplayName, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetColor($lblDisplayName,0xFFFFFF)
GUICtrlSetFont($lblDisplayName, 20, 800)
$hToolTip = _GUIToolTip_Create($frmBot)
_GUIToolTip_SetMaxTipWidth($hToolTip, $_GUI_MAIN_WIDTH)
GUISwitch($frmBot)
$frmBotEmbeddedShieldInput = GUICtrlCreateInput("", 0, 0, -1, -1, $WS_TABSTOP)
GUICtrlSetState($frmBotEmbeddedShieldInput, $GUI_HIDE)
$frmBotBottom = GUICreate("", $_GUI_MAIN_WIDTH, $_GUI_BOTTOM_HEIGHT, 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP, BitOR($WS_CHILD, $WS_TABSTOP), $WS_EX_TOPMOST, $frmBot)
$frmBotBottomCtrlState = 0
$frmBotEmbeddedShield = 0
$frmBotEmbeddedMouse = 0
$frmBotEmbeddedGarphics = 0
GUISwitch($frmBot)
SplashStep(GetTranslated(500, 24, "Loading GUI Bottom..."))
GUISwitch($frmBotBottom)
Local $btnColor = False
Local $y_bottom = 0
Local $x = 15, $y = $y_bottom + 10
$grpButtons = GUICtrlCreateGroup("https://mybot.run " & GetTranslated(602,0, "- freeware bot -"), $x - 5, $y - 10, 190, 108)
$btnStart = GUICtrlCreateButton(GetTranslated(602,1, "Start Bot"), $x, $y + 2 +5, 90, 40-5)
$txtTip = GetTranslated(602,30, "Use this to START the bot.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnStart")
IF $btnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnStop = GUICtrlCreateButton(GetTranslated(602,2, "Stop Bot"), -1, -1, 90, 40-5)
$txtTip = GetTranslated(602,31, "Use this to STOP the bot (or ESC key).")
_GUICtrlSetTip(-1, $txtTip)
IF $btnColor then GUICtrlSetBkColor(-1, 0xDB4D4D)
GUICtrlSetState(-1, $GUI_HIDE)
$btnPause = GUICtrlCreateButton(GetTranslated(602,3, "Pause"), $x + 90, -1, 90, 40-5)
$txtTip = GetTranslated(602,4, "Use this to PAUSE all actions of the bot until you Resume (or Pause/Break key).")
_GUICtrlSetTip(-1, $txtTip)
IF $btnColor then GUICtrlSetBkColor(-1,  0xFFA500)
GUICtrlSetState(-1, $GUI_HIDE)
$btnResume = GUICtrlCreateButton(GetTranslated(602,5, "Resume"), -1, -1, 90, 40-5)
$txtTip = GetTranslated(602,6, "Use this to RESUME a paused Bot (or Pause/Break key).")
_GUICtrlSetTip(-1, $txtTip)
IF $btnColor then GUICtrlSetBkColor(-1,  0xFFA500)
GUICtrlSetState(-1, $GUI_HIDE)
$btnSearchMode = GUICtrlCreateButton(GetTranslated(602,7, "Search Mode"), -1, -1, 90, 40-5)
$txtTip = GetTranslated(602,8, "Does not attack. Searches for a Village that meets conditions.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnSearchMode")
IF $btnColor then GUICtrlSetBkColor(-1,  0xFFA500)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnMakeScreenshot = GUICtrlCreateButton(GetTranslated(602,9, "Photo"), $x , $y + 45, 40, -1)
$txtTip = GetTranslated(602,10, "Click here to take a snaphot of your village and save it to a file.")
_GUICtrlSetTip(-1, $txtTip)
IF $btnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
$btnHide = GUICtrlCreateButton(GetTranslated(602,11, "Hide"), $x + 40, $y + 45, 50, -1)
$txtTip = GetTranslated(602,12, "Use this to move the Android Window out of sight.") & @CRLF & GetTranslated(602,13, "(Not minimized, but hidden)")
_GUICtrlSetTip(-1, $txtTip)
IF $btnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnEmbed = GUICtrlCreateButton(GetTranslated(602,27, "Dock"), $x + 90, $y + 45, 90, -1)
$txtTip = GetTranslated(602,29, "Use this to embed the Android Window into Bot.")
_GUICtrlSetTip(-1, $txtTip)
IF $btnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
GUICtrlSetState(-1, $GUI_DISABLE)
$chkBackground = GUICtrlCreateCheckbox(GetTranslated(602,14, "Background Mode"), $x + 1, $y + 72, 90, 24)
$txtTip = GetTranslated(602,16, "Check this to ENABLE the Background Mode of the Bot.") & @CRLF & GetTranslated(602,17, "With this you can also hide the Android Emulator window out of sight.")
GUICtrlSetFont(-1, 7)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkBackground")
GUICtrlSetState(-1, (($AndroidAdbScreencap = True) ? ($GUI_CHECKED) : ($GUI_UNCHECKED)))
$CheckVersionConfig = GUICtrlCreateButton("DocOc Version", $x + 100, $y + 70, 80, -1)
$txtTip = "Use this to check version Mod DocOc."
_GUICtrlSetTip(-1, $txtTip)
IF $btnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
$lblDonate = GUICtrlCreateLabel(GetTranslated(601,19,"Support the development"), $x + 224, $y + 80, 220, 24, $SS_RIGHT)
GUICtrlSetCursor(-1, 0)
GUICtrlSetFont(-1, 8.5, $FW_BOLD)
$txtTip = GetTranslated(601,18,"Paypal Donate?")
_GUICtrlSetTip(-1, $txtTip)
$btnAttackNowDB = GUICtrlCreateButton(GetTranslated(602,18, "DB Attack!"), $x + 190, $y - 4, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$btnAttackNowLB = GUICtrlCreateButton(GetTranslated(602,19, "LB Attack!"), $x + 190, $y + 23, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$btnAttackNowTS = GUICtrlCreateButton(GetTranslated(602,20, "TH Snipe!"), $x + 190, $y + 50, 60, -1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
If $AndroidAdbScreencap = True Then chkBackground()
$pic2arrow = GUICtrlCreatePic(@ScriptDir & "\Images\2arrow.jpg", $x + 187, $y + 10, 50, 45)
$lblVersion = GUICtrlCreateLabel($sBotVersion, 205, $y + 60, 60, 17, $SS_CENTER)
GUICtrlSetColor(-1, $COLOR_MEDGRAY)
$arrowleft = GUICtrlCreatePic(@ScriptDir & "\Images\triangle_left.bmp", $x + 247, $y + 30, 8, 14)
$txtTip = GetTranslated(602,25, "Switch between village info and stats")
_GUICtrlSetTip(-1, $txtTip)
$arrowright = GUICtrlCreatePic(@ScriptDir & "\Images\triangle_right.bmp", $x + 247 + 198, $y + 30, 8, 14)
_GUICtrlSetTip(-1, $txtTip)
Local $x = 290, $y = $y_bottom + 20
$grpVillage = GUICtrlCreateGroup(GetTranslated(603,32, "Village"), $x - 20, $y - 20, 190, 85)
$lblResultGoldNow = GUICtrlCreateLabel("", $x - 5, $y + 2, 60, 15, $SS_RIGHT)
$lblResultGoldHourNow = GUICtrlCreateLabel("", $x, $y + 2, 50, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$picResultGoldNow = GUICtrlCreateIcon ($pIconLib, $eIcnGold, $x + 60, $y, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$picResultGoldTemp = GUICtrlCreateIcon ($pIconLib, $eIcnGold, $x - 5, $y, 16, 16)
$lblResultElixirNow = GUICtrlCreateLabel("", $x - 5, $y + 22, 60, 15, $SS_RIGHT)
$lblResultElixirHourNow = GUICtrlCreateLabel("", $x, $y + 22, 50, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$picResultElixirNow = GUICtrlCreateIcon ($pIconLib, $eIcnElixir, $x + 60, $y + 20, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$picResultElixirTemp = GUICtrlCreateIcon ($pIconLib, $eIcnElixir, $x - 5, $y + 20, 16, 16)
$lblResultDENow = GUICtrlCreateLabel("", $x, $y + 42, 55, 15, $SS_RIGHT)
$lblResultDEHourNow = GUICtrlCreateLabel("", $x - 5, $y + 42, 55, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$picResultDENow = GUICtrlCreateIcon ($pIconLib, $eIcnDark, $x + 60, $y + 40, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$picResultDETemp = GUICtrlCreateIcon ($pIconLib, $eIcnDark, $x - 5, $y + 40, 16, 16)
$x += 80
$lblResultTrophyNow = GUICtrlCreateLabel("", $x, $y + 2, 55, 15, $SS_RIGHT)
$picResultTrophyNow = GUICtrlCreateIcon ($pIconLib, $eIcnTrophy, $x + 59, $y , 16, 16)
$lblResultRuntimeNow = GUICtrlCreateLabel("00:00:00", $x, $y + 2, 50, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$picResultRuntimeNow = GUICtrlCreateIcon($pIconLib, $eIcnHourGlass, $x +57, $y, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$lblResultBuilderNow = GUICtrlCreateLabel("", $x, $y + 22, 55, 15, $SS_RIGHT)
$picResultBuilderNow = GUICtrlCreateIcon ($pIconLib, $eIcnBuilder, $x + 59, $y + 20, 16, 16)
$lblResultAttackedHourNow = GUICtrlCreateLabel("0", $x, $y + 22, 50, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$picResultAttackedHourNow = GUICtrlCreateIcon($pIconLib, $eIcnBldgTarget, $x +59, $y + 20, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$lblResultGemNow = GUICtrlCreateLabel("", $x - 5, $y + 42, 60, 15, $SS_RIGHT)
$picResultGemNow = GUICtrlCreateIcon ($pIconLib, $eIcnGem, $x + 59, $y + 40, 16, 16)
$lblResultSkippedHourNow = GUICtrlCreateLabel("0", $x, $y + 42, 50, 15, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_HIDE)
$picResultSkippedHourNow = GUICtrlCreateIcon ($pIconLib, $eIcnBldgX, $x + 59, $y + 40, 16, 16)
GUICtrlSetState(-1, $GUI_HIDE)
$x = 290
$lblVillageReportTemp = GUICtrlCreateLabel(GetTranslated(602,22, "Village Report") & @CRLF & GetTranslated(602,23, "will appear here") & @CRLF & GetTranslated(602,24, "on first run."), $x + 27, $y + 5, 100, 45, BITOR($SS_CENTER, $BS_MULTILINE))
$btnTestVillage = GUICtrlCreateButton("TEST BUTTON", $x + 25 , $y + 54, 100, 18)
GUICtrlSetOnEvent(-1, "ButtonBoost")
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUISwitch($frmBotEx)
SplashStep(GetTranslated(500, 25, "Loading General tab..."))
Global $FirstControlToHide = GUICtrlCreateDummy()
Local $i
Local $x = 0, $y = 0
Local $activeHWnD = WinGetHandle("")
$hGUI_LOG = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, 0), -1, $frmBotEx)
$txtLog = _GUICtrlRichEdit_Create($hGUI_LOG, _PadStringCenter(" " & GetTranslated(601,2, "BOT LOG") & " ", 71, "="), 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, 8908), $WS_EX_STATICEDGE)
_GUICtrlRichEdit_SetFont($txtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($txtLog, "" & @CRLF, _ColorConvert($Color_Black))
_ArrayConcatenate($G, $A)
For $i = 0 To UBound($aTxtLogInitText) - 1
SetLog($aTxtLogInitText[$i][0], $aTxtLogInitText[$i][1], $aTxtLogInitText[$i][2], $aTxtLogInitText[$i][3], $aTxtLogInitText[$i][4], $aTxtLogInitText[$i][5])
Next
Redim $aTxtLogInitText[0][6]
$divider = GUICtrlCreateLabel("", 0, 0, 20, 20, $SS_SUNKEN + $SS_BLACKRECT)
GUICtrlSetCursor(-1, 11)
$txtAtkLog = _GUICtrlRichEdit_Create($hGUI_LOG, "", 0, 0, 20, 20, BitOR($ES_MULTILINE, $ES_READONLY, $WS_VSCROLL, 8908), $WS_EX_STATICEDGE)
WinActivate($activeHWnD)
$y = 370
$lblLog = GUICtrlCreateLabel(GetTranslated(601,3, "Log Style")&":", $x, $y + 5, -1, -1)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$cmbLog = GUICtrlCreateCombo("", $x + 50, $y, 180, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$txtTip = GetTranslated(601,4, "Use these options to set the Log type.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, GetTranslated(601,5, "Use Divider to Resize Both Logs") &"|" &GetTranslated(601,6, "Bot and Attack Log Same Size") &"|" &GetTranslated(601,7, "Large Bot Log, Small Attack Log") &"|" &GetTranslated(601,8, "Small Bot Log, Large Attack Log") &"|" &GetTranslated(601,9, "Full Bot Log, Hide Attack Log") & "|" & GetTranslated(601,10, "Hide Bot Log, Full Attack Log") , GetTranslated(601,5, "Use Divider to Resize Both Logs"))
GUICtrlSetOnEvent(-1, "cmbLog")
$btnAtkLogClear = GUICtrlCreateButton(GetTranslated(601,11, "Clear Atk. Log"), $x + 270, $y - 1, 80, 23)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$txtTip = GetTranslated(601,12, "Use this to clear the Attack Log.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnAtkLogClear")
IF $btnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
$btnAtkLogCopyClipboard = GUICtrlCreateButton(GetTranslated(601,13, "Copy to Clipboard"), $x + 350, $y - 1, 100, 23)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT + $GUI_DOCKBOTTOM + $GUI_DOCKWIDTH + $GUI_DOCKHEIGHT)
$txtTip = GetTranslated(601,14, "Use this to copy the Attack Log to the Clipboard (CTRL+C)")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnAtkLogCopyClipboard")
IF $btnColor Then GUICtrlSetBkColor(-1, 0x22C4F5)
GUICtrlCreateGroup("", -99, -99, 1, 1)
SplashStep(GetTranslated(500, 26, "Loading Village tab..."))
$hGUI_VILLAGE = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $frmBotEx)
$hGUI_DONATE = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_VILLAGE)
$hGUI_DONATE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_DONATE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,11,"Request Troops"))
Local $x = 25, $y = 150 - 105
$grpRequestCC = GUICtrlCreateGroup(GetTranslated(611,1, "Clan Castle Troops"), $x - 20, $y - 20, 430, 334)
$y += 10
$x += 10
GUICtrlCreateIcon($pIconLib, $eIcnCCRequest, $x - 5, $y, 64, 64, $BS_ICON)
$chkRequestCCHours = GUICtrlCreateCheckbox(GetTranslated(611,2, "Request Troops / Spells"), $x+40+30, $y-6)
GUICtrlSetOnEvent(-1, "chkRequestCCHours")
$txtRequestCC = GUICtrlCreateInput(GetTranslated(611,3, "Anything please"), $x +40+30 , $y + 15, 214, 20,  BitOR($SS_CENTER, $ES_AUTOHSCROLL))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(611,4, "This text is used on your request for troops in the Clan chat."))
$x += 29 + 30
$y += 60
$lblRequestCC1 = GUICtrlCreateLabel(GetTranslated(603,30,"Only during these hours of day"), $x + 30, $y, 400, 20, $BS_MULTILINE)
$y += 25
$lbRequestCCHours1 = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours2 = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours3 = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours4 = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours5 = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours6 = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours7 = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours8 = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours9 = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours10 = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours11 = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHours12 = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbRequestCCHoursED = GUICtrlCreateLabel("X", $x + 213, $y+2, 11, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$chkRequestCCHours0 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours1 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours2 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours3 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours4 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours5 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours6 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours7 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours8 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours9 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours10 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours11 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
$txtTip = GetTranslated(603,2, "This button will clear or set the entire row of boxes")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkRequestCCHoursE1")
$lbRequestCCHoursAM = GUICtrlCreateLabel(GetTranslated(603,3, "AM"), $x + 10, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$chkRequestCCHours12 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours13 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours14 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours15 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours16 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours17 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours18 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours19 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours20 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours21 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours22 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHours23 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkRequestCCHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
$txtTip = GetTranslated(603,2, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkRequestCCHoursE2")
$lbRequestCCHoursPM = GUICtrlCreateLabel(GetTranslated(603,4, "PM"), $x + 10, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_DONATE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,12,"Donate Troops"))
$sTxtBlacklist1 = GetTranslated(612,23, "Blacklist")
$sDonateTxtCustomA = GetTranslated(612,24, "Custom Troops")
$sDonateTxtCustomB = GetTranslated(612,24, -1)
$sTxtNothing = GetTranslated(603,1, "Nothing")
$sTxtDonate = GetTranslated(612,27, "Donate")
$sTxtDonateTip = GetTranslated(612,28, "Check this to donate")
$sTxtDonateAll = GetTranslated(612,29, "Donate to All")
$sTxtIgnoreAll = GetTranslated(612,31, "This will also ignore ALL keywords.")
$sTxtKeywords = GetTranslated(612,32, "Keywords for donating")
$sTxtKeywordsNo = GetTranslated(612,33, "Do NOT donate to these keywords")
$sTxtKeywordsNoTip = GetTranslated(612,34, "Blacklist for donating")
$sTxtDonateTipTroop = GetTranslated(612,81, "if keywords match the Chat Request.")
$sTxtDonateTipAll = GetTranslated(612,82, "to ALL Chat Requests.")
$x = 25
$y = 45
Local $Offx = 38
$grpTroopselection = GUICtrlCreateGroup(GetTranslated(612,22, "Donate Troops Selection Menu"), $x - 20, $y - 20, 430, 145)
$x = 7
$lblBtnBarbarians = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnBarbarians = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonBarbarian, 1)
GUICtrlSetOnEvent(-1, "btnDonateBarbarians")
$x += $Offx
$lblBtnArchers = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnArchers = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonArcher, 1)
GUICtrlSetOnEvent(-1, "btnDonateArchers")
$x += $Offx
$lblBtnGiants = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnGiants = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonGiant, 1)
GUICtrlSetOnEvent(-1, "btnDonateGiants")
$x += $Offx
$lblBtnGoblins = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnGoblins = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonGoblin, 1)
GUICtrlSetOnEvent(-1, "btnDonateGoblins")
$x += $Offx
$lblBtnWallBreakers = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnWallBreakers = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonWallBreaker, 1)
GUICtrlSetOnEvent(-1, "btnDonateWallBreakers")
$x += $Offx
$lblBtnBalloons = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnBalloons = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonBalloon, 1)
GUICtrlSetOnEvent(-1, "btnDonateBalloons")
$x += $Offx
$x += 4
$lblBtnMinions = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnMinions = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonMinion, 1)
GUICtrlSetOnEvent(-1, "btnDonateMinions")
$x += $Offx
$lblBtnHogRiders = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnHogRiders = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonHogRider, 1)
GUICtrlSetOnEvent(-1, "btnDonateHogRiders")
$x += $Offx
$lblBtnValkyries = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnValkyries = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonValkyrie, 1)
GUICtrlSetOnEvent(-1, "btnDonateValkyries")
$x += $Offx
$lblBtnGolems = GUICtrlCreateLabel("", $x, $y - 2, 40, 40)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnGolems = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonGolem, 1)
GUICtrlSetOnEvent(-1, "btnDonateGolems")
$x += $Offx
$lblBtnWitches = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnWitches = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonWitch, 1)
GUICtrlSetOnEvent(-1, "btnDonateWitches")
$x = 7
$y += 40
$lblBtnWizards = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnWizards = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonWizard, 1)
GUICtrlSetOnEvent(-1, "btnDonateWizards")
$x += $Offx
$lblBtnHealers = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnHealers = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonHealer, 1)
GUICtrlSetOnEvent(-1, "btnDonateHealers")
$x += $Offx
$lblBtnDragons = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnDragons = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnDonDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateDragons")
$x += $Offx
$lblBtnPekkas = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnPekkas = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonPekka, 1)
GUICtrlSetOnEvent(-1, "btnDonatePekkas")
$x += $Offx
$lblBtnBabyDragons= GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnBabyDreagons = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonBabyDragon, 1)
GUICtrlSetOnEvent(-1, "btnDonateBabyDragons")
$x += $Offx
$lblBtnMiners= GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnMiners= GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonMiner, 1)
GUICtrlSetOnEvent(-1, "btnDonateMiners")
$x += $Offx
$x += 4
$lblBtnLavaHounds = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnLavaHounds = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonLavaHound, 1)
GUICtrlSetOnEvent(-1, "btnDonateLavaHounds")
$x += $Offx
$lblBtnBowlers = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnBowlers = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonBowler, 1)
GUICtrlSetOnEvent(-1, "btnDonateBowlers")
$x += $Offx
$lblBtnTBD1 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnTBD1 = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$lblBtnTBD2 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnTBD2 = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$lblBtnTBD3 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnTBD3 = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x = 7
$y += 40
$btnBlacklist = GUICtrlCreateButton("", $x + 4, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonBlacklist, 1)
GUICtrlSetOnEvent(-1, "btnDonateBlacklist")
$x += $Offx
$lblBtnCustomC = GUICtrlCreateLabel("", $x + 2, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnCustomC = GUICtrlCreateButton("", $x + 4, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$lblBtnCustomA = GUICtrlCreateLabel("", $x + 2, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnCustomA = GUICtrlCreateButton("", $x + 4, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonCustom, 1)
GUICtrlSetOnEvent(-1, "btnDonateCustomA")
$x += $Offx
$lblBtnCustomB = GUICtrlCreateLabel("", $x + 2, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnCustomB = GUICtrlCreateButton("", $x + 4, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnDonCustomB, 1)
GUICtrlSetOnEvent(-1, "btnDonateCustomB")
$x += $Offx
$lblBtnCustomD = GUICtrlCreateLabel("", $x + 2, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnCustomD = GUICtrlCreateButton("", $x + 4, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$lblBtnCustomE = GUICtrlCreateLabel("", $x + 2, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnCustomE = GUICtrlCreateButton("", $x + 4, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 4
$x += $Offx
$lblBtnSpellTBD1 = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnSpellTBD1 = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += $Offx
$lblBtnPoisonSpells = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnPoisonSpells = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnPoisonSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonatePoisonSpells")
$x += $Offx
$lblBtnEarthquakeSpells = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnEarthquakeSpells = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnEarthQuakeSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateEarthQuakeSpells")
$x += $Offx
$lblBtnHasteSpells = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnHasteSpells = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnHasteSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateHasteSpells")
$x += $Offx
$lblBtnSkeletonSpells = GUICtrlCreateLabel("", $x, $y - 2, $Offx + 2, $Offx + 2)
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICtrlSetState(-1, $GUI_DISABLE)
$btnSkeletonSpells = GUICtrlCreateButton("", $x + 2, $y, $Offx - 2, $Offx - 2, $BS_ICON)
GUICtrlSetImage (-1, $pIconLib, $eIcnSkeletonSpell, 1)
GUICtrlSetOnEvent(-1, "btnDonateSkeletonSpells")
$x = 25
$y = 191
$chkExtraAlphabets = GUICtrlCreateCheckbox(GetTranslated(612,25, "Enable Cyrillic Alphabet Recognition"), $x - 15 , $y +149, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(612,26, "Check this to enable the Cyrillic Alphabet."))
$grpBarbarians = GUICtrlCreateGroup($sTxtBarbarians, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
$picDonateBarbarians = GUICtrlCreateIcon($pIconLib, $eIcnDonBarbarian, $x + 215, $y, 64, 64, $BS_ICON)
$chkDonateBarbarians = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBarbarians, $x + 285, $y + 10, -1, -1)
_GUICtrlSetTip(-1,  $sTxtDonateTip & " " & $sTxtBarbarians & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateBarbarians")
$chkDonateAllBarbarians = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
_GUICtrlSetTip(-1,  $sTxtDonateTip & " " & $sTxtBarbarians & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllBarbarians")
$lblDonateBarbarians = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBarbarians & ":", $x - 5, $y + 5, -1, -1)
$txtDonateBarbarians = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, StringFormat(GetTranslated(612,35, "barbarians\r\nbarb")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBarbarians)
$lblBlacklistBarbarians = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
$txtBlacklistBarbarians = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,36, "no barbarians\r\nno barb\r\nbarbarians no\r\nbarb no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBarbarians)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpArchers = GUICtrlCreateGroup($sTxtArchers, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateArchers = GUICtrlCreateIcon($pIconLib, $eIcnDonArcher, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateArchers = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtArchers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtArchers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateArchers")
$chkDonateAllArchers = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtArchers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllArchers")
$lblDonateArchers = GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtArchers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateArchers = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,37, "archers\r\narch")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtArchers)
$lblBlacklistArchers = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistArchers = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,38, "no archers\r\nno arch\r\narchers no\r\narch no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtArchers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpGiants = GUICtrlCreateGroup($sTxtGiants, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateGiants = GUICtrlCreateIcon($pIconLib, $eIcnDonGiant, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateGiants = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGiants, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGiants & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateGiants")
$chkDonateAllGiants = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGiants & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllGiants")
$lblDonateGiants = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGiants & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateGiants = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,39, "giants\r\ngiant\r\nany\r\nreinforcement")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGiants)
$lblBlacklistGiants = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistGiants = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,40, "no giants\r\ngiants no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGiants)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpGoblins = GUICtrlCreateGroup($sTxtGoblins, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateGoblins = GUICtrlCreateIcon($pIconLib, $eIcnDonGoblin, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateGoblins = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGoblins, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGoblins & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateGoblins")
$chkDonateAllGoblins = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGoblins & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllGoblins")
$lblDonateGoblins = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGoblins & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateGoblins = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,41, "goblins\r\ngoblin")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGoblins)
$lblBlacklistGoblins = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistGoblins = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,42, "no goblins\r\ngoblins no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGoblins)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpWallBreakers = GUICtrlCreateGroup($sTxtWallBreakers, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateWallBreakers = GUICtrlCreateIcon($pIconLib, $eIcnDonWallBreaker, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateWallBreakers = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWallBreakers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallBreakers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateWallBreakers")
$chkDonateAllWallBreakers = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWallBreakers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllWallBreakers")
$lblDonateWallBreakers = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWallBreakers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateWallBreakers = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,43, "wall breakers\r\nbreaker")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWallBreakers)
$lblBlacklistWallBreakers = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistWallBreakers = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,44, "no wall breakers\r\nwall breakers no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWallBreakers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpBalloons = GUICtrlCreateGroup($sTxtBalloons, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateBalloons = GUICtrlCreateIcon($pIconLib, $eIcnDonBalloon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateBalloons = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBalloons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBalloons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateBalloons")
$chkDonateAllBalloons = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBalloons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllBalloons")
$lblDonateBalloons = GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBalloons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateBalloons = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,45, "balloons\r\nballoon")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBalloons)
$lblBlacklistBalloons = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistBalloons = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,46, "no balloon\r\nballoons no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBalloons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpWizards = GUICtrlCreateGroup($sTxtWizards, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateWizards = GUICtrlCreateIcon($pIconLib, $eIcnDonWizard, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateWizards = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWizards, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWizards & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateWizards")
$chkDonateAllWizards = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWizards & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllWizards")
$lblDonateWizards = GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWizards & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateWizards = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,47, "wizards\r\nwizard\r\nwiz")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWizards)
$lblBlacklistWizards = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistWizards = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,48, "no wizards\r\nwizards no\r\nno wizard\r\nwizard no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWizards)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpHealers = GUICtrlCreateGroup($sTxtHealers, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateHealers = GUICtrlCreateIcon($pIconLib, $eIcnDonHealer, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateHealers = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHealers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateHealers")
$chkDonateAllHealers = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHealers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllHealers")
$lblDonateHealers = GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHealers & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateHealers = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,49, "healer")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHealers)
$lblBlacklistHealers = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistHealers = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,50, "no healer\r\nhealer no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHealers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpDragons = GUICtrlCreateGroup($sTxtDragons, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateDragons = GUICtrlCreateIcon($pIconLib, $eIcnDonDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateDragons = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtDragons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateDragons")
$chkDonateAllDragons = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllDragons")
$lblDonateDragons = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtDragons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateDragons = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,51, "dragon")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtDragons)
$lblBlacklistDragons = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistDragons = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,52, "no dragon\r\ndragon no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpPekkas = GUICtrlCreateGroup($sTxtPekkas, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonatePekkas = GUICtrlCreateIcon($pIconLib, $eIcnDonPekka, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonatePekkas = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtPekkas, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPekkas & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonatePekkas")
$chkDonateAllPekkas = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPekkas & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllPekkas")
$lblDonatePekkas = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtPekkas & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonatePekkas = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,53, "PEKKA\r\npekka")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtPekkas)
$lblBlacklistPekkas = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistPekkas = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,54, "no PEKKA\r\npekka no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtPekkas)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpBabyDragons = GUICtrlCreateGroup($sTxtBabyDragons, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateBabyDragons = GUICtrlCreateIcon($pIconLib, $eIcnDonBabyDragon, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateBabyDragons = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBabyDragons, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBabyDragons & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateBabyDragons")
$chkDonateAllBabyDragons = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBabyDragons & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllBabyDragons")
$lblDonateBabyDragons = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBabyDragons & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateBabyDragons = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,95, "baby dragon\r\nbaby")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBabyDragons)
$lblBlacklistBabyDragons = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistBabyDragons = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,96, "no baby dragon\r\nbaby dragon no\r\nno baby\r\nbaby no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBabyDragons)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpMiners = GUICtrlCreateGroup($sTxtMiners, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateMiners = GUICtrlCreateIcon($pIconLib, $eIcnDonMiner, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateMiners = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtMiners, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMiners & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateMiners")
$chkDonateAllMiners = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMiners & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllMiners")
$lblDonateMiners = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtMiners & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateMiners = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,97, "miner|mine")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtMiners)
$lblBlacklistMiners = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistMiners = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,98, "no miner\r\nminer no\r\nno mine\r\nmine no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtMiners)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpMinions = GUICtrlCreateGroup($sTxtMinions, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateMinions = GUICtrlCreateIcon($pIconLib, $eIcnDonMinion, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateMinions = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtMinions, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMinions & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateMinions")
$chkDonateAllMinions = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtMinions & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllMinions")
$lblDonateMinions = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtMinions & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateMinions = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,55, "minions\r\nminion")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtMinions)
$lblBlacklistMinions = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistMinions = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,56, "no minions\r\nminions no\r\nno minion\r\nminion no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtMinions)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpHogRiders = GUICtrlCreateGroup($sTxtHogRiders, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateHogRiders = GUICtrlCreateIcon($pIconLib, $eIcnDonHogRider, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateHogRiders = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHogRiders, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHogRiders & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateHogRiders")
$chkDonateAllHogRiders = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " &  $sTxtHogRiders & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllHogRiders")
$lblDonateHogRiders = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHogRiders & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateHogRiders = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,57, "hogriders\r\nhogs\r\nhog")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHogRiders)
$lblBlacklistHogRiders = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistHogRiders = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,58, "no hogs\r\nhog no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHogRiders)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpValkyries = GUICtrlCreateGroup($sTxtValkyries, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateValkyries = GUICtrlCreateIcon($pIconLib, $eIcnDonValkyrie, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateValkyries = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtValkyries, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtValkyries & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateValkyries")
$chkDonateAllValkyries = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtValkyries & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllValkyries")
$lblDonateValkyries = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtValkyries & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateValkyries = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,59, "valkyries\r\nvalkyrie\r\nvalk")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtValkyries)
$lblBlacklistValkyries = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistValkyries = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,60, "no valkyries\r\nvalkyries no\r\nno valk\r\nvalk no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtValkyries)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpGolems = GUICtrlCreateGroup($sTxtGolems, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateGolems = GUICtrlCreateIcon($pIconLib, $eIcnDonGolem, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateGolems = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtGolems, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGolems & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateGolems")
$chkDonateAllGolems = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtGolems & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllGolems")
$lblDonateGolems = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtGolems & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateGolems = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,61, "golem")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtGolems)
$lblBlacklistGolems = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistGolems = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,62, "no golem\r\ngolem no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtGolems)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpWitches = GUICtrlCreateGroup($sTxtWitches, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateWitches = GUICtrlCreateIcon($pIconLib, $eIcnDonWitch, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateWitches = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtWitches, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWitches & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateWitches")
$chkDonateAllWitches = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtWitches & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllWitches")
$lblDonateWitches = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtWitches & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateWitches = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,63, "witches\r\nwitch")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtWitches)
$lblBlacklistWitches = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistWitches = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,64, "no witches\r\nwitch no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtWitches)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpLavaHounds = GUICtrlCreateGroup($sTxtLavaHounds, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateLavaHounds = GUICtrlCreateIcon($pIconLib, $eIcnDonLavaHound, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateLavaHounds = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtLavaHounds, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLavaHounds & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateLavaHounds")
$chkDonateAllLavaHounds = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtLavaHounds & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllLavaHounds")
$lblDonateLavaHounds = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtLavaHounds & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateLavaHounds = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,65, "lavahound\r\nlava\r\nhound")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtLavaHounds)
$lblBlacklistLavaHounds = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistLavaHounds = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,66, "no lavahound\r\nlava no\r\nhound no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtLavaHounds)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpBowlers = GUICtrlCreateGroup($sTxtBowlers, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateBowlers = GUICtrlCreateIcon($pIconLib, $eIcnDonBowler, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateBowlers = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtBowlers, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBowlers & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateBowlers")
$chkDonateAllBowlers = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtBowlers & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllBowlers")
$lblDonateBowlers = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtBowlers & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateBowlers = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,93, "bowler\r\nbowlers\r\nbowl")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtBowlers)
$lblBlacklistBowlers = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistBowlers = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,94, "no bowler\r\nbowl no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtBowlers)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpPoisonSpells = GUICtrlCreateGroup($sTxtPoisonSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonatePoisonSpells = GUICtrlCreateIcon($pIconLib, $eIcnPoisonSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonatePoisonSpells = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtPoisonSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPoisonSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonatePoisonSpells")
$chkDonateAllPoisonSpells = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtPoisonSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllPoisonSpells")
$lblDonatePoisonSpells = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtPoisonSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonatePoisonSpells = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,87, "poison")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtPoisonSpells)
$lblBlacklistPoisonSpells = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistPoisonSpells = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,88, "no poison\r\npoison no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtPoisonSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpEarthQuakeSpells = GUICtrlCreateGroup($sTxtEarthQuakeSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateEarthQuakeSpells = GUICtrlCreateIcon($pIconLib, $eIcnEarthQuakeSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateEarthQuakeSpells = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtEarthQuakeSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtEarthQuakeSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateEarthQuakeSpells")
$chkDonateAllEarthQuakeSpells = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtEarthQuakeSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllEarthQuakeSpells")
$lblDonateEarthQuakeSpells = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtEarthQuakeSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateEarthQuakeSpells = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,89, "earthquake\r\nquake")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtEarthQuakeSpells)
$lblBlacklistEarthQuakeSpells = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistEarthQuakeSpells = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,90, "no earthquake\r\nquake no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtEarthQuakeSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpHasteSpells = GUICtrlCreateGroup($sTxtHasteSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateHasteSpells = GUICtrlCreateIcon($pIconLib, $eIcnHasteSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateHasteSpells = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtHasteSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHasteSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateHasteSpells")
$chkDonateAllHasteSpells = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtHasteSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllHasteSpells")
$lblDonateHasteSpells = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtHasteSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateHasteSpells = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,91, "haste")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtHasteSpells)
$lblBlacklistHasteSpells = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistHasteSpells = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,92, "no haste\r\nhaste no")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtHasteSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpSkeletonSpells = GUICtrlCreateGroup($sTxtSkeletonSpells, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateSkeletonSpells = GUICtrlCreateIcon($pIconLib, $eIcnSkeletonSpell, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateSkeletonSpells = GUICtrlCreateCheckbox($sTxtDonate & " " & $sTxtSkeletonSpells, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtSkeletonSpells & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateSkeletonSpells")
$chkDonateAllSkeletonSpells = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sTxtSkeletonSpells & " " & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllSkeletonSpells")
$lblDonateSkeletonSpells = 	GUICtrlCreateLabel($sTxtKeywords & " " & $sTxtSkeletonSpells & ":" , $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateSkeletonSpells = GUICtrlCreateEdit("", $x - 5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,99, "skeleton|skel")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sTxtSkeletonSpells)
$lblBlacklistSkeletonSpells = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 70, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistSkeletonSpells = GUICtrlCreateEdit("", $x + 215, $y + 85, 200, 60, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,100, "no skeleton\r\nskeleton no\r\nno skel")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sTxtSkeletonSpells)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpCustomA = GUICtrlCreateGroup($sDonateTxtCustomA, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateCustomA = GUICtrlCreateIcon($pIconLib, $eIcnDonCustom, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateCustomA = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomA, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomA & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateCustomA")
$chkDonateAllCustomA = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomA & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllCustomA")
$lblDonateCustomA =     GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomA & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateCustomA = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,71, "ground support\r\nground")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomA)
$lblDonateCustomA1 = GUICtrlCreateLabel(GetTranslated(612,72, "1st") & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateCustomA1 = GUICtrlCreateIcon($pIconLib, $eIcnDonWizard, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbDonateCustomA1 = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtWizards)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateCustomA1 = GUICtrlCreateInput("2", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
$lblDonateCustomA2 = GUICtrlCreateLabel(GetTranslated(612,73, "2nd") & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateCustomA2 = GUICtrlCreateIcon($pIconLib, $eIcnDonArcher, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbDonateCustomA2 = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtArchers)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateCustomA2 = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
$lblDonateCustomA3 = GUICtrlCreateLabel(GetTranslated(612,74, "3rd") & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateCustomA3 = GUICtrlCreateIcon($pIconLib, $eIcnDonBarbarian, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbDonateCustomA3 = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBarbarians)
GUICtrlSetOnEvent(-1, "cmbDonateCustomA")
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateCustomA3 = GUICtrlCreateInput("1", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
$lblBlacklistCustomA = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistCustomA = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,76, "no ground\r\nground no\r\nonly")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomA)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpCustomB = GUICtrlCreateGroup($sDonateTxtCustomB, $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 2
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateCustomB = GUICtrlCreateIcon($pIconLib, $eIcnDonCustomB, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$chkDonateCustomB = GUICtrlCreateCheckbox($sTxtDonate & " " & $sDonateTxtCustomB, $x + 285, $y + 10, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomB & " " & $sTxtDonateTipTroop)
GUICtrlSetOnEvent(-1, "chkDonateCustomB")
$chkDonateAllCustomB = GUICtrlCreateCheckbox($sTxtDonateAll, $x + 285, $y + 30, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $sTxtDonateTip & " " & $sDonateTxtCustomB & $sTxtDonateTipAll & @CRLF & $sTxtIgnoreAll)
GUICtrlSetOnEvent(-1, "chkDonateAllCustomB")
$lblDonateCustomB =     GUICtrlCreateLabel($sTxtKeywords & " " & $sDonateTxtCustomB & ":", $x - 5, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateCustomB = GUICtrlCreateEdit("", $x - 5, $y + 95, 205, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,101, "air support\r\nany air")))
_GUICtrlSetTip(-1, $sTxtKeywords & " " & $sDonateTxtCustomB)
$lblDonateCustomB1 = GUICtrlCreateLabel(GetTranslated(612,72, "1st") & ":", $x, $y + 4, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateCustomB1 = GUICtrlCreateIcon($pIconLib, $eIcnDonBabyDragon, $x + 25, $y, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbDonateCustomB1 = GUICtrlCreateCombo("", $x + 60, $y, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBabyDragons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateCustomB1 = GUICtrlCreateInput("1", $x + 165, $y, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
$lblDonateCustomB2 = GUICtrlCreateLabel(GetTranslated(612,73, "2nd") & ":", $x, $y + 29, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateCustomB2 = GUICtrlCreateIcon($pIconLib, $eIcnDonBalloon, $x + 25, $y + 25, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbDonateCustomB2 = GUICtrlCreateCombo("", $x + 60, $y + 25, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtBalloons)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateCustomB2 = GUICtrlCreateInput("3", $x + 165, $y + 25, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
$lblDonateCustomB3 = GUICtrlCreateLabel(GetTranslated(612,74, "3rd") & ":", $x, $y + 54, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateCustomB3 = GUICtrlCreateIcon($pIconLib, $eIcnDonMinion, $x + 25, $y + 50, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbDonateCustomB3 = GUICtrlCreateCombo("", $x + 60, $y + 50, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" & $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" & $sTxtBabyDragons & "|" & $sTxtMiners & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers & "|" & $sTxtNothing, $sTxtMinions)
GUICtrlSetOnEvent(-1, "cmbDonateCustomB")
GUICtrlSetState(-1, $GUI_HIDE)
$txtDonateCustomB3 = GUICtrlCreateInput("5", $x + 165, $y + 50, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetLimit(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
$lblBlacklistCustomB = GUICtrlCreateLabel($sTxtKeywordsNo & ":", $x + 215, $y + 80, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklistCustomB = GUICtrlCreateEdit("", $x + 215, $y + 95, 200, 50, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,102, "no air\r\nair no\r\nonly\r\njust")))
_GUICtrlSetTip(-1, $sTxtKeywordsNoTip & " " & $sDonateTxtCustomB)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 191
$grpBlacklist = GUICtrlCreateGroup(GetTranslated(612,78, "General Blacklist"), $x - 20, $y - 20, 430, 169)
$x -= 10
$y -= 4
GUICtrlSetState(-1, $GUI_HIDE)
$picDonateBlacklist = GUICtrlCreateIcon($pIconLib, $eIcnDonBlacklist, $x + 215, $y, 64, 64, $BS_ICON)
GUICtrlSetState(-1, $GUI_HIDE)
$lblBlacklist = GUICtrlCreateLabel(GetTranslated(612,77, "Do NOT donate to any of these keywords") & ":", $x - 5, $y + 5, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtBlacklist = GUICtrlCreateEdit("", $x -5, $y + 20, 205, 125, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetBkColor ( -1, 0x505050)
GUICtrlSetColor ( -1, $COLOR_WHITE)
GUICtrlSetData(-1, StringFormat(GetTranslated(612,79, "clan war\r\nwar\r\ncw")))
_GUICtrlSetTip(-1, GetTranslated(612,80, "General Blacklist for donation requests"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_DONATE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,13,"Schedule Donations"))
Local $x = 25, $y = 150 - 105
$grpDonateCC = GUICtrlCreateGroup(GetTranslated(613,1,"Donate Schedule"), $x - 20, $y - 20, 430, 334)
$y += 10
$x += 10
GUICtrlCreateIcon($pIconLib, $eIcnCCDonate, $x - 5, $y, 64, 60, $BS_ICON)
$chkDonateHours = GUICtrlCreateCheckbox(GetTranslated(603,30, -1), $x +40+ 30, $y-6)
GUICtrlSetOnEvent(-1, "chkDonateHours")
$y += 85
$x += 29 + 30
$lbDonateHours1 = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours2 = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours3 = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours4 = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours5 = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours6 = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours7 = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours8 = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours9 = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours10 = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours11 = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHours12 = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbDonateHoursED = GUICtrlCreateLabel("X", $x + 213, $y+2, 11, 11)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$chkDonateHours0 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours1 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours2 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours3 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours4 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours5 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours6 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours7 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours8 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours9 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours10 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours11 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
$txtTip = GetTranslated(603,2, -2)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDonateHoursE1")
$lbDonateHoursAM = GUICtrlCreateLabel(GetTranslated(603,3, -1), $x + 10, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$chkDonateHours12 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours13 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours14 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours15 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours16 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours17 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours18 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours19 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours20 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours21 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours22 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHours23 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkDonateHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
$txtTip = GetTranslated(603,2, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDonateHoursE2")
$lbDonateHoursPM = GUICtrlCreateLabel(GetTranslated(603,4, -1), $x + 10, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 16
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_UPGRADE = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_VILLAGE)
$hGUI_UPGRADE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_UPGRADE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,14,"Laboratory"))
Global $chkLab, $cmbLaboratory, $chkUpgradeKing, $chkUpgradeQueen, $chkUpgradeWarden, $chkbxUpgrade, $chkbxUpgrade, $txtUpgradeX, $txtUpgradeY,$txtUpgradeValue
Global $icnLabUpgrade, $btnResetLabUpgradeTime
Global $txtUpgrMinGold, $txtUpgrMinElixir, $lblNextUpgrade
$sTxtNothing = GetTranslated(603,0, "None")
$sTxtNames = $sTxtNothing & "|" & $sTxtBarbarians & "|" & $sTxtArchers & "|" & $sTxtGiants & "|" & $sTxtGoblins & "|" & $sTxtWallBreakers & "|" &  $sTxtBalloons & "|" & $sTxtWizards & "|" & $sTxtHealers & "|" & $sTxtDragons & "|" & $sTxtPekkas & "|" &  $sTxtBabyDragons & "|" &  $sTxtMiners & "|" &  $sTxtLiSpell & "|" & $sTxtHeSpell & "|" & $sTxtRaSpell & "|" & $sTxtJuSPell & "|" & $sTxtFrSpell & "|" &  $sTxtClSpell& "|" & $sTxtPoSpell & "|" &  $sTxtEaSpell & "|" & $sTxtHaSpell & "|" &  $sTxtSkSpell & "|" & $sTxtMinions & "|" & $sTxtHogRiders & "|" & $sTxtValkyries & "|" & $sTxtGolems & "|" & $sTxtWitches & "|" & $sTxtLavaHounds & "|" & $sTxtBowlers
$sTxtCheckBox = GetTranslated(616,27, "Check box to Enable Upgrade")
$sTxtAfterUsing = GetTranslated(616,28, "after using Locate Upgrades button")
$sTxtShowType = GetTranslated(616,29, "This shows type of upgrade, click to show location")
$sTxtStatus = GetTranslated(616,30, "Status: Red=not programmed, Yellow=programmed, not completed, Green=Completed")
$sTxtShowName = GetTranslated(616, 31, "This box is updated with unit name after upgrades are checked")
$sTxtShowLevel = GetTranslated(616, 32, "This unit box is updated with unit level after upgrades are checked")
$sTxtShowCost = GetTranslated(616, 33, "This upgrade cost box is updated after upgrades are checked")
$sTxtShowTime = GetTranslated(616, 34, "This box is updated with time length of upgrade after upgrades are checked")
$sTxtChkRepeat = GetTranslated(616, 35, "Check box to Enable Upgrade to repeat continuously")
$sTxtShowEndTime = GetTranslated(616, 36, "This box is updated with estimate end time of upgrade after upgrades are checked")
Local $x = 25, $y = 45
$Laboratory = GUICtrlCreateGroup(GetTranslated(614,1, "Laboratory"), $x - 20, $y - 20, 430, 334)
GUICtrlCreateIcon($pIconLib, $eIcnLaboratory, $x, $y, 64, 64)
$chkLab = GUICtrlCreateCheckbox(GetTranslated(614,2, "Auto Laboratory Upgrades"), $x + 80, $y + 5, -1, -1)
$txtTip = GetTranslated(614,3, "Check box to enable automatically starting Upgrades in laboratory")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkLab")
$lblNextUpgrade = GUICtrlCreateLabel(GetTranslated(614,4, "Next one") & ":", $x + 80, $y + 38, 50, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
$cmbLaboratory = GUICtrlCreateCombo("", $x + 135, $y + 35, 140, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtNames, GetTranslated(603,0, "None"))
$txtTip = GetTranslated(614,5, "Select the troop type to upgrade with this pull down menu") & @CRLF &  GetTranslated(614,6, "The troop icon will appear on the right.") & @CRLF & GetTranslated(614,7, "Any Dark Spell/Troop have priority over Upg Heroes!")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbLab")
$btnResetLabUpgradeTime = GUICtrlCreateButton("", $x + 120 + 172, $y + 36, 18, 18, BitOR($BS_PUSHLIKE,$BS_DEFPUSHBUTTON))
GUICtrlSetBkColor(-1, $COLOR_RED)
$txtTip = GetTranslated(614,8, "Visible Red button means that laboratory upgrade in process") & @CRLF &  GetTranslated(614,9, "This will automatically disappear when near time for upgrade to be completed.") & @CRLF &  GetTranslated(614,10, "If upgrade has been manually finished with gems before normal end time,") & @CRLF &  GetTranslated(614,11, "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF &  GetTranslated(614,12, "Caution - Unnecessary timer reset will force constant checks for lab status")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetOnEvent(-1, "ResetLabUpgradeTime")
$icnLabUpgrade = GUICtrlCreateIcon($pIconLib, $eIcnBlank, $x + 330, $y, 64, 64)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_UPGRADE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,15,"Heroes"))
Local $x = 25, $y = 45
$grpHeroes = GUICtrlCreateGroup(GetTranslated(615,1, "Upgrade Heroes Continuously"), $x - 20, $y - 20, 430, 334)
$lblUpgradeHeroes = GUICtrlCreateLabel(GetTranslated(615,2, "Auto upgrading of your Heroes"), $x - 10, $y, -1, -1)
$y += 20
$chkUpgradeKing = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$txtTip = GetTranslated(615,3, "Enable upgrading of your King when you have enough Dark Elixir (Saving Min. Dark Elixir)") & @CRLF & GetTranslated(615,4, "You can manually locate your Kings Altar on Misc Tab") & @CRLF &  GetTranslated(615,5, "Verify your Resume Bot Dark Elixir value at Misc Tab vs Saving Min. Dark Elixir here!") & @CRLF & GetTranslated(615,11, "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeKing")
GUICtrlCreateIcon($pIconLib, $eIcnKingUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $txtTip)
$IMGchkKingSleepWait=GUICtrlCreateIcon($pIconLib, $eIcnSleepingKing, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 95
$chkUpgradeQueen = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$txtTip = GetTranslated(615,6, "Enable upgrading of your Queen when you have enough Dark Elixir (Saving Min. Dark Elixir)") & @CRLF & GetTranslated(615,7, "You can manually locate your Queens Altar on Misc Tab") & @CRLF &  GetTranslated(615,5, -1) & @CRLF & GetTranslated(615,12, "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeQueen")
GUICtrlCreateIcon($pIconLib, $eIcnQueenUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $txtTip)
$IMGchkQueenSleepWait=GUICtrlCreateIcon($pIconLib, $eIcnSleepingQueen, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 95
$chkUpgradeWarden = GUICtrlCreateCheckbox("", $x, $y + 25, 17, 17)
$txtTip = GetTranslated(615,8, "Enable upgrading of your Warden when you have enough Elixir (Saving Min. Elixir)") & @CRLF & GetTranslated(615,9, "You can manually locate your Wardens Altar on Misc Tab") & @CRLF &  GetTranslated(615,5, -1) & @CRLF & GetTranslated(615,13, "Enabled with TownHall 11")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeWarden")
GUICtrlSetColor ( -1, $COLOR_RED )
GUICtrlCreateIcon($pIconLib, $eIcnWardenUpgr, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $txtTip)
$IMGchkWardenSleepWait=GUICtrlCreateIcon($pIconLib, $eIcnSleepingWarden, $x + 18, $y, 64, 64)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_UPGRADE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,16,"Buildings"))
Local $x = 25, $y = 45
$grpUpgrade = GUICtrlCreateGroup(GetTranslated(616,1, "Buildings or Heroes"), $x - 20, $y - 20, 430, 30 + ($iUpgradeSlots * 22))
$x -= 7
$y -= 7
$lblUpgradeUp1 = GUICtrlCreateLabel(GetTranslated(616,2,"Unit Name"), $x+71, $y, 70, 18)
$lblUpgradeUp2 = GUICtrlCreateLabel(GetTranslated(616,3,"Lvl"), $x+153, $y, 40, 18)
$lblUpgradeUp3 = GUICtrlCreateLabel(GetTranslated(616,4,"Type"), $x+173, $y, 50, 18)
$lblUpgradeUp4 = GUICtrlCreateLabel(GetTranslated(616,5,"Cost"), $x+219, $y, 50, 18)
$lblUpgradeUp5 = GUICtrlCreateLabel(GetTranslated(616,6,"Time"), $x+270, $y, 50, 18)
$lblUpgradeUp6 = GUICtrlCreateLabel(GetTranslated(616,7,"Rep."), $x+392, $y, 50, 18)
$lblUpgradeUp7 = GUICtrlCreateLabel(GetTranslated(616,37,"Estimate End"), $x+314, $y, 70, 18)
$y+=13
For $i = 0 To $iUpgradeSlots - 1
$picUpgradeStatus[$i]= GUICtrlCreateIcon($pIconLib, $eIcnTroops, $x - 10, $y+1, 14, 14)
_GUICtrlSetTip(-1, $sTxtStatus)
$chkbxUpgrade[$i] = GUICtrlCreateCheckbox($i+1 &":", $x + 5, $y+1, 34, 15)
_GUICtrlSetTip(-1,  $sTxtCheckBox & " #" & $i+1 & " " & $sTxtAfterUsing)
GUICtrlSetOnEvent(-1, "btnchkbxUpgrade")
$txtUpgradeName[$i] = GUICtrlCreateInput("", $x+40, $y, 107, 17,BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowName)
$txtUpgradeLevel[$i] = GUICtrlCreateInput("", $x+150, $y, 23, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowLevel)
$picUpgradeType[$i]= GUICtrlCreateIcon($pIconLib, $eIcnBlank,$x+178, $y+1, 15, 15)
_GUICtrlSetTip(-1, $sTxtShowType)
GUICtrlSetOnEvent(-1, "picUpgradeTypeLocation")
$txtUpgradeValue[$i] = GUICtrlCreateInput("", $x+197, $y, 65, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowCost)
$txtUpgradeTime[$i] = GUICtrlCreateInput("", $x+266, $y, 35, 17, BitOR($ES_CENTER, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtShowTime)
$txtUpgradeEndTime[$i] = GUICtrlCreateInput("", $x+305, $y, 85, 17, BitOR($ES_LEFT, $GUI_SS_DEFAULT_INPUT, $ES_READONLY, $ES_NUMBER))
GUICtrlSetFont(-1, 7)
_GUICtrlSetTip(-1, $sTxtShowEndTime)
$chkUpgrdeRepeat[$i] = GUICtrlCreateCheckbox("", $x + 395, $y+1, 15, 15)
_GUICtrlSetTip(-1, $sTxtChkRepeat)
GUICtrlSetOnEvent(-1, "btnchkbxRepeat")
$y += 22
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x += 5
$y += 8
GUICtrlCreateIcon ($pIconLib, $eIcnGold, $x - 15, $y, 15, 15)
$UpgrMinGold = GUICtrlCreateLabel(GetTranslated(616,14, "Min. Gold")&":", $x + 5, $y + 3, -1, -1)
$txtUpgrMinGold = GUICtrlCreateInput("250000", $x + 55, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(616,15, "Save this much Gold after the upgrade completes.") & @CRLF & GetTranslated(616,16, "Set this value as needed to save for searching, or wall upgrades."))
GUICtrlSetLimit(-1, 7)
$y += 18
GUICtrlCreateIcon ($pIconLib, $eIcnElixir, $x - 15, $y, 15, 15)
$UpgrMinElixir = GUICtrlCreateLabel(GetTranslated(616,17, "Min. Elixir") & ":", $x + 5, $y + 3, -1, -1)
$txtUpgrMinElixir = GUICtrlCreateInput("250000", $x + 55, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(616,18, "Save this much Elixir after the upgrade completes") & @CRLF & GetTranslated(616,19, "Set this value as needed to save for making troops or wall upgrades."))
GUICtrlSetLimit(-1, 7)
$x -= 15
$y -= 8
GUICtrlCreateIcon ($pIconLib, $eIcnDark, $x + 140, $y, 15, 15)
$UpgrMinDark = GUICtrlCreateLabel(GetTranslated(616,20, "Min. Dark") & ":", $x + 160, $y + 3, -1, -1)
$txtUpgrMinDark= GUICtrlCreateInput("3000", $x + 210, $y, 61, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(616,21, "Save this amount of Dark Elixir after the upgrade completes.") & @CRLF & GetTranslated(616,22, "Set this value higher if you want make war troops."))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y -= 8
$btnLocateUpgrade = GUICtrlCreateButton(GetTranslated(616,8, "Locate Upgrades"), $x + 290, $y - 4, 120, 18, BitOR($BS_MULTILINE, $BS_VCENTER))
$txtTip = GetTranslated(616,9, "Push button to locate and record information on building/Hero upgrades") & @CRLF &  GetTranslated(616,10, "Any upgrades with repeat enabled are skipped and can not be located again")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnLocateUpgrades")
$btnResetUpgrade = GUICtrlCreateButton(GetTranslated(616,11, "Reset Upgrades"), $x + 290, $y + 16, 120, 18, BitOR($BS_MULTILINE, $BS_VCENTER))
$txtTip = GetTranslated(616,12, "Push button to reset & remove upgrade information") & @CRLF &  GetTranslated(616,13, "If repeat box is checked, data will not be reset")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnResetUpgrade")
GUICtrlCreateTabItem("")
$hGUI_UPGRADE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,17,"Walls"))
Global $chkWalls
Global $txtWall04ST, $txtWall05ST, $txtWall06ST, $txtWall07ST, $txtWall08ST, $txtWall09ST, $txtWall10ST, $txtWall11ST
Global $Wall04ST, $Wall05ST, $Wall06ST, $Wall07ST, $Wall08ST, $Wall09ST, $Wall10ST, $Wall11ST
Global $sldMaxNbWall
Global $lblWallCost, $cmbWalls, $UseGold, $UseElixir, $UseElixirGold, $txtWallMinGold, $txtWallMinElixir
Local $x = 25, $y = 45
$grpWalls = GUICtrlCreateGroup(GetTranslated(617,1, "Walls"), $x - 20, $y - 20, 430, 150)
GUICtrlCreateIcon ($pIconLib, $eIcnWall, $x - 12, $y - 6, 24, 24)
$chkWalls = GUICtrlCreateCheckbox(GetTranslated(617,2, "Auto Wall Upgrade"), $x + 18, $y-2, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,3, "Check this to upgrade Walls if there are enough resources."))
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkWalls")
_ArrayConcatenate($G, $B)
$sldMaxNbWall = GUICtrlCreateSlider( $x + 135, $y, 85 , 24, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, GetTranslated(617,4, "No. of Positions to test and find walls. Higher is better but slower."))
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlSetLimit(-1, 8, 1)
GUICtrlSetData(-1, 4)
$btnFindWalls = GUICtrlCreateButton(GetTranslated(617,5, "TEST"), $x + 150, $y , 45, -1)
$txtTip = GetTranslated(617,6, "Click here to test the Wall Detection.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnWalls")
IF $btnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
$UseGold = GUICtrlCreateRadio(GetTranslated(617,7, "Use Gold"), $x + 25, $y + 16, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,8, "Use only Gold for Walls.") & @CRLF & GetTranslated(617,9, "Available at all Wall levels."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$UseElixir = GUICtrlCreateRadio(GetTranslated(617,10, "Use Elixir"), $x + 25, $y + 34, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,11, "Use only Elixir for Walls.") & @CRLF & GetTranslated(617,12, "Available only at Wall levels upgradeable with Elixir."))
GUICtrlSetState(-1, $GUI_DISABLE)
$UseElixirGold = GUICtrlCreateRadio(GetTranslated(617,13, "Try Elixir first, Gold second"), $x + 25, $y + 52, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,14, "Try to use Elixir first. If not enough Elixir try to use Gold second for Walls.") & @CRLF & GetTranslated(617,12, -1))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon ($pIconLib, $eIcnBuilder, $x - 12, $y + 72, 20, 20)
$chkSaveWallBldr = GUICtrlCreateCheckbox(GetTranslated(617,15, "Save ONE builder for Walls"), $x+18, $y + 72, -1, -1)
$TxtTip = GetTranslated(617,16, "Check this to reserve 1 builder exclusively for walls and") & @CRLF &GetTranslated(617,17, "reduce the available builder by 1 for other upgrades")
_GUICtrlSetTip(-1, $TxtTip)
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSaveWallBldr")
$chkUpgradeContinually = GUICtrlCreateCheckbox("Upgrade Continually", $x+18, $y + 92, -1, -1)
$TxtTip = "Check this to Upgrade Walls Continually Until Reaching The Minimum Number Of Resources"
_GUICtrlSetTip(-1, $TxtTip)
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkUpgradeContinually")
$x += 225
$lblWalls = GUICtrlCreateLabel(GetTranslated(617,18, "Search for Walls level") & ":", $x, $y+2, -1, -1)
$cmbWalls = GUICtrlCreateCombo("", $x + 110, $y, 61, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL), $WS_EX_RIGHT)
_GUICtrlSetTip(-1, GetTranslated(617,19, "Search for Walls of this level and try to upgrade them one by one."))
GUICtrlSetData(-1, "4   |5   |6   |7   |8   |9   |10   ", "4   ")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbWalls")
_ArrayConcatenate($G, $C)
$lblTxtWallCost = GUICtrlCreateLabel(GetTranslated(617,20, "Next Wall level costs") &":", $x,  $y + 25, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(617,21, "Use this value as an indicator.") &@CRLF & GetTranslated(617,22, "The value will update if you select an other wall level."))
$lblWallCost = GUICtrlCreateLabel("30 000", $x + 110, $y + 25, 50, -1, $SS_RIGHT)
GUICtrlCreateIcon ($pIconLib, $eIcnGold, $x, $y + 47, 16, 16)
$WallMinGold = GUICtrlCreateLabel(GetTranslated(617,23, "Min. Gold to save"), $x + 20, $y + 47, -1, -1)
$txtWallMinGold = GUICtrlCreateInput("250000", $x + 110, $y + 45, 61, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,24, "Save this much Gold after the wall upgrade completes,") & @CRLF & GetTranslated(617,25, "Set this value to save Gold for other upgrades, or searching."))
GUICtrlSetLimit(-1, 7)
GUICtrlSetState(-1, $GUI_DISABLE)
$y +=2
GUICtrlCreateIcon ($pIconLib, $eIcnElixir, $x, $y + 67, 16, 16)
$WallMinElixir = GUICtrlCreateLabel(GetTranslated(617,32, "Min. Elixir to save"), $x + 20, $y + 70, -1, -1)
$txtWallMinElixir = GUICtrlCreateInput("250000", $x + 110, $y + 65, 61, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,27, "Save this much Elixir after the wall upgrade completes,") & @CRLF & GetTranslated(617,28, "Set this value to save Elixir for other upgrades or troop making."))
GUICtrlSetLimit(-1, 7)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 200
$grpUpgrWalls = GUICtrlCreateGroup(Gettranslated(617,29, "Walls counter"), $x - 20, $y - 20, 430, 60)
$x -= 3
$txtWall04ST = GUICtrlCreateInput("0", $x - 10, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 4 "&GetTranslated(617,31, "you have."))
$Wall04ST = GUICtrlCreateIcon(@ScriptDir & "\Images\Walls\04.ico",-1, $x + 17, $y-2, 24, 24)
$x = 70
$txtWall05ST = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 5 "&GetTranslated(617,31, "you have."))
$Wall05ST = GUICtrlCreateIcon(@ScriptDir & "\Images\Walls\05.ico",-1, $x+27, $y-2, 24, 24)
$x = +130
$txtWall06ST = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 6 "&GetTranslated(617,31, "you have."))
$Wall06ST = GUICtrlCreateIcon(@ScriptDir & "\Images\Walls\06.ico",-1, $x+27, $y-2, 24, 24)
$x = +180
$txtWall07ST = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 7 "&GetTranslated(617,31, "you have."))
$Wall07ST = GUICtrlCreateIcon(@ScriptDir & "\Images\Walls\07.ico",-1, $x+27, $y-2, 24, 24)
$x = +230
$txtWall08ST = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 8 "&GetTranslated(617,31, "you have."))
$Wall08ST = GUICtrlCreateIcon(@ScriptDir & "\Images\Walls\08.ico",-1, $x+27, $y-2, 24, 24)
$x = +280
$txtWall09ST = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 9 "&GetTranslated(617,31, "you have."))
$Wall09ST = GUICtrlCreateIcon(@ScriptDir & "\Images\Walls\09.ico",-1, $x+27, $y-2, 24, 24)
$x = +330
$txtWall10ST = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 10 "&GetTranslated(617,31, "you have."))
$Wall10ST = GUICtrlCreateIcon(@ScriptDir & "\Images\Walls\10.ico",-1, $x+27, $y-2, 24, 24)
$x = +380
$txtWall11ST = GUICtrlCreateInput("0", $x, $y , 25, 19, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(617,30, "Input number of Walls level")&" 11 "&GetTranslated(617,31, "you have."))
$Wall11ST = GUICtrlCreateIcon(@ScriptDir & "\Images\Walls\11.ico",-1, $x+27, $y-2, 24, 24)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_NOTIFY = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_VILLAGE)
$hGUI_NOTIFY_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_NOTIFY_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,18,"PushBullet/Telegram"))
Local $x = 25, $y = 45
$grpNotify = GUICtrlCreateGroup(GetTranslated(619,1, "PushBullet/Telegram Notify") & " " & $NotifyVersion, $x - 20, $y - 20, 430, 334)
$x -= 10
$picPushBullet = GUICtrlCreateIcon ($pIconLib, $eIcnPushBullet, $x + 3, $y, 32, 32)
$chkNotifyPBEnabled = GUICtrlCreateCheckbox(GetTranslated(619,2, "Enable PushBullet"), $x + 40, $y)
GUICtrlSetOnEvent(-1, "chkPBTGenabled")
_GUICtrlSetTip(-1, GetTranslated(619,3, "Enable PushBullet notifications"))
$chkTGenabled = GUICtrlCreateCheckbox(GetTranslated(619,4, "Enable Telegram"), $x + 40, $y + 22)
GUICtrlSetOnEvent(-1, "chkPBTGenabled")
_GUICtrlSetTip(-1, GetTranslated(619,5, "Enable Telegram notifications"))
$chkNotifyRemote = GUICtrlCreateCheckbox(GetTranslated(619,6, "Remote Control"), $x + 40, $y + 44)
_GUICtrlSetTip(-1, GetTranslated(619,7, "Enables PushBullet Remote function"))
GUICtrlSetState(-1, $GUI_DISABLE)
$y = 45
$chkNotifyDeleteAllPBPushes = GUICtrlCreateCheckbox(GetTranslated(619,8, "Delete Msg on Start"), $x + 160, $y)
_GUICtrlSetTip(-1, GetTranslated(619,9, "It will delete all previous push notification when you start bot"))
GUICtrlSetState(-1, $GUI_DISABLE)
$btnNotifyDeleteMessages = GUICtrlCreateButton(GetTranslated(619,10, "Delete all Msg now"), $x + 300, $y, 100, 20)
_GUICtrlSetTip(-1, GetTranslated(619,11, "Click here to delete all PushBullet messages."))
GUICtrlSetOnEvent(-1, "btnDeletePBMessages")
IF $btnColor then GUICtrlSetBkColor(-1, 0x5CAD85)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 22
$chkNotifyDeleteOldPBPushes = GUICtrlCreateCheckbox(GetTranslated(619,12, "Delete Msg older than"), $x + 160, $y)
_GUICtrlSetTip(-1, GetTranslated(619,13, "Delete all previous push notification older than specified hour"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkDeleteOldPBPushes")
$cmbNotifyPushHours = GUICtrlCreateCombo("", $x + 300, $y, 100, 35, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(619,14, "Set the interval for messages to be deleted."))
$sTxtHours = GetTranslated(603,14, "Hours")
GUICtrlSetData(-1, "1 " & GetTranslated(619,15, "Hour") &"|2 " & $sTxtHours & "|3 " & $sTxtHours & "|4 " & $sTxtHours & "|5 " & $sTxtHours & "|6 " & $sTxtHours & "|7 " & $sTxtHours & "|8 " &$sTxtHours & "|9 " & $sTxtHours & "|10 " & $sTxtHours & "|11 " & $sTxtHours & "|12 " & $sTxtHours & "|13 " & $sTxtHours & "|14 " & $sTxtHours & "|15 " & $sTxtHours & "|16 " & $sTxtHours & "|17 " & $sTxtHours & "|18 " & $sTxtHours & "|19 " & $sTxtHours & "|20 " & $sTxtHours & "|21 " & $sTxtHours & "|22 " & $sTxtHours & "|23 " & $sTxtHours & "|24 " & $sTxtHours )
_GUICtrlComboBox_SetCurSel(-1,0)
GUICtrlSetState (-1, $GUI_DISABLE)
$y += 55
$lblPushBulletTokenValue = GUICtrlCreateLabel(GetTranslated(619,16, "Token (PushBullet)") & ":", $x, $y, -1, -1, $SS_RIGHT)
$txbNotifyPBToken = GUICtrlCreateInput("", $x + 120, $y - 3, 280, 19)
_GUICtrlSetTip(-1, GetTranslated(619,17, "You need a Token to use PushBullet notifications. Get a token from PushBullet.com"))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
$lblTelegramTokenValue = GUICtrlCreateLabel(GetTranslated(619,18, "Token (Telegram)") & ":", $x, $y, -1, -1, $SS_RIGHT)
$txbNotifyTGToken = GUICtrlCreateInput("", $x + 120, $y - 3, 280, 19)
_GUICtrlSetTip(-1, GetTranslated(619,19, "You need a Token to use Telegram notifications. Get a token from Telegram.com"))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
$lblOrigPushBullet = GUICtrlCreateLabel(GetTranslated(619,20, "Origin") & ":", $x, $y, -1, -1, $SS_RIGHT)
$txtTip = GetTranslated(619,21, "Origin - Village name.")
_GUICtrlSetTip(-1, $txtTip)
$txbNotifyOrigin = GUICtrlCreateInput("", $x + 120, $y - 3, 280, 19)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 25
$lblNotifyPBWhen = GUICtrlCreateLabel(GetTranslated(619,22, "Send a PushBullet/Telegram message for these options") & ":", $x, $y, -1, -1, $SS_RIGHT)
$y += 15
$chkNotifyAlertMatchFound = GUICtrlCreateCheckbox(GetTranslated(619,23, "Match Found"), $x + 10, $y)
_GUICtrlSetTip(-1, GetTranslated(619,24, "Send the amount of available loot when bot finds a village to attack."))
GUICtrlSetState(-1, $GUI_DISABLE)
$chkNotifyAlertLastRaidIMG = GUICtrlCreateCheckbox(GetTranslated(619,25, "Last raid as image"), $x + 100, $y)
_GUICtrlSetTip(-1, GetTranslated(619,26, "Send the last raid screenshot."))
GUICtrlSetState(-1, $GUI_DISABLE)
$chkNotifyAlertLastRaidTXT = GUICtrlCreateCheckbox(GetTranslated(619,27, "Last raid as Text"), $x + 210, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(619,28, "Send the last raid results as text."))
$chkNotifyAlertCampFull = GUICtrlCreateCheckbox(GetTranslated(619,29, "Army Camp Full"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,30, "Sent an Alert when your Army Camp is full."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$chkNotifyAlertUpgradeWall = GUICtrlCreateCheckbox(GetTranslated(619,31, "Wall upgrade"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,32, "Send info about wall upgrades."))
GUICtrlSetState(-1, $GUI_DISABLE)
$chkNotifyAlertOutOfSync = GUICtrlCreateCheckbox(GetTranslated(619,33, "Error: Out Of Sync"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,34, "Send an Alert when you get the Error: Client and Server out of sync"))
GUICtrlSetState(-1, $GUI_DISABLE)
$chkNotifyAlertTakeBreak = GUICtrlCreateCheckbox(GetTranslated(619,35, "Take a break"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,36, "Send an Alert when you have been playing for too long and your villagers need to rest."))
GUICtrlSetState(-1, $GUI_DISABLE)
$chkNotifyAlertBuilderIdle = GUICtrlCreateCheckbox(GetTranslated(619,37, "Builder Idle"), $x + 315, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,38, "Send an Alert when at least one builder is idle."))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$chkNotifyAlertVillageStats = GUICtrlCreateCheckbox(GetTranslated(619,39, "Village Report"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,40, "Send a Village Report."))
GUICtrlSetState(-1, $GUI_DISABLE)
$chkNotifyAlertLastAttack = GUICtrlCreateCheckbox(GetTranslated(619,41, "Alert Last Attack"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,42, "Send info about the Last Attack."))
GUICtrlSetState(-1, $GUI_DISABLE)
$chkNotifyAlertAnotherDevice = GUICtrlCreateCheckbox(GetTranslated(619,43, "Another device"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,44, "Send an Alert when your village is connected to from another device."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 20
$chkNotifyAlertMaintenance = GUICtrlCreateCheckbox(GetTranslated(619,45, "Maintenance"), $x + 10, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,46, "Send an Alert when CoC is under maintenance by SuperCell"))
GUICtrlSetState(-1, $GUI_DISABLE)
$chkNotifyAlertBAN = GUICtrlCreateCheckbox(GetTranslated(619,47, "BAN"), $x + 100, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,48, "Send an Alert if your village was BANNED by SuperCell"))
GUICtrlSetState(-1, $GUI_DISABLE)
$chkNotifyBOTUpdate = GUICtrlCreateCheckbox(GetTranslated(619,49, "BOT Update"), $x + 210, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(619,50, "Send an Alert when there is a new version of the bot."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_NOTIFY_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,19,"Instructions"))
Local $NotifyHelp = _IECreateEmbedded()
GUICtrlCreateObj($NotifyHelp, 5, 25, 430, 334)
If FileExists(@ScriptDir & "\Help\NotifyHelp_" & $sDefaultLanguage & ".mht") Then
_IENavigate($NotifyHelp, @ScriptDir & "\Help\NotifyHelp_" & $sDefaultLanguage & ".mht", 1)
ElseIf FileExists(@ScriptDir & "\Help\NotifyHelp_English.mht") Then
_IENavigate($NotifyHelp, @ScriptDir & "\Help\NotifyHelp_English.mht", 1)
EndIf
$NotifyHelp.document.body.style.border = "0px"
GUICtrlCreateTabItem("")
$hGUI_NOTIFY_TAB_ITEM6 = GUICtrlCreateTabItem(GetTranslated(619,51,"Notify Schedule"))
$x = 25
$y = 150 - 105
$grpSchedulerNotify = GUICtrlCreateGroup(GetTranslated(619,51, "Notify Schedule"), $x - 20, $y - 20, 430, 334)
$x += 10
$y += 10
GUICtrlCreateIcon($pIconLib, $eIcnPBNotify, $x - 5, $y, 64, 64, $BS_ICON)
$chkNotifyHours = GUICtrlCreateCheckbox(GetTranslated(619,52, "Only during these hours of day"), $x+70, $y-6)
GUICtrlSetOnEvent(-1, "chkNotifyHours")
$x += 59
$y += 85
$lbNotifyhours1 = GUICtrlCreateLabel(" 0", $x + 30, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours2 = GUICtrlCreateLabel(" 1", $x + 45, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours3 = GUICtrlCreateLabel(" 2", $x + 60, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours4 = GUICtrlCreateLabel(" 3", $x + 75, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours5 = GUICtrlCreateLabel(" 4", $x + 90, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours6 = GUICtrlCreateLabel(" 5", $x + 105, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours7 = GUICtrlCreateLabel(" 6", $x + 120, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours8 = GUICtrlCreateLabel(" 7", $x + 135, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours9 = GUICtrlCreateLabel(" 8", $x + 150, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours10 = GUICtrlCreateLabel(" 9", $x + 165, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours11 = GUICtrlCreateLabel("10", $x + 180, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyhours12 = GUICtrlCreateLabel("11", $x + 195, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$chkNotifyhours0 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours1 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours2 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours3 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours4 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours5 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours6 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours7 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours8 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours9 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours10 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours11 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
$txtTip = GetTranslated(619,53, "This button will clear or set the entire row of boxes")
GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkNotifyhoursE1")
$lbNotifyhoursAM = GUICtrlCreateLabel("AM", $x + 10, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 15
$chkNotifyhours12 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours13 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours14 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours15 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours16 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours17 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours18 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours19 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours20 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours21 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours22 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhours23 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyhoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED + $GUI_DISABLE)
$txtTip = GetTranslated(619,53, "This button will clear or set the entire row of boxes")
GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkNotifyhoursE2")
$lbNotifyhoursPM = GUICtrlCreateLabel("PM", $x + 10, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$x = 35
$y = 220
$chkNotifyWeekDays = GUICtrlCreateCheckbox(GetTranslated(619,54, "Notify only in this day of the week"), $x + 70, $y - 6)
GUICtrlSetOnEvent(-1, "chkNotifyWeekDays")
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 59
$y += 19
$lbNotifyWeekdays0 = " " & GUICtrlCreateLabel(GetTranslated(619,55, "S"), $x + 30, $y)
GUICtrlSetTip(-1, GetTranslated(619,56, "Sunday"))
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyWeekdays1 = " " & GUICtrlCreateLabel(GetTranslated(619,57, "M"), $x + 45, $y)
GUICtrlSetTip(-1, GetTranslated(619,58, "Monday"))
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyWeekdays2 = " " & GUICtrlCreateLabel(GetTranslated(619,59, "T"), $x + 60, $y)
GUICtrlSetTip(-1, GetTranslated(619,60, "Tuesday"))
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyWeekdays3 = " " & GUICtrlCreateLabel(GetTranslated(619,61, "W"), $x + 75, $y)
GUICtrlSetTip(-1, GetTranslated(619,62, "Wednesday"))
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyWeekdays4 = " " & GUICtrlCreateLabel(GetTranslated(619,63, "T"), $x + 90, $y)
GUICtrlSetTip(-1, GetTranslated(619,64, "Thursday"))
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyWeekdays5 = " " & GUICtrlCreateLabel(GetTranslated(619,65, "F"), $x + 105, $y)
GUICtrlSetTip(-1, GetTranslated(619,66, "Friday"))
GUICtrlSetState(-1, $GUI_DISABLE)
$lbNotifyWeekdays6 = " " & GUICtrlCreateLabel(GetTranslated(619,67, "S"), $x + 120, $y)
GUICtrlSetTip(-1, GetTranslated(619,68, "Saturday"))
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 13
$chkNotifyWeekdays0 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyWeekdays1 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyWeekdays2 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyWeekdays3 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyWeekdays4 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyWeekdays5 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
$chkNotifyWeekdays6 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED + $GUI_DISABLE)
GUISwitch($hGUI_VILLAGE)
$hGUI_VILLAGE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_VILLAGE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,6,"Misc"))
Global $chkBotStop, $cmbBotCommand, $cmbBotCond, $cmbHoursStop
Global $txtTimeWakeUp
Global $txtRestartGold, $txtRestartElixir, $txtRestartDark
Local $x = 15, $y = 45
$grpControls = GUICtrlCreateGroup(GetTranslated(610,1, "Halt Attack"), $x - 10, $y - 20, 440, 100)
$chkBotStop = GUICtrlCreateCheckbox("", $x - 5, $y, 16, 16)
$txtTip = GetTranslated(610,2, "Use these options to set when the bot will stop attacking.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkBotStop")
$cmbBotCommand = GUICtrlCreateCombo("", $x + 20, $y - 3, 95, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, GetTranslated(610,3, "Halt Attack") & "|" & GetTranslated(610,4, "Stop Bot") & "|" & GetTranslated(610,5, "Close Bot") & "|" & GetTranslated(610,6, "Close CoC+Bot") & "|" & GetTranslated(610,7, "Shutdown PC") & "|" & GetTranslated(610,8, "Sleep PC") & "|" & GetTranslated(610,9, "Reboot PC"), GetTranslated(610,3, -1))
GUICtrlSetState (-1, $GUI_DISABLE)
$lblBotCond = GUICtrlCreateLabel(GetTranslated(610,10, "When..."), $x + 128, $y, 45, 17)
$cmbBotCond = GUICtrlCreateCombo("", $x + 175, $y - 3, 160, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, GetTranslated(610,11, "G and E Full and Max.Trophy") & "|" & GetTranslated(610,12, "(G and E) Full or Max.Trophy") & "|" & GetTranslated(610,13, "(G or E) Full and Max.Trophy") & "|" &  GetTranslated(610,14, "G or E Full or Max.Trophy") & "|" & GetTranslated(610,15, "Gold and Elixir Full") & "|" & GetTranslated(610,16, "Gold or Elixir Full") & "|" & GetTranslated(610,17, "Gold Full and Max.Trophy") & "|" &  GetTranslated(610,18, "Elixir Full and Max.Trophy") & "|" & GetTranslated(610,19, "Gold Full or Max.Trophy") & "|" & GetTranslated(610,20, "Elixir Full or Max.Trophy") & "|" & GetTranslated(610,21, "Gold Full") & "|" &  GetTranslated(610,22, "Elixir Full") & "|" & GetTranslated(610,23, "Reach Max. Trophy") & "|" & GetTranslated(610,24, "Dark Elixir Full") & "|" & GetTranslated(610,25, "All Storage (G+E+DE) Full") & "|" &  GetTranslated(610,26, "Bot running for...") & "|" & GetTranslated(610,27, "Now (Train/Donate Only)") & "|" &  GetTranslated(610,28, "Now (Donate Only)") & "|" & GetTranslated(610,29, "Now (Only stay online)") & "|" & GetTranslated(610,30, "W/Shield (Train/Donate Only)") & "|" & GetTranslated(610,31, "W/Shield (Donate Only)") & "|" &  GetTranslated(610,32, "W/Shield (Only stay online)"), GetTranslated(610,27, -1))
GUICtrlSetOnEvent(-1, "cmbBotCond")
GUICtrlSetState (-1, $GUI_DISABLE)
$cmbHoursStop = GUICtrlCreateCombo("", $x + 340, $y - 3, 80, 35, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $txtTip)
$sTxtHours = GetTranslated(603,14, "Hours")
GUICtrlSetData(-1, "-|1 " & GetTranslated(603,15, "Hour") & "|2 " & $sTxtHours & "|3 " & $sTxtHours & "|4 " & $sTxtHours & "|5 " & $sTxtHours & "|6 " & $sTxtHours & "|7 " & $sTxtHours & "|8 " & $sTxtHours & "|9 " & $sTxtHours & "|10 " & $sTxtHours & "|11 " & $sTxtHours & "|12 " & $sTxtHours& "|13 " & $sTxtHours & "|14 " & $sTxtHours & "|15 " & $sTxtHours & "|16 " & $sTxtHours & "|17 " & $sTxtHours & "|18 " & $sTxtHours & "|19 " & $sTxtHours & "|20 " & $sTxtHours & "|21 " & $sTxtHours & "|22 " & $sTxtHours & "|23 " & $sTxtHours & "|24 " & $sTxtHours, "-")
GUICtrlSetState (-1, $GUI_DISABLE)
$y += 25
$lblRestartMins = GUICtrlCreateLabel(GetTranslated(610,35, "The bot will Halt automatically when you run out of Resources. It will resume when reaching these minimal values."), $x + 20, $y, 400, 25, $BS_MULTILINE)
$y += 30
$lblResumeAttack = GUICtrlCreateLabel(GetTranslated(610,36, "Resume Attack") & ":", $x + 20, $y + 2, 80, -1)
$x += 90
$lblRestartGold = GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
GUICtrlCreateIcon ($pIconLib, $eIcnGold, $x + 82, $y, 16, 16)
$txtRestartGold = GUICtrlCreateInput("10000", $x + 30, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(610,37, "Minimum Gold value for the bot to resume attacking after halting because of low gold.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 7)
$x += 90
$lblRestartElixir = GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
GUICtrlCreateIcon ($pIconLib, $eIcnElixir, $x + 82, $y, 16, 16)
$txtRestartElixir = GUICtrlCreateInput("25000", $x + 30, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(610,38, "Minimum Elixir value for the bot to resume attacking after halting because of low elixir.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 7)
$x += 90
$lblRestartDark = GUICtrlCreateLabel(ChrW(8805), $x + 22, $y + 2, -1, -1)
GUICtrlCreateIcon ($pIconLib, $eIcnDark, $x + 82, $y, 16, 16)
$txtRestartDark = GUICtrlCreateInput("500", $x + 30, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(610,39, "Minimum Dark Elixir value for the bot to resume attacking after halting because of low dark elixir.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 15, $y = 150
$grpMisc = GUICtrlCreateGroup(GetTranslated(610,40, "Rearm, Collect, Clear"), $x -10, $y - 20 , 440, 190)
GUICtrlCreateIcon($pIconLib, $eIcnTrap, $x + 7, $y, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnXbow, $x + 32, $y, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnInferno, $x + 57, $y, 24, 24)
$chkTrap = GUICtrlCreateCheckbox(GetTranslated(610,41, "Rearm Traps && Reload Xbows and Infernos"), $x + 100, $y + 4, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(610,42, "Check this to automatically Rearm Traps, Reload Xbows and Infernos (if any) in your Village."))
GUICtrlSetOnEvent(-1, "chkTrap")
_ArrayConcatenate($G, $D)
$y += 35
GUICtrlCreateIcon($pIconLib, $eIcnMine, $x - 5, $y, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20, $y, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnDrill, $x + 45, $y, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnLootCart, $x + 70, $y, 24, 24)
$chkCollect = GUICtrlCreateCheckbox(GetTranslated(610,43, "Collect Resources && Loot Cart"), $x + 100, $y + 4, -1, -1, -1)
$txtTip = GetTranslated(610,44, "Check this to automatically collect the Village's Resources") & @CRLF & GetTranslated(610,45, "from Gold Mines, Elixir Collectors and Dark Elixir Drills.") & @CRLF & GetTranslated(610,46, "This will also search for a Loot Cart in your village and collect it.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 35
GUICtrlCreateIcon($pIconLib, $eIcnTombstone, $x + 32 , $y, 24, 24)
$chkTombstones = GUICtrlCreateCheckbox(GetTranslated(610,47, "Clear Tombstones"), $x + 100, $y + 4, -1, -1)
$txtTip = GetTranslated(610,48, "Check this to automatically clear tombstones after enemy attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 35
GUICtrlCreateIcon($pIconLib, $eIcnTree, $x + 20, $y, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnBark, $x + 45, $y, 24, 24)
$chkCleanYard = GUICtrlCreateCheckbox(GetTranslated(610,49, "Remove Obstacles"), $x + 100, $y + 4, -1, -1)
$txtTip = GetTranslated(610,50, "Check this to automatically clear Yard from Trees, Trunks, etc.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 35
GUICtrlCreateIcon($pIconLib, $eIcnGembox, $x + 32, $y, 24, 24)
$chkGemsBox = GUICtrlCreateCheckbox(GetTranslated(610,51, "Remove GemBox"), $x + 100, $y + 4, -1, -1)
$txtTip = GetTranslated(610,52, "Check this to automatically clear GemBox.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 20, $y = 345
$grpLocateBuildings = GUICtrlCreateGroup(GetTranslated(610,53, "Locate Manually"), $x - 15, $y - 20, 440, 65)
$X -= 11
$y += 0
$btnLocateTownHall = GUICtrlCreateButton(GetTranslated(610,54, "Townhall"), $x, $y, 34, 34, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnTH11, 1)
$sTxtRelocate = GetTranslated(610,55, "Relocate your")
$txtTip =  $sTxtRelocate & " " & GetTranslated(610,54, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnLocateTownHall")
$x += 36
$btnLocateClanCastle = GUICtrlCreateButton(GetTranslated(610,56, "Clan Castle"), $x, $y, 34, 34, $BS_ICON)
GUICtrlSetOnEvent(-1, "btnLocateClanCastle")
GUICtrlSetImage(-1, $pIconLib, $eIcnCC, 1)
$txtTip = $sTxtRelocate & " " & GetTranslated(610,56, -1)
_GUICtrlSetTip(-1, $txtTip)
$x += 36
$x += 18
$btnLocateKingAltar = GUICtrlCreateButton(GetTranslated(610,65, "King"), $x, $y, 34, 34, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnKingBoostLocate)
$txtTip = $sTxtRelocate & " " & GetTranslated(610,66, "Barbarian King Altar")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnLocateKingAltar")
$x += 36
$btnLocateQueenAltar = GUICtrlCreateButton(GetTranslated(610,67, "Queen"), $x, $y, 34, 34, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnQueenBoostLocate)
$txtTip = $sTxtRelocate & " " & GetTranslated(610,68, "Archer Queen Altar")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnLocateQueenAltar")
$x += 36
$btnLocateWardenAltar = GUICtrlCreateButton(GetTranslated(610,69, "Grand Warden"), $x, $y, 34, 34, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnWardenBoostLocate)
$txtTip = $sTxtRelocate & " " & GetTranslated(610,70, "Grand Warden Altar")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnLocateWardenAltar")
$x += 36
$x += 18
$btnLocateLaboratory = GUICtrlCreateButton(GetTranslated(610,71, "Lab."), $x, $y, 34, 34, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnLaboratory)
$txtTip = $sTxtRelocate & " " & GetTranslated(610,72, "Laboratory")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnLab")
$x += 36
$x += 18
$btnResetBuilding = GUICtrlCreateButton(GetTranslated(610,73, "Reset."), $x, $y, 34, 34, $BS_ICON)
GUICtrlSetImage(-1, $pIconLib, $eIcnBldgX)
$txtTip = GetTranslated(610,74, "Click here to reset all building locations,") & @CRLF & GetTranslated(610,75, "when you have changed your village layout.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnResetBuilding")
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_VILLAGE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,7,"Req. && Donate"))
GUICtrlCreateTabItem("")
$hGUI_VILLAGE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,8,"Upgrade"))
GUICtrlCreateTabItem("")
$hGUI_VILLAGE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,9,"Achievements"))
Global $txtUnbreakable, $txtUnBrkMinGold,$txtUnBrkMaxGold,$txtUnBrkMinElixir, $txtUnBrkMaxElixir,$txtUnBrkMinDark, $txtUnBrkMaxDark ,$chkUnbreakable
$x = 25
$y = 45
$grpDefenseFarming = GUICtrlCreateGroup(GetTranslated(618,1, "Defense Farming"), $x - 20, $y - 20, 440, 150)
$y +=10
$chkUnbreakable = GUICtrlCreateCheckbox(GetTranslated(618,2, "Enable Unbreakable"), $x - 10, $y, -1, -1)
$TxtTip = GetTranslated(618,3, "Enable farming Defense Wins for Unbreakable achievement.")
_GUICtrlSetTip(-1, $TxtTip)
GUICtrlSetOnEvent(-1, "chkUnbreakable")
$picUnbreakable1 = GUICtrlCreateIcon($pIconLib, $eIcnGoldStar, $x + 10, $y + 51, 32, 32)
$picUnbreakable2 = GUICtrlCreateIcon($pIconLib, $eIcnGoldStar, $x + 42, $y + 36, 48, 48)
$picUnbreakable3 = GUICtrlCreateIcon($pIconLib, $eIcnGoldStar, $x + 90, $y + 51, 32, 32)
$x = 150
$lblUnbreakable1 = GUICtrlCreateLabel(GetTranslated(618,4, "Wait Time") & ":", $x - 10, $y + 3, 86, -1, $SS_RIGHT)
$txtUnbreakable = GUICtrlCreateInput("5", $x + 80, $y, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$TxtTip = GetTranslated(618,5, "Set the amount of time to stop CoC and wait for enemy attacks to gain defense wins. (1-99 minutes)")
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
$lblUnbreakable2 = GUICtrlCreateLabel(GetTranslated(618,6, "Minutes"), $x + 113, $y+3, -1, -1)
$y += 28
$lblUnBreakableFarm = GUICtrlCreateLabel(GetTranslated(618,7, "Farm Min."), $x + 25 , $y, -1, -1)
$lblUnBreakableSave = GUICtrlCreateLabel(GetTranslated(618,8, "Save Min."), $x + 115 , $y, -1, -1)
$y += 16
$txtUnBrkMinGold = GUICtrlCreateInput("50000", $x + 20, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,9, "Amount of Gold that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslated(618,10, "Set this value to amount of Gold you need for searching or upgrades."))
GUICtrlSetLimit(-1, 7)
GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 80, $y + 2, 16, 16)
$txtUnBrkMaxGold = GUICtrlCreateInput("600000", $x + 110, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,11, "Amount of Gold in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslated(618,12, "Input amount of Gold you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 7)
GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 170, $y + 2, 16, 16)
$y += 26
$txtUnBrkMinElixir = GUICtrlCreateInput("50000", $x + 20, $y, 58, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,13, "Amount of Elixir that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslated(618,14, "Set this value to amount of Elixir you need for making troops or upgrades."))
GUICtrlSetLimit(-1, 7)
GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 80, $y, 16, 16)
$txtUnBrkMaxElixir = GUICtrlCreateInput("600000", $x + 110, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,15, "Amount of Elixir in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslated(618,16, "Input amount of Elixir you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 7)
GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 170, $y, 16, 16)
$y += 24
$txtUnBrkMinDark = GUICtrlCreateInput("5000", $x + 20, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,17, "Amount of Dark Elixir that stops Defense farming, switches to normal farming if below.") & @CRLF & GetTranslated(618,18, "Set this value to amount of Dark Elixir you need for making troops or upgrades."))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 80, $y, 16, 16)
$txtUnBrkMaxDark = GUICtrlCreateInput("6000", $x + 110, $y, 58, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(618,19, "Amount of Dark Elixir in Storage Required to Enable Defense Farming.") & @CRLF & GetTranslated(618,20, "Input amount of Dark Elixir you need to attract enemy or for upgrades."))
GUICtrlSetLimit(-1, 6)
GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 170, $y, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 200
$grpUnbreakableHelp = GUICtrlCreateGroup(GetTranslated(618,21,"How to use Unbreakable Mode"), $x - 20, $y - 20, 440, 200)
$txtHelp = GetTranslated(618,22,"Unbreakable mode will help you gain defense wins and the ""Unbreakable"" achievement.") &  @CRLF & GetTranslated(618,23,"Set ""Wait Time"" to how long you want the bot to wait for defenses." ) &  @CRLF & GetTranslated(618,24,"Farm Min is how many resources the bot must have before attacking." ) &  @CRLF & GetTranslated(618,25,"Save Min is how many resources the bot must have before starting unbreakable mode." ) &  @CRLF & GetTranslated(618,26,"Click the below link for more information:" )
$lblUnbreakableHelp = GUICtrlCreateLabel($txtHelp, $x - 10, $y, 430, 125)
$lblUnbreakableLink = GUICtrlCreateLabel(GetTranslated(618,27,"More Info"), $x - 10, $y + 100, 100,20)
_GUIToolTip_AddTool($hToolTip, 0, "https://mybot.run/forums/index.php?/topic/2964-guide-how-to-use-mybot-unbreakable-mode-updated/", GUICtrlGetHandle($lblUnbreakableLink))
GUICtrlSetFont(-1, 8.5, $FW_BOLD, $GUI_FONTUNDER)
GUICtrlSetColor(-1, $COLOR_BLUE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_VILLAGE_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslated(600,10,"Notify"))
GUICtrlCreateTabItem("")
SplashStep(GetTranslated(500, 27, "Loading Attack tab..."))
$hGUI_ATTACK = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $frmBotEx)
$hGUI_ARMY = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_ATTACK)
$textBoostLeft = GetTranslated(623, 1, "Boosts left")
$sTxtClick = "Mouse Left Click To Increase" & @CRLF & "Mouse Right Click To Decrease"
$sTxtSetPerc = GetTranslated(621, 26, "Enter the No. of")
$sTxtSetPerc2 = GetTranslated(621, 27, " to make.") & @CRLF & "Or click icon with:" & @CRLF & $sTxtClick
$sTxtSetPerc3 = GetTranslated(621, 28, "Enter the No. of")
$sTxtSetSpell = GetTranslated(621, 29, "Spells to make.") & @CRLF & "Or click icon with:" & @CRLF & $sTxtClick
$sTxtNone = GetTranslated(603, 0, "None")
$hGUI_ARMY_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_ARMY_TAB_ITEM1 = GUICtrlCreateTabItem("Train ReVamp")
Local $xStart = 0, $yStart = 0
Local $x = 10
Local $y = 25
$grpTrainTroops = GUICtrlCreateGroup(GetTranslated(1000, 1, "Train Troops"), $x, $y, 418, 145)
Local $x = 30, $y = 50
$icnBarb = GUICtrlCreateIcon($pIconLib, $eIcnBarbarian, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumBarb = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTxtBarbarians & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnGiant = GUICtrlCreateIcon($pIconLib, $eIcnGiant, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumGiant = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtGiants & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnWall = GUICtrlCreateIcon($pIconLib, $eIcnWallBreaker, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumWall = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtWallBreakers & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnWiza = GUICtrlCreateIcon($pIconLib, $eIcnWizard, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumWiza = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtWizards & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnDrag = GUICtrlCreateIcon($pIconLib, $eIcnDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumDrag = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtDragons & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnBabyD = GUICtrlCreateIcon($pIconLib, $eIcnBabyDragon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumBabyD = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtBabyDragons & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 45
$icnMini = GUICtrlCreateIcon($pIconLib, $eIcnMinion, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumMini = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtMinions & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnValk = GUICtrlCreateIcon($pIconLib, $eIcnValkyrie, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumValk = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtValkyries & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnWitc = GUICtrlCreateIcon($pIconLib, $eIcnWitch, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumWitc = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtWitches & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnBowl = GUICtrlCreateIcon($pIconLib, $eIcnBowler, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumBowl = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtBowlers & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x = 30
$y += 60
$icnArch = GUICtrlCreateIcon($pIconLib, $eIcnArcher, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumArch = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTxtArchers & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnGobl = GUICtrlCreateIcon($pIconLib, $eIcnGoblin, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumGobl = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc & " " & $sTxtGoblins & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnBall = GUICtrlCreateIcon($pIconLib, $eIcnBalloon, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumBall = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtBalloons & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnHeal = GUICtrlCreateIcon($pIconLib, $eIcnHealer, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumHeal = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtHealers & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnPekk = GUICtrlCreateIcon($pIconLib, $eIcnPekka, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumPekk = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtPekkas & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnMine = GUICtrlCreateIcon($pIconLib, $eIcnMiner, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumMine = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtMiners & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 45
$icnHogs = GUICtrlCreateIcon($pIconLib, $eIcnHogRider, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumHogs = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtHogRiders & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnGole = GUICtrlCreateIcon($pIconLib, $eIcnGolem, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumGole = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtGolems & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
$icnLava = GUICtrlCreateIcon($pIconLib, $eIcnLavaHound, $x, $y - 5, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumLava = GUICtrlCreateInput("0", $x + 1, $y + 29, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtLavaHounds & " " & $sTxtSetPerc2)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCount")
$x += 38
GUICtrlCreateGroup("", $x, $y - 11, 38, 62)
$LblRemovecamp = GUICtrlCreateLabel("Reset", $x + 1, $y + 29, -1, 15, $SS_CENTER)
$txtTipRemove = "Use this to reset all army"
_GUICtrlSetTip(-1, $txtTipRemove)
GUICtrlSetFont(-1, 9, $FW_BOLD, Default, "Arial", $CLEARTYPE_QUALITY)
GUICtrlSetColor(-1, $COLOR_BLACK)
$icnRemovecamp = GUICtrlCreateIcon(@ScriptDir & "\images\Resources\Reset\ResetIcon.ico",-1, $x + 6, $y - 3, 26, 26)
_GUICtrlSetTip(-1, $txtTipRemove)
GUICtrlSetOnEvent(-1, "Removecamp")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10
Local $y = 170
$grpBrewSpells = GUICtrlCreateGroup(GetTranslated(1000, 2, "Brew Spells"), $x, $y, 418, 75)
$x += 20
$y += 5
$lblLightningIcon = GUICtrlCreateIcon($pIconLib, $eIcnLightSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumLightningSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtLiSpell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
$x += 38
$lblHealIcon = GUICtrlCreateIcon($pIconLib, $eIcnHealSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumHealSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtHeSpell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
$x += 38
$lblRageIcon = GUICtrlCreateIcon($pIconLib, $eIcnRageSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumRageSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtRaSpell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
$x += 38
$lblJumpSpellIcon = GUICtrlCreateIcon($pIconLib, $eIcnJumpSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumJumpSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtJuSPell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
$x += 38
$lblFreezeIcon = GUICtrlCreateIcon($pIconLib, $eIcnFreezeSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumFreezeSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtFrSpell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
$x += 38
$lblCloneIcon = GUICtrlCreateIcon($pIconLib, $eIcnCloneSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumCloneSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtClSpell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
$x += 45
$lblPoisonIcon = GUICtrlCreateIcon($pIconLib, $eIcnPoisonSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumPoisonSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtPoSpell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
$x += 38
$lblEarthquakeIcon = GUICtrlCreateIcon($pIconLib, $eIcnEarthquakeSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumEarthSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtEaSpell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
$x += 38
$lblHasteIcon = GUICtrlCreateIcon($pIconLib, $eIcnHasteSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumHasteSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtHaSpell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
$x += 38
$lblSkeletonIcon = GUICtrlCreateIcon($pIconLib, $eIcnSkeletonSpell, $x, $y + 10, 32, 32)
_GUICtrlSetTip(-1, $sTxtClick)
$txtNumSkeletonSpell = GUICtrlCreateInput("0", $x + 1, $y + 44, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $sTxtSetPerc3 & " " & $sTxtSkSpell & " " & $sTxtSetSpell)
GUICtrlSetLimit(-1, 2)
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10
Local $y = 245
$grpBrewSpells = GUICtrlCreateGroup(GetTranslated(1000, 3, "Train Options | Quick Train"), $x, $y, 418, 80)
$hRadio_Army1 = GUICtrlCreateRadio("Army 1", $x + 135, $y + 20, 50, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_CHECKED)
$hChk_UseQTrain = GUICtrlCreateCheckbox("Use Quick Train > ", $x + 15, $y + 40, 115, 15)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkUseQTrain")
$hRadio_Army2 = GUICtrlCreateRadio("Army 2", $x + 135, $y + 40, 50, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$hRadio_Army3 = GUICtrlCreateRadio("Army 3", $x + 135, $y + 60, 50, 15)
GUICtrlSetState(-1, $GUI_DISABLE)
$x += 280
$y += 20
GUICtrlCreateIcon($pIconLib, $eIcnBldgTarget, $x - 10, $y - 8, 24, 24)
$lblFullTroop = GUICtrlCreateLabel(GetTranslated(621, 20, "'Full' Camps"), $x + 16, $y, 55, 17)
$lblFullTroop2 = GUICtrlCreateLabel(ChrW(8805), $x + 75, $y, -1, 17)
$txtFullTroop = GUICtrlCreateInput("100", $x + 83, $y - 3, 30, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "SetComboTroopComp")
_GUICtrlSetTip(-1, GetTranslated(621, 21, "Army camps are 'Full' when reaching this %, then start attack."))
GUICtrlSetLimit(-1, 3)
$lblFullTroop3 = GUICtrlCreateLabel("%", $x + 114, $y, -1, 17)
$y += 20
$lblTotalSpell = GUICtrlCreateLabel(GetTranslated(622, 2, "Spell Capacity") & " :", $x - 15, $y + 10, -1, -1, $SS_RIGHT)
$txtTotalCountSpell = GUICtrlCreateCombo("", $x + 80, $y + 5, 35, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(622, 3, "Enter the No. of Spells Capacity. Set to ZERO if you don't want any Spells"))
GUICtrlSetBkColor(-1, $COLOR_MONEYGREEN)
GUICtrlSetData(-1, "0|2|4|6|7|8|9|10|11", "0")
GUICtrlSetOnEvent(-1, "lblTotalCountSpell")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10
Local $y = 330
$chkTotalCampForced = GUICtrlCreateCheckbox(GetTranslated(636, 46, "Force Total Army Camp") & ":", $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkTotalCampForced")
_GUICtrlSetTip(-1, GetTranslated(636, 47, "If not detected set army camp values (instead ask)"))
$txtTotalCampForced = GUICtrlCreateInput("200", $x + 135, $y + 3, 30, 17, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetOnEvent(-1, "SetComboTroopComp")
GUICtrlSetLimit(-1, 3)
$chkForceBrewBeforeAttack = GUICtrlCreateCheckbox("Force Brew Spells", $x + 175, $y, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$caltotaltroops = GUICtrlCreateProgress($x, $y + 22, 420, 10)
$lbltotalprogress = GUICtrlCreateLabel("", $x, $y + 22, 420, 10)
GUICtrlSetBkColor(-1, $COLOR_RED)
GUICtrlSetState(-1, BitOR($GUI_DISABLE, $GUI_HIDE))
$x += 40
$lblTotalTroops = GUICtrlCreateLabel(GetTranslated(621, 15, "Total"), $x + 300, $y + 7, -1, -1, $SS_RIGHT)
$lblTotalCount = GUICtrlCreateLabel(200, $x + 335, $y + 5, 30, 15, $SS_CENTER)
_GUICtrlSetTip(-1, GetTranslated(621, 16, "The total Units of Troops should equal Total Army Camps."))
GUICtrlSetBkColor(-1, $COLOR_MONEYGREEN)
$lblPercentTotal = GUICtrlCreateLabel("x", $x + 367, $y + 7, -1, -1)
$lblBarbarians = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblPercentBarbarians = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblArchers = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblPercentArchers = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblGoblins = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblPercentGoblins = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblGiants = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesGiants = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblWallBreakers = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesWallBreakers = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblBalloons = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesBalloons = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblWizards = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesWizards = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblHealers = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesHealers = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblDragons = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesDragons = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblPekka = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesPekka = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblBabyDragons = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesBabyDragons = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblMine = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesMine = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblMinion = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesMinions = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblHogRiders = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesHogRiders = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblValkyries = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesValkyries = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblGolems = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesGolems = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblWitches = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesWitches = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblLavaHounds = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesLavaHounds = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblBowlers = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesBowlers = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblLightningSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesLightS = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblHealSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesHealS = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblRageSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesRageS = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblJumpSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesJumpS = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblFreezeSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblFreezeS = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblCloneSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblCloneS = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblPoisonSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesPoisonS = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblEarthquakeSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesEarthquakeS = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblHasteSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesHasteS = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblSkeletonSpell = GUICtrlCreateLabel("", $x, $y, 0, 0)
$lblTimesSkeletonS = GUICtrlCreateLabel("", $x, $y, 0, 0)
GUICtrlCreateTabItem("")
$hGUI_ARMY_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600, 22, "Boost"))
Global $chkBoostBarracksHours
Global $chkBoostBarracksHours0, $chkBoostBarracksHours1, $chkBoostBarracksHours2, $chkBoostBarracksHours3, $chkBoostBarracksHours4, $chkBoostBarracksHours5
Global $chkBoostBarracksHours6, $chkBoostBarracksHours7, $chkBoostBarracksHours8, $chkBoostBarracksHours9, $chkBoostBarracksHours10, $chkBoostBarracksHours11
Global $chkBoostBarracksHours12, $chkBoostBarracksHours13, $chkBoostBarracksHours14, $chkBoostBarracksHours15, $chkBoostBarracksHours16, $chkBoostBarracksHours17
Global $chkBoostBarracksHours18, $chkBoostBarracksHours19, $chkBoostBarracksHours20, $chkBoostBarracksHours21, $chkBoostBarracksHours22, $chkBoostBarracksHours23
Global $lbBoostBarracksHours1, $lbBoostBarracksHours2, $lbBoostBarracksHours3, $lbBoostBarracksHours4, $lbBoostBarracksHours5, $lbBoostBarracksHours6
Global $lbBoostBarracksHours7, $lbBoostBarracksHours8, $lbBoostBarracksHours9, $lbBoostBarracksHours10, $lbBoostBarracksHours11, $lbBoostBarracksHours12
Global $lbBoostBarracksHoursED, $lbBoostBarracksHoursPM, $lbBoostBarracksHoursAM, $chkBoostBarracksHoursE1, $chkBoostBarracksHoursE2
Global $tabBoost, $tabBoostOptions, $grpBoosterOptions
Global $lblQuantBoostBarracks, $cmbQuantBoostBarracks, $cmbBoostBarracks
Global $lblQuantBoostDarkBarracks, $cmbQuantBoostDarkBarracks, $cmbBoostDarkBarracks
Global $lblBoostSpellFactory, $cmbBoostSpellFactory, $lblBoostDarkSpellFactory, $cmbBoostDarkSpellFactory
Global $lblBoostBarbarianKing, $cmbBoostBarbarianKing, $lblBoostArcherQueen, $cmbBoostArcherQueen
Global $lblBoostWarden, $cmbBoostWarden
Local $x = $xStart + 25, $y = $yStart + 45
$grpBoosterBarracks = GUICtrlCreateGroup(GetTranslated(623, 2, "Boost Barracks"), $x - 20, $y - 20, 430, 60)
GUICtrlCreateIcon($pIconLib, $eIcnBarrackBoost, $x - 10, $y + 5, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnDarkBarrackBoost, $x + 19, $y + 5, 24, 24)
$lblBoostBarracks = GUICtrlCreateLabel(GetTranslated(623, 5, "Barracks") & " " & $textBoostLeft, $x + 20 + 29, $y + 4 + 7, -1, -1)
$txtTip = GetTranslated(623, 6, "Use this to boost your Barracks with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $txtTip)
$cmbBoostBarracks = GUICtrlCreateCombo("", $x + 140 + 45, $y + 7, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = "How Many Times To Boost? Use with caution!"
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $txtTip)
$lblQuantBoostBarracks = GUICtrlCreateLabel(GetTranslated(623, 3, "Num. Of Barracks to Boost"), $x + 20, $y + 4, -1, -1)
$txtTip = GetTranslated(623, 4, "How many Barracks to boost with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbQuantBoostBarracks = GUICtrlCreateCombo("", $x + 160, $y, 37, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4", "0")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$icDarkBarrack = GUICtrlCreateIcon($pIconLib, $eIcnDarkBarrackBoost, $x + 207, $y - 2, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$lblQuantBoostDarkBarracks = GUICtrlCreateLabel("Dark Barracks to Boost", $x + 237, $y + 4, -1, -1)
$txtTip = "How many Dark Barracks to boost with GEMS! Use with caution!"
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbQuantBoostDarkBarracks = GUICtrlCreateCombo("", $x + 365, $y, 37, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2", "0")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$lblBoostDarkBarracks = GUICtrlCreateLabel("Dark Barracks" & " " & $textBoostLeft, $x + 237, $y + 27, -1, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$txtTip = "Use this to boost your Dark Barracks with GEMS! Use with caution!"
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbBoostDarkBarracks = GUICtrlCreateCombo("", $x + 365, $y + 23, 37, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 65
$grpBoosterSpellFactories = GUICtrlCreateGroup(GetTranslated(623, 7, "Boost Spell Factories"), $x - 20, $y - 20, 430, 50)
GUICtrlCreateIcon($pIconLib, $eIcnSpellFactoryBoost, $x - 10, $y - 2, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnDarkSpellBoost, $x + 19, $y - 2, 24, 24)
$lblBoostSpellFactory = GUICtrlCreateLabel(GetTranslated(623, 8, "Spell Factory") & " " & $textBoostLeft, $x + 20 + 29, $y + 4, -1, -1)
$txtTip = GetTranslated(623, 9, "Use this to boost your Spell Factory with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $txtTip)
$cmbBoostSpellFactory = GUICtrlCreateCombo("", $x + 185, $y, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $txtTip)
$y += 25
GUICtrlCreateIcon($pIconLib, $eIcnDarkSpellBoost, $x - 10, $y - 2, 24, 24)
GUICtrlSetState(-1, $GUI_HIDE)
$lblBoostDarkSpellFactory = GUICtrlCreateLabel(GetTranslated(623, 10, "Dark Spell Factory") & " " & $textBoostLeft, $x + 20, $y + 4, -1, -1)
$txtTip = GetTranslated(623, 11, "Use this to boost your Dark Spell Factory with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_HIDE)
$cmbBoostDarkSpellFactory = GUICtrlCreateCombo("", $x + 200, $y, 30, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 30
$grpBoosterHeroes = GUICtrlCreateGroup(GetTranslated(623, 12, "Boost Heroes"), $x - 20, $y - 20, 430, 95)
GUICtrlCreateIcon($pIconLib, $eIcnKingBoost, $x - 10, $y - 2, 24, 24)
$lblBoostBarbarianKing = GUICtrlCreateLabel(GetTranslated(623, 13, "Barbarian King") & " " & $textBoostLeft, $x + 20, $y + 4, -1, -1)
$txtTip = GetTranslated(623, 14, "Use this to boost your Barbarian King with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $txtTip)
$cmbBoostBarbarianKing = GUICtrlCreateCombo("", $x + 185, $y, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeKing")
$y += 25
GUICtrlCreateIcon($pIconLib, $eIcnQueenBoost, $x - 10, $y - 2, 24, 24)
$lblBoostArcherQueen = GUICtrlCreateLabel(GetTranslated(623, 15, "Archer Queen") & " " & $textBoostLeft, $x + 20, $y + 4, -1, -1)
$txtTip = GetTranslated(623, 16, "Use this to boost your Archer Queen with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $txtTip)
$cmbBoostArcherQueen = GUICtrlCreateCombo("", $x + 185, $y, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeQueen")
$y += 25
GUICtrlCreateIcon($pIconLib, $eIcnWardenBoost, $x - 10, $y - 2, 24, 24)
$lblBoostWarden = GUICtrlCreateLabel(GetTranslated(623, 17, "Grand Warden") & " " & $textBoostLeft, $x + 20, $y + 4, -1, -1)
$txtTip = GetTranslated(623, 18, "Use this to boost your Grand Warden with GEMS! Use with caution!")
_GUICtrlSetTip(-1, $txtTip)
$cmbBoostWarden = GUICtrlCreateCombo("", $x + 185, $y, 40, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0|1|2|3|4|5|6|7|8|9|10|11|12", "0")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkUpgradeWarden")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 50
$grpBoosterSchedule = GUICtrlCreateGroup(GetTranslated(623, 19, "Boost Schedule"), $x - 20, $y - 20, 430, 70)
$lbBoostBarracksHours1 = GUICtrlCreateLabel(" 0", $x + 30, $y)
$lbBoostBarracksHours2 = GUICtrlCreateLabel(" 1", $x + 45, $y)
$lbBoostBarracksHours3 = GUICtrlCreateLabel(" 2", $x + 60, $y)
$lbBoostBarracksHours4 = GUICtrlCreateLabel(" 3", $x + 75, $y)
$lbBoostBarracksHours5 = GUICtrlCreateLabel(" 4", $x + 90, $y)
$lbBoostBarracksHours6 = GUICtrlCreateLabel(" 5", $x + 105, $y)
$lbBoostBarracksHours7 = GUICtrlCreateLabel(" 6", $x + 120, $y)
$lbBoostBarracksHours8 = GUICtrlCreateLabel(" 7", $x + 135, $y)
$lbBoostBarracksHours9 = GUICtrlCreateLabel(" 8", $x + 150, $y)
$lbBoostBarracksHours10 = GUICtrlCreateLabel(" 9", $x + 165, $y)
$lbBoostBarracksHours11 = GUICtrlCreateLabel("10", $x + 180, $y)
$lbBoostBarracksHours12 = GUICtrlCreateLabel("11", $x + 195, $y)
$lbBoostBarracksHoursED = GUICtrlCreateLabel("X", $x + 213, $y + 2, 11, 11)
$y += 15
$chkBoostBarracksHours0 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours1 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours2 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours3 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours4 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours5 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours6 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours7 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours8 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours9 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours10 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours11 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$txtTip = GetTranslated(603, 2, "This button will clear or set the entire row of boxes")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkBoostBarracksHoursE1")
$lbBoostBarracksHoursAM = GUICtrlCreateLabel(GetTranslated(603, 3, "AM"), $x + 5, $y)
$y += 15
$chkBoostBarracksHours12 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours13 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours14 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours15 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours16 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours17 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours18 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours19 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours20 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours21 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours22 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHours23 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
$chkBoostBarracksHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y + 1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$txtTip = GetTranslated(603, 2, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkBoostBarracksHoursE2")
$lbBoostBarracksHoursPM = GUICtrlCreateLabel(GetTranslated(603, 4, "PM"), $x + 5, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_ARMY_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(641, 1, "Options"))
$x = $xStart + 25
$y = $yStart + 45
$grpCloseWaitTrain = GUICtrlCreateGroup(GetTranslated(641, 2, "Training Idle Time"), $x - 20, $y - 20, 151, 266)
$chkCloseWaitEnable = GUICtrlCreateCheckbox(GetTranslated(641, 3, "Close While Training"), $x - 12, $y, 140, -1)
$txtTip = GetTranslated(641, 4, "Option will exit CoC game for time required to complete TROOP training when SHIELD IS ACTIVE") & @CRLF &  GetTranslated(641, 5, "Close for Spell creation will be enabled when 'Wait for Spells' is selected on Search tabs") & @CRLF &  GetTranslated(641, 6, "Close for Hero healing will be enabled when 'Wait for Heroes' is enabled on Search tabs")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkCloseWaitEnable")
$y += 28
$chkCloseWaitTrain = GUICtrlCreateCheckbox(GetTranslated(641, 7, "Without Shield"), $x + 18, $y + 1, 110, -1)
$txtTip = GetTranslated(641, 8, "Option will ALWAYS close CoC for idle training time and when NO SHIELD IS ACTIVE!") & @CRLF &  GetTranslated(641, 9, "Note - You can be attacked and lose trophies when this option is enabled!")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkCloseWaitTrain")
$picCloseWaitTrain = GUICtrlCreateIcon($pIconLib, $eIcnNoShield, $x - 13, $y, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y += 28
$btnCloseWaitStop = GUICtrlCreateCheckbox(GetTranslated(641, 13, "Close Emulator"), $x + 18, $y + 1, 110, -1)
$txtTip = GetTranslated(641, 14, "Option will close Android Emulator completely when selected") & @CRLF &  GetTranslated(641, 15, "Adding this option may increase offline time slightly due to variable times required for startup")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnCloseWaitStop")
$picCloseWaitStop = GUICtrlCreateIcon($pIconLib, $eIcnRecycle, $x - 13, $y + 13, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y += 28
$btnCloseWaitStopRandom = GUICtrlCreateCheckbox(GetTranslated(641, 10, "Random Close"), $x + 18, $y + 1, 110, -1)
$txtTip = GetTranslated(641, 11, "Option will Randomly choose between time out, close CoC, or Close emulator when selected") & @CRLF &  GetTranslated(641, 15, "Adding this option may increase offline time slightly due to variable times required for startup")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnCloseWaitStopRandom")
$y += 28
$btnCloseWaitExact = GUICtrlCreateRadio(GetTranslated(641, 16, "Exact Time"), $x + 18, $y + 1, 110, -1)
$txtTip = GetTranslated(641, 17, "Select to wait exact time required for troops to complete training")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "btnCloseWaitRandom")
$picCloseWaitExact = GUICtrlCreateIcon($pIconLib, $eIcnHourGlass, $x - 13, $y + 13, 24, 24)
$txtTip = GetTranslated(641, 18, "Select how much time to wait when feature enables")
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$btnCloseWaitRandom = GUICtrlCreateRadio(GetTranslated(641, 19, "Random Time"), $x + 18, $y + 1, 110, -1)
$txtTip = GetTranslated(641, 20, "Select to ADD a random extra wait time like human who forgets to clash")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "btnCloseWaitRandom")
$y += 28
$cmbCloseWaitRdmPercent = GUICtrlCreateCombo("", $x + 36, $y, 40, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(641, 21, "Enter maximum percentage of additional time to be used creating random wait times,") & @CRLF &  GetTranslated(641, 22, "Bot will compute a random wait time between exact time needed, and") & @CRLF &  GetTranslated(641, 23, "maximum random percent entered to appear more human like")
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15", "10")
_GUICtrlSetTip(-1, $txtTip)
$lblCloseWaitRdmPercent = GUICtrlCreateLabel("%", $x + 84, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$y += 28
$lblCloseWaitingTroops = GUICtrlCreateLabel("Minimum Time To Close : ", $x - 12, $y, -1, -1)
$txtTip = "Will be close CoC If train time troops >= (Minimum time required to close)" & @CRLF &  "Just stay in the main screen if train time troops < (Minimum time required to close)"
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkCloseWaitEnable")
$y += 22
$lblSymbolWaiting = GUICtrlCreateLabel(">", $x + 26, $y + 3, -1, -1)
$txtTip = "Enter number Minimum time to close in minutes for close CoC which you want, Default Is (2)"
_GUICtrlSetTip(-1, $txtTip)
$cmbMinimumTimeClose = GUICtrlCreateCombo("", $x + 36, $y, 40, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "2|3|4|5|6|7|8|9|10", "2")
_GUICtrlSetTip(-1, $txtTip)
$lblWaitingInMinutes = GUICtrlCreateLabel("Min", $x + 84, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 53
$grpTiming = GUICtrlCreateGroup(GetTranslated(636, 30, "Train Click Timing"), $x - 20, $y - 20, 151, 60)
$lbltxtTrainITDelay = GUICtrlCreateLabel(GetTranslated(636, 32, "delay"), $x - 10, $y, 37, 30)
$txtTip = GetTranslated(636, 33, "Increase the delay if your PC is slow or to create human like training click speed")
_GUICtrlSetTip(-1, $txtTip)
$lbltxtTrainITDelayTime = GUICtrlCreateLabel("40 ms", $x - 10, $y + 15, 37, 30)
_GUICtrlSetTip(-1, $txtTip)
$sldTrainITDelay = GUICtrlCreateSlider($x + 30, $y, 90, 25, BitOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, GetTranslated(636, 33, -1))
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-100, 100)
GUICtrlSetLimit(-1, 500, 1)
GUICtrlSetData(-1, 40)
GUICtrlSetOnEvent(-1, "sldTrainITDelay")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 182
$y = $yStart + 45
$grpTrainOrder = GUICtrlCreateGroup(GetTranslated(641, 25, "Training Order"), $x - 20, $y - 20, 271, 335)
$chkTroopOrder = GUICtrlCreateCheckbox(GetTranslated(641, 26, "Custom Order"), $x - 5, $y, -1, -1)
$txtTip = GetTranslated(641, 27, "Enable to select a custom troop training order") & @CRLF &  GetTranslated(641, 28, "Changing train order can be useful with CSV scripted attack armies!")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkTroopOrder2")
Local $sComboData = ""
Local $aTroopOrderList[] = ["", "Barbarians", "Archers", "Giants", "Goblins", "Wall Breakers", "Balloons", "Wizards", "Healers", "Dragons", "Pekkas", "Baby Dragons", "Miners", "Minions", "Hog Riders", "Valkyries", "Golems", "Witches", "Lava Hounds", "Bowlers"]
For $j = 0 To UBound($aTroopOrderList) - 1
$sComboData &= $aTroopOrderList[$j] & "|"
Next
Local $txtTroopOrder = GetTranslated(641, 29, "Enter sequence order for training of troop #")
$y += 23
For $z = 0 To UBound($aTroopOrderList) - 2
If $z < 12 Then
$lblTroopOrder[$z] = GUICtrlCreateLabel($z + 1 & ":", $x - 16, $y + 2, -1, 18)
$cmbTroopOrder[$z] = GUICtrlCreateCombo("", $x, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUITrainOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtTroopOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$ImgTroopOrder[$z] = GUICtrlCreateIcon($pIconLib, $eIcnOptions, $x + 96, $y + 1, 18, 18)
$y += 22
Else
If $z = 12 Then
$x += 128
$y = $yStart + 45 + 23
EndIf
$lblTroopOrder[$z] = GUICtrlCreateLabel($z + 1 & ":", $x - 13, $y + 2, -1, 18)
$cmbTroopOrder[$z] = GUICtrlCreateCombo("", $x + 4, $y, 94, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUITrainOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtTroopOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
$ImgTroopOrder[$z] = GUICtrlCreateIcon($pIconLib, $eIcnOptions, $x + 100, $y + 1, 18, 18)
$y += 22
EndIf
Next
$x = $xStart + 182
$y = $yStart + 45 + 291
$btnTroopOrderSet = GUICtrlCreateButton(GetTranslated(641, 30, "Apply New Order"), $x, $y, 222, 20)
$txtTip = GetTranslated(641, 31, "Push button when finished selecting custom troop training order") & @CRLF &  GetTranslated(641, 32, "Icon changes color based on status: Red= Not Set, Green = Order Set")
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnTroopOrderSet")
$ImgTroopOrderSet = GUICtrlCreateIcon($pIconLib, $eIcnSilverStar, $x + 226, $y + 2, 18, 18)
$x += 128
$y = $yStart + 45
$chkDarkTroopOrder = GUICtrlCreateCheckbox(GetTranslated(641, 33, "Custom Dark Order"), $x - 5, $y, -1, -1)
$txtTip = GetTranslated(641, 34, "Enable to select a custom dark troop training order") & @CRLF &  GetTranslated(641, 28, "Changing train order can be useful with CSV scripted attack armies!")
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDarkTroopOrder2")
GUICtrlSetState(-1, $GUI_HIDE)
Local $sComboData = ""
Local $aDarkTroopOrderList[8] = ["", "Minions", "Hog Riders", "Valkyries", "Golems", "Witches", "Lava Hounds", "Bowlers"]
For $j = 0 To UBound($aDarkTroopOrderList) - 1
$sComboData &= $aDarkTroopOrderList[$j] & "|"
Next
$y += 23
For $z = 0 To UBound($aDarkTroopOrderList) - 2
$cmbDarkTroopOrder[$z] = GUICtrlCreateCombo("", $x + 4, $y, 92, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetOnEvent(-1, "GUITrainDarkOrder")
GUICtrlSetData(-1, $sComboData, "")
_GUICtrlSetTip(-1, $txtTroopOrder & $z + 1)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$ImgDarkTroopOrder[$z] = GUICtrlCreateIcon($pIconLib, $eIcnOptions, $x + 98, $y + 1, 18, 18)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 22
Next
$y = $yStart + 45 + 184
$btnDarkTroopOrderSet = GUICtrlCreateButton(GetTranslated(641, 30, "Apply New Order"), $x + 2, $y, 92, 20)
$txtTip = GetTranslated(641, 31, "Push button when finished selecting custom troop training order") & @CRLF &  GetTranslated(641, 32, "Icon changes color based on status: Red= Not Set, Green = Order Set")
GUICtrlSetState(-1, BitOR($GUI_UNCHECKED, $GUI_DISABLE))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "btnDarkTroopOrderSet")
GUICtrlSetState(-1, $GUI_HIDE)
$ImgDarkTroopOrderSet = GUICtrlCreateIcon($pIconLib, $eIcnSilverStar, $x + 98, $y + 1, 18, 18)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_SEARCH = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_ATTACK)
Local $x = 82
$DBcheck = GUICtrlCreateCheckbox("", $x, 6, 13, 13)
GUICtrlSetState(-1,$GUI_CHECKED)
GUICtrlSetOnEvent(-1, "DBcheck")
$ABcheck = GUICtrlCreateCheckbox("", $x + 100, 4, 13, 13)
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "Abcheck")
$TScheck = GUICtrlCreateCheckbox("", $x + 190, 4, 13, 13)
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "TScheck")
$Bullycheck = GUICtrlCreateCheckbox("", $x + 260, 4, 13, 13)
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "Bullycheck")
$hGUI_DEADBASE = GUICreate("", $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_SEARCH)
$hGUI_DEADBASE_ATTACK_STANDARD = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_DEADBASE)
Local $x = 25, $y = 20
$grpDeployDB = GUICtrlCreateGroup(GetTranslated(608,1,"Deploy"), $x - 20, $y - 20, 270, 306)
$lblDBmode = GUICtrlCreateLabel(GetTranslated(608,2,"Troop Drop Order"),$x, $y, 143,18,$SS_LEFT)
$y += 15
$cmbStandardAlgorithmDB = GUICtrlCreateCombo("", $x, $y, 150, Default, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(608,25,"Default(All Troops)")&"|Barch/BAM/BAG|GiBarch", GetTranslated(608,25, -1))
_GUICtrlSetTip(-1, GetTranslated(608,33,"Select a preset troop drop order.")&@CRLF&GetTranslated(608,34,"Each option deploys troops in a different order and in different waves")&@CRLF&GetTranslated(608,35,"Only the troops selected in the ""Only drop these troops"" option will be dropped"))
$y += 25
$lblDeployDB = GUICtrlCreateLabel(GetTranslated(608,3, "Attack on")&":", $x, $y + 5, -1, -1)
$cmbDeployDB = GUICtrlCreateCombo("", $x + 55, $y, 120, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(608,4, "Attack on a single side, penetrates through base") & @CRLF & GetTranslated(608,5, "Attack on two sides, penetrates through base") & @CRLF & GetTranslated(608,6, "Attack on three sides, gets outer and some inside of base"), GetTranslated(608,7,"Select the No. of sides to attack on."))
GUICtrlSetData(-1, GetTranslated(608,8, "one side") & "|" & GetTranslated(608,9, "two sides") & "|" & GetTranslated(608,10, "three sides") &"|" & GetTranslated(608,11,"all sides equally" ), GetTranslated(608,11, -1))
$y += 25
$lblUnitDelayDB = GUICtrlCreateLabel(GetTranslated(608,12, "Delay Unit") & ":", $x, $y + 5, -1, -1)
$txtTip = GetTranslated(608,13, "This delays the deployment of troops, 1 (fast) = like a Bot, 10 (slow) = Like a Human.") & @CRLF & GetTranslated(608,14, "Random will make bot more varied and closer to a person.")
_GUICtrlSetTip(-1, $txtTip)
$cmbUnitDelayDB = GUICtrlCreateCombo("", $x + 55, $y, 36, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
$lblWaveDelayDB = GUICtrlCreateLabel(GetTranslated(608,15, "Wave") & ":", $x + 100, $y + 5, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbWaveDelayDB = GUICtrlCreateCombo("", $x + 140, $y, 36, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
$y += 22
$chkRandomSpeedAtkDB = GUICtrlCreateCheckbox(GetTranslated(608,16, "Randomize delay for Units && Waves"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkRandomSpeedAtkDB")
$y +=22
$chkSmartAttackRedAreaDB = GUICtrlCreateCheckbox(GetTranslated(608,17, "Use Smart Attack: Near Red Line."), $x, $y, -1, -1)
$txtTip = GetTranslated(608,18, "Use Smart Attack to detect the outer 'Red Line' of the village to attack. And drop your troops close to it.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkSmartAttackRedAreaDB")
$y += 22
$lblSmartDeployDB = GUICtrlCreateLabel(GetTranslated(608,19, "Drop Type") & ":", $x, $y + 5, -1, -1)
$txtTip = GetTranslated(608,20, "Select the Deploy Mode for the waves of Troops.") & @CRLF & GetTranslated(608,21, "Type 1: Drop a single wave of troops on each side then switch troops, OR") & @CRLF & GetTranslated(608,22, "Type 2: Drop a full wave of all troops (e.g. giants, barbs and archers) on each side then switch sides.")
_GUICtrlSetTip(-1, $txtTip)
$cmbSmartDeployDB = GUICtrlCreateCombo("", $x + 55, $y, 120, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(608,23, "Sides, then Troops") & "|" & GetTranslated(608,24, "Troops, then Sides") , GetTranslated(608,23, -1))
_GUICtrlSetTip(-1, $txtTip)
$y += 26
$chkAttackNearGoldMineDB = GUICtrlCreateCheckbox("", $x + 20, $y, 17, 17)
$txtTip = GetTranslated(608,26, "Drop troops near Gold Mines")
_GUICtrlSetTip(-1, $txtTip)
$picAttackNearGoldMineDB = GUICtrlCreateIcon($pIconLib, $eIcnMine, $x + 40 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$x += 75
$chkAttackNearElixirCollectorDB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(608,27, "Drop troops near Elixir Collectors")
_GUICtrlSetTip(-1, $txtTip)
$picAttackNearElixirCollectorDB = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$x += 55
$chkAttackNearDarkElixirDrillDB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(608,28, "Drop troops near Dark Elixir Drills")
_GUICtrlSetTip(-1, $txtTip)
$picAttackNearDarkElixirDrillDB = GUICtrlCreateIcon($pIconLib, $eIcnDrill, $x + 20 , $y - 3, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Global $cmbScriptNameDB, $lblNotesScriptAB
$hGUI_DEADBASE_ATTACK_SCRIPTED = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_DEADBASE)
Local $x = 25, $y = 20
$grpAttackCSVDB = GUICtrlCreateGroup(GetTranslated(607,1,"Deploy"), $x - 20, $y - 20, 270, 306)
$chkmakeIMGCSVDB = GUICtrlCreateCheckbox(GetTranslated(607,2, "IMG"), $x + 150, $y, -1, -1)
$txtTip = GetTranslated(607,3, "Make IMG with extra info in Profile -> Temp Folder")
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $txtTip)
$y +=15
$cmbScriptNameDB=GUICtrlCreateCombo("", $x, $y, 185, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(607,4, "Choose the script; You can edit/add new scripts located in folder: 'CSV/Attack'")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptNameDB")
$picreloadScriptsDB = GUICtrlCreateIcon($pIconLib, $eIcnReload, $x + 192, $y + 2, 16, 16)
$txtTip =  GetTranslated(607,5, "Reload Script Files")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, 'UpdateComboScriptNameDB')
$y +=25
$lblNotesScriptDB =  GUICtrlCreateLabel("", $x, $y + 5, 180, 118)
PopulateComboScriptsFilesDB()
$picreloadScripts = GUICtrlCreateIcon($pIconLib, $eIcnEdit, $x + 192, $y + 2, 16, 16)
$txtTip =  GetTranslated(607,6, "Show/Edit current Attack Script")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "EditScriptDB")
$y +=25
$picnewScriptsDB = GUICtrlCreateIcon($pIconLib, $eIcnAddcvs, $x + 192, $y + 2, 16, 16)
$txtTip =  GetTranslated(607,7, "Create a new Attack Script")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "NewScriptDB")
$y +=25
$picduplicateScriptsDB = GUICtrlCreateIcon($pIconLib, $eIcnCopy, $x + 192, $y + 2, 16, 16)
$txtTip =  GetTranslated(607,8, "Copy current Attack Script to a new name")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "DuplicateScriptDB")
GUICtrlCreateGroup("", -99, -99, 1, 1)
UpdateComboScriptNameDB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($cmbScriptNameDB, $scmbDBScriptName)
If $tempindex = -1 Then $tempindex = 0
_GUICtrlComboBox_SetCurSel($cmbScriptNameDB, $tempindex)
Global $cmbMilkLvl4,$cmbMilkLvl5,$cmbMilkLvl6,$cmbMilkLvl7,$cmbMilkLvl8,$cmbMilkLvl9,$cmbMilkLvl10,$cmbMilkLvl11,$cmbMilkLvl12
Global $chkAtkElixirExtractors, $chkAtkGoldMines, $chkAtkDarkDrills
Global $cmbAtkGoldMinesLevel, $cmbAtkDarkDrillsLevel
Global $cmbRedlineResDistance
Global $chkAttackMinesifGold,$chkAttackMinesifElixir, $chkAttackMinesifDarkElixir
Global $txtAttackMinesifGold,$txtAttackMinesifElixir, $txtAttackMinesifDarkElixir
Global $txtLowerXWave, $txtUpperXWave, $txtLowerDelayWaves, $txtUpperDelayWaves, $txtMaxWaves
Global  $txtMaxTilesMilk, $cmbMilkSnipeAlgorithm, $chkSnipeIfNoElixir
Global $grpMilkingDebug ,$chkMilkingDebugIMG, $chkMilkingDebugFullSearch, $chkMilkingVillageDebugIMG, $chkMilkingDebugVillage
Global $chkMilkFarmForcetolerance, $txtMilkFarmForcetolerancenormal, $txtMilkFarmForcetoleranceboosted, $txtMilkFarmForcetolerancedestroyed
Global $cmbMilkAttackType, $grpExtractorOptions, $grpIfFoundElixir, $cmbStructureOrder,$chkStructureDestroyedBeforeAttack,$chkStructureDestroyedAfterAttack,$cmbMilkingAttackDropGoblinAlgorithm
Global $tabMilkingTHSNIPE, $lblAttackAfterMilking,  $grpSnipeOutsideTHAtEnd,  $lblMaxTilesMilk, $txtMaxTilesMilk, $lblMilkSnipeAlgorithm, $cmbMilkSnipeAlgorithm, $chkSnipeIfNoElixir
Global $cmbStandardAlgorithm, $grpDeploy, $lblDeploy,$cmbDeploy, $lblUnitDelay, $cmbUnitDelay, $lblWaveDelay, $cmbWaveDelay, $chkRandomSpeedAtk, $chkSmartAttackRedArea, $lblSmartDeploy, $cmbSmartDeploy
Global $chkAttackNearGoldMine, $picAttackNearGoldMine, $chkAttackNearElixirCollector, $picAttackNearElixirCollector, $chkAttackNearDarkElixirDrill, $picAttackNearDarkElixirDrill,$lblx
Global $chkMilkAfterAttackTHSnipe, $chkMilkAfterAttackScripted, $cmbMilkingCSVScriptName, $lblMilkingCSVNotesScript
$hGUI_DEADBASE_ATTACK_MILKING = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_DEADBASE)
Local $sTxtDisable = GetTranslated(631,79,"DIS.")
Local $x = 5, $y = 0
$tabMilking = GUICtrlCreateTab($x, $y, 268, 306, $TCS_MULTILINE)
$tabMilkingOptions = GUICtrlCreateTabItem(GetTranslated(600,44,"A - Structures"))
Local $x = 15, $y = 45
$grpMilkAttackType = GUICtrlCreateGroup(GetTranslated(631,80,"Choose Milking Search Type"), $x - 5, $y - 5, 260, 45)
$y += 15
$cmbMilkAttackType = GUICtrlCreateCombo("", $x, $y, 250, 20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1,  GetTranslated(631,59,"Slower: Check the Resources in each collector.") & "|" &  GetTranslated(631,60,"Faster: Only check the Level of each collector."), GetTranslated(631,60,-1))
$y += 30
$grpExtractorOptions = GUICtrlCreateGroup(GetTranslated(631,2, "Elixir Collectors Min. Level to Attack"), $x - 5, $y, 210, 145)
$y += 20
$lblLvl4 = GUICtrlCreateLabel(GetTranslated(631,3, "Levels 1-4"), $x,$y)
$cmbMilkLvl4 = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x+=67
$lblLvl5 = GUICtrlCreateLabel(GetTranslated(631,4, "Level 5"), $x,$y)
$cmbMilkLvl5 = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x+=67
$lblLvl6 = GUICtrlCreateLabel(GetTranslated(631,5, "Level 6"), $x,$y)
$cmbMilkLvl6 = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x = 15
$y += 40
$lblLvl7 = GUICtrlCreateLabel(GetTranslated(631,6, "Level 7"), $x,$y)
$cmbMilkLvl7 = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x+=67
$lblLvl8 = GUICtrlCreateLabel(GetTranslated(631,7, "Level 8"), $x,$y)
$cmbMilkLvl8 = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x+=67
$lblLvl9 = GUICtrlCreateLabel(GetTranslated(631,8, "Level 9"), $x,$y)
$cmbMilkLvl9 = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%",$sTxtDisable)
$x = 15
$y += 40
$lblLvl10 = GUICtrlCreateLabel(GetTranslated(631,9, "Level 10"), $x,$y)
$cmbMilkLvl10 = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%","5-19%")
$x+=67
$lblLvl11 = GUICtrlCreateLabel(GetTranslated(631,10, "Level 11"), $x,$y)
$cmbMilkLvl11 = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%","5-19%")
$x+=67
$lblLvl12 = GUICtrlCreateLabel(GetTranslated(631,11, "Level 12"), $x,$y)
$cmbMilkLvl12 = GUICtrlCreateCombo("", $x, $y +16, 65,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $sTxtDisable & "|0-4%|5-19%|20-74%|75-89%|90-100%","5-19%")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 240
$grpMilkingLegend = GUICtrlCreateGroup(GetTranslated(631,31, "Legend"), $x, $y, 260, 65)
$x = 23
$y = 255
$lblLegend0 = GUICtrlCreateLabel(GetTranslated(631,32, "0-4%"),$x, $y)
$x = 21
$y = 273
$picLegend0 = GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_0_70_A.bmp", $x , $y, 25, 25 )
$x = 65
$y = 255
$lblLegend1 = GUICtrlCreateLabel(GetTranslated(631,33, "5-19%"),$x, $y)
$x = 66
$y = 273
$picLegend1 = GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_1_70_A.bmp", $x , $y, 25, 25 )
$x = 117
$y = 255
$lblLegend2 = GUICtrlCreateLabel(GetTranslated(631,34, "20-74%"),$x, $y)
$x = 121
$y = 273
$picLegend2 = GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_2_70_A.bmp", $x , $y, 25, 25 )
$x = 173
$y = 255
$lblLegend3 = GUICtrlCreateLabel(GetTranslated(631,35, "75-89%"),$x, $y)
$x = 176
$y = 273
$picLegend3 = GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_3_70_A.bmp", $x , $y, 25, 25 )
$x = 224
$y = 255
$lblLegend4 = GUICtrlCreateLabel(GetTranslated(631,36, "90-100%"),$x, $y)
$x = 232
$y = 273
$picLegend4 = GUICtrlCreatePic(@ScriptDir & "\Images\CapacityStructure\elixir_8_4_70_A.bmp", $x , $y, 25, 25 )
GUICtrlCreateGroup("", -99, -99, 1, 1)
$tabMilkingFilters = GUICtrlCreateTabItem(GetTranslated(600,45,"B - Conditions"))
Local $x = 14, $y = 45
$grpIfFoundElixir = GUICtrlCreateGroup(GetTranslated(631,56, "Structures to Attack"), $x - 5, $y, 260, 100)
$y += 22
$chkAtkElixirExtractors = GUICtrlCreateCheckbox(GetTranslated(631,13, "Attack"), $x, $y, -1, 18)
GUICtrlSetState(-1, $GUI_CHECKED)
$picAtkElixirCollectors = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 60, $y - 6, 24, 24)
$y += 26
$chkAtkGoldMines = GUICtrlCreateCheckbox(GetTranslated(631,13, -1), $x, $y, -1, 18)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkAtkGoldMines")
$picAtkGoldMines = GUICtrlCreateIcon($pIconLib, $eIcnMine, $x + 60, $y - 6, 24, 24)
$lblAtkGoldMines = GUICtrlCreateLabel(GetTranslated(631,14, "Which have a Level") & " " & ChrW(8805), $x + 70, $y + 2, 115, 18, $SS_RIGHT)
$cmbAtkGoldMinesLevel = GUICtrlCreateCombo("", $x + 200, $y - 2, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1,"1-4|5|6|7|8|9|10|11","5")
$y += 26
$chkAtkDarkDrills = GUICtrlCreateCheckbox(GetTranslated(631,13, -1), $x, $y, -1, 18)
GUICtrlSetOnEvent(-1, "chkAtkDarkDrills")
GUICtrlSetState(-1, $GUI_CHECKED)
$picAtkDarkDrills = GUICtrlCreateIcon($pIconLib, $eIcnDrill, $x + 60, $y - 6, 24, 24)
$lblAtkDarkDrills = GUICtrlCreateLabel(GetTranslated(631,14, -1) & " " & ChrW(8805), $x + 70, $y + 2, 115, 18, $SS_RIGHT)
$cmbAtkDarkDrillsLevel = GUICtrlCreateCombo("", $x + 200, $y - 2, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1,"1|2|3|4|5|6","1")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 14, $y = 155
$grpAttackResourcesIf = GUICtrlCreateGroup(GetTranslated(631,16, "Only Attack If"), $x - 5, $y - 5, 260, 110)
$y += 15
$lblRedlineResDistance = GUICtrlCreateLabel(GetTranslated(631,17, "Distance between red line and collectors"), $x, $y)
$cmbRedlineResDistance = GUICtrlCreateCombo("", $x + 200, $y - 4, 50, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "0 tile|1 tile|2 tiles","0 tile")
$y += 21
$chkAttackMinesifGold = GUICtrlCreateCheckbox(GetTranslated(631,18, "Attack Gold Mines If Gold Under"), $x, $y)
GUICtrlSetOnEvent(-1, "chkAttackMinesifGold")
GUICtrlSetState(-1, $GUI_CHECKED)
$txtAttackMinesIfGold = GUICtrlCreateInput("9950000", $x + 200, $y, 50, 18, $SS_CENTER)
GUICtrlSetState(-1,$GUI_DISABLE)
$y += 21
$chkAttackMinesifElixir = GUICtrlCreateCheckbox(GetTranslated(631,19, "Attack Elixir Collectors If Elixir Under"), $x, $y)
GUICtrlSetOnEvent(-1, "chkAttackMinesifElixir")
GUICtrlSetState(-1, $GUI_CHECKED)
$txtAttackMinesIfElixir = GUICtrlCreateInput("9950000", $x + 200, $y, 50, 18, $SS_CENTER)
GUICtrlSetState(-1,$GUI_DISABLE)
$y += 21
$chkAttackMinesifDarkElixir = GUICtrlCreateCheckbox(GetTranslated(631,20, "Attack Dark Elixir Drills If Dark Under"), $x, $y)
GUICtrlSetOnEvent(-1, "chkAttackMinesifDarkElixir")
GUICtrlSetState(-1, $GUI_CHECKED)
$txtAttackMinesIfDarkElixir = GUICtrlCreateInput("200000", $x + 200, $y, 50, 18, $SS_CENTER)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlCreateTabItem("")
$tabMilkingDrop = GUICtrlCreateTabItem(GetTranslated(600,46,"C - Attack"))
Local $x = 9
Local $y = 45
$grpTroopsToUse = GUICtrlCreateGroup(GetTranslated(631,21, "4. Troops To Use For Each Building"), $x, $y,260,90)
$x = 15
$y +=20
$lblTroopXWave = GUICtrlCreateLabel(GetTranslated(631,22, "- Troops Per Wave:"),$x, $y)
$txtLowerXWave = GUICtrlCreateInput("4", 180-10, $y-7, 37,21)
GUICtrlCreateLabel("-", 208, $y)
$txtUpperXWave = GUICtrlCreateInput("6", 245-20, $y-7, 37,21)
$y +=20
$lblMaxWave = GUICtrlCreateLabel(GetTranslated(631,23, "- Max Waves:"),$x, $y)
$txtMaxWaves = GUICtrlCreateInput("3", 180-10, $y-7, 37,21)
_GUICtrlSetTip(-1,  GetTranslated(631,85,"Choose the maximum number of waves of troops to drop at each collector.")&@CRLF& GetTranslated(631,86,"If the collector gets destroyed, then no more waves will be dropped at it."))
$y +=20
$lblDelayBtwnWaves = GUICtrlCreateLabel(GetTranslated(631,24, "- Delay Between Waves (ms):"),$x, $y)
$txtLowerDelayWaves = GUICtrlCreateInput("3000", 180-10, $y-7, 37,21)
GUICtrlCreateLabel("-", 208, $y)
$txtUpperDelayWaves = GUICtrlCreateInput("5000", 245-20, $y-7, 37,21)
$x = 9
$y +=40
$grpCheckStructureDestroyed = GUICtrlCreateGroup(GetTranslated(631,71, "5. Dropping options"), $x,$y, 260,80)
$y +=21
$cmbMilkingAttackDropGoblinAlgorithm = GUICtrlCreateCombo("", $x+5, $y , 240,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1,  GetTranslated(631,72,"Drop each Goblin in the same place") & "|" &  GetTranslated(631,73,"Drop each Goblin in a different place"), GetTranslated(631,72,-1))
$y +=25
$cmbStructureOrder = GUICtrlCreateCombo("", $x+5, $y , 250,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1,  GetTranslated(631,74,"Attack Order: as found") & "|" &  GetTranslated(631,75,"Attack Order: Random") & "|" &  GetTranslated(631,76,"Attack Order: by side"), GetTranslated(631,76,-1))
$x = 9
$y +=40
$grpCheckStructureDestroyed = GUICtrlCreateGroup(GetTranslated(631,61, "Check Destroyed Structures"), $x,$y, 260,70)
$y += 20
$x += 5
$chkStructureDestroyedBeforeAttack = GUICtrlCreateCheckbox(GetTranslated(631,62, "Check Structure Destruction Before Wave"), $x, $y)
$txtTip = GetTranslated(631,63, "Before attacking a structure, check to see if it has been destroyed by another wave.") & @crlf &  GetTranslated(631,64,"You must have a high delay between waves to use this option")
_GUICtrlSetTip(-1, $txtTip)
$y += 20
$chkStructureDestroyedAfterAttack = GUICtrlCreateCheckbox(GetTranslated(631,65, "Check Structure Destruction After Wave"), $x, $y)
$txtTip = GetTranslated(631,66, "After attacking a structure, check to see if it has been destroyed by another wave.") & @crlf & GetTranslated(631,67,"You must have a high delay between waves to use this option")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateTabItem("")
$tabMilkingTHSNIPE = GUICtrlCreateTabItem(GetTranslated(600,47,"D - After Milking"))
Local $x = 9
Local $y = 45
$grpSnipeOutsideTHAtEnd = GUICtrlCreateGroup(GetTranslated(631,25, "5a. Snipe Outside TH After Milking"), $x, $y-4,260,120)
$x =15
$y+=15
$chkMilkAfterAttackTHSnipe = GUICtrlCreateCheckbox(GetTranslated(631,82,"Enable TH Snipe"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkMilkAfterAttackTHSnipe")
$y+=21
$lblMaxTilesMilk = GUICtrlCreateLabel(GetTranslated(631,27, "Max Tiles From Border") & ":", $x, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$txtMaxTilesMilk = GUICtrlCreateInput("1", $x + 175,$y-7, 37,21)
GUICtrlSetState(-1, $GUI_DISABLE)
$y+=20
$lblMilkSnipeAlgorithm = GUICtrlCreateLabel(GetTranslated(631,28, "Use Algorithm")&":", $x, $y)
GUICtrlSetState(-1, $GUI_DISABLE)
$cmbMilkSnipeAlgorithm = GUICtrlCreateCombo("", 120,$y-2, 120,20,BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetState(-1, $GUI_DISABLE)
PopulateCmbMilkSnipeAlgorithm()
_GUICtrlComboBox_SetCurSel($cmbMilkSnipeAlgorithm,_GUICtrlComboBox_FindStringExact($cmbMilkSnipeAlgorithm, "Queen&GobTakeTH"))
$y+=20
$chkSnipeIfNoElixir = GUICtrlCreateCheckbox(GetTranslated(631,29, "Snipe Even If No Collectors can be Milked"), $x,$y)
GUICtrlSetState(-1, $GUI_DISABLE)
$x =9
$y += 85
Local $textnum = "", $groupText = "", $mode = $DB
$grpDeploy = GUICtrlCreateGroup(GetTranslated(631,84,"5b. Continue With An Scripted Attack"), $x , $y - 20, 260, 70)
$x+=15
$chkMilkAfterAttackScripted = GUICtrlCreateCheckbox(GetTranslated(631,83,"Enable Scripted Attack"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$y+=21
$cmbMilkingCSVScriptName = GUICtrlCreateCombo("", $x-10 , $y, 185, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(631,30, "Use scripted attack for dead bases, this disables standard attack")
PopulateComboMilkingCSVScriptsFiles()
_GUICtrlComboBox_SetCurSel($cmbMilkingCSVScriptName,_GUICtrlComboBox_FindStringExact($cmbMilkingCSVScriptName, "Barch four fingers"))
$y +=25
$lblMilkingCSVNotesScript =  GUICtrlCreateLabel("", $x, $y + 5, 180, 118)
$y +=20
$lblx = GUICtrlCreateLabel("",$x,$y,-1,-1)
GUICtrlSetState(-1,$GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$tabMilkingTolerance = GUICtrlCreateTabItem(GetTranslated(600,48,"Advanced"))
Local $x = 9
Local $y = 45
$y +=21
$grpForeTolerance = GUICtrlCreateGroup(GetTranslated(631,68, "Tolerance Settings"), $x,$y, 260,120)
$x+=5
$y +=21
$chkMilkFarmForcetolerance = GUICtrlCreateCheckbox(GetTranslated(631,50, "Force Tolerance"), $x, $y)
GUICtrlSetOnEvent(-1,"chkMilkFarmForcetolerance")
$y +=21
$lblMilkFarmForcetolerancenormal = GUICtrlCreateLabel(GetTranslated(631,51, "Tolerance Normal"), $x,$y)
$txtMilkFarmForcetolerancenormal = GUICtrlCreateInput("60", 235-31, $y, 60-8,21)
GUICtrlSetState(-1, $GUI_DISABLE)
$y +=21
$lblMilkFarmForcetoleranceBoosted = GUICtrlCreateLabel(GetTranslated(631,52, "Tolerance Boosted"), $x,$y)
$txtMilkFarmForcetoleranceboosted = GUICtrlCreateInput("60", 235-31, $y, 60-8,21)
GUICtrlSetState(-1, $GUI_DISABLE)
$y +=21
$lblMilkFarmForcetoleranceDestroyed = GUICtrlCreateLabel(GetTranslated(631,53, "Tolerance Destroyed"), $x,$y)
$txtMilkFarmForcetoleranceDestroyed = GUICtrlCreateInput("60", 235-31, $y, 60-8,21)
GUICtrlSetState(-1, $GUI_DISABLE)
$x = 9
$y += 50
$grpMilkingDebug = GUICtrlCreateGroup(GetTranslated(631,37, "Debug"), $x,$y, 260,100)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$x += 5
$chkMilkingDebugIMG = GUICtrlCreateCheckbox(GetTranslated(631,38, "Make Images of each extractor with offset"), $x, $y)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$chkMilkingDebugVillage = GUICtrlCreateCheckbox(GetTranslated(631,41, "Make Images of villages"), $x, $y)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$chkMilkingDebugFullSearch = GUICtrlCreateCheckbox(GetTranslated(631,39, "fullsearch, only for debug purpose (very slow)"), $x, $y)
$txtTip = GetTranslated(631,81,"with this options you can detect images of undetected Elixir Extractors")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateTabItem("")
GUISwitch($hGUI_DEADBASE)
$hGUI_DEADBASE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_DEADBASE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,28,"Search"))
Local $x = 25, $y = 45
$grpDBActivate = GUICtrlCreateGroup(GetTranslated(625,0, "Start Search IF"), $x - 20, $y - 20, 190, 305)
$x -= 15
$chkDBActivateSearches = GUICtrlCreateCheckbox(GetTranslated(625,1,"Search"), $x, $y, 68, 18)
$txtTip = GetTranslated(625,68, "Note - enables SEARCH range for this attack type ONLY.") & @CRLF &  GetTranslated(625,69, "Setting will not set search limit to restart search process!")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkDBActivateSearches")
$txtDBSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,2, "Set the Min. number of searches to activate this attack option") & @CRLF & @CRLF &  GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$lblDBSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$txtDBSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,3, "Set the Max number of searches to activate this attack option") & @CRLF & @CRLF &  GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picDBSearches = GUICtrlCreateIcon($pIconLib, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y += 21
$chkDBActivateTropies = GUICtrlCreateCheckbox(GetTranslated(625,4,"Trophies"), $x, $y, 68, 18)
$txtTip = GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,"This option will NOT adjust tropies to stay in range entered!")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBActivateTropies")
$txtDBTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTip = GetTranslated(625,5, "Set the Min. number of tropies where this attack will be used") & @CRLF & @CRLF &  GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$lblDBTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$txtDBTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTip = GetTranslated(625,6, "Set the Max number of tropies where this attack will be used") & @CRLF & @CRLF &  GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picDBTrophies = GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y +=21
$chkDBActivateCamps = GUICtrlCreateCheckbox(GetTranslated(625,7, "Army Camps"), $x, $y, 110, 18)
$txtTip = GetTranslated(625,8, "Set the % Army camps required to enable this attack option while searching")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBActivateCamps")
$lblDBArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
$txtDBArmyCamps = GUICtrlCreateInput("80", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
$txtDBArmyCampsPerc = GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$y +=23
$picDBHeroesWait = GUICtrlCreateIcon($pIconLib, $eIcnHourGlass, $x - 1, $y + 3, 16, 16)
$txtDBHeroesWait = GUICtrlCreateLabel(GetTranslated(625,9,"Wait for Heroes to be Ready") & ":", $x + 20, $y + 4, 180, 18)
$y += 20
$x += 20
$chkDBKingWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
Local $sTxtKingWait = GetTranslated(625,50, "Wait for Hero option disabled when continuous Upgrade Hero selected!")
$txtTip = GetTranslated(625,10, "Wait for King to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslated(625,65, "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBKingWait")
$IMGchkDBKingWait=GUICtrlCreateIcon($pIconLib, $eIcnKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
$IMGchkDBKingSleepWait=GUICtrlCreateIcon($pIconLib, $eIcnSleepingKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 55
$chkDBQueenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$txtTip = GetTranslated(625,12, "Wait for Queen to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslated(625,66, "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBQueenWait")
$IMGchkDBQueenWait=GUICtrlCreateIcon($pIconLib, $eIcnQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
$IMGchkDBQueenSleepWait=GUICtrlCreateIcon($pIconLib, $eIcnSleepingQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 55
$chkDBWardenWait = GUICtrlCreateCheckbox("", $x, $y + 55, 16, 16)
$txtTip = GetTranslated(625,13, "Wait for Warden to be ready before attacking...") & @CRLF & $sTxtKingWait & @CRLF & GetTranslated(625,67, "Enabled with TownHall 11")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBWardenWait")
$IMGchkDBWardenWait=GUICtrlCreateIcon($pIconLib, $eIcnWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
$IMGchkDBWardenSleepWait=GUICtrlCreateIcon($pIconLib, $eIcnSleepingWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$y += 80
$x = 8
$IMGchkDBLightSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnLightSpell, $x, $y, 22, 22)
$IMGchkDBHealSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnHealSpell, $x+23, $y, 22, 22)
$IMGchkDBRageSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnRageSpell, $x+46, $y, 22, 22)
$IMGchkDBJumpSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnJumpSpell , $x+69, $y, 22, 22)
$IMGchkDBFreezeSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnFreezeSpell , $x+92, $y, 22, 22)
$IMGchkDBPoisonSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnPoisonSpell , $x+115, $y, 22, 22)
$IMGchkDBEarthquakeSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnEarthquakeSpell , $x+138, $y, 22, 22)
$IMGchkDBHasteSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnHasteSpell, $x+161, $y, 22, 22)
$y += 22
$x = 10
$chkDBSpellsWait = GUICtrlCreateCheckbox("Wait for Spells to be Ready", $x, $y, -1, -1)
$txtTip = GetTranslated(625,100, "Stop searching for this attack type when Spells are not ready") & @CRLF &  GetTranslated(625,101, "Warning: Do not enable unless you have spell factory or bot will not attack!")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBSpellsWait")
$chkDBWaitForCastleSpell = GUICtrlCreateCheckbox("Wait to get Castle Spell", $x, $y + 25, -1, -1)
$txtTip = "Wait until Someone Donate you an Spell"
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBWaitForCCSpell")
$cmbDBWaitForCastleSpell = GUICtrlCreateCombo("Any", $x, $y + 50, -1, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = "Wait until Someone Donate this Spell, Else remove other spells in Castle and Request AGAIN"
GUICtrlSetData(-1, "Poison|EarthQuake|Haste|Skeleton")
_GUICtrlSetTip(-1, $txtTip)
$chkDBWaitForCastleTroops = GUICtrlCreateCheckbox("Wait to for Castle troops to be full", $x, $y + 75, -1, -1)
$txtTip = "Wait until your Clan Castle be Full"
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$grpDBFilter = GUICtrlCreateGroup(GetTranslated(625,14, "Filters"), $x - 20, $y - 20, 225, 305)
$x -= 15
$cmbDBMeetGE = GUICtrlCreateCombo("", $x , $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,15, "Search for a base that meets the values set for Gold And/Or/Plus Elixir.") & @CRLF & GetTranslated(625,16, "AND: Both conditions must meet, Gold and Elixir.") & @CRLF & GetTranslated(625,17, "OR: One condition must meet, Gold or Elixir.") & @CRLF & GetTranslated(625,18, "+ (PLUS): Total amount of Gold + Elixir must meet.")
GUICtrlSetData(-1, GetTranslated(625,19, "G And E") &"|" & GetTranslated(625,20, "G Or E") & "|" & GetTranslated(625,21, "G + E"), GetTranslated(625,19, -1))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "cmbDBGoldElixir")
$txtDBMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,23, "Set the Min. amount of Gold to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picDBMinGold = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$txtDBMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,24, "Set the Min. amount of Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picDBMinElixir = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y -= 11
$txtDBMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,25, "Set the Min. amount of Gold + Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState (-1, $GUI_HIDE)
$picDBMinGPEGold = GUICtrlCreateIcon($pIconLib, $eIcnGoldElixir, $x + 140, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState (-1, $GUI_HIDE)
$y += 34
$chkDBMeetDE = GUICtrlCreateCheckbox(GetTranslated(625,26, "Dark Elixir"), $x , $y, -1, -1)
$txtTip = GetTranslated(625,27, "Search for a base that meets the value set for Min. Dark Elixir.")
GUICtrlSetOnEvent(-1, "chkDBMeetDE")
_GUICtrlSetTip(-1, $txtTip)
$txtDBMinDarkElixir = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,28, "Set the Min. amount of Dark Elixir to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$picDBMinDarkElixir = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$chkDBMeetTrophy = GUICtrlCreateCheckbox(GetTranslated(625,4, -1), $x, $y, -1, -1)
$txtTip = GetTranslated(625,29, "Search for a base that meets the value set for Min. Trophies.")
GUICtrlSetOnEvent(-1, "chkDBMeetTrophy")
_GUICtrlSetTip(-1, $txtTip)
$txtDBMinTrophy = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,30, "Set the Min. amount of Trophies to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
$picDBMinTrophies = GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 140, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$chkDBMeetTH = GUICtrlCreateCheckbox(GetTranslated(625,31, "Townhall"), $x, $y, -1, -1)
$txtTip = GetTranslated(625,32, "Search for a base that meets the value set for Max. Townhall Level.")
GUICtrlSetOnEvent(-1, "chkDBMeetTH")
_GUICtrlSetTip(-1, $txtTip)
$cmbDBTH = GUICtrlCreateCombo("", $x + 85, $y - 1, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,33, "Set the Max. level of the Townhall to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "4-6|7|8|9|10|11", "4-6")
$picDBMaxTH10 = GUICtrlCreateIcon($pIconLib, $eIcnTH10, $x + 140, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$chkDBMeetTHO = GUICtrlCreateCheckbox(GetTranslated(625,34, "Townhall Outside"), $x, $y, -1, -1)
$txtTip = GetTranslated(625,35, "Search for a base that has an exposed Townhall. (Outside of Walls)")
_GUICtrlSetTip(-1, $txtTip)
$y += 24
GUICtrlCreateGroup("Weak base | max defenses", $x, $y, 215, 100)
$x += 5
$y += 20
$xStarColumn = $x
$yStartColumn = $y
$chkMaxMortar[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,59, "Search for a base that has Mortar below this level.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$cmbWeakMortar[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,38, "Set the Max. level of the Mortar to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8", "Lvl 5")
GUICtrlSetState(-1, $GUI_DISABLE)
$picDBWeakMortar = GUICtrlCreateIcon($pIconLib, $eIcnMortar, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y +=24
$chkMaxWizTower[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,60, "Search for a base that has Wizard Tower below this level")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$cmbWeakWizTower[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,39, "Set the Max. level of the Wizard Tower to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9", "Lvl 4")
GUICtrlSetState(-1, $GUI_DISABLE)
$picDBWeakWizTower = GUICtrlCreateIcon($pIconLib, $eIcnWizTower, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y +=24
$chkMaxAirDefense[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = "Search for a base that has Air Defense below this level"
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$cmbWeakAirDefense[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = "Set the Max. level of the Air Defense to search for on a village to attack."
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8", "Lvl 7")
GUICtrlSetState(-1, $GUI_DISABLE)
$picDBWeakAirDefense = GUICtrlCreateIcon($pIconLib, $eIcnAirDefense, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$x = $xStarColumn + 104
$y = $yStartColumn
$chkMaxXBow[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,61, "Search for a base that has X-Bow below this level")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$cmbWeakXBow[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,51, "Set the Max. level of the X-Bow to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$picDBWeakXBow = GUICtrlCreateIcon($pIconLib, $eIcnXBow3, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y +=24
$chkMaxInferno[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,62, "Search for a base that has Inferno below this level")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$cmbWeakInferno[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,52, "Set the Max. level of the Inferno Tower to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$picDBWeakInferno = GUICtrlCreateIcon($pIconLib, $eIcnInferno4, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y +=24
$chkMaxEagle[$DB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,63, "Search for a base that has Eagle Artillery below this level")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBWeakBase")
$cmbWeakEagle[$DB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,53, "Set the Max. level of the Eagle Artillery to search for on a village to attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2", "Lvl 1")
GUICtrlSetState(-1, $GUI_DISABLE)
$picDBWeakEagle = GUICtrlCreateIcon($pIconLib, $eIcnEagleArt, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y += 44
$x = $xStarColumn
$chkDBMeetOne = GUICtrlCreateCheckbox(GetTranslated(625,40, "Meet One Then Attack"), $x, $y, -1, -1)
$txtTip = GetTranslated(625,41, "Just meet only ONE of the above conditions, then Attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_DEADBASE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,29,"Attack"))
Local $x = 25, $y = 40
$grpDBAttack = GUICtrlCreateGroup(GetTranslated(624,1,"Attack with"), $x - 20, $y - 15, 145, 223)
$x -= 15
$lblDBAlgorithm = GUICtrlCreateLabel(GetTranslated(624,2,"Attack Type") & ":", $x, $y, 135, 18, $SS_LEFT)
$y += 15
$cmbDBAlgorithm = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, "")
GUICtrlSetData(-1, GetTranslated(624,3,"Standard Attack") & "|" & GetTranslated(624,4,"Scripted Attack") & "|" & GetTranslated(624,5,"Milking Attack"), GetTranslated(624,3,-1))
GUICtrlSetOnEvent(-1, "cmbDBAlgorithm")
$y += 25
$lblDBSelectTroop=GUICtrlCreateLabel(GetTranslated(624,6,"Only drop these troops") & ":", $x, $y, 135, 18, $SS_LEFT)
$y += 15
$cmbDBSelectTroop=GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(624,7, "Use All Troops") &"|"&GetTranslated(624,8, "Use Troops in Barracks")&"|"&GetTranslated(624,9, "Barb Only")&"|" & GetTranslated(624,10, "Arch Only") &"|"&GetTranslated(624,11, "B+A")&"|"&GetTranslated(624,12, "B+Gob")&"|"&GetTranslated(624,13, "A+Gob")&"|"&GetTranslated(624,14, "B+A+Gi")&"|"&GetTranslated(624,15, "B+A+Gob+Gi")&"|"&GetTranslated(624,16, "B+A+Hog Rider")&"|"&GetTranslated(624,17, "B+A+Minion") , GetTranslated(624,7, -1))
_GUICtrlSetTip(-1, GetTranslated(624,18,"Select the troops to use in attacks"))
$y += 25
$lblDBSelectSpecialTroop=GUICtrlCreateLabel(GetTranslated(624,19,"Special troops to use") & ":",$x, $y, 135, 18, $SS_LEFT)
$y += 18
$IMGchkDBKingAttack=GUICtrlCreateIcon($pIconLib, $eIcnKing, $x , $y, 24, 24)
$txtTip = GetTranslated(624,20, "Use your King when Attacking...") & @CRLF & GetTranslated(624,41, "Enabled with TownHall 7 and higher")
_GUICtrlSetTip(-1, $txtTip)
$chkDBKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x += 46
$IMGchkDBQueenAttack=GUICtrlCreateIcon($pIconLib, $eIcnQueen, $x, $y, 24, 24)
$txtTip = GetTranslated(624,21, "Use your Queen when Attacking...")& @CRLF & GetTranslated(624,42, "Enabled with TownHall 9 and higher")
_GUICtrlSetTip(-1, $txtTip)
$chkDBQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkDBWardenAttack=GUICtrlCreateIcon($pIconLib, $eIcnWarden, $x, $y, 24, 24)
$txtTip = GetTranslated(624,22, "Use your Warden when Attacking...") & @CRLF & GetTranslated(624,43, "Enabled with Townhall 11")
_GUICtrlSetTip(-1, $txtTip)
$chkDBWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y +=27
$x -=92
$IMGchkDBDropCC=GUICtrlCreateIcon($pIconLib, $eIcnCC, $x, $y, 24, 24)
$txtTip =GetTranslated(624,23, "Drop your Clan Castle in battle if it contains troops.")
_GUICtrlSetTip(-1, $txtTip)
$chkDBDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x += 46
$IMGchkDBLightSpell=GUICtrlCreateIcon($pIconLib, $eIcnLightSpell, $x, $y, 24, 24)
$txtTip = GetTranslated(624,24, "Use your Light Spells when Attacking...")
_GUICtrlSetTip(-1, $txtTip)
$chkDBLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkDBHealSpell=GUICtrlCreateIcon($pIconLib, $eIcnHealSpell, $x, $y, 24, 24)
$txtTip = GetTranslated(624,25, "Use your Healing Spells when Attacking...")
_GUICtrlSetTip(-1, $txtTip)
$chkDBHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y +=27
$x -=92
$IMGchkDBRageSpell=GUICtrlCreateIcon($pIconLib, $eIcnRageSpell, $x, $y, 24, 24)
$txtTip = GetTranslated(624,26, "Use your Rage Spells when Attacking...")
_GUICtrlSetTip(-1, $txtTip)
$chkDBRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkDBJumpSpell=GUICtrlCreateIcon($pIconLib, $eIcnJumpSpell , $x, $y, 24, 24)
$txtTip =GetTranslated(624,27, "Use your Jump Spells when Attacking...")
_GUICtrlSetTip(-1, $txtTip)
$chkDBJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x += 46
$IMGchkDBFreezeSpell=GUICtrlCreateIcon($pIconLib, $eIcnFreezeSpell , $x, $y, 24, 24)
$txtTip = GetTranslated(624,28, "Use your Freeze Spells when Attacking...")
_GUICtrlSetTip(-1, $txtTip)
$chkDBFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y +=27
$x -=92
$IMGchkDBPoisonSpell=GUICtrlCreateIcon($pIconLib, $eIcnPoisonSpell , $x, $y, 24, 24)
$txtTip = GetTranslated(624,29, "Use your Poison Spells when Attacking...")
_GUICtrlSetTip(-1, $txtTip)
$chkDBPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkDBEarthquakeSpell=GUICtrlCreateIcon($pIconLib, $eIcnEarthquakeSpell , $x, $y, 24, 24)
$txtTip = GetTranslated(624,30, "Use your Earthquake Spells when Attacking...")
_GUICtrlSetTip(-1, $txtTip)
$chkDBEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkDBHasteSpell=GUICtrlCreateIcon($pIconLib, $eIcnHasteSpell, $x, $y, 24, 24)
$txtTip =GetTranslated(624,31, "Use your Haste Spells when Attacking...")
_GUICtrlSetTip(-1, $txtTip)
$chkDBHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 268
$grpTSAttackBeforeDB = GUICtrlCreateGroup(GetTranslated(624,32, "TH Snipe"),  $x - 5, $y - 20, 145, 84,$SS_CENTER)
$chkTHSnipeBeforeDBEnable = GUICtrlCreateCheckbox(GetTranslated(624,33, "Snipe TH External first") ,$x, $y - 5, -1, -1)
$txtTip = GetTranslated(624,34, "If TH is external start with a TH Snipe")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkTHSnipeBeforeDBEnable")
$y +=16
$lblTHSnipeBeforeDBTiles = GUICtrlCreateLabel(GetTranslated(624,35, "Add Tiles")& ":", $x, $y + 3, 70, -1, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_DISABLE)
$txtTHSnipeBeforeDBTiles = GUICtrlCreateInput("2", $x + 75, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(624,36, "Max numbers of tiles from border to consider TH as external")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$picTHSnipeBeforeDBTiles = GUICtrlCreateIcon($pIconLib, $eIcnTiles, $x + 107, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$cmbTHSnipeBeforeDBScript = GUICtrlCreateCombo("",  $x, $y, 130, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
$txtTip = GetTranslated(624,37, "You can add/edit CSV settings in the CSV\THSnipe folder")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
LoadDBSnipeAttacks()
_GUICtrlComboBox_SetCurSel($cmbTHSnipeBeforeDBScript,_GUICtrlComboBox_FindStringExact($cmbTHSnipeBeforeDBScript, "Bam"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_DEADBASE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,30,"End Battle"))
Local $x = 10, $y = 45
$grpDBEndBattle = GUICtrlCreateGroup(GetTranslated(606,1, "Exit Battle"),  $x - 5, $y - 20, 420, 305)
$y -=5
$chkDBTimeStopAtk = GUICtrlCreateCheckbox(GetTranslated(606,2, "When no New loot") ,$x, $y, -1, -1)
$txtTip = GetTranslated(606,3, "End Battle if there is no extra loot raided within this No. of seconds.") & @CRLF & GetTranslated(606,4, "Countdown is started after all Troops and Royals are deployed in battle.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBTimeStopAtk")
GUICtrlSetState(-1, $GUI_CHECKED)
$y +=20
$lblDBTimeStopAtka = GUICtrlCreateLabel(GetTranslated(606,5, "raided within")& ":", $x + 16, $y + 3, -1, -1)
$txtDBTimeStopAtk = GUICtrlCreateInput("20", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
$lblDBTimeStopAtk = GUICtrlCreateLabel(GetTranslated(603,6, "sec."), $x + 120, $y + 3, -1, -1)
$y += 20
$chkDBTimeStopAtk2 = GUICtrlCreateCheckbox(GetTranslated(606,2, -1) ,$x, $y, -1, -1)
$txtTip = GetTranslated(606,3, -1) & @CRLF & GetTranslated(606,4, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDBTimeStopAtk2")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$lblDBTimeStopAtk2a = GUICtrlCreateLabel(GetTranslated(606,5, -1)& ":", $x + 16, $y + 3, -1, -1)
$txtDBTimeStopAtk2 = GUICtrlCreateInput("5", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$lblDBTimeStopAtk2 = GUICtrlCreateLabel(GetTranslated(603,6, -1), $x + 120, $y + 3, -1, -1)
$y += 21
$lblDBMinRerourcesAtk2 = GUICtrlCreateLabel(GetTranslated(606,7, "And Resources are below") & ":", $x + 16 , $y + 2, -1, -1)
$txtTip = GetTranslated(606,8, "End Battle if below this amount of Gold.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
$txtDBMinGoldStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$picDBMinGoldStopAtk2 = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$txtDBMinElixirStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$picDBMinElixirStopAtk2 = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$txtDBMinDarkElixirStopAtk2 = GUICtrlCreateInput("50", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$picDBMinDarkElixirStopAtk2 = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$chkDBEndNoResources = GUICtrlCreateCheckbox(GetTranslated(606,9, "When no Resources left"), $x , $y , -1, -1)
$txtTip = GetTranslated(606,10, "End Battle when all Gold, Elixir and Dark Elixir = 0")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$chkDBEndOneStar = GUICtrlCreateCheckbox(GetTranslated(606,11, "When One Star is won") , $x, $y , -1, -1)
$txtTip = GetTranslated(606,12, "Will End the Battle if 1 star is won in battle")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$chkDBEndTwoStars = GUICtrlCreateCheckbox(GetTranslated(606,13, "When Two Stars are won") , $x, $y, -1, -1)
$txtTip = GetTranslated(606,14, "Will End the Battle if 2 stars are won in battle")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_DEADBASE_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,31,"Collectors"))
Global $chkLvl6, $chkLvl7, $chkLvl8, $chkLvl9, $chkLvl10, $chkLvl11, $chkLvl12
Global $cmbLvl6, $cmbLvl7, $cmbLvl8, $cmbLvl9, $cmbLvl10, $cmbLvl11, $cmbLvl12
Global $sldCollectorTolerance
Local $x = 10, $y = 45
Local $txtTip1 = GetTranslated(626,15, "If this box is checked, then the bot will look")
Local $txtFull = GetTranslated(626,30, "Full")
$grpDeadBaseCollectors = GUICtrlCreateGroup(GetTranslated(626,1,"Collectors"), $x - 5, $y - 20, 420, 305)
$txtCollectors = GUICtrlCreateLabel(GetTranslated(626,2, "Choose which collectors to search for while looking for a dead base. Also, choose how full they must be."), $x, $y, 250, 28)
$y+=40
$chkLvl6 = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$txtTip = $txtTip1 & @CRLF & GetTranslated(626,16, "for level 6 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkLvl6")
$picLvl6 = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$txtLvl6 = GUICtrlCreateLabel(GetTranslated(626,3, "Lvl 6. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbLvl6 = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(626,23,'Select how full a level 6 collector needs to be for it to be marked "dead"')
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "50% " & GetTranslated(626,10, "(N/A)")& "|75%|90%+", "90%+")
GUICtrlSetOnEvent(-1, "cmbLvl6")
$txtLvl6Full = GUICtrlCreateLabel($txtFull, $x + 205, $y + 3)
$y+= 25
$chkLvl7 = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$txtTip = $txtTip1 & @CRLF & GetTranslated(626,17, "for level 7 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkLvl7")
$picLvl7 = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$txtLvl7 = GUICtrlCreateLabel(GetTranslated(626,4, "Lvl 7. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbLvl7 = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(626,24,'Select how full a level 7 collector needs to be for it to be marked "dead"')
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "50% " & GetTranslated(626,10,-1) & "|75%|90%+", "90%+")
GUICtrlSetOnEvent(-1, "cmbLvl7")
$txtLvl7Full = GUICtrlCreateLabel($txtFull, $x + 205, $y + 3)
$y+= 25
$chkLvl8 = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$txtTip = $txtTip1 & @CRLF & GetTranslated(626,18,"for level 8 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkLvl8")
$picLvl8 = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$txtLvl8 = GUICtrlCreateLabel(GetTranslated(626,5, "Lvl 8. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbLvl8 = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(626,25,'Select how full a level 8 collector needs to be for it to be marked "dead"')
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "50% " & GetTranslated(626,10,-1) & "|75%|90%+", "90%+")
GUICtrlSetOnEvent(-1, "cmbLvl8")
$txtLvl8Full = GUICtrlCreateLabel($txtFull, $x + 205, $y + 3)
$y+= 25
$chkLvl9 = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$txtTip = $txtTip1 & @CRLF & GetTranslated(626,19,"for level 9 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkLvl9")
$picLvl9 = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$txtLvl9 = GUICtrlCreateLabel(GetTranslated(626,6, "Lvl 9. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbLvl9 = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(626,26,'Select how full a level 9 collector needs to be for it to be marked "dead"')
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "50% " & GetTranslated(626,10,-1) & "|75%|90%+", "75%")
GUICtrlSetOnEvent(-1, "cmbLvl9")
$txtLvl9Full = GUICtrlCreateLabel($txtFull, $x + 205, $y + 3)
$y+= 25
$chkLvl10 = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$txtTip = $txtTip1&@CRLF&GetTranslated(626,20,"for level 10 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkLvl10")
$picLvl10 = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$txtLvl10 = GUICtrlCreateLabel(GetTranslated(626,7, "Lvl 10. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbLvl10 = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(626,27,'Select how full a level 10 collector needs to be for it to be marked "dead"')
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "50% " & GetTranslated(626,10,-1) & "|75%|90%+", "50% " & GetTranslated(626,10,-1))
GUICtrlSetOnEvent(-1, "cmbLvl10")
$txtLvl10Full = GUICtrlCreateLabel($txtFull, $x + 205, $y + 3)
$y+= 25
$chkLvl11 = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$txtTip = $txtTip1&@CRLF&GetTranslated(626,21,"for level 11 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkLvl11")
$picLvl11 = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$txtLvl11 = GUICtrlCreateLabel(GetTranslated(626,8, "Lvl 11. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbLvl11 = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(626,28,'Select how full a level 11 collector needs to be for it to be marked "dead"')
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "50% " & GetTranslated(626,10,-1) & "|75%|90%+", "50% " & GetTranslated(626,10,-1))
GUICtrlSetOnEvent(-1, "cmbLvl11")
$txtLvl11Full = GUICtrlCreateLabel($txtFull, $x + 205, $y + 3)
$y+= 25
$chkLvl12 = GUICtrlCreateCheckbox("", $x, $y, 18, 18)
$txtTip = $txtTip1&@CRLF&GetTranslated(626,22,"for level 12 elixir collectors during dead base detection.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkLvl12")
$picLvl12 = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$txtLvl12 = GUICtrlCreateLabel(GetTranslated(626,9, "Lvl 12. Must be >"), $x + 40, $y + 3, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbLvl12 = GUICtrlCreateCombo("", $x + 125, $y, 75, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(626,29,'Select how full a level 12 collector needs to be for it to be marked "dead"')
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "50% " & GetTranslated(626,10,-1) & "|75%|90%+", "50% " & GetTranslated(626,10,-1))
GUICtrlSetOnEvent(-1, "cmbLvl12")
$txtLvl12Full = GUICtrlCreateLabel($txtFull, $x + 205, $y + 3)
$y += 25
$lblTolerance = GUICtrlCreateLabel("-15" & _PadStringCenter(GetTranslated(626,11, "Tolerance"), 66, " ") & "15", $x, $y)
$y += 15
$sldCollectorTolerance = GUICtrlCreateSlider($x, $y, 250, 20, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
$txtTip = GetTranslated(626,12, "Use this slider to adjust the tolerance of ALL images.") &@CRLF& GetTranslated(626,13, "If you want to adjust individual images, you must edit the files.")&@CRLF&GetTranslated(626,31,"WARNING: Do not change this setting unless you know what you are doing. Set it to 0 if you're not sure.")
GUICtrlSetBkColor(-1, $GUI_BKCOLOR_TRANSPARENT)
_GUICtrlSetTip(-1, $txtTip)
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1,1)
GUICtrlSetLimit(-1, 15,-15)
GUICtrlSetData(-1, 0)
GUICtrlSetOnEvent(-1, "sldCollectorTolerance")
If $DevMode = 0 Then
GUICtrlSetState($lblTolerance, $GUI_HIDE)
GUICtrlSetState($sldCollectorTolerance, $GUI_HIDE)
EndIf
$y += 25
$lblCollectorWarning = GUICtrlCreateLabel("Warning: no collecters are selected. The bot will never find a dead base.", $x, $y, 255, 30)
GUICtrlSetFont(-1, 10, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_RED)
GUICtrlSetState(-1, $GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_ACTIVEBASE = GUICreate("", $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_SEARCH)
$hGUI_ACTIVEBASE_ATTACK_STANDARD = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_ACTIVEBASE)
Local $x = 25, $y = 20
$grpDeployAB = GUICtrlCreateGroup(GetTranslated(608,1, -1), $x - 20, $y - 20, 270, 306)
$lblABmode = GUICtrlCreateLabel(GetTranslated(608,2, -1),$x, $y, 143,18,$SS_LEFT)
$y += 15
$cmbStandardAlgorithmAB = GUICtrlCreateCombo("", $x, $y, 150, Default, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(608,25, -1)&"|Barch/BAM/BAG|GiBarch", GetTranslated(608,25, -1))
_GUICtrlSetTip(-1, GetTranslated(608,33, -1)&@CRLF&GetTranslated(608,34, -1))
$y += 25
$lblDeployAB = GUICtrlCreateLabel(GetTranslated(608,3, "Attack on")&":", $x, $y + 5, -1, -1)
$cmbDeployAB = GUICtrlCreateCombo("", $x + 55, $y, 120, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(608,4, -1) & @CRLF & GetTranslated(608,5, -1) & @CRLF & GetTranslated(608,6, -1) & @CRLF & GetTranslated(608,29, "Attack on the single side closest to the Dark Elixir Storage") & @CRLF & GetTranslated(608,30, "Attack on the single side closest to the Townhall"), GetTranslated(608,7, -1))
GUICtrlSetData(-1, GetTranslated(608,8, -1) & "|" & GetTranslated(608,9, -1) & "|" & GetTranslated(608,10, -1) & "|" & GetTranslated(608,11, -1) & "|" & GetTranslated(608,31, "DE Side Attack") & "|" & GetTranslated(608,32, "TH Side Attack"), GetTranslated(608,11, -1))
$y += 25
$lblUnitDelayAB = GUICtrlCreateLabel(GetTranslated(608,12, -1) & ":", $x, $y + 5, -1, -1)
$txtTip = GetTranslated(608,13, -1) & @CRLF & GetTranslated(608,14, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbUnitDelayAB = GUICtrlCreateCombo("", $x + 55, $y, 36, 21, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
$lblWaveDelayAB = GUICtrlCreateLabel(GetTranslated(608,15, -1) & ":", $x + 100, $y + 5, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbWaveDelayAB = GUICtrlCreateCombo("", $x + 140, $y, 36, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10", "4")
$y += 22
$chkRandomSpeedAtkAB = GUICtrlCreateCheckbox(GetTranslated(608,16, -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkRandomSpeedAtkAB")
$y +=22
$chkSmartAttackRedAreaAB = GUICtrlCreateCheckbox(GetTranslated(608,17, -1), $x, $y, -1, -1)
$txtTip = GetTranslated(608,18, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkSmartAttackRedAreaAB")
$y += 22
$lblSmartDeployAB = GUICtrlCreateLabel(GetTranslated(608,19, -1) & ":", $x, $y + 5, -1, -1)
$txtTip = GetTranslated(608,20, -1) & @CRLF & GetTranslated(608,21, -1) & @CRLF & GetTranslated(608,22, -1)
_GUICtrlSetTip(-1, $txtTip)
$cmbSmartDeployAB = GUICtrlCreateCombo("", $x + 55, $y, 120, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(608,23, -1) & "|" & GetTranslated(608,24, -1) , GetTranslated(608,23, -1))
_GUICtrlSetTip(-1, $txtTip)
$y += 26
$chkAttackNearGoldMineAB = GUICtrlCreateCheckbox("", $x + 20, $y, 17, 17)
$txtTip = GetTranslated(608,26, -1)
_GUICtrlSetTip(-1, $txtTip)
$picAttackNearGoldMineAB = GUICtrlCreateIcon($pIconLib, $eIcnMine, $x + 40 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$x += 75
$chkAttackNearElixirCollectorAB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(608,27, -1)
_GUICtrlSetTip(-1, $txtTip)
$picAttackNearElixirCollectorAB = GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 20 , $y - 3 , 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$x += 55
$chkAttackNearDarkElixirDrillAB = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(608,28, -1)
_GUICtrlSetTip(-1, $txtTip)
$picAttackNearDarkElixirDrillAB = GUICtrlCreateIcon($pIconLib, $eIcnDrill, $x + 20 , $y - 3, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
Global $cmbScriptNameAB, $lblNotesScriptAB
$hGUI_ACTIVEBASE_ATTACK_SCRIPTED = GUICreate("", $_GUI_MAIN_WIDTH - 195, $_GUI_MAIN_HEIGHT - 344, 150, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_ACTIVEBASE)
Local $x = 25, $y = 20
$grpAttackCSVAB = GUICtrlCreateGroup(GetTranslated(607,1, -1), $x - 20, $y - 20, 270, 306)
$chkmakeIMGCSVAB = GUICtrlCreateCheckbox(GetTranslated(607,2, -1), $x + 150, $y, -1, -1)
$txtTip = GetTranslated(607,3, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, $txtTip)
$y +=15
$cmbScriptNameAB=GUICtrlCreateCombo("", $x , $y, 185, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(607,4, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "cmbScriptNameAB")
$picreloadScriptsAB = GUICtrlCreateIcon($pIconLib, $eIcnReload, $x + 192, $y + 2, 16, 16)
$txtTip =  GetTranslated(607,5, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, 'UpdateComboScriptNameAB')
$y +=25
$lblNotesScriptAB =  GUICtrlCreateLabel("", $x, $y + 5, 180, 118)
PopulateComboScriptsFilesAB()
$picreloadScriptsAB = GUICtrlCreateIcon($pIconLib, $eIcnEdit, $x + 192, $y + 2, 16, 16)
$txtTip =  GetTranslated(607,6, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "EditScriptAB")
$y +=25
$picnewScriptsAB = GUICtrlCreateIcon($pIconLib, $eIcnAddcvs, $x + 192, $y + 2, 16, 16)
$txtTip =  GetTranslated(607,7, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "NewScriptAB")
$y +=25
$picduplicateScriptsAB = GUICtrlCreateIcon($pIconLib, $eIcnCopy, $x + 192, $y + 2, 16, 16)
$txtTip =  GetTranslated(607,8, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "DuplicateScriptAB")
GUICtrlCreateGroup("", -99, -99, 1, 1)
UpdateComboScriptNameAB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($cmbScriptNameAB, $scmbABScriptName)
If $tempindex = -1 Then 	$tempindex = 0
_GUICtrlComboBox_SetCurSel($cmbScriptNameAB, $tempindex)
GUISwitch($hGUI_ACTIVEBASE)
$hGUI_ACTIVEBASE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_ACTIVEBASE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,28,"Search"))
Local $x = 25, $y = 45
$grpABActivate = GUICtrlCreateGroup(GetTranslated(625,0, -1), $x - 20, $y - 20, 190, 305)
$x -= 15
$chkABActivateSearches = GUICtrlCreateCheckbox(GetTranslated(625,1, -1), $x, $y, 68, 18)
$txtTip = GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkABActivateSearches")
$txtABSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,2, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$lblABSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$txtABSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,3, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picABSearches = GUICtrlCreateIcon($pIconLib, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y +=21
$chkABActivateTropies = GUICtrlCreateCheckbox(GetTranslated(625,4, -1), $x, $y, 68, 18)
$txtTip = GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABActivateTropies")
$txtABTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTip = GetTranslated(625,5, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$lblABTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$txtABTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTip = GetTranslated(625,6, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picABTrophies = GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y +=21
$chkABActivateCamps = GUICtrlCreateCheckbox(GetTranslated(625,7, -1), $x, $y, 110, 18)
$txtTip = GetTranslated(625,8, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABActivateCamps")
$lblABArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
$txtABArmyCamps = GUICtrlCreateInput("100", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
$txtABArmyCampsPerc = GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$y +=23
$picABHeroesWait = GUICtrlCreateIcon($pIconLib, $eIcnHourGlass, $x - 1, $y + 3, 16, 16)
$txtABHeroesWait = GUICtrlCreateLabel(GetTranslated(625,9, -1) & ":", $x + 20, $y + 4, 180, 18)
$y += 20
$x += 20
$chkABKingWait = GUICtrlCreateCheckbox("", $x , $y + 55, 16, 16)
$txtTip = GetTranslated(625,10, -1) & @CRLF & GetTranslated(625, 50, -1) & @CRLF & GetTranslated(625, 65, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABKingWait")
$IMGchkABKingWait=GUICtrlCreateIcon($pIconLib, $eIcnKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
$IMGchkABKingSleepWait=GUICtrlCreateIcon($pIconLib, $eIcnSleepingKing, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 55
$chkABQueenWait = GUICtrlCreateCheckbox("", $x , $y + 55, 16, 16)
$txtTip = GetTranslated(625,12, -1) & @CRLF & GetTranslated(625, 50, -1) & @CRLF & GetTranslated(625, 66, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABQueenWait")
$IMGchkABQueenWait=GUICtrlCreateIcon($pIconLib, $eIcnQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
$IMGchkABQueenSleepWait=GUICtrlCreateIcon($pIconLib, $eIcnSleepingQueen, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$x += 55
$chkABWardenWait = GUICtrlCreateCheckbox("", $x , $y + 55, 16, 16)
$txtTip = GetTranslated(625,13, -1) & @CRLF & GetTranslated(625, 50, -1) & @CRLF & GetTranslated(625, 67, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABWardenWait")
$IMGchkABWardenWait=GUICtrlCreateIcon($pIconLib, $eIcnWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
$IMGchkABWardenSleepWait=GUICtrlCreateIcon($pIconLib, $eIcnSleepingWarden, $x - 18, $y + 4, 48, 48)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_HIDE)
$y += 80
$x = 8
$IMGchkABLightSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnLightSpell, $x, $y, 22, 22)
$IMGchkABHealSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnHealSpell, $x+23, $y, 22, 22)
$IMGchkABRageSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnRageSpell, $x+46, $y, 22, 22)
$IMGchkABJumpSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnJumpSpell , $x+69, $y, 22, 22)
$IMGchkABFreezeSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnFreezeSpell , $x+92, $y, 22, 22)
$IMGchkABPoisonSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnPoisonSpell , $x+115, $y, 22, 22)
$IMGchkABEarthquakeSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnEarthquakeSpell , $x+138, $y, 22, 22)
$IMGchkABHasteSpellWait = GUICtrlCreateIcon($pIconLib, $eIcnHasteSpell, $x+161, $y, 22, 22)
$y += 22
$x = 10
$x = 10
$chkABSpellsWait = GUICtrlCreateCheckbox("Wait for Spells to be Ready", $x, $y, -1, -1)
$txtTip = GetTranslated(625,100, -1) & @CRLF &  GetTranslated(625,101, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABSpellsWait")
$chkABWaitForCastleSpell = GUICtrlCreateCheckbox("Wait to get Castle Spell", $x, $y + 25, -1, -1)
$txtTip = "Wait until Someone Donate you an Spell"
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABWaitForCCSpell")
$cmbABWaitForCastleSpell = GUICtrlCreateCombo("Any", $x, $y + 50, -1, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = "Wait until Someone Donate this Spell, Else remove other spells in Castle and Request AGAIN"
GUICtrlSetData(-1, "Poison|EarthQuake|Haste|Skeleton")
_GUICtrlSetTip(-1, $txtTip)
$chkABWaitForCastleTroops = GUICtrlCreateCheckbox("Wait to for Castle to be full", $x, $y + 75, -1, -1)
$txtTip = "Wait until your Clan Castle be Full"
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$grpABFilter = GUICtrlCreateGroup(GetTranslated(625,14, -1), $x - 20, $y - 20, 225, 305)
$x -= 15
$cmbABMeetGE = GUICtrlCreateCombo("", $x , $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,15, -1) & @CRLF & GetTranslated(625,16, -1) & @CRLF & GetTranslated(625,17, -1) & @CRLF & GetTranslated(625,18, -1)
GUICtrlSetData(-1, GetTranslated(625,19, -1) &"|" & GetTranslated(625,20, -1) & "|" & GetTranslated(625,21, -1), GetTranslated(625,19, -1))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "cmbABGoldElixir")
$txtABMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,23, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picABMinGold = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$txtABMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,24, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picABMinElixir = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y -= 11
$txtABMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,25, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState (-1, $GUI_HIDE)
$picABMinGPEGold = GUICtrlCreateIcon($pIconLib, $eIcnGoldElixir, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState (-1, $GUI_HIDE)
$y += 34
$chkABMeetDE = GUICtrlCreateCheckbox(GetTranslated(625,26, -1), $x, $y, -1, -1)
$txtTip = GetTranslated(625,27, -1)
GUICtrlSetOnEvent(-1, "chkABMeetDE")
_GUICtrlSetTip(-1, $txtTip)
$txtABMinDarkElixir = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,28, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$picABMinDarkElixir = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$chkABMeetTrophy = GUICtrlCreateCheckbox(GetTranslated(625,4, -1), $x, $y, -1, -1)
$txtTip = GetTranslated(625,29, -1)
GUICtrlSetOnEvent(-1, "chkABMeetTrophy")
_GUICtrlSetTip(-1, $txtTip)
$txtABMinTrophy = GUICtrlCreateInput("0", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,30, -1)
_GUICtrlSetTip(-1, $txtTip)
_GUICtrlEdit_SetReadOnly(-1, True)
GUICtrlSetLimit(-1, 2)
$picABMinTrophies = GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$chkABMeetTH = GUICtrlCreateCheckbox(GetTranslated(625,31, -1), $x, $y, -1, -1)
$txtTip = GetTranslated(625,32, -1)
GUICtrlSetOnEvent(-1, "chkABMeetTH")
_GUICtrlSetTip(-1, $txtTip)
$cmbABTH = GUICtrlCreateCombo("", $x + 85, $y - 1, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,33, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetData(-1, "4-6|7|8|9|10|11", "4-6")
$picABMaxTH10 = GUICtrlCreateIcon($pIconLib, $eIcnTH10, $x + 137, $y - 3, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$chkABMeetTHO = GUICtrlCreateCheckbox(GetTranslated(625,34, -1), $x, $y, -1, -1)
$txtTip = GetTranslated(625,35, -1)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
GUICtrlCreateGroup("Weak base | max defenses", $x, $y, 215, 100)
$x += 5
$y += 20
$xStarColumn = $x
$yStartColumn = $y
$chkMaxMortar[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,59, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$cmbWeakMortar[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,38, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8", "Lvl 5")
GUICtrlSetState(-1, $GUI_DISABLE)
$picABWeakMortar = GUICtrlCreateIcon($pIconLib, $eIcnMortar, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y +=24
$chkMaxWizTower[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,60, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$cmbWeakWizTower[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,39, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8|Lvl 9", "Lvl 4")
GUICtrlSetState(-1, $GUI_DISABLE)
$picABWeakWizTower = GUICtrlCreateIcon($pIconLib, $eIcnWizTower, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$chkMaxAirDefense[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = "Search for a base that has Air Defense below this level"
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$cmbWeakAirDefense[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = "Set the Max. level of the Air Defense to search for on a village to attack."
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4|Lvl 5|Lvl 6|Lvl 7|Lvl 8", "Lvl 7")
GUICtrlSetState(-1, $GUI_DISABLE)
$picABWeakAirDefense = GUICtrlCreateIcon($pIconLib, $eIcnAirDefense, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$x = $xStarColumn + 104
$y = $yStartColumn
$chkMaxXBow[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,61, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$cmbWeakXBow[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,51, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3|Lvl 4", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$picABWeakXBow = GUICtrlCreateIcon($pIconLib, $eIcnXBow3, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y +=24
$chkMaxInferno[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,62, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$cmbWeakInferno[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,52, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2|Lvl 3", "Lvl 2")
GUICtrlSetState(-1, $GUI_DISABLE)
$picABWeakInferno = GUICtrlCreateIcon($pIconLib, $eIcnInferno4, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y +=24
$chkMaxEagle[$LB] = GUICtrlCreateCheckbox("", $x, $y, 17, 17)
$txtTip = GetTranslated(625,63, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABWeakBase")
$cmbWeakEagle[$LB] = GUICtrlCreateCombo("", $x + 19, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,53, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "-|Lvl 1|Lvl 2", "Lvl 1")
GUICtrlSetState(-1, $GUI_DISABLE)
$picABWeakEagle = GUICtrlCreateIcon($pIconLib, $eIcnEagleArt, $x + 75, $y - 2, 24, 24)
_GUICtrlSetTip(-1, $txtTip)
$y += 44
$x = $xStarColumn
$chkABMeetOne = GUICtrlCreateCheckbox(GetTranslated(625,40, -1), $x, $y, -1, -1)
$txtTip = GetTranslated(625,41, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_ACTIVEBASE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,29,"Attack"))
Local $x = 25, $y = 40
$grpABAttack = GUICtrlCreateGroup(GetTranslated(624,1, -1), $x - 20, $y - 15, 145, 223)
$x -= 15
$lblABAlgorithm = GUICtrlCreateLabel(GetTranslated(624,2, -1) & ":",  $x, $y, 135, 18,$SS_LEFT)
$y += 15
$cmbABAlgorithm = GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, "")
GUICtrlSetData(-1, GetTranslated(624,3, -1) & "|" & GetTranslated(624,4, -1) , GetTranslated(624,3,-1))
GUICtrlSetOnEvent(-1, "cmbABAlgorithm")
$y += 25
$lblABSelectTroop=GUICtrlCreateLabel(GetTranslated(624,6, -1) & ":", $x, $y, 135, 18,$SS_LEFT)
$y += 15
$cmbABSelectTroop=GUICtrlCreateCombo("", $x, $y, 135, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(624,7, -1) & "|" & GetTranslated(624,8, -1) & "|" & GetTranslated(624,9, -1) & "|" & GetTranslated(624,10, -1) & "|" & GetTranslated(624,11, -1) & "|" & GetTranslated(624,12, -1) & "|" & GetTranslated(624,13, -1) & "|" & GetTranslated(624,14, -1) & "|" & GetTranslated(624,15, -1) & "|" & GetTranslated(624,16, -1) & "|" & GetTranslated(624,17, -1), GetTranslated(624,7, -1))
_GUICtrlSetTip(-1, GetTranslated(624,18, -1))
$y += 25
$lblABSelectSpecialTroop=GUICtrlCreateLabel(GetTranslated(624,19, -1) & ":",$x, $y, 135, 18, $SS_LEFT)
$y += 18
$IMGchkABKingAttack=GUICtrlCreateIcon($pIconLib, $eIcnKing, $x , $y, 24, 24)
$txtTip = GetTranslated(624,20, -1) & @CRLF & GetTranslated(624, 41, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x += 46
$IMGchkABQueenAttack=GUICtrlCreateIcon($pIconLib, $eIcnQueen, $x, $y, 24, 24)
$txtTip = GetTranslated(624,21, -1) & @CRLF & GetTranslated(624, 42, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkABWardenAttack=GUICtrlCreateIcon($pIconLib, $eIcnWarden, $x, $y, 24, 24)
$txtTip = GetTranslated(624,22, -1) & @CRLF & GetTranslated(624, 43, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y +=27
$x -=92
$IMGchkABDropCC=GUICtrlCreateIcon($pIconLib, $eIcnCC, $x, $y, 24, 24)
$txtTip = GetTranslated(624,23, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x += 46
$IMGchkABLightSpell=GUICtrlCreateIcon($pIconLib, $eIcnLightSpell, $x, $y, 24, 24)
$txtTip = GetTranslated(624,24, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkABHealSpell=GUICtrlCreateIcon($pIconLib, $eIcnHealSpell, $x, $y, 24, 24)
$txtTip = GetTranslated(624,25, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y +=27
$x -=92
$IMGchkABRageSpell=GUICtrlCreateIcon($pIconLib, $eIcnRageSpell, $x, $y, 24, 24)
$txtTip = GetTranslated(624,26, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkABJumpSpell=GUICtrlCreateIcon($pIconLib, $eIcnJumpSpell , $x, $y, 24, 24)
$txtTip =GetTranslated(624,27, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x += 46
$IMGchkABFreezeSpell=GUICtrlCreateIcon($pIconLib, $eIcnFreezeSpell , $x, $y, 24, 24)
$txtTip = GetTranslated(624,28, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y +=27
$x -=92
$IMGchkABPoisonSpell=GUICtrlCreateIcon($pIconLib, $eIcnPoisonSpell , $x, $y, 24, 24)
$txtTip = GetTranslated(624,29, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkABEarthquakeSpell=GUICtrlCreateIcon($pIconLib, $eIcnEarthquakeSpell , $x, $y, 24, 24)
$txtTip = GetTranslated(624,30, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkABHasteSpell=GUICtrlCreateIcon($pIconLib, $eIcnHasteSpell, $x, $y, 24, 24)
$txtTip =GetTranslated(624,31, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkABHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 10, $y = 268
$grpTSAttackBeforeAB = GUICtrlCreateGroup(GetTranslated(624,32, -1),  $x - 5, $y - 20, 145, 84,$SS_CENTER)
$chkTHSnipeBeforeLBEnable = GUICtrlCreateCheckbox(GetTranslated(624,33, -1) ,$x, $y - 5, -1, -1)
$txtTip = GetTranslated(624,34, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkTHSnipeBeforeLBEnable")
$y += 16
$lblTHSnipeBeforeLBTiles = GUICtrlCreateLabel(GetTranslated(624,35, -1)& ":", $x, $y + 3, 70, -1, $SS_RIGHT)
GUICtrlSetState(-1, $GUI_DISABLE)
$txtTHSnipeBeforeLBTiles = GUICtrlCreateInput("2", $x + 75, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(624,36, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$picTHSnipeBeforeLBTiles = GUICtrlCreateIcon($pIconLib, $eIcnTiles, $x + 107, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$cmbTHSnipeBeforeLBScript = GUICtrlCreateCombo("",  $x, $y, 130, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
$txtTip = GetTranslated(624,37, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
LoadABSnipeAttacks()
_GUICtrlComboBox_SetCurSel($cmbTHSnipeBeforeLBScript,_GUICtrlComboBox_FindStringExact($cmbTHSnipeBeforeLBScript, "Bam"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_ACTIVEBASE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,30,"End Battle"))
Local $x = 10, $y = 45
$grpABEndBattle = GUICtrlCreateGroup(GetTranslated(606,1, -1),  $x - 5, $y - 20, 155, 305)
$y -=5
$chkABTimeStopAtk = GUICtrlCreateCheckbox(GetTranslated(606,2, -1) ,$x, $y, -1, -1)
$txtTip = GetTranslated(606,3, -1) & @CRLF & GetTranslated(606,4, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABTimeStopAtk")
GUICtrlSetState(-1, $GUI_CHECKED)
$y +=20
$lblABTimeStopAtka = GUICtrlCreateLabel(GetTranslated(606,5, -1)& ":", $x + 16, $y + 3, -1, -1)
$txtABTimeStopAtk = GUICtrlCreateInput("20", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
$lblABTimeStopAtk = GUICtrlCreateLabel(GetTranslated(603,6, -1), $x + 120, $y + 3, -1, -1)
$y += 20
$chkABTimeStopAtk2 = GUICtrlCreateCheckbox(GetTranslated(606,2, -1) ,$x, $y, -1, -1)
$txtTip = GetTranslated(606,3, -1) & @CRLF & GetTranslated(606,4, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkABTimeStopAtk2")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$lblABTimeStopAtk2a = GUICtrlCreateLabel(GetTranslated(606,5, -1)& ":", $x + 16, $y + 3, -1, -1)
$txtABTimeStopAtk2 = GUICtrlCreateInput("5", $x + 85, $y + 1, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$lblABTimeStopAtk2 = GUICtrlCreateLabel(GetTranslated(603,6, -1), $x + 120, $y + 3, -1, -1)
$y += 21
$lblABMinRerourcesAtk2 = GUICtrlCreateLabel(GetTranslated(606,7, -1) & ":", $x + 16 , $y + 2, -1, -1)
$txtTip = GetTranslated(606,8, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 21
$txtABMinGoldStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$picABMinGoldStopAtk2 = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$txtABMinElixirStopAtk2 = GUICtrlCreateInput("2000", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState(-1, $GUI_DISABLE)
$picABMinElixirStopAtk2 = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$txtABMinDarkElixirStopAtk2 = GUICtrlCreateInput("50", $x + 65, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 4)
GUICtrlSetState(-1, $GUI_DISABLE)
$picABMinDarkElixirStopAtk2 = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 117, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$chkABEndNoResources = GUICtrlCreateCheckbox(GetTranslated(606,9, -1), $x , $y , -1, -1)
$txtTip = GetTranslated(606,10, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$chkABEndOneStar = GUICtrlCreateCheckbox(GetTranslated(606,11, -1) , $x, $y , -1, -1)
$txtTip = GetTranslated(606,12, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_ENABLE)
$y += 21
$chkABEndTwoStars = GUICtrlCreateCheckbox(GetTranslated(606,13,-1) , $x, $y, -1, -1)
$txtTip = GetTranslated(606,14, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_ENABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 185, $y = 45
Global $grpDEside , $chkDESideEB ,$txtDELowEndMin  , $lblDELowEndMin , $chkDisableOtherEBO , $chkDEEndOneStar , $chkDEEndBk ,$lblDEEndBk  ,$chkDEEndAq  , $lblDEEndAq
$grpDEside = GUICtrlCreateGroup(GetTranslated(606,15,"DE side End Battle options"), $x - 20, $y - 20, 259, 305)
GUICtrlCreateLabel(GetTranslated(606,16, "Attack Dark Elixir Side, End Battle Options") & ":", $x - 10, $y , -1, -1)
$txtTip = GetTranslated(606,17, "Enabled by selecting DE side attack in LiveBase Deploy - Attack On: options")
_GUICtrlSetTip(-1, $txtTip)
$y += 15
$x -= 10
$chkDESideEB = GUICtrlCreateCheckbox(GetTranslated(606,18, "When below") & ":", $x , $y , -1, -1)
$txtTip = GetTranslated(606,19, "Enables Special conditions for Dark Elixir side attack.") & @CRLF & GetTranslated(606,20, "If no additional filters are selected will end battle when below Total Dark Elixir Percent.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDESideEB")
$txtDELowEndMin = GUICtrlCreateInput("25", $x + 92, $y , 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState(-1, $GUI_DISABLE)
$lblDELowEndMin = GUICtrlCreateLabel("%", $x + 136 , $y + 2 , -1, -1)
GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 147, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 20
$chkDisableOtherEBO = GUICtrlCreateCheckbox(GetTranslated(606,21, "Disable Normal End Battle Options"), $x, $y, -1, -1)
$txtTip = GetTranslated(606,22, "Disable Normal End Battle Options when DE side attack is found.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 20
$chkDEEndOneStar = GUICtrlCreateCheckbox(GetTranslated(606,11, -1) & ":", $x, $y , -1, -1)
$txtTip = GetTranslated(606,23, "Will End the Battle when below min DE and One Star is won.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($pIconLib, $eIcnSilverStar, $x + 135, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 20
$chkDEEndBk = GUICtrlCreateCheckbox(GetTranslated(606,24, "When"), $x, $y , -1, -1)
$txtTip = GetTranslated(606,25, "Will End the Battle when below min DE and King is weak")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($pIconLib, $eIcnKing, $x + 50, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$lblDEEndBk = GUICtrlCreateLabel(GetTranslated(606,26, "is weak"), $x + 70, $y + 4, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$y += 20
$chkDEEndAq = GUICtrlCreateCheckbox(GetTranslated(606,24, -1), $x, $y , -1, -1)
$txtTip = GetTranslated(606,27, "Will End the Battle when below min DE and Queen is weak")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($pIconLib, $eIcnQueen, $x + 50, $y + 2, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$lblDEEndAq = GUICtrlCreateLabel(GetTranslated(606,26, -1), $x + 70, $y + 4, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_THSNIPE = GUICreate("", $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_SEARCH)
GUISwitch($hGUI_THSNIPE)
$hGUI_THSNIPE_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_THSNIPE_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,28,"Search"))
Local $x = 25, $y = 45
$grpTSActivate = GUICtrlCreateGroup(GetTranslated(625,0, -1), $x - 20, $y - 20, 190, 305)
$x -= 15
$chkTSActivateSearches = GUICtrlCreateCheckbox(GetTranslated(625,1, -1), $x, $y, 68, 18)
$txtTip = GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkTSActivateSearches")
$txtTSSearchesMin = GUICtrlCreateInput("1", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,2, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$lblTSSearches = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
$txtTSSearchesMax = GUICtrlCreateInput("9999", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,3, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,69,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picTSSearches = GUICtrlCreateIcon($pIconLib, $eIcnMagnifier, $x + 163, $y + 1, 16, 16)
$y +=21
$chkTSActivateTropies = GUICtrlCreateCheckbox(GetTranslated(625,4, -1), $x, $y, 68, 18)
$txtTip = GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkTSActivateTropies")
$txtTSTropiesMin = GUICtrlCreateInput("0", $x + 70, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTip = GetTranslated(625,5, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$lblTSTropies = GUICtrlCreateLabel("-", $x + 113, $y + 2, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTSTropiesMax = GUICtrlCreateInput("6000", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTip = GetTranslated(625,6, -1) & @CRLF & @CRLF & GetTranslated(625,68, -1) & @CRLF & GetTranslated(625,70,-1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picTSTrophies = GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 163, $y + 1, 16, 16)
$y +=21
$chkTSActivateCamps = GUICtrlCreateCheckbox(GetTranslated(625,7, -1), $x, $y, 110, 18)
$txtTip = GetTranslated(625,8, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkTSActivateCamps")
$lblTSArmyCamps = GUICtrlCreateLabel(ChrW(8805), $x + 113 - 1, $y + 2, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTSArmyCamps = GUICtrlCreateInput("50", $x + 120, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlSetLimit(-1, 6)
$txtTSArmyCampsPerc = GUICtrlCreateLabel("%", $x + 163 + 3, $y + 4, -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 220, $y = 45
$grpTSFilter = GUICtrlCreateGroup(GetTranslated(625,14, -1), $x - 20, $y - 20, 225, 305)
$x -= 15
$cmbTSMeetGE = GUICtrlCreateCombo("", $x , $y + 10, 65, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(625,15, -1) & @CRLF & GetTranslated(625,16, -1) & @CRLF & GetTranslated(625,17, -1) & @CRLF & GetTranslated(625,18, -1)
GUICtrlSetData(-1, GetTranslated(625,19, -1) &"|" & GetTranslated(625,20, -1) & "|" & GetTranslated(625,21, -1), GetTranslated(625,22, -1))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "cmbTSGoldElixir")
$txtTSMinGold = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,23, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picTSMinGold = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$txtTSMinElixir = GUICtrlCreateInput("80000", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,24, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picTSMinElixir = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y -= 11
$txtTSMinGoldPlusElixir = GUICtrlCreateInput("160000", $x + 85, $y, 50, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,25, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
GUICtrlSetState (-1, $GUI_HIDE)
$picTSMinGPEGold = GUICtrlCreateIcon($pIconLib, $eIcnGoldElixir, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState (-1, $GUI_HIDE)
$y += 34
$chkTSMeetDE = GUICtrlCreateCheckbox(GetTranslated(625,26, -1), $x, $y, -1, -1)
$txtTip = GetTranslated(625,27, -1)
GUICtrlSetOnEvent(-1, "chkTSMeetDE")
_GUICtrlSetTip(-1, $txtTip)
$txtTSMinDarkElixir = GUICtrlCreateInput("600", $x + 85, $y, 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(625,28, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 5)
_GUICtrlEdit_SetReadOnly(-1, True)
$picTSMinDarkElixir = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 137, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$y +=35
$lblAddTiles = GUICtrlCreateLabel(GetTranslated(625,42, "TownHall, Distance From") , $x , $y + 4, -1, -1, $SS_LEFT)
$y += 16
$lblAddTiles2 = GUICtrlCreateLabel(GetTranslated(625,43, "Border, Add Tiles") & ":" , $x+5 , $y + 4, -1, -1, $SS_LEFT)
$y += 21
$lblSWTTiles = GUICtrlCreateLabel("- " & GetTranslated(625,44, "While Train"), $x, $y + 4, 100, -1, $SS_LEFT)
$txtTip = GetTranslated(625,45, "Add number of tiles from Base Edges")
_GUICtrlSetTip(-1, $txtTip)
$txtSWTTiles = GUICtrlCreateInput("2", $x + 85, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 1)
$picSWTiles = GUICtrlCreateIcon($pIconLib, $eIcnTiles, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 24
$lblTHadd = GUICtrlCreateLabel("- " & GetTranslated(625,46, "Full Troops"), $x, $y + 4, -1, 17, $SS_LEFT)
$txtTip = GetTranslated(625,47, "Enter how many 'Grass' 1x1 tiles the TH may be from the Base edges to be seen as a TH Outside.") & @CRLF & GetTranslated(625,48, "Ex: (0) tiles; TH must be exactly at the edge. (4) tiles: TH may be 4 tiles farther from edges and closer to the center of the village.") & @CRLF & GetTranslated(625,49, "If the TH is farther away then the No. of tiles set, the base will be skipped.")
_GUICtrlSetTip(-1, $txtTip)
$txtTHaddtiles = GUICtrlCreateInput("2", $x + 85, $y , 50, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 1)
$picTHaddtiles = GUICtrlCreateIcon($pIconLib, $eIcnTiles, $x + 137, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_THSNIPE_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,29,"Attack"))
Local $x = 25, $y = 40
$grpTSAttack = GUICtrlCreateGroup(GetTranslated(624,1, -1), $x - 20, $y - 15, 420, 305)
$x -= 15
$lblAttackTHType = GUICtrlCreateLabel(GetTranslated(624,2, -1) & ":", $x  , $y  , 135, 18, $SS_LEFT)
$y += 15
$cmbAttackTHType = GUICtrlCreateCombo("",  $x, $y, 128, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "")
$txtTip = GetTranslated(624,37, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "cmbAttackTHType")
LoadThSnipeAttacks()
$y += 25
$lblTSSelectTroop=GUICtrlCreateLabel(GetTranslated(624,6,-1) & ":",$x, $y , 135 , 18,$SS_LEFT)
$y += 15
$cmbTSSelectTroop=GUICtrlCreateCombo("", $x , $y, 128, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(624,7, -1) & "|" & GetTranslated(624,8, -1) & "|" & GetTranslated(624,9, -1) & "|" & GetTranslated(624,10, -1) & "|" & GetTranslated(624,11, -1) & "|" & GetTranslated(624,12, -1) & "|" & GetTranslated(624,13, -1) & "|" & GetTranslated(624,14, -1) & "|" & GetTranslated(624,15, -1) & "|" & GetTranslated(624,16, -1) & "|" & GetTranslated(624,17, -1), GetTranslated(624,7, -1))
_GUICtrlSetTip(-1, GetTranslated(624,18, -1))
$y += 25
$lblTSSelectSpecialTroop=GUICtrlCreateLabel(GetTranslated(624,19, -1) & ":",$x, $y, 135, 18, $SS_LEFT)
$y += 18
$IMGchkTSKingAttack=GUICtrlCreateIcon($pIconLib, $eIcnKing, $x , $y, 24, 24)
$txtTip = GetTranslated(624,20, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSKingAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x += 46
$IMGchkTSQueenAttack=GUICtrlCreateIcon($pIconLib, $eIcnQueen, $x, $y, 24, 24)
$txtTip = GetTranslated(624,21, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSQueenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkTSWardenAttack=GUICtrlCreateIcon($pIconLib, $eIcnWarden, $x, $y, 24, 24)
$txtTip = GetTranslated(624,22, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSWardenAttack = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y +=27
$x -=92
$IMGchkTSDropCC=GUICtrlCreateIcon($pIconLib, $eIcnCC, $x, $y, 24, 24)
$txtTip =GetTranslated(624,23, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSDropCC = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x += 46
$IMGchkTSLightSpell=GUICtrlCreateIcon($pIconLib, $eIcnLightSpell, $x, $y, 24, 24)
$txtTip = GetTranslated(624,24, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSLightSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkTSHealSpell=GUICtrlCreateIcon($pIconLib, $eIcnHealSpell, $x, $y, 24, 24)
$txtTip = GetTranslated(624,25, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSHealSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y +=27
$x -=92
$IMGchkTSRageSpell=GUICtrlCreateIcon($pIconLib, $eIcnRageSpell, $x, $y, 24, 24)
$txtTip = GetTranslated(624,26, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSRageSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkTSJumpSpell=GUICtrlCreateIcon($pIconLib, $eIcnJumpSpell , $x, $y, 24, 24)
$txtTip =GetTranslated(624,27, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSJumpSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x += 46
$IMGchkTSFreezeSpell=GUICtrlCreateIcon($pIconLib, $eIcnFreezeSpell , $x, $y, 24, 24)
$txtTip = GetTranslated(624,28, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSFreezeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y +=27
$x -=92
$IMGchkTSPoisonSpell=GUICtrlCreateIcon($pIconLib, $eIcnPoisonSpell , $x, $y, 24, 24)
$txtTip = GetTranslated(624,29, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSPoisonSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkTSEarthquakeSpell=GUICtrlCreateIcon($pIconLib, $eIcnEarthquakeSpell , $x, $y, 24, 24)
$txtTip = GetTranslated(624,30, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSEarthquakeSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$x +=46
$IMGchkTSHasteSpell=GUICtrlCreateIcon($pIconLib, $eIcnHasteSpell, $x, $y, 24, 24)
$txtTip =GetTranslated(624,31, -1)
_GUICtrlSetTip(-1, $txtTip)
$chkTSHasteSpell = GUICtrlCreateCheckbox("", $x + 27, $y, 17, 17)
_GUICtrlSetTip(-1, $txtTip)
$y += 30
$x = 30
$chkAttackTH = GUICtrlCreateCheckbox(GetTranslated(624,38, "Attack Townhall Outside"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(624,39, "Check this to Attack an exposed Townhall first. (Townhall outside of Walls)") & @CRLF & GetTranslated(624,40, "TIP: Also tick 'Meet Townhall Outside' on the Search tab if you only want to search for bases with exposed Townhalls."))
GUICtrlSetState(-1,$GUI_HIDE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_THSNIPE_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,30,"End Battle"))
Local $x = 10, $y = 45
$grpTSEndBattle = GUICtrlCreateGroup(GetTranslated(606,1, -1),  $x - 5, $y - 20, 420, 305)
$lblTSAttackConfigure2=GUICtrlCreateLabel(GetTranslated(606,28,"Switch DB Attack at END") & ":",$x, $y , 143 , 18,$SS_LEFT)
$y += 15
$chkTSActivateCamps2 = GUICtrlCreateCheckbox("",$x+2,$y+3,16,16)
GUICtrlSetOnEvent(-1, "chkTSActivateCamps2")
$lblTSArmyCamps2 = GUICtrlCreateLabel("Camps >=", $x +20 , $y +4 , -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTSArmyCamps2 = GUICtrlCreateInput("50", $x + 75, $y, 35, 20, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetState(-1,$GUI_DISABLE)
$txtTip = GetTranslated(606,29, "Set the % Army camps before activate this option")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$lblTSArmyCamps2_1 = GUICtrlCreateLabel("%", $x+115 , $y +4 , -1, -1)
GUICtrlSetState(-1,$GUI_DISABLE)
$y +=26
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_AttackOption = GUICreate("", $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_SEARCH)
$hGUI_AttackOption_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 40, $_GUI_MAIN_HEIGHT - 315, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_AttackOption_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,28,"Search"))
Global $txtSearchReduceCount, $txtSearchReduceGold,$txtSearchReduceElixir, $txtSearchReduceGoldPlusElixir,  $txtSearchReduceDark, $txtSearchReduceTrophy
Local $x = 25, $y = 45
$grpSearchReduction = GUICtrlCreateGroup(GetTranslated(630,1, "Search Reduction"), $x - 20, $y - 20, 223, 165)
$x -=13
$chkSearchReduction = GUICtrlCreateCheckbox(GetTranslated(630,2, "Enable Search Reduction") , $x , $y-4, -1, -1)
$txtTip = GetTranslated(630,3, "Check this if you want the search values to automatically be lowered after a certain amount of searches.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkSearchReduction")
$y+=15
$lblSearchReduceCount = GUICtrlCreateLabel(GetTranslated(630,4, "Reduce targets every"), $x , $y + 3, -1, -1)
$txtSearchReduceCount = GUICtrlCreateInput("20", $x +115, $y + 2, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(630,5, "Enter the No. of searches to wait before each reduction occurs.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 3)
$lblSearchReduceCount2 = GUICtrlCreateLabel(GetTranslated(603,5, "search(es)."), $x + 160 , $y + 3, -1, -1)
$y += 21
$lblSearchReduceGold = GUICtrlCreateLabel(GetTranslated(630,6,"- Reduce Gold"), $x, $y + 3, -1, 17)
$txtTip = GetTranslated(630,7, "Lower value for Gold by this amount on each step.")
_GUICtrlSetTip(-1, $txtTip)
$txtSearchReduceGold = GUICtrlCreateInput("2000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 5)
$picSearchReduceGold = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$lblSearchReduceElixir = GUICtrlCreateLabel(GetTranslated(630,8,"- Reduce Elixir"), $x, $y + 3, -1, 17)
$txtTip = GetTranslated(630,9, "Lower value for Elixir by this amount on each step.")
_GUICtrlSetTip(-1, $txtTip)
$txtSearchReduceElixir = GUICtrlCreateInput("2000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 5)
$picSearchReduceElixir = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y +=21
$lblSearchReduceGoldPlusElixir = GUICtrlCreateLabel(GetTranslated(630,10,"- Reduce Gold + Elixir"), $x, $y + 3, -1, 17)
$txtTip = GetTranslated(630,11, "Lower total sum for G+E by this amount on each step.")
_GUICtrlSetTip(-1, $txtTip)
$txtSearchReduceGoldPlusElixir = GUICtrlCreateInput("4000", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 5)
$picSearchReduceGPEGold = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 160, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$lblSearchReduceGPE = GUICtrlCreateLabel("+", $x + 176, $y + 1, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
$picSearchReduceGPEElixir = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 182, $y + 1, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$lblSearchReduceDark = GUICtrlCreateLabel(GetTranslated(630,12,"- Reduce Dark Elixir"), $x, $y + 3, -1, 17)
$txtTip = GetTranslated(630,13, "Lower value for Dark Elixir by this amount on each step.")
_GUICtrlSetTip(-1, $txtTip)
$txtSearchReduceDark = GUICtrlCreateInput("100", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 3)
$picSearchReduceDark = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
$y += 21
$lblSearchReduceTrophy = GUICtrlCreateLabel(GetTranslated(630,14,"- Reduce Tropies"), $x, $y + 3, -1, 17)
$txtTip = GetTranslated(630,15, "Lower value for Trophies by this amount on each step.")
_GUICtrlSetTip(-1, $txtTip)
$txtSearchReduceTrophy = GUICtrlCreateInput("2", $x + 115, $y, 40, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 1)
$picSearchReduceTrophy = GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 160, $y, 16, 16)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 25
$y = 212
$grpVSDelay = GUICtrlCreateGroup(GetTranslated(636,75, "Village Search Delay"), $x - 20, $y - 20, 223, 72)
$txtTip = GetTranslated(636,76, "Use this slider to change the time to wait between Next clicks when searching for a Village to Attack.") & @CRLF & GetTranslated(636,77, "This might compensate for Out of Sync errors on some PC's.") & @CRLF & GetTranslated(636,78, "NO GUARANTEES! This will not always have the same results!")
$lblVSDelay0 = GUICtrlCreateLabel(GetTranslated(603,9, -1), $x-14, $y-2, 19, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $txtTip)
$lblVSDelay = GUICtrlCreateLabel("0", $x+7, $y-2, 12, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $txtTip)
$lbltxtVSDelay = GUICtrlCreateLabel(GetTranslated(603,8, "seconds"), $x + 23, $y-2, -1, -1)
$sldVSDelay = GUICtrlCreateSlider($x + 70, $y - 4, 105, 25, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, $txtTip)
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 12, 0)
GUICtrlSetData(-1, 1)
GUICtrlSetOnEvent(-1, "sldVSDelay")
$y += 25
$lblMaxVSDelay0 = GUICtrlCreateLabel(GetTranslated(636,80, "Max"), $x-12, $y-2, 19, 15, $SS_RIGHT)
$txtTip = GetTranslated(636,81, "Enable random village search delay value by setting") & @CRLF & GetTranslated(636,82, "bottom Max slide value higher than the top minimum slide")
_GUICtrlSetTip(-1, $txtTip)
$lblMaxVSDelay = GUICtrlCreateLabel("0", $x+7, $y-2, 12, 15, $SS_RIGHT)
_GUICtrlSetTip(-1, $txtTip)
$lbltxtMaxVSDelay = GUICtrlCreateLabel(GetTranslated(603,8, -1), $x + 23, $y-2, 45, -1)
$sldMaxVSDelay = GUICtrlCreateSlider($x + 70, $y - 4, 125, 25, BITOR($TBS_TOOLTIPS, $TBS_AUTOTICKS))
_GUICtrlSetTip(-1, $txtTip)
_GUICtrlSlider_SetTipSide(-1, $TBTS_BOTTOM)
_GUICtrlSlider_SetTicFreq(-1, 1)
GUICtrlSetLimit(-1, 15, 0)
GUICtrlSetData(-1, 4)
GUICtrlSetOnEvent(-1, "sldMaxVSDelay")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = 253
$y = 45
$grpAtkOptions = GUICtrlCreateGroup(GetTranslated(630,16, "Search Options"), $x - 20, $y - 20, 189, 165)
$x -= 5
$chkAttackNow = GUICtrlCreateCheckbox(GetTranslated(630,17, "Attack Now! option."), $x-5, $y -8, -1, -1)
$txtTip = GetTranslated(630,18, "Check this if you want the option to have an 'Attack Now!' button next to") & @CRLF & GetTranslated(630,25, "the Start and Pause buttons to bypass the dead base or all base search values.") & @CRLF & GetTranslated(630,26, "The Attack Now! button will only appear when searching for villages to Attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkAttackNow")
$lblAttackNow = GUICtrlCreateLabel(GetTranslated(630,19, "Add") & ":", $x +10 , $y + 16, 27, -1, $SS_RIGHT)
$txtTip = GetTranslated(630,20, "Add this amount of reaction time to slow down the search.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$cmbAttackNowDelay = GUICtrlCreateCombo("", $x + 45, $y + 13, 35, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "0|1|2|3|4|5", "3")
GUICtrlSetState(-1, $GUI_DISABLE)
$lblAttackNowSec = GUICtrlCreateLabel(GetTranslated(603,6, "sec."), $x + 85, $y + 16, -1, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
$y += 45
$chkRestartSearchLimit = GUICtrlCreateCheckbox( GetTranslated(630,21, "Restart every") & ":", $x-5, $y-8, -1, -1)
$txtTip = GetTranslated(630,22, "Return To Base after x searches and restart to search enemy villages.")
Global $txtrestartsearchlimit, $chkbtnscheduler, $btnscheduler
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkRestartSearchLimit")
$txtRestartSearchlimit = GUICtrlCreateInput("50", $x+15, $y + 15, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 3)
$lblRestartSearchLimit = GUICtrlCreateLabel( GetTranslated(603,5, -1), $x + 47, $y + 17, -1, -1)
$y += 45
$chkAlertSearch = GUICtrlCreateCheckbox(GetTranslated(630,23, "Alert me when Village found"), $x-5, $y , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(630,24, "Check this if you want an Audio alarm & a Balloon Tip when a Base to attack is found."))
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_AttackOption_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,29,"Attack"))
Local $x = 25, $y = 45
$grpRoyalAbilitiesCSV = GUICtrlCreateGroup(GetTranslated(634,1, "Hero Abilities"), $x - 20, $y - 20, 420, 60)
GUICtrlCreateIcon($pIconLib, $eIcnKingAbility, $x-10, $y, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnQueenAbility, $x+ 15, $y, 24, 24)
GUICtrlCreateIcon($pIconLib, $eIcnWardenAbility, $x+ 40, $y, 24, 24)
$x += 70
$y -= 4
$radAutoAbilities = GUICtrlCreateRadio(GetTranslated(634,2, "Auto activate (red zone)"), $x, $y-4 , 160, -1)
$txtTip = GetTranslated(634,3, "Activate the Ability when the Hero becomes weak.") & @CRLF & GetTranslated(634,4, "Heroes are checked and activated individually.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 15
$radManAbilities = GUICtrlCreateRadio(GetTranslated(634,5, "Timed after") & ":", $x , $y , -1, -1)
$txtTip = GetTranslated(634,6, "Activate the Ability on a timer.") & @CRLF & GetTranslated(634,7, "All Heroes are activated at the same time.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$txtManAbilities = GUICtrlCreateInput("9", $x + 80, $y+3, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(634,8, "Set the time in seconds for Timed Activation of Hero Abilities.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
$lblRoyalAbilitiesSec = GUICtrlCreateLabel(GetTranslated(603,6, "sec."), $x + 115, $y + 4, -1, -1)
$y += 40
$chkUseWardenAbility = GUICtrlCreateCheckbox(GetTranslated(634,9, "Timed activation of Warden Ability after") & ":", $x, $y, -1, -1)
$txtTip = GetTranslated(634,10, "Use the ability of the Grand Warden on a timer.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED+$GUI_DISABLE+$GUI_HIDE)
GUICtrlSetColor (-1,$COLOR_RED)
$txtWardenAbility = GUICtrlCreateInput("25", $x + 260, $y, 30, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(634,11, "Set the time in seconds for Timed Activation of Grand Warden Ability.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE+$GUI_HIDE)
GUICtrlSetLimit(-1, 2)
GUICtrlSetColor (-1,$COLOR_RED)
$lblWardenAbilitiesSec = GUICtrlCreateLabel(GetTranslated(603,6, -1), $x + 293, $y, -1, -1)
GUICtrlSetState(-1, $GUI_DISABLE+$GUI_HIDE)
GUICtrlSetColor (-1,$COLOR_RED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 110
Global $chkattackHours0, $chkattackHours1, $chkattackHours2, $chkattackHours3, $chkattackHours4, $chkattackHours5
Global $chkattackHours6, $chkattackHours7, $chkattackHours8, $chkattackHours9, $chkattackHours10, $chkattackHours11
Global $chkattackHours12, $chkattackHours13, $chkattackHours14, $chkattackHours15, $chkattackHours16, $chkattackHours17
Global $chkattackHours18, $chkattackHours19, $chkattackHours20, $chkattackHours21, $chkattackHours22, $chkattackHours23
Global $lbattackHours1, $lbattackHours2, $lbattackHours3, $lbattackHours4, $lbattackHours5, $lbattackHours6
Global $lbattackHours7, $lbattackHours8, $lbattackHours9, $lbattackHours10, $lbattackHours11, $lbattackHours12
Global $lbattackHoursED, $lbattackHoursPM, $lbattackHoursAM, $chkattackHoursE1, $chkattackHoursE2
Global $chkAttackWeekdays1, $chkAttackWeekdays2, $chkAttackWeekdays3, $chkAttackWeekdays4, $chkAttackWeekdays5, $chkAttackWeekdays6, $chkAttackWeekdays0
Global $chkAttackPlannerEnable, $ichkAttackPlannerEnable, $chkAttackPlannerCloseCoC, $ichkAttackPlannerCloseCoC, $chkAttackPlannerCloseAll, $ichkAttackPlannerCloseAll
Global $chkAttackPlannerRandom, $ichkAttackPlannerRandom, $cmbAttackPlannerRandom, $icmbAttackPlannerRandom, $chkAttackPlannerDayLimit, $ichkAttackPlannerDayLimit
Global $cmbAttackPlannerDayMin, $icmbAttackPlannerDayMin, $cmbAttackPlannerDayMax, $icmbAttackPlannerDayMax
$grpAttHSched = GUICtrlCreateGroup(GetTranslated(634,20, "Attack Schedule"), $x - 20, $y - 20, 420, 130)
$x -= 5
$chkAttackPlannerEnable = GUICtrlCreateCheckbox(GetTranslated(634,21, "Enable Schedule"), $x, $y-5, -1, -1)
$txtTip = GetTranslated(634,22, "This option will allow you to schedule attack times") & @CRLF &  GetTranslated(634,23, "Bot continues to run and will attack only when schedule allows")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkAttackPlannerEnable")
$chkAttackPlannerCloseCoC = GUICtrlCreateCheckbox(GetTranslated(634,24, "Close CoC"), $x, $y+14, -1, -1)
$txtTip = GetTranslated(634,25, "This option will close CoC app when not scheduled to Search & Attack!") & @CRLF &  GetTranslated(634,26, "Bot Continues to run and will restart when schedule allows")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerCloseCoC")
$chkAttackPlannerCloseAll = GUICtrlCreateCheckbox(GetTranslated(634,27, "Close emulator"), $x, $y+33, -1, -1)
$txtTip = GetTranslated(634,28, "This option will close emulator when not scheduled to Search & Attack!") & @CRLF &  GetTranslated(634,26, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerCloseAll")
$chkAttackPlannerRandom = GUICtrlCreateCheckbox(GetTranslated(634,29, "Random Disable"), $x, $y+52, -1, -1)
$txtTip = GetTranslated(634,30, "This option will randomly stop attacking") & @CRLF &  GetTranslated(634,26, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerRandom")
$cmbAttackPlannerRandom = GUICtrlCreateCombo("",  $x + 110 , $y+50, 37, 16, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(634,31, "Select number of hours to stop attacking"))
GUICtrlSetData(-1, "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20", "4")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerRandom")
$lbAttackPlannerRandom = GUICtrlCreateLabel(GetTranslated(603,37, "hrs"), $x+148, $y+54, -1,-1)
GUICtrlSetState(-1, $GUI_DISABLE)
$chkAttackPlannerDayLimit = GUICtrlCreateCheckbox(GetTranslated(634,35, "Daily Limit"), $x, $y+77, -1, -1)
$txtTip = GetTranslated(634,36, "Will randomly stop attacking when exceed random number of attacks between range selected") & @CRLF &  GetTranslated(634,26, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "chkAttackPlannerDayLimit")
$cmbAttackPlannerDayMin = GUICtrlCreateInput("12",  $x+79 , $y+77, 37, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(634,37, "Enter minimum number of attacks allowed per day"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerDayMin")
$lbAttackPlannerDayLimit = GUICtrlCreateLabel(GetTranslated(634,39,"to"), $x+121, $y+80, -1,-1)
GUICtrlSetState(-1, $GUI_DISABLE)
$cmbAttackPlannerDayMax = GUICtrlCreateInput("15",  $x+136 , $y+77, 37, 18,  BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(634,38, "Enter maximum number of attacks allowed per day"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "cmbAttackPlannerDayMax")
$x += 198
$y -= 5
$lbAttackWeekdays0 = GUICtrlCreateLabel(GetTranslated(603,36, "Day:"), $x, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,31, "Only during these day of week"))
$lbAttackWeekdays1 = GUICtrlCreateLabel(GetTranslated(603,16, "Su"), $x + 30, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,17, "Sunday"))
$lbAttackWeekdays2 = GUICtrlCreateLabel(GetTranslated(603,18, "Mo"), $x + 46, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,19, "Monday"))
$lbAttackWeekdays3 = GUICtrlCreateLabel(GetTranslated(603,20, "Tu"), $x + 63, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,21, "Tuesday"))
$lbAttackWeekdays4 = GUICtrlCreateLabel(GetTranslated(603,22, "We"), $x + 79, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,23, "Wednesday"))
$lbAttackWeekdays5 = GUICtrlCreateLabel(GetTranslated(603,24, "Th"), $x + 99, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,25, "Thursday"))
$lbAttackWeekdays6 = GUICtrlCreateLabel(GetTranslated(603,26, "Fr"), $x + 117, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,27, "Friday"))
$lbAttackWeekdays7 = GUICtrlCreateLabel(GetTranslated(603,28, "Sa"), $x + 133, $y, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,29, "Saturday"))
$lbAttackWeekdaysE = GUICtrlCreateLabel("X", $x + 155, $y+1, -1, 15)
_GUICtrlSetTip(-1, GetTranslated(603,2, -1))
$y += 13
$chkAttackWeekdays0 = GUICtrlCreateCheckbox("", $x + 30, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$chkAttackWeekdays1 = GUICtrlCreateCheckbox("", $x + 47, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$chkAttackWeekdays2 = GUICtrlCreateCheckbox("", $x + 64, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$chkAttackWeekdays3 = GUICtrlCreateCheckbox("", $x + 81, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$chkAttackWeekdays4 = GUICtrlCreateCheckbox("", $x + 99, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$chkAttackWeekdays5 = GUICtrlCreateCheckbox("", $x + 117, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$chkAttackWeekdays6 = GUICtrlCreateCheckbox("", $x + 133, $y, 16, 16)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, GetTranslated(603,31, -1))
$chkattackWeekDaysE = GUICtrlCreateCheckbox("", $x + 151, $y, 15, 15, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$txtTip = GetTranslated(603,2, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkattackWeekDaysE")
$x -= 25
$y += 17
$lbattackHours0 = GUICtrlCreateLabel(GetTranslated(603,35,"Hour:"), $x , $y, -1, 15)
$txtTip = GetTranslated(603,30, "Only during these hours of each day")
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours1 = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours2 = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours3 = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours4 = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours5 = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours6 = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours7 = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours8 = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours9 = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours10 = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours11 = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHours12 = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
_GUICtrlSetTip(-1, $txtTip)
$lbattackHoursED = GUICtrlCreateLabel("X", $x + 214, $y+1, 11, 11)
_GUICtrlSetTip(-1, $txtTip)
$y += 15
$chkattackHours0 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours1 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours2 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours3 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours4 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours5 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours6 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours7 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours8 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours9 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours10 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours11 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$chkattackHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$txtTip = GetTranslated(603,2, "This button will clear or set the entire row of boxes")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkattackHoursE1")
$lbattackHoursAM = GUICtrlCreateLabel(GetTranslated(603,3, "AM"), $x + 10, $y)
$y += 15
$txtTip = GetTranslated(603,30, -1)
$chkattackHours12 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours13 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours14 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours15 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours16 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours17 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours18 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours19 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours20 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours21 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours22 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHours23 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkattackHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$txtTip = GetTranslated(603,2, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkattackHoursE2")
$lbattackHoursPM = GUICtrlCreateLabel(GetTranslated(603,4, "PM"), $x + 10, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 25, $y = 245
$grpClanCastleBal = GUICtrlCreateGroup(GetTranslated(634,12, "ClanCastle"), $x - 20, $y - 20, 420, 100)
GUICtrlCreateIcon($pIconLib, $eIcnCC, $x -10 , $y + 4, 24, 24)
$y -= 4
$chkDropCCHoursEnable = GUICtrlCreateCheckbox(GetTranslated(634,40,"Enable CC Drop Schedule" ), $x +20, $y+2, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(634,41, "Use schedule to define when dropping CC is allowed, \r\n CC is always dropped when schedule is not enabled"))
GUICtrlSetOnEvent(-1, "chkDropCCHoursEnable")
$y += 22
$chkUseCCBalanced = GUICtrlCreateCheckbox(GetTranslated(634,13,"Balance Donate/Receive" ), $x +20, $y+2, -1, -1)
GUICtrlSetState(-1, $GUI_UNCHECKED)
_GUICtrlSetTip(-1, GetTranslated(634,14, "Drop your Clan Castle only if your donated/received ratio is greater than D/R ratio below."))
GUICtrlSetOnEvent(-1, "chkBalanceDR")
$y += 28
$cmbCCDonated = GUICtrlCreateCombo("",  $x + 40 , $y, 30, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(634,15, "Donated ratio"))
GUICtrlSetData(-1, "1|2|3|4|5", "1")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbBalanceDR")
$lblDRRatio = GUICtrlCreateLabel("/", $x + 73, $y + 5, -1, -1)
$txtTip = GetTranslated(634,16, "Wanted donated / received ratio") & @CRLF & GetTranslated(634,17, "1/1 means donated = received, 1/2 means donated = half the received etc.")
_GUICtrlSetTip(-1, $txtTip)
$cmbCCReceived = GUICtrlCreateCombo("", $x +80, $y, 30, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
_GUICtrlSetTip(-1, GetTranslated(634,18, "Received ratio"))
GUICtrlSetData(-1, "1|2|3|4|5", "1")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetOnEvent(-1, "cmbBalanceDR")
$x += 188
$y = 245
$lblDropCCHours = GUICtrlCreateLabel(GetTranslated(603,30, -1), $x+8, $y)
$y += 14
$x -= 21
$txtTip = GetTranslated(603,30, -1)
$lbDropCCHours1 = GUICtrlCreateLabel(" 0", $x + 30, $y, 13, 15)
$lbDropCCHours2 = GUICtrlCreateLabel(" 1", $x + 45, $y, 13, 15)
$lbDropCCHours3 = GUICtrlCreateLabel(" 2", $x + 60, $y, 13, 15)
$lbDropCCHours4 = GUICtrlCreateLabel(" 3", $x + 75, $y, 13, 15)
$lbDropCCHours5 = GUICtrlCreateLabel(" 4", $x + 90, $y, 13, 15)
$lbDropCCHours6 = GUICtrlCreateLabel(" 5", $x + 105, $y, 13, 15)
$lbDropCCHours7 = GUICtrlCreateLabel(" 6", $x + 120, $y, 13, 15)
$lbDropCCHours8 = GUICtrlCreateLabel(" 7", $x + 135, $y, 13, 15)
$lbDropCCHours9 = GUICtrlCreateLabel(" 8", $x + 150, $y, 13, 15)
$lbDropCCHours10 = GUICtrlCreateLabel(" 9", $x + 165, $y, 13, 15)
$lbDropCCHours11 = GUICtrlCreateLabel("10", $x + 180, $y, 13, 15)
$lbDropCCHours12 = GUICtrlCreateLabel("11", $x + 195, $y, 13, 15)
$lbDropCCHoursED = GUICtrlCreateLabel("X", $x + 213, $y+2, 11, 11)
$y += 15
$chkDropCCHours0 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours1 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours2 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours3 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours4 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours5 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours6 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours7 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours8 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours9 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours10 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours11 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHoursE1 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED )
$txtTip = GetTranslated(603,2, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDropCCHoursE1")
$lbDropCCHoursAM = GUICtrlCreateLabel(GetTranslated(603,3, -1), $x + 10, $y)
$y += 15
$txtTip = GetTranslated(603,30, -1)
$chkDropCCHours12 = GUICtrlCreateCheckbox("", $x + 30, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours13 = GUICtrlCreateCheckbox("", $x + 45, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours14 = GUICtrlCreateCheckbox("", $x + 60, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours15 = GUICtrlCreateCheckbox("", $x + 75, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours16 = GUICtrlCreateCheckbox("", $x + 90, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours17 = GUICtrlCreateCheckbox("", $x + 105, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours18 = GUICtrlCreateCheckbox("", $x + 120, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours19 = GUICtrlCreateCheckbox("", $x + 135, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours20 = GUICtrlCreateCheckbox("", $x + 150, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours21 = GUICtrlCreateCheckbox("", $x + 165, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours22 = GUICtrlCreateCheckbox("", $x + 180, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHours23 = GUICtrlCreateCheckbox("", $x + 195, $y, 15, 15)
GUICtrlSetState(-1, $GUI_CHECKED )
GUICtrlSetState(-1, $GUI_DISABLE)
_GUICtrlSetTip(-1, $txtTip)
$chkDropCCHoursE2 = GUICtrlCreateCheckbox("", $x + 211, $y+1, 13, 13, BitOR($BS_PUSHLIKE, $BS_ICON))
GUICtrlSetImage(-1, $pIconLib, $eIcnGoldStar, 0)
GUICtrlSetState(-1, $GUI_UNCHECKED )
$txtTip = GetTranslated(603,2, -1)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDropCCHoursE2")
$lbDropCCHoursPM = GUICtrlCreateLabel(GetTranslated(603,4, -1), $x + 10, $y)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_AttackOption_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,30,"End Battle"))
Local $x = 20, $y = 45
Global $hReplayShareGUI, $txtShareMinGold, $txtShareMinElixir, $txtShareMinDark, $txtShareMessage
$grpReplayShare = GUICtrlCreateGroup(GetTranslated(633,1,"Share Replay"), $x-15, $y-20, 420, 204)
$chkShareAttack = GUICtrlCreateCheckbox(GetTranslated(633,2, "Share Replays in your clan's chat."), $x, $y-7, -1, -1)
$TxtTip = GetTranslated(633,3, "Check this to share your battle replay in the clan chat.")
_GUICtrlSetTip(-1, $TxtTip)
GUICtrlSetOnEvent(-1, "chkShareAttack")
$x -= 15
$y -= 2
$y -=5
$y += 25
$lblShareMinGold = GUICtrlCreateLabel(GetTranslated(633,4, "When Loot Gained") & ":>", $x + 20 , $y, -1, -1)
$txtShareMinGold = GUICtrlCreateInput("300000", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(633,5, "Only Share Replay when the battle loot is more than this amount of Gold.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picShareLootGold = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 182, $y, 16, 16)
$y += 22
$lblShareMinElixir = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
$txtShareMinElixir = GUICtrlCreateInput("300000", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(633,6, "Only Share Replay when the battle loot is more than this amount of Elixir.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 6)
$picShareLootElixir = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 182, $y, 16, 16)
$y += 22
$lblShareMinDark = GUICtrlCreateLabel(">", $x + 112, $y, -1, -1)
$txtShareMinDark = GUICtrlCreateInput("0", $x + 120, $y - 2, 61, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(633,7, "Only Share Replay when the battle loot is more than this amount of Dark Elixir.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 5)
$picShareLootDarkElixir = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 182, $y, 16, 16)
$y += 25
$x += 5
$lblShareMessage = GUICtrlCreateLabel(GetTranslated(633,8, "Use a random message from this list") &":", $x , $y -2 , -1, -1)
$y += 27
$txtShareMessage = GUICtrlCreateEdit("", $x, $y - 10 , 205, 72, BitOR($ES_WANTRETURN, $ES_CENTER, $ES_AUTOVSCROLL))
GUICtrlSetData(-1, StringFormat(GetTranslated(633,9, "Nice\r\nGood\r\nThanks \r\nWowwww")))
_GUICtrlSetTip(-1, GetTranslated(633,10, "Message to send with the Share Replay"))
$x = 20
$y+=100
$grpTakeLootSS = GUICtrlCreateGroup(GetTranslated(633,11,"Take Loot Snapshot"), $x-15, $y-20, 420, 67)
$chkTakeLootSS = GUICtrlCreateCheckbox(GetTranslated(633,11, -1), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(633,12, "Check this if you want to save a Loot snapshot of the Village that was attacked."))
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlSetOnEvent(-1, "chkTakeLootSS")
$y += 18
$chkScreenshotLootInfo = GUICtrlCreateCheckbox(GetTranslated(633,13, "Include loot info in filename"), $x  , $y , -1, -1)
_GUICtrlSetTip(-1, GetTranslated(633,14, "Include loot info in the screenshot filename"))
GUICtrlSetState(-1,$GUI_DISABLE)
GUICtrlCreateTabItem("")
$hGUI_AttackOption_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,32,"Trophy Settings"))
Local $x = 25, $y = 45
$grpTrophy = GUICtrlCreateGroup(GetTranslated(609,1, "Trophy Settings"), $x - 20, $y - 20, 420, 305)
$x += 25
$y += 25
GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x - 15, $y, 64, 64, $BS_ICON)
$x += 50
$chkTrophyRange = GUICtrlCreateCheckbox(GetTranslated(609,2, "Trophy range") & ":",$x + 20, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkTrophyRange")
$txtdropTrophy = GUICtrlCreateInput("5000", $x + 110, $y, 35, -1, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(609,3, "MIN: The Bot will drop trophies until below this value.")
GUICtrlSetLimit(-1, 4)
_GUICtrlSetTip(-1, $txtTip)
GuiCtrlSetState(-1,$GUI_DISABLE)
$lblDash = GUICtrlCreateLabel(GetTranslated(603,13, "-"), $x + 148, $y + 4, -1, -1)
$txtMaxTrophy = GUICtrlCreateInput("5000", $x + 155, $y, 35, -1, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(609,4, "MAX: The Bot will drop trophies if your trophy count is greater than this value.")
GUICtrlSetLimit(-1, 4)
_GUICtrlSetTip(-1, $txtTip)
GuiCtrlSetState(-1,$GUI_DISABLE)
$y += 24
$x += 20
$chkTrophyHeroes = GUICtrlCreateCheckbox(GetTranslated(609,5, "Use Heroes To Drop Trophies"), $x, $y, -1, -1)
$txtTip = GetTranslated(609,6, "Use Heroes to drop Trophies if Heroes are available.")
_GUICtrlSetTip(-1, $txtTip)
GuiCtrlSetState(-1,$GUI_DISABLE)
$y += 20
$chkTrophyAtkDead = GUICtrlCreateCheckbox(GetTranslated(609,7, "Attack Dead Bases During Drop"), $x  , $y +2, -1, -1)
$txtTip = GetTranslated(609,8, "Attack a Deadbase found on the first search while dropping Trophies.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkTrophyAtkDead")
GuiCtrlSetState(-1,$GUI_DISABLE)
$y += 24
$lblDTArmyMin = GUICtrlCreateLabel(GetTranslated(609,9, "Wait until Army") & " " & ChrW(8805), $x + 10, $y + 6, 120, -1, $SS_RIGHT)
$txtTip = GetTranslated(609,10, "Enter the percent of full army required for dead base attack before starting trophy drop.")
_GUICtrlSetTip(-1, $txtTip)
$txtDTArmyMin = GUICtrlCreateInput("70", $x + 135, $y +2, 27, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetState (-1, $GUI_DISABLE)
$lblDTArmypercent = GUICtrlCreateLabel(GetTranslated(603,12, "%"), $x + 165, $y +6, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_AttackOption_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslated(700, 0, "Goblin XP"))
Local $x = 25, $y = 45, $xStart = 25, $yStart = 45
$grpSuperXP = GUICtrlCreateGroup(GetTranslated(700, 1, "Goblin XP"), $x - 20, $y - 20, 420, 305)
$chkEnableSuperXP = GUICtrlCreateCheckbox(GetTranslated(700, 2, "Enable Goblin XP"), $x, $y, 102, 17)
GUICtrlSetOnEvent(-1, "chkEnableSuperXP")
$rbSXTraining = GUICtrlCreateRadio(GetTranslated(700, 3, "Farm XP during troops Training"), $x, $y + 23, 165, 17)
GUICtrlSetState(-1, $GUI_CHECKED)
$lblLOCKEDSX = GUICtrlCreateLabel(GetTranslated(700, 13, "LOCKED"), $x + 210, $y + 23, 173, 50)
GUICtrlSetFont(-1, 30, 800, 0, "Arial")
GUICtrlSetColor(-1, 0xFF0000)
GUICtrlSetState(-1, $GUI_HIDE)
$rbSXIAttacking = GUICtrlCreateRadio(GetTranslated(700, 4, "Farm XP instead of Attacking"), $x, $y + 46, 158, 17)
$x += 129
$y += 75
GUICtrlCreateLabel(GetTranslated(700, 5, "Use"), $x - 35, $y + 13, 23, 17)
GUICtrlCreateIcon($pIconLib, $eIcnKing, $x, $y, 32, 32)
GUICtrlCreateIcon($pIconLib, $eIcnQueen, $x + 40, $y, 32, 32)
GUICtrlCreateIcon($pIconLib, $eIcnWarden, $x + 80, $y, 32, 32)
GUICtrlCreateLabel(GetTranslated(700, 6, "to gain XP"), $x + 123, $y + 13, 53, 17)
$x += 10
$chkSXBK = GUICtrlCreateCheckbox("", $x, $y + 35, 17, 17)
$chkSXAQ = GUICtrlCreateCheckbox("", $x + 40, $y + 35, 17, 17)
$chkSXGW = GUICtrlCreateCheckbox("", $x + 80, $y + 35, 17, 17)
$x = $xStart + 25
$y += 73
GUICtrlCreateLabel("", $x - 25, $y, 5, 19)
GUICtrlSetBkColor (-1, 0xD8D8D8)
$DocXP1 = GUICtrlCreateLabel(GetTranslated(700, 7, "XP at Start"), $x - 20, $y, 98, 19)
GUICtrlSetBkColor (-1, 0xD8D8D8)
$DocXP2 = GUICtrlCreateLabel(GetTranslated(700, 8, "Current XP"), $x + 63 + 15, $y, 104, 19)
GUICtrlSetBkColor (-1, 0xD8D8D8)
$DocXP3 = GUICtrlCreateLabel(GetTranslated(700, 9, "XP Won"), $x + 71 + 76 + 35, $y, 103, 19)
GUICtrlSetBkColor (-1, 0xD8D8D8)
$DocXP4 = GUICtrlCreateLabel(GetTranslated(700, 10, "XP Won/Hour"), $x + 69 + 55 + 110 + 45, $y, 87, 19)
GUICtrlSetBkColor (-1, 0xD8D8D8)
GUICtrlCreateGroup("", $x - 28, $y - 7, 395, 29)
$y += 15
GUICtrlCreateLabel("", $x - 25, $y + 7, 5, 36)
GUICtrlSetBkColor (-1, 0xbfdfff)
$lblXPatStart = GUICtrlCreateLabel("0", $x - 20, $y + 7, 99, 36)
GUICtrlSetFont(-1, 20, 800, 0, "Arial")
GUICtrlSetBkColor (-1, 0xbfdfff)
$lblXPCurrent = GUICtrlCreateLabel("0", $x + 78, $y + 7, 105, 36)
GUICtrlSetFont(-1, 20, 800, 0, "Arial")
GUICtrlSetBkColor (-1, 0xbfdfff)
$lblXPSXWon = GUICtrlCreateLabel("0", $x + 182, $y + 7, 97, 36)
GUICtrlSetFont(-1, 20, 800, 0, "Arial")
GUICtrlSetBkColor (-1, 0xbfdfff)
$lblXPSXWonHour = GUICtrlCreateLabel("0", $x + 279, $y + 7, 87, 36)
GUICtrlSetFont(-1, 20, 800, 0, "Arial")
GUICtrlSetBkColor (-1, 0xbfdfff)
$x = $xStart
$y += 67
GUICtrlCreateLabel(GetTranslated(700, 11, "Goblin XP attack continuously the TH of Goblin Picnic to farm XP."), $x, $y, 312, 17)
GUICtrlCreateLabel(GetTranslated(700, 12, "At each attack, you win 5 XP"), $x, $y + 20, 306, 17)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_BullyMode = GUICreate("", $_GUI_MAIN_WIDTH - 30 - 10, $_GUI_MAIN_HEIGHT - 255 - 30 - 30, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_SEARCH)
GUISwitch($hGUI_BullyMode)
Local $x = 20, $y = 130 - 105
$grpBullyAtkCombo = GUICtrlCreateGroup(GetTranslated(629,1, "Bully Attack Combo"), $x - 20, $y - 20, 430, 330)
$y -= 5
$x -= 10
$lblBullyMode	= GUICtrlCreateLabel(GetTranslated(629,2, "In Bully Mode, ALL bases that meet the TH level requirement below will be attacked.") , $x - 5, $y + 3, 209, 30, $SS_LEFT)
$y +=35
$lblBullyDelay = GUICtrlCreateLabel(GetTranslated(629,3,"Enable Bully after"), $x, $y+3)
$txtATBullyMode = GUICtrlCreateInput("150", $x + 95, $y, 35, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(629,4, "TH Bully: No. of searches to wait before activating.")
GUICtrlSetLimit(-1, 3)
_GUICtrlSetTip(-1, $txtTip)
$lblATBullyMode = GUICtrlCreateLabel(GetTranslated(603,5, "search(es)."), $x + 135, $y + 5, -1, -1)
$y +=25
$lblATBullyMode = GUICtrlCreateLabel(GetTranslated(629,6, "Max TH level") & ":", $x - 5, $y + 3, 90, -1, $SS_RIGHT)
$cmbYourTH = GUICtrlCreateCombo("", $x + 95, $y, 50, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(629,7, "TH Bully: Max. Townhall level to bully.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetData(-1, "4-6|7|8|9|10|11", "4-6")
$y += 24
GUICtrlCreateLabel(GetTranslated(629,8, "When found, Attack with settings from")&":", $x + 10, $y, -1, -1, $SS_RIGHT)
$y += 14
$radUseDBAttack = GUICtrlCreateRadio(GetTranslated(629,9, "DeadBase Atk."), $x + 20, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(629,10, "Use Dead Base attack settings when attacking a TH Bully match."))
GUICtrlSetState(-1, $GUI_CHECKED)
$radUseLBAttack = GUICtrlCreateRadio(GetTranslated(629,11, "LiveBase Atk."), $x + 115, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(629,12, "Use Live Base attack settings when attacking a TH Bully match."))
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUISwitch($hGUI_SEARCH)
$hGUI_SEARCH_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_SEARCH_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,23,"DeadBase") & "    ")
$lblDBdisabled = GUICtrlCreateLabel(GetTranslated(600,49,"Note: This Strategy is disabled, tick the checkmark on the") & " " & GetTranslated(600, 23, -1) & " " & GetTranslated(600,50,"tab to enable it!"), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$hGUI_SEARCH_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,24,"ActiveBase") & "    ")
$lblABdisabled = GUICtrlCreateLabel(GetTranslated(600,49, -1) & " " & GetTranslated(600, 24, -1) & " " & GetTranslated(600,50, -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$hGUI_SEARCH_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,25,"TH Snipe") & "    ")
$lblTSdisabled = GUICtrlCreateLabel(GetTranslated(600,49, -1) & " " & GetTranslated(600, 25, -1) & " " & GetTranslated(600,50, -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$hGUI_SEARCH_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,26,"Bully") & "    ")
$lblBullydisabled = GUICtrlCreateLabel(GetTranslated(600,49, -1) & " " & GetTranslated(600, 26, -1) & " " & GetTranslated(600,50, -1), 20, 30, $_GUI_MAIN_WIDTH - 40, -1)
GUICtrlSetState(-1, $GUI_HIDE)
$hGUI_SEARCH_TAB_ITEM5 = GUICtrlCreateTabItem(GetTranslated(600,27,"Options"))
GUICtrlCreateTabItem("")
$hGUI_NewSmartZap = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_ATTACK)
GUISetBkColor($COLOR_WHITE, $hGUI_NewSmartZap)
GUISwitch($hGUI_NewSmartZap)
Local $x = 20, $y = 25
$grpStatsMisc = GUICtrlCreateGroup("SmartZap", $x - 20, $y - 20, 437, 218 + 25)
GUICtrlCreateIcon($pIconLib, $eIcnNewSmartZap1, $x - 10, $y + 5, 25, 25)
GUICtrlCreateIcon($pIconLib, $eIcnDrill, $x - 10, $y + 42, 25, 25)
$chkSmartLightSpell = GUICtrlCreateCheckbox("Use Lightning Spells to Zap Drills", $x + 20 + 2, $y + 5, -1, -1)
$txtTip = "Check this to drop Lightning Spells on top of Dark Elixir Drills." & @CRLF & @CRLF &  "Remember to go to the tab 'troops' and put the maximum capacity " & @CRLF &  "of your spell factory and the number of spells so that the bot " & @CRLF &  "can function perfectly."
GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkSmartLightSpell")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$chkNoobZap = GUICtrlCreateCheckbox("Use NoobZap to Zap any Dark Drills", $x + 20 + 2, $y + 30, -1, -1)
$txtTip = "Check this to drop lightning spells on any Dark Elixir Drills," & @CRLF & @CRLF &  "__If You Do Not Like SmartZap, This Is The Right Choice.__"
GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkNoobZap")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$chkSmartZapDB = GUICtrlCreateCheckbox("Only Zap Drills in Dead Bases", $x + 20 + 2, $y + 55, -1, -1)
$txtTip = "It is recommended you only zap drills in dead bases as most of the " & @CRLF &  "Dark Elixir in a live base will be in the storage."
GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkSmartZapDB")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 220 + 9, $y + 11, 24, 24)
$grpNewSmartZap = GUICtrlCreateGroup("", $x + 219, $y - 1, 192, 106 + 30)
$lblSmartZap = GUICtrlCreateLabel("Min. amount of Dark Elixir:", $x + 180 + 79, $y + 12, -1, -1)
$txtMinDark = GUICtrlCreateInput("250", $x + 309, $y + 32, 90, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = "The value here depends a lot on what level your Town Hall is, " & @CRLF &  "and what level drills you most often see."
GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "txtMinDark")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 220 + 9, $y + 57, 24, 24)
$lblNoobZap = GUICtrlCreateLabel("Expected gain of Dark Drills:", $x + 180 + 79, $y + 58, -1, -1)
$txtExpectedDE = GUICtrlCreateInput("95", $x + 309, $y + 78, 90, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = "Set value for expected gain every dark drill" & @CRLF &  "NoobZap will be stop if, last zap gained less DE then expected"
GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 3)
GUICtrlSetOnEvent(-1, "txtExpectedDE")
GUICtrlSetState(-1, $GUI_DISABLE)
$picTimeCloseATK = GUICtrlCreateIcon($pIconLib, $eIcnHourGlass, $x + 220 + 9, $y + 98, 24, 24)
$TimeCloseATK = GUICtrlCreateLabel("Time to End Battle:", $x + 180 + 79, $y + 104, -1, -1)
$txtTip = "Set the time in seconds before closing an attack for smartzap to be released"
GUICtrlSetTip(-1, $txtTip)
$MinTimeCloseATK = GUICtrlCreateCombo("", $x + 359, $y + 104, 40, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "5|10|15|20|25|30", "15")
GUICtrlSetTip(-1, $txtTip)
$chkSmartZapSaveHeroes = GUICtrlCreateCheckbox("TH snipe NoZap if Heroes Deployed", $x + 20 + 2, $y + 80, -1, -1)
$txtTip = "This will stop SmartZap from zapping a base on a Town Hall Snipe " & @CRLF &  "if your heroes were deployed. " & @CRLF & @CRLF &  "This protects their health so they will be ready for battle sooner!"
GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkSmartZapSaveHeroes")
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetState(-1, $GUI_DISABLE)
$picSmartZap = GUICtrlCreateIcon($pIconLib, $eIcnLightSpell, $x - 10, $y + 112 + 30, 24, 24)
$lblLightningUsed = GUICtrlCreateLabel("0", $x + 20, $y + 110 + 30, 396, 30, $SS_CENTER)
GUICtrlSetFont(-1, 16, $FW_BOLD, Default, "arial", $CLEARTYPE_QUALITY)
GUICtrlSetBkColor (-1, 0xbfdfff)
$txtTip = "Amount of used spells."
GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateIcon($pIconLib, $eIcnNewSmartZap2, $x - 12, $y + 150 + 30, 30, 30)
$lblSmartZap = GUICtrlCreateLabel("0", $x + 20, $y + 150 + 30, 396, 30, $SS_CENTER)
GUICtrlSetFont(-1, 16, $FW_BOLD, Default, "arial", $CLEARTYPE_QUALITY)
GUICtrlSetBkColor (-1, 0xbfdfff)
$txtTip = "Number of dark elixir zapped during the attack with lightning."
GUICtrlSetTip(-1, $txtTip)
Local $x = 320, $y = 265
$chkDebugSmartZap = GUICtrlCreateCheckbox("DebugSZ", $x + 50 + 2, $y + 80, -1, -1)
$txtTip = "Use it for debug SmartZap"
GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Global $txtPresetSaveFilename, $txtSavePresetMessage, $lblLoadPresetMessage,$btnGUIPresetDeleteConf, $chkCheckDeleteConf
Global $cmbPresetList, $txtPresetMessage,$btnGUIPresetLoadConf,  $lblLoadPresetMessage,$btnGUIPresetDeleteConf, $chkCheckDeleteConf
$hGUI_STRATEGIES = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_ATTACK)
GUISwitch($hGUI_STRATEGIES)
Local $xStart = 5, $yStart = 25
$hGUI_STRATEGIES_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_STRATEGIES_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,33,"Load Strategy"))
$x = $xStart
$y = $yStart
$cmbPresetList = GUICtrlCreateCombo("",$x,$y,200,300,$WS_VSCROLL)
GUICtrlSetOnEvent(-1, "PresetLoadConfigInfo")
$x +=205
$txtPresetMessage = GUICtrlCreateEdit("", $x, $y , 225, 250, BitOR($ES_WANTRETURN, $ES_AUTOVSCROLL))
GuiCtrlSetState(-1, $GUI_HIDE)
Local $loadmessage = GetTranslated(627,1,"LOAD PRECONFIGURED SETTINGS.\n\n- Load ALL Train Army Tab Settings\n- Load ALL Search && Attack Tab Settings\n\n- EXCEPT: Share Replay Settings\n- EXCEPT: Take Loot Snapshot Settings\n- EXCEPT: Gem Boost Settings")
$lblLoadPresetMessage = GUICtrlCreateLabel(StringReplace($loadmessage, "\n", @crlf ) ,$x+15, $y+25,400)
$x +=5
$y +=255
$btnGUIPresetLoadConf = GUICtrlCreateButton(GetTranslated(627,2,"Load Configuration"), $x , $y, 130, 20)
GUICtrlSetOnEvent(-1, "PresetLoadConf")
GuiCtrlSetState(-1, $GUI_HIDE)
$x +=145
$chkCheckDeleteConf = GUICtrlCreateCheckbox("", $x, $y + 2, 15, 15)
GUICtrlSetOnEvent(-1, "chkCheckDeleteConf")
GuiCtrlSetState(-1, $GUI_HIDE)
$btnGUIPresetDeleteConf = GUICtrlCreateButton(GetTranslated(627,3,"Delete"), $x + 15 , $y, 60, 20)
GUICtrlSetOnEvent(-1, "PresetDeleteConf")
GuiCtrlSetState(-1, $GUI_HIDE+$gui_DISABLE)
$btnStrategyFolder = GUICtrlCreateButton(GetTranslated(627,4, "Open Strategy folder"),$xStart + 40 , $y+ 40 , 120, 30)
GUICtrlSetOnEvent(-1, "btnStrategyFolder")
$hGUI_STRATEGIES_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,34,"Save Strategy"))
$x = $xStart
$y = $yStart
$lblPresetSaveFilename = GUICtrlCreateLabel(GetTranslated(628,1,"Strategy file name") & ":" ,$x,$y+4,200,25, $SS_RIGHT)
$x += 205
$txtPresetSaveFilename = GUICtrlCreateInput("strategy " &  @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & "." & @MIN & "." & @SEC,$x,$y,200,25)
$x = $xStart
$y +=30
$lblPresetSaveMessage =  GUICtrlCreateLabel(GetTranslated(628,2,"Notes") & ":" ,$x,$y+4,200,25,  $SS_RIGHT)
Local $savemessage = GetTranslated(628,3,"SAVE SETTINGS\n--------------------------------------\nSave ALL:\n- Train Army Tab Settings\n- Search && Attack Tab Settings\n\nExcept:\n- Share Replay Settings\n- Take Loot Snapshot Settings\n- Gem Boost Settings\n--------------------------------------")
$lblSavePresetMessage = GUICtrlCreateLabel(StringReplace($savemessage, "\n", @crlf ) ,$x+15, $y+4+25,280)
$x +=205
$txtSavePresetMessage = GUICtrlCreateEdit("", $x, $y , 223, 230, BitOR($ES_WANTRETURN, $ES_AUTOVSCROLL))
$y += 235
$btnGUIPresetSaveConf = GUICtrlCreateButton(GetTranslated(628,4,"Save Configuration"), $x+13 , $y, 200, 20)
GUICtrlSetOnEvent(-1, "PresetSaveConf")
GUICtrlCreateTabItem("")
GUISwitch($hGUI_ATTACK)
$hGUI_ATTACK_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_ATTACK_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,41,"Train Army"))
$hGUI_ATTACK_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,42,"Search && Attack"))
$hGUI_ATTACK_TAB_ITEM4 = GUICtrlCreateTabItem("NewSmartZap")
$hGUI_ATTACK_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,43,"Strategies"))
GUICtrlCreateTabItem("")
SplashStep(GetTranslated(500, 28, "Loading Bot tab..."))
Global $chkDisableSplash, $chkVersion, $chkDeleteLogs, $chkDeleteTemp, $chkDeleteLoots
Global $chkAutostart, $txtAutostartDelay, $chkLanguage,$chkDisposeWindows, $txtWAOffsetx, $txtWAOffsety, $cmbDisposeWindowsCond
Global $chkDebugClick, $chkDebugSetlog, $chkDebugOcr, $chkDebugImageSave, $chkdebugBuildingPos, $chkdebugTrain, $chkdebugOCRDonate, $chkdebugDeadBaseImage
Global $chkTotalCampForced, $txtTotalCampForced
Global $txtDeleteLogsDays, $txtDeleteTempDays, $txtDeleteLootsDays, $cmbLanguage, $chkScreenshotType, $chkScreenshotHideName, $chkUseRandomClick
Global $sldVSDelay, $sldMaxVSDelay, $lblVSDelay, $lblMaxVSDelay, $lbltxtVSDelay, $lbltxtMaxVSDelay
Global $sldTrainITDelay ,  $lbltxtTrainITDelay, $chkAlertSearch
Global $chkSinglePBTForced, $txtSinglePBTimeForced, $txtPBTimeForcedExit
$hGUI_BOT = GUICreate("", $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, BitOR($WS_CHILD, $WS_TABSTOP), -1, $frmBotEx)
$hGUI_STATS = GUICreate("", $_GUI_MAIN_WIDTH - 28, $_GUI_MAIN_HEIGHT - 255 - 28, 5, 25, BitOR($WS_CHILD, $WS_TABSTOP), -1, $hGUI_BOT)
GUISwitch($hGUI_BOT)
$hGUI_BOT_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 20, $_GUI_MAIN_HEIGHT - 255, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
$hGUI_BOT_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,35,"Options"))
Local $x = 25, $y = 45
$grpLanguages = GUICtrlCreateGroup(GetTranslated(636,83, "GUI Language"), $x - 20, $y - 20, 210, 47)
$y -=2
$cmbLanguage = GUICtrlCreateCombo("", $x - 8 , $y, 185, -1, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(636,84, "Use this to switch to a different GUI language")
_GUICtrlSetTip(-1, $txtTip)
LoadLanguagesComboBox()
GUICtrlSetData(-1, "English", "English")
GUICtrlSetOnEvent(-1, "cmbLanguage")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 54
$grpOnLoadBot = GUICtrlCreateGroup(GetTranslated(636,2, "When Bot Loads"), $x - 20, $y - 20, 210, 120)
$y -= 4
$chkDisableSplash = GUICtrlCreateCheckbox(GetTranslated(636,100, "Disable Splash Screen"), $x, $y, -1, -1)
$txtTip = GetTranslated(636,101, "Disables the splash screen on startup.")
GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_UNCHECKED)
$y += 20
$chkVersion = GUICtrlCreateCheckbox(GetTranslated(636,3, "Check for Updates"), $x, $y, -1, -1)
$txtTip = GetTranslated(636,4, "Check if you are running the latest version of the bot.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 20
$chkDeleteLogs = GUICtrlCreateCheckbox(GetTranslated(636,5, "Delete Log Files")& ":", $x, $y, -1, -1)
$txtTip = GetTranslated(636,6, "Delete log files older than this specified No. of days.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDeleteLogs")
$txtDeleteLogsDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
$lblDeleteLogsDays = GUICtrlCreateLabel(GetTranslated(636,7, "days"), $x + 150, $y + 4, 27, 15)
$y += 20
$chkDeleteTemp = GUICtrlCreateCheckbox(GetTranslated(636,8, "Delete Temp Files") & ":", $x, $y, -1, -1)
$txtTip = GetTranslated(636,9, "Delete temp files older than this specified No. of days.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDeleteTemp")
$txtDeleteTempDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
$lblDeleteTempDays = GUICtrlCreateLabel(GetTranslated(636,7, "days"), $x + 150, $y + 4, 27, 15)
$y += 20
$chkDeleteLoots = GUICtrlCreateCheckbox(GetTranslated(636,10, "Delete Loot Images"), $x, $y, -1, -1)
$txtTip = GetTranslated(636,11, "Delete loot image files older than this specified No. of days.")
GUICtrlSetState(-1, $GUI_CHECKED)
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "chkDeleteLoots")
$txtDeleteLootsDays = GUICtrlCreateInput("2", $x + 120, $y + 2, 25, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
$lblDeleteLootsDays = GUICtrlCreateLabel(GetTranslated(636,7, "days"), $x + 150, $y + 4, 27, 15)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 48
$grpOnStartBot = GUICtrlCreateGroup(GetTranslated(636,12, "When Bot Starts"), $x - 20, $y - 20, 210, 112)
$y -= 5
$chkAutostart = GUICtrlCreateCheckbox(GetTranslated(636,13, "Auto START after") & ":", $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,58, "Auto START the Bot after this No. of seconds."))
GUICtrlSetOnEvent(-1, "chkAutostart")
$txtAutostartDelay = GUICtrlCreateInput("10", $x + 120, $y + 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
GUICtrlSetFont(-1, 8)
GUICtrlSetState(-1, $GUI_DISABLE)
$lblAutostartSeconds = GUICtrlCreateLabel(GetTranslated(603,6, "sec."), $x + 150, $y + 4, 27, 18)
$y += 22
$chkLanguage = GUICtrlCreateCheckbox(GetTranslated(636,15, "Check Game Language (EN)"), $x, $y, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,16, "Check if the Game is set to the correct language (Must be set to English)."))
GUICtrlSetState(-1, $GUI_CHECKED)
$y += 22
$chkDisposeWindows = GUICtrlCreateCheckbox(GetTranslated(636,17, "Auto Align"), $x, $y, -1, -1)
$txtTip = GetTranslated(636,18, "Reposition/Align Android Emulator and BOT windows on the screen.")
GUICtrlSetOnEvent(-1, "chkDisposeWindows")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
$lblOffset = GUICtrlCreateLabel(GetTranslated(636,19, "Offset") & ":", $x + 85, $y + 4, -1, -1)
$txtWAOffsetx = GUICtrlCreateInput("10", $x + 120, $y + 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(636,20, "Offset horizontal pixels between Android Emulator and BOT windows.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
$txtWAOffsety= GUICtrlCreateInput("0", $x + 150, $y + 2, 25, 18, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
$txtTip = GetTranslated(636,21, "Offset vertical pixels between Android Emulator and BOT windows.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 2)
GUICtrlSetFont(-1, 8)
$y += 23
$cmbDisposeWindowsCond = GUICtrlCreateCombo("", $x, $y, 175, 20, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetData(-1, GetTranslated(636,22, "0,0: Android Emulator-Bot") & "|" &  GetTranslated(636,23, "0,0: Bot-Android Emulator") & "|" &  GetTranslated(636,24, "SNAP: Bot TopRight to Android") &"|" &  GetTranslated(636,25, "SNAP: Bot TopLeft to Android") & "|" &  GetTranslated(636,26, "SNAP: Bot BottomRight to Android") & "|" &  GetTranslated(636,27, "SNAP: Bot BottomLeft to Android") & "|" &  GetTranslated(636,95, "DOCK: Android into Bot"),  GetTranslated(636,24, "SNAP: Bot TopRight to Android"))
$txtTip &= @CRLF & GetTranslated(636,28, "0,0: Reposition Android Emulator screen to position 0,0 on windows desktop and align Bot window right or left to it.") & @CRLF &  GetTranslated(636,29, "SNAP: Only reorder windows, Align Bot window to Android Emulator window at Top Right, Top Left, Bottom Right or Bottom Left.\r\n" &  "DOCK: Integrate Android Screen into bot window.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Local $x = 240, $y = 45
$grpAdvanced = GUICtrlCreateGroup(GetTranslated(636,93, "Advanced"), $x - 20, $y - 20, 225, 82)
$chkUpdatingWhenMinimized = GUICtrlCreateCheckbox(GetTranslated(636,96, "Updating when minimized"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkUpdatingWhenMinimized")
_GUICtrlSetTip(-1, GetTranslated(636,97, "Enable different minimize routine for bot window.\r\nWhen bot is minimized, screen updates are shown in taskbar preview."))
$y += 19
$chkHideWhenMinimized = GUICtrlCreateCheckbox(GetTranslated(636,98, "Hide when minimized"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkHideWhenMinimized")
_GUICtrlSetTip(-1, GetTranslated(636,99, "Hide bot window in taskbar when minimized.\r\nUse trayicon 'Show bot' to display bot window again."))
$y += 19
$chkUseRandomClick = GUICtrlCreateCheckbox(GetTranslated(636,94, "Random Click"), $x, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkUseRandomClick")
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y += 47
$grpPhotoExpert = GUICtrlCreateGroup(GetTranslated(636,55, "Photo Screenshot Options"), $x - 20, $y - 17, 225, 60)
$chkScreenshotType = GUICtrlCreateCheckbox(GetTranslated(636,56, "Make in PNG format"), $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkScreenshotType")
$y += 19
$chkScreenshotHideName = GUICtrlCreateCheckbox(GetTranslated(636,57, "Hide Village and Clan Castle Name"), $x, $y, -1, -1)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetOnEvent(-1, "chkScreenshotHideName")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y +=48
$grpTimeWakeUp = GUICtrlCreateGroup(GetTranslated(636,85, "Remote Device"), $x - 20, $y - 20 , 225, 42)
$y -= 5
$lblTimeWakeUp = GUICtrlCreateLabel(GetTranslated(636,86, "When 'Another Device' wait") & ":", $x - 10, $y + 2, -1, -1)
$txtTip = GetTranslated(636,87, "Enter the time to wait (in Minutes) before the Bot reconnects when another device took control.")
_GUICtrlSetTip(-1, $txtTip)
$txtTimeWakeUp = GUICtrlCreateInput("2", $x + 127, $y - 1, 35, 21, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetLimit(-1, 3)
$lblTimeWakeUpSec = GUICtrlCreateLabel(GetTranslated(603,10, "min."), $x + 165, $y + 2, -1, -1)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y+= 51
$grpOtherExpert = GUICtrlCreateGroup(GetTranslated(636,45, "Other Options"), $x - 20, $y - 20, 225, 90)
$chkSinglePBTForced = GUICtrlCreateCheckbox(GetTranslated(636,61, "Force Single PB logoff"), $x-5, $y, -1, -1)
GUICtrlSetOnEvent(-1, "chkSinglePBTForced")
_GUICtrlSetTip(-1, GetTranslated(636,62, "This forces bot to exit CoC only one time prior to normal start of PB"))
$txtSinglePBTimeForced = GUICtrlCreateInput("18", $x + 130, $y-1, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, GetTranslated(636,63, "Type in number of minutes to keep CoC closed. Set to 15 minimum to reset PB timer!"))
GUICtrlSetOnEvent(-1, "txtSinglePBTimeForced")
GUICtrlSetLimit(-1, 3)
GUICtrlSetState(-1, $GUI_DISABLE)
$lblSinglePBTimeForced = GUICtrlCreateLabel( GetTranslated(603,9, "Min"), $x+162, $y+2, 27, 15)
$y += 20
$lblPBTimeForcedExit = GUICtrlCreateLabel( GetTranslated(636,65, "Subtract time for early PB exit"), $x-10, $y+3)
$txtTip = GetTranslated(636,66, "Type in number of minutes to quit CoC early! Setting below 10 minutes may not function!")
_GUICtrlSetTip(-1, $txtTip)
$txtPBTimeForcedExit = GUICtrlCreateInput("16", $x + 130, $y, 30, 16, BitOR($GUI_SS_DEFAULT_INPUT, $ES_CENTER, $ES_NUMBER))
_GUICtrlSetTip(-1, $txtTip)
GUICtrlSetOnEvent(-1, "txtSinglePBTimeForced")
GUICtrlSetLimit(-1, 3)
GUICtrlSetState(-1, $GUI_DISABLE)
$lblPBTimeForcedExit1 = GUICtrlCreateLabel( GetTranslated(603,9, -1), $x+162, $y+1, 27, 15)
$y += 20
$lblNameMyBot = GUICtrlCreateLabel("Name Your Bot :",$x - 10, $y + 3, 78, 20)
$NameMyBot = GUICtrlCreateInput("",$x + 80, $y, 80, 20)
_GUICtrlSetTip(-1, "Will Update Name Label in Header Image on Next Restart of the Bot.")
$btnNameMyBot = GUICtrlCreateButton("Enter",$x + 80+83, $y, 35, 20)
GUICtrlSetOnEvent(-1, "NameMyBotUpdate")
GUICtrlCreateGroup("", -99, -99, 1, 1)
Func NameMyBotUpdate()
GUICtrlSetData($lblDisplayName, GUICtrlRead($NameMyBot))
EndFunc
GUICtrlCreateTabItem("")
$hGUI_BOT_TAB_ITEM5 = GUICtrlCreateTabItem("Bot Humanization")
$chkUseBotHumanization = GUICtrlCreateCheckbox("Enable Bot Humanization", 10, 30, 137, 17)
GUICtrlSetOnEvent(-1, "chkUseBotHumanization")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$chkUseAltRClick = GUICtrlCreateCheckbox("Make ALL BOT clicks random", 280, 30, 162, 17)
GUICtrlSetOnEvent(-1, "chkUseAltRClick")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$Group1 = GUICtrlCreateGroup("Settings", 4, 55, 440, 335)
Local $x = 0, $y = 20
$x += 10
$y += 50
$Icon1 = GUICtrlCreateIcon($pIconLib, $eIcnChat, $x, $y + 5, 32, 32)
$Label1 = GUICtrlCreateLabel("Read the Clan Chat", $x + 40, $y + 5, 110, 17)
$cmbPriority[0] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$Label2 = GUICtrlCreateLabel("Read the Global Chat", $x + 240, $y + 5, 110, 17)
$cmbPriority[1] = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$Label4 = GUICtrlCreateLabel("Say...", $x + 40, $y + 30, 31, 17)
$humanMessage[0] = GUICtrlCreateInput("Hello !", $x + 75, $y + 25, 121, 21)
$Label3 = GUICtrlCreateLabel("Or", $x + 205, $y + 30, 15, 17)
$humanMessage[1] = GUICtrlCreateInput("Re !", $x + 225, $y + 25, 121, 21)
$cmbPriority[2] = GUICtrlCreateCombo("", $x + 355, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$Label20 = GUICtrlCreateLabel("Launch Challenges with message", $x + 40, $y + 55, 170, 17)
$challengeMessage = GUICtrlCreateInput("Can you beat my village ?", $x + 205, $y + 50, 141, 21)
$cmbPriority[12] = GUICtrlCreateCombo("", $x + 355, $y + 50, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$y += 81
$Icon2 = GUICtrlCreateIcon($pIconLib, $eIcnRepeat, $x, $y + 5, 32, 32)
$Label5 = GUICtrlCreateLabel("Watch Defenses", $x + 40, $y + 5, 110, 17)
$cmbPriority[3] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
GUICtrlSetOnEvent(-1, "cmbStandardReplay")
$Label6 = GUICtrlCreateLabel("Watch Attacks", $x + 40, $y + 30, 110, 17)
$cmbPriority[4] = GUICtrlCreateCombo("", $x + 155, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
GUICtrlSetOnEvent(-1, "cmbStandardReplay")
$Label7 = GUICtrlCreateLabel("Max Replay Speed ", $x + 240, $y + 5, 110, 17)
$cmbMaxSpeed[0] = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $ReplayChain, "2")
$Label8 = GUICtrlCreateLabel("Pause Replay", $x + 240, $y + 30, 110, 17)
$cmbPause[0] = GUICtrlCreateCombo("", $x + 355, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$y += 56
$Icon3 = GUICtrlCreateIcon($pIconLib, $eIcnClan, $x, $y + 5, 32, 32)
$Label9 = GUICtrlCreateLabel("Watch War log", $x + 40, $y + 5, 110, 17)
$cmbPriority[5] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$Label10 = GUICtrlCreateLabel("Visit Clanmates", $x + 40, $y + 30, 110, 17)
$cmbPriority[6] = GUICtrlCreateCombo("", $x + 155, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$Label11 = GUICtrlCreateLabel("Look at Best Players", $x + 240, $y + 5, 110, 17)
$cmbPriority[7] = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$Label12 = GUICtrlCreateLabel("Look at Best Clans", $x + 240, $y + 30, 110, 17)
$cmbPriority[8] = GUICtrlCreateCombo("", $x + 355, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$y += 56
$Icon4 = GUICtrlCreateIcon($pIconLib, $eIcnSwords, $x, $y + 5, 32, 32)
$Label14 = GUICtrlCreateLabel("Look at Current War", $x + 40, $y + 5, 110, 17)
$cmbPriority[9] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$Label16 = GUICtrlCreateLabel("Watch Replays", $x + 40, $y + 30, 110, 17)
$cmbPriority[10] = GUICtrlCreateCombo("", $x + 155, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
GUICtrlSetOnEvent(-1, "cmbWarReplay")
$Label13 = GUICtrlCreateLabel("Max Replay Speed ", $x + 240, $y + 5, 110, 17)
$cmbMaxSpeed[1] = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $ReplayChain, "2")
$Label15 = GUICtrlCreateLabel("Pause Replay", $x + 240, $y + 30, 110, 17)
$cmbPause[1] = GUICtrlCreateCombo("", $x + 355, $y + 25, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$y += 56
$Icon5 = GUICtrlCreateIcon($pIconLib, $eIcnLoop, $x, $y + 5, 32, 32)
$Label17 = GUICtrlCreateLabel("Do nothing", $x + 40, $y + 5, 110, 17)
$cmbPriority[11] = GUICtrlCreateCombo("", $x + 155, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, $FrequenceChain, "Never")
$Label18 = GUICtrlCreateLabel("Max Actions by Loop", $x + 240, $y + 5, 103, 17)
$cmbMaxActionsNumber = GUICtrlCreateCombo("", $x + 355, $y, 75, 25, BitOR($CBS_DROPDOWNLIST,$CBS_AUTOHSCROLL))
GUICtrlSetData(-1, "1|2|3|4|5", "2")
$y += 25
$chkCollectAchievements = GUICtrlCreateCheckbox("Collect achievements automatically", $x + 40, $y, 182, 17)
GUICtrlSetOnEvent(-1, "chkCollectAchievements")
GUICtrlSetState(-1, $GUI_UNCHECKED)
$chkLookAtRedNotifications = GUICtrlCreateCheckbox("Look at red/purple flags on buttons", $x + 240, $y, 187, 17)
GUICtrlSetOnEvent(-1, "chkLookAtRedNotifications")
GUICtrlSetState(-1, $GUI_UNCHECKED)
GUICtrlCreateGroup("", -99, -99, 1, 1)
For $i = $Icon1 To $chkLookAtRedNotifications
GUICtrlSetState($i, $GUI_DISABLE)
Next
GUICtrlCreateTabItem("")
$hGUI_BOT_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,51,"Debug"))
Local $x = 25, $y = 45
$grpDebug = GUICtrlCreateGroup(GetTranslated(636,34, "Debug"), $x - 20, $y - 20, 440, 360)
$chkDebugClick = GUICtrlCreateCheckbox(GetTranslated(636,40, "Click"), $x, $y-5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,35, "Debug: Write the clicked (x,y) coordinates to the log."))
$y += 20
$chkDebugSetlog = GUICtrlCreateCheckbox(GetTranslated(636,41, "Messages"), $x  , $y-5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,36, "Debug: Enables debug SetLog messages in code for Troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$chkDebugOcr = GUICtrlCreateCheckbox(GetTranslated(636,42, "OCR"), $x , $y-5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,37, "Debug: Enables Saving OCR images for troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$chkDebugImageSave = GUICtrlCreateCheckbox(GetTranslated(636,43, "Images"), $x , $y-5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,38, "Debug: Enables Saving images for troubleshooting."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$chkdebugBuildingPos = GUICtrlCreateCheckbox(GetTranslated(636,44, "Buildings"), $x  , $y-5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,39, "Debug: Enables showing positions of buildings in log."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$chkdebugTrain = GUICtrlCreateCheckbox(GetTranslated(636,73, "Training"), $x , $y-5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,74, "Debug: Enables showing debug during training."))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$chkdebugOCRDonate = GUICtrlCreateCheckbox(GetTranslated(636,91, "Online debug donations"), $x , $y-5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,92, "Debug: make ocr of donations and simulate only donate but no donate any troop"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 20
$chkdebugDeadBaseImage = GUICtrlCreateCheckbox(GetTranslated(636,107, "Dead Bases Images"), $x , $y-5, -1, -1)
_GUICtrlSetTip(-1, GetTranslated(636,108, "Debug: Capture the Skipped and detected dead bases"))
GUICtrlSetState(-1, $GUI_DISABLE)
GUICtrlSetState(-1, $GUI_HIDE)
$y += 40
$btnDBCheck = GUICtrlCreateButton("DeadBase Check", $x  , $y , 140, 25)
$y += 30
$btnPosCheck = GUICtrlCreateButton("Position Check", $x  , $y , 140, 25)
$y += 30
Local $x = 295
$y = 40
$btnTestTrain = GUICtrlCreateButton(GetTranslated(636,88, "Test Train"), $x  , $y , 140, 25)
$y += 30
$btnTestDonateCC = GUICtrlCreateButton(GetTranslated(636,89, "Test Donate"), $x  , $y , 140, 25)
$y += 30
$btnTestAttackBar = GUICtrlCreateButton(GetTranslated(636,90, "Test Attack Bar"), $x  , $y , 140, 25)
$y += 30
$btnTestClickDrag = GUICtrlCreateButton(GetTranslated(636,102, "Test Click Drag (scrolling)"), $x  , $y , 140, 25)
$y += 30
$btnTestImage = GUICtrlCreateButton(GetTranslated(636,103, "Test Image"), $x  , $y , 140, 25)
$y += 30
$btnEagle = GUICtrlCreateButton(GetTranslated(636,104, "Test Eagle"), $x  , $y , 140, 25)
$y += 30
$btnDropS = GUICtrlCreateButton("Test DropS CSV Comm.", $x  , $y , 140, 25)
$y += 30
$btnTestAD = GUICtrlCreateButton("Test Air Defense", $x  , $y , 140, 25)
$y += 30
$btnImageFolder = GUICtrlCreateButton(GetTranslated(636,105, "Test Folder"), $x  , $y , 140, 25)
$y += 30
$btnEQDeploy = GUICtrlCreateButton(GetTranslated(636,106, "Test Attack Bar 2"), $x  , $y , 140, 25)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_BOT_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,36,"Profiles"))
Global $txtPresetSaveFilename, $txtSavePresetMessage, $lblLoadPresetMessage,$btnGUIPresetDeleteConf, $chkCheckDeleteConf
Global $cmbPresetList, $txtPresetMessage,$btnGUIPresetLoadConf,  $lblLoadPresetMessage,$btnGUIPresetDeleteConf, $chkCheckDeleteConf
Local $x = 25, $y = 45
$grpProfiles = GUICtrlCreateGroup(GetTranslated(637,1, "Switch Profiles"), $x - 20, $y - 20, 440, 360)
$x -= 5
$cmbProfile = GUICtrlCreateCombo("", $x - 3, $y + 1, 130, 18, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
$txtTip = GetTranslated(637,2, "Use this to switch to a different profile")& @CRLF & GetTranslated(637,3, "Your profiles can be found in") & ": " & @CRLF & $sProfilePath
_GUICtrlSetTip(-1, $txtTip)
setupProfileComboBox()
PopulatePresetComboBox()
GUICtrlSetState(-1, $GUI_SHOW)
GUICtrlSetOnEvent(-1, "cmbProfile")
$txtVillageName = GUICtrlCreateInput(GetTranslated(637,4, "MyVillage"), $x - 3, $y, 130, 22, $ES_AUTOHSCROLL)
GUICtrlSetLimit (-1, 100, 0)
GUICtrlSetFont(-1, 9, 400, 1)
_GUICtrlSetTip(-1, GetTranslated(637,5, "Your village/profile's name"))
GUICtrlSetState(-1, $GUI_HIDE)
$bIconAdd = _GUIImageList_Create(22, 22, 4)
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd.bmp")
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd_2.bmp")
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd_2.bmp")
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd_4.bmp")
_GUIImageList_AddBitmap($bIconAdd, @ScriptDir & "\images\Button\iconAdd.bmp")
$bIconConfirm = _GUIImageList_Create(22, 22, 4)
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm.bmp")
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm_2.bmp")
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm_2.bmp")
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm_4.bmp")
_GUIImageList_AddBitmap($bIconConfirm, @ScriptDir & "\images\Button\iconConfirm.bmp")
$bIconDelete = _GUIImageList_Create(22, 22, 4)
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete.bmp")
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete_2.bmp")
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete_2.bmp")
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete_4.bmp")
_GUIImageList_AddBitmap($bIconDelete, @ScriptDir & "\images\Button\iconDelete.bmp")
$bIconCancel = _GUIImageList_Create(22, 22, 4)
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel.bmp")
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel_2.bmp")
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel_2.bmp")
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel_4.bmp")
_GUIImageList_AddBitmap($bIconCancel, @ScriptDir & "\images\Button\iconCancel.bmp")
$bIconEdit = _GUIImageList_Create(22, 22, 4)
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit.bmp")
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit_2.bmp")
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit_2.bmp")
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit_4.bmp")
_GUIImageList_AddBitmap($bIconEdit, @ScriptDir & "\images\Button\iconEdit.bmp")
$btnAdd = GUICtrlCreateButton("", $x + 135, $y, 22, 22)
_GUICtrlButton_SetImageList($btnAdd, $bIconAdd, 4)
GUICtrlSetOnEvent(-1, "btnAddConfirm")
GUICtrlSetState(-1, $GUI_SHOW)
_GUICtrlSetTip(-1, GetTranslated(637,6, "Add New Profile"))
$btnConfirmAdd = GUICtrlCreateButton("", $x + 135, $y, 22, 22)
_GUICtrlButton_SetImageList($btnConfirmAdd, $bIconConfirm, 4)
GUICtrlSetOnEvent(-1, "btnAddConfirm")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslated(637,7, "Confirm"))
$btnConfirmRename = GUICtrlCreateButton("", $x + 135, $y, 22, 22)
_GUICtrlButton_SetImageList($btnConfirmRename, $bIconConfirm, 4)
GUICtrlSetOnEvent(-1, "btnRenameConfirm")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslated(637,7, -1))
$btnDelete = GUICtrlCreateButton("", $x + 162, $y, 22, 22)
_GUICtrlButton_SetImageList($btnDelete, $bIconDelete, 4)
GUICtrlSetOnEvent(-1, "btnDeleteCancel")
GUICtrlSetState(-1, $GUI_SHOW)
_GUICtrlSetTip(-1, GetTranslated(637,8, "Delete Profile"))
$btnCancel = GUICtrlCreateButton("", $x + 162, $y, 22, 22)
_GUICtrlButton_SetImageList($btnCancel, $bIconCancel, 4)
GUICtrlSetOnEvent(-1, "btnDeleteCancel")
GUICtrlSetState(-1, $GUI_HIDE)
_GUICtrlSetTip(-1, GetTranslated(637,9, "Cancel"))
$btnRename = GUICtrlCreateButton("", $x + 190, $y, 22, 22)
_GUICtrlButton_SetImageList($btnRename, $bIconEdit, 4)
GUICtrlSetOnEvent(-1, "btnRenameConfirm")
_GUICtrlSetTip(-1, GetTranslated(637,10, "Rename Profile"))
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
$hGUI_BOT_TAB_ITEM4 = GUICtrlCreateTabItem(GetTranslated(600,37, "Stats"))
GUICtrlCreateTabItem("")
Global $LastControlToHide = GUICtrlCreateDummy()
Global $iPrevState[$LastControlToHide + 1]
GUISwitch($hGUI_STATS)
$hGUI_STATS_TAB = GUICtrlCreateTab(0, 0, $_GUI_MAIN_WIDTH - 30, $_GUI_MAIN_HEIGHT - 255 - 30, BitOR($TCS_MULTILINE, $TCS_RIGHTJUSTIFY))
Local $x = 375, $y = 0
$btnResetStats = GUICtrlCreateButton(GetTranslated(632,31, "Reset Stats"), $x, $y, 60, 20)
GUICtrlSetOnEvent(-1, "btnResetStats")
GUICtrlSetState(-1, $GUI_DISABLE)
$hGUI_STATS_TAB_ITEM1 = GUICtrlCreateTabItem(GetTranslated(600,38,"Gain"))
Local $xStart = 25, $yStart = 45
$x = $xStart
$y = $yStart
$grpResourceOnStart = GUICtrlCreateGroup(GetTranslated(632, 2, "Started with"), $x - 20, $y - 20, 90, 118)
$THLevels = GUICtrlCreateLabel(GetTranslated(632,0, "TH Level:"), $x - 20, $y + 3, 55, 17, $SS_RIGHT)
$THLevels04 = GUICtrlCreateIcon(@ScriptDir & "\images\TH\Levels\HdV04.ico",-1, $x + 42, $y - 2, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$THLevels05 = GUICtrlCreateIcon(@ScriptDir & "\images\TH\Levels\HdV05.ico",-1, $x + 42, $y - 2, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$THLevels06 = GUICtrlCreateIcon(@ScriptDir & "\images\TH\Levels\HdV06.ico",-1, $x + 42, $y - 2, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$THLevels07 = GUICtrlCreateIcon(@ScriptDir & "\images\TH\Levels\HdV07.ico",-1, $x + 42, $y - 2, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$THLevels08 = GUICtrlCreateIcon(@ScriptDir & "\images\TH\Levels\HdV08.ico",-1, $x + 42, $y - 2, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$THLevels09 = GUICtrlCreateIcon(@ScriptDir & "\images\TH\Levels\HdV09.ico",-1, $x + 42, $y - 2, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$THLevels10 = GUICtrlCreateIcon(@ScriptDir & "\images\TH\Levels\HdV10.ico",-1, $x + 42, $y - 2, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$THLevels11 = GUICtrlCreateIcon(@ScriptDir & "\images\TH\Levels\HdV11.ico",-1, $x + 42, $y - 2, 24, 24)
GUICtrlSetState(-1,$GUI_HIDE)
$y += 25
$lblResultStatsTemp = GUICtrlCreateLabel(GetTranslated(632, 3, "Report") & @CRLF & GetTranslated(632, 4, "will appear") & @CRLF & GetTranslated(632, 5, "here on") & @CRLF & GetTranslated(632, 6, "first run."), $x - 15, $y + 5, 100, 65, BitOR($SS_LEFT, $BS_MULTILINE))
$picResultGoldStart = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 50, $y, 16, 16)
$lblResultGoldStart = GUICtrlCreateLabel("", $x - 15, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632, 7, "The amount of Gold you had when the bot started.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picResultElixirStart = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 50, $y, 16, 16)
$lblResultElixirStart = GUICtrlCreateLabel("", $x - 15, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632, 8, "The amount of Elixir you had when the bot started.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picResultDEStart = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 50, $y, 16, 16)
$lblResultDEStart = GUICtrlCreateLabel("", $x - 10, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632, 9, "The amount of Dark Elixir you had when the bot started.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picResultTrophyStart = GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 50, $y, 16, 16)
$lblResultTrophyStart = GUICtrlCreateLabel("", $x - 10, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632, 10, "The amount of Trophies you had when the bot started.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 95
$y = $yStart + 23
$grpTotalLoot = GUICtrlCreateGroup(GetTranslated(632,20, "Total Gain"), $x - 20, $y - 15, 90, 90)
$lblTotalLootTemp = GUICtrlCreateLabel(GetTranslated(632,3, "Report") & @CRLF & GetTranslated(632,99, "will update") & @CRLF & GetTranslated(632,97, "here after") & @CRLF & GetTranslated(632,98, "each attack."), $x - 15, $y + 5, 100, 65, BitOR($SS_LEFT, $BS_MULTILINE))
$picGoldLoot = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 50, $y, 16, 16)
$lblGoldLoot = GUICtrlCreateLabel("", $x - 15, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,21, "The total amount of Gold you gained or lost while the Bot is running.") & @CRLF & GetTranslated(632,22, "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picElixirLoot = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 50, $y, 16, 16)
$lblElixirLoot = GUICtrlCreateLabel("", $x - 15, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,23, "The total amount of Elixir you gained or lost while the Bot is running.") & @CRLF & GetTranslated(632,22, "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picDarkLoot = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 50, $y, 16, 16)
$lblDarkLoot = GUICtrlCreateLabel("", $x - 15, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,24, "The total amount of Dark Elixir you gained or lost while the Bot is running.") & @CRLF & GetTranslated(632,22, "(This includes manual spending of resources on upgrade of buildings)")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picTrophyLoot = GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 50, $y, 16, 16)
$lblTrophyLoot = GUICtrlCreateLabel("", $x - 15, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,25, "The amount of Trophies you gained or lost while the Bot is running.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + (95 * 2)
$y = $yStart + 23
$grpHourlyStats = GUICtrlCreateGroup(GetTranslated(632,26, "Gain per Hour"), $x - 20, $y - 15, 80, 90)
$lblHourlyStatsTemp = GUICtrlCreateLabel(GetTranslated(632,3, "Report") & @CRLF & GetTranslated(632,99, "will update") & @CRLF & GetTranslated(632,97, "here after") & @CRLF & GetTranslated(632,98, "each attack."), $x - 15, $y + 5, 100, 65, BitOR($SS_LEFT, $BS_MULTILINE))
$picHourlyStatsGold = GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 40, $y, 16, 16)
$lblHourlyStatsGold = GUICtrlCreateLabel("", $x - 20, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,27, "Gold gain per hour")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picHourlyStatsElixir = GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 40, $y, 16, 16)
$lblHourlyStatsElixir = GUICtrlCreateLabel("", $x - 20, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,28, "Elixir gain per hour")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picHourlyStatsDark = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 40, $y, 16, 16)
$lblHourlyStatsDark = GUICtrlCreateLabel("", $x - 20, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,29, "Dark Elixir gain per hour")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picHourlyStatsTrophy = GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 40, $y, 16, 16)
$lblHourlyStatsTrophy = GUICtrlCreateLabel("", $x - 20, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,30, "Trophy gain per hour")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $yStart + 118
$grpLastAttack1 = GUICtrlCreateGroup(GetTranslated(632,102,"Last Attack"), $x - 20, $y - 15, 270, 115)
$x = $xStart + 10
$y = $yStart + 118 +20
$grpLastAttack = GUICtrlCreateGroup(GetTranslated(632, 11, "Gain"), $x - 20, $y - 15, 85, 90)
$lblLastAttackTemp = GUICtrlCreateLabel(GetTranslated(632, 3, "Report") & @CRLF & GetTranslated(632, 4, "will appear") & @CRLF & GetTranslated(632, 97, "here after") & @CRLF & GetTranslated(632, 98, "each attack."), $x - 15, $y + 5, 100, 65, BitOR($SS_LEFT, $BS_MULTILINE))
GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 45, $y, 16, 16)
$lblGoldLastAttack = GUICtrlCreateLabel("", $x - 15, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632, 12, "The amount of Gold you gained on the last attack.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 45, $y, 16, 16)
$lblElixirLastAttack = GUICtrlCreateLabel("", $x - 15, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632, 13, "The amount of Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picDarkLastAttack = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 45, $y, 16, 16)
$lblDarkLastAttack = GUICtrlCreateLabel("", $x - 15, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,14, "The amount of Dark Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x + 45, $y, 16, 16)
$lblTrophyLastAttack = GUICtrlCreateLabel("", $x - 15, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,15, "The amount of Trophies you gained or lost on the last attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart +10 + 90
$y = $yStart + 118 +20
$grpLastAttackBonus = GUICtrlCreateGroup(GetTranslated(632,16, "League Bonus"), $x - 20, $y - 15, 85, 90)
$lblLastAttackBonusTemp = GUICtrlCreateLabel(GetTranslated(632,3, "Report") & @CRLF & GetTranslated(632,99, "will update") & @CRLF & GetTranslated(632,97, "here after") & @CRLF & GetTranslated(632,98, "each attack."), $x - 15, $y + 5, 100, 65, BitOR($SS_LEFT, $BS_MULTILINE))
GUICtrlCreateIcon($pIconLib, $eIcnGold, $x + 45, $y, 16, 16)
$lblGoldBonusLastAttack = GUICtrlCreateLabel("", $x - 15, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,17, "The amount of Bonus Gold you gained on the last attack.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x + 45, $y, 16, 16)
$lblElixirBonusLastAttack = GUICtrlCreateLabel("", $x - 15, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,18, "The amount of Bonus Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$picDarkBonusLastAttack = GUICtrlCreateIcon($pIconLib, $eIcnDark, $x + 45, $y, 16, 16)
$lblDarkBonusLastAttack = GUICtrlCreateLabel("", $x - 15, $y + 2, 55, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,19, "The amount of Bonus Dark Elixir you gained on the last attack.")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart +10 + 165
$y = $yStart + 118 +20
$grpLeague = GUICtrlCreateGroup(GetTranslated(632,106, "League"), $x - 5, $y - 15, 70, 90)
$y += 1
$UnrankedLeague = GUICtrlCreateIcon(@ScriptDir & "\images\League\Unranked.ico",-1, $x - 2, $y - 2, 64, 64)
GUICtrlSetState(-1,$GUI_SHOW)
$BronzeLeague = GUICtrlCreateIcon(@ScriptDir & "\images\League\Bronze.ico",-1, $x - 2, $y - 2, 64, 64)
GUICtrlSetState(-1,$GUI_HIDE)
$SilverLeague = GUICtrlCreateIcon(@ScriptDir & "\images\League\Silver.ico",-1, $x - 2, $y - 2, 64, 64)
GUICtrlSetState(-1,$GUI_HIDE)
$GoldLeague = GUICtrlCreateIcon(@ScriptDir & "\images\League\Gold.ico",-1, $x - 2, $y - 2, 64, 64)
GUICtrlSetState(-1,$GUI_HIDE)
$CrystalLeague = GUICtrlCreateIcon(@ScriptDir & "\images\League\Crystal.ico",-1, $x - 2, $y - 2, 64, 64)
GUICtrlSetState(-1,$GUI_HIDE)
$MasterLeague = GUICtrlCreateIcon(@ScriptDir & "\images\League\Master.ico",-1, $x - 2, $y - 2, 64, 64)
GUICtrlSetState(-1,$GUI_HIDE)
$ChampionLeague = GUICtrlCreateIcon(@ScriptDir & "\images\League\Champion.ico",-1, $x - 2, $y - 2, 64, 64)
GUICtrlSetState(-1,$GUI_HIDE)
$TitanLeague = GUICtrlCreateIcon(@ScriptDir & "\images\League\Titan.ico",-1, $x - 2, $y - 2, 64, 64)
GUICtrlSetState(-1,$GUI_HIDE)
$LegendLeague = GUICtrlCreateIcon(@ScriptDir & "\images\League\Legend.ico",-1, $x - 2, $y - 2, 64, 64)
GUICtrlSetState(-1,$GUI_HIDE)
$lblLeague = GUICtrlCreateLabel("", $x + 20, $y + 50, 64, 64, $SS_CENTER)
GUICtrlSetFont($lblLeague, 12, $FW_BOLD)
GUICtrlSetColor($lblLeague, $COLOR_BLACK)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$btn1Chart = GUICtrlCreateButton("Totals 3d Bar", $x - 195, $y + 100, -1, -1)
GUICtrlSetOnEvent(-1, "btn1DisplayChart")
$btn2Chart = GUICtrlCreateButton("Totals Line", $x - 123, $y + 100, -1, -1)
GUICtrlSetOnEvent(-1, "btn2DisplayChart")
$btn3Chart = GUICtrlCreateButton("Rate/Hr Line", $x - 62, $y + 100, -1, -1)
GUICtrlSetOnEvent(-1, "btn3DisplayChart")
$btn4Chart = GUICtrlCreateButton("Attack Line", $x + 9, $y + 100, -1, -1)
GUICtrlSetOnEvent(-1, "btn4DisplayChart")
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_STATS_TAB_ITEM2 = GUICtrlCreateTabItem(GetTranslated(600,39,"Misc"))
Local $xStart = 25, $yStart = 45
$x = $xStart
$y = $yStart
$y += 5
$grpStatsMisc = GUICtrlCreateGroup(GetTranslated(632,32, "Stats: Misc"), $x - 20, $y - 20, 428, 330)
$x += 5
$y += 20
$GroupRun = GUICtrlCreateGroup(GetTranslated(632, 105, "Run:"), $x - 20, $y - 20, 416, 133)
$y -= 2
GUICtrlCreateIcon($pIconLib, $eIcnHourGlass, $x - 10, $y, 16, 16)
$lblruntime = GUICtrlCreateLabel(GetTranslated(632,47, "Runtime") & ":", $x + 13, $y + 2, -1, 17)
$lblresultruntime = GUICtrlCreateLabel("00:00:00", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,48, "The total Running Time of the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnRecycle, $x - 10, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,57, "Nbr of OoS") & ":", $x + 13, $y + 2, -1, 17)
$lblNbrOfOoS = GUICtrlCreateLabel("0", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,58, "The number of Out of Sync error occurred")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnBldgTarget, $x - 10, $y, 16, 16)
$lblvillagesattacked = GUICtrlCreateLabel(GetTranslated(632,33, "Attacked") & ":", $x + 13, $y + 2, -1, 17)
$lblresultvillagesattacked = GUICtrlCreateLabel("0", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,34, "The No. of Villages that were attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnBldgX, $x - 10, $y, 16, 16)
$lblvillagesskipped = GUICtrlCreateLabel(GetTranslated(632,35, "Skipped")&":", $x + 13, $y + 2, -1, 17)
$lblresultvillagesskipped = GUICtrlCreateLabel("0", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,36, "The No. of Villages that were skipped during search by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x - 10, $y, 16, 16)
$lbltrophiesdropped = GUICtrlCreateLabel(GetTranslated(632,45, "Dropped") & ":", $x + 13, $y + 2, -1, 17)
$lblresulttrophiesdropped = GUICtrlCreateLabel("0", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,46, "The amount of Trophies dropped by the Bot due to Trophy Settings (on Misc Tab).")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 5
$y = $yStart + 165
$GroupNumUpg = GUICtrlCreateGroup(GetTranslated(632, 103, "Upgrades Made"), $x - 20, $y - 20, 135, 118)
$y -= 2
GUICtrlCreateIcon($pIconLib, $eIcnWallGold, $x - 10, $y, 16, 16)
$lblwallbygold = GUICtrlCreateLabel(GetTranslated(632,37, "Upg. by Gold") &":", $x + 8, $y + 2, -1, 17)
$lblWallgoldmake = GUICtrlCreateLabel("0", $x + 40, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,38, "The No. of Walls upgraded by Gold.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnWallElixir, $x - 10, $y, 16, 16)
$lblwallbyelixir = GUICtrlCreateLabel(GetTranslated(632,39, "Upg. by Elixir") &":", $x + 8, $y + 2, -1, 17)
$lblWallelixirmake = GUICtrlCreateLabel("0", $x + 40, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,40, "The No. of Walls upgraded by Elixir.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnBldgGold, $x - 10, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,37, "Upg. by Gold") & ":", $x + 8, $y + 2, -1, 17)
$lblNbrOfBuildingUpgGold = GUICtrlCreateLabel("0", $x + 40, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,41, "The number of buildings upgraded using gold")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnBldgElixir, $x - 10, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,39, "Upg. by Elixir") & ":", $x + 8, $y + 2, -1, 17)
$lblNbrOfBuildingUpgElixir = GUICtrlCreateLabel("0", $x + 40, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,42, "The number of buildings upgraded using elixir")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnHeroes, $x - 10, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,43, "Hero Upgrade") & ":", $x + 8, $y + 2, -1, 17)
$lblNbrOfHeroUpg = GUICtrlCreateLabel("0", $x + 40, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,44, "The number of heroes upgraded")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 150
$y = $yStart + 165
$GroupNumUpg = GUICtrlCreateGroup(GetTranslated(632, 104, "Upgrade Costs"), $x - 20, $y - 20, 165, 118)
$x -= 10
$y -= 2
GUICtrlCreateIcon($pIconLib, $eIcnWallGold, $x - 5, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,49, "Upg. Cost Gold") & ":", $x + 13, $y + 2, -1, 17)
$lblWallUpgCostGold = GUICtrlCreateLabel("0", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,50, "The cost of gold used by bot while upgrading walls")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnWallElixir, $x - 5, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,51, "Upg. Cost Elixir") & ":", $x + 13, $y + 2, -1, 17)
$lblWallUpgCostElixir = GUICtrlCreateLabel("0", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,52, "The cost of elixir used by bot while upgrading walls")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnBldgGold, $x - 5, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,49, "Upg. Cost Gold") & ":", $x + 13, $y + 2, -1, 17)
$lblBuildingUpgCostGold = GUICtrlCreateLabel("0", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,53, "The cost of gold used by bot while upgrading buildings")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnBldgElixir, $x - 5, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,51, "Upg. Cost Elixir") & ":", $x + 13, $y + 2, -1, 17)
$lblBuildingUpgCostElixir = GUICtrlCreateLabel("0", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,54, "The cost of elixir used by bot while upgrading buildings")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnHeroes, $x - 5, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,55, "Upg. Cost DElixir") & ":", $x + 13, $y + 2, -1, 17)
$lblHeroUpgCost = GUICtrlCreateLabel("0", $x + 85, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,56, "The cost of dark elixir used by bot while upgrading heroes")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 215
$y = $yStart + 25
$y -= 2
GUICtrlCreateIcon($pIconLib, $eIcnMagnifier, $x + 27, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,59, "Search Cost") & ":", $x + 45, $y + 2, -1, 17)
$lblSearchCost = GUICtrlCreateLabel("0", $x + 115, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,60, "Search cost for skipping villages in gold")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnArcher, $x + 27, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,61, "Train Cost Elixir") & ":", $x + 45, $y + 2, -1, 17)
$lblTrainCostElixir = GUICtrlCreateLabel("0", $x + 115, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,62, "Elixir spent for training Barrack Troops")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnMinion, $x + 27, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,63, "Train Cost DElixir") & ":", $x + 45, $y + 2, -1, 17)
$lblTrainCostDElixir = GUICtrlCreateLabel("0", $x + 115, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,64, "Dark Elixir spent for training Dark Barrack Troops")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnMine, $x + 27, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,65, "Gold collected")&":", $x + 45, $y + 2, -1, 17)
$lblGoldFromMines = GUICtrlCreateLabel("0", $x + 115, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,66, "Gold gained by collecting mines")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 27, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,67, "Elixir collected") & ":", $x + 45, $y + 2, -1, 17)
$lblElixirFromCollectors = GUICtrlCreateLabel("0", $x + 115, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,68, "Elixir gained by collecting collectors")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnDrill, $x + 27, $y, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,69, "DElixir collected") & ":", $x + 45, $y + 2, -1, 17)
$lblDElixirFromDrills = GUICtrlCreateLabel("0", $x + 115, $y + 2, 60, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,70, "Dark Elixir gained by collecting drills")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_STATS_TAB_ITEM3 = GUICtrlCreateTabItem(GetTranslated(600,40,"Attacks"))
Local $xStart = 25, $yStart = 45
$x = $xStart
$y = $yStart
$grpStatsDB = GUICtrlCreateGroup(GetTranslated(632,71, "Dead Base"), $x - 20, $y - 20, 111, 120)
GUICtrlCreateLabel(GetTranslated(632,72, "Attacked") & ":", $x - 15, $y - 2, -1, 17)
$lblAttacked[$DB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,73, "The No. of Dead Base that were attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnGold, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, "gain") & ":", $x + 3, $y - 2, -1, 17)
$lblTotalGoldGain[$DB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,75, "The amount of Gold gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalElixirGain[$DB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,75, -1)
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnDark, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalDElixirGain[$DB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,100, "The amount of Dark Elixir gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalTrophyGain[$DB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,76, "The amount of Elixir gained from Dead Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$lblNbrOfDetectedMines[$DB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlCreateIcon($pIconLib, $eIcnMine, $x + 1, $y - 4, 16, 16)
$lblNbrOfDetectedCollectors[$DB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 37, $y - 4, 16, 16)
$lblNbrOfDetectedDrills[$DB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlCreateIcon($pIconLib, $eIcnDrill, $x + 73, $y - 4, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 116
$y = $yStart
$grpStatsLB = GUICtrlCreateGroup(GetTranslated(632,78, "Live Base"), $x - 20, $y - 20, 111, 120)
GUICtrlCreateLabel(GetTranslated(632,72, "Attacked") & ":", $x - 15, $y - 2, -1, 17)
$lblAttacked[$LB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,79, "The No. of Live Base that were attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnGold, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalGoldGain[$LB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,80, "The amount of Gold gained from Live Bases attacked by the Bot")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalElixirGain[$LB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,81, "The amount of Elixir gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnDark, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalDElixirGain[$LB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,82, "The amount of Dark Elixir gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalTrophyGain[$LB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,83, "The amount of Trophy gained from Live Bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$lblNbrOfDetectedMines[$LB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlCreateIcon($pIconLib, $eIcnMine, $x + 1, $y - 4, 16, 16)
$lblNbrOfDetectedCollectors[$LB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 37, $y - 4, 16, 16)
$lblNbrOfDetectedDrills[$LB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlCreateIcon($pIconLib, $eIcnDrill, $x + 73, $y - 4, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $yStart + 135
$grpStatsTS = GUICtrlCreateGroup(GetTranslated(632,90, "TH Snipe"), $x - 20, $y - 20, 111, 120)
GUICtrlCreateLabel(GetTranslated(632,72, "Attacked") & ":", $x - 15, $y - 2, -1, 17)
$lblAttacked[$TS] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,101,"The No. of TH Snipes attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnGold, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalGoldGain[$TS] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,91, "The amount of Gold gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalElixirGain[$TS] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,92, "The amount of Elixir gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnDark, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalDElixirGain[$TS] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,93, "The amount of Dark Elixir gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalTrophyGain[$TS] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,94, "The amount of Trophy gained from TH Snipe bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnGreenLight, $x - 15, $y - 4, 16, 16)
$lblNbrOfTSSuccess = GUICtrlCreateLabel("0", $x + 8, $y - 2, 25, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,95, "The number of successful TH Snipes")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateIcon($pIconLib, $eIcnRedLight, $x + 35, $y - 4, 16, 16)
$lblNbrOfTSFailed = GUICtrlCreateLabel("0", $x + 58, $y - 2, 25, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,96, "The number of failed TH Snipe attempt")
_GUICtrlSetTip(-1, $txtTip)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart + 116
$y = $yStart + 135
$grpStatsTB = GUICtrlCreateGroup(GetTranslated(632,84, "TH Bully"), $x - 20, $y - 20, 111, 120)
GUICtrlCreateLabel(GetTranslated(632,72, "Attacked") & ":", $x - 15, $y - 2, -1, 17)
$lblAttacked[$TB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,85, "The No. of TH Bully bases that were attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnGold, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalGoldGain[$TB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,86, "The amount of Gold gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnElixir, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalElixirGain[$TB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,87, "The amount of Elixir gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnDark, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalDElixirGain[$TB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,88, "The amount of Dark Elixir gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
GUICtrlCreateIcon($pIconLib, $eIcnTrophy, $x - 15, $y - 4, 16, 16)
GUICtrlCreateLabel(GetTranslated(632,74, -1) & ":", $x + 3, $y - 2, -1, 17)
$lblTotalTrophyGain[$TB] = GUICtrlCreateLabel("0", $x + 2, $y - 2, 80, 17, $SS_RIGHT)
$txtTip = GetTranslated(632,89, "The amount of Trophy gained from TH Bully bases attacked by the Bot.")
_GUICtrlSetTip(-1, $txtTip)
$y += 17
$lblNbrOfDetectedMines[$TB] = GUICtrlCreateLabel("0", $x - 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlCreateIcon($pIconLib, $eIcnMine, $x + 1, $y - 4, 16, 16)
$lblNbrOfDetectedCollectors[$TB] = GUICtrlCreateLabel("0", $x + 18, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlCreateIcon($pIconLib, $eIcnCollector, $x + 37, $y - 4, 16, 16)
$lblNbrOfDetectedDrills[$TB] = GUICtrlCreateLabel("0", $x + 54, $y - 2, 18, 17, $SS_RIGHT)
GUICtrlCreateIcon($pIconLib, $eIcnDrill, $x + 73, $y - 4, 16, 16)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$hGUI_STATS_TAB_ITEM4 = GUICtrlCreateTabItem("Donation Stats")
Local $xStart = 25, $yStart = 45
$x = $xStart
$y = $yStart
$grpStatsETroops = GUICtrlCreateGroup("Elixir Troops", $x - 20, $y - 20, 425, 130)
GUICtrlCreateIcon($pIconLib, $eIcnBarbarian, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eBarb, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnArcher, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eArch, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnGiant, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eGiant, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnGoblin, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eGobl, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnWallBreaker, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eWall, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnBalloon, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eBall, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x = $xStart
$y += 35
GUICtrlCreateIcon($pIconLib, $eIcnWizard, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eWiza, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnHealer, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eHeal, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnDragon, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eDrag, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnPekka, $x - 5, $y, 32, 32)
Assign("lblDonated" & $ePekk, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnBabyDragon, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eBabyD, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnMiner, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eMine, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x = $xStart
$y += 42
$x += 32 + 27 + 10 + 32 + 27 + 126
$lblTotalDonated = GUICtrlCreateLabel("Total Donated: 0", $x, $y + 10, 150, 16)
GUICtrlSetFont(-1,10, 800)
GUICtrlSetBkColor (-1, 0xbfdfff)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $yStart + 130
$grpStatsDTroops = GUICtrlCreateGroup("Dark Elixir Troops", $x - 20, $y - 20, 425, 100)
GUICtrlCreateIcon($pIconLib, $eIcnMinion, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eMini, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnHogRider, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eHogs, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnValkyrie, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eValk, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnGolem, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eGole, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnWitch, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eWitc, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnLavaHound, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eLava, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x = $xStart
$y += 35
GUICtrlCreateIcon($pIconLib, $eIcnBowler, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eBowl, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$y += 12
$x += 32 + 27 + 10 + 32 + 27 + 126
$lblTotalDonatedDark = GUICtrlCreateLabel("Total Donated: 0", $x, $y + 10, 150, 16)
GUICtrlSetFont(-1,10, 800)
GUICtrlSetBkColor (-1, 0xbfdfff)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$x = $xStart
$y = $yStart + 130 + 100
$grpStatsDTroops = GUICtrlCreateGroup("Dark Spells", $x - 20, $y - 20, 425, 70)
GUICtrlCreateIcon($pIconLib, $eIcnPoisonSpell, $x - 5, $y, 32, 32)
Assign("lblDonated" & $ePSpell, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnEarthQuakeSpell, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eESpell, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnHasteSpell, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eHaSpell, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$x += 32 + 27 + 10
GUICtrlCreateIcon($pIconLib, $eIcnSkeletonSpell, $x - 5, $y, 32, 32)
Assign("lblDonated" & $eSkSpell, GUICtrlCreateLabel("0", $x + 32, $y + 8, 27, 16), 2)
$y += 11
$x += 32 + 22
$lblTotalDonatedSpell = GUICtrlCreateLabel("Total Donated: 0", $x - 7, $y + 16, 150, 16)
GUICtrlSetFont(-1,10, 800)
GUICtrlSetBkColor (-1, 0xbfdfff)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$y -= 6
$x += 15
GUICtrlCreateButton("Reset Don. Stats", $x + 20, $y + 48, 110,30)
GUICtrlSetOnEvent(-1, "ResetDonateStats")
GUICtrlCreateTabItem("")
GUISwitch($frmBotEx)
$tabMain = GUICtrlCreateTab(5, 85 + $_GUI_MAIN_TOP, $_GUI_MAIN_WIDTH - 9, $_GUI_MAIN_HEIGHT - 225)
GUICtrlSetResizing(-1, $GUI_DOCKBORDERS)
$tabGeneral = GUICtrlCreateTabItem(GetTranslated(600,1, "Log"))
$tabVillage = GUICtrlCreateTabItem(GetTranslated(600,2, "Village"))
$tabAttack = GUICtrlCreateTabItem(GetTranslated(600,3,"Attack Plan"))
$tabBot = GUICtrlCreateTabItem(GetTranslated(600,4,"Bot"))
SplashStep(GetTranslated(500, 29, "Loading About Us tab..."))
$tabAboutUs = GUICtrlCreateTabItem(GetTranslated(600,5, "About Us"))
Local $x = 30, $y = 150 + $_GUI_MAIN_TOP
$grpCredits = GUICtrlCreateGroup("Credits", $x - 20, $y - 20, 450, 375)
$lblCreditsBckGrnd = GUICtrlCreateLabel("", $x - 20, $y - 20, 450, 375)
GUICtrlSetBkColor(-1, $COLOR_WHITE)
$txtCredits = "My Bot is brought to you by a worldwide team of open source"  & @CRLF &  "programmers and a vibrant community of forum members!"
$lblCredits1 = GUICtrlCreateLabel($txtCredits, $x - 5, $y - 10, 400, 35)
GUICtrlSetFont(-1, 10, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_NAVY)
$y += 30
$txtCredits = "Please visit our web forums:"
$lblCredits2 = GUICtrlCreateLabel($txtCredits, $x+20, $y, 180, 30)
GUICtrlSetFont(-1, 9.5, $FW_BOLD)
$labelMyBotURL = GUICtrlCreateLabel("https://mybot.run/forums", $x + 198, $y, 150, 20)
GUICtrlSetFont(-1, 9.5, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_BLUE)
$y += 22
$lblCredits3 = GUICtrlCreateLabel("Credits belong to following programmers for donating their time:", $x - 5, $y , 420, 20)
GUICtrlSetFont(-1,10, $FW_BOLD)
$y += 20
$txtCredits =	"Active developers: "
$lbltxtCreditsA1 = GUICtrlCreateLabel($txtCredits, $x+5, $y, 410, 20, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT),0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_NAVY)
$txtCredits = "Boju, Cosote, MonkeyHunter, Trlopes, Zengzeng"
$lbltxtCreditsA2 = GUICtrlCreateLabel($txtCredits, $x+10, $y+15, 410, 20, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT),0)
GUICtrlSetFont(-1,9, $FW_MEDIUM)
$y += 35
$txtCredits =	"Inactive developers: "
$lbltxtCreditsMIA1 = GUICtrlCreateLabel($txtCredits, $x+5, $y, 410, 20, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT),0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_NAVY)
$txtCredits = "Hervidero, Kaganus, Sardo"
$lbltxtCreditsMIA2 = GUICtrlCreateLabel($txtCredits, $x+10, $y+15, 410, 20, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT),0)
GUICtrlSetFont(-1,9, $FW_MEDIUM)
$y += 35
$txtCredits =	"Retired developers: "
$lbltxtCreditsDead1 = GUICtrlCreateLabel($txtCredits, $x+5, $y, 410, 20, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT),0)
GUICtrlSetFont(-1, 9.5, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_NAVY)
$txtCredits = "Antidote, AtoZ, Barracoda, Didipe, Dinobot, DixonHill, DkEd, GkevinOD, HungLe, KnowJack, LunaEclipse, ProMac, Safar46, Saviart, TheMaster1st, and others"
$lbltxtCreditsDead2 = GUICtrlCreateLabel($txtCredits, $x+10, $y+15, 410, 50, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT),0)
GUICtrlSetFont(-1,9, $FW_MEDIUM)
$y += 66
$txtCredits = "Special thanks to all contributing forum members helping " & @CRLF & "to make this software better! "
$lbltxtCredits2 = GUICtrlCreateLabel($txtCredits, $x+5, $y, 390,30, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $ES_CENTER),0)
GUICtrlSetFont(-1,9, $FW_MEDIUM)
$y += 40
$txtCredits =	"The latest release of 'My Bot' can be found at:"
$lbltxtNewVer = GUICtrlCreateLabel($txtCredits, $x - 5, $y, 400,15, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT),0)
GUICtrlSetFont(-1, 10, $FW_BOLD)
$y += 18
$labelForumURL = GUICtrlCreateLabel("https://mybot.run/forums/index.php?/forum/4-official-releases/", $x+25, $y, 450, 20)
GUICtrlSetFont(-1, 9.5, $FW_BOLD)
GUICtrlSetColor(-1, $COLOR_BLUE)
$y = 450
$txtWarn =	"By running this program, the user accepts all responsibility that arises from the use of this software."  & @CRLF &  "This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even " & @CRLF &  "the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General " & @CRLF &  "Public License for more details. The license can be found in the main code folder location."  & @CRLF &  "Copyright (C) 2015-2016 MyBot.run"
$lbltxtWarn1 = GUICtrlCreateLabel($txtWarn, $x - 5, $y, 410, 56, BITOR($WS_VISIBLE, $ES_AUTOVSCROLL, $SS_LEFT, $ES_CENTER),0)
GUICtrlSetColor(-1, 0x000053)
GUICtrlSetFont(-1, 6, $FW_BOLD)
GUICtrlCreateGroup("", -99, -99, 1, 1)
GUICtrlCreateTabItem("")
SplashStep(GetTranslated(500, 30, "Initializing GUI..."))
#Region
Bind_ImageList($tabMain)
Bind_ImageList($hGUI_VILLAGE_TAB)
Bind_ImageList($hGUI_ARMY_TAB)
Bind_ImageList($hGUI_DONATE_TAB)
Bind_ImageList($hGUI_UPGRADE_TAB)
Bind_ImageList($hGUI_NOTIFY_TAB)
Bind_ImageList($hGUI_ATTACK_TAB)
Bind_ImageList($hGUI_SEARCH_TAB)
Bind_ImageList($hGUI_DEADBASE_TAB)
Bind_ImageList($hGUI_ACTIVEBASE_TAB)
Bind_ImageList($hGUI_AttackOption_TAB)
Bind_ImageList($hGUI_THSNIPE_TAB)
Bind_ImageList($hGUI_BOT_TAB)
Bind_ImageList($hGUI_STRATEGIES_TAB)
Bind_ImageList($hGUI_STATS_TAB)
#EndRegion
#Region
GUICtrlSetState($hGUI_LOG, $GUI_SHOW)
#EndRegion
cmbLog()
If IsHWnd($hSplash) Then GUIDelete($hSplash)
If Not $NoFocusTampering Then
GUISetState(@SW_SHOW, $frmBot)
Else
GUISetState(@SW_SHOW, $frmBot)
EndIf
GUISetState(@SW_SHOWNOACTIVATE, $frmBotEx)
GUISetState(@SW_SHOWNOACTIVATE, $frmBotBottom)
GUISwitch($frmBotEx)
$frmBotMinimized = False
$frmBotPosInit = WinGetPos($frmBot)
ReDim $frmBotPosInit[7]
$frmBotPosInit[4] = _WinAPI_GetClientWidth($frmBot)
$frmBotPosInit[5] = _WinAPI_GetClientHeight($frmBot)
$frmBotPosInit[6] = ControlGetPos($frmBot, "", $frmBotEx)[3]
$statLog = _GUICtrlStatusBar_Create($frmBotBottom)
_ArrayConcatenate($G, $y)
_GUICtrlStatusBar_SetSimple($statLog)
_GUICtrlStatusBar_SetText($statLog, "Status : Idle")
$tiShow = TrayCreateItem(GetTranslated(500,31,"Show bot"))
TrayItemSetOnEvent($tiShow, "tiShow")
$tiHide = TrayCreateItem(GetTranslated(500,32, "Hide when minimized"))
TrayItemSetOnEvent($tiHide, "tiHide")
TrayCreateItem("")
$tiDonate = TrayCreateItem(GetTranslated(500,33, "Support Development"))
TrayItemSetOnEvent($tiDonate, "tiDonate")
$tiAbout = TrayCreateItem(GetTranslated(500,34, "About"))
TrayItemSetOnEvent($tiAbout, "tiAbout")
TrayCreateItem("")
$tiExit = TrayCreateItem(GetTranslated(500,35, "Exit"))
TrayItemSetOnEvent($tiExit, "tiExit")
If $hFuncLib <> -1 Then
GUICtrlSetState($btnStart, $GUI_ENABLE)
If $iTownHallLevel > 2 Then
GUICtrlSetState($btnSearchMode, $GUI_ENABLE)
EndIf
EndIf
SetDebugLog("$frmBot=" & $frmBot, Default, True)
SetDebugLog("$frmBotEx=" & $frmBotEx, Default, True)
SetDebugLog("$frmBotBottom=" & $frmBotBottom, Default, True)
SetDebugLog("$frmBotEmbeddedShield=" & $frmBotEmbeddedShield, Default, True)
SetDebugLog("$frmBotEmbeddedGarphics=" & $frmBotEmbeddedGarphics, Default, True)
Opt("GUIOnEventMode", 1)
Opt("MouseClickDelay", 10)
Opt("MouseClickDownDelay", 10)
Opt("TrayMenuMode", 3)
Opt("TrayOnEventMode", 1)
Func GUICtrlGetBkColor($hWnd)
If Not IsHWnd($hWnd) Then
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
Local $hDC = _WinAPI_GetDC($hWnd)
Local $iColor = _WinAPI_GetPixel($hDC, 0, 0)
_WinAPI_ReleaseDC($hWnd, $hDC)
Return $iColor
EndFunc
Global $groupSearchDB = $grpDBFilter&"#"&$cmbDBMeetGE&"#"&$txtDBMinGold&"#"&$picDBMinGold&"#"&$txtDBMinElixir&"#"&$picDBMinElixir&"#"&$txtDBMinGoldPlusElixir&"#"&$picDBMinGPEGold&"#"&$chkDBMeetDE&"#"&$txtDBMinDarkElixir&"#"&  $picDBMinDarkElixir&"#"&$chkDBMeetTrophy&"#"&$txtDBMinTrophy&"#"&$picDBMinTrophies&"#"&$chkDBMeetTH&"#"&$cmbDBTH&"#"&$picDBMaxTH10&"#"&$chkDBMeetTHO&"#"&$chkDBMeetOne&"#"&$chkMaxMortar[$DB]&"#"&$cmbWeakMortar[$DB]&"#"&  $picDBWeakMortar&"#"&$chkMaxWizTower[$DB]&"#"&$cmbWeakWizTower[$DB]&"#"&$picDBWeakWizTower&"#"&$chkMaxXBow[$DB]&"#"&$cmbWeakXBow[$DB]&"#"&$picDBWeakXbow&"#"&$chkMaxInferno[$DB]&"#"&$cmbWeakInferno[$DB]&"#"&$picDBWeakInferno&"#"&$chkMaxEagle[$DB]&"#"&$cmbWeakEagle[$DB]&"#"&$picDBWeakEagle
Global $groupHerosDB=$picDBHeroesWait&"#"&$txtDBHeroesWait&"#"&$chkDBKingWait&"#"&$chkDBQueenWait&"#"&$chkDBWardenWait&"#"&$IMGchkDBKingWait&"#"&$IMGchkDBQueenWait&"#"&$IMGchkDBWardenWait
Global $groupSearchAB=$grpABFilter&"#"&$cmbABMeetGE&"#"&$txtABMinGold&"#"&$picABMinGold&"#"&$txtABMinElixir&"#"&$picABMinElixir&"#"&$txtABMinGoldPlusElixir&"#"&$picABMinGPEGold&"#"&$chkABMeetDE&"#"&$txtABMinDarkElixir&"#"&  $picABMinDarkElixir&"#"&$chkABMeetTrophy&"#"&$txtABMinTrophy&"#"&$picABMinTrophies&"#"&$chkABMeetTH&"#"&$cmbABTH&"#"&$picABMaxTH10&"#"&$chkABMeetTHO&"#"&$chkABMeetOne&"#"&$chkMaxMortar[$LB]&"#"&$cmbWeakMortar[$LB]&"#"&  $picABWeakMortar&"#"&$chkMaxWizTower[$LB]&"#"&$cmbWeakWizTower[$LB]&"#"&$picABWeakWizTower&"#"&$chkMaxXBow[$LB]&"#"&$cmbWeakXBow[$LB]&"#"&$picABWeakXbow&"#"&$chkMaxInferno[$LB]&"#"&$cmbWeakInferno[$LB]&"#"&$picABWeakInferno&"#"&$chkMaxEagle[$LB]&"#"&$cmbWeakEagle[$LB]&"#"&$picABWeakEagle
Global $groupHerosAB=$picABHeroesWait&"#"&$txtABHeroesWait&"#"&$chkABKingWait&"#"&$chkABQueenWait&"#"&$chkABWardenWait&"#"&$IMGchkABKingWait&"#"&$IMGchkABQueenWait&"#"&$IMGchkABWardenWait
Global $groupSpellsDB=$chkDBSpellsWait&"#"&$IMGchkDBLightSpellWait&"#"&$IMGchkDBHealSpellWait&"#"&$IMGchkDBRageSpellWait&"#"&$IMGchkDBJumpSpellWait&"#"&$IMGchkDBFreezeSpellWait&"#"&$IMGchkDBPoisonSpellWait&"#"&$IMGchkDBEarthquakeSpellWait&"#"&$IMGchkDBHasteSpellWait
Global $groupSpellsAB=$chkABSpellsWait&"#"&$IMGchkABLightSpellWait&"#"&$IMGchkABHealSpellWait&"#"&$IMGchkABRageSpellWait&"#"&$IMGchkABJumpSpellWait&"#"&$IMGchkABFreezeSpellWait&"#"&$IMGchkABPoisonSpellWait&"#"&$IMGchkABEarthquakeSpellWait&"#"&$IMGchkABHasteSpellWait
Global $groupSearchTS=$grpTSFilter&"#"&$cmbTSMeetGE&"#"&$txtTSMinGold&"#"&$picTSMinGold&"#"&$txtTSMinElixir&"#"&$picTSMinElixir&"#"&$txtTSMinGoldPlusElixir&"#"&$picTSMinGPEGold&"#"&$chkTSMeetDE&"#"&$txtTSMinDarkElixir&"#"&$picTSMinDarkElixir&"#"&$lblAddTiles&"#"&$lblAddTiles2&"#"&$lblSWTTiles&"#"&$txtSWTTiles&"#"&$lblTHadd&"#"&$txtTHaddtiles
Global $groupAttackDB=$lblDBAlgorithm&"#"&$cmbDBAlgorithm&"#"&$lblDBSelectTroop&"#"&$cmbDBSelectTroop&"#"&$lblDBSelectSpecialTroop&"#"&$chkDBKingAttack&"#"&$chkDBQueenAttack&"#"&$chkDBWardenAttack&"#"&$chkDBDropCC&"#"&$chkDBLightSpell&"#"&$chkDBHealSpell&"#"&$chkDBRageSpell&"#"&$chkDBJumpSpell&"#"&$chkDBFreezeSpell&"#"&$chkDBPoisonSpell&"#"&$chkDBEarthquakeSpell&"#"&$chkDBHasteSpell
Global $groupAttackDBSpell=$chkDBLightSpell&"#"&$chkDBHealSpell&"#"&$chkDBRageSpell&"#"&$chkDBJumpSpell&"#"&$chkDBFreezeSpell&"#"&$chkDBPoisonSpell&"#"&$chkDBEarthquakeSpell&"#"&$chkDBHasteSpell
Global $groupIMGAttackDB=$IMGchkDBKingAttack&"#"&$IMGchkDBQueenAttack&"#"&$IMGchkDBWardenAttack&"#"&$IMGchkDBDropCC&"#"&$IMGchkDBLightSpell&"#"&$IMGchkDBHealSpell&"#"&$IMGchkDBRageSpell&"#"&$IMGchkDBJumpSpell&"#"&$IMGchkDBFreezeSpell&"#"&$IMGchkDBPoisonSpell&"#"&$IMGchkDBEarthquakeSpell&"#"&$IMGchkDBHasteSpell
Global $groupIMGAttackDBSpell=$IMGchkDBLightSpell&"#"&$IMGchkDBHealSpell&"#"&$IMGchkDBRageSpell&"#"&$IMGchkDBJumpSpell&"#"&$IMGchkDBFreezeSpell&"#"&$IMGchkDBPoisonSpell&"#"&$IMGchkDBEarthquakeSpell&"#"&$IMGchkDBHasteSpell
Global $groupAttackAB=$lblABAlgorithm&"#"&$cmbABAlgorithm&"#"&$lblABSelectTroop&"#"&$cmbABSelectTroop&"#"&$lblABSelectSpecialTroop&"#"&$chkABKingAttack&"#"&$chkABQueenAttack&"#"&$chkABWardenAttack&"#"&$chkABDropCC&"#"&$chkABLightSpell&"#"&$chkABHealSpell&"#"&$chkABRageSpell&"#"&$chkABJumpSpell&"#"&$chkABFreezeSpell&"#"&$chkABPoisonSpell&"#"&$chkABEarthquakeSpell&"#"&$chkABHasteSpell
Global $groupAttackABSpell=$chkABLightSpell&"#"&$chkABHealSpell&"#"&$chkABRageSpell&"#"&$chkABJumpSpell&"#"&$chkABFreezeSpell&"#"&$chkABPoisonSpell&"#"&$chkABEarthquakeSpell&"#"&$chkABHasteSpell
Global $groupIMGAttackAB=$IMGchkABKingAttack&"#"&$IMGchkABQueenAttack&"#"&$IMGchkABWardenAttack&"#"&$IMGchkABDropCC&"#"&$IMGchkABLightSpell&"#"&$IMGchkABHealSpell&"#"&$IMGchkABRageSpell&"#"&$IMGchkABJumpSpell&"#"&$IMGchkABFreezeSpell&"#"&$IMGchkABPoisonSpell&"#"&$IMGchkABEarthquakeSpell&"#"&$IMGchkABHasteSpell
Global $groupIMGAttackABSpell=$IMGchkABLightSpell&"#"&$IMGchkABHealSpell&"#"&$IMGchkABRageSpell&"#"&$IMGchkABJumpSpell&"#"&$IMGchkABFreezeSpell&"#"&$IMGchkABPoisonSpell&"#"&$IMGchkABEarthquakeSpell&"#"&$IMGchkABHasteSpell
Global $groupAttackTS=$grpABAttack&"#"&$lblAttackTHType&"#"&$cmbAttackTHType&"#"&$lblTSSelectTroop&"#"&$cmbTSSelectTroop&"#"&$lblTSSelectSpecialTroop&"#"&$chkTSKingAttack&"#"&$chkTSQueenAttack&"#"&$chkTSWardenAttack&"#"&$chkTSDropCC&"#"&$chkTSLightSpell&"#"&$chkTSHealSpell&"#"&$chkTSRageSpell&"#"&$chkTSJumpSpell&"#"&$chkTSFreezeSpell&"#"&$chkTSPoisonSpell&"#"&$chkTSEarthquakeSpell&"#"&$chkTSHasteSpell
Global $groupAttackTSSpell=$chkTSLightSpell&"#"&$chkTSHealSpell&"#"&$chkTSRageSpell&"#"&$chkTSJumpSpell&"#"&$chkTSFreezeSpell&"#"&$chkTSPoisonSpell&"#"&$chkTSEarthquakeSpell&"#"&$chkTSHasteSpell
Global $groupIMGAttackTS=$IMGchkTSKingAttack&"#"&$IMGchkTSQueenAttack&"#"&$IMGchkTSWardenAttack&"#"&$IMGchkTSDropCC&"#"&$IMGchkTSLightSpell&"#"&$IMGchkTSHealSpell&"#"&$IMGchkTSRageSpell&"#"&$IMGchkTSJumpSpell&"#"&$IMGchkTSFreezeSpell&"#"&$IMGchkTSPoisonSpell&"#"&$IMGchkTSEarthquakeSpell&"#"&$IMGchkTSHasteSpell
Global $groupIMGAttackTSSpell=$IMGchkTSLightSpell&"#"&$IMGchkTSHealSpell&"#"&$IMGchkTSRageSpell&"#"&$IMGchkTSJumpSpell&"#"&$IMGchkTSFreezeSpell&"#"&$IMGchkTSPoisonSpell&"#"&$IMGchkTSEarthquakeSpell&"#"&$IMGchkTSHasteSpell
Global $groupEndBattkeDB=$grpDBEndBattle&"#"&$chkDBTimeStopAtk&"#"&$lblDBTimeStopAtka&"#"&$txtDBTimeStopAtk&"#"&$lblDBTimeStopAtk&"#"&$chkDBTimeStopAtk2&"#"&$chkDBTimeStopAtk2&"#"&$lblDBTimeStopAtk2a&"#"&$txtDBTimeStopAtk2&"#"&$lblDBTimeStopAtk2&"#"&$lblDBMinRerourcesAtk2&"#"&$txtDBMinGoldStopAtk2&"#"&$picDBMinGoldStopAtk2&"#"&$txtDBMinElixirStopAtk2&"#"&$picDBMinElixirStopAtk2&"#"&$txtDBMinDarkElixirStopAtk2&"#"&$picDBMinDarkElixirStopAtk2&"#"&$chkDBEndNoResources&"#"&$chkDBEndOneStar&"#"&$chkDBEndTwoStars
Global $groupEndBattkeAB=$grpABEndBattle&"#"&$chkABTimeStopAtk&"#"&$lblABTimeStopAtka&"#"&$txtABTimeStopAtk&"#"&$lblABTimeStopAtk&"#"&$chkABTimeStopAtk2&"#"&$chkABTimeStopAtk2&"#"&$lblABTimeStopAtk2a&"#"&$txtABTimeStopAtk2&"#"&$lblABTimeStopAtk2&"#"&$lblABMinRerourcesAtk2&"#"&$txtABMinGoldStopAtk2&"#"&$picABMinGoldStopAtk2&"#"&$txtABMinElixirStopAtk2&"#"&$picABMinElixirStopAtk2&"#"&$txtABMinDarkElixirStopAtk2&"#"&$picABMinDarkElixirStopAtk2&"#"&$chkABEndNoResources&"#"&$chkABEndOneStar&"#"&$chkABEndTwoStars
Global $groupKingSleeping=$IMGchkDBKingSleepWait&"#"&$IMGchkABKingSleepWait&"#"&$IMGchkKingSleepWait
Global $groupQueenSleeping=$IMGchkDBQueenSleepWait&"#"&$IMGchkABQueenSleepWait&"#"&$IMGchkQueenSleepWait
Global $groupWardenSleeping=$IMGchkDBWardenSleepWait&"#"&$IMGchkABWardenSleepWait&"#"&$IMGchkWardenSleepWait
Global $groupCloseWaitTrain=$chkCloseWaitTrain&"#"&$btnCloseWaitStop&"#"&$picCloseWaitTrain&"#"&$btnCloseWaitStopRandom&"#"&$picCloseWaitStop&"#"&$btnCloseWaitExact&"#"&$picCloseWaitExact&"#"&$btnCloseWaitRandom&"#"&$cmbCloseWaitRdmPercent&"#"&$lblCloseWaitRdmPercent
Global $groupLightning =$lblLightningIcon&"#"&$lblLightningSpell&"#"&$txtNumLightningSpell&"#"&$lblTimesLightS
Global $groupHeal =$lblHealIcon&"#"&$lblHealSpell&"#"&$txtNumHealSpell&"#"&$lblTimesHealS
Global $groupRage =$lblRageIcon&"#"&$lblRageSpell&"#"&$txtNumRageSpell&"#"&$lblTimesRageS
Global $groupJumpSpell =$lblJumpSpellIcon&"#"&$lblJumpSpell&"#"&$txtNumJumpSpell&"#"&$lblTimesJumpS
Global $groupFreeze =$lblFreezeIcon&"#"&$lblFreezeSpell&"#"&$txtNumFreezeSpell&"#"&$lblFreezeS
Global $groupClone = $lblCloneIcon&"#"&$lblCloneSpell&"#"&$txtNumCloneSpell&"#"&$lblCloneS
Global $groupPoison =$lblPoisonIcon&"#"&$lblPoisonSpell&"#"&$txtNumPoisonSpell&"#"&$lblTimesPoisonS
Global $groupEarthquake =$lblEarthquakeIcon&"#"&$lblEarthquakeSpell&"#"&$txtNumEarthSpell&"#"&$lblTimesEarthquakeS
Global $groupHaste =$lblHasteIcon&"#"&$lblHasteSpell&"#"&$txtNumHasteSpell&"#"&$lblTimesHasteS
Global $groupSkeleton =$lblSkeletonIcon&"#"&$lblSkeletonSpell&"#"&$txtNumSkeletonSpell&"#"&$lblTimesSkeletonS
Global $groupListSpells=$groupLightning&"#"&$groupHeal&"#"&$groupRage&"#"&$groupJumpSpell&"#"&$groupFreeze&"#"&$groupClone&"#"&$groupPoison&"#"&$groupEarthquake&"#"&$groupHaste&"#"&$groupSkeleton
Global $groupListTHLevels=$THLevels04&"#"&$THLevels05&"#"&$THLevels06&"#"&$THLevels07&"#"&$THLevels08&"#"&$THLevels09&"#"&$THLevels10&"#"&$THLevels11
Global $groupLeague=$UnrankedLeague&"#"&$BronzeLeague&"#"&$SilverLeague&"#"&$GoldLeague &"#"&$CrystalLeague&"#"&$MasterLeague&"#"&$ChampionLeague&"#"&$TitanLeague&"#"&$LegendLeague
Func BotStart()
ResumeAndroid()
$RunModeChart = 1
$RunState = True
$TogglePauseAllowed = True
$SkipFirstZoomout = False
EnableControls($frmBotBottom, False, $frmBotBottomCtrlState)
$bTrainEnabled = True
$bDonationEnabled = True
$MeetCondStop = False
$Is_ClientSyncError = False
$bDisableBreakCheck = False
$bDisableDropTrophy = False
If Not $bSearchMode Then
CreateLogFile()
CreateAttackLogFile()
If $FirstRun = -1 Then $FirstRun = 1
EndIf
_GUICtrlEdit_SetText($txtLog, _PadStringCenter(" BOT LOG ", 71, "="))
_GUICtrlRichEdit_SetFont($txtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($txtLog, "" & @CRLF, _ColorConvert($Color_Black))
SaveConfig()
readConfig()
applyConfig(False)
If BitAND($AndroidSupportFeature, 1 + 2) = 0 And $ichkBackground = 1 Then
GUICtrlSetState($chkBackground, $GUI_UNCHECKED)
chkBackground()
SetLog("Background Mode not supported for " & $Android & " and has been disabled", $COLOR_ERROR)
EndIf
DisableGuiControls()
EnableControls($frmBotBottom, Default, $frmBotBottomCtrlState)
GUICtrlSetState($btnStart, $GUI_HIDE)
GUICtrlSetState($btnStop, $GUI_SHOW)
GUICtrlSetState($btnPause, $GUI_SHOW)
GUICtrlSetState($btnResume, $GUI_HIDE)
GUICtrlSetState($btnSearchMode, $GUI_HIDE)
GUICtrlSetState($chkBackground, $GUI_DISABLE)
Local $Result = False
Local $hWin = $HWnD
If $HWnD = 0 Then
If $hWin = 0 Then
$Result = OpenAndroid(False)
Else
$Result = RebootAndroid(False)
EndIf
EndIf
SetDebugLog("Android Window Handle: " & WinGetAndroidHandle())
If $HWnD <> 0 Then
If Not $RunState Then Return
If $AndroidBackgroundLaunched = True Or AndroidControlAvailable() Then
If Not $Result Then
$Result = InitiateLayout()
EndIf
Else
SetLog("Current " & $Android & " Window not supported by MyBot", $COLOR_ERROR)
$Result = RebootAndroid(False)
EndIf
If Not $RunState Then Return
Local $hWndActive = $HWnD
If $NoFocusTampering = False And $AndroidBackgroundLaunched = False And $AndroidEmbedded = False Then
Local $hTimer = TimerInit()
$hWndActive = -1
Local $activeHWnD = WinGetHandle("")
While TimerDiff($hTimer) < 1000 And $hWndActive <> $HWnD And Not _Sleep(100)
$hWndActive = WinActivate($HWnD)
WEnd
WinActivate($activeHWnD)
EndIf
If Not $RunState Then Return
If $hWndActive = $HWnD And ($AndroidBackgroundLaunched = True Or AndroidControlAvailable())  Then
Initiate()
Else
SetLog("Cannot use " & $Android & ", please check log", $COLOR_ERROR)
btnStop()
EndIf
Else
SetLog("Cannot start " & $Android & ", please check log", $COLOR_ERROR)
btnStop()
EndIf
EndFunc
Func BotStop()
ResumeAndroid()
$RunState = False
$TPaused = False
$TogglePauseAllowed = True
Local $aCtrlState
EnableControls($frmBotBottom, False, $frmBotBottomCtrlState)
EnableGuiControls()
AndroidBotStopEvent()
AndroidShield("btnStop", Default)
EnableControls($frmBotBottom, Default, $frmBotBottomCtrlState)
GUICtrlSetState($chkBackground, $GUI_ENABLE)
GUICtrlSetState($btnStart, $GUI_SHOW)
GUICtrlSetState($btnStop, $GUI_HIDE)
GUICtrlSetState($btnPause, $GUI_HIDE)
GUICtrlSetState($btnResume, $GUI_HIDE)
If $iTownHallLevel > 2 Then GUICtrlSetState($btnSearchMode, $GUI_ENABLE)
GUICtrlSetState($btnSearchMode, $GUI_SHOW)
GUICtrlSetState($btnAttackNowDB, $GUI_HIDE)
GUICtrlSetState($btnAttackNowLB, $GUI_HIDE)
GUICtrlSetState($btnAttackNowTS, $GUI_HIDE)
GUICtrlSetState($pic2arrow, $GUI_SHOW)
GUICtrlSetState($lblVersion, $GUI_SHOW)
SetLog(_PadStringCenter(" Bot Stop ", 50, "="), $COLOR_ACTION)
If Not $bSearchMode Then
If Not $TPaused Then $iTimePassed += Int(TimerDiff($sTimer))
$Restart = True
FileClose($hLogFileHandle)
$hLogFileHandle = ""
FileClose($hLogFileTrain)
$hLogFileTrain = ""
FileClose($hAttackLogFileHandle)
$hAttackLogFileHandle = ""
Else
$bSearchMode = False
EndIf
EndFunc
Func BotSearchMode()
$bSearchMode = True
$Restart = False
$Is_ClientSyncError = False
If $FirstRun = 1 Then $FirstRun = -1
btnStart()
checkMainScreen(False)
If _Sleep(100) Then Return
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If _Sleep(100) Then Return
If _Sleep(100) Then Return
PrepareSearch()
If _Sleep(1000) Then Return
VillageSearch()
If _Sleep(100) Then Return
btnStop()
EndFunc
Global Enum $eBotNoAction, $eBotStart, $eBotStop, $eBotSearchMode, $eBotClose
Global $BotAction = $eBotNoAction
Global $aChkDonateControls[21] = [$chkDonateBarbarians, $chkDonateArchers, $chkDonateGiants, $chkDonateGoblins, $chkDonateWallBreakers, $chkDonateBalloons, $chkDonateWizards, $chkDonateHealers, $chkDonateDragons, $chkDonatePekkas, $chkDonateBabyDragons, $chkDonateMiners, $chkDonateMinions, $chkDonateHogRiders, $chkDonateValkyries, $chkDonateGolems, $chkDonateWitches, $chkDonateLavaHounds, $chkDonateBowlers, $chkDonateCustomA, $chkDonateCustomB]
Global $aChkDonateControlsSpell[4] = [$chkDonatePoisonSpells, $chkDonateEarthQuakeSpells, $chkDonateHasteSpells, $chkDonateSkeletonSpells]
Global $aChkDonateAllControls[21] = [$chkDonateAllBarbarians, $chkDonateAllArchers, $chkDonateAllGiants, $chkDonateAllGoblins, $chkDonateAllWallBreakers, $chkDonateAllBalloons, $chkDonateAllWizards, $chkDonateAllHealers, $chkDonateAllDragons, $chkDonateAllPekkas, $chkDonateAllBabyDragons, $chkDonateAllMiners, $chkDonateAllMinions, $chkDonateAllHogRiders, $chkDonateAllValkyries, $chkDonateAllGolems, $chkDonateAllWitches, $chkDonateAllLavaHounds, $chkDonateAllBowlers, $chkDonateAllCustomA, $chkDonateAllCustomB]
Global $aChkDonateAllControlsSpell[4] = [$chkDonateAllPoisonSpells, $chkDonateAllEarthQuakeSpells, $chkDonateAllHasteSpells, $chkDonateAllSkeletonSpells]
Global $aTxtDonateControls[21] = [$txtDonateBarbarians, $txtDonateArchers, $txtDonateGiants, $txtDonateGoblins, $txtDonateWallBreakers, $txtDonateBalloons, $txtDonateWizards, $txtDonateHealers, $txtDonateDragons, $txtDonatePekkas, $txtDonateBabyDragons, $txtDonateMiners, $txtDonateMinions, $txtDonateHogRiders, $txtDonateValkyries, $txtDonateGolems, $txtDonateWitches, $txtDonateLavaHounds, $txtDonateBowlers, $txtDonateCustomA, $txtDonateCustomB]
Global $aTxtDonateControlsSpell[4] = [$txtDonatePoisonSpells, $txtDonateEarthQuakeSpells, $txtDonateHasteSpells, $txtDonateSkeletonSpells]
Global $aTxtBlacklistControls[21] = [$txtBlacklistBarbarians, $txtBlacklistArchers, $txtBlacklistGiants, $txtBlacklistGoblins, $txtBlacklistWallBreakers, $txtBlacklistBalloons, $txtBlacklistWizards, $txtBlacklistHealers, $txtBlacklistDragons, $txtBlacklistPekkas, $txtBlacklistBabyDragons, $txtBlacklistMiners, $txtBlacklistMinions, $txtBlacklistHogRiders, $txtBlacklistValkyries, $txtBlacklistGolems, $txtBlacklistWitches, $txtBlacklistLavaHounds, $txtBlacklistBowlers, $txtBlacklistCustomA, $txtBlacklistCustomB]
Global $aTxtBlacklistControlsSpell[4] = [$txtBlacklistPoisonSpells, $txtBlacklistEarthQuakeSpells, $txtBlacklistHasteSpells, $txtBlacklistSkeletonSpells]
Global $aLblBtnControls[21] = [$lblBtnBarbarians, $lblBtnArchers, $lblBtnGiants, $lblBtnGoblins, $lblBtnWallBreakers, $lblBtnBalloons, $lblBtnWizards, $lblBtnHealers, $lblBtnDragons, $lblBtnPekkas, $lblBtnBabyDragons, $lblBtnMiners, $lblBtnMinions, $lblBtnHogRiders, $lblBtnValkyries, $lblBtnGolems, $lblBtnWitches, $lblBtnLavaHounds, $lblBtnBowlers, $lblBtnCustomA, $lblBtnCustomB]
Global $aLblBtnControlsSpell[4] = [$lblBtnPoisonSpells, $lblBtnEarthQuakeSpells, $lblBtnHasteSpells, $lblBtnSkeletonSpells]
Global $aMainTabItems[7] = [$tabMain, $tabGeneral, $tabVillage, $tabAttack, $tabBot, $tabAboutUs]
Global $aTabControlsVillage[6] = [$hGUI_VILLAGE_TAB, $hGUI_VILLAGE_TAB_ITEM1, $hGUI_VILLAGE_TAB_ITEM2, $hGUI_VILLAGE_TAB_ITEM3, $hGUI_VILLAGE_TAB_ITEM4, $hGUI_VILLAGE_TAB_ITEM5]
Global $aTabControlsDonate[4] = [$hGUI_DONATE_TAB, $hGUI_DONATE_TAB_ITEM1, $hGUI_DONATE_TAB_ITEM2, $hGUI_DONATE_TAB_ITEM3]
Global $aTabControlsUpgrade[5] = [$hGUI_UPGRADE_TAB, $hGUI_UPGRADE_TAB_ITEM1, $hGUI_UPGRADE_TAB_ITEM2, $hGUI_UPGRADE_TAB_ITEM3, $hGUI_UPGRADE_TAB_ITEM4]
Global $aTabControlsNotify[4] = [$hGUI_NOTIFY_TAB, $hGUI_NOTIFY_TAB_ITEM2, $hGUI_NOTIFY_TAB_ITEM4, $hGUI_NOTIFY_TAB_ITEM6]
Global $aTabControlsAttack[5] = [$hGUI_ATTACK_TAB, $hGUI_ATTACK_TAB_ITEM1, $hGUI_ATTACK_TAB_ITEM2, $hGUI_ATTACK_TAB_ITEM3, $hGUI_ATTACK_TAB_ITEM4]
Global $aTabControlsArmy[4] = [$hGUI_ARMY_TAB, $hGUI_ARMY_TAB_ITEM1, $hGUI_ARMY_TAB_ITEM2, $hGUI_ARMY_TAB_ITEM3]
Global $aTabControlsSearch[6] = [$hGUI_SEARCH_TAB, $hGUI_SEARCH_TAB_ITEM1, $hGUI_SEARCH_TAB_ITEM2, $hGUI_SEARCH_TAB_ITEM3, $hGUI_SEARCH_TAB_ITEM4, $hGUI_SEARCH_TAB_ITEM5]
Global $aTabControlsDeadbase[5] = [$hGUI_DEADBASE_TAB, $hGUI_DEADBASE_TAB_ITEM1, $hGUI_DEADBASE_TAB_ITEM2, $hGUI_DEADBASE_TAB_ITEM3, $hGUI_DEADBASE_TAB_ITEM4]
Global $aTabControlsActivebase[4] = [$hGUI_ACTIVEBASE_TAB, $hGUI_ACTIVEBASE_TAB_ITEM1, $hGUI_ACTIVEBASE_TAB_ITEM2, $hGUI_ACTIVEBASE_TAB_ITEM3]
Global $aTabControlsTHSnipe[4] = [$hGUI_THSNIPE_TAB, $hGUI_THSNIPE_TAB_ITEM1, $hGUI_THSNIPE_TAB_ITEM2, $hGUI_THSNIPE_TAB_ITEM3]
Global $aTabControlsAttackOptions[5] = [$hGUI_AttackOption_TAB, $hGUI_AttackOption_TAB_ITEM1, $hGUI_AttackOption_TAB_ITEM2, $hGUI_AttackOption_TAB_ITEM3, $hGUI_AttackOption_TAB_ITEM4]
Global $aTabControlsStrategies[3] = [$hGUI_STRATEGIES_TAB, $hGUI_STRATEGIES_TAB_ITEM1, $hGUI_STRATEGIES_TAB_ITEM2]
Global $aTabControlsBot[6] = [$hGUI_BOT_TAB, $hGUI_BOT_TAB_ITEM1, $hGUI_BOT_TAB_ITEM2, $hGUI_BOT_TAB_ITEM3, $hGUI_BOT_TAB_ITEM4, $hGUI_BOT_TAB_ITEM5]
Global $aTabControlsStats[4] = [$hGUI_STATS_TAB, $hGUI_STATS_TAB_ITEM1, $hGUI_STATS_TAB_ITEM2, $hGUI_STATS_TAB_ITEM3]
Global $aAlwaysEnabledControls[32] = [$chkUpdatingWhenMinimized, $chkHideWhenMinimized, $chkDebugClick, $chkDebugSetlog, $chkDebugOcr, $chkDebugImageSave, $chkdebugBuildingPos, $chkdebugTrain, $chkdebugOCRDonate, $chkdebugDeadBaseImage, $btnTestTrain, $btnTestDonateCC, $btnTestAttackBar, $btnTestClickDrag, $btnTestImage, $btnEagle, $btnImageFolder, $btnEQDeploy, $btnDropS, $btnTestAD, $btnDBCheck, $btnPosCheck, $lblLightningUsed, $lblSmartZap, $DocXP1, $DocXP2, $DocXP3, $DocXP4, $lblXPatStart, $lblXPCurrent, $lblXPSXWon, $lblXPSXWonHour]
Global $frmBot_WNDPROC = 0
Func UpdateFrmBotStyle()
Local $ShowMinimize = $AndroidBackgroundLaunched = True Or $AndroidEmbedded = False Or ($AndroidEmbedded = True And $ichkBackground = 1)
Local $lStyle = $WS_MINIMIZEBOX
Local $lNewStyle = ($ShowMinimize ? $lStyle : 0)
Local $lCurStyle = _WinAPI_GetWindowLong($frmBot, $GWL_STYLE)
If BitAND($lCurStyle, $lStyle) <> $lNewStyle Then
If $ShowMinimize Then
$lNewStyle = BitOR($lCurStyle, $lStyle)
SetDebugLog("Show Bot Minimize Button")
Else
$lNewStyle = BitAND($lCurStyle, BitNOT($lStyle))
SetDebugLog("Hide Bot Minimize Button")
EndIf
_WinAPI_SetWindowLong($frmBot, $GWL_STYLE, $lNewStyle)
Return True
EndIf
Return False
EndFunc
Func IsTab($controlID)
If _ArraySearch($aMainTabItems, $controlID) <> -1 Or  _ArraySearch($aTabControlsVillage, $controlID) <> -1 Or  _ArraySearch($aTabControlsDonate, $controlID) <> -1 Or  _ArraySearch($aTabControlsUpgrade, $controlID) <> -1 Or  _ArraySearch($aTabControlsNotify, $controlID) <> -1 Or  _ArraySearch($aTabControlsAttack, $controlID) <> -1 Or  _ArraySearch($aTabControlsArmy, $controlID) <> -1 Or  _ArraySearch($aTabControlsSearch, $controlID) <> -1 Or  _ArraySearch($aTabControlsDeadbase, $controlID) <> -1 Or  _ArraySearch($aTabControlsActivebase, $controlID) <> -1 Or  _ArraySearch($aTabControlsTHSnipe, $controlID) <> -1 Or  _ArraySearch($aTabControlsAttackOptions, $controlID) <> -1 Or  _ArraySearch($aTabControlsStrategies, $controlID) <> -1 Or  _ArraySearch($aTabControlsBot, $controlID) <> -1 Or  _ArraySearch($aTabControlsStats, $controlID) <> -1 Then
Return True
EndIf
Return False
EndFunc
Func IsAlwaysEnabledControl($controlID)
If _ArraySearch($aAlwaysEnabledControls, $controlID) <> -1 Then
Return True
EndIf
Return False
EndFunc
Global $Initiate = 0
Global $GUIControl_Disabled = False
Global $ichklanguageFirst = 0
Global $ichklanguage = 1
AtkLogHead()
Func Initiate()
WinGetAndroidHandle()
If $HWnD <> 0 And ($AndroidBackgroundLaunched = True Or AndroidControlAvailable()) Then
SetLog(_PadStringCenter(" " & $sBotTitle & " Powered by MyBot.run ", 50, "~"), $COLOR_DEBUG)
SetLog($Compiled & " running on " & @OSVersion & " " & @OSServicePack & " " & @OSArch)
If Not $bSearchMode Then
SetLog(_PadStringCenter(" Bot Start ", 50, "="), $COLOR_GREEN)
Else
SetLog(_PadStringCenter(" Search Mode Start ", 50, "="), $COLOR_GREEN)
EndIf
SetLog(_PadStringCenter("  Current Profile: " & $sCurrProfile & " ", 73, "-"), $COLOR_BLUE)
If $DebugSetlog = 1 Or $DebugOcr = 1 Or $debugRedArea = 1 Or $DevMode = 1 Or $debugImageSave = 1 Or $debugBuildingPos = 1 Or $debugOCRdonate = 1 Then
SetLog(_PadStringCenter(" Warning Debug Mode Enabled! Setlog: " & $DebugSetlog & " OCR: " & $DebugOcr & " RedArea: " & $debugRedArea & " ImageSave: " & $debugImageSave & " BuildingPos: " & $debugBuildingPos & " OCRDonate: " & $debugOCRdonate, 55, "-"), $COLOR_DEBUG)
EndIf
$AttackNow = False
$FirstStart = True
$Checkrearm = True
If $NotifyDeleteAllPushesOnStart = 1 Then _DeletePush()
If Not $bSearchMode Then
$sTimer = TimerInit()
EndIf
AndroidBotStartEvent()
If Not $RunState Then Return
If Not $bSearchMode Then
If $restarted = 1 Then
$restarted = 0
IniWrite($config, "general", "Restarted", 0)
PushMsg("Restarted")
EndIf
EndIf
If Not $RunState Then Return
AndroidShield("Initiate", True)
checkMainScreen()
If Not $RunState Then Return
ZoomOut()
If Not $RunState Then Return
If Not $bSearchMode Then
BotDetectFirstTime()
If Not $RunState Then Return
If $ichklanguageFirst = 0 And $ichklanguage = 1 Then $ichklanguageFirst = TestLanguage()
If Not $RunState Then Return
runBot()
EndIf
Else
SetLog("Not in Game!", $COLOR_RED)
btnStop()
EndIf
EndFunc
Func InitiateLayout()
Local $AdjustScreenIfNecessarry = True
WinGetAndroidHandle()
Local $BSsize = getAndroidPos()
If IsArray($BSsize) Then
Local $BSx = $BSsize[2]
Local $BSy = $BSsize[3]
SetDebugLog("InitiateLayout: " & $title & " Android-ClientSize: " & $BSx & " x " & $BSy, $COLOR_BLUE)
If Not CheckScreenAndroid($BSx, $BSy) Then
If $AdjustScreenIfNecessarry = True Then
Local $MsgRet = $IDOK
If $MsgRet = $IDOK Then
Return RebootAndroidSetScreen()
EndIf
Else
SetLog("Cannot use " & $Android & ".", $COLOR_RED)
SetLog("Please set its screen size manually to " & $AndroidClientWidth & " x " & $AndroidClientHeight, $COLOR_RED)
btnStop()
Return False
EndIf
EndIf
DisposeWindows()
Return True
EndIf
Return False
EndFunc
Func chkBackground()
If GUICtrlRead($chkBackground) = $GUI_CHECKED Then
$ichkBackground = 1
updateBtnHideState($GUI_ENABLE)
Else
$ichkBackground = 0
updateBtnHideState($GUI_DISABLE)
EndIf
EndFunc
Func IsStopped()
If $RunState Then Return False
If $Restart Then Return True
Return False
EndFunc
Func btnStart()
EnableControls($frmBotBottom, False, $frmBotBottomCtrlState)
Local $RunNow = $BotAction <> $eBotNoAction
If $RunNow Then
BotStart()
Else
$BotAction = $eBotStart
EndIf
$iGUIEnabled = False
EndFunc
Func btnStop()
If $RunState Then
EnableControls($frmBotBottom, False, $frmBotBottomCtrlState)
$RunState = False
$BotAction = $eBotStop
EndIf
$iGUIEnabled = True
EndFunc
Func btnSearchMode()
EnableControls($frmBotBottom, False, $frmBotBottomCtrlState)
Local $RunNow = $BotAction <> $eBotNoAction
If $RunNow Then
BotSearchMode()
Else
$BotAction = $eBotSearchMode
EndIf
EndFunc
Func btnPause($RunNow = True)
TogglePause()
EndFunc
Func btnResume()
TogglePause()
EndFunc
Func btnAttackNowDB()
If $RunState Then
$bBtnAttackNowPressed = True
$iMatchMode = $DB
EndIf
EndFunc
Func btnAttackNowLB()
If $RunState Then
$bBtnAttackNowPressed = True
$iMatchMode = $LB
EndIf
EndFunc
Func btnAttackNowTS()
If $RunState Then
$bBtnAttackNowPressed = True
$iMatchMode = $TS
EndIf
EndFunc
Func reHide()
WinGetAndroidHandle()
If $Hide = True And $HWnD <> 0 And $AndroidEmbedded = False Then
SetDebugLog("Hide " & $Android & " Window after restart")
Return WinMove2($HWnD, "", -32000, -32000)
EndIf
Return 0
EndFunc
Func updateBtnHideState($newState = $GUI_ENABLE)
Local $hideState = GUICtrlGetState($btnHide)
Local $newHideState = ($AndroidEmbedded = True ? $GUI_DISABLE : $newState)
If $hideState <> $newHideState Then GUICtrlSetState($btnHide, $newHideState)
EndFunc
Func btnHide()
ResumeAndroid()
WinGetAndroidHandle()
WinGetPos($HWnD)
If @error <> 0 Then Return SetError(0, 0, 0)
If $Hide = False Then
GUICtrlSetData($btnHide, GetTranslated(602, 26, "Show"))
Local $a = WinGetPos($HWnD)
WinMove2($HWnD, "", -32000, -32000)
$Hide = True
Else
GUICtrlSetData($btnHide, GetTranslated(602, 11, "Hide"))
WinMove2($HWnD, "", $AndroidPosX, $AndroidPosY)
WinActivate($HWnD)
$Hide = False
EndIf
EndFunc
Func updateBtnEmbed()
If IsDeclared("btnEmbed") = $DECLARED_UNKNOWN Then Return False
UpdateFrmBotStyle()
Local $state = GUICtrlGetState($btnEmbed)
If $HWnD = 0 Or $AndroidBackgroundLaunched = True Or $AndroidEmbed = False Then
If $state <> $GUI_DISABLE Then GUICtrlSetState($btnEmbed, $GUI_DISABLE)
Return False
EndIf
Local $text = GUICtrlRead($btnEmbed)
Local $newText
If $AndroidEmbedded = True Then
$newText = GetTranslated(602, 28, "Undock")
Else
$newText = GetTranslated(602, 27, "Dock")
EndIf
If $text <> $newText Then GUICtrlSetData($btnEmbed, $newText)
If $state <> $GUI_ENABLE Then GUICtrlSetState($btnEmbed, $GUI_ENABLE)
updateBtnHideState()
Return True
EndFunc
Func btnEmbed()
ResumeAndroid()
WinGetAndroidHandle()
WinGetPos($HWnD)
If @error <> 0 Then Return SetError(0, 0, 0)
AndroidEmbed(Not $AndroidEmbedded)
EndFunc
Func btnMakeScreenshot()
If $RunState Then $iMakeScreenshotNow = True
EndFunc
Func GetFont()
Local $i, $sText = "", $DefaultFont
$DefaultFont = __EMB_GetDefaultFont()
For $i = 0 To UBound($DefaultFont) - 1
$sText &= " $DefaultFont[" & $i & "]= " & $DefaultFont[$i] & ", "
Next
Setlog($sText, $COLOR_DEBUG)
EndFunc
Func btnAnalyzeVillage()
$debugBuildingPos = 1
$debugDeadBaseImage = 1
SETLOG("DEADBASE CHECK..................")
$dbBase = checkDeadBase()
SETLOG("TOWNHALL CHECK..................")
$searchTH = townHallCheck(True)
SETLOG("MINE CHECK C#...................")
$PixelMine = GetLocationMine()
SetLog("[" & UBound($PixelMine) & "] Gold Mines")
SETLOG("ELIXIR CHECK C#.................")
$PixelElixir = GetLocationElixir()
SetLog("[" & UBound($PixelElixir) & "] Elixir Collectors")
SETLOG("DARK ELIXIR CHECK C#............")
$PixelDarkElixir = GetLocationDarkElixir()
SetLog("[" & UBound($PixelDarkElixir) & "] Dark Elixir Drill/s")
SETLOG("DARK ELIXIR STORAGE CHECK C#....")
$BuildingToLoc = GetLocationDarkElixirStorage
SetLog("[" & UBound($BuildingToLoc) & "] Dark Elixir Storage")
For $i = 0 To UBound($BuildingToLoc) - 1
$pixel = $BuildingToLoc[$i]
If $DebugSetlog = 1 Then SetLog("- Dark Elixir Storage " & $i + 1 & ": (" & $pixel[0] & "," & $pixel[1] & ")", $COLOR_DEBUG)
Next
SETLOG("LOCATE BARRACKS C#..............")
Local $PixelBarrackHere = GetLocationItem("getLocationBarrack")
SetLog("Total No. of Barracks: " & UBound($PixelBarrackHere), $COLOR_DEBUG)
For $i = 0 To UBound($PixelBarrackHere) - 1
$pixel = $PixelBarrackHere[$i]
If $DebugSetlog = 1 Then SetLog("- Barrack " & $i + 1 & ": (" & $pixel[0] & "," & $pixel[1] & ")", $COLOR_DEBUG)
Next
SETLOG("LOCATE BARRACKS C#..............")
Local $PixelDarkBarrackHere = GetLocationItem("getLocationDarkBarrack")
SetLog("Total No. of Dark Barracks: " & UBound($PixelBarrackHere), $COLOR_DEBUG)
For $i = 0 To UBound($PixelDarkBarrackHere) - 1
$pixel = $PixelDarkBarrackHere[$i]
If $DebugSetlog = 1 Then SetLog("- Dark Barrack " & $i + 1 & ": (" & $pixel[0] & "," & $pixel[1] & ")", $COLOR_DEBUG)
Next
SetLog("WEAK BASE C#.....................", $COLOR_TEAL)
Local $weakBaseValues
If IsWeakBaseActive($DB) Or IsWeakBaseActive($LB) Then
$weakBaseValues = IsWeakBase()
EndIf
For $i = 0 To $iModeCount - 2
If IsWeakBaseActive($i) Then
If getIsWeak($weakBaseValues, $i) Then
SetLog(StringUpper($sModeText[$i]) & " IS A WEAK BASE: TRUE", $COLOR_DEBUG)
Else
SetLog(StringUpper($sModeText[$i]) & " IS A WEAK BASE: FALSE", $COLOR_DEBUG)
EndIf
SetLog("Time taken: " & $weakBaseValues[5][0] & " " & $weakBaseValues[5][1], $COLOR_DEBUG)
EndIf
Next
Setlog("--------------------------------------------------------------", $COLOR_TEAL)
$debugBuildingPos = 0
$debugDeadBaseImage = 0
EndFunc
Func btnVillageStat()
GUICtrlSetState($lblVillageReportTemp, $GUI_HIDE)
If GUICtrlGetState($lblResultGoldNow) = $GUI_ENABLE + $GUI_SHOW Then
GUICtrlSetState($lblResultGoldNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultElixirNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultDENow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultTrophyNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultBuilderNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultGemNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultGoldHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultElixirHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultDEHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultRuntimeNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultAttackedHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultSkippedHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($picResultTrophyNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($picResultBuilderNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($picResultGemNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($picResultRuntimeNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($picResultAttackedHourNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($picResultSkippedHourNow, $GUI_ENABLE + $GUI_SHOW)
Else
GUICtrlSetState($lblResultGoldNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultElixirNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultDENow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultTrophyNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultBuilderNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultGemNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($lblResultGoldHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultElixirHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultDEHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultRuntimeNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultAttackedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($lblResultSkippedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($picResultTrophyNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($picResultBuilderNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($picResultGemNow, $GUI_ENABLE + $GUI_SHOW)
GUICtrlSetState($picResultRuntimeNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($picResultAttackedHourNow, $GUI_ENABLE + $GUI_HIDE)
GUICtrlSetState($picResultSkippedHourNow, $GUI_ENABLE + $GUI_HIDE)
EndIf
EndFunc
Func btnTestDeadBase()
Local $test = 0
LoadElixirImage()
LoadElixirImage75Percent()
LoadElixirImage50Percent()
Zoomout()
If $debugBuildingPos = 0 Then
$test = 1
$debugBuildingPos = 1
EndIf
SETLOG("DEADBASE CHECK..................")
$dbBase = checkDeadBase()
SETLOG("TOWNHALL CHECK..................")
$searchTH = townHallCheck(True)
If $test = 1 Then $debugBuildingPos = 0
EndFunc
Func btnTestDonate()
$RunState = True
SETLOG("DONATE TEST..................START")
ZoomOut()
saveconfig()
readconfig()
applyconfig()
DonateCC()
SETLOG("DONATE TEST..................STOP")
$RunState = False
EndFunc
Func btnTestButtons()
$RunState = True
Local $ButtonX, $ButtonY
Local $hTimer = TimerInit()
Local $res
Local $ImagesToUse[3]
$ImagesToUse[0] = @ScriptDir & "\images\Button\Traps.png"
$ImagesToUse[1] = @ScriptDir & "\images\Button\Xbow.png"
$ImagesToUse[2] = @ScriptDir & "\images\Button\Inferno.png"
Local $x = 1
Local $y = 1
Local $w = 615
Local $h = 105
$ToleranceImgLoc = 0.950
SETLOG("SearchTile TEST..................START")
$SearchArea = String($x & "|" & $y & "|" & $w & "|" & $h)
Local $AreaInRectangle = String($x + 1 & "," & $y + 1 & "|" & $w - 1 & "," & $y + 1 & "|" & $w - 1 & "," & $h - 1 & "|" & $x + 1 & "," & $h - 1)
_CaptureRegion(125, 610, 740, 715)
For $i = 0 To 2
If FileExists($ImagesToUse[$i]) Then
$res = DllCall($pImgLib, "str", "SearchTile", "handle", $hHBitmap2, "str", $ImagesToUse[$i], "float", $ToleranceImgLoc, "str", $SearchArea, "str", $AreaInRectangle)
If @error Then _logErrorDLLCall($pImgLib, @error)
If IsArray($res) Then
If $DebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_DEBUG)
If $res[0] = "0" Then
SetLog("No Button found")
ElseIf $res[0] = "-1" Then
SetLog("DLL Error", $COLOR_RED)
ElseIf $res[0] = "-2" Then
SetLog("Invalid Resolution", $COLOR_RED)
Else
$expRet = StringSplit($res[0], "|", 2)
$ButtonX = 125 + Int($expRet[1])
$ButtonY = 610 + Int($expRet[2])
SetLog("found (" & $ButtonX & "," & $ButtonY & ")", $COLOR_GREEN)
If _Sleep(200) Then Return
If _Sleep(200) Then Return
If isGemOpen(True) = True Then
Setlog("Not enough loot to rearm traps.....", $COLOR_RED)
Click(585, 252, 1, 0, "#0227")
If _Sleep(200) Then Return
Else
If $i = 0 Then SetLog("Rearmed Trap(s)", $COLOR_GREEN)
If $i = 1 Then SetLog("Reloaded XBow(s)", $COLOR_GREEN)
If $i = 2 Then SetLog("Reloaded Inferno(s)", $COLOR_GREEN)
If _Sleep(200) Then Return
EndIf
EndIf
EndIf
EndIf
Next
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_TEAL)
SETLOG("SearchTile TEST..................STOP")
Local $hTimer = TimerInit()
SETLOG("MBRSearchImage TEST..................STOP")
For $i = 0 To 2
If FileExists($ImagesToUse[$i]) Then
_CaptureRegion2(125, 610, 740, 715)
$res = DllCall($pImgLib, "str", "MBRSearchImage", "handle", $hHBitmap2, "str", $ImagesToUse[$i], "float", $ToleranceImgLoc)
If @error Then _logErrorDLLCall($pImgLib, @error)
If IsArray($res) Then
If $DebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_DEBUG)
If $res[0] = "0" Then
SetLog("No Button found")
ElseIf $res[0] = "-1" Then
SetLog("DLL Error", $COLOR_RED)
ElseIf $res[0] = "-2" Then
SetLog("Invalid Resolution", $COLOR_RED)
Else
$expRet = StringSplit($res[0], "|", 2)
$ButtonX = 125 + Int($expRet[1])
$ButtonY = 610 + Int($expRet[2])
SetLog("found (" & $ButtonX & "," & $ButtonY & ")", $COLOR_GREEN)
If _Sleep(200) Then Return
If _Sleep(200) Then Return
If isGemOpen(True) = True Then
Setlog("Not enough loot to rearm traps.....", $COLOR_RED)
Click(585, 252, 1, 0, "#0227")
If _Sleep(200) Then Return
Else
If $i = 0 Then SetLog("Rearmed Trap(s)", $COLOR_GREEN)
If $i = 1 Then SetLog("Reloaded XBow(s)", $COLOR_GREEN)
If $i = 2 Then SetLog("Reloaded Inferno(s)", $COLOR_GREEN)
If _Sleep(200) Then Return
EndIf
EndIf
EndIf
EndIf
Next
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_TEAL)
SETLOG("MBRSearchImage TEST..................STOP")
$RunState = False
EndFunc
Func btnDBCheck()
SetLog("Func btnDBCheck", $COLOR_DEBUG)
Local $oDebugBuildingPos = $debugBuildingPos
$debugBuildingPos = 1
checkDeadBase()
$debugBuildingPos = $oDebugBuildingPos
SetLog("EndFunc btnDBCheck", $COLOR_DEBUG)
EndFunc
Func ButtonBoost()
$RunState = True
Local $ButtonX, $ButtonY
Local $hTimer = TimerInit()
Local $res
Local $ImagesToUse[2]
$ImagesToUse[0] = @ScriptDir & "\images\Button\BoostBarrack.png"
$ImagesToUse[1] = @ScriptDir & "\images\Button\BarrackBoosted.png"
$ToleranceImgLoc = 0.90
SETLOG("MBRSearchImage TEST..................STARTED")
_CaptureRegion2(125, 610, 740, 715)
For $i = 0 To 1
If FileExists($ImagesToUse[$i]) Then
$res = DllCall($pImgLib, "str", "MBRSearchImage", "handle", $hHBitmap2, "str", $ImagesToUse[$i], "float", $ToleranceImgLoc)
If @error Then _logErrorDLLCall($pImgLib, @error)
If IsArray($res) Then
If $DebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_DEBUG)
If $res[0] = "0" Then
If $i = 1 Then SetLog("No Button found")
ElseIf $res[0] = "-1" Then
SetLog("DLL Error", $COLOR_RED)
ElseIf $res[0] = "-2" Then
SetLog("Invalid Resolution", $COLOR_RED)
Else
If _Sleep(200) Then Return
If $i = 0 Then
SetLog("Found the Button to Boost individual")
$expRet = StringSplit($res[0], "|", 2)
$ButtonX = 125 + Int($expRet[1])
$ButtonY = 610 + Int($expRet[2])
SetLog("found (" & $ButtonX & "," & $ButtonY & ")", $COLOR_GREEN)
ExitLoop
Else
SetLog("The Barrack is already boosted!")
EndIf
EndIf
EndIf
EndIf
Next
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_TEAL)
SETLOG("MBRSearchImage TEST..................STOP")
$RunState = False
EndFunc
Func btnEagle()
Local $PixelEaglePos[2]
Local $colorVariation = 40
Local $xSkip = 1
Local $ySkip = 5
$hTimer = TimerInit()
Local $directory = @ScriptDir & "\images\WeakBase\Eagle"
Local $return = returnHighestLevelSingleMatch($directory)
Local $NotdetectedEagle = True
Setlog(" Â»Â» Ubound ROW $return: " & UBound($return, $UBOUND_ROWS))
Setlog(" Â»Â» Ubound COLUMNS $return: " & UBound($return, $UBOUND_COLUMNS))
Setlog(" Â»Â» Ubound DIMENSIONS $return: " & UBound($return, $UBOUND_DIMENSIONS))
Local $result = DllCall($hFuncLib, "str", "getRedArea", "ptr", $hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation)
If UBound($return) > 0 Then
Setlog(" Â»Â» Image: " & $return[0])
Setlog(" Â»Â» Build: " & $return[1])
Setlog(" Â»Â» Level: " & $return[2])
Local $EaglePosition = $return[5]
Setlog(" Â»Â» $EaglePosition[0] X: " & $EaglePosition[0][0])
Setlog(" Â»Â» $EaglePosition[1] Y: " & $EaglePosition[0][1])
Setlog(" Â»Â» Ubound ROW $EaglePosition: " & UBound($EaglePosition, $UBOUND_ROWS))
Setlog(" Â»Â» Ubound COLUMNS $EaglePosition: " & UBound($EaglePosition, $UBOUND_COLUMNS))
Setlog(" Â»Â» Ubound DIMENSIONS $EaglePosition: " & UBound($EaglePosition, $UBOUND_DIMENSIONS))
Setlog(" Â»Â» REDlines Imgloc: " & $return[6])
Setlog(" Â»Â» REDlines MBRFunction: " & $result[0])
Local $AllPoints = StringSplit($return[6], "|", $STR_NOCOUNT)
Dim $EachPoint[UBound($AllPoints)][2]
Local $PixelTopLeft, $PixelBottomLeft, $PixelBottomRight, $PixelTopRight
For $i = 0 To UBound($AllPoints) - 1
Local $temp = StringSplit($AllPoints[$i], ",", $STR_NOCOUNT)
$EachPoint[$i][0] = Number($temp[0])
$EachPoint[$i][1] = Number($temp[1])
Setlog(" $EachPoint[0]: " & $EachPoint[$i][0] & " | $EachPoint[1]: " & $EachPoint[$i][1])
Next
_ArraySort($EachPoint, 0, 0, 0, 0)
For $i = 0 To UBound($EachPoint) - 1
If $EachPoint[$i][0] > 0 And $EachPoint[$i][0] < 430 And $EachPoint[$i][1] > 0 And $EachPoint[$i][1] < 338 Then
$PixelTopLeft &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
ElseIf $EachPoint[$i][0] > 0 And $EachPoint[$i][0] < 430 And $EachPoint[$i][1] > 338 And $EachPoint[$i][1] < 650 Then
$PixelBottomLeft &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
ElseIf $EachPoint[$i][0] > 430 And $EachPoint[$i][0] < 840 And $EachPoint[$i][1] > 338 And $EachPoint[$i][1] < 650 Then
$PixelBottomRight &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
ElseIf $EachPoint[$i][0] > 430 And $EachPoint[$i][0] < 840 And $EachPoint[$i][1] > 0 And $EachPoint[$i][1] < 338 Then
$PixelTopRight &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
EndIf
Next
If Not StringIsSpace($PixelTopLeft) Then $PixelTopLeft = StringTrimLeft($PixelTopLeft, 1)
If Not StringIsSpace($PixelBottomLeft) Then $PixelBottomLeft = StringTrimLeft($PixelBottomLeft, 1)
If Not StringIsSpace($PixelBottomRight) Then $PixelBottomRight = StringTrimLeft($PixelBottomRight, 1)
If Not StringIsSpace($PixelTopRight) Then $PixelTopRight = StringTrimLeft($PixelTopRight, 1)
Local $NewRedLineString = $PixelTopLeft & "#" & $PixelBottomLeft & "#" & $PixelBottomRight & "#" & $PixelTopRight
Setlog(" Â»Â» NEW REDlines Imgloc: " & $NewRedLineString)
If $EaglePosition[0][0] <> "" Then
$PixelEaglePos[0] = $EaglePosition[0][0]
$PixelEaglePos[1] = $EaglePosition[0][1]
Setlog(" Â»Â» Eagle located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
Switch StringLeft(Slice8($PixelEaglePos), 1)
Case 1, 2
$MAINSIDE = "BOTTOM-RIGHT"
Case 3, 4
$MAINSIDE = "TOP-RIGHT"
Case 5, 6
$MAINSIDE = "TOP-LEFT"
Case 7, 8
$MAINSIDE = "BOTTOM-LEFT"
EndSwitch
Setlog(" Â» Eagle located : " & $MAINSIDE, $COLOR_BLUE)
$NotdetectedEagle = False
Else
Setlog("> Eagle not detected!", $COLOR_BLUE)
DebugImageSave("EagleDetection_NotDetected_", True)
EndIf
Else
Setlog("> Eagle not detected!", $COLOR_BLUE)
DebugImageSave("EagleDetection_NotPresent_", True)
EndIf
EndFunc
Func btnDropRSpell()
$oldDebugSetlog = $DebugSetlog
$oldRunState = $RunState
Local $debugDropSCommand
Local $oldDropSDebug = $debugDropSCommand
$debugDropSCommand = 1
$DebugSetlog = 1
$iMatchMode = $LB
$iAtkAlgorithm[$LB] = 1
$scmbABScriptName = "Test DropS Command"
$iMatchMode = 1
$RunState = True
PrepareAttack($iMatchMode)
Attack()
$RunState = $oldRunState
$DebugSetlog = $oldDebugSetlog
$debugDropSCommand = $oldDropSDebug
EndFunc
Func btnNEWRedLineDetection()
$RunState = True
$hTimer = TimerInit()
$DebugOcr = 1
$debugImageSave = 1
Local $result = AttackBarCheck()
Local $plural = 0
Local $aTroopDataList = StringSplit($result, "|" , $STR_NOCOUNT)
Local $aTemp[Ubound($aTroopDataList)][3]
If $result <> "" Then
For $i = 0 To UBound($aTroopDataList) - 1
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
$aTemp[$i][0] = $troopData[0]
$aTemp[$i][1] = Number($troopData[1])
$aTemp[$i][2] = Number($troopData[2])
Next
EndIf
Local $x = 0, $y = 659, $x1 = 853, $y1 = 698
_CaptureRegion($x,$y,$x1,$y1)
Local $subDirectory = @ScriptDir & "\AttackBarCheck"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = String($Date & "_" & $Time & "_.png")
Local $editedImage = $hBitmap
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 2)
For $i = 0 To UBound($aTemp) - 1
$plural = 0
If $aTemp[$i][2] > 1  then $plural = 1
SetLog($aTemp[$i][1] & " Â» " & $aTemp[$i][2] & " " & NameOfTroop($aTemp[$i][0], $Plural), $COLOR_GREEN)
Next
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $fileName)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_GraphicsDispose($hGraphic)
Setlog(" Â»Â» AttackBarCheck located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
$DebugOcr = 0
$debugImageSave = 0
$RunState = False
EndFunc
Func btnTestAD()
$hTimer = TimerInit()
Local $directory = @ScriptDir & "\images\WeakBase\ADefense"
Local $return = returnAllMatches($directory)
Setlog(" Â»Â» Air Defense located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
_ArrayDisplay($return)
EndFunc
Func btnPosCheck()
Local $oRunState = $RunState
$RunState = True
Local $ToCheck = "IsMainGrayed"
Select
Case $ToCheck = "IsPostDefenseSummaryPage"
$result = IsPostDefenseSummaryPage()
SetLog("=============", $COLOR_TEAL)
SetLog("#*# Func btnPosCheck", $COLOR_TEAL)
SetLog("To Check = " & $ToCheck, $COLOR_TEAL)
SetLog("Result = " & $result, $COLOR_TEAL)
Case $ToCheck = "NoCloudsAttack"
$result = _CheckPixel($aNoCloudsAttack, $bCapturePixel)
SetLog("=============", $COLOR_TEAL)
SetLog("#*# Func btnPosCheck", $COLOR_TEAL)
SetLog("To Check = " & $ToCheck, $COLOR_TEAL)
SetLog("Result = " & $result, $COLOR_TEAL)
Case $ToCheck = "SurrenderButton"
$result = _CheckPixel($aSurrenderButton, $bCapturePixel)
SetLog("=============", $COLOR_TEAL)
SetLog("#*# Func btnPosCheck", $COLOR_TEAL)
SetLog("To Check = " & $ToCheck, $COLOR_TEAL)
SetLog("Result = " & $result, $COLOR_TEAL)
If $result = False Then SetLog("Cur Color = " & _GetPixelColor($aSurrenderButton[0], $aSurrenderButton[1], True), $COLOR_TEAL)
Case $ToCheck = "IsMain"
$result = _CheckPixel($aIsMain, $bCapturePixel)
SetLog("=============", $COLOR_TEAL)
SetLog("#*# Func btnPosCheck", $COLOR_TEAL)
SetLog("To Check = " & $ToCheck, $COLOR_TEAL)
SetLog("Result = " & $result, $COLOR_TEAL)
If $result = False Then SetLog("Cur Color = " & _GetPixelColor($aIsMain[0], $aIsMain[1], True), $COLOR_TEAL)
Case $ToCheck = "RequestCC"
$result = _GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True)
$CCheck1 = _ColorCheck($result, Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
$CCheck2 = _ColorCheck($result, Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5])
$CCheck3 = _ColorCheck($result, Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5])
SetLog("=============", $COLOR_TEAL)
SetLog("#*# Func btnPosCheck", $COLOR_TEAL)
SetLog("To Check = " & $ToCheck, $COLOR_TEAL)
SetLog("Can Request = " & $CCheck1, $COLOR_TEAL)
SetLog("Already Made = " & $CCheck2, $COLOR_TEAL)
SetLog("Army Full / No Clan = " & $CCheck3, $COLOR_TEAL)
Case $ToCheck = "IsMainGrayed"
$result = _CheckPixel($aIsMainGrayed, $bCapturePixel)
SetLog("=============", $COLOR_TEAL)
SetLog("#*# Func btnPosCheck", $COLOR_TEAL)
SetLog("To Check = " & $ToCheck, $COLOR_TEAL)
SetLog("Result = " & $result, $COLOR_TEAL)
If $result = False Then SetLog("Cur Color = " & _GetPixelColor($aIsMainGrayed[0], $aIsMainGrayed[1], True), $COLOR_TEAL)
EndSelect
$RunState = $oRunState
EndFunc
Func arrows()
getArmyHeroCount()
EndFunc
Func EnableGuiControls($OptimizedRedraw = True)
Return ToggleGuiControls(True, $OptimizedRedraw)
EndFunc
Func DisableGuiControls($OptimizedRedraw = True)
Return ToggleGuiControls(False, $OptimizedRedraw)
EndFunc
Func ToggleGuiControls($Enable, $OptimizedRedraw = True)
If $OptimizedRedraw = True Then SetRedrawBotWindow(False)
If $Enable = False Then
SetDebugLog("Disable GUI Controls")
Else
SetDebugLog("Enable GUI Controls")
EndIf
$GUIControl_Disabled = True
For $i = $FirstControlToHide To $LastControlToHide
If IsTab($i) Or IsAlwaysEnabledControl($i) Then ContinueLoop
If $NotifyPBEnabled And $i = $btnNotifyDeleteMessages Then ContinueLoop
If $i = $btnMakeScreenshot Then ContinueLoop
If $i = $divider Then ContinueLoop
If $Enable = False Then
$iPrevState[$i] = GUICtrlGetState($i)
GUICtrlSetState($i, $GUI_DISABLE)
Else
GUICtrlSetState($i, $iPrevState[$i])
EndIf
Next
$GUIControl_Disabled = False
If $OptimizedRedraw = True Then SetRedrawBotWindow(True)
EndFunc
Func btnAtkLogClear()
_GUICtrlRichEdit_SetText($txtAtkLog, "")
AtkLogHead()
EndFunc
Func btnAtkLogCopyClipboard()
Local $text = _GUICtrlRichEdit_GetText($txtAtkLog)
$text = StringReplace($text, @CR, @CRLF)
ClipPut($text)
EndFunc
Func cmbLog()
Local $x = 0, $y = 0, $w = $_GUI_MAIN_WIDTH - 20, $h = $_GUI_MAIN_HEIGHT - 470 + Int($frmBotAddH / 2)
If ($iDividerY > $h + Int($h / 2) + $y And $iDividerY < $h * 2 + $iDividerHeight + $y) Or $iDividerY > $h * 2 + $iDividerHeight + $y Then $iDividerY = $h + Int($h / 2) + $y
If ($iDividerY < Int($h / 2) + $y And $iDividerY > 0) Or $iDividerY < 0 Then $iDividerY = Int($h / 2)
_SendMessage($txtLog, $WM_SETREDRAW, False, 0)
_WINAPI_EnableWindow($txtLog, False)
_SendMessage($txtAtkLog, $WM_SETREDRAW, False, 0)
_WINAPI_EnableWindow($txtAtkLog, False)
Switch _GUICtrlComboBox_GetCurSel($cmbLog)
Case 0
ControlShow($hGUI_LOG, "", $divider)
ControlMove($hGUI_LOG, "", $divider, $x, $iDividerY - $y, $w, $iDividerHeight)
ControlShow($hGUI_LOG, "", $txtLog)
ControlMove($hGUI_LOG, "", $txtLog, $x, $y, $w, $iDividerY - $y)
ControlShow($hGUI_LOG, "", $txtAtkLog)
ControlMove($hGUI_LOG, "", $txtAtkLog, $x, $iDividerY + $iDividerHeight, $w, ($h * 2) - ($iDividerY - $y))
Case 1
ControlShow($hGUI_LOG, "", $txtLog)
ControlMove($hGUI_LOG, "", $txtLog, $x, $y, $w, $h)
$y += $h
ControlHide($hGUI_LOG, "", $divider)
$y += $iDividerHeight
ControlShow($hGUI_LOG, "", $txtAtkLog)
ControlMove($hGUI_LOG, "", $txtAtkLog, $x, $y, $w, $h)
Case 2
ControlShow($hGUI_LOG, "", $txtLog)
ControlMove($hGUI_LOG, "", $txtLog, $x, $y, $w, $h + ($h / 2))
$y += $h + ($h / 2) + $iDividerHeight
ControlHide($hGUI_LOG, "", $divider)
ControlShow($hGUI_LOG, "", $txtAtkLog)
ControlMove($hGUI_LOG, "", $txtAtkLog, $x, $y, $w, $h - ($h / 2))
Case 3
ControlShow($hGUI_LOG, "", $txtLog)
ControlMove($hGUI_LOG, "", $txtLog, $x, $y, $w, $h - ($h / 2))
$y += ($h / 2) + $iDividerHeight
ControlHide($hGUI_LOG, "", $divider)
ControlShow($hGUI_LOG, "", $txtAtkLog)
ControlMove($hGUI_LOG, "", $txtAtkLog, $x, $y, $w, $h + ($h / 2))
Case 4
ControlShow($hGUI_LOG, "", $txtLog)
ControlMove($hGUI_LOG, "", $txtLog, $x, $y, $w, $h * 2 + $iDividerHeight)
ControlHide($hGUI_LOG, "", $txtAtkLog)
ControlMove($hGUI_LOG, "", $txtAtkLog, $x, $y + $h * 2 + $iDividerHeight, $w, 0)
ControlHide($hGUI_LOG, "", $divider)
Case 5
ControlHide($hGUI_LOG, "", $txtLog)
ControlMove($hGUI_LOG, "", $txtLog, $x, $y, $w, 0)
ControlShow($hGUI_LOG, "", $txtAtkLog)
ControlMove($hGUI_LOG, "", $txtAtkLog, $x, $y, $w, $h * 2 + $iDividerHeight)
ControlHide($hGUI_LOG, "", $divider)
EndSwitch
_SendMessage($txtLog, $WM_SETREDRAW, True, 0)
_WINAPI_EnableWindow($txtLog, True)
_SendMessage($txtAtkLog, $WM_SETREDRAW, True, 0)
_WINAPI_EnableWindow($txtAtkLog, True)
CheckRedrawControls(True)
EndFunc
Func MoveDivider()
Local $PPos = ControlGetPos($frmBot, "", $hGUI_LOG)
$TPos = ControlGetPos($hGUI_LOG, "", $txtLog)
$BPos = ControlGetPos($hGUI_LOG, "", $txtAtkLog)
$DPos = ControlGetPos($hGUI_LOG, "", $divider)
$logAndDividerX = $TPos[0] - $PPos[0]
$logAndDividerWidth = $TPos[2]
$totalLogsHeight = $TPos[3] + $BPos[3]
$minVisibleHeight = Ceiling($totalLogsHeight / 4)
$snapToMinMax = Ceiling($minVisibleHeight / 3)
$halfDividerTopHeight = Ceiling($iDividerHeight / 2)
$halfDividerBottomHeight = Floor($iDividerHeight / 2)
$startLogsY = $TPos[1] - $_GUI_CHILD_TOP
$endLogsY = $BPos[1] - $_GUI_CHILD_TOP + $BPos[3]
Do
$pos = GUIGetCursorInfo($hGUI_LOG)
$clickY = $pos[1]
If $clickY - $halfDividerTopHeight <= $startLogsY + $snapToMinMax Then
$clickY = $startLogsY + $halfDividerTopHeight
ElseIf $clickY + $halfDividerBottomHeight >= $endLogsY - $snapToMinMax Then
$clickY = $endLogsY - $halfDividerBottomHeight
ElseIf $clickY - $halfDividerTopHeight > $startLogsY + $snapToMinMax And $clickY - $halfDividerTopHeight <= $startLogsY + $minVisibleHeight Then
$clickY = $startLogsY + $minVisibleHeight + $halfDividerTopHeight
ElseIf $clickY + $halfDividerBottomHeight < $endLogsY - $snapToMinMax And $clickY + $halfDividerBottomHeight >= $endLogsY - $minVisibleHeight Then
$clickY = $endLogsY - $minVisibleHeight - $halfDividerBottomHeight
EndIf
$iDividerY = $clickY - $halfDividerTopHeight
ControlMove($hGUI_LOG, "", $divider, $logAndDividerX, $iDividerY, $logAndDividerWidth, $iDividerHeight)
ControlMove($hGUI_LOG, "", $txtLog, $logAndDividerX, $startLogsY, $logAndDividerWidth, $clickY - $startLogsY - $halfDividerTopHeight)
If $endLogsY - ($clickY + $halfDividerBottomHeight) < 0 Then
ControlMove($hGUI_LOG, "", $txtAtkLog, $logAndDividerX, $endLogsY, $logAndDividerWidth, 0)
Else
ControlMove($hGUI_LOG, "", $txtAtkLog, $logAndDividerX, $clickY + $halfDividerBottomHeight, $logAndDividerWidth, $endLogsY - $clickY - $halfDividerBottomHeight)
EndIf
_WinAPI_UpdateWindow(WinGetHandle($hGUI_LOG))
Until $pos[2] = 0
_GUICtrlRichEdit_SetSel($txtLog, - 1, -1)
_GUICtrlRichEdit_SetSel($txtAtkLog, - 1, -1)
SetDebugLog("MoveDivider exit", Default, True)
EndFunc
Func XPStyleToggle($Off = 1)
Local $XS_n
If Not StringInStr(@OSType, "WIN32_NT") Then Return 0
If $Off Then
$XS_n = DllCall("uxtheme.dll", "int", "GetThemeAppProperties")
DllCall("uxtheme.dll", "none", "SetThemeAppProperties", "int", 0)
Return 1
ElseIf IsArray($XS_n) Then
DllCall("uxtheme.dll", "none", "SetThemeAppProperties", "int", $XS_n[0])
$XS_n = ""
Return 1
EndIf
Return 0
EndFunc
Func chkUseQTrain()
If GUICtrlRead($hChk_UseQTrain) = $GUI_CHECKED Then
GUICtrlSetState($hRadio_Army1, $GUI_ENABLE)
GUICtrlSetState($hRadio_Army2, $GUI_ENABLE)
GUICtrlSetState($hRadio_Army3, $GUI_ENABLE)
For $i = $txtNumBarb To $txtNumLava
GUICtrlSetState($i, $GUI_DISABLE)
Next
For $i = $txtNumLightningSpell To $txtNumSkeletonSpell
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
GUICtrlSetState($hRadio_Army1, $GUI_DISABLE)
GUICtrlSetState($hRadio_Army2, $GUI_DISABLE)
GUICtrlSetState($hRadio_Army3, $GUI_DISABLE)
For $i = $txtNumBarb To $txtNumLava
GUICtrlSetState($i, $GUI_ENABLE)
Next
For $i = $txtNumLightningSpell To $txtNumSkeletonSpell
GUICtrlSetState($i, $GUI_ENABLE)
Next
EndIf
EndFunc
Func SetComboTroopComp()
Local $bWasRedraw = SetRedrawBotWindow(False)
Local $ArmyCampTemp = 0
If GUICtrlRead($chkTotalCampForced) = $GUI_CHECKED Then
$ArmyCampTemp = Floor(GUICtrlRead($txtTotalCampForced) * GUICtrlRead($txtFullTroop)/100)
Else
$ArmyCampTemp = Floor($TotalCamp * GUICtrlRead($txtFullTroop)/100)
EndIf
Local $TotalTroopsTOtrain = 0
lblTotalCount()
SetRedrawBotWindow($bWasRedraw)
EndFunc
Func lblTotalCount()
Local $TotalTroopsTOtrain = 0
Local $ArmyCampTemp = 0
If GUICtrlRead($chkTotalCampForced) = $GUI_CHECKED Then
$ArmyCampTemp = Floor(GUICtrlRead($txtTotalCampForced) * GUICtrlRead($txtFullTroop) / 100)
Else
$ArmyCampTemp = Floor($TotalCamp * GUICtrlRead($txtFullTroop)/100)
EndIf
For $i = 0 To UBound($TroopName) - 1
If GUICtrlRead(Eval("txtNum" & $TroopName[$i])) > 0 Then
$TotalTroopsTOtrain += GUICtrlRead(Eval("txtNum" & $TroopName[$i])) * $TroopHeight[$i]
Else
GUICtrlSetData(Eval("txtNum" & $TroopName[$i]), 0)
EndIf
Next
GUICtrlSetData($lblTotalCount, String($TotalTroopsTOtrain))
If GUICtrlRead($chkTotalCampForced) = $GUI_CHECKED And GUICtrlRead($lblTotalCount) = GUICtrlRead($txtTotalCampForced) Then
GUICtrlSetBkColor($lblTotalCount, $COLOR_MONEYGREEN)
ElseIf GUICtrlRead($lblTotalCount) = $ArmyCampTemp Then
GUICtrlSetBkColor($lblTotalCount, $COLOR_MONEYGREEN)
ElseIf GUICtrlRead($lblTotalCount) > $ArmyCampTemp / 2 And GUICtrlRead($lblTotalCount) < $ArmyCampTemp Then
GUICtrlSetBkColor($lblTotalCount, $COLOR_ORANGE)
Else
GUICtrlSetBkColor($lblTotalCount, $COLOR_RED)
EndIf
If GUICtrlRead($chkTotalCampForced) = $GUI_CHECKED Then
GUICtrlSetData($caltotaltroops, (Floor((GUICtrlRead($lblTotalCount) / GUICtrlRead($txtTotalCampForced)) * 100) < 1 ? (GUICtrlRead($lblTotalCount) > 0 ? 1 : 0) : Floor((GUICtrlRead($lblTotalCount) / GUICtrlRead($txtTotalCampForced)) * 100)))
Else
GUICtrlSetData($caltotaltroops, (Floor((GUICtrlRead($lblTotalCount) / $ArmyCampTemp) * 100) < 1 ? (GUICtrlRead($lblTotalCount) > 0 ? 1 : 0) : Floor((GUICtrlRead($lblTotalCount) / $ArmyCampTemp) * 100)))
EndIf
If GUICtrlRead($chkTotalCampForced) = $GUI_CHECKED And GUICtrlRead($lblTotalCount) > GUICtrlRead($txtTotalCampForced) Then
GUICtrlSetState($lbltotalprogress, $GUI_SHOW)
ElseIf GUICtrlRead($lblTotalCount) > $ArmyCampTemp Then
GUICtrlSetState($lbltotalprogress, $GUI_SHOW)
Else
GUICtrlSetState($lbltotalprogress, $GUI_HIDE)
EndIf
EndFunc
Func lblTotalCountSpell()
_GUI_Value_STATE("HIDE", $groupListSpells)
$iTotalTrainSpaceSpell = (GUICtrlRead($txtNumLightningSpell) * 2) + (GUICtrlRead($txtNumHealSpell) * 2) + (GUICtrlRead($txtNumRageSpell) * 2) + (GUICtrlRead($txtNumJumpSpell) * 2) +  (GUICtrlRead($txtNumFreezeSpell) * 2) + (GUICtrlRead($txtNumCloneSpell) * 4) + GUICtrlRead($txtNumPoisonSpell) + GUICtrlRead($txtNumHasteSpell) + GUICtrlRead($txtNumEarthSpell) + GUICtrlRead($txtNumSkeletonSpell)
For $i = 0 To UBound($TxtNameSpell) - 1
If GUICtrlRead(Eval("txtNum" & $TxtNameSpell[$i])) < 0 Then
GUICtrlSetData(Eval("txtNum" & $TxtNameSpell[$i]), 0)
EndIf
Next
If $iTotalTrainSpaceSpell < GUICtrlRead($txtTotalCountSpell) + 1 Then
GUICtrlSetBkColor($txtNumLightningSpell, $COLOR_MONEYGREEN)
GUICtrlSetBkColor($txtNumHealSpell, $COLOR_MONEYGREEN)
GUICtrlSetBkColor($txtNumRageSpell, $COLOR_MONEYGREEN)
GUICtrlSetBkColor($txtNumJumpSpell, $COLOR_MONEYGREEN)
GUICtrlSetBkColor($txtNumFreezeSpell, $COLOR_MONEYGREEN)
GUICtrlSetBkColor($txtNumCloneSpell, $COLOR_MONEYGREEN)
GUICtrlSetBkColor($txtNumPoisonSpell, $COLOR_MONEYGREEN)
GUICtrlSetBkColor($txtNumEarthSpell, $COLOR_MONEYGREEN)
GUICtrlSetBkColor($txtNumHasteSpell, $COLOR_MONEYGREEN)
GUICtrlSetBkColor($txtNumSkeletonSpell, $COLOR_MONEYGREEN)
Else
GUICtrlSetBkColor($txtNumLightningSpell, $COLOR_RED)
GUICtrlSetBkColor($txtNumHealSpell, $COLOR_RED)
GUICtrlSetBkColor($txtNumRageSpell, $COLOR_RED)
GUICtrlSetBkColor($txtNumFreezeSpell, $COLOR_RED)
GUICtrlSetBkColor($txtNumCloneSpell, $COLOR_RED)
GUICtrlSetBkColor($txtNumJumpSpell, $COLOR_RED)
GUICtrlSetBkColor($txtNumPoisonSpell, $COLOR_RED)
GUICtrlSetBkColor($txtNumEarthSpell, $COLOR_RED)
GUICtrlSetBkColor($txtNumHasteSpell, $COLOR_RED)
GUICtrlSetBkColor($txtNumSkeletonSpell, $COLOR_RED)
EndIf
$iTownHallLevel = Int($iTownHallLevel)
If $iTownHallLevel > 4 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $groupLightning)
Else
GUICtrlSetData($txtNumLightningSpell, 0)
GUICtrlSetData($txtNumRageSpell, 0)
GUICtrlSetData($txtNumHealSpell, 0)
GUICtrlSetData($txtNumJumpSpell, 0)
GUICtrlSetData($txtNumFreezeSpell, 0)
GUICtrlSetData($txtNumCloneSpell, 0)
GUICtrlSetData($txtNumPoisonSpell, 0)
GUICtrlSetData($txtNumEarthSpell, 0)
GUICtrlSetData($txtNumHasteSpell, 0)
GUICtrlSetData($txtNumSkeletonSpell, 0)
GUICtrlSetData($txtTotalCountSpell, 0)
EndIf
If $iTownHallLevel > 5 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $groupHeal)
Else
GUICtrlSetData($txtNumRageSpell, 0)
GUICtrlSetData($txtNumJumpSpell, 0)
GUICtrlSetData($txtNumFreezeSpell, 0)
GUICtrlSetData($txtNumCloneSpell, 0)
GUICtrlSetData($txtNumPoisonSpell, 0)
GUICtrlSetData($txtNumEarthSpell, 0)
GUICtrlSetData($txtNumHasteSpell, 0)
GUICtrlSetData($txtNumSkeletonSpell, 0)
EndIf
If $iTownHallLevel > 6 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $groupRage)
Else
GUICtrlSetData($txtNumJumpSpell, 0)
GUICtrlSetData($txtNumFreezeSpell, 0)
GUICtrlSetData($txtNumCloneSpell, 0)
GUICtrlSetData($txtNumPoisonSpell, 0)
GUICtrlSetData($txtNumEarthSpell, 0)
GUICtrlSetData($txtNumHasteSpell, 0)
GUICtrlSetData($txtNumSkeletonSpell, 0)
EndIf
If $iTownHallLevel > 7 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $groupPoison)
_GUI_Value_STATE("SHOW", $groupEarthquake)
Else
GUICtrlSetData($txtNumJumpSpell, 0)
GUICtrlSetData($txtNumFreezeSpell, 0)
GUICtrlSetData($txtNumCloneSpell, 0)
GUICtrlSetData($txtNumHasteSpell, 0)
GUICtrlSetData($txtNumSkeletonSpell, 0)
EndIf
If $iTownHallLevel > 8 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $groupJumpSpell)
_GUI_Value_STATE("SHOW", $groupFreeze)
_GUI_Value_STATE("SHOW", $groupHaste)
_GUI_Value_STATE("SHOW", $groupSkeleton)
Else
GUICtrlSetData($txtNumCloneSpell, 0)
EndIf
If $iTownHallLevel > 9 Or $iTownHallLevel = 0 Then
_GUI_Value_STATE("SHOW", $groupClone)
EndIf
EndFunc
Func chkBoostBarracksHoursE1()
If GUICtrlRead($chkBoostBarracksHoursE1) = $GUI_CHECKED And GUICtrlRead($chkBoostBarracksHours0) = $GUI_CHECKED Then
For $i = $chkBoostBarracksHours0 To $chkBoostBarracksHours11
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkBoostBarracksHours0 To $chkBoostBarracksHours11
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkBoostBarracksHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkBoostBarracksHoursE2()
If GUICtrlRead($chkBoostBarracksHoursE2) = $GUI_CHECKED And GUICtrlRead($chkBoostBarracksHours12) = $GUI_CHECKED Then
For $i = $chkBoostBarracksHours12 To $chkBoostBarracksHours23
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkBoostBarracksHours12 To $chkBoostBarracksHours23
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkBoostBarracksHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkCloseWaitEnable()
If GUICtrlRead($chkCloseWaitEnable) = $GUI_CHECKED Then
$ichkCloseWaitEnable = 1
_GUI_Value_STATE("ENABLE", $groupCloseWaitTrain)
GUICtrlSetState($lblCloseWaitingTroops, $GUI_ENABLE)
GUICtrlSetState($cmbMinimumTimeClose, $GUI_ENABLE)
GUICtrlSetState($lblSymbolWaiting, $GUI_ENABLE)
GUICtrlSetState($lblWaitingInMinutes, $GUI_ENABLE)
Else
$ichkCloseWaitEnable = 0
_GUI_Value_STATE("DISABLE", $groupCloseWaitTrain)
GUICtrlSetState($lblCloseWaitingTroops, $GUI_DISABLE)
GUICtrlSetState($cmbMinimumTimeClose, $GUI_DISABLE)
GUICtrlSetState($lblSymbolWaiting, $GUI_DISABLE)
GUICtrlSetState($lblWaitingInMinutes, $GUI_DISABLE)
EndIf
If GUICtrlRead($btnCloseWaitStopRandom) = $GUI_CHECKED Then
GUICtrlSetState($btnCloseWaitStop, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
If GUICtrlRead($chkCloseWaitEnable) = $GUI_CHECKED Then GUICtrlSetState($btnCloseWaitStop, $GUI_ENABLE)
EndIf
EndFunc
Func chkCloseWaitTrain()
If GUICtrlRead($chkCloseWaitTrain) = $GUI_CHECKED Then
$ichkCloseWaitTrain = 1
Else
$ichkCloseWaitTrain = 0
EndIf
EndFunc
Func btnCloseWaitStop()
If GUICtrlRead($btnCloseWaitStop) = $GUI_CHECKED Then
$ibtnCloseWaitStop = 1
Else
$ibtnCloseWaitStop = 0
EndIf
EndFunc
Func btnCloseWaitStopRandom()
If GUICtrlRead($btnCloseWaitStopRandom) = $GUI_CHECKED Then
$ibtnCloseWaitStopRandom = 1
$ibtnCloseWaitStop = 0
GUICtrlSetState($btnCloseWaitStop, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
$ibtnCloseWaitStopRandom = 0
If GUICtrlRead($chkCloseWaitEnable) = $GUI_CHECKED Then GUICtrlSetState($btnCloseWaitStop, $GUI_ENABLE)
EndIf
EndFunc
Func btnCloseWaitRandom()
If GUICtrlRead($btnCloseWaitExact) = $GUI_CHECKED Then
$ibtnCloseWaitExact = 1
$ibtnCloseWaitRandom = 0
GUICtrlSetState($cmbCloseWaitRdmPercent, $GUI_DISABLE)
ElseIf GUICtrlRead($btnCloseWaitRandom) = $GUI_CHECKED Then
$ibtnCloseWaitExact = 0
$ibtnCloseWaitRandom = 1
If GUICtrlRead($chkCloseWaitEnable) = $GUI_CHECKED Then GUICtrlSetState($cmbCloseWaitRdmPercent, $GUI_ENABLE)
Else
$ibtnCloseWaitExact = 0
$ibtnCloseWaitRandom = 0
GUICtrlSetState($cmbCloseWaitRdmPercent, $GUI_DISABLE)
EndIf
EndFunc
Func sldTrainITDelay()
$isldTrainITDelay = GUICtrlRead($sldTrainITDelay)
GUICtrlSetData($lbltxtTrainITDelayTime, $isldTrainITDelay & " ms")
EndFunc
Func chkTroopOrder2()
chkTroopOrder()
EndFunc
Func chkTroopOrder($bNoiseMode = True)
If GUICtrlRead($chkTroopOrder) = $GUI_CHECKED Then
$ichkTroopOrder = 1
GUICtrlSetState($btnTroopOrderSet, $GUI_ENABLE)
For $i = 0 To UBound($aTroopOrderList) - 2
GUICtrlSetState($cmbTroopOrder[$i], $GUI_ENABLE)
Next
If IsUseCustomTroopOrder() = True Then GUICtrlSetImage($ImgTroopOrderSet, $pIconLib, $eIcnRedLight)
Else
$ichkTroopOrder = 0
GUICtrlSetState($btnTroopOrderSet, $GUI_DISABLE)
For $i = 0 To UBound($aTroopOrderList) - 2
GUICtrlSetState($cmbTroopOrder[$i], $GUI_DISABLE)
Next
SetDefaultTroopGroup($bNoiseMode)
If $bNoiseMode Or $debugsetlogTrain = 1 Then
Local $sNewTrainList = ""
For $i = 0 To UBound($DefaultTroopGroup) - 1
$sNewTrainList &= $TroopName[$i] & ", "
Next
$sNewTrainList = StringLeft($sNewTrainList, StringLen($sNewTrainList)-2)
Setlog("Current train order= " & $sNewTrainList, $COLOR_BLUE)
EndIf
EndIf
EndFunc
Func chkDarkTroopOrder2()
chkDarkTroopOrder()
EndFunc
Func chkDarkTroopOrder($bNoiseMode = True)
If GUICtrlRead($chkDarkTroopOrder) = $GUI_CHECKED Then
$ichkDarkTroopOrder = 1
GUICtrlSetState($btnDarkTroopOrderSet, $GUI_ENABLE)
For $i = 0 To UBound($aDarkTroopOrderList) - 2
GUICtrlSetState($cmbDarkTroopOrder[$i], $GUI_ENABLE)
Next
If IsUseCustomDarkTroopOrder() = True Then GUICtrlSetImage($ImgDarkTroopOrderSet, $pIconLib, $eIcnRedLight)
Else
$ichkDarkTroopOrder = 0
GUICtrlSetState($btnDarkTroopOrderSet, $GUI_DISABLE)
For $i = 0 To UBound($aDarkTroopOrderList) - 2
GUICtrlSetState($cmbDarkTroopOrder[$i], $GUI_DISABLE)
Next
SetDefaultTroopGroupDark($bNoiseMode)
If $bNoiseMode Or $debugsetlogTrain = 1 Then
Local $sNewTrainList = ""
For $i = 0 To UBound($DefaultTroopGroupDark) - 1
$sNewTrainList &= $TroopDarkName[$i] & ", "
Next
$sNewTrainList = StringLeft($sNewTrainList, StringLen($sNewTrainList)-2)
Setlog("Current train order= " & $sNewTrainList, $COLOR_BLUE)
EndIf
EndIf
EndFunc
Func GUITrainOrder()
Local $bDuplicate = False
Local $iGUI_CtrlId = @GUI_CtrlId
Local $iCtrlIdImage = $iGUI_CtrlId + 1
Local $iTroopIndex = _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) + 1
GUICtrlSetImage($iCtrlIdImage, $pIconLib, $aTroopOrderIcon[$iTroopIndex])
For $i = 0 To UBound($aTroopOrderList) - 2
If $iGUI_CtrlId = $cmbTroopOrder[$i] Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) = _GUICtrlComboBox_GetCurSel($cmbTroopOrder[$i]) Then
GUICtrlSetImage($ImgTroopOrder[$i], $pIconLib, $eIcnOptions)
_GUICtrlComboBox_SetCurSel($cmbTroopOrder[$i], -1)
GUISetState()
$bDuplicate = True
EndIf
Next
If $bDuplicate = True Then
GUICtrlSetState($BtnTroopOrderSet, $GUI_DISABLE)
Return
Else
GUICtrlSetState($BtnTroopOrderSet, $GUI_ENABLE)
GUICtrlSetImage($ImgTroopOrderSet, $pIconLib, $eIcnRedLight)
EndIf
EndFunc
Func GUITrainDarkOrder()
Local $bDuplicate = False
Local $iGUI_CtrlId = @GUI_CtrlId
Local $iCtrlIdImage = $iGUI_CtrlId + 1
Local $iTroopIndex = _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) + 1
GUICtrlSetImage($iCtrlIdImage, $pIconLib, $aDarkTroopOrderIcon[$iTroopIndex])
For $i = 0 To UBound($aDarkTroopOrderList) - 2
If $iGUI_CtrlId = $cmbDarkTroopOrder[$i] Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($iGUI_CtrlId) = _GUICtrlComboBox_GetCurSel($cmbDarkTroopOrder[$i]) Then
GUICtrlSetImage($ImgDarkTroopOrder[$i], $pIconLib, $eIcnOptions)
_GUICtrlComboBox_SetCurSel($cmbDarkTroopOrder[$i], -1)
GUISetState()
$bDuplicate = True
EndIf
Next
If $bDuplicate = True Then
GUICtrlSetState($BtnDarkTroopOrderSet, $GUI_DISABLE)
Return
Else
GUICtrlSetState($BtnDarkTroopOrderSet, $GUI_ENABLE)
GUICtrlSetImage($ImgDarkTroopOrderSet, $pIconLib, $eIcnRedLight)
EndIf
EndFunc
Func BtnTroopOrderSet()
Local $bReady = True
Local $sNewTrainList = ""
For $i = 0 To UBound($aTroopOrderList) - 2
For $j = 0 To UBound($aTroopOrderList) - 2
If $i = $j Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($cmbTroopOrder[$i]) = _GUICtrlComboBox_GetCurSel($cmbTroopOrder[$j]) Then
_GUICtrlComboBox_SetCurSel($cmbTroopOrder[$j], -1)
GUICtrlSetImage($ImgTroopOrder[$j], $pIconLib, $eIcnOptions)
$bReady = False
Else
GUICtrlSetColor($cmbTroopOrder[$j], $COLOR_BLACK)
EndIf
$icmbTroopOrder[$i] = _GUICtrlComboBox_GetCurSel($cmbTroopOrder[$i])
Next
Next
If $bReady Then
ChangeTroopTrainOrder()
If @error Then
Switch @error
Case 1
Setlog("Code problem, can not continue till fixed!", $COLOR_RED)
Case 2
Setlog("Bad Combobox selections, please fix!", $COLOR_RED)
Case 3
Setlog("Unable to Change Troop Train Order due bad change count!", $COLOR_RED)
Case Else
Setlog("Monkey ate bad banana, something wrong with ChangeTroopTrainOrder() code!", $COLOR_RED)
EndSwitch
GUICtrlSetImage($ImgTroopOrderSet, $pIconLib, $eIcnRedLight)
Else
Setlog("Troop training order changed successfully!", $COLOR_GREEN)
For $i = 0 To UBound($DefaultTroopGroup) - 1
$sNewTrainList &= $TroopName[$i] & ", "
Next
Setlog("Troop train order= " & $sNewTrainList, $COLOR_BLUE)
EndIf
Else
Setlog("Must use all troops and No duplicate troop names!", $COLOR_RED)
GUICtrlSetImage($ImgTroopOrderSet, $pIconLib, $eIcnRedLight)
EndIf
GUICtrlSetState(BtnTroopOrderSet, $GUI_DISABLE)
EndFunc
Func BtnDarkTroopOrderSet()
Local $bReady = True
Local $sNewTrainList = ""
For $i = 0 To UBound($aDarkTroopOrderList) - 2
For $j = 0 To UBound($aDarkTroopOrderList) - 2
If $i = $j Then ContinueLoop
If _GUICtrlComboBox_GetCurSel($cmbDarkTroopOrder[$i]) = _GUICtrlComboBox_GetCurSel($cmbDarkTroopOrder[$j]) Then
_GUICtrlComboBox_SetCurSel($cmbDarkTroopOrder[$j], -1)
GUICtrlSetImage($ImgDarkTroopOrder[$j], $pIconLib, $eIcnOptions)
$bReady = False
Else
GUICtrlSetColor($cmbDarkTroopOrder[$j], $COLOR_BLACK)
EndIf
$icmbDarkTroopOrder[$i] = _GUICtrlComboBox_GetCurSel($cmbDarkTroopOrder[$i])
Next
Next
If $bReady Then
ChangeDarkTroopTrainOrder()
If @error Then
Switch @error
Case 1
Setlog("Code problem, can not continue till fixed!", $COLOR_RED)
Case 2
Setlog("Bad Combobox selections, please fix!", $COLOR_RED)
Case 3
Setlog("Unable to Change Dark Troop Train Order due bad change count!", $COLOR_RED)
Case Else
Setlog("Monkey ate bad banana, something wrong with ChangeDarkTroopTrainOrder() code!", $COLOR_RED)
EndSwitch
GUICtrlSetImage($ImgDarkTroopOrderSet, $pIconLib, $eIcnRedLight)
Else
Setlog("Troop training order changed successfully!", $COLOR_GREEN)
For $i = 0 To UBound($DefaultTroopGroupDark) - 1
$sNewTrainList &= $TroopDarkName[$i] & ", "
Next
Setlog("Troop train order= " & $sNewTrainList, $COLOR_BLUE)
EndIf
Else
Setlog("Must use all dark troops and No duplicate troop names!", $COLOR_RED)
GUICtrlSetImage($ImgDarkTroopOrderSet, $pIconLib, $eIcnRedLight)
EndIf
GUICtrlSetState($BtnDarkTroopOrderSet, $GUI_DISABLE)
EndFunc
Func ChangeTroopTrainOrder()
If $debugsetlog = 1 Or $debugsetlogTrain = 1 Then Setlog("Begin Func ChangeTroopTrainOrder()", $COLOR_DEBUG)
Local $sComboText = ""
Local $NewTroopGroup[19][3]
Local $iUpdateCount = 0
If UBound($aTroopOrderList) - 1 <> UBound($TroopGroup) Then
If $debugsetlogTrain = 1 Then Setlog("UBound($aTroopOrderList) - 1: " & UBound($aTroopOrderList) - 1 & " = " & UBound($TroopGroup) & "UBound($TroopGroup)", $COLOR_DEBUG)
Setlog("Monkey ate bad banana, fix $aTroopOrderList & $TroopGroup arrays!", $COLOR_RED)
SetError(1, 0, False)
Return
EndIf
If IsUseCustomTroopOrder() = False Then
SetError(2, 0, False)
Return
EndIf
For $i = 0 To UBound($aTroopOrderList) - 2
$sComboText = StringLeft(StringStripWS(GUICtrlRead($cmbTroopOrder[$i]), $STR_STRIPALL), 5)
For $j = 0 To UBound($DefaultTroopGroup) - 1
If StringInStr($sComboText, $j > 11 ? StringLeft($DefaultTroopGroup[$j][0], 3) : $DefaultTroopGroup[$j][0], $STR_NOCASESENSEBASIC) = 0 Then ContinueLoop
$iUpdateCount += 1
For $k = 0 To UBound($DefaultTroopGroup, 2) - 1
$NewTroopGroup[$i][$k] = $DefaultTroopGroup[$j][$k]
Next
ExitLoop
Next
Next
If $iUpdateCount = UBound($DefaultTroopGroup, 1) Then
For $j = 0 To UBound($DefaultTroopGroup) - 1
For $k = 0 To UBound($DefaultTroopGroup, 2) - 1
$TroopGroup[$j][$k] = $NewTroopGroup[$j][$k]
Next
If $debugsetlogTrain = 1 Then Setlog("$TroopGroup[" & $j & "]= " & $TroopGroup[$j][0] & ":" & $TroopGroup[$j][1] & ":" & $TroopGroup[$j][2], $COLOR_ORANGE)
Next
For $i = 0 To UBound($TroopGroup, 1) - 1
$TroopName[$i] = $TroopGroup[$i][0]
$TroopNamePosition[$i] = $TroopGroup[$i][1]
$TroopHeight[$i] = $TroopGroup[$i][2]
Next
GUICtrlSetImage($ImgTroopOrderSet, $pIconLib, $eIcnGreenLight)
Else
Setlog($iUpdateCount & "|" & UBound($DefaultTroopGroup, 1) & " - Error - Bad troop assignment in ChangeTroopTrainOrder()", $COLOR_RED)
SetError(3, 0, False)
Return
EndIf
Return True
EndFunc
Func ChangeDarkTroopTrainOrder()
If $debugsetlog = 1 Or $debugsetlogTrain = 1 Then Setlog("Begin Func ChangeDarkTroopTrainOrder()", $COLOR_DEBUG)
Local $sComboText = ""
Local $NewTroopGroup[7][3]
Local $iUpdateCount = 0
If UBound($aDarkTroopOrderList) - 1 <> UBound($TroopGroupDark) Then
If $debugsetlogTrain = 1 Then Setlog("UBound($aDarkTroopOrderList) - 1: " & UBound($aDarkTroopOrderList) - 1 & " = " & UBound($TroopGroupDark) & "UBound($TroopGroupDark)", $COLOR_DEBUG)
Setlog("Monkey ate bad banana, fix $aDarkTroopOrderList & $TroopGroupDark arrays!", $COLOR_RED)
SetError(1, 0, False)
Return
EndIf
If IsUseCustomDarkTroopOrder() = False Then
SetError(2, 0, False)
Return
EndIf
For $i = 0 To UBound($aDarkTroopOrderList) - 2
$sComboText = StringLeft(StringStripWS(GUICtrlRead($cmbDarkTroopOrder[$i]), $STR_STRIPALL), 5)
For $j = 0 To UBound($DefaultTroopGroupDark) - 1
If StringInStr($sComboText, StringLeft($DefaultTroopGroupDark[$j][0],3), $STR_NOCASESENSEBASIC) = 0 Then ContinueLoop
$iUpdateCount += 1
For $k = 0 To UBound($DefaultTroopGroupDark, 2) - 1
$NewTroopGroup[$i][$k] = $DefaultTroopGroupDark[$j][$k]
Next
ExitLoop
Next
Next
If $iUpdateCount = UBound($DefaultTroopGroupDark, 1) Then
For $j = 0 To UBound($DefaultTroopGroupDark) - 1
For $k = 0 To UBound($DefaultTroopGroupDark, 2) - 1
$TroopGroupDark[$j][$k] = $NewTroopGroup[$j][$k]
Next
If $debugsetlogTrain = 1 Then Setlog("$TroopGroupDark[" & $j & "]= " & $TroopGroupDark[$j][0] & ":" & $TroopGroupDark[$j][1] & ":" & $TroopGroupDark[$j][2], $COLOR_ORANGE)
Next
For $i = 0 To UBound($TroopGroupDark, 1) - 1
$TroopDarkName[$i] = $TroopGroupDark[$i][0]
$TroopDarkNamePosition[$i] = $TroopGroupDark[$i][1]
$TroopDarkHeight[$i] = $TroopGroupDark[$i][2]
Next
GUICtrlSetImage($ImgDarkTroopOrderSet, $pIconLib, $eIcnGreenLight)
Else
Setlog("Error - Bad troop assignment in ChangeDarkTroopTrainOrder()", $COLOR_RED)
SetError(3, 0, False)
Return
EndIf
Return True
EndFunc
Func SetDefaultTroopGroup($bNoiseMode = True)
For $i = 0 To UBound($DefaultTroopGroup, 1) - 1
For $j = 0 To UBound($DefaultTroopGroup, 2) - 1
$TroopGroup[$i][$j] = $DefaultTroopGroup[$i][$j]
Next
Next
For $i = 0 To UBound($DefaultTroopGroup, 1) - 1
$TroopName[$i] = $TroopGroup[$i][0]
$TroopNamePosition[$i] = $TroopGroup[$i][1]
$TroopHeight[$i] = $TroopGroup[$i][2]
Next
If $bNoiseMode Or $debugsetlogTrain = 1 Then Setlog("Default troop training order set", $COLOR_GREEN)
EndFunc
Func SetDefaultTroopGroupDark($bNoiseMode = True)
For $i = 0 To UBound($DefaultTroopGroupDark, 1) - 1
For $j = 0 To UBound($DefaultTroopGroupDark, 2) - 1
$TroopGroupDark[$i][$j] = $DefaultTroopGroupDark[$i][$j]
Next
Next
For $i = 0 To UBound($DefaultTroopGroupDark, 1) - 1
$TroopDarkName[$i] = $TroopGroupDark[$i][0]
$TroopDarkNamePosition[$i] = $TroopGroupDark[$i][1]
$TroopDarkHeight[$i] = $TroopGroupDark[$i][2]
Next
If $bNoiseMode Or $debugsetlogTrain = 1 Then Setlog("Default dark troop training order set", $COLOR_GREEN)
EndFunc
Func IsUseCustomTroopOrder()
For $i = 0 To UBound($aTroopOrderList) - 2
If $icmbTroopOrder[$i] = -1 Then
If $debugsetlogTrain = 1 Then Setlog("Custom train order not used...", $COLOR_DEBUG)
Return False
EndIf
Next
If $debugsetlogTrain = 1 Then Setlog("Custom train order used...", $COLOR_DEBUG)
Return True
EndFunc
Func IsUseCustomDarkTroopOrder()
For $i = 0 To UBound($aDarkTroopOrderList) - 2
If $icmbDarkTroopOrder[$i] = -1 Then
If $debugsetlogTrain = 1 Then Setlog("Custom dark train order not used...", $COLOR_DEBUG)
Return False
EndIf
Next
If $debugsetlogTrain = 1 Then Setlog("Custom dark train order used...", $COLOR_DEBUG)
Return True
EndFunc
Func chkSmartLightSpell()
If GUICtrlRead($chkSmartLightSpell) = $GUI_CHECKED Then
GUICtrlSetState($chkSmartZapDB, $GUI_ENABLE)
GUICtrlSetState($chkSmartZapSaveHeroes, $GUI_ENABLE)
GUICtrlSetState($txtMinDark, $GUI_ENABLE)
GUICtrlSetState($chkNoobZap, $GUI_ENABLE)
$ichkSmartZap = 1
Else
GUICtrlSetState($chkSmartZapDB, $GUI_DISABLE)
GUICtrlSetState($chkSmartZapSaveHeroes, $GUI_DISABLE)
GUICtrlSetState($txtMinDark, $GUI_DISABLE)
GUICtrlSetState($chkNoobZap, $GUI_DISABLE)
$ichkSmartZap = 0
EndIf
EndFunc
Func ForceTimeStopAtk()
If GUICtrlRead($chkSmartLightSpell) = $GUI_CHECKED And GUICtrlRead($chkDBTimeStopAtk) = $GUI_CHECKED Then
GUICtrlSetState($chkDBTimeStopAtk, $GUI_UNCHECKED)
$ichkTimeStopAtk[$DB] = 0
EndIf
If GUICtrlRead($chkSmartLightSpell) = $GUI_CHECKED And GUICtrlRead($chkABTimeStopAtk) = $GUI_CHECKED Then
GUICtrlSetState($chkABTimeStopAtk, $GUI_UNCHECKED)
$ichkTimeStopAtk[$LB] = 0
EndIf
EndFunc
Func chkNoobZap()
If GUICtrlRead($chkNoobZap) = $GUI_CHECKED Then
GUICtrlSetState($txtExpectedDE, $GUI_ENABLE)
$ichkNoobZap = 1
Else
GUICtrlSetState($txtExpectedDE, $GUI_DISABLE)
$ichkNoobZap = 0
EndIf
EndFunc
Func chkSmartZapDB()
If GUICtrlRead($chkSmartZapDB) = $GUI_CHECKED Then
$ichkSmartZapDB = 1
Else
$ichkSmartZapDB = 0
EndIf
EndFunc
Func chkSmartZapSaveHeroes()
If GUICtrlRead($chkSmartZapSaveHeroes) = $GUI_CHECKED Then
$ichkSmartZapSaveHeroes = 1
Else
$ichkSmartZapSaveHeroes = 0
EndIf
EndFunc
Func txtMinDark()
$itxtMinDE = GUICtrlRead($txtMinDark)
EndFunc
Func txtExpectedDE()
$itxtExpectedDE = GUICtrlRead($txtExpectedDE)
EndFunc
Func leftclick()
If $iGUIEnabled = False Then Return
$ilftclck = GUIGetCursorInfo($frmBot)
Switch $ilftclck[4]
Case $icnBarb
LevUpDown("Barb")
lblTotalCount()
Case $icnArch
LevUpDown("Arch")
lblTotalCount()
Case $icnGiant
LevUpDown("Giant")
lblTotalCount()
Case $icnGobl
LevUpDown("Gobl")
lblTotalCount()
Case $icnWall
LevUpDown("Wall")
lblTotalCount()
Case $icnWiza
LevUpDown("Wiza")
lblTotalCount()
Case $icnBall
LevUpDown("Ball")
lblTotalCount()
Case $icnHeal
LevUpDown("Heal")
lblTotalCount()
Case $icnDrag
LevUpDown("Drag")
lblTotalCount()
Case $icnPekk
LevUpDown("Pekk")
lblTotalCount()
Case $icnBabyD
LevUpDown("BabyD")
lblTotalCount()
Case $icnMine
LevUpDown("Mine")
lblTotalCount()
Case $icnMini
LevUpDown("Mini")
lblTotalCount()
Case $icnHogs
LevUpDown("Hogs")
lblTotalCount()
Case $icnValk
LevUpDown("Valk")
lblTotalCount()
Case $icnGole
LevUpDown("Gole")
lblTotalCount()
Case $icnWitc
LevUpDown("Witc")
lblTotalCount()
Case $icnLava
LevUpDown("Lava")
lblTotalCount()
Case $icnBowl
LevUpDown("Bowl")
lblTotalCount()
Case $lblLightningIcon
LevUpDown("LightningSpell")
lblTotalCountSpell()
Case $lblHealIcon
LevUpDown("HealSpell")
lblTotalCountSpell()
Case $lblRageIcon
LevUpDown("RageSpell")
lblTotalCountSpell()
Case $lblJumpSpellIcon
LevUpDown("JumpSpell")
lblTotalCountSpell()
Case $lblFreezeIcon
LevUpDown("FreezeSpell")
lblTotalCountSpell()
Case $lblCloneIcon
LevUpDown("CloneSpell")
lblTotalCountSpell()
Case $lblPoisonIcon
LevUpDown("PoisonSpell")
lblTotalCountSpell()
Case $lblEarthquakeIcon
LevUpDown("EarthSpell")
lblTotalCountSpell()
Case $lblHasteIcon
LevUpDown("HasteSpell")
lblTotalCountSpell()
Case $lblSkeletonIcon
LevUpDown("SkeletonSpell")
lblTotalCountSpell()
EndSwitch
Return
EndFunc
Func rightclick()
If $iGUIEnabled = False Then Return
$irghtclck = GUIGetCursorInfo($frmBot)
Switch $irghtclck[4]
Case $icnBarb
LevUpDown("Barb")
lblTotalCount()
Case $icnArch
LevUpDown("Arch")
lblTotalCount()
Case $icnGiant
LevUpDown("Giant")
lblTotalCount()
Case $icnGobl
LevUpDown("Gobl")
lblTotalCount()
Case $icnWall
LevUpDown("Wall")
lblTotalCount()
Case $icnWiza
LevUpDown("Wiza")
lblTotalCount()
Case $icnBall
LevUpDown("Ball")
lblTotalCount()
Case $icnHeal
LevUpDown("Heal")
lblTotalCount()
Case $icnDrag
LevUpDown("Drag")
lblTotalCount()
Case $icnPekk
LevUpDown("Pekk")
lblTotalCount()
Case $icnBabyD
LevUpDown("BabyD")
lblTotalCount()
Case $icnMine
LevUpDown("Mine")
lblTotalCount()
Case $icnMini
LevUpDown("Mini")
lblTotalCount()
Case $icnHogs
LevUpDown("Hogs")
lblTotalCount()
Case $icnValk
LevUpDown("Valk")
lblTotalCount()
Case $icnGole
LevUpDown("Gole")
lblTotalCount()
Case $icnWitc
LevUpDown("Witc")
lblTotalCount()
Case $icnLava
LevUpDown("Lava")
lblTotalCount()
Case $icnBowl
LevUpDown("Bowl")
lblTotalCount()
Case $lblLightningIcon
LevUpDown("LightningSpell")
lblTotalCountSpell()
Case $lblHealIcon
LevUpDown("HealSpell")
lblTotalCountSpell()
Case $lblRageIcon
LevUpDown("RageSpell")
lblTotalCountSpell()
Case $lblJumpSpellIcon
LevUpDown("JumpSpell")
lblTotalCountSpell()
Case $lblFreezeIcon
LevUpDown("FreezeSpell")
lblTotalCountSpell()
Case $lblCloneIcon
LevUpDown("CloneSpell")
lblTotalCountSpell()
Case $lblPoisonIcon
LevUpDown("PoisonSpell")
lblTotalCountSpell()
Case $lblEarthquakeIcon
LevUpDown("EarthSpell")
lblTotalCountSpell()
Case $lblHasteIcon
LevUpDown("HasteSpell")
lblTotalCountSpell()
Case $lblSkeletonIcon
LevUpDown("SkeletonSpell")
lblTotalCountSpell()
EndSwitch
Return
EndFunc
Func LevUpDown($SelTroopSpell)
Local $TempClick
While _IsPressed(01)
$TempClick = Eval("txtNum" & $SelTroopSpell) + 1
GUICtrlSetData(Eval("txtNum" & $SelTroopSpell), GUICtrlRead(Eval("txtNum" & $SelTroopSpell)) + 1)
Sleep(150)
WEnd
While _IsPressed(02)
$TempClick = Eval("txtNum" & $SelTroopSpell) - 1
GUICtrlSetData(Eval("txtNum" & $SelTroopSpell), GUICtrlRead(Eval("txtNum" & $SelTroopSpell)) - 1)
Sleep(150)
WEnd
EndFunc
Func Removecamp()
For $T = 0 To UBound($TroopName) - 1
Assign($TroopName[$T] & "Comp", 0)
GUICtrlSetData(Eval("txtNum" & $TroopName[$T]), 0)
Next
For $S = 0 To UBound($TxtNameSpell) - 1
Assign($TxtNameSpell[$S] & "Comp", 0)
GUICtrlSetData(Eval("txtNum" & $TxtNameSpell[$S]), 0)
Next
For $C = 0 To UBound($SpellName) - 1
Assign($SpellName[$C] & "Comp", 0)
Next
lblTotalCount()
lblTotalCountSpell()
EndFunc
Func chkTrap()
If GUICtrlRead($chkTrap) = $GUI_CHECKED Then
$ichkTrap = 1
Else
$ichkTrap = 0
EndIf
EndFunc
Func chkRequestCCHours()
Local $bWasRedraw = SetRedrawBotWindow(False)
If GUICtrlRead($chkRequestCCHours) = $GUI_CHECKED Then
GUICtrlSetState($txtRequestCC, $GUI_SHOW + $GUI_ENABLE)
For $i = $lbRequestCCHours1 To $lbRequestCCHoursPM
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
GUICtrlSetState($txtRequestCC, $GUI_SHOW + $GUI_DISABLE)
For $i = $lbRequestCCHours1 To $lbRequestCCHoursPM
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
SetRedrawBotWindowControls($bWasRedraw, $grpRequestCC)
EndFunc
Func chkRequestCCHoursE1()
If GUICtrlRead($chkRequestCCHoursE1) = $GUI_CHECKED And GUICtrlRead($chkRequestCCHours0) = $GUI_CHECKED Then
For $i = $chkRequestCCHours0 To $chkRequestCCHours11
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkRequestCCHours0 To $chkRequestCCHours11
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkRequestCCHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkRequestCCHoursE2()
If GUICtrlRead($chkRequestCCHoursE2) = $GUI_CHECKED And GUICtrlRead($chkRequestCCHours12) = $GUI_CHECKED Then
For $i = $chkRequestCCHours12 To $chkRequestCCHours23
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkRequestCCHours12 To $chkRequestCCHours23
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkRequestCCHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkDonateHours()
Local $bWasRedraw = SetRedrawBotWindow(False)
If GUICtrlRead($chkDonateHours) = $GUI_CHECKED Then
For $i = $lbDonateHours1 To $lbDonateHoursPM
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $lbDonateHours1 To $lbDonateHoursPM
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
SetRedrawBotWindowControls($bWasRedraw, $grpDonateCC)
EndFunc
Func chkDonateHoursE1()
If GUICtrlRead($chkDonateHoursE1) = $GUI_CHECKED And GUICtrlRead($chkDonateHours0) = $GUI_CHECKED Then
For $i = $chkDonateHours0 To $chkDonateHours11
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkDonateHours0 To $chkDonateHours11
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkDonateHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkDonateHoursE2()
If GUICtrlRead($chkDonateHoursE2) = $GUI_CHECKED And GUICtrlRead($chkDonateHours12) = $GUI_CHECKED Then
For $i = $chkDonateHours12 To $chkDonateHours23
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkDonateHours12 To $chkDonateHours23
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkDonateHoursE2, $GUI_UNCHECKED)
EndFunc
Func chkDropCCHoursEnable()
If GUICtrlRead($chkDropCCHoursEnable) = $GUI_CHECKED Then
$ichkDropCCHoursEnable = 1
For $i = $chkDropCCHours0 To $chkDropCCHours11
GUICtrlSetState($i, $GUI_ENABLE)
Next
For $i = $chkDropCCHours12 To $chkDropCCHours23
GUICtrlSetState($i, $GUI_ENABLE)
Next
GUICtrlSetState($chkDropCCHoursE1, $GUI_ENABLE)
GUICtrlSetState($chkDropCCHoursE2, $GUI_ENABLE)
Else
$ichkDropCCHoursEnable = 0
For $i = $chkDropCCHours0 To $chkDropCCHours11
GUICtrlSetState($i, $GUI_DISABLE)
Next
For $i = $chkDropCCHours12 To $chkDropCCHours23
GUICtrlSetState($i, $GUI_DISABLE)
Next
GUICtrlSetState($chkDropCCHoursE1, $GUI_DISABLE)
GUICtrlSetState($chkDropCCHoursE2, $GUI_DISABLE)
EndIf
EndFunc
Func chkDropCCHoursE1()
If GUICtrlRead($chkDropCCHoursE1) = $GUI_CHECKED And GUICtrlRead($chkDropCCHours0) = $GUI_CHECKED Then
For $i = $chkDropCCHours0 To $chkDropCCHours11
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkDropCCHours0 To $chkDropCCHours11
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkDropCCHoursE1, $GUI_UNCHECKED)
EndFunc
Func chkDropCCHoursE2()
If GUICtrlRead($chkDropCCHoursE2) = $GUI_CHECKED And GUICtrlRead($chkDropCCHours12) = $GUI_CHECKED Then
For $i = $chkDropCCHours12 To $chkDropCCHours23
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkDropCCHours12 To $chkDropCCHours23
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkDropCCHoursE2, $GUI_UNCHECKED)
EndFunc
Func cmbDBGoldElixir()
If _GUICtrlComboBox_GetCurSel($cmbDBMeetGE) < 2 Then
GUICtrlSetState($txtDBMinGold, $GUI_SHOW)
GUICtrlSetState($picDBMinGold, $GUI_SHOW)
GUICtrlSetState($txtDBMinElixir, $GUI_SHOW)
GUICtrlSetState($picDBMinElixir, $GUI_SHOW)
GUICtrlSetState($txtDBMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($picDBMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($txtDBMinGold, $GUI_HIDE)
GUICtrlSetState($picDBMinGold, $GUI_HIDE)
GUICtrlSetState($txtDBMinElixir, $GUI_HIDE)
GUICtrlSetState($picDBMinElixir, $GUI_HIDE)
GUICtrlSetState($txtDBMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($picDBMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkDBMeetDE()
If GUICtrlRead($chkDBMeetDE) = $GUI_CHECKED Then
_GUICtrlEdit_SetReadOnly($txtDBMinDarkElixir, False)
Else
_GUICtrlEdit_SetReadOnly($txtDBMinDarkElixir, True)
EndIf
EndFunc
Func chkDBMeetTrophy()
If GUICtrlRead($chkDBMeetTrophy) = $GUI_CHECKED Then
_GUICtrlEdit_SetReadOnly($txtDBMinTrophy, False)
Else
_GUICtrlEdit_SetReadOnly($txtDBMinTrophy, True)
EndIf
EndFunc
Func chkDBMeetTH()
If GUICtrlRead($chkDBMeetTH) = $GUI_CHECKED Then
GUICtrlSetState($cmbDBTH, $GUI_ENABLE)
Else
GUICtrlSetState($cmbDBTH, $GUI_DISABLE)
EndIf
EndFunc
Func chkDBWeakBase()
If GUICtrlRead($chkMaxMortar[$DB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakMortar[$DB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakMortar[$DB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxWizTower[$DB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakWizTower[$DB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakWizTower[$DB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxAirDefense[$DB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakAirDefense[$DB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakAirDefense[$DB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxXBow[$DB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakXBow[$DB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakXBow[$DB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxInferno[$DB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakInferno[$DB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakInferno[$DB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxEagle[$DB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakEagle[$DB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakEagle[$DB], $GUI_DISABLE)
EndIf
EndFunc
Func cmbABGoldElixir()
If _GUICtrlComboBox_GetCurSel($cmbABMeetGE) < 2 Then
GUICtrlSetState($txtABMinGold, $GUI_SHOW)
GUICtrlSetState($picABMinGold, $GUI_SHOW)
GUICtrlSetState($txtABMinElixir, $GUI_SHOW)
GUICtrlSetState($picABMinElixir, $GUI_SHOW)
GUICtrlSetState($txtABMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($picABMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($txtABMinGold, $GUI_HIDE)
GUICtrlSetState($picABMinGold, $GUI_HIDE)
GUICtrlSetState($txtABMinElixir, $GUI_HIDE)
GUICtrlSetState($picABMinElixir, $GUI_HIDE)
GUICtrlSetState($txtABMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($picABMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkABMeetDE()
If GUICtrlRead($chkABMeetDE) = $GUI_CHECKED Then
_GUICtrlEdit_SetReadOnly($txtABMinDarkElixir, False)
Else
_GUICtrlEdit_SetReadOnly($txtABMinDarkElixir, True)
EndIf
EndFunc
Func chkABMeetTrophy()
If GUICtrlRead($chkABMeetTrophy) = $GUI_CHECKED Then
_GUICtrlEdit_SetReadOnly($txtABMinTrophy, False)
Else
_GUICtrlEdit_SetReadOnly($txtABMinTrophy, True)
EndIf
EndFunc
Func chkABMeetTH()
If GUICtrlRead($chkABMeetTH) = $GUI_CHECKED Then
GUICtrlSetState($cmbABTH, $GUI_ENABLE)
Else
GUICtrlSetState($cmbABTH, $GUI_DISABLE)
EndIf
EndFunc
Func chkABWeakBase()
If GUICtrlRead($chkMaxMortar[$LB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakMortar[$LB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakMortar[$LB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxWizTower[$LB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakWizTower[$LB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakWizTower[$LB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxAirDefense[$LB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakAirDefense[$LB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakAirDefense[$LB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxXBow[$LB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakXBow[$LB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakXBow[$LB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxInferno[$LB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakInferno[$LB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakInferno[$LB], $GUI_DISABLE)
EndIf
If GUICtrlRead($chkMaxEagle[$LB]) = $GUI_CHECKED Then
GUICtrlSetState($cmbWeakEagle[$LB], $GUI_ENABLE)
Else
GUICtrlSetState($cmbWeakEagle[$LB], $GUI_DISABLE)
EndIf
EndFunc
Func chkRestartSearchLimit()
If GUICtrlRead($ChkRestartSearchLimit) = $GUI_CHECKED Then
GUICtrlSetState($txtRestartSearchlimit, $GUI_ENABLE)
Else
GUICtrlSetState($txtRestartSearchlimit, $GUI_DISABLE)
EndIf
EndFunc
Func btnConfigureCollectors()
EndFunc
Func btnConfigureReduction()
EndFunc
Func btnConfigureTHBully()
EndFunc
Func btnConfigureDBWeakBase()
EndFunc
Func btnConfigureABWeakBase()
EndFunc
Func chkDBActivateSearches()
If GUICtrlRead($chkDBActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($txtDBSearchesMin, $GUI_ENABLE)
GUICtrlSetState($lblDBSearches, $GUI_ENABLE)
GUICtrlSetState($txtDBSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($txtDBSearchesMin, $GUI_DISABLE)
GUICtrlSetState($lblDBSearches, $GUI_DISABLE)
GUICtrlSetState($txtDBSearchesMax, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func chkDBActivateTropies()
If GUICtrlRead($chkDBActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($txtDBTropiesMin, $GUI_ENABLE)
GUICtrlSetState($lblDBTropies, $GUI_ENABLE)
GUICtrlSetState($txtDBTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($txtDBTropiesMin, $GUI_DISABLE)
GUICtrlSetState($lblDBTropies, $GUI_DISABLE)
GUICtrlSetState($txtDBTropiesMax, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func chkDBActivateCamps()
If GUICtrlRead($chkDBActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($lblDBArmyCamps, $GUI_ENABLE)
GUICtrlSetState($txtDBArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($lblDBArmyCamps, $GUI_DISABLE)
GUICtrlSetState($txtDBArmyCamps, $GUI_DISABLE)
EndIf
dbCheckall()
EndFunc
Func EnableSearchPanels($mode)
Switch $mode
Case $DB
If GUICtrlRead($chkDBActivateSearches) = $GUI_CHECKED Or GUICtrlRead($chkDBActivateTropies) = $GUI_CHECKED Or GUICtrlRead($chkDBActivateCamps) = $GUI_CHECKED Or GUICtrlRead($chkDBKingWait) = $GUI_CHECKED Or GUICtrlRead($chkDBQueenWait) = $GUI_CHECKED Or GUICtrlRead($chkDBWardenWait) = $GUI_CHECKED Or GUICtrlRead($chkDBSpellsWait) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupHerosDB)
_GUI_Value_STATE("SHOW", $groupSearchDB)
_GUI_Value_STATE("SHOW", $groupSpellsDB)
cmbDBGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupHerosDB)
_GUI_Value_STATE("HIDE", $groupSearchDB)
_GUI_Value_STATE("HIDE", $groupSpellsDB)
EndIf
Case $LB
If GUICtrlRead($chkABActivateSearches) = $GUI_CHECKED Or GUICtrlRead($chkABActivateTropies) = $GUI_CHECKED Or GUICtrlRead($chkABActivateCamps) = $GUI_CHECKED Or GUICtrlRead($chkABKingWait) = $GUI_CHECKED Or GUICtrlRead($chkABQueenWait) = $GUI_CHECKED Or GUICtrlRead($chkABWardenWait) = $GUI_CHECKED Or GUICtrlRead($chkABSpellsWait) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupHerosAB)
_GUI_Value_STATE("SHOW", $groupSearchAB)
_GUI_Value_STATE("SHOW", $groupSpellsAB)
cmbABGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupHerosAB)
_GUI_Value_STATE("HIDE", $groupSearchAB)
_GUI_Value_STATE("HIDE", $groupSpellsAB)
EndIf
Case $TS
If GUICtrlRead($chkTSActivateSearches) = $GUI_CHECKED Or GUICtrlRead($chkTSActivateTropies) = $GUI_CHECKED Or GUICtrlRead($chkTSActivateCamps) = $GUI_CHECKED Then
_GUI_Value_STATE("SHOW", $groupSearchTS)
cmbTSGoldElixir()
Else
_GUI_Value_STATE("HIDE", $groupSearchTS)
EndIf
EndSwitch
EndFunc
Func chkABActivateSearches()
If GUICtrlRead($chkABActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($txtABSearchesMin, $GUI_ENABLE)
GUICtrlSetState($lblABSearches, $GUI_ENABLE)
GUICtrlSetState($txtABSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($txtABSearchesMin, $GUI_DISABLE)
GUICtrlSetState($lblABSearches, $GUI_DISABLE)
GUICtrlSetState($txtABSearchesMax, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkABActivateTropies()
If GUICtrlRead($chkABActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($txtABTropiesMin, $GUI_ENABLE)
GUICtrlSetState($lblABTropies, $GUI_ENABLE)
GUICtrlSetState($txtABTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($txtABTropiesMin, $GUI_DISABLE)
GUICtrlSetState($lblABTropies, $GUI_DISABLE)
GUICtrlSetState($txtABTropiesMax, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkABActivateCamps()
If GUICtrlRead($chkABActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($lblABArmyCamps, $GUI_ENABLE)
GUICtrlSetState($txtABArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($lblABArmyCamps, $GUI_DISABLE)
GUICtrlSetState($txtABArmyCamps, $GUI_DISABLE)
EndIf
abCheckall()
EndFunc
Func chkTSActivateSearches()
If GUICtrlRead($chkTSActivateSearches) = $GUI_CHECKED Then
GUICtrlSetState($txtTSSearchesMin, $GUI_ENABLE)
GUICtrlSetState($lblTSSearches, $GUI_ENABLE)
GUICtrlSetState($txtTSSearchesMax, $GUI_ENABLE)
Else
GUICtrlSetState($txtTSSearchesMin, $GUI_DISABLE)
GUICtrlSetState($lblTSSearches, $GUI_DISABLE)
GUICtrlSetState($txtTSSearchesMax, $GUI_DISABLE)
EndIf
tsCheckall()
EndFunc
Func chkTSActivateTropies()
If GUICtrlRead($chkTSActivateTropies) = $GUI_CHECKED Then
GUICtrlSetState($txtTSTropiesMin, $GUI_ENABLE)
GUICtrlSetState($lblTSTropies, $GUI_ENABLE)
GUICtrlSetState($txtTSTropiesMax, $GUI_ENABLE)
Else
GUICtrlSetState($txtTSTropiesMin, $GUI_DISABLE)
GUICtrlSetState($lblTSTropies, $GUI_DISABLE)
GUICtrlSetState($txtTSTropiesMax, $GUI_DISABLE)
EndIf
tsCheckAll()
EndFunc
Func chkTSActivateCamps()
If GUICtrlRead($chkTSActivateCamps) = $GUI_CHECKED Then
GUICtrlSetState($lblTSArmyCamps, $GUI_ENABLE)
GUICtrlSetState($txtTSArmyCamps, $GUI_ENABLE)
Else
GUICtrlSetState($lblTSArmyCamps, $GUI_DISABLE)
GUICtrlSetState($txtTSArmyCamps, $GUI_DISABLE)
EndIf
tsCheckAll()
EndFunc
Func chkDBKingWait()
If $iTownHallLevel > 6 Or $iTownHallLevel = 0 Then
If GUICtrlRead($chkDBKingWait) = $GUI_CHECKED Then
If $ichkUpgradeKing = 0 Then
GUICtrlSetState($chkDBKingAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $ichkUpgradeKing = 0 Then
GUICtrlSetState($chkDBKingWait, $GUI_ENABLE)
Else
GUICtrlSetState($chkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($chkDBKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($chkDBKingAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBQueenWait()
If $iTownHallLevel > 8 Or $iTownHallLevel = 0 Then
If GUICtrlRead($chkDBQueenWait) = $GUI_CHECKED Then
If $ichkUpgradeQueen = 0 Then
GUICtrlSetState($chkDBQueenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $ichkUpgradeQueen = 0 Then
GUICtrlSetState($chkDBQueenWait, $GUI_ENABLE)
Else
GUICtrlSetState($chkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($chkDBQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($chkDBQueenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBWardenWait()
If $iTownHallLevel > 10 Or $iTownHallLevel = 0 Then
If GUICtrlRead($chkDBWardenWait) = $GUI_CHECKED Then
If $ichkUpgradeWarden = 0 Then
GUICtrlSetState($chkDBWardenAttack, $GUI_CHECKED)
GUICtrlSetState($IMGchkDBWardenWait, $GUI_ENABLE)
Else
GUICtrlSetState($chkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $ichkUpgradeWarden = 0 Then
GUICtrlSetState($chkDBWardenWait, $GUI_ENABLE)
Else
GUICtrlSetState($chkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($chkDBWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($chkDBWardenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABKingWait()
If $iTownHallLevel > 6 Or $iTownHallLevel = 0 Then
If GUICtrlRead($chkABKingWait) = $GUI_CHECKED Then
If $ichkUpgradeKing = 0 Then
GUICtrlSetState($chkABKingAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $ichkUpgradeKing = 0 Then
GUICtrlSetState($chkABKingWait, $GUI_ENABLE)
Else
GUICtrlSetState($chkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($chkABKingWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($chkABKingAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABQueenWait()
If $iTownHallLevel > 8 Or $iTownHallLevel = 0 Then
If GUICtrlRead($chkABQueenWait) = $GUI_CHECKED Then
If $ichkUpgradeQueen = 0 Then
GUICtrlSetState($chkABQueenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $ichkUpgradeQueen = 0 Then
GUICtrlSetState($chkABQueenWait, $GUI_ENABLE)
Else
GUICtrlSetState($chkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($chkABQueenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($chkABQueenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkABWardenWait()
If $iTownHallLevel > 10 Or $iTownHallLevel = 0 Then
If GUICtrlRead($chkABWardenWait) = $GUI_CHECKED Then
If $ichkUpgradeWarden = 0 Then
GUICtrlSetState($chkABWardenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
Else
If $ichkUpgradeWarden = 0 Then
GUICtrlSetState($chkABWardenWait, $GUI_ENABLE)
Else
GUICtrlSetState($chkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndIf
Else
GUICtrlSetState($chkABWardenWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
GUICtrlSetState($chkABWardenAttack, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkDBSpellsWait()
If $iTownHallLevel > 4 Or $iTownHallLevel = 0 Then
For $i = $IMGchkDBLightSpellWait To $IMGchkDBHasteSpellWait
GUICtrlSetState($i, $GUI_ENABLE)
Next
If GUICtrlRead($chkDBSpellsWait) = $GUI_CHECKED Then
$iEnableSpellsWait[$DB] = 1
chkSpellWaitError()
If @error Then
GUICtrlSetState($chkDBSpellsWait, $GUI_UNCHECKED)
$iEnableSpellsWait[$DB] = 0
Setlog("Wait for Spells disabled due training count error", $COLOR_RED)
EndIf
Else
$iEnableSpellsWait[$DB] = 0
EndIf
Else
GUICtrlSetState($chkDBSpellsWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
For $i = $IMGchkDBLightSpellWait To $IMGchkDBHasteSpellWait
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkABSpellsWait()
If $iTownHallLevel > 4 Or $iTownHallLevel = 0 Then
For $i = $IMGchkABLightSpellWait To $IMGchkABHasteSpellWait
GUICtrlSetState($i, $GUI_ENABLE)
Next
If GUICtrlRead($chkABSpellsWait) = $GUI_CHECKED Then
$iEnableSpellsWait[$LB] = 1
chkSpellWaitError()
If @error Then
GUICtrlSetState($chkABSpellsWait, $GUI_UNCHECKED)
$iEnableSpellsWait[$LB] = 0
Setlog("Wait for Spells disabled due training count error", $COLOR_RED)
EndIf
Else
$iEnableSpellsWait[$LB] = 0
EndIf
Else
GUICtrlSetState($chkABSpellsWait, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
For $i = $IMGchkABLightSpellWait To $IMGchkABHasteSpellWait
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkSpellWaitError()
Local Static $bHaveBeenWarned = False
Local $bErrorCondition = False
Local $sErrorText, $sText, $MsgBox1, $MsgBox2, $MsgBox3
If $iTotalTrainSpaceSpell > GUICtrlRead($txtTotalCountSpell) Then
$sErrorText = GetTranslated(625,110, "Total number of trained spells exceeds total set in GUI!") & @CRLF &  GetTranslated(625,111, "Reduce number of trained spells,") & @CRLF &  GetTranslated(625,112, "OR ELSE BOT WILL NEVER ATTACK!!") & @CRLF
$bErrorCondition = True
Else
Return
EndIf
If $bHaveBeenWarned = True And $bErrorCondition = True Then
SetError(1)
Return
ElseIf $bErrorCondition = False Then
Return
EndIf
Local $iCount = 0
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xE00000, 0xFFFF00, 12, "Comic Sans MS", 480)
$sText = $sErrorText & @CRLF & GetTranslated(625,113,"Click YES to close this warning message") & @CRLF
$MsgBox1 = _ExtMsgBox(48, GetTranslated(625,114,"YES, I Understand Warning|No"), GetTranslated(625,115,"Wait for Spells Warning!"), $sText, 30, $frmBot)
Switch $MsgBox1
Case 1
$bHaveBeenWarned = True
ExitLoop
Case Else
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xFFFF00 , 0xE00000, 12, "Comic Sans MS", 480)
$stext = GetTranslated(625,116,"Sorry, must understand warning and click Yes!") & @CRLF
$MsgBox2 = _ExtMsgBox(16, GetTranslated(625,117,"OK"), GetTranslated(625,118,"User Input Error"), $stext, 15, $frmBot)
If $iCount = 1 And $MsgBox1 = 9 And $MsgBox2 = 9 Then ExitLoop
EndSwitch
$iCount += 1
If $iCount > 2 Then
$sText = GetTranslated(625,119,"CONGRATULATIONS!!") & @CRLF & GetTranslated(625,120,"You found the secret message in Bot!") & @CRLF &  GetTranslated(625,121,"Can you find the randomly selected button to close this message?") & @CRLF &  GetTranslated(625,122, "HaHaHaHa...") & @CRLF & @CRLF & @CRLF
$sFunnyText = $sText
$iCount = 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 480)
While 1
$MsgBox3 = _ExtMsgBox(128, "1|2|3|4|5|6|7", GetTranslated(625,123,"You are a WINNER!!"), $sFunnyText, 900, $frmBot)
If @error Then Setlog("_ExtMsgBox error: " & @error, $COLOR_RED)
If $iCount > 7 And Int($MsgBox3) = Random(1,8,1) Then
ExitLoop
Else
If $iCount <= 7 Then
$iControl = $iCount
Else
$iControl = $MsgBox3
EndIf
Switch $iControl
Case 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x61FF00, 0x020028, 12, "Arial", 480)
$sFunnyText = $sText & GetTranslated(625,124,"Sorry not that button!") & @CRLF
Case 2
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xDC00FF, 0x011E00, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslated(625,125,"Donate Â£5000 to MyBot.run while you wait 15 minutes for this to time out?") & @CRLF
Case 3
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x000000, 0xFFFFFF, 12, "Tahoma", 480)
$sFunnyText = $sText & GetTranslated(625,126,"Having trouble finding the exit button?") & @CRLF
Case 4
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x4800FF, 0xD800FF, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslated(625,127,"This is fun, can we keep going all day?") & @CRLF
Case 5
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Times New Roman", 480)
$sFunnyText = $sText & GetTranslated(625,128,"Try four more times, you have to get lucky sooner or later!") & @CRLF
Case 6
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x00FFED, 0x010051, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslated(625,129,"Do you have a Banana? This code monkey is Hungry!") & @CRLF
Case 7
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0xFF6600, 0x013000, 12, "Lucida Console", 480)
$sFunnyText = $sText & GetTranslated(625,130,"Maybe try hitting same button till you and Mr. Random pick same?") & @CRLF
Case 0
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x000000, 0xFFFFFF, 12, "Tahoma", 480)
$sFunnyText = $sText & GetTranslated(625,131,"Sorry, can not 'escape' from this!") & @CRLF
Case Else
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 480)
$sFunnyText = $sText & GetTranslated(625,132,"Program error! Programmers can ruin a good joke.") & @CRLF
ExitLoop 2
EndSwitch
$iCount += 1
EndIf
WEnd
EndIf
WEnd
If $bErrorCondition = True Then
SetError(1)
Return
EndIf
EndFunc
Func DisableSX()
GUICtrlSetState($chkEnableSuperXP, $GUI_UNCHECKED)
$ichkEnableSuperXP = 0
For $i = $grpSuperXP To $lblXPSXWonHour
GUICtrlSetState($i, $GUI_DISABLE)
Next
GUICtrlSetState($lblLOCKEDSX, BitOR($GUI_SHOW, $GUI_ENABLE))
EndFunc
Func SXSetXP($toSet = "")
If $toSet = "S" Or $toSet = "" Then GUICtrlSetData($lblXPatStart, $iStartXP)
If $toSet = "C" Or $toSet = "" Then GUICtrlSetData($lblXPCurrent, $iCurrentXP)
If $toSet = "W" Or $toSet = "" Then GUICtrlSetData($lblXPSXWon, $iGainedXP)
$iGainedXPHour = Round($iGainedXP / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600 * 1000)
If $toSet = "H" Or $toSet = "" Then GUICtrlSetData($lblXPSXWonHour, _NumberFormat($iGainedXPHour))
EndFunc
Func chkEnableSuperXP()
If GUICtrlRead($chkEnableSuperXP) = $GUI_CHECKED Then
GUICtrlSetState($rbSXTraining, $GUI_ENABLE)
GUICtrlSetState($rbSXIAttacking, $GUI_ENABLE)
GUICtrlSetState($chkSXBK, $GUI_ENABLE)
GUICtrlSetState($chkSXAQ, $GUI_ENABLE)
GUICtrlSetState($chkSXGW, $GUI_ENABLE)
Else
GUICtrlSetState($rbSXTraining, $GUI_DISABLE)
GUICtrlSetState($rbSXIAttacking, $GUI_DISABLE)
GUICtrlSetState($chkSXBK, $GUI_DISABLE)
GUICtrlSetState($chkSXAQ, $GUI_DISABLE)
GUICtrlSetState($chkSXGW, $GUI_DISABLE)
EndIf
EndFunc
Func chkDBWaitForCCSpell()
If GUICtrlRead($chkDBWaitForCastleSpell) = $GUI_CHECKED Then
GUICtrlSetState($cmbDBWaitForCastleSpell, $GUI_ENABLE)
Else
GUICtrlSetState($cmbDBWaitForCastleSpell, $GUI_DISABLE)
EndIf
EndFunc
Func chkABWaitForCCSpell()
If GUICtrlRead($chkABWaitForCastleSpell) = $GUI_CHECKED Then
GUICtrlSetState($cmbABWaitForCastleSpell, $GUI_ENABLE)
Else
GUICtrlSetState($cmbABWaitForCastleSpell, $GUI_DISABLE)
EndIf
EndFunc
Func chkBalanceDR()
If GUICtrlRead($chkUseCCBalanced) = $GUI_CHECKED Then
GUICtrlSetState($cmbCCDonated, $GUI_ENABLE)
GUICtrlSetState($cmbCCReceived, $GUI_ENABLE)
Else
GUICtrlSetState($cmbCCDonated, $GUI_DISABLE)
GUICtrlSetState($cmbCCReceived, $GUI_DISABLE)
EndIf
EndFunc
Func cmbBalanceDR()
If _GUICtrlComboBox_GetCurSel($cmbCCDonated) = _GUICtrlComboBox_GetCurSel($cmbCCReceived) Then
_GUICtrlComboBox_SetCurSel($cmbCCDonated, 0)
_GUICtrlComboBox_SetCurSel($cmbCCReceived, 0)
EndIf
EndFunc
Func btnMilkingOptions()
EndFunc
Func btnDBAttackConfigure()
Switch _GUICtrlComboBox_GetCurSel($cmbDBAlgorithm)
Case 0
Case 1
Case 2
EndSwitch
EndFunc
Func btnABAttackConfigure()
Switch _GUICtrlComboBox_GetCurSel($cmbABAlgorithm)
Case 0
Case 1
EndSwitch
EndFunc
Func cmbDBAlgorithm()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($cmbDBAlgorithm)
If $iCmbValue = 1 Or $iCmbValue = 2 Then
_GUI_Value_STATE("SHOW", $groupAttackDBSpell & "#" & $groupIMGAttackDBSpell)
Else
_GUI_Value_STATE("HIDE", $groupAttackDBSpell & "#" & $groupIMGAttackDBSpell)
EndIf
Select
Case $iCmbValue = 0
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_MILKING)
Case $iCmbValue = 1
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_MILKING)
Case $iCmbValue = 2
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_DEADBASE_ATTACK_MILKING)
Case Else
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_MILKING)
EndSelect
EndFunc
Func cmbABAlgorithm()
Local $iCmbValue = _GUICtrlComboBox_GetCurSel($cmbABAlgorithm)
If $iCmbValue = 1 Then
_GUI_Value_STATE("SHOW", $groupAttackABSpell & "#" & $groupIMGAttackABSpell)
Else
_GUI_Value_STATE("HIDE", $groupAttackABSpell & "#" & $groupIMGAttackABSpell)
EndIf
Select
Case $iCmbValue = 0
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
Case $iCmbValue = 1
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
Case Else
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
EndSelect
EndFunc
Func chkAttackNow()
If GUICtrlRead($chkAttackNow) = $GUI_CHECKED Then
$iChkAttackNow = 1
GUICtrlSetState($lblAttackNow, $GUI_ENABLE)
GUICtrlSetState($lblAttackNowSec, $GUI_ENABLE)
GUICtrlSetState($cmbAttackNowDelay, $GUI_ENABLE)
GUICtrlSetState($cmbAttackNowDelay, $GUI_ENABLE)
Else
$iChkAttackNow = 0
GUICtrlSetState($lblAttackNow, $GUI_DISABLE)
GUICtrlSetState($lblAttackNowSec, $GUI_DISABLE)
GUICtrlSetState($cmbAttackNowDelay, $GUI_DISABLE)
EndIf
EndFunc
Func LoadThSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($dirTHSnipesAttacks & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($cmbAttackTHType)
GUICtrlSetData($cmbAttackTHType, $output)
_GUICtrlComboBox_SetCurSel($cmbAttackTHType, _GUICtrlComboBox_FindStringExact($cmbAttackTHType, $scmbAttackTHType))
EndFunc
Func LoadDBSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($dirTHSnipesAttacks & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($cmbTHSnipeBeforeDBScript)
GUICtrlSetData($cmbTHSnipeBeforeDBScript, $output)
_GUICtrlComboBox_SetCurSel($cmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($cmbTHSnipeBeforeDBScript, $THSnipeBeforeDBTiles))
EndFunc
Func LoadABSnipeAttacks()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($dirTHSnipesAttacks & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($cmbTHSnipeBeforeLBScript)
GUICtrlSetData($cmbTHSnipeBeforeLBScript, $output)
_GUICtrlComboBox_SetCurSel($cmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($cmbTHSnipeBeforeLBScript, $THSnipeBeforeLBscript))
EndFunc
Func cmbAttackTHType()
Local $arrayattack = _GUICtrlComboBox_GetListArray($cmbAttackTHType)
$scmbAttackTHType = $arrayattack[_GUICtrlComboBox_GetCurSel($cmbAttackTHType) + 1]
EndFunc
Func btnTestTHcsv()
AttackTHParseCSV(True)
EndFunc
Func cmbTSGoldElixir()
If _GUICtrlComboBox_GetCurSel($cmbTSMeetGE) < 2 Then
GUICtrlSetState($txtTSMinGold, $GUI_SHOW)
GUICtrlSetState($picTSMinGold, $GUI_SHOW)
GUICtrlSetState($txtTSMinElixir, $GUI_SHOW)
GUICtrlSetState($picTSMinElixir, $GUI_SHOW)
GUICtrlSetState($txtTSMinGoldPlusElixir, $GUI_HIDE)
GUICtrlSetState($picTSMinGPEGold, $GUI_HIDE)
Else
GUICtrlSetState($txtTSMinGold, $GUI_HIDE)
GUICtrlSetState($picTSMinGold, $GUI_HIDE)
GUICtrlSetState($txtTSMinElixir, $GUI_HIDE)
GUICtrlSetState($picTSMinElixir, $GUI_HIDE)
GUICtrlSetState($txtTSMinGoldPlusElixir, $GUI_SHOW)
GUICtrlSetState($picTSMinGPEGold, $GUI_SHOW)
EndIf
EndFunc
Func chkTHSnipeBeforeDBEnable()
If GUICtrlRead($chkTHSnipeBeforeDBEnable) = $GUI_CHECKED Then
GUICtrlSetState($lblTHSnipeBeforeDBTiles, $GUI_ENABLE)
GUICtrlSetState($txtTHSnipeBeforeDBTiles, $GUI_ENABLE)
GUICtrlSetState($cmbTHSnipeBeforeDBScript, $GUI_ENABLE)
Else
GUICtrlSetState($lblTHSnipeBeforeDBTiles, $GUI_DISABLE)
GUICtrlSetState($txtTHSnipeBeforeDBTiles, $GUI_DISABLE)
GUICtrlSetState($cmbTHSnipeBeforeDBScript, $GUI_DISABLE)
EndIf
EndFunc
Func chkTHSnipeBeforeLBEnable()
If GUICtrlRead($chkTHSnipeBeforeLBEnable) = $GUI_CHECKED Then
GUICtrlSetState($lblTHSnipeBeforeLBTiles, $GUI_ENABLE)
GUICtrlSetState($txtTHSnipeBeforeLBTiles, $GUI_ENABLE)
GUICtrlSetState($cmbTHSnipeBeforeLBScript, $GUI_ENABLE)
Else
GUICtrlSetState($lblTHSnipeBeforeLBTiles, $GUI_DISABLE)
GUICtrlSetState($txtTHSnipeBeforeLBTiles, $GUI_DISABLE)
GUICtrlSetState($cmbTHSnipeBeforeLBScript, $GUI_DISABLE)
EndIf
EndFunc
Func chkattackHoursE1()
If GUICtrlRead($chkattackHoursE1) = $GUI_CHECKED And IschkattackHoursE1() Then
For $i = $chkattackHours0 To $chkattackHours11
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkattackHours0 To $chkattackHours11
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkattackHoursE1, $GUI_UNCHECKED)
EndFunc
Func IschkattackHoursE1()
For $i = $chkattackHours0 To $chkattackHours11
If GUICtrlRead($i) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkattackHoursE2()
If GUICtrlRead($chkattackHoursE2) = $GUI_CHECKED And IschkattackHoursE2() Then
For $i = $chkattackHours12 To $chkattackHours23
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkattackHours12 To $chkattackHours23
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkattackHoursE2, $GUI_UNCHECKED)
EndFunc
Func IschkattackHoursE2()
For $i = $chkattackHours12 To $chkattackHours23
If GUICtrlRead($i) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkattackWeekDaysE()
If GUICtrlRead($chkattackWeekDaysE) = $GUI_CHECKED And IschkAttackWeekdays() Then
For $i = $chkAttackWeekdays0 To $chkAttackWeekdays6
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkAttackWeekdays0 To $chkAttackWeekdays6
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkattackWeekDaysE, $GUI_UNCHECKED)
EndFunc
Func IschkAttackWeekdays()
For $i = $chkAttackWeekdays0 To $chkAttackWeekdays6
If GUICtrlRead($i) = $GUI_CHECKED Then Return True
Next
Return False
EndFunc
Func chkAttackPlannerEnable()
If GUICtrlRead($chkAttackPlannerEnable) = $GUI_CHECKED Then
$ichkAttackPlannerEnable = 1
If GUICtrlRead($chkAttackPlannerCloseAll) = $GUI_UNCHECKED Then
GUICtrlSetState($chkAttackPlannerCloseAll, $GUI_ENABLE)
GUICtrlSetState($chkAttackPlannerCloseCoC, $GUI_ENABLE)
Else
GUICtrlSetState($chkAttackPlannerCloseAll, $GUI_ENABLE)
GUICtrlSetState($chkAttackPlannerCloseCoC, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
GUICtrlSetState($chkAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($chkAttackPlannerDayLimit, $GUI_ENABLE)
chkAttackPlannerDayLimit()
cmbAttackPlannerRandom()
If GUICtrlRead($chkAttackPlannerRandom) = $GUI_CHECKED Then
GUICtrlSetState($cmbAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($lbAttackPlannerRandom, $GUI_ENABLE)
For $i = $chkAttackWeekdays0 To $chkattackWeekDaysE
GUICtrlSetState($i, $GUI_DISABLE)
Next
For $i = $chkattackHours0 To $chkattackHoursE1
GUICtrlSetState($i, $GUI_DISABLE)
Next
For $i = $chkAttackHours12 To $chkattackHoursE2
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
GUICtrlSetState($cmbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($lbAttackPlannerRandom, $GUI_DISABLE)
For $i = $chkAttackWeekdays0 To $chkattackWeekDaysE
GUICtrlSetState($i, $GUI_ENABLE)
Next
For $i = $chkattackHours0 To $chkattackHoursE1
GUICtrlSetState($i, $GUI_ENABLE)
Next
For $i = $chkAttackHours12 To $chkattackHoursE2
GUICtrlSetState($i, $GUI_ENABLE)
Next
EndIf
Else
$ichkAttackPlannerEnable = 0
GUICtrlSetState($chkAttackPlannerCloseCoC, $GUI_DISABLE)
GUICtrlSetState($chkAttackPlannerCloseAll, $GUI_DISABLE)
GUICtrlSetState($chkAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($cmbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($lbAttackPlannerRandom, $GUI_DISABLE)
GUICtrlSetState($chkAttackPlannerDayLimit, $GUI_DISABLE)
GUICtrlSetState($cmbAttackPlannerDayMin, $GUI_DISABLE)
GUICtrlSetState($cmbAttackPlannerDayMax, $GUI_DISABLE)
For $i = $chkAttackWeekdays0 To $chkattackWeekDaysE
GUICtrlSetState($i, $GUI_DISABLE)
Next
For $i = $chkattackHours0 To $chkattackHoursE1
GUICtrlSetState($i, $GUI_DISABLE)
Next
For $i = $chkAttackHours12 To $chkattackHoursE2
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkAttackPlannerCloseCoC()
If GUICtrlRead($chkAttackPlannerCloseCoC) = $GUI_CHECKED Then
$ichkAttackPlannerCloseCoC = 1
Else
$ichkAttackPlannerCloseCoC = 0
EndIf
EndFunc
Func chkAttackPlannerCloseAll()
If GUICtrlRead($chkAttackPlannerCloseAll) = $GUI_CHECKED Then
$ichkAttackPlannerCloseAll = 1
GUICtrlSetState($chkAttackPlannerCloseCoC, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
Else
$ichkAttackPlannerCloseAll = 0
GUICtrlSetState($chkAttackPlannerCloseCoC, $GUI_ENABLE)
EndIf
EndFunc
Func chkAttackPlannerRandom()
If GUICtrlRead($chkAttackPlannerRandom) = $GUI_CHECKED Then
$ichkAttackPlannerRandom = 1
GUICtrlSetState($cmbAttackPlannerRandom, $GUI_ENABLE)
GUICtrlSetState($lbAttackPlannerRandom, $GUI_ENABLE)
For $i = $chkAttackWeekdays0 To $chkattackWeekDaysE
GUICtrlSetState($i, $GUI_DISABLE)
Next
For $i = $chkattackHours0 To $chkattackHoursE1
GUICtrlSetState($i, $GUI_DISABLE)
Next
For $i = $chkAttackHours12 To $chkattackHoursE2
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
$ichkAttackPlannerRandom = 0
chkAttackPlannerEnable()
EndIf
EndFunc
Func cmbAttackPlannerRandom()
$icmbAttackPlannerRandom = Int(_GUICtrlComboBox_GetCurSel($cmbAttackPlannerRandom))
If $icmbAttackPlannerRandom > 0 Then
GUICtrlSetData($lbAttackPlannerRandom, GetTranslated(603, 37, -1))
Else
GUICtrlSetData($lbAttackPlannerRandom, GetTranslated(603, 38, "hr"))
EndIf
EndFunc
Func chkAttackPlannerDayLimit()
If GUICtrlRead($chkAttackPlannerDayLimit) = $GUI_CHECKED Then
$ichkAttackPlannerDayLimit = 1
GUICtrlSetState($cmbAttackPlannerDayMin, $GUI_ENABLE)
GUICtrlSetState($lbAttackPlannerDayLimit, $GUI_ENABLE)
GUICtrlSetState($cmbAttackPlannerDayMax, $GUI_ENABLE)
Else
$ichkAttackPlannerDayLimit = 0
GUICtrlSetState($cmbAttackPlannerDayMin, $GUI_DISABLE)
GUICtrlSetState($lbAttackPlannerDayLimit, $GUI_DISABLE)
GUICtrlSetState($cmbAttackPlannerDayMax, $GUI_DISABLE)
EndIf
_cmbAttackPlannerDayLimit()
EndFunc
Func cmbAttackPlannerDayMin()
If Int(GUICtrlRead($cmbAttackPlannerDayMax)) < Int(GUICtrlRead($cmbAttackPlannerDayMin)) Then
GUICtrlSetData($cmbAttackPlannerDayMin, GUICtrlRead($cmbAttackPlannerDayMax))
EndIf
$icmbAttackPlannerDayMin = Int(GUICtrlRead($cmbAttackPlannerDayMin))
_cmbAttackPlannerDayLimit()
EndFunc
Func cmbAttackPlannerDayMax()
If Int(GUICtrlRead($cmbAttackPlannerDayMax)) < Int(GUICtrlRead($cmbAttackPlannerDayMin)) Then
GUICtrlSetData($cmbAttackPlannerDayMax, GUICtrlRead($cmbAttackPlannerDayMin))
EndIf
$icmbAttackPlannerDayMax = Int(GUICtrlRead($cmbAttackPlannerDayMax))
_cmbAttackPlannerDayLimit()
EndFunc
Func _cmbAttackPlannerDayLimit()
Switch Int(GUICtrlRead($cmbAttackPlannerDayMin))
Case 0 To 15
GUICtrlSetBkColor($cmbAttackPlannerDayMin, $COLOR_MONEYGREEN)
Case 16 To 20
GUICtrlSetBkColor($cmbAttackPlannerDayMin, $COLOR_YELLOW)
Case 21 To 999
GUICtrlSetBkColor($cmbAttackPlannerDayMin, $COLOR_RED)
EndSwitch
Switch Int(GUICtrlRead($cmbAttackPlannerDayMax))
Case 0 To 15
GUICtrlSetBkColor($cmbAttackPlannerDayMax, $COLOR_MONEYGREEN)
Case 16 To 25
GUICtrlSetBkColor($cmbAttackPlannerDayMax, $COLOR_YELLOW)
Case 26 To 999
GUICtrlSetBkColor($cmbAttackPlannerDayMax, $COLOR_RED)
EndSwitch
EndFunc
Func chkShareAttack()
If GUICtrlRead($chkShareAttack) = $GUI_CHECKED Then
For $i = $lblShareMinGold To $txtShareMessage
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $lblShareMinGold To $txtShareMessage
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkSearchReduction()
If GUICtrlRead($chkSearchReduction) = $GUI_CHECKED Then
_GUICtrlEdit_SetReadOnly($txtSearchReduceCount, False)
_GUICtrlEdit_SetReadOnly($txtSearchReduceGold, False)
_GUICtrlEdit_SetReadOnly($txtSearchReduceElixir, False)
_GUICtrlEdit_SetReadOnly($txtSearchReduceGoldPlusElixir, False)
_GUICtrlEdit_SetReadOnly($txtSearchReduceDark, False)
_GUICtrlEdit_SetReadOnly($txtSearchReduceTrophy, False)
Else
_GUICtrlEdit_SetReadOnly($txtSearchReduceCount, True)
_GUICtrlEdit_SetReadOnly($txtSearchReduceGold, True)
_GUICtrlEdit_SetReadOnly($txtSearchReduceGoldPlusElixir, True)
_GUICtrlEdit_SetReadOnly($txtSearchReduceElixir, True)
_GUICtrlEdit_SetReadOnly($txtSearchReduceDark, True)
_GUICtrlEdit_SetReadOnly($txtSearchReduceTrophy, True)
EndIf
EndFunc
Func sldMaxVSDelay()
$iMaxVSDelay = GUICtrlRead($sldMaxVSDelay)
GUICtrlSetData($lblMaxVSDelay, $iMaxVSDelay)
If $iMaxVSDelay < $iVSDelay Then
GUICtrlSetData($lblVSDelay, $iMaxVSDelay)
GUICtrlSetData($sldVSDelay, $iMaxVSDelay)
$iVSDelay = $iMaxVSDelay
EndIf
If $iVSDelay = 1 Then
GUICtrlSetData($lbltxtVSDelay, GetTranslated(603, 7, "second"))
Else
GUICtrlSetData($lbltxtVSDelay, GetTranslated(603, 8, "seconds"))
EndIf
If $iMaxVSDelay = 1 Then
GUICtrlSetData($lbltxtMaxVSDelay, GetTranslated(603, 7, "second"))
Else
GUICtrlSetData($lbltxtMaxVSDelay, GetTranslated(603, 8, "seconds"))
EndIf
EndFunc
Func sldVSDelay()
$iVSDelay = GUICtrlRead($sldVSDelay)
GUICtrlSetData($lblVSDelay, $iVSDelay)
If $iVSDelay > $iMaxVSDelay Then
GUICtrlSetData($lblMaxVSDelay, $iVSDelay)
GUICtrlSetData($sldMaxVSDelay, $iVSDelay)
$iMaxVSDelay = $iVSDelay
EndIf
If $iVSDelay = 1 Then
GUICtrlSetData($lbltxtVSDelay, GetTranslated(603, 7, "second"))
Else
GUICtrlSetData($lbltxtVSDelay, GetTranslated(603, 8, "seconds"))
EndIf
If $iMaxVSDelay = 1 Then
GUICtrlSetData($lbltxtMaxVSDelay, GetTranslated(603, 7, "second"))
Else
GUICtrlSetData($lbltxtMaxVSDelay, GetTranslated(603, 8, "seconds"))
EndIf
EndFunc
Func chkDBTimeStopAtk()
If GUICtrlRead($chkDBTimeStopAtk) = $GUI_CHECKED Then
$ichkTimeStopAtk[$DB] = 1
GUICtrlSetState($txtDBTimeStopAtk, $GUI_ENABLE)
GUICtrlSetState($lblDBTimeStopAtk, $GUI_ENABLE)
Else
$ichkTimeStopAtk[$DB] = 0
GUICtrlSetState($txtDBTimeStopAtk, $GUI_DISABLE)
GUICtrlSetState($lblDBTimeStopAtk, $GUI_DISABLE)
EndIf
EndFunc
Func chkDBTimeStopAtk2()
If GUICtrlRead($chkDBTimeStopAtk2) = $GUI_CHECKED Then
$ichkTimeStopAtk2[$DB] = 1
GUICtrlSetState($txtDBTimeStopAtk2, $GUI_ENABLE)
GUICtrlSetState($lblDBTimeStopAtk2, $GUI_ENABLE)
GUICtrlSetState($txtDBMinGoldStopAtk2, $GUI_ENABLE)
GUICtrlSetState($txtDBMinElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($txtDBMinDarkElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($lblDBMinRerourcesAtk2, $GUI_ENABLE)
Else
$ichkTimeStopAtk2[$DB] = 0
GUICtrlSetState($txtDBTimeStopAtk2, $GUI_DISABLE)
GUICtrlSetState($lblDBTimeStopAtk2, $GUI_DISABLE)
GUICtrlSetState($txtDBMinGoldStopAtk2, $GUI_DISABLE)
GUICtrlSetState($txtDBMinElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($txtDBMinDarkElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($lblDBMinRerourcesAtk2, $GUI_DISABLE)
EndIf
EndFunc
Func chkABTimeStopAtk()
If GUICtrlRead($chkABTimeStopAtk) = $GUI_CHECKED Then
$ichkTimeStopAtk[$LB] = 1
GUICtrlSetState($txtABTimeStopAtk, $GUI_ENABLE)
GUICtrlSetState($lblABTimeStopAtk, $GUI_ENABLE)
Else
$ichkTimeStopAtk[$LB] = 0
GUICtrlSetState($txtABTimeStopAtk, $GUI_DISABLE)
GUICtrlSetState($lblABTimeStopAtk, $GUI_DISABLE)
EndIf
EndFunc
Func chkABTimeStopAtk2()
If GUICtrlRead($chkABTimeStopAtk2) = $GUI_CHECKED Then
$ichkTimeStopAtk2[$LB] = 1
GUICtrlSetState($txtABTimeStopAtk2, $GUI_ENABLE)
GUICtrlSetState($lblABTimeStopAtk2, $GUI_ENABLE)
GUICtrlSetState($txtABMinGoldStopAtk2, $GUI_ENABLE)
GUICtrlSetState($txtABMinElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($txtABMinDarkElixirStopAtk2, $GUI_ENABLE)
GUICtrlSetState($lblABMinRerourcesAtk2, $GUI_ENABLE)
Else
$ichkTimeStopAtk2[$LB] = 0
GUICtrlSetState($txtABTimeStopAtk2, $GUI_DISABLE)
GUICtrlSetState($lblABTimeStopAtk2, $GUI_DISABLE)
GUICtrlSetState($txtABMinGoldStopAtk2, $GUI_DISABLE)
GUICtrlSetState($txtABMinElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($txtABMinDarkElixirStopAtk2, $GUI_DISABLE)
GUICtrlSetState($lblABMinRerourcesAtk2, $GUI_DISABLE)
EndIf
EndFunc
Func chkDESideEB()
If GUICtrlRead($chkDESideEB) = $GUI_CHECKED Then
For $i = $txtDELowEndMin To $lblDEEndAq
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $txtDELowEndMin To $lblDEEndAq
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkTSMeetDE()
If GUICtrlRead($chkTSMeetDE) = $GUI_CHECKED Then
_GUICtrlEdit_SetReadOnly($txtTSMinDarkElixir, False)
Else
_GUICtrlEdit_SetReadOnly($txtTSMinDarkElixir, True)
EndIf
EndFunc
Func btnConfigureReplayShare()
EndFunc
Func chkTakeLootSS()
If GUICtrlRead($chkTakeLootSS) = $GUI_CHECKED Then
GUICtrlSetState($chkScreenshotLootInfo, $GUI_ENABLE)
Else
GUICtrlSetState($chkScreenshotLootInfo, $GUI_DISABLE)
EndIf
EndFunc
Func chkTSActivateCamps2()
If GUICtrlRead($chkTSActivateCamps2) = $GUI_CHECKED Then
GUICtrlSetState($lblTSArmyCamps2, $GUI_ENABLE)
GUICtrlSetState($txtTSArmyCamps2, $GUI_ENABLE)
Else
GUICtrlSetState($lblTSArmyCamps2, $GUI_DISABLE)
GUICtrlSetState($txtTSArmyCamps2, $GUI_DISABLE)
EndIf
EndFunc
Func btnLoots()
Run("Explorer.exe " & $sProfilePath & "\" & $sCurrProfile & "\Loots")
EndFunc
Func btnLogs()
Run("Explorer.exe " & $sProfilePath & "\" & $sCurrProfile & "\Logs")
EndFunc
Func btnResetStats()
ResetStats()
EndFunc
Func ResetDonateStats()
For $i = 0 To UBound($TroopName) - 1
$type = Eval("e" & $TroopName[$i])
Assign("Donated" & $type & "ViPER", 0, 4)
GUICtrlSetData(Eval("lblDonated" & $type), 0)
Next
For $i = 0 To UBound($TroopDarkName) - 1
$type = Eval("e" & $TroopDarkName[$i])
Assign("Donated" & $type & "ViPER", 0, 4)
GUICtrlSetData(Eval("lblDonated" & $type), 0)
Next
Assign("Donated" & $ePSpell & "ViPER", 0, 4)
GUICtrlSetData(Eval("lblDonated" & $ePSpell), 0)
Assign("Donated" & $eESpell & "ViPER", 0, 4)
GUICtrlSetData(Eval("lblDonated" & $eESpell), 0)
Assign("Donated" & $eHaSpell & "ViPER", 0, 4)
GUICtrlSetData(Eval("lblDonated" & $eHaSpell), 0)
Assign("Donated" & $eSkSpell & "ViPER", 0, 4)
GUICtrlSetData(Eval("lblDonated" & $eHaSpell), 0)
GUICtrlSetData($lblTotalDonated,"Total Donated: " & 0)
GUICtrlSetData($lblTotalDonatedDark,"Total Donated: " & 0)
GUICtrlSetData($lblTotalDonatedSpell,"Total Donated: " & 0)
EndFunc
Func checkCollectors($log = False, $showLabel = True)
Local $anyCollectorsEnabled = 0
For $i = 6 To 12
If Eval("chkLvl"&$i&"Enabled") = 1 Then
$anyCollectorsEnabled = 1
ExitLoop
EndIf
Next
If $anyCollectorsEnabled = 0 Then
If $showLabel Then GUICtrlSetState($lblCollectorWarning, $GUI_SHOW)
If $log Then
SetLog("Warning: Dead base is enabled, but no collectors are selected!", $COLOR_RED)
SetLog("Dead base will never be found!", $COLOR_RED)
SetLog("Select some in Attack Plan-Search&Attack-DeadBase-Collectors", $COLOR_RED)
Return False
EndIf
ElseIf $anyCollectorsEnabled = 1 Then
If $showLabel Then GUICtrlSetState($lblCollectorWarning, $GUI_HIDE)
Return True
EndIf
Return False
EndFunc
Func chkLvl6()
If GUICtrlRead($chkLvl6) = $GUI_CHECKED Then
$chkLvl6Enabled = 1
GUICtrlSetState($cmbLvl6, $GUI_ENABLE)
Else
$chkLvl6Enabled = 0
GUICtrlSetState($cmbLvl6, $GUI_DISABLE)
EndIf
checkCollectors()
EndFunc
Func chkLvl7()
If GUICtrlRead($chkLvl7) = $GUI_CHECKED Then
$chkLvl7Enabled = 1
GUICtrlSetState($cmbLvl7, $GUI_ENABLE)
Else
$chkLvl7Enabled = 0
GUICtrlSetState($cmbLvl7, $GUI_DISABLE)
EndIf
checkCollectors()
EndFunc
Func chkLvl8()
If GUICtrlRead($chkLvl8) = $GUI_CHECKED Then
$chkLvl8Enabled = 1
GUICtrlSetState($cmbLvl8, $GUI_ENABLE)
Else
$chkLvl8Enabled = 0
GUICtrlSetState($cmbLvl8, $GUI_DISABLE)
EndIf
checkCollectors()
EndFunc
Func chkLvl9()
If GUICtrlRead($chkLvl9) = $GUI_CHECKED Then
$chkLvl9Enabled = 1
GUICtrlSetState($cmbLvl9, $GUI_ENABLE)
Else
$chkLvl9Enabled = 0
GUICtrlSetState($cmbLvl9, $GUI_DISABLE)
EndIf
checkCollectors()
EndFunc
Func chkLvl10()
If GUICtrlRead($chkLvl10) = $GUI_CHECKED Then
$chkLvl10Enabled = 1
GUICtrlSetState($cmbLvl10, $GUI_ENABLE)
Else
$chkLvl10Enabled = 0
GUICtrlSetState($cmbLvl10, $GUI_DISABLE)
EndIf
checkCollectors()
EndFunc
Func chkLvl11()
If GUICtrlRead($chkLvl11) = $GUI_CHECKED Then
$chkLvl11Enabled = 1
GUICtrlSetState($cmbLvl11, $GUI_ENABLE)
Else
$chkLvl11Enabled = 0
GUICtrlSetState($cmbLvl11, $GUI_DISABLE)
EndIf
checkCollectors()
EndFunc
Func chkLvl12()
If GUICtrlRead($chkLvl12) = $GUI_CHECKED Then
$chkLvl12Enabled = 1
GUICtrlSetState($cmbLvl12, $GUI_ENABLE)
Else
$chkLvl12Enabled = 0
GUICtrlSetState($cmbLvl12, $GUI_DISABLE)
EndIf
checkCollectors()
EndFunc
Func cmbLvl6()
$cmbLvl6Fill = _GUICtrlComboBox_GetCurSel($cmbLvl6)
EndFunc
Func cmbLvl7()
$cmbLvl7Fill = _GUICtrlComboBox_GetCurSel($cmbLvl7)
EndFunc
Func cmbLvl8()
$cmbLvl8Fill = _GUICtrlComboBox_GetCurSel($cmbLvl8)
EndFunc
Func cmbLvl9()
$cmbLvl9Fill = _GUICtrlComboBox_GetCurSel($cmbLvl9)
EndFunc
Func cmbLvl10()
$cmbLvl10Fill = _GUICtrlComboBox_GetCurSel($cmbLvl10)
EndFunc
Func cmbLvl11()
$cmbLvl11Fill = _GUICtrlComboBox_GetCurSel($cmbLvl11)
EndFunc
Func cmbLvl12()
$cmbLvl12Fill = _GUICtrlComboBox_GetCurSel($cmbLvl12)
EndFunc
Func sldCollectorTolerance()
$toleranceOffset = GUICtrlRead($sldCollectorTolerance)
EndFunc
Func chkAtkGoldMines()
If GUICtrlRead($chkAtkGoldMines) = $GUI_CHECKED Then
GUICtrlSetState($cmbAtkGoldMinesLevel, $GUI_ENABLE)
Else
GUICtrlSetState($cmbAtkGoldMinesLevel, $GUI_DISABLE)
EndIf
EndFunc
Func chkAtkDarkDrills()
If GUICtrlRead($chkAtkDarkDrills) = $GUI_CHECKED Then
GUICtrlSetState($cmbAtkDarkDrillsLevel, $GUI_ENABLE)
Else
GUICtrlSetState($cmbAtkDarkDrillsLevel, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackMinesifGold()
If GUICtrlRead($chkAttackMinesifGold) = $GUI_CHECKED Then
GUICtrlSetState($txtAttackMinesIfGold, $GUI_ENABLE)
Else
GUICtrlSetState($txtAttackMinesIfGold, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackMinesifelixir()
If GUICtrlRead($chkAttackMinesifElixir) = $GUI_CHECKED Then
GUICtrlSetState($txtAttackMinesIfelixir, $GUI_ENABLE)
Else
GUICtrlSetState($txtAttackMinesIfelixir, $GUI_DISABLE)
EndIf
EndFunc
Func chkAttackMinesifdarkElixir()
If GUICtrlRead($chkAttackMinesifDarkElixir) = $GUI_CHECKED Then
GUICtrlSetState($txtAttackMinesIfdarkElixir, $GUI_ENABLE)
Else
GUICtrlSetState($txtAttackMinesIfdarkElixir, $GUI_DISABLE)
EndIf
EndFunc
Func chkMilkFarmForcetolerance()
If GUICtrlRead($chkMilkFarmForcetolerance) = $GUI_CHECKED Then
GUICtrlSetState($txtMilkFarmForcetolerancenormal, $GUI_ENABLE)
GUICtrlSetState($txtMilkFarmForcetoleranceboosted, $GUI_ENABLE)
GUICtrlSetState($txtMilkFarmForcetolerancedestroyed, $GUI_ENABLE)
Else
GUICtrlSetState($txtMilkFarmForcetolerancenormal, $GUI_DISABLE)
GUICtrlSetState($txtMilkFarmForcetoleranceboosted, $GUI_DISABLE)
GUICtrlSetState($txtMilkFarmForcetolerancedestroyed, $GUI_DISABLE)
EndIf
EndFunc
Func chkMilkAfterAttackTHSnipe()
If GUICtrlRead($chkMilkAfterAttackTHSnipe) = $GUI_CHECKED Then
For $i = $grpSnipeOutsideTHAtEnd To $grpDeploy - 1
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $grpSnipeOutsideTHAtEnd To $grpDeploy - 1
If $i <> $chkMilkAfterAttackTHSnipe Then GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func PopulateComboMilkingCSVScriptsFiles()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($dirAttacksCSV & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($cmbMilkingCSVScriptName)
GUICtrlSetData($cmbMilkingCSVScriptName, $output)
_GUICtrlComboBox_SetCurSel($cmbMilkingCSVScriptName, _GUICtrlComboBox_FindStringExact($cmbMilkingCSVScriptName, ""))
GUICtrlSetData($lblMilkingCSVNotesScript, "")
EndFunc
Func PopulateCmbMilkSnipeAlgorithm()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($dirTHSnipesAttacks & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($cmbMilkSnipeAlgorithm)
GUICtrlSetData($cmbMilkSnipeAlgorithm, $output)
EndFunc
Func chkRandomSpeedAtkAB()
If GUICtrlRead($chkRandomSpeedAtkAB) = $GUI_CHECKED Then
GUICtrlSetState($cmbUnitDelayAB, $GUI_DISABLE)
GUICtrlSetState($cmbWaveDelayAB, $GUI_DISABLE)
Else
GUICtrlSetState($cmbUnitDelayAB, $GUI_ENABLE)
GUICtrlSetState($cmbWaveDelayAB, $GUI_ENABLE)
EndIf
EndFunc
Func chkSmartAttackRedAreaAB()
If GUICtrlRead($chkSmartAttackRedAreaAB) = $GUI_CHECKED Then
$iChkRedArea[$LB] = 1
For $i = $lblSmartDeployAB To $picAttackNearDarkElixirDrillAB
GUICtrlSetState($i, $GUI_SHOW)
Next
Else
$iChkRedArea[$LB] = 0
For $i = $lblSmartDeployAB To $picAttackNearDarkElixirDrillAB
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
EndFunc
Func chkRandomSpeedAtkDB()
If GUICtrlRead($chkRandomSpeedAtkDB) = $GUI_CHECKED Then
GUICtrlSetState($cmbUnitDelayDB, $GUI_DISABLE)
GUICtrlSetState($cmbWaveDelayDB, $GUI_DISABLE)
Else
GUICtrlSetState($cmbUnitDelayDB, $GUI_ENABLE)
GUICtrlSetState($cmbWaveDelayDB, $GUI_ENABLE)
EndIf
EndFunc
Func chkSmartAttackRedAreaDB()
If GUICtrlRead($chkSmartAttackRedAreaDB) = $GUI_CHECKED Then
$iChkRedArea[$DB] = 1
For $i = $lblSmartDeployDB To $picAttackNearDarkElixirDrillDB
GUICtrlSetState($i, $GUI_SHOW)
Next
Else
$iChkRedArea[$DB] = 0
For $i = $lblSmartDeployDB To $picAttackNearDarkElixirDrillDB
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
EndFunc
Func PopulateComboScriptsFilesDB()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($dirAttacksCSV & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($cmbScriptNameDB)
GUICtrlSetData($cmbScriptNameDB, $output)
_GUICtrlComboBox_SetCurSel($cmbScriptNameDB, _GUICtrlComboBox_FindStringExact($cmbScriptNameDB, ""))
GUICtrlSetData($lblNotesScriptDB, "")
EndFunc
Func PopulateComboScriptsFilesAB()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($dirAttacksCSV & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($cmbScriptNameAB)
GUICtrlSetData($cmbScriptNameAB, $output)
_GUICtrlComboBox_SetCurSel($cmbScriptNameAB, _GUICtrlComboBox_FindStringExact($cmbScriptNameAB, ""))
GUICtrlSetData($lblNotesScriptAB, "")
EndFunc
Func cmbScriptNameDB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($cmbScriptNameDB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($cmbScriptNameDB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
$scmbScriptNameDB = $filename
If FileExists($dirAttacksCSV & "\" & $filename & ".csv") Then
$f = FileOpen($dirAttacksCSV & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$tempvect = StringSplit($line, "|", 2)
If UBound($tempvect) >= 2 Then
If StringStripWS(StringUpper($tempvect[0]), 2) = "NOTE" Then $result &= $tempvect[1] & @CRLF
EndIf
WEnd
FileClose($f)
EndIf
GUICtrlSetData($lblNotesScriptDB, $result)
EndFunc
Func cmbScriptNameAB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($cmbScriptNameAB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($cmbScriptNameAB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
$scmbScriptNameAB = $filename
If FileExists($dirAttacksCSV & "\" & $filename & ".csv") Then
$f = FileOpen($dirAttacksCSV & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$tempvect = StringSplit($line, "|", 2)
If UBound($tempvect) >= 2 Then
If StringStripWS(StringUpper($tempvect[0]), 2) = "NOTE" Then $result &= $tempvect[1] & @CRLF
EndIf
WEnd
FileClose($f)
EndIf
GUICtrlSetData($lblNotesScriptAB, $result)
EndFunc
Func UpdateComboScriptNameDB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($cmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($cmbScriptNameDB, $indexofscript, $scriptname)
PopulateComboScriptsFilesDB()
_GUICtrlComboBox_SetCurSel($cmbScriptNameDB, _GUICtrlComboBox_FindStringExact($cmbScriptNameDB, $scriptname))
cmbScriptNameDB()
EndFunc
Func UpdateComboScriptNameAB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($cmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($cmbScriptNameAB, $indexofscript, $scriptname)
PopulateComboScriptsFilesAB()
_GUICtrlComboBox_SetCurSel($cmbScriptNameAB, _GUICtrlComboBox_FindStringExact($cmbScriptNameAB, $scriptname))
cmbScriptNameAB()
EndFunc
Func EditScriptDB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($cmbScriptNameDB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($cmbScriptNameDB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
If FileExists($dirAttacksCSV & "\" & $filename & ".csv") Then
ShellExecute("notepad.exe", $dirAttacksCSV & "\" & $filename & ".csv")
EndIf
EndFunc
Func EditScriptAB()
Local $tempvect1 = _GUICtrlComboBox_GetListArray($cmbScriptNameAB)
Local $filename = $tempvect1[_GUICtrlComboBox_GetCurSel($cmbScriptNameAB) + 1]
Local $f, $result = ""
Local $tempvect, $line, $t
If FileExists($dirAttacksCSV & "\" & $filename & ".csv") Then
ShellExecute("notepad.exe", $dirAttacksCSV & "\" & $filename & ".csv")
EndIf
EndFunc
Func AttackCSVAssignDefaultScriptName()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($dirAttacksCSV & "\*.csv")
Dim $output = ""
$NewFile = FileFindNextFile($FileSearch)
If @error Then $output = ""
$output = StringLeft($NewFile, StringLen($NewFile) - 4)
FileClose($FileSearch)
_GUICtrlComboBox_SetCurSel($cmbScriptNameDB, _GUICtrlComboBox_FindStringExact($cmbScriptNameDB, $output))
_GUICtrlComboBox_SetCurSel($cmbScriptNameAB, _GUICtrlComboBox_FindStringExact($cmbScriptNameAB, $output))
cmbScriptNameDB()
cmbScriptNameAB()
EndFunc
Local $temp1 = GetTranslated(635,1, "Create New Script File"), $temp2 = GetTranslated(635,2, "New Script Filename")
Local $temp3 = GetTranslated(635,3, "File exists, please input a new name"), $temp4 = GetTranslated(635,4, "An error occurred when creating the file.")
Local $temp1 = 0, $temp2 = 0, $temp3 = 0, $temp4 = 0
Func NewScriptDB()
Local $filenameScript = InputBox(GetTranslated(635,1, -1), GetTranslated(635,2, -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($dirAttacksCSV & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslated(635,3, -1), 30)
Else
Local $hFileOpen = FileOpen($dirAttacksCSV & "\" & $filenameScript & ".csv", $FO_APPEND)
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslated(635,4, -1), 30)
Return False
Else
FileClose($hFileOpen)
$scmbDBScriptName = $filenameScript
UpdateComboScriptNameDB()
UpdateComboScriptNameAB()
EndIf
EndIf
EndIf
EndFunc
Func NewScriptAB()
Local $filenameScript = InputBox(GetTranslated(635,1, -1), GetTranslated(635,2, -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($dirAttacksCSV & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslated(635,3, -1), 30)
Else
Local $hFileOpen = FileOpen($dirAttacksCSV & "\" & $filenameScript & ".csv", $FO_APPEND)
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslated(635,4, -1), 30)
Return False
Else
FileClose($hFileOpen)
$scmbABScriptName = $filenameScript
UpdateComboScriptNameAB()
UpdateComboScriptNameDB()
EndIf
EndIf
EndIf
EndFunc
Local $temp1 = GetTranslated(635,5, "Copy to New Script File"), $temp2 = GetTranslated(635,6, "Copy"), $temp3 = GetTranslated(635,7, "to New Script Filename")
Local $temp1 = 0, $temp2 = 0, $temp3 = 0
Func DuplicateScriptDB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($cmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($cmbScriptNameDB, $indexofscript, $scriptname)
$scmbDBScriptName = $scriptname
Local $filenameScript = InputBox(GetTranslated(635,5, -1), GetTranslated(635,6, -1) & ": <" & $scmbDBScriptName & ">" & @CRLF & GetTranslated(635,7, -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($dirAttacksCSV & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslated(635,3, -1))
Else
Local $hFileOpen = FileCopy($dirAttacksCSV & "\" & $scmbDBScriptName & ".csv", $dirAttacksCSV & "\" & $filenameScript & ".csv")
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslated(635,4, -1))
Return False
Else
FileClose($hFileOpen)
$scmbDBScriptName = $filenameScript
UpdateComboScriptNameDB()
UpdateComboScriptNameAB()
EndIf
EndIf
EndIf
EndFunc
Func DuplicateScriptAB()
Local $indexofscript = _GUICtrlComboBox_GetCurSel($cmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($cmbScriptNameAB, $indexofscript, $scriptname)
$scmbABScriptName = $scriptname
Local $filenameScript = InputBox(GetTranslated(635,5, -1), GetTranslated(635,6, -1) & ": <" & $scmbABScriptName & ">" & @CRLF & GetTranslated(635,7, -1) & ":")
If StringLen($filenameScript) > 0 Then
If FileExists($dirAttacksCSV & "\" & $filenameScript & ".csv") Then
MsgBox("", "", GetTranslated(635,3, -1))
Else
Local $hFileOpen = FileCopy($dirAttacksCSV & "\" & $scmbABScriptName & ".csv", $dirAttacksCSV & "\" & $filenameScript & ".csv")
If $hFileOpen = -1 Then
MsgBox($MB_SYSTEMMODAL, "", GetTranslated(635,4, -1))
Return False
Else
FileClose($hFileOpen)
$scmbABScriptName = $filenameScript
UpdateComboScriptNameAB()
UpdateComboScriptNameDB()
EndIf
EndIf
EndIf
EndFunc
Func chkUnbreakable()
If GUICtrlRead($chkUnbreakable) = $GUI_CHECKED Then
GUICtrlSetState($txtUnbreakable, $GUI_ENABLE)
GUICtrlSetState($txtUnBrkMinGold, $GUI_ENABLE)
GUICtrlSetState($txtUnBrkMaxGold, $GUI_ENABLE)
GUICtrlSetState($txtUnBrkMinElixir, $GUI_ENABLE)
GUICtrlSetState($txtUnBrkMaxElixir, $GUI_ENABLE)
GUICtrlSetState($txtUnBrkMinDark, $GUI_ENABLE)
GUICtrlSetState($txtUnBrkMaxDark, $GUI_ENABLE)
$iUnbreakableMode = 1
ElseIf GUICtrlRead($chkUnbreakable) = $GUI_UNCHECKED Then
GUICtrlSetState($txtUnbreakable, $GUI_DISABLE)
GUICtrlSetState($txtUnBrkMinGold, $GUI_DISABLE)
GUICtrlSetState($txtUnBrkMaxGold, $GUI_DISABLE)
GUICtrlSetState($txtUnBrkMinElixir, $GUI_DISABLE)
GUICtrlSetState($txtUnBrkMaxElixir, $GUI_DISABLE)
GUICtrlSetState($txtUnBrkMinDark, $GUI_DISABLE)
GUICtrlSetState($txtUnBrkMaxDark, $GUI_DISABLE)
$iUnbreakableMode = 0
EndIf
EndFunc
Func PushBulletRemoteControl()
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyRemoteEnable = 1 Then _RemoteControl()
EndFunc
Func PushBulletDeleteOldPushes()
If $NotifyPBEnabled = 1 And $NotifyDeletePushesOlderThan = 1 Then _DeleteOldPushes()
EndFunc
Func chkPBTGenabled()
If GUICtrlRead($chkNotifyPBEnabled) = $GUI_CHECKED Then
$NotifyPBEnabled = 1
GUICtrlSetState($txbNotifyPBToken, $GUI_ENABLE)
GUICtrlSetState($btnNotifyDeleteMessages, $GUI_ENABLE)
GUICtrlSetState($chkNotifyDeleteAllPBPushes, $GUI_ENABLE)
GUICtrlSetState($chkNotifyDeleteOldPBPushes, $GUI_ENABLE)
GUICtrlSetState($btnNotifyDeleteMessages, $GUI_ENABLE)
If $NotifyDeletePushesOlderThan = 1 Then
GUICtrlSetState($cmbNotifyPushHours, $GUI_ENABLE)
Else
GUICtrlSetState($cmbNotifyPushHours, $GUI_DISABLE)
EndIf
Else
$NotifyPBEnabled = 0
GUICtrlSetState($chkTGenabled, $GUI_ENABLE)
GUICtrlSetState($txbNotifyPBToken, $GUI_DISABLE)
GUICtrlSetState($btnNotifyDeleteMessages, $GUI_DISABLE)
GUICtrlSetState($chkNotifyDeleteAllPBPushes, $GUI_ENABLE)
GUICtrlSetState($chkNotifyDeleteOldPBPushes, $GUI_ENABLE)
GUICtrlSetState($btnNotifyDeleteMessages, $GUI_ENABLE)
GUICtrlSetState($cmbNotifyPushHours, $GUI_DISABLE)
EndIf
If GUICtrlRead($chkTGenabled) = $GUI_CHECKED Then
$NotifyTGEnabled = 1
GUICtrlSetState($txbNotifyTGToken, $GUI_ENABLE)
Else
$NotifyTGEnabled = 0
GUICtrlSetState($txbNotifyTGToken, $GUI_DISABLE)
EndIf
If $NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1 Then
GUICtrlSetState($chkNotifyRemote, $GUI_ENABLE)
GUICtrlSetState($txbNotifyOrigin, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertMatchFound, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertLastRaidIMG, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertUpgradeWall, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertLastRaidTXT, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertOutOfSync, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertTakeBreak, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertVillageStats, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertLastAttack, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertAnotherDevice, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertCampFull, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertBuilderIdle, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertMaintenance, $GUI_ENABLE)
GUICtrlSetState($chkNotifyAlertBAN, $GUI_ENABLE)
GUICtrlSetState($chkNotifyBOTUpdate, $GUI_ENABLE)
Else
GUICtrlSetState($chkNotifyRemote, $GUI_DISABLE)
GUICtrlSetState($txbNotifyOrigin, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertMatchFound, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertLastRaidIMG, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertUpgradeWall, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertLastRaidTXT, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertOutOfSync, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertTakeBreak, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertVillageStats, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertLastAttack, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertAnotherDevice, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertCampFull, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertBuilderIdle, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertMaintenance, $GUI_DISABLE)
GUICtrlSetState($chkNotifyAlertBAN, $GUI_DISABLE)
GUICtrlSetState($chkNotifyBOTUpdate, $GUI_DISABLE)
GUICtrlSetState($cmbNotifyPushHours, $GUI_DISABLE)
GUICtrlSetState($chkNotifyDeleteAllPBPushes, $GUI_DISABLE)
GUICtrlSetState($chkNotifyDeleteOldPBPushes, $GUI_DISABLE)
GUICtrlSetState($btnNotifyDeleteMessages, $GUI_DISABLE)
EndIf
EndFunc
Func chkDeleteOldPBPushes()
If GUICtrlRead($chkNotifyDeleteOldPBPushes) = $GUI_CHECKED Then
$NotifyDeletePushesOlderThan = 1
If $NotifyPBEnabled Then GUICtrlSetState($cmbNotifyPushHours, $GUI_ENABLE)
Else
$NotifyDeletePushesOlderThan = 0
GUICtrlSetState($cmbNotifyPushHours, $GUI_DISABLE)
EndIf
EndFunc
Func btnDeletePBMessages()
$NotifyDeleteAllPushesNow = True
EndFunc
Func _Restart_()
Local $sCmdFile
FileDelete(@TempDir & "restart.bat")
$sCmdFile = 'tasklist /FI "IMAGENAME eq ' & @ScriptFullPath & '" | find /i "' & @ScriptFullPath & '"' & @CRLF  & 'IF ERRORLEVEL 1 GOTO LAUNCHPROGRAM' & @CRLF  & ' :LAUNCHPROGRAM ' & @CRLF  & ' start "" "' & @ScriptFullPath & '" ' & @CRLF  & 'call :deleteSelf&exit /b ' & @CRLF  & ':deleteSelf ' & @CRLF  & 'start /b "" cmd /c del "%~f0"&exit /b'
FileWrite(@TempDir & "restart.bat", $sCmdFile)
IniWrite($config, "general", "Restarted", 1)
Run(@TempDir & "restart.bat", @TempDir, @SW_HIDE)
CloseAndroid()
BotClose()
EndFunc
Func _Restart()
SetDebugLog("Restart " & $sBotTitle)
Local $sCmdLine = ProcessGetCommandLine(@AutoItPID)
If @error <> 0 Then
SetLog("Cannot prepare to restart " & $sBotTitle & ", error code " & @error, $COLOR_RED)
Return SetError(1, 0, 0)
EndIf
IniWrite($config, "general", "Restarted", 1)
If StringRight($sCmdLine, 9) <> " /Restart" Then
$sCmdLine &= " /Restart"
EndIf
Local $pid = Run("cmd.exe /c start """" " & $sCmdLine, $WorkingDir, @SW_HIDE)
If @error = 0 Then
CloseAndroid()
SetLog("Restarting " & $sBotTitle)
_SleepStatus(60 * 1000)
Else
SetLog("Cannot restart " & $sBotTitle, $COLOR_RED)
EndIf
Return SetError(2, 0, 0)
EndFunc
Func chkNotifyHours()
If GUICtrlRead($chkNotifyHours) = $GUI_CHECKED Then
For $i = $lbNotifyHours1 To $lbNotifyHoursPM
GUICtrlSetState($i, $GUI_ENABLE)
Next
GUICtrlSetState($chkNotifyWeekDays, $GUI_ENABLE)
Else
GUICtrlSetState($chkNotifyWeekDays, $GUI_UNCHECKED)
For $i = $lbNotifyHours1 To $lbNotifyHoursPM
GUICtrlSetState($i, $GUI_DISABLE)
Next
GUICtrlSetState($chkNotifyWeekDays, $GUI_UNCHECKED)
GUICtrlSetState($chkNotifyWeekDays, $GUI_DISABLE)
chkNotifyWeekDays()
EndIf
EndFunc
Func chkNotifyhoursE1()
If GUICtrlRead($chkNotifyhoursE1) = $GUI_CHECKED And GUICtrlRead($chkNotifyhours0) = $GUI_CHECKED Then
For $i = $chkNotifyhours0 To $chkNotifyhours11
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkNotifyhours0 To $chkNotifyhours11
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkNotifyhoursE1, $GUI_UNCHECKED)
EndFunc
Func chkNotifyhoursE2()
If GUICtrlRead($chkNotifyhoursE2) = $GUI_CHECKED And GUICtrlRead($chkNotifyhours12) = $GUI_CHECKED Then
For $i = $chkNotifyhours12 To $chkNotifyhours23
GUICtrlSetState($i, $GUI_UNCHECKED)
Next
Else
For $i = $chkNotifyhours12 To $chkNotifyhours23
GUICtrlSetState($i, $GUI_CHECKED)
Next
EndIf
Sleep(300)
GUICtrlSetState($chkNotifyhoursE2, $GUI_UNCHECKED)
EndFunc
Func chkNotifyWeekDays()
If GUICtrlRead($chkNotifyWeekDays) = $GUI_CHECKED Then
For $i = $chkNotifyWeekdays0 To $chkNotifyWeekdays6
GUICtrlSetState($i, $GUI_ENABLE)
Next
For $i = $lbNotifyWeekdays0 To $lbNotifyWeekdays6
GUICtrlSetState($i, $GUI_ENABLE)
Next
Else
For $i = $chkNotifyWeekdays0 To $chkNotifyWeekdays6
GUICtrlSetState($i, $GUI_DISABLE)
Next
For $i = $lbNotifyWeekdays0 To $lbNotifyWeekdays6
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func btnLocateUpgrades()
Local $wasRunState = $RunState
$RunState = True
LocateUpgrades()
$RunState = $wasRunState
EndFunc
Func btnchkbxUpgrade()
For $i = 0 To UBound($aUpgrades, 1) - 1
If GUICtrlRead($chkbxUpgrade[$i]) = $GUI_CHECKED Then
$ichkbxUpgrade[$i] = 1
Else
$ichkbxUpgrade[$i] = 0
EndIf
Next
EndFunc
Func btnchkbxRepeat()
For $i = 0 To UBound($aUpgrades, 1) - 1
If GUICtrlRead($chkUpgrdeRepeat[$i]) = $GUI_CHECKED Then
$ichkUpgrdeRepeat[$i] = 1
Else
$ichkUpgrdeRepeat[$i] = 0
EndIf
Next
EndFunc
Func picUpgradeTypeLocation()
$RunState = True
PureClick(1, 40, 1, 0, "#9999")
Sleep(100)
Zoomout()
For $j = 0 To UBound($aUpgrades, 1) - 1
If @GUI_CtrlId = $picUpgradeType[$j] Then
If isInsideDiamondXY($aUpgrades[$j][0], $aUpgrades[$j][0]) Then
Click($aUpgrades[$j][0], $aUpgrades[$j][1], 1, 0, "#9999")
Sleep(100)
If StringInStr($aUpgrades[$j][4], "collect", $STR_NOCASESENSEBASIC) Or  StringInStr($aUpgrades[$j][4], "mine", $STR_NOCASESENSEBASIC) Or  StringInStr($aUpgrades[$j][4], "drill", $STR_NOCASESENSEBASIC) Then
Click(1, 40, 1, 0, "#0999")
Sleep(100)
Click($aUpgrades[$j][0], $aUpgrades[$j][1], 1, 0, "#9999")
EndIf
EndIf
EndIf
Next
$RunState = False
EndFunc
Func btnResetUpgrade()
For $i = 0 To UBound($aUpgrades, 1) - 1
If GUICtrlRead($chkUpgrdeRepeat[$i]) = $GUI_CHECKED Then ContinueLoop
$aUpgrades[$i][0] = -1
$aUpgrades[$i][1] = -1
$aUpgrades[$i][2] = -1
$aUpgrades[$i][3] = ""
$aUpgrades[$i][4] = ""
$aUpgrades[$i][5] = ""
$aUpgrades[$i][6] = ""
$aUpgrades[$i][7] = ""
GUICtrlSetData($txtUpgradeName[$i], "")
GUICtrlSetData($txtUpgradeLevel[$i], "")
GUICtrlSetData($txtUpgradeValue[$i], "")
GUICtrlSetData($txtUpgradeTime[$i], "")
GUICtrlSetImage($picUpgradeType[$i], $pIconLib, $eIcnBlank)
$ipicUpgradeStatus[$i] = $eIcnTroops
GUICtrlSetImage($picUpgradeStatus[$i], $pIconLib, $ipicUpgradeStatus[$i])
GUICtrlSetState($chkbxUpgrade[$i], $GUI_UNCHECKED)
GUICtrlSetData($txtUpgradeEndTime[$i], "")
GUICtrlSetState($chkUpgrdeRepeat[$i], $GUI_UNCHECKED)
Next
EndFunc
Func chkLab()
If GUICtrlRead($chkLab) = $GUI_CHECKED Then
$ichkLab = 1
GUICtrlSetState($icnLabUpgrade, $GUI_SHOW)
GUICtrlSetState($lblNextUpgrade, $GUI_ENABLE)
GUICtrlSetState($cmbLaboratory, $GUI_ENABLE)
GUICtrlSetImage($icnLabUpgrade, $pIconLib, $aLabTroops[$icmbLaboratory][4])
Else
$ichkLab = 0
GUICtrlSetState($icnLabUpgrade, $GUI_HIDE)
GUICtrlSetState($lblNextUpgrade, $GUI_DISABLE)
GUICtrlSetState($cmbLaboratory, $GUI_DISABLE)
GUICtrlSetImage($icnLabUpgrade, $pIconLib, $aLabTroops[0][4])
EndIf
LabStatusGUIUpdate()
EndFunc
Func LabStatusGUIUpdate()
If _DateIsValid($sLabUpgradeTime) Then
$txtTip = GetTranslated(614, 8, "Visible Red button means that laboratory upgrade in process") & @CRLF &  GetTranslated(614, 9, "This will automatically disappear when near time for upgrade to be completed.") & @CRLF &  GetTranslated(614, 10, "If upgrade has been manually finished with gems before normal end time,") & @CRLF &  GetTranslated(614, 11, "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF &  GetTranslated(614, 12, "Caution - Unnecessary timer reset will force constant checks for lab status") & @CRLF & @CRLF &  GetTranslated(614, 19, "Troop Upgrade started") & ", " &  GetTranslated(614, 20, "Will begin to check completion at:") & " " & $sLabUpgradeTime & @CRLF & " "
_GUICtrlSetTip($btnResetLabUpgradeTime, $txtTip)
GUICtrlSetState($btnResetLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($btnResetLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($btnResetLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($btnResetLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func cmbLab()
$icmbLaboratory = _GUICtrlComboBox_GetCurSel($cmbLaboratory)
GUICtrlSetImage($icnLabUpgrade, $pIconLib, $aLabTroops[$icmbLaboratory][4])
EndFunc
Func ResetLabUpgradeTime()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslated(614, 13, "Are you 100% sure you want to reset lab upgrade timer?") & @CRLF &  GetTranslated(614, 14, "Click OK to reset") & @CRLF & GetTranslated(614, 15, "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(614, 16, "Reset timer") & "|" & GetTranslated(614, 17, "Cancel and Return"), GetTranslated(614, 18, "Reset laboratory upgrade timer?"), $stext, 120, $frmBot)
If $DebugSetlog = 1 Then Setlog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
$sLabUpgradeTime = ""
$txtTip = GetTranslated(614, 8, "Visible Red button means that laboratory upgrade in process") & @CRLF &  GetTranslated(614, 9, "This will automatically disappear when near time for upgrade to be completed.") & @CRLF &  GetTranslated(614, 10, "If upgrade has been manually finished with gems before normal end time,") & @CRLF &  GetTranslated(614, 11, "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF &  GetTranslated(614, 12, "Caution - Unnecessary timer reset will force constant checks for lab status")
_GUICtrlSetTip($btnResetLabUpgradeTime, $txtTip)
EndIf
If _DateIsValid($sLabUpgradeTime) Then
GUICtrlSetState($btnResetLabUpgradeTime, $GUI_SHOW)
GUICtrlSetState($btnResetLabUpgradeTime, $GUI_ENABLE)
Else
GUICtrlSetState($btnResetLabUpgradeTime, $GUI_HIDE)
GUICtrlSetState($btnResetLabUpgradeTime, $GUI_DISABLE)
EndIf
EndFunc
Func chkUpgradeKing()
If $iTownHallLevel > 6 Or $iTownHallLevel = 0 Then
GUICtrlSetState($chkUpgradeKing, $GUI_ENABLE)
If GUICtrlRead($chkUpgradeKing) = $GUI_CHECKED Then
$ichkUpgradeKing = 1
GUICtrlSetState($chkDBKingWait, $GUI_UNCHECKED)
GUICtrlSetState($chkABKingWait, $GUI_UNCHECKED)
GUICtrlSetState($chkDBKingWait, $GUI_DISABLE)
GUICtrlSetState($chkABKingWait, $GUI_DISABLE)
_GUI_Value_STATE("SHOW", $groupKingSleeping)
Else
$ichkUpgradeKing = 0
GUICtrlSetState($chkDBKingWait, $GUI_ENABLE)
GUICtrlSetState($chkABKingWait, $GUI_ENABLE)
_GUI_Value_STATE("HIDE", $groupKingSleeping)
EndIf
If GUICtrlRead($cmbBoostBarbarianKing) > 0 Then
GUICtrlSetState($chkUpgradeKing, $GUI_DISABLE)
GUICtrlSetState($chkUpgradeKing, $GUI_UNCHECKED)
$ichkUpgradeKing = 0
Else
GUICtrlSetState($chkUpgradeKing, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($chkUpgradeKing, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkUpgradeQueen()
If $iTownHallLevel > 8 Or $iTownHallLevel = 0 Then
GUICtrlSetState($chkUpgradeQueen, $GUI_ENABLE)
If GUICtrlRead($chkUpgradeQueen) = $GUI_CHECKED Then
$ichkUpgradeQueen = 1
GUICtrlSetState($chkDBQueenWait, $GUI_UNCHECKED)
GUICtrlSetState($chkABQueenWait, $GUI_UNCHECKED)
GUICtrlSetState($chkDBQueenWait, $GUI_DISABLE)
GUICtrlSetState($chkABQueenWait, $GUI_DISABLE)
_GUI_Value_STATE("SHOW", $groupQueenSleeping)
Else
$ichkUpgradeQueen = 0
GUICtrlSetState($chkDBQueenWait, $GUI_ENABLE)
GUICtrlSetState($chkABQueenWait, $GUI_ENABLE)
_GUI_Value_STATE("HIDE", $groupQueenSleeping)
EndIf
If GUICtrlRead($cmbBoostArcherQueen) > 0 Then
GUICtrlSetState($chkUpgradeQueen, $GUI_DISABLE)
GUICtrlSetState($chkUpgradeQueen, $GUI_UNCHECKED)
$ichkUpgradeQueen = 0
Else
GUICtrlSetState($chkUpgradeQueen, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($chkUpgradeQueen, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkUpgradeWarden()
If $iTownHallLevel > 10 Or $iTownHallLevel = 0 Then
GUICtrlSetState($chkUpgradeWarden, $GUI_ENABLE)
If GUICtrlRead($chkUpgradeWarden) = $GUI_CHECKED Then
$ichkUpgradeWarden = 1
GUICtrlSetState($chkDBWardenWait, $GUI_UNCHECKED)
GUICtrlSetState($chkABWardenWait, $GUI_UNCHECKED)
GUICtrlSetState($chkDBWardenWait, $GUI_DISABLE)
GUICtrlSetState($chkABWardenWait, $GUI_DISABLE)
_GUI_Value_STATE("SHOW", $groupWardenSleeping)
Else
$ichkUpgradeWarden = 0
GUICtrlSetState($chkDBWardenWait, $GUI_ENABLE)
GUICtrlSetState($chkABWardenWait, $GUI_ENABLE)
_GUI_Value_STATE("HIDE", $groupWardenSleeping)
EndIf
If GUICtrlRead($cmbBoostWarden) > 0 Then
GUICtrlSetState($chkUpgradeWarden, $GUI_DISABLE)
GUICtrlSetState($chkUpgradeWarden, $GUI_UNCHECKED)
$ichkUpgradeWarden = 0
Else
GUICtrlSetState($chkUpgradeWarden, $GUI_ENABLE)
EndIf
Else
GUICtrlSetState($chkUpgradeWarden, BitOR($GUI_DISABLE, $GUI_UNCHECKED))
EndIf
EndFunc
Func chkWalls()
If GUICtrlRead($chkWalls) = $GUI_CHECKED Then
$ichkWalls = 1
GUICtrlSetState($UseGold, $GUI_ENABLE)
GUICtrlSetState($sldMaxNbWall, $GUI_ENABLE)
GUICtrlSetState($cmbWalls, $GUI_ENABLE)
GUICtrlSetState($txtWallMinGold, $GUI_ENABLE)
GUICtrlSetState($chkUpgradeContinually, $GUI_ENABLE)
cmbWalls()
Else
$ichkWalls = 0
GUICtrlSetState($UseGold, $GUI_DISABLE)
GUICtrlSetState($UseElixir, $GUI_DISABLE)
GUICtrlSetState($UseElixirGold, $GUI_DISABLE)
GUICtrlSetState($cmbWalls, $GUI_DISABLE)
GUICtrlSetState($txtWallMinGold, $GUI_DISABLE)
GUICtrlSetState($txtWallMinElixir, $GUI_DISABLE)
GUICtrlSetState($sldMaxNbWall, $GUI_DISABLE)
GUICtrlSetState($chkUpgradeContinually, $GUI_DISABLE)
EndIf
EndFunc
Func chkSaveWallBldr()
If GUICtrlRead($chkSaveWallBldr) = $GUI_CHECKED Then
$iSaveWallBldr = 1
Else
$iSaveWallBldr = 0
EndIf
EndFunc
Func chkUpgradeContinually()
If GUICtrlRead($chkUpgradeContinually) = $GUI_CHECKED Then
$ichkUpgradeContinually = 1
Else
$ichkUpgradeContinually = 0
EndIf
EndFunc
Func cmbWalls()
$icmbWalls = _GUICtrlComboBox_GetCurSel($cmbWalls)
$WallCost = $WallCosts[_GUICtrlComboBox_GetCurSel($cmbWalls)]
GUICtrlSetData($lblWallCost, _NumberFormat($WallCost))
_GUI_Value_STATE("HIDE", $txtWall04ST & "#" & $txtWall05ST & "#" & $txtWall06ST & "#" & $txtWall07ST & "#" & $txtWall08ST & "#" & $txtWall09ST & "#" & $txtWall10ST & "#" & $txtWall11ST)
_GUI_Value_STATE("HIDE", $Wall04ST & "#" & $Wall05ST & "#" & $Wall06ST & "#" & $Wall07ST & "#" & $Wall08ST & "#" & $Wall09ST & "#" & $Wall10ST & "#" & $Wall11ST)
Switch $icmbWalls
Case 0
_GUI_Value_STATE("SHOW", $txtWall04ST & "#" & $Wall04ST & "#" & $txtWall05ST & "#" & $Wall05ST)
$WallCost = 30000
GUICtrlSetData($lblWallCost, _NumberFormat($WallCost))
GUICtrlSetState($UseGold, $GUI_CHECKED)
GUICtrlSetState($UseElixir, $GUI_DISABLE)
GUICtrlSetState($UseElixirGold, $GUI_DISABLE)
GUICtrlSetState($txtWallMinElixir, $GUI_DISABLE)
Case 1
_GUI_Value_STATE("SHOW", $txtWall04ST & "#" & $Wall04ST & "#" & $txtWall05ST & "#" & $Wall05ST & "#" & $txtWall06ST & "#" & $Wall06ST)
$WallCost = 75000
GUICtrlSetData($lblWallCost, _NumberFormat($WallCost))
GUICtrlSetState($UseGold, $GUI_CHECKED)
GUICtrlSetState($UseElixir, $GUI_DISABLE)
GUICtrlSetState($UseElixirGold, $GUI_DISABLE)
GUICtrlSetState($txtWallMinElixir, $GUI_DISABLE)
Case 2
_GUI_Value_STATE("SHOW", $txtWall04ST & "#" & $Wall04ST & "#" & $txtWall05ST & "#" & $Wall05ST & "#" & $txtWall06ST & "#" & $Wall06ST & "#" & $txtWall07ST & "#" & $Wall07ST)
$WallCost = 200000
GUICtrlSetData($lblWallCost, _NumberFormat($WallCost))
GUICtrlSetState($UseGold, $GUI_CHECKED)
GUICtrlSetState($UseElixir, $GUI_DISABLE)
GUICtrlSetState($UseElixirGold, $GUI_DISABLE)
GUICtrlSetState($txtWallMinElixir, $GUI_DISABLE)
Case 3
_GUI_Value_STATE("SHOW", $txtWall04ST & "#" & $Wall04ST & "#" & $txtWall05ST & "#" & $Wall05ST & "#" & $txtWall06ST & "#" & $Wall06ST & "#" & $txtWall07ST & "#" & $Wall07ST & "#" & $txtWall08ST & "#" & $Wall08ST)
$WallCost = 500000
GUICtrlSetData($lblWallCost, _NumberFormat($WallCost))
GUICtrlSetState($UseGold, $GUI_CHECKED)
GUICtrlSetState($UseElixir, $GUI_DISABLE)
GUICtrlSetState($UseElixirGold, $GUI_DISABLE)
GUICtrlSetState($txtWallMinElixir, $GUI_DISABLE)
Case 4
_GUI_Value_STATE("SHOW", $txtWall04ST & "#" & $Wall04ST & "#" & $txtWall05ST & "#" & $Wall05ST & "#" & $txtWall06ST & "#" & $Wall06ST & "#" & $txtWall07ST & "#" & $Wall07ST & "#" & $txtWall08ST & "#" & $Wall08ST & "#" & $txtWall09ST & "#" & $Wall09ST)
$WallCost = 1000000
GUICtrlSetData($lblWallCost, _NumberFormat($WallCost))
GUICtrlSetState($UseElixir, $GUI_ENABLE)
GUICtrlSetState($UseElixirGold, $GUI_ENABLE)
GUICtrlSetState($txtWallMinElixir, $GUI_ENABLE)
Case 5
_GUI_Value_STATE("SHOW", $txtWall04ST & "#" & $Wall04ST & "#" & $txtWall05ST & "#" & $Wall05ST & "#" & $txtWall06ST & "#" & $Wall06ST & "#" & $txtWall07ST & "#" & $Wall07ST & "#" & $txtWall08ST & "#" & $Wall08ST & "#" & $txtWall09ST & "#" & $Wall09ST & "#" & $txtWall10ST & "#" & $Wall10ST)
$WallCost = 3000000
GUICtrlSetData($lblWallCost, _NumberFormat($WallCost))
GUICtrlSetState($UseElixir, $GUI_ENABLE)
GUICtrlSetState($UseElixirGold, $GUI_ENABLE)
GUICtrlSetState($txtWallMinElixir, $GUI_ENABLE)
Case 6
_GUI_Value_STATE("SHOW", $txtWall04ST & "#" & $Wall04ST & "#" & $txtWall05ST & "#" & $Wall05ST & "#" & $txtWall06ST & "#" & $Wall06ST & "#" & $txtWall07ST & "#" & $Wall07ST & "#" & $txtWall08ST & "#" & $Wall08ST & "#" & $txtWall09ST & "#" & $Wall09ST & "#" & $txtWall10ST & "#" & $Wall10ST & "#" & $txtWall11ST & "#" & $Wall11ST)
$WallCost = 4000000
GUICtrlSetData($lblWallCost, _NumberFormat($WallCost))
GUICtrlSetState($UseElixir, $GUI_ENABLE)
GUICtrlSetState($UseElixirGold, $GUI_ENABLE)
GUICtrlSetState($txtWallMinElixir, $GUI_ENABLE)
EndSwitch
EndFunc
Func btnWalls()
Local $wasRunState = $RunState
$RunState = True
Zoomout()
$icmbWalls = _GUICtrlComboBox_GetCurSel($cmbWalls)
If CheckWall() Then Setlog("Hei Chef! We found the Wall!")
$RunState = $wasRunState
AndroidShield("btnWalls")
EndFunc
Func btnDonateBarbarians()
If GUICtrlGetState($grpBarbarians) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpBarbarians, $txtBlacklistBarbarians)
EndIf
EndFunc
Func btnDonateArchers()
If GUICtrlGetState($grpArchers) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpArchers, $txtBlacklistArchers)
EndIf
EndFunc
Func btnDonateGiants()
If GUICtrlGetState($grpGiants) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpGiants, $txtBlacklistGiants)
EndIf
EndFunc
Func btnDonateGoblins()
If GUICtrlGetState($grpGoblins) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpGoblins, $txtBlacklistGoblins)
EndIf
EndFunc
Func btnDonateWallBreakers()
If GUICtrlGetState($grpWallBreakers) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpWallBreakers, $txtBlacklistWallBreakers)
EndIf
EndFunc
Func btnDonateBalloons()
If GUICtrlGetState($grpBalloons) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpBalloons, $txtBlacklistBalloons)
EndIf
EndFunc
Func btnDonateWizards()
If GUICtrlGetState($grpWizards) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpWizards, $txtBlacklistWizards)
EndIf
EndFunc
Func btnDonateHealers()
If GUICtrlGetState($grpHealers) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpHealers, $txtBlacklistHealers)
EndIf
EndFunc
Func btnDonateDragons()
If GUICtrlGetState($grpDragons) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpDragons, $txtBlacklistDragons)
EndIf
EndFunc
Func btnDonatePekkas()
If GUICtrlGetState($grpPekkas) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpPekkas, $txtBlacklistPekkas)
EndIf
EndFunc
Func btnDonateBabyDragons()
If GUICtrlGetState($grpBabyDragons) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpBabyDragons, $txtBlacklistBabyDragons)
EndIf
EndFunc
Func btnDonateMiners()
If GUICtrlGetState($grpMiners) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpMiners, $txtBlacklistMiners)
EndIf
EndFunc
Func btnDonateMinions()
If GUICtrlGetState($grpMinions) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpMinions, $txtBlacklistMinions)
EndIf
EndFunc
Func btnDonateHogRiders()
If GUICtrlGetState($grpHogRiders) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpHogRiders, $txtBlacklistHogRiders)
EndIf
EndFunc
Func btnDonateValkyries()
If GUICtrlGetState($grpValkyries) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpValkyries, $txtBlacklistValkyries)
EndIf
EndFunc
Func btnDonateGolems()
If GUICtrlGetState($grpGolems) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpGolems, $txtBlacklistGolems)
EndIf
EndFunc
Func btnDonateWitches()
If GUICtrlGetState($grpWitches) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpWitches, $txtBlacklistWitches)
EndIf
EndFunc
Func btnDonateLavaHounds()
If GUICtrlGetState($grpLavaHounds) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpLavaHounds, $txtBlacklistLavaHounds)
EndIf
EndFunc
Func btnDonateBowlers()
If GUICtrlGetState($grpBowlers) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpBowlers, $txtBlacklistBowlers)
EndIf
EndFunc
Func btnDonatePoisonSpells()
If GUICtrlGetState($grpPoisonSpells) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpPoisonSpells, $txtBlacklistPoisonSpells)
EndIf
EndFunc
Func btnDonateEarthQuakeSpells()
If GUICtrlGetState($grpEarthQuakeSpells) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpEarthQuakeSpells, $txtBlacklistEarthQuakeSpells)
EndIf
EndFunc
Func btnDonateHasteSpells()
If GUICtrlGetState($grpHasteSpells) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpHasteSpells, $txtBlacklistHasteSpells)
EndIf
EndFunc
Func btnDonateSkeletonSpells()
If GUICtrlGetState($grpSkeletonSpells) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpSkeletonSpells, $txtBlacklistSkeletonSpells)
EndIf
EndFunc
Func btnDonateCustomA()
If GUICtrlGetState($grpCustomA) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpCustomA, $txtBlacklistCustomA)
EndIf
EndFunc
Func btnDonateCustomB()
If GUICtrlGetState($grpCustomB) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpCustomB, $txtBlacklistCustomB)
EndIf
EndFunc
Func btnDonateBlacklist()
If GUICtrlGetState($grpBlacklist) = BitOR($GUI_HIDE, $GUI_ENABLE) Then
_DonateBtn($grpBlacklist, $txtBlacklist)
EndIf
EndFunc
Func chkDonateAllBarbarians()
If GUICtrlRead($chkDonateAllBarbarians) = $GUI_CHECKED Then
_DonateAllControls($eBarb, True)
Else
_DonateAllControls($eBarb, False)
EndIf
EndFunc
Func chkDonateAllArchers()
If GUICtrlRead($chkDonateAllArchers) = $GUI_CHECKED Then
_DonateAllControls($eArch, True)
Else
_DonateAllControls($eArch, False)
EndIf
EndFunc
Func chkDonateAllGiants()
If GUICtrlRead($chkDonateAllGiants) = $GUI_CHECKED Then
_DonateAllControls($eGiant, True)
Else
_DonateAllControls($eGiant, False)
EndIf
EndFunc
Func chkDonateAllGoblins()
If GUICtrlRead($chkDonateAllGoblins) = $GUI_CHECKED Then
_DonateAllControls($eGobl, True)
Else
_DonateAllControls($eGobl, False)
EndIf
EndFunc
Func chkDonateAllWallBreakers()
If GUICtrlRead($chkDonateAllWallBreakers) = $GUI_CHECKED Then
_DonateAllControls($eWall, True)
Else
_DonateAllControls($eWall, False)
EndIf
EndFunc
Func chkDonateAllBalloons()
If GUICtrlRead($chkDonateAllBalloons) = $GUI_CHECKED Then
_DonateAllControls($eBall, True)
Else
_DonateAllControls($eBall, False)
EndIf
EndFunc
Func chkDonateAllWizards()
If GUICtrlRead($chkDonateAllWizards) = $GUI_CHECKED Then
_DonateAllControls($eWiza, True)
Else
_DonateAllControls($eWiza, False)
EndIf
EndFunc
Func chkDonateAllHealers()
If GUICtrlRead($chkDonateAllHealers) = $GUI_CHECKED Then
_DonateAllControls($eHeal, True)
Else
_DonateAllControls($eHeal, False)
EndIf
EndFunc
Func chkDonateAllDragons()
If GUICtrlRead($chkDonateAllDragons) = $GUI_CHECKED Then
_DonateAllControls($eDrag, True)
Else
_DonateAllControls($eDrag, False)
EndIf
EndFunc
Func chkDonateAllPekkas()
If GUICtrlRead($chkDonateAllPekkas) = $GUI_CHECKED Then
_DonateAllControls($ePekk, True)
Else
_DonateAllControls($ePekk, False)
EndIf
EndFunc
Func chkDonateAllBabyDragons()
If GUICtrlRead($chkDonateAllBabyDragons) = $GUI_CHECKED Then
_DonateAllControls($eBabyD, True)
Else
_DonateAllControls($eBabyD, False)
EndIf
EndFunc
Func chkDonateAllMiners()
If GUICtrlRead($chkDonateAllMiners) = $GUI_CHECKED Then
_DonateAllControls($eMine, True)
Else
_DonateAllControls($eMine, False)
EndIf
EndFunc
Func chkDonateAllMinions()
If GUICtrlRead($chkDonateAllMinions) = $GUI_CHECKED Then
_DonateAllControls($eMini, True)
Else
_DonateAllControls($eMini, False)
EndIf
EndFunc
Func chkDonateAllHogRiders()
If GUICtrlRead($chkDonateAllHogRiders) = $GUI_CHECKED Then
_DonateAllControls($eHogs, True)
Else
_DonateAllControls($eHogs, False)
EndIf
EndFunc
Func chkDonateAllValkyries()
If GUICtrlRead($chkDonateAllValkyries) = $GUI_CHECKED Then
_DonateAllControls($eValk, True)
Else
_DonateAllControls($eValk, False)
EndIf
EndFunc
Func chkDonateAllGolems()
If GUICtrlRead($chkDonateAllGolems) = $GUI_CHECKED Then
_DonateAllControls($eGole, True)
Else
_DonateAllControls($eGole, False)
EndIf
EndFunc
Func chkDonateAllWitches()
If GUICtrlRead($chkDonateAllWitches) = $GUI_CHECKED Then
_DonateAllControls($eWitc, True)
Else
_DonateAllControls($eWitc, False)
EndIf
EndFunc
Func chkDonateAllLavaHounds()
If GUICtrlRead($chkDonateAllLavaHounds) = $GUI_CHECKED Then
_DonateAllControls($eLava, True)
Else
_DonateAllControls($eLava, False)
EndIf
EndFunc
Func chkDonateAllBowlers()
If GUICtrlRead($chkDonateAllBowlers) = $GUI_CHECKED Then
_DonateAllControls($eBowl, True)
Else
_DonateAllControls($eBowl, False)
EndIf
EndFunc
Func chkDonateAllPoisonSpells()
If GUICtrlRead($chkDonateAllPoisonSpells) = $GUI_CHECKED Then
_DonateAllControlsSpell(0, True)
Else
_DonateAllControlsSpell(0, False)
EndIf
EndFunc
Func chkDonateAllEarthQuakeSpells()
If GUICtrlRead($chkDonateAllEarthQuakeSpells) = $GUI_CHECKED Then
_DonateAllControlsSpell(1, True)
Else
_DonateAllControlsSpell(1, False)
EndIf
EndFunc
Func chkDonateAllHasteSpells()
If GUICtrlRead($chkDonateAllHasteSpells) = $GUI_CHECKED Then
_DonateAllControlsSpell(2, True)
Else
_DonateAllControlsSpell(2, False)
EndIf
EndFunc
Func chkDonateAllSkeletonSpells()
If GUICtrlRead($chkDonateAllSkeletonSpells) = $GUI_CHECKED Then
_DonateAllControlsSpell(3, True)
Else
_DonateAllControlsSpell(3, False)
EndIf
EndFunc
Func chkDonateAllCustomA()
If GUICtrlRead($chkDonateAllCustomA) = $GUI_CHECKED Then
_DonateAllControls(19, True)
Else
_DonateAllControls(19, False)
EndIf
EndFunc
Func chkDonateAllCustomB()
If GUICtrlRead($chkDonateAllCustomB) = $GUI_CHECKED Then
_DonateAllControls(20, True)
Else
_DonateAllControls(20, False)
EndIf
EndFunc
Func chkDonateBarbarians()
If GUICtrlRead($chkDonateBarbarians) = $GUI_CHECKED Then
_DonateControls($eBarb)
Else
GUICtrlSetBkColor($lblBtnBarbarians, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateArchers()
If GUICtrlRead($chkDonateArchers) = $GUI_CHECKED Then
_DonateControls($eArch)
Else
GUICtrlSetBkColor($lblBtnArchers, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateGiants()
If GUICtrlRead($chkDonateGiants) = $GUI_CHECKED Then
_DonateControls($eGiant)
Else
GUICtrlSetBkColor($lblBtnGiants, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateGoblins()
If GUICtrlRead($chkDonateGoblins) = $GUI_CHECKED Then
_DonateControls($eGobl)
Else
GUICtrlSetBkColor($lblBtnGoblins, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateWallBreakers()
If GUICtrlRead($chkDonateWallBreakers) = $GUI_CHECKED Then
_DonateControls($eWall)
Else
GUICtrlSetBkColor($lblBtnWallBreakers, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateBalloons()
If GUICtrlRead($chkDonateBalloons) = $GUI_CHECKED Then
_DonateControls($eBall)
Else
GUICtrlSetBkColor($lblBtnBalloons, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateWizards()
If GUICtrlRead($chkDonateWizards) = $GUI_CHECKED Then
_DonateControls($eWiza)
Else
GUICtrlSetBkColor($lblBtnWizards, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateHealers()
If GUICtrlRead($chkDonateHealers) = $GUI_CHECKED Then
_DonateControls($eHeal)
Else
GUICtrlSetBkColor($lblBtnHealers, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateDragons()
If GUICtrlRead($chkDonateDragons) = $GUI_CHECKED Then
_DonateControls($eDrag)
Else
GUICtrlSetBkColor($lblBtnDragons, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonatePekkas()
If GUICtrlRead($chkDonatePekkas) = $GUI_CHECKED Then
_DonateControls($ePekk)
Else
GUICtrlSetBkColor($lblBtnPekkas, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateBabyDragons()
If GUICtrlRead($chkDonateBabyDragons) = $GUI_CHECKED Then
_DonateControls($eBabyD)
Else
GUICtrlSetBkColor($lblBtnBabyDragons, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateMiners()
If GUICtrlRead($chkDonateMiners) = $GUI_CHECKED Then
_DonateControls($eMine)
Else
GUICtrlSetBkColor($lblBtnMiners, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateMinions()
If GUICtrlRead($chkDonateMinions) = $GUI_CHECKED Then
_DonateControls($eMini)
Else
GUICtrlSetBkColor($lblBtnMinions, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateHogRiders()
If GUICtrlRead($chkDonateHogRiders) = $GUI_CHECKED Then
_DonateControls($eHogs)
Else
GUICtrlSetBkColor($lblBtnHogRiders, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateValkyries()
If GUICtrlRead($chkDonateValkyries) = $GUI_CHECKED Then
_DonateControls($eValk)
Else
GUICtrlSetBkColor($lblBtnValkyries, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateGolems()
If GUICtrlRead($chkDonateGolems) = $GUI_CHECKED Then
_DonateControls($eGole)
Else
GUICtrlSetBkColor($lblBtnGolems, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateWitches()
If GUICtrlRead($chkDonateWitches) = $GUI_CHECKED Then
_DonateControls($eWitc)
Else
GUICtrlSetBkColor($lblBtnWitches, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateLavaHounds()
If GUICtrlRead($chkDonateLavaHounds) = $GUI_CHECKED Then
_DonateControls($eLava)
Else
GUICtrlSetBkColor($lblBtnLavaHounds, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateBowlers()
If GUICtrlRead($chkDonateBowlers) = $GUI_CHECKED Then
_DonateControls($eBowl)
Else
GUICtrlSetBkColor($lblBtnBowlers, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonatePoisonSpells()
If GUICtrlRead($chkDonatePoisonSpells) = $GUI_CHECKED Then
_DonateControlsSpell(0)
Else
GUICtrlSetBkColor($lblBtnPoisonSpells, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateEarthQuakeSpells()
If GUICtrlRead($chkDonateEarthQuakeSpells) = $GUI_CHECKED Then
_DonateControlsSpell(1)
Else
GUICtrlSetBkColor($lblBtnEarthQuakeSpells, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateHasteSpells()
If GUICtrlRead($chkDonateHasteSpells) = $GUI_CHECKED Then
_DonateControlsSpell(2)
Else
GUICtrlSetBkColor($lblBtnHasteSpells, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateSkeletonSpells()
If GUICtrlRead($chkDonateSkeletonSpells) = $GUI_CHECKED Then
_DonateControlsSpell(3)
Else
GUICtrlSetBkColor($lblBtnSkeletonSpells, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateCustomA()
If GUICtrlRead($chkDonateCustomA) = $GUI_CHECKED Then
_DonateControls(19)
Else
GUICtrlSetBkColor($lblBtnCustomA, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func chkDonateCustomB()
If GUICtrlRead($chkDonateCustomB) = $GUI_CHECKED Then
_DonateControls(20)
Else
GUICtrlSetBkColor($lblBtnCustomB, $GUI_BKCOLOR_TRANSPARENT)
EndIf
EndFunc
Func cmbDonateCustomA()
Local $aDonIcons[20] = [$eIcnDonBarbarian, $eIcnDonArcher, $eIcnDonGiant, $eIcnDonGoblin, $eIcnDonWallBreaker, $eIcnDonBalloon, $eIcnDonWizard, $eIcnDonHealer, $eIcnDonDragon, $eIcnDonPekka, $eIcnDonBabyDragon, $eIcnDonMiner, $eIcnDonMinion, $eIcnDonHogRider, $eIcnDonValkyrie, $eIcnDonGolem, $eIcnDonWitch, $eIcnDonLavaHound, $eIcnDonBowler, $eIcnDonBlank]
Local $combo1 = _GUICtrlComboBox_GetCurSel($cmbDonateCustomA1)
Local $combo2 = _GUICtrlComboBox_GetCurSel($cmbDonateCustomA2)
Local $combo3 = _GUICtrlComboBox_GetCurSel($cmbDonateCustomA3)
GUICtrlSetImage($picDonateCustomA1, $pIconLib, $aDonIcons[$combo1])
GUICtrlSetImage($picDonateCustomA2, $pIconLib, $aDonIcons[$combo2])
GUICtrlSetImage($picDonateCustomA3, $pIconLib, $aDonIcons[$combo3])
EndFunc
Func cmbDonateCustomB()
Local $aDonIcons[20] = [$eIcnDonBarbarian, $eIcnDonArcher, $eIcnDonGiant, $eIcnDonGoblin, $eIcnDonWallBreaker, $eIcnDonBalloon, $eIcnDonWizard, $eIcnDonHealer, $eIcnDonDragon, $eIcnDonPekka, $eIcnDonBabyDragon, $eIcnDonMiner, $eIcnDonMinion, $eIcnDonHogRider, $eIcnDonValkyrie, $eIcnDonGolem, $eIcnDonWitch, $eIcnDonLavaHound, $eIcnDonBowler, $eIcnDonBlank]
Local $combo1 = _GUICtrlComboBox_GetCurSel($cmbDonateCustomB1)
Local $combo2 = _GUICtrlComboBox_GetCurSel($cmbDonateCustomB2)
Local $combo3 = _GUICtrlComboBox_GetCurSel($cmbDonateCustomB3)
GUICtrlSetImage($picDonateCustomB1, $pIconLib, $aDonIcons[$combo1])
GUICtrlSetImage($picDonateCustomB2, $pIconLib, $aDonIcons[$combo2])
GUICtrlSetImage($picDonateCustomB3, $pIconLib, $aDonIcons[$combo3])
EndFunc
Func _DonateBtn($FirstControl, $LastControl)
If $LastDonateBtn1 = -1 Then
For $i = $grpBarbarians To $txtBlacklistBarbarians
GUICtrlSetState($i, $GUI_HIDE)
Next
Else
For $i = $LastDonateBtn1 To $LastDonateBtn2
GUICtrlSetState($i, $GUI_HIDE)
Next
EndIf
$LastDonateBtn1 = $FirstControl
$LastDonateBtn2 = $LastControl
For $i = $FirstControl To $LastControl
GUICtrlSetState($i, $GUI_SHOW)
Next
EndFunc
Func _DonateControls($TroopType)
Local $bWasRedraw = SetRedrawBotWindow(False)
For $i = 0 To UBound($aLblBtnControls) - 1
If $i = $TroopType Then
GUICtrlSetBkColor($aLblBtnControls[$i], $COLOR_GREEN)
Else
If GUICtrlGetBkColor($aLblBtnControls[$i]) = $COLOR_NAVY Then GUICtrlSetBkColor($aLblBtnControls[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
Next
For $i = 0 To UBound($aChkDonateAllControls) - 1
GUICtrlSetState($aChkDonateAllControls[$i], $GUI_UNCHECKED)
Next
For $i = 0 To UBound($aTxtDonateControls) - 1
If BitAND(GUICtrlGetState($aTxtDonateControls[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($aTxtDonateControls[$i], $GUI_ENABLE)
Next
For $i = 0 To UBound($aTxtBlacklistControls) - 1
If BitAND(GUICtrlGetState($aTxtBlacklistControls[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($aTxtBlacklistControls[$i], $GUI_ENABLE)
Next
SetRedrawBotWindowControls($bWasRedraw, $hGUI_DONATE_TAB)
EndFunc
Func _DonateControlsSpell($TroopType)
For $i = 0 To UBound($aLblBtnControlsSpell) - 1
If $i = $TroopType Then
GUICtrlSetBkColor($aLblBtnControlsSpell[$i], $COLOR_GREEN)
Else
If GUICtrlGetBkColor($aLblBtnControlsSpell[$i]) = $COLOR_NAVY Then GUICtrlSetBkColor($aLblBtnControlsSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
Next
For $i = 0 To UBound($aChkDonateAllControlsSpell) - 1
GUICtrlSetState($aChkDonateAllControlsSpell[$i], $GUI_UNCHECKED)
Next
For $i = 0 To UBound($aTxtDonateControlsSpell) - 1
If BitAND(GUICtrlGetState($aTxtDonateControlsSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($aTxtDonateControlsSpell[$i], $GUI_ENABLE)
Next
For $i = 0 To UBound($aTxtBlacklistControlsSpell) - 1
If BitAND(GUICtrlGetState($aTxtBlacklistControlsSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($aTxtBlacklistControlsSpell[$i], $GUI_ENABLE)
Next
EndFunc
Func LoadLanguagesComboBox()
Local $hFileSearch = FileFindFirstFile($dirLanguages & "*.ini")
Local $sFilename, $sOutput = "", $sLangDisplayName = "", $iFileIndex = 0
While 1
$sFilename = FileFindNextFile($hFileSearch)
If @error Then ExitLoop
ReDim $aLanguageFile[$iFileIndex + 1][2]
$aLanguageFile[$iFileIndex][0] = StringLeft($sFilename, StringLen($sFilename) - 4)
$sLangDisplayName = IniRead($dirLanguages & $sFilename, "Language", "DisplayName", "Unknown")
$aLanguageFile[$iFileIndex][1] = $sLangDisplayName
If $sLangDisplayName = "Unknown" Then
IniWrite($dirLanguages & $sFilename, "Language", "DisplayName", StringLeft($sFilename, StringLen($sFilename) - 4))
$sLangDisplayName = IniRead($dirLanguages & $sFilename, "Language", "DisplayName", "Unknown")
$aLanguageFile[$iFileIndex][1] = $sLangDisplayName
EndIf
$sOutput = $sOutput & $sLangDisplayName & "|"
$iFileIndex += 1
WEnd
FileClose($hFileSearch)
$sOutput = StringLeft($sOutput, StringLen($sOutput) - 1)
_GUICtrlComboBox_ResetContent($cmbLanguage)
GUICtrlSetData($cmbLanguage, $sOutput)
EndFunc
Func cmbLanguage()
Local $aLanguage = _GUICtrlComboBox_GetListArray($cmbLanguage)
Local $sLanguageIndex = _ArraySearch($aLanguageFile, $aLanguage[_GUICtrlComboBox_GetCurSel($cmbLanguage) + 1])
$sLanguage = $aLanguageFile[$sLanguageIndex][0]
MsgBox("", "", GetTranslated(636, 71, "Restart Bot to load program with new language:") & " " & $aLanguageFile[$sLanguageIndex][1] & " (" & $sLanguage & ")")
EndFunc
Func chkUseRandomClick()
If GUICtrlRead($chkUseRandomClick) = $GUI_CHECKED Then
$iUseRandomClick = 1
Else
$iUseRandomClick = 0
EndIf
EndFunc
Func chkUpdatingWhenMinimized()
$iUpdatingWhenMinimized = (GUICtrlRead($chkUpdatingWhenMinimized) = $GUI_CHECKED ? 1 : 0)
EndFunc
Func chkHideWhenMinimized()
$iHideWhenMinimized = (GUICtrlRead($chkHideWhenMinimized) = $GUI_CHECKED ? 1 : 0)
TrayItemSetState($tiHide, ($iHideWhenMinimized = 1 ? $TRAY_CHECKED : $TRAY_UNCHECKED))
EndFunc
Func chkScreenshotType()
If GUICtrlRead($chkScreenshotType) = $GUI_CHECKED Then
$iScreenshotType = 1
Else
$iScreenshotType = 0
EndIf
EndFunc
Func chkScreenshotHideName()
If GUICtrlRead($chkScreenshotHideName) = $GUI_CHECKED Then
$ichkScreenshotHideName = 1
Else
$ichkScreenshotHideName = 0
EndIf
EndFunc
Func chkDeleteLogs()
If GUICtrlRead($chkDeleteLogs) = $GUI_CHECKED Then
GUICtrlSetState($txtDeleteLogsDays, $GUI_ENABLE)
Else
GUICtrlSetState($txtDeleteLogsDays, $GUI_DISABLE)
EndIf
EndFunc
Func chkDeleteTemp()
If GUICtrlRead($chkDeleteTemp) = $GUI_CHECKED Then
GUICtrlSetState($txtDeleteTempDays, $GUI_ENABLE)
Else
GUICtrlSetState($txtDeleteTempDays, $GUI_DISABLE)
EndIf
EndFunc
Func chkDeleteLoots()
If GUICtrlRead($chkDeleteLoots) = $GUI_CHECKED Then
GUICtrlSetState($txtDeleteLootsDays, $GUI_ENABLE)
Else
GUICtrlSetState($txtDeleteLootsDays, $GUI_DISABLE)
EndIf
EndFunc
Func chkAutoStart()
If GUICtrlRead($chkAutoStart) = $GUI_CHECKED Then
GUICtrlSetState($txtAutostartDelay, $GUI_ENABLE)
Else
GUICtrlSetState($txtAutostartDelay, $GUI_DISABLE)
EndIf
EndFunc
Func chkDisposeWindows()
If GUICtrlRead($chkDisposeWindows) = $GUI_CHECKED Then
GUICtrlSetState($cmbDisposeWindowsCond, $GUI_ENABLE)
GUICtrlSetState($txtWAOffsetx, $GUI_ENABLE)
GUICtrlSetState($txtWAOffsety, $GUI_ENABLE)
Else
GUICtrlSetState($cmbDisposeWindowsCond, $GUI_DISABLE)
GUICtrlSetState($txtWAOffsetx, $GUI_DISABLE)
GUICtrlSetState($txtWAOffsety, $GUI_DISABLE)
EndIf
EndFunc
Func chkTotalCampForced()
If GUICtrlRead($chkTotalCampForced) = $GUI_CHECKED Then
GUICtrlSetState($txtTotalCampForced, $GUI_ENABLE)
Else
GUICtrlSetState($txtTotalCampForced, $GUI_DISABLE)
EndIf
EndFunc
Func chkSinglePBTForced()
If GUICtrlRead($chkSinglePBTForced) = $GUI_CHECKED Then
GUICtrlSetState($txtSinglePBTimeForced, $GUI_ENABLE)
GUICtrlSetState($txtPBTimeForcedExit, $GUI_ENABLE)
Else
GUICtrlSetState($txtSinglePBTimeForced, $GUI_DISABLE)
GUICtrlSetState($txtPBTimeForcedExit, $GUI_DISABLE)
EndIf
txtSinglePBTimeForced()
EndFunc
Func txtSinglePBTimeForced()
Switch Int(GUICtrlRead($txtSinglePBTimeForced))
Case 0 To 15
GUICtrlSetBkColor($txtSinglePBTimeForced, $COLOR_RED)
Case 16
GUICtrlSetBkColor($txtSinglePBTimeForced, $COLOR_YELLOW)
Case 17 To 999
GUICtrlSetBkColor($txtSinglePBTimeForced, $COLOR_MONEYGREEN)
EndSwitch
Switch Int(GUICtrlRead($txtPBTimeForcedExit))
Case 0 To 11
GUICtrlSetBkColor($txtPBTimeForcedExit, $COLOR_RED)
Case 12 To 14
GUICtrlSetBkColor($txtPBTimeForcedExit, $COLOR_YELLOW)
Case 15 To 999
GUICtrlSetBkColor($txtPBTimeForcedExit, $COLOR_MONEYGREEN)
EndSwitch
EndFunc
Func chkDebugClick()
If GUICtrlRead($chkDebugClick) = $GUI_CHECKED Then
$debugClick = 1
Else
$debugClick = 0
EndIf
SetDebugLog("DebugClick " & ($debugClick = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugSetlog()
If GUICtrlRead($chkDebugSetlog) = $GUI_CHECKED Then
$DebugSetlog = 1
Else
$DebugSetlog = 0
EndIf
SetDebugLog("DebugSetlog " & ($DebugSetlog = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugOcr()
If GUICtrlRead($chkDebugOcr) = $GUI_CHECKED Then
$debugOcr = 1
Else
$debugOcr = 0
EndIf
SetDebugLog("DebugOcr " & ($debugOcr = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugImageSave()
If GUICtrlRead($chkDebugImageSave) = $GUI_CHECKED Then
$DebugImageSave = 1
Else
$DebugImageSave = 0
EndIf
SetDebugLog("DebugImageSave " & ($DebugImageSave = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugBuildingPos()
If GUICtrlRead($chkdebugBuildingPos) = $GUI_CHECKED Then
$debugBuildingPos = 1
Else
$debugBuildingPos = 0
EndIf
SetDebugLog("DebugBuildingPos " & ($debugBuildingPos = 1 ? "enabled" : "disabled"))
EndFunc
Func chkDebugTrain()
If GUICtrlRead($chkdebugTrain) = $GUI_CHECKED Then
$debugsetlogTrain = 1
Else
$debugsetlogTrain = 0
EndIf
SetDebugLog("chkDebugTrain " & ($debugsetlogTrain = 1 ? "enabled" : "disabled"))
EndFunc
Func chkdebugOCRDonate()
If GUICtrlRead($chkdebugOCRDonate) = $GUI_CHECKED Then
$debugOCRdonate = 1
Else
$debugOCRdonate = 0
EndIf
SetDebugLog("chkdebugOCRDonate " & ($debugOCRdonate = 1 ? "enabled" : "disabled"))
EndFunc
Func chkdebugDeadBaseImage()
If GUICtrlRead($chkdebugDeadBaseImage) = $GUI_CHECKED Then
$debugDeadBaseImage = 1
Else
$debugDeadBaseImage = 0
EndIf
SetDebugLog("chkdebugDeadBaseImage " & ($debugDeadBaseImage = 1 ? "enabled" : "disabled"))
EndFunc
Func btnTestTrain()
Local $currentOCR = $debugOcr
Local $currentRunState = $RunState
_GUICtrlTab_ClickTab($tabMain, 0)
$debugOcr = 1
$RunState = True
ForceCaptureRegion()
DebugImageSave("train_")
SetLog(_PadStringCenter(" Test Train begin (" & $sBotVersion & ")", 54, "="), $COLOR_BLUE)
getArmyHeroCount(False, False)
SetLog(_PadStringCenter(" Test Train end ", 54, "="), $COLOR_BLUE)
Run("Explorer.exe " & $LibDir & "\debug\ocr\")
Run("Explorer.exe " & $dirTempDebug & "train_")
$debugOcr = $currentOCR
$RunState = $currentRunState
EndFunc
Func btnTestDonateCC()
Local $currentOCR = $debugOcr
Local $currentRunState = $RunState
Local $currentSetlog = $DebugSetlog
_GUICtrlTab_ClickTab($tabMain, 0)
$debugOcr = 1
$RunState = True
$DebugSetlog = 1
ForceCaptureRegion()
SetLog(_PadStringCenter(" Test DonateCC begin (" & $sBotVersion & ")", 54, "="), $COLOR_BLUE)
$DonationWindowY = 0
Local $aDonWinOffColors[2][3] = [[0xFFFFFF, 0, 2], [0xc7c5bc, 0, 209]]
Local $aDonationWindow = _MultiPixelSearch(409, 0, 410, $DEFAULT_HEIGHT, 1, 1, Hex(0xFFFFFF, 6), $aDonWinOffColors, 10)
If IsArray($aDonationWindow) Then
$DonationWindowY = $aDonationWindow[1]
If _Sleep(250) Then Return
Setlog("$DonationWindowY: " & $DonationWindowY, $COLOR_DEBUG)
Else
SetLog("Could not find the Donate Window :(", $COLOR_RED)
Return False
EndIf
Setlog("Detecting Troops...")
DetectSlotTroop($eBowl)
Setlog("Detecting Spells...")
DetectSlotTroop($eSkSpell)
SetLog(_PadStringCenter(" Test DonateCC end ", 54, "="), $COLOR_BLUE)
Run("Explorer.exe " & $LibDir & "\debug\ocr\")
$debugOcr = $currentOCR
$RunState = $currentRunState
$DebugSetlog = $currentSetlog
EndFunc
Func btnTestAttackBar()
Local $currentOCR = $debugOcr
Local $currentRunState = $RunState
_GUICtrlTab_ClickTab($tabMain, 0)
$debugOcr = 1
$RunState = True
ForceCaptureRegion()
SetLog(_PadStringCenter(" Test Attack Bar begin (" & $sBotVersion & ")", 54, "="), $COLOR_BLUE)
$DonationWindowY = 0
_CaptureRegion2(0, 571 + $bottomOffsetY, 859, 671 + $bottomOffsetY)
Local $result = DllCall($hFuncLib, "str", "searchIdentifyTroop", "ptr", $hHBitmap2)
Setlog("DLL Troopsbar list: " & $result[0], $COLOR_DEBUG)
Local $aTroopDataList = StringSplit($result[0], "|")
Local $aTemp[12][3]
If $result[0] <> "" Then
For $i = 1 To $aTroopDataList[0]
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
If $troopData[0] = 17 Or $troopData[0] = 18 Or $troopData[0] = 19 Or $troopData[0] = 20 Then $troopData[2] = 1
Setlog("position: " & $troopData[1] & " | troop code: " & $troopData[0] & " troop name:" & NameOfTroop($troopData[0]) & " | qty: " & $troopData[2])
Next
EndIf
_CaptureRegion(0, 630, $DEFAULT_WIDTH)
Local $savefolder = $dirTempDebug
$savefolder = $dirTempDebug & "Test_Attack_Bar\"
DirCreate($savefolder)
Local $debugfile
$Date = @MDAY & "." & @MON & "." & @YEAR
$Time = @HOUR & "." & @MIN & "." & @SEC
$debugfile = "Test_Attack_Bar_" & $sBotVersion & "_" & $Date & "_" & $Time & ".png"
_GDIPlus_ImageSaveToFile($hBitmap, $savefolder & $debugfile)
SetLog(_PadStringCenter(" Test Attack Bar end ", 54, "="), $COLOR_BLUE)
Run("Explorer.exe " & $savefolder)
$debugOcr = $currentOCR
$RunState = $currentRunState
EndFunc
Func btnTestClickDrag()
Local $i
SetLog("Testing Click drag functionality...", $COLOR_BLUE)
For $i = 0 To 4
SetLog("Click x1/y1=100/600 and drag to x2/y2=150/600", $COLOR_BLUE)
ClickDrag(100, 600, 150, 600)
Next
SetDebugLog("Waiting 3 Seconds...")
_SleepStatus(3000, True, True, False)
For $i = 0 To 4
SetLog("Click x1/y1=150/600 and drag to x2/y2=100/600", $COLOR_BLUE)
ClickDrag(150, 600, 100, 600)
Next
EndFunc
Func btnTestImage()
Local $sImageFile = FileOpenDialog("Select CoC screenshot to test", $dirTemp, "Image (*.png)", $FD_FILEMUSTEXIST, "", $frmBot)
SetLog("Testing image " & $sImageFile, $COLOR_BLUE)
Local $currentRunState = $RunState
$RunState = True
Local $hBMP = _GDIPlus_BitmapCreateFromFile($sImageFile)
Local $hHBMP = _GDIPlus_BitmapCreateDIBFromBitmap($hBMP)
TestCapture($hHBMP)
SetLog("Testing image hHBitmap = " & $hHBMP)
Local $result
SetLog("Testing checkObstacles", $COLOR_GREEN)
$result = checkObstacles()
SetLog("Testing checkObstacles DONE, $Result=" & $result, $COLOR_GREEN)
SetLog("Testing waitMainScreen...", $COLOR_GREEN)
$result = waitMainScreen()
SetLog("Testing waitMainScreen DONE, $Result=" & $result, $COLOR_GREEN)
SetLog("Testing waitMainScreenMini", $COLOR_GREEN)
$result = waitMainScreenMini()
SetLog("Testing waitMainScreenMini DONE, $Result=" & $result, $COLOR_GREEN)
SetLog("Testing WaitForClouds...", $COLOR_SUCCESS)
SetLog("$aNoCloudsAttack2 pixel check: " & _CheckPixel2($aNoCloudsAttack2, $bCapturePixel))
SetLog("Testing WaitForClouds DONE", $COLOR_SUCCESS)
_GDIPlus_BitmapDispose($hBMP)
_WinAPI_DeleteObject($hHBMP)
TestCapture(0)
SetLog("Testing finished", $COLOR_BLUE)
$RunState = $currentRunState
EndFunc
Func btnTestImageFolder()
local $ECD = "440,22|860,344|440,670|2,344"
$RunState = True
Local Const $sMessage = "Select a folder with images"
Local $dirTempDebug = $sProfilePath & "\" & $sCurrProfile & "\Temp\Debug\"
Local $directory = FileSelectFolder($sMessage, "")
If @error Then
MsgBox($MB_SYSTEMMODAL, "", "No folder was selected.")
Else
MsgBox($MB_SYSTEMMODAL, "", "You chose the following folder:" & @CRLF & $directory)
Setlog("Â» folder: " & $directory)
EndIf
ForceCaptureRegion()
Local $subDirectory = "DebugImage"
$hTimer = TimerInit()
local $Res = multiMatches($directory, 20, $ECD, "", "", 0, 1000)
Setlog("Â» Detection in " & Round(TimerDiff($hTimer)/1000,2) & "'s")
If UBound($Res) > 1 then
For $i = 1 to UBound($Res) - 1
$aCorrdenates = $Res[$i][5]
Setlog($i & " filename :" & $Res[$i][0])
Setlog($i & " totalobjects :" & $Res[$i][4])
If IsArray($aCorrdenates) then
For $x = 0 to UBound($aCorrdenates) - 1
Setlog($x + 1 & " Coord :" & $aCorrdenates[$x][0] & "|" & $aCorrdenates[$x][1])
Next
EndIf
Next
captureDebugImage($Res, $subDirectory)
$Res = ""
$directory = ""
Run("Explorer.exe " & $dirTempDebug & $subDirectory )
$subDirectory = ""
EndIf
$RunState = False
EndFunc
Func PopulatePresetComboBox()
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($sPreset & "\*.ini")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
_GUICtrlComboBox_ResetContent($cmbPresetList)
GUICtrlSetData($cmbPresetList, $output)
EndFunc
Func PresetLoadConfigInfo()
Local $inputfilename = $sPreset & "\" & GUICtrlRead($cmbPresetList) & ".ini"
Local $message = IniRead($inputfilename, "Preset", "info", "")
If StringInStr($message, "\n") > 0 Then
GUICtrlSetData($txtPresetMessage, StringReplace($message, "\n", @CRLF))
Else
GUICtrlSetData($txtPresetMessage, $message)
EndIf
GUICtrlSetState($lblLoadPresetMessage, $GUI_HIDE)
GUICtrlSetState($txtPresetMessage, $GUI_SHOW)
GUICtrlSetState($btnGUIPresetLoadConf, $GUI_SHOW)
GUICtrlSetState($btnGUIPresetDeleteConf, $GUI_SHOW + $GUI_DISABLE)
GUICtrlSetState($chkCheckDeleteConf, $GUI_UNCHECKED)
GUICtrlSetState($chkCheckDeleteConf, $GUI_SHOW)
EndFunc
Func PresetLoadConf()
Local $filename = GUICtrlRead($cmbPresetList)
$SecondaryInputFile = $sPreset & "\" & $filename & ".ini"
SaveConfig()
readConfig()
applyConfig(False)
_GUICtrlTab_ClickTab($tabMain, 0)
SetRedrawBotWindow(True)
Setlog("Config " & $filename & " LOADED!", $COLOR_GREEN)
$SecondaryInputFile = ""
EndFunc
Func PresetSaveConf()
Local $filename = GUICtrlRead($txtPresetSaveFilename)
If StringRight($filename, 4) = ".ini" Then
$filename = StringLeft($filename, StringLen($filename) - 4)
GUICtrlSetData($txtPresetSaveFilename, $filename)
EndIf
If StringRegExp($filename, '\\|/|:|\*|\?|\"|\<|\>|\|') Then GUICtrlSetData($txtPresetSaveFilename, StringRegExpReplace($filename, '\\|/|:|\*|\?|\"|\<|\>|\|', "_"))
If FileExists($sPreset & "\" & $filename & ".ini") Then
Local $i = 2
While $i > 0
If FileExists($sPreset & "\" & $filename & " (" & $i & ").ini") Then
$i += 1
Else
$filename = $filename & " (" & $i & ")"
GUICtrlSetData($txtPresetSaveFilename, $filename)
$i = 0
EndIf
WEnd
EndIf
Local $msg = StringReplace(GUICtrlRead($txtSavePresetMessage), @CRLF, "\n")
$SecondaryOutputFile = $sPreset & "\" & $filename & ".ini"
IniWrite($SecondaryOutputFile, "preset", "info", $msg)
saveConfig()
readconfig()
applyConfig()
_GUICtrlTab_ClickTab($tabMain, 0)
Setlog("Config " & $filename & " SAVED!", $COLOR_GREEN)
$SecondaryOutputFile = ""
EndFunc
Func PresetDeleteConf()
Local $button = MsgBox($MB_ICONWARNING + $MB_OKCANCEL, GetTranslated(640, 70, "Delete Configuration"), GetTranslated(640, 71, 'Are you sure you want to delete the configuration ?') & GUICtrlRead($cmbPresetList) & '"?' & @CRLF &  "This cannot be undone.")
If $button = $IDOK Then
FileDelete($sPreset & "\" & GUICtrlRead($cmbPresetList) & ".ini")
saveconfig()
readconfig()
applyConfig()
EndIf
EndFunc
Func chkCheckDeleteConf()
If GUICtrlRead($chkCheckDeleteConf) = $GUI_CHECKED Then
GUICtrlSetState($btnGUIPresetDeleteConf, $GUI_ENABLE)
Else
GUICtrlSetState($btnGUIPresetDeleteConf, $GUI_DISABLE)
EndIf
EndFunc
Func MakeSavePresetMessage()
Local $message = ""
$message &= "NOTES:" & @CRLF & @CRLF
If $iChkTrophyRange = 1 Then $message &= "TROPHIES RANGE: " & $itxtdropTrophy & " - " & $itxtMaxTrophy & @CRLF & @CRLF
$message &= "TRAIN ARMY SETTINGS:" & @CRLF
$message &= "- Elixir Troops: Custom" & @CRLF
For $i = 0 To UBound($TroopName) - 1
If Eval($TroopName[$i] & "Comp") > 0 Then
$message &= "  " & $TroopName[$i] & " " & Eval($TroopName[$i] & "Comp")
If Mod($i + 1, 4) = 0 Then $message &= @CRLF
EndIf
Next
$message &= @CRLF
$message &= "SEARCH SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB search: "
Case $LB
$message &= "- AS search: "
Case $TS
$message &= "- TH search: "
EndSwitch
If $iEnableSearchSearches[$i] = 1 Then $message &= " " & "s. " & $iEnableAfterCount[$i] & "-" & $iEnableBeforeCount[$i]
If $iEnableSearchTropies[$i] = 1 Then $message &= "  " & "t. " & $iEnableAfterTropies[$i] & "-" & $iEnableBeforeTropies[$i]
If $iEnableSearchCamps[$i] = 1 Then $message &= " " & "c. >" & $iEnableAfterArmyCamps[$i] & "%"
$message &= @CRLF
Switch $i
Case $DB
$message &= "- DB filter: "
Case $LB
$message &= "- AS filter: "
Case $TS
$message &= "- TH filter: "
EndSwitch
Switch $iCmbMeetGE[$i]
Case 0
$message &= " G >= " & $iMinGold[$i]
$message &= " & "
$message &= " E >= " & $iMinElixir[$i] & "  "
Case 1
$message &= " G >= " & $iMinGold[$i]
$message &= " or "
$message &= " E >= " & $iMinElixir[$i] & "  "
Case 2
$message &= " G+E >= " & $iMinGoldPlusElixir[$i] & "  "
EndSwitch
If $iChkMeetDE[$i] = 1 Then $message &= " D >= " & $iMinDark[$i] & "  "
If $iChkMeetTrophy[$i] = 1 Then $message &= " TR >= " & $iMinTrophy[$i] & "  "
If $iChkMeetTH[$i] = 1 Then $message &= " TH >= " & $iCmbTH[$i] + 6 & "  "
If $iChkMeetTHO[$i] = 1 Then $message &= " THO" & "  "
If IsWeakBaseActive($i) Then $message &= " WB" & "  "
If $iChkMeetOne[$i] = 1 Then $message &= " MeetOne" & "  "
$message &= @CRLF
EndIf
Next
$message &= @CRLF & "ATTACK SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB: "
Case $LB
$message &= "- AS: "
Case $TS
$message &= "- TH: "
EndSwitch
If $i = $DB Or $i = $LB Then
Switch $iAtkAlgorithm[$i]
Case "0"
$message &= "Standard Attack > "
Case "1"
$message &= "Scripted Attack > "
Case "2"
$message &= "Milking Attack   " & @CRLF
EndSwitch
EndIf
If $i = $TS Then $message &= $scmbAttackTHType & @CRLF
If ($i = $DB Or $i = $LB) And $iAtkAlgorithm[$i] = 0 Then
Local $tmp = StringSplit("one side|two sides|three sides|four sides|DE side|TH side", "|", 2)
$message &= $tmp[$iChkDeploySettings[$i]] & @CRLF
EndIf
EndIf
Next
$message &= @CRLF & "END BATTLE SETTINGS:" & @CRLF
For $i = $DB To $TS
If IsSearchModeActive($i, True) Then
Switch $i
Case $DB
$message &= "- DB: "
Case $LB
$message &= "- AS: "
Case $TS
$message &= "- TH: "
EndSwitch
If $iChkTimeStopAtk[$i] = 1 Then $message &= "wait " & $sTimeStopAtk[$i] & "  "
If $iChkTimeStopAtk2[$i] = 1 Then $message &= "wait " & $sTimeStopAtk2[$i] & " ->(" & $stxtMinGoldStopAtk2[$i] & "," & $stxtMinElixirStopAtk2[$i] & "," & $stxtMinDarkElixirStopAtk2[$i] & ")  "
If $ichkEndNoResources[$i] = 1 Then $message &= "nores "
If $ichkEndOneStar[$i] = 1 Then $message &= "1star  "
If $ichkEndTwoStars[$i] = 1 Then $message &= "2stars  "
EndIf
$message &= @CRLF
Next
GUICtrlSetData($txtSavePresetMessage, $message)
EndFunc
Func btnStrategyFolder()
ShellExecute("explorer",$sPreset)
EndFunc
Func cmbProfile()
saveConfig()
FileClose($hLogFileHandle)
FileClose($hAttackLogFileHandle)
setupProfile()
readConfig()
applyConfig()
saveConfig()
SetLog("Profile " & $sCurrProfile & " loaded from " & $config, $COLOR_SUCCESS)
EndFunc
Func btnAddConfirm()
Switch @GUI_CtrlId
Case $btnAdd
GUICtrlSetState($cmbProfile, $GUI_HIDE)
GUICtrlSetState($txtVillageName, $GUI_SHOW)
GUICtrlSetState($btnAdd, $GUI_HIDE)
GUICtrlSetState($btnConfirmAdd, $GUI_SHOW)
GUICtrlSetState($btnDelete, $GUI_HIDE)
GUICtrlSetState($btnCancel, $GUI_SHOW)
GUICtrlSetState($btnConfirmRename, $GUI_HIDE)
GUICtrlSetState($btnRename, $GUI_HIDE)
Case $btnConfirmAdd
Local $newProfileName = StringRegExpReplace(GUICtrlRead($txtVillageName), '[/:*?"<>|]', '_')
If FileExists($sProfilePath & "\" & $newProfileName) Then
MsgBox($MB_ICONWARNING, GetTranslated(637, 11, "Profile Already Exists"), GetTranslated(637, 12, "%s already exists.\r\nPlease choose another name for your profile.", $newProfileName))
Return
EndIf
$sCurrProfile = $newProfileName
createProfile()
setupProfileComboBox()
selectProfile()
GUICtrlSetState($txtVillageName, $GUI_HIDE)
GUICtrlSetState($cmbProfile, $GUI_SHOW)
GUICtrlSetState($btnAdd, $GUI_SHOW)
GUICtrlSetState($btnConfirmAdd, $GUI_HIDE)
GUICtrlSetState($btnDelete, $GUI_SHOW)
GUICtrlSetState($btnCancel, $GUI_HIDE)
GUICtrlSetState($btnConfirmRename, $GUI_HIDE)
GUICtrlSetState($btnRename, $GUI_SHOW)
If GUICtrlGetState($btnDelete) <> $GUI_ENABLE Then GUICtrlSetState($btnDelete, $GUI_ENABLE)
If GUICtrlGetState($btnRename) <> $GUI_ENABLE Then GUICtrlSetState($btnRename, $GUI_ENABLE)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
EndFunc
Func btnDeleteCancel()
Switch @GUI_CtrlId
Case $btnDelete
Local $msgboxAnswer = MsgBox($MB_ICONWARNING + $MB_OKCANCEL, GetTranslated(637, 8, "Delete Profile"), GetTranslated(637, 14, "Are you sure you really want to delete the profile?\r\nThis action can not be undone."))
If $msgboxAnswer = $IDOK Then
deleteProfile()
GUICtrlSetData($txtVillageName, GetTranslated(637,4, "MyVillage"))
If _GUICtrlComboBox_GetCount($cmbProfile) > 1 Then
setupProfileComboBox()
selectProfile()
Else
createProfile(True)
EndIf
EndIf
Case $btnCancel
GUICtrlSetState($txtVillageName, $GUI_HIDE)
GUICtrlSetState($cmbProfile, $GUI_SHOW)
GUICtrlSetState($btnConfirmAdd, $GUI_HIDE)
GUICtrlSetState($btnAdd, $GUI_SHOW)
GUICtrlSetState($btnCancel, $GUI_HIDE)
GUICtrlSetState($btnDelete, $GUI_SHOW)
GUICtrlSetState($btnConfirmRename, $GUI_HIDE)
GUICtrlSetState($btnRename, $GUI_SHOW)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
If GUICtrlRead($cmbProfile) = "<No Profiles>" Then
GUICtrlSetState($btnDelete, $GUI_DISABLE)
GUICtrlSetState($btnRename, $GUI_DISABLE)
EndIf
EndFunc
Func btnRenameConfirm()
Switch @GUI_CtrlId
Case $btnRename
GUICtrlSetData($txtVillageName, GUICtrlRead($cmbProfile))
GUICtrlSetState($cmbProfile, $GUI_HIDE)
GUICtrlSetState($txtVillageName, $GUI_SHOW)
GUICtrlSetState($btnAdd, $GUI_HIDE)
GUICtrlSetState($btnConfirmAdd, $GUI_HIDE)
GUICtrlSetState($btnDelete, $GUI_HIDE)
GUICtrlSetState($btnCancel, $GUI_SHOW)
GUICtrlSetState($btnRename, $GUI_HIDE)
GUICtrlSetState($btnConfirmRename, $GUI_SHOW)
Case $btnConfirmRename
Local $newProfileName = StringRegExpReplace(GUICtrlRead($txtVillageName), '[/:*?"<>|]', '_')
If FileExists($sProfilePath & "\" & $newProfileName) Then
MsgBox($MB_ICONWARNING, GetTranslated(7, 108, "Profile Already Exists"), $newProfileName & " " & GetTranslated(7, 109, "already exists.") & @CRLF & GetTranslated(7, 110, "Please choose another name for your profile"))
Return
EndIf
$sCurrProfile = $newProfileName
renameProfile()
setupProfileComboBox()
selectProfile()
GUICtrlSetState($txtVillageName, $GUI_HIDE)
GUICtrlSetState($cmbProfile, $GUI_SHOW)
GUICtrlSetState($btnConfirmAdd, $GUI_HIDE)
GUICtrlSetState($btnAdd, $GUI_SHOW)
GUICtrlSetState($btnCancel, $GUI_HIDE)
GUICtrlSetState($btnDelete, $GUI_SHOW)
GUICtrlSetState($btnConfirmRename, $GUI_HIDE)
GUICtrlSetState($btnRename, $GUI_SHOW)
Case Else
SetLog("If you are seeing this log message there is something wrong.", $COLOR_ERROR)
EndSwitch
EndFunc
Func cmbBotCond()
If _GUICtrlComboBox_GetCurSel($cmbBotCond) = 15 Then
If _GUICtrlComboBox_GetCurSel($cmbHoursStop) = 0 Then _GUICtrlComboBox_SetCurSel($cmbHoursStop, 1)
GUICtrlSetState($cmbHoursStop, $GUI_ENABLE)
Else
_GUICtrlComboBox_SetCurSel($cmbHoursStop, 0)
GUICtrlSetState($cmbHoursStop, $GUI_DISABLE)
EndIf
EndFunc
Func chkBotStop()
If GUICtrlRead($chkBotStop) = $GUI_CHECKED Then
GUICtrlSetState($cmbBotCommand, $GUI_ENABLE)
GUICtrlSetState($cmbBotCond, $GUI_ENABLE)
Else
GUICtrlSetState($cmbBotCommand, $GUI_DISABLE)
GUICtrlSetState($cmbBotCond, $GUI_DISABLE)
EndIf
EndFunc
Func btnLocateClanCastle()
Local $wasRunState = $RunState
$RunState = True
ZoomOut()
LocateClanCastle()
$RunState = $wasRunState
AndroidShield("btnLocateClanCastle")
EndFunc
Func btnLocateKingAltar()
LocateKingAltar()
EndFunc
Func btnLocateQueenAltar()
LocateQueenAltar()
EndFunc
Func btnLocateWardenAltar()
LocateWardenAltar()
EndFunc
Func btnLocateTownHall()
Local $wasRunState = $RunState
$RunState = True
ZoomOut()
LocateTownHall()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslated(640, 72, "If you locating your TH because you upgraded,") & @CRLF &  GetTranslated(640, 73, "then you must restart bot!!!") & @CRLF & @CRLF &  GetTranslated(640, 74, "Click OK to restart bot, ") & @CRLF & @CRLF & GetTranslated(640, 65, "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(640, 1, "Ok|Cancel"), GetTranslated(640, 76, "Close Bot Please!"), $stext, 120, $frmBot)
If $DebugSetlog = 1 Then Setlog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
Local $stext = @CRLF & GetTranslated(640, 77, "Are you 100% sure you want to restart bot ?") & @CRLF & @CRLF &  GetTranslated(640, 78, "Click OK to close bot and then restart the bot (manually)") & @CRLF & @CRLF & GetTranslated(640, 65, -1) & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(640, 1, -1), GetTranslated(640, 76, -1), $stext, 120, $frmBot)
If $DebugSetlog = 1 Then Setlog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then BotClose(False)
EndIf
$RunState = $wasRunState
AndroidShield("btnLocateTownHall")
EndFunc
Func btnResetBuilding()
Local $wasRunState = $RunState
$RunState = True
While 1
If _Sleep(500) Then Return
If FileExists($building) Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
Local $stext = @CRLF & GetTranslated(640, 63, "Click OK to Delete and Reset all Building info,") & @CRLF & @CRLF &  GetTranslated(640, 64, "NOTE =>> Bot will exit and need to be restarted when complete") & @CRLF & @CRLF & GetTranslated(640, 65, "Or Click Cancel to exit") & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(640, 1, "Ok|Cancel"), GetTranslated(640, 67, "Delete Building Infomation ?"), $stext, 120, $frmBot)
If $DebugSetlog = 1 Then Setlog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
Local $stext = @CRLF & GetTranslated(640, 68, "Are you 100% sure you want to delete Building information ?") & @CRLF & @CRLF &  GetTranslated(640, 69, "Click OK to Delete and then restart the bot (manually)") & @CRLF & @CRLF & GetTranslated(640, 65, -1) & @CRLF
Local $MsgBox = _ExtMsgBox(0, GetTranslated(640, 1, -1), GetTranslated(640, 67, -1), $stext, 120, $frmBot)
If $DebugSetlog = 1 Then Setlog("$MsgBox= " & $MsgBox, $COLOR_DEBUG)
If $MsgBox = 1 Then
Local $Result = FileDelete($building)
If $Result = 0 Then
Setlog("Unable to remove building.ini file, please use manual method", $COLOR_ERROR)
Else
BotClose(False)
EndIf
EndIf
EndIf
Else
Setlog("Building.ini file does not exist", $COLOR_INFO)
EndIf
ExitLoop
WEnd
$RunState = $wasRunState
AndroidShield("btnResetBuilding")
EndFunc
Func btnLab()
Local $wasRunState = $RunState
$RunState = True
ZoomOut()
LocateLab()
$RunState = $wasRunState
AndroidShield("btnLab")
EndFunc
Func chkTrophyAtkDead()
If GUICtrlRead($chkTrophyAtkDead) = $GUI_CHECKED Then
$ichkTrophyAtkDead = 1
GUICtrlSetState($txtDTArmyMin, $GUI_ENABLE)
GUICtrlSetState($lblDTArmyMin, $GUI_ENABLE)
GUICtrlSetState($lblDTArmypercent, $GUI_ENABLE)
Else
$ichkTrophyAtkDead = 0
GUICtrlSetState($txtDTArmyMin, $GUI_DISABLE)
GUICtrlSetState($lblDTArmyMin, $GUI_DISABLE)
GUICtrlSetState($lblDTArmypercent, $GUI_DISABLE)
EndIf
EndFunc
Func chkTrophyRange()
If GUICtrlRead($chkTrophyRange) = $GUI_CHECKED Then
GUICtrlSetState($txtdropTrophy, $GUI_ENABLE)
GUICtrlSetState($txtMaxTrophy, $GUI_ENABLE)
GUICtrlSetState($chkTrophyHeroes, $GUI_ENABLE)
GUICtrlSetState($chkTrophyAtkDead, $GUI_ENABLE)
chkTrophyAtkDead()
Else
GUICtrlSetState($txtdropTrophy, $GUI_DISABLE)
GUICtrlSetState($txtMaxTrophy, $GUI_DISABLE)
GUICtrlSetState($chkTrophyHeroes, $GUI_DISABLE)
GUICtrlSetState($chkTrophyAtkDead, $GUI_DISABLE)
GUICtrlSetState($txtDTArmyMin, $GUI_DISABLE)
GUICtrlSetState($lblDTArmyMin, $GUI_DISABLE)
GUICtrlSetState($lblDTArmypercent, $GUI_DISABLE)
EndIf
EndFunc
Local $aAccelKeys[2][2] = [["{ESC}", $btnStop], ["{PAUSE}", $btnPause]]
Local $aAccelKeys_DockedUnshieledFocus[1][2] = [["{PAUSE}", $btnPause]]
Func SetAccelerators($bDockedUnshieledFocus = False)
GUISetAccelerators(0, $frmBot)
If $bDockedUnshieledFocus = False Then
GUISetAccelerators($aAccelKeys, $frmBot)
Else
GUISetAccelerators($aAccelKeys_DockedUnshieledFocus, $frmBot)
EndIf
EndFunc
Func BotToFront()
WinMove2(GetCurrentAndroidHWnD(), "", -1, -1, -1, -1, $HWND_TOPMOST, 0, False)
WinMove2(GetCurrentAndroidHWnD(), "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
EndFunc
Func GUIControl_WM_NCACTIVATE($hWin, $iMsg, $wParam, $lParam)
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
If $debugWindowMessages Then SetDebugLog("GUIControl_WM_NCACTIVATE: $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg, 8) & ", $wParam=" & $wParam & ", $lParam=" & $lParam, Default, True)
Local $iActive = BitAND($wParam, 0x0000FFFF)
If $hWin = $frmBot Then
If $AndroidEmbedded And AndroidShieldActiveDelay() = False Then
If $iActive = 0 Then
AndroidShield("GUIControl_WM_NCACTIVATE not active", Default, False, 0, False, False)
Else
AndroidShield("GUIControl_WM_NCACTIVATE active", Default, False)
EndIf
EndIf
If $iActive = 0 Then
SetDebugLog("GUIControl_WM_NCACTIVATE: Deactivate Bot", Default, True)
_WinAPI_SetFocus(0)
Else
If $iHideWhenMinimized = 0 Then BotRestore("GUIControl_WM_NCACTIVATE")
SetDebugLog("GUIControl_WM_NCACTIVATE: Activate Bot", Default, True)
EndIf
If $AndroidEmbedded And $AndroidEmbedMode = 1 And AndroidShieldActiveDelay() = False Then
AndroidEmbedCheck(False, $iActive <> 0, 1)
AndroidShield("GUIControl_WM_NCACTIVATE", Default, False)
EndIf
EndIf
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_FOCUS($hWin, $iMsg, $wParam, $lParam)
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
If $debugWindowMessages Then SetDebugLog("GUIControl_WM_FOCUS: $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg, 8) & ", $wParam=" & $wParam & ", $lParam=" & $lParam, Default, True)
Local $iActive = BitAND($wParam, 0x0000FFFF)
Switch $hWin
Case $frmBot
If $AndroidEmbedded And AndroidShieldActiveDelay() = False Then
AndroidShield("GUIControl_WM_FOCUS", Default, False)
If $AndroidEmbedMode = 1 Then
AndroidEmbedCheck(False, Default, 1)
EndIf
EndIf
EndSwitch
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_MOUSE($hWin, $iMsg, $wParam, $lParam)
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
Local $hWinMouse = $frmBotEmbeddedMouse
If $frmBotEmbeddedMouse = 0 Then $hWinMouse = (($AndroidEmbedMode = 0) ? $frmBotEmbeddedShield : $frmBot)
If $debugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_MOUSE: $hWin=" & $hWin & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ",$hWinMouse=" & $hWinMouse, Default, True)
If $hWin <> $hWinMouse Or $AndroidEmbedded = False Or $AndroidShieldStatus[0] = True Then
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndIf
Switch $iMsg
Case $WM_LBUTTONDOWN, $WM_LBUTTONUP, $WM_RBUTTONDOWN, $WM_RBUTTONUP
Local $hInput = GUICtrlGetHandle($frmBotEmbeddedShieldInput)
_WinAPI_SetFocus($hInput)
EndSwitch
Switch $iMsg
Case $WM_LBUTTONUP, $WM_RBUTTONUP
If $debugWindowMessages Then
Local $x = BitAND($lParam, 0xFFFF)
Local $y = BitAND($lParam, 0xFFFF0000) / 0x10000
SetDebugLog("GUIControl_WM_MOUSE: " & ($iMsg = $WM_LBUTTONUP ? "$WM_LBUTTONUP" : "$WM_RBUTTONUP") & " $hWin=" & $hWin & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam & ", X=" & $x & ", Y=" & $y, Default, True)
EndIf
If AndroidShieldHasFocus() = False Then
Local $hInput = GUICtrlGetHandle($frmBotEmbeddedShieldInput)
_WinAPI_SetFocus($hInput)
AndroidShield("GUIControl_WM_MOUSE", Default, False, 0, True)
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndIf
EndSwitch
If AndroidShieldHasFocus() = False Then
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndIf
Local $hCtrlTarget = $AndroidEmbeddedCtrlTarget[0]
Local $Result = _SendMessage($hCtrlTarget, $iMsg, $wParam, $lParam)
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_AndroidEmbedded($hWin, $iMsg, $wParam, $lParam)
If $AndroidEmbedded = False Or $AndroidShieldStatus[0] = True Then
Return $GUI_RUNDEFMSG
EndIf
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
Switch $iMsg
Case $WM_KEYDOWN, $WM_KEYUP, $WM_SYSKEYDOWN, $WM_SYSKEYUP, $WM_MOUSEWHEEL
If $debugAndroidEmbedded Then SetDebugLog("GUIControl_AndroidEmbedded: FORWARD $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg) & ", $wParam=" & $wParam & ", $lParam=" & $lParam, Default, True)
Local $hCtrlTarget = $AndroidEmbeddedCtrlTarget[0]
If $iMsg = $WM_KEYUP And $wParam = 27 Then
Local $wasSilentSetLog = $SilentSetLog
$SilentSetLog = True
AndroidBackButton(False)
$SilentSetLog = $wasSilentSetLog
If $debugAndroidEmbedded Then AndroidShield("GUIControl_AndroidEmbedded WM_SETFOCUS", Default, False, 0, True)
Else
_WinAPI_PostMessage($hCtrlTarget, $iMsg, $wParam, $lParam)
EndIf
EndSwitch
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_COMMAND($hWind, $iMsg, $wParam, $lParam)
If $GUIControl_Disabled = True Then Return $GUI_RUNDEFMSG
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
If $debugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_COMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
Local $nNotifyCode = BitShift($wParam, 16)
Local $nID = BitAND($wParam, 0x0000FFFF)
Local $hCtrl = $lParam
If $hWind <> $frmBotEmbeddedShield And $hWind <> $frmBotEmbeddedGarphics And $hWind <> $frmBotEmbeddedMouse Then
If AndroidShieldHasFocus() = True Then
If $debugWindowMessages Then SetDebugLog("GUIControl_WM_COMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
AndroidShield("GUIControl_WM_COMMAND", Default, False, 150, False)
EndIf
EndIf
CheckRedrawBotWindow()
Switch $nID
Case $divider
$bMoveDivider = True
SetDebugLog("MoveDivider active", Default, True)
Case $GUI_EVENT_CLOSE
BotCloseRequest()
Case $lblCreditsBckGrnd, $lblUnbreakableHelp
Local $CursorInfo = GUIGetCursorInfo($frmBot)
If IsArray($CursorInfo) = 1 Then
Switch $CursorInfo[4]
Case $labelMyBotURL, $labelForumURL, $lblUnbreakableLink
OpenURL_Label($CursorInfo[4])
EndSwitch
EndIf
Case $labelMyBotURL, $labelForumURL, $lblUnbreakableLink
OpenURL_Label($nID)
Case $lblDonate
ShellExecute("https://mybot.run/forums/index.php?/donate/make-donation/")
Case $btnStop
btnStop()
Case $btnPause
btnPause()
Case $btnResume
btnResume()
Case $btnHide
btnHide()
Case $btnEmbed
btnEmbed()
Case $btnResetStats
btnResetStats()
Case $btnAttackNowDB
btnAttackNowDB()
Case $btnAttackNowLB
btnAttackNowLB()
Case $btnAttackNowTS
btnAttackNowTS()
Case $CheckVersionConfig
CheckVersionHTML()
CheckModVersion()
Case $btnNotifyDeleteMessages
If $RunState Then
btnDeletePBMessages()
Else
PushMsg("DeleteAllPBMessages")
EndIf
Case $btnMakeScreenshot
If $RunState Then
btnMakeScreenshot()
Else
If $iScreenshotType = 0 Then
MakeScreenshot($dirTemp, "jpg")
Else
MakeScreenshot($dirTemp, "png")
EndIf
EndIf
Case $pic2arrow
btnVillageStat()
Case $arrowleft, $arrowright
btnVillageStat()
Case $chkDebugClick
chkDebugClick()
Case $chkDebugSetlog
chkDebugSetlog()
Case $chkDebugOcr
chkDebugOcr()
Case $chkDebugImageSave
chkDebugImageSave()
Case $chkdebugBuildingPos
chkDebugBuildingPos()
Case $chkDebugTrain
chkDebugTrain()
Case $chkdebugOCRDonate
chkdebugOCRDonate()
Case $chkdebugDeadBaseImage
chkdebugDeadBaseImage()
Case $btnTestTrain
btnTestTrain()
Case $btnTestDonateCC
btnTestDonateCC()
Case $btnTestAttackBar
btnTestAttackBar()
Case $btnTestClickDrag
btnTestClickDrag()
Case $btnTestImage
btnTestImage()
Case $btnEagle
btnEagle()
Case $btnDropS
btnDropRSpell()
Case $btnTestAD
btnTestAD()
Case $btnImageFolder
btnTestImageFolder()
Case $btnEQDeploy
btnNEWRedLineDetection()
Case $btnDBCheck
btnDBCheck()
Case $btnPosCheck
btnPosCheck()
EndSwitch
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_MOVE($hWind, $iMsg, $wParam, $lParam)
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
If $debugWindowMessages Then SetDebugLog("GUIControl_WM_MOVE: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $frmBot Then
If $iUpdatingWhenMinimized = 1 And BotWindowCheck() = False And _WinAPI_IsIconic($frmBot) Then
BotMinimize("GUIControl_WM_MOVE")
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndIf
Local $frmBotPos = WinGetPos($frmBot)
If $AndroidEmbedded = False Then
$frmBotPosX = ($frmBotPos[0] > -30000 ? $frmBotPos[0] : $frmBotPosX)
$frmBotPosY = ($frmBotPos[1] > -30000 ? $frmBotPos[1] : $frmBotPosY)
Else
$frmBotDockedPosX = ($frmBotPos[0] > -30000 ? $frmBotPos[0] : $frmBotDockedPosX)
$frmBotDockedPosY = ($frmBotPos[1] > -30000 ? $frmBotPos[1] : $frmBotDockedPosY)
EndIf
If $AndroidEmbedded And AndroidEmbedArrangeActive() = False Then
Local $iAction = AndroidEmbedCheck(True)
If $iAction > 0 Then
AndroidEmbedCheck(False, Default, $iAction)
EndIf
If $debugWindowMessages Then
Local $a = $frmBotPos
SetDebugLog("Bot Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
$a = WinGetPos($HWnD)
SetDebugLog("Android Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
If $frmBotEmbeddedMouse <> 0 Then
$a = WinGetPos($frmBotEmbeddedMouse)
SetDebugLog("Mouse Window Position: " & $a[0] & "," & $a[1] & " " & $a[2] & "x" & $a[3])
EndIf
EndIf
EndIf
EndIf
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_SYSCOMMAND($hWind, $iMsg, $wParam, $lParam)
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
If $debugWindowMessages Then SetDebugLog("GUIControl_WM_SYSCOMMAND: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $frmBot Then
Switch $wParam
Case $SC_MINIMIZE
BotMinimize("GUIControl_WM_SYSCOMMAND")
Case $SC_RESTORE
BotRestore("GUIControl_WM_SYSCOMMAND")
Case $SC_CLOSE
BotCloseRequest()
EndSwitch
EndIf
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_NOTIFY($hWind, $iMsg, $wParam, $lParam)
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
If $debugWindowMessages > 1 Then SetDebugLog("GUIControl_WM_NOTIFY: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
Local $nNotifyCode = BitShift($wParam, 16)
Local $nID = BitAND($wParam, 0x0000FFFF)
Local $hCtrl = $lParam
Local $bCheckEmbeddedShield = True
Switch $nID
Case $tabMain
tabMain()
Case $hGUI_VILLAGE_TAB
tabVillage()
Case $hGUI_ATTACK_TAB
tabAttack()
Case $hGUI_SEARCH_TAB
tabSEARCH()
Case $hGUI_DEADBASE_TAB
tabDeadbase()
Case $hGUI_ACTIVEBASE_TAB
tabActivebase()
Case $hGUI_THSNIPE_TAB
tabTHSnipe()
Case $hGUI_BOT_TAB
tabBot()
Case Else
$bCheckEmbeddedShield = False
EndSwitch
If $bCheckEmbeddedShield Then
If $hWind <> $frmBotEmbeddedShield And $hWind <> $frmBotEmbeddedGarphics And $hWind <> $frmBotEmbeddedMouse Then
If AndroidShieldHasFocus() = True Then
If $debugWindowMessages Then SetDebugLog("GUIControl_WM_NOTIFY: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
AndroidShield("GUIControl_WM_NOTIFY", Default, False, 150, False)
EndIf
EndIf
EndIf
$TogglePauseAllowed = $wasAllowed
Return $GUI_RUNDEFMSG
EndFunc
Func GUIControl_WM_CLOSE($hWind, $iMsg, $wParam, $lParam)
If $debugWindowMessages > 0 Then SetDebugLog("GUIControl_WM_CLOSE: $hWind=" & $hWind & ",$iMsg=" & $iMsg & ",$wParam=" & $wParam & ",$lParam=" & $lParam, Default, True)
If $hWind = $frmBot Then
BotCloseRequest()
EndIf
EndFunc
Func GUIEvents()
Local $wasAllowed = $TogglePauseAllowed
$TogglePauseAllowed = False
Local $GUI_CtrlId = @GUI_CtrlId
If $FrmBotMinimized And $GUI_CtrlId = $GUI_EVENT_MINIMIZE Then
If $debugWindowMessages Then SetDebugLog("$GUI_EVENT_MINIMIZE changed to $GUI_EVENT_RESTORE", Default, True)
$GUI_CtrlId = $GUI_EVENT_RESTORE
EndIf
Switch $GUI_CtrlId
Case $GUI_EVENT_CLOSE
If $debugWindowMessages Then SetDebugLog("$GUI_EVENT_CLOSE", Default, True)
BotCloseRequest()
Case $GUI_EVENT_MINIMIZE
If $debugWindowMessages Then SetDebugLog("$GUI_EVENT_MINIMIZE", Default, True)
BotMinimize("GUIEvents")
Case $GUI_EVENT_RESTORE
If $debugWindowMessages Then SetDebugLog("$GUI_EVENT_RESTORE", Default, True)
BotRestore("GUIEvents")
Case Else
If $debugWindowMessages Then SetDebugLog("$GUI_EVENT: " & @GUI_CtrlId, Default, True)
EndSwitch
$TogglePauseAllowed = $wasAllowed
EndFunc
Func OpenURL_Label($LabelCtrlID)
Local $url = GUICtrlRead($LabelCtrlID)
If StringInStr($url, "http") <> 1 Then
$url = _GUIToolTip_GetText($hToolTip, 0, GUICtrlGetHandle($LabelCtrlID))
EndIf
If StringInStr($url, "http") = 1 Then
SetDebugLog("Open URL: " & $url)
ShellExecute($url)
Else
SetDebugLog("Cannot open URL for Control ID " & $LabelCtrlID, $COLOR_RED)
EndIf
EndFunc
Func BotCloseRequest()
If $BotAction = $eBotClose Then
BotClose()
Else
SetLog("Closing " & $sBotTitle & ", please wait ...")
EndIf
$RunState = False
$TPaused = False
$BotAction = $eBotClose
EndFunc
Func BotClose($SaveConfig = Default, $bExit = True)
If $SaveConfig = Default Then $SaveConfig = $iBotLaunchTime > 0
$RunState = False
$TPaused = False
ResumeAndroid()
SetLog("Closing " & $sBotTitle & " now ...")
AndroidEmbed(False)
AndroidShieldDestroy()
AndroidBotStopEvent()
If $SaveConfig = True Then
setupProfile()
SaveConfig()
EndIf
AndroidAdbTerminateShellInstance()
If $hMutex_BotTitle <> 0 Then _WinAPI_CloseHandle($hMutex_BotTitle)
If $hMutex_Profile <> 0 Then _WinAPI_CloseHandle($hMutex_Profile)
If $hMutex_MyBot <> 0 Then _WinAPI_CloseHandle($hMutex_MyBot)
_GDIPlus_ImageDispose($hBitmap)
_WinAPI_DeleteObject($hHBitmap)
_WinAPI_DeleteObject($hHBitmap2)
_GDIPlus_Shutdown()
MBRFunc(False)
_GUICtrlRichEdit_Destroy($txtLog)
_GUICtrlRichEdit_Destroy($txtAtkLog)
DllCall("comctl32.dll", "int", "ImageList_Destroy", "hwnd", $hImageList)
If $HWnD <> 0 Then ControlFocus($HWnD, "", $HWnD)
GUIDelete($frmBot)
DeletePicturesHostFolder()
If $bExit = True Then Exit
EndFunc
Func BotMinimize($sCaller, $iForceUpdatingWhenMinimized = False)
Local $hMutex = AcquireMutex("MinimizeRestore")
SetDebugLog("Minimize bot window, caller: " & $sCaller, Default, True)
$FrmBotMinimized = True
If $iUpdatingWhenMinimized = 1 Or $iForceUpdatingWhenMinimized = True Then
If $iHideWhenMinimized = 1 Then
WinMove2($frmBot, "", -32000, -32000, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($frmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($frmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
If _WinAPI_IsIconic($frmBot) Then WinSetState($frmBot, "", @SW_RESTORE)
If _WinAPI_IsIconic($HWnD) Then WinSetState($HWnD, "", @SW_RESTORE)
WinMove2($frmBot, "", -32000, -32000, -1, -1, 0, $SWP_SHOWWINDOW, False)
Else
If $iHideWhenMinimized = 1 Then
WinMove2($frmBot, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($frmBot, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($frmBot, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW))
EndIf
WinSetState($frmBot, "", @SW_MINIMIZE)
EndIf
ReleaseMutex($hMutex)
EndFunc
Func BotRestore($sCaller)
Local $hMutex = AcquireMutex("MinimizeRestore")
$FrmBotMinimized = False
Local $botPosX = ($AndroidEmbedded = False ? $frmBotPosX : $frmBotDockedPosX)
Local $botPosY = ($AndroidEmbedded = False ? $frmBotPosY : $frmBotDockedPosY)
SetDebugLog("Restore bot window to " & $botPosX & ", " & $botPosY & ", caller: " & $sCaller, Default, True)
Local $iExStyle = _WinAPI_GetWindowLong($frmBot, $GWL_EXSTYLE)
If BitAND($iExStyle, $WS_EX_TOOLWINDOW) Then
WinMove2($frmBot, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_SetWindowLong($frmBot, $GWL_EXSTYLE, BitAND($iExStyle, BitNOT($WS_EX_TOOLWINDOW)))
EndIf
If _WinAPI_IsIconic($frmBot) Then WinSetState($frmBot, "", @SW_RESTORE)
If $AndroidAdbScreencap = False And $RunState = True And $TPaused = False And _WinAPI_IsIconic($HWnD) Then WinSetState($HWnD, "", @SW_RESTORE)
WinMove2($frmBot, "", $botPosX, $botPosY, -1, -1, $HWND_TOP, $SWP_SHOWWINDOW)
_WinAPI_SetActiveWindow($frmBot)
_WinAPI_SetFocus($frmBot)
ReleaseMutex($hMutex)
EndFunc
Func BotWindowCheck()
If $FrmBotMinimized Then
Local $aPos = WinGetPos($frmBot)
If IsArray($aPos) And $aPos[0] > -30000 Or $aPos[0] > -30000 Then
BotMinimize("BotWindowCheck")
Return True
EndIf
EndIf
Return False
EndFunc
Func tiShow()
BotRestore("tiShow")
EndFunc
Func tiHide()
$iHideWhenMinimized = ($iHideWhenMinimized = 1 ? 0 : 1)
TrayItemSetState($tiHide, ($iHideWhenMinimized = 1 ? $TRAY_CHECKED : $TRAY_UNCHECKED))
GUICtrlSetState($chkHideWhenMinimized, ($iHideWhenMinimized = 1 ? $GUI_CHECKED : $GUI_UNCHECKED))
If $FrmBotMinimized = True Then
If $iHideWhenMinimized = 0 Then
BotRestore("tiHide")
Else
BotMinimize("tiHide")
EndIf
EndIf
EndFunc
Func tiAbout()
Local $sMsg = "Clash of Clans Bot" & @CRLF & @CRLF &  "Version: " & $sBotVersion & @CRLF &  "Released under the GNU GPLv3 license." & @CRLF &  "Visit www.MyBot.run"
MsgBox(64 + $MB_APPLMODAL + $MB_TOPMOST, $sBotTitle, $sMsg, 30, $frmBot)
EndFunc
Func tiDonate()
ShellExecute("https://mybot.run/forums/index.php?/donate/make-donation/")
EndFunc
Func tiExit()
BotCloseRequest()
EndFunc
Func SetRedrawBotWindow($bEnableRedraw, $bCheckRedrawBotWindow = True, $bForceRedraw = False, $RedrawControlIDs = Default)
If $RedrawBotWindowMode = 0 Then Return False
If $RedrawBotWindowMode = 1 Then $RedrawControlIDs = Default
Local $bWasRedraw = $bRedrawBotWindow[0]
If $bRedrawBotWindow[0] = $bEnableRedraw Then
Return $bWasRedraw
EndIf
_SendMessage($frmBotEx, $WM_SETREDRAW, $bEnableRedraw, 0)
$bRedrawBotWindow[0] = $bEnableRedraw
If $bEnableRedraw Then
If $bCheckRedrawBotWindow Then
CheckRedrawBotWindow($bForceRedraw, $RedrawControlIDs)
EndIf
Else
$bRedrawBotWindow[1] = True
EndIf
Return $bWasRedraw
EndFunc
Func SetRedrawBotWindowControls($bEnableRedraw, $RedrawControlIDs)
Return SetRedrawBotWindow($bEnableRedraw, True, False, $RedrawControlIDs)
EndFunc
Func CheckRedrawBotWindow($bForceRedraw = False, $RedrawControlIDs = Default)
If $RedrawBotWindowMode = 0 Then Return False
If $RedrawBotWindowMode = 1 Then $RedrawControlIDs = Default
If Not $bRedrawBotWindow[0] Then Return False
If $bRedrawBotWindow[1] Or $bForceRedraw Then
$bRedrawBotWindow[1] = False
$bRedrawBotWindow[2] = False
If $RedrawControlIDs = Default Then
SetDebugLog("Redraw MyBot Window" & ($bForceRedraw ? " (forced)" : ""))
_WinAPI_RedrawWindow($frmBotEx, 0, 0, $RDW_INVALIDATE)
Else
If IsArray($RedrawControlIDs) Then
SetDebugLog("Redraw MyBot ControlIds" & ($bForceRedraw ? " (forced)" : "") & ": " & _ArrayToString($RedrawControlIDs, ", "))
Local $c
For $c In $RedrawControlIDs
If ControlRedraw($frmBotEx, $c) = 0 Then
_WinAPI_RedrawWindow($frmBotEx, 0, 0, $RDW_INVALIDATE)
ExitLoop
EndIf
Next
Else
SetDebugLog("Redraw MyBot ControlId" & ($bForceRedraw ? " (forced)" : "") & ": " & $RedrawControlIDs)
If ControlRedraw($frmBotEx, $RedrawControlIDs) = 0 Then
_WinAPI_RedrawWindow($frmBotEx, 0, 0, $RDW_INVALIDATE)
EndIf
EndIf
EndIf
_WinAPI_UpdateWindow($frmBotEx)
Return True
Else
Return CheckRedrawControls()
EndIf
Return False
EndFunc
Func CheckRedrawControls($ForceCheck = False)
If $RedrawBotWindowMode = 0 Then Return False
If Not $bRedrawBotWindow[2] And Not $ForceCheck Then Return False
If GUICtrlRead($tabMain, 1) = $tabGeneral Then
Local $a = [$txtLog, $txtAtkLog]
Return CheckRedrawBotWindow(True, $a)
EndIf
$bRedrawBotWindow[2] = False
Return False
EndFunc
Func RedrawBotWindowNow()
_WinAPI_RedrawWindow($frmBot, 0, 0, $RDW_INVALIDATE)
_WinAPI_UpdateWindow($frmBot)
EndFunc
Func ControlRedraw($hWin, $ConrolId)
Local $a = ControlGetPos($hWin, "", $ConrolId)
If IsArray($a) = 0 Then
SetDebugLog("ControlRedraw: Invalid ControlId: " & $ConrolId)
Return 0
EndIf
SetDebugLog("Control ID " & $ConrolId & " Pos: " & $a[0] & ", " & $a[1] & ", " & $a[2] & ", " & $a[3], Default, True)
Local $left = $a[0]
Local $top = $a[1]
Local $width = $a[2]
Local $height = $a[3]
Local $hCtrl = (IsHWnd($ConrolId) ? $ConrolId : GUICtrlGetHandle($ConrolId))
Local $hWinParent = _WinAPI_GetParent($hCtrl)
If $hWinParent <> $frmBot Then
$a = ControlGetPos($hWin, "", $hWinParent)
If IsArray($a) Then
$left -= $a[0]
$top -= $a[1]
EndIf
EndIf
Local $tRECT = DllStructCreate($tagRECT)
Local $groupBorder = 0
DllStructSetData($tRECT, "Left", $left + $groupBorder)
DllStructSetData($tRECT, "Top", $top + $groupBorder)
DllStructSetData($tRECT, "Right", $left + $width - $groupBorder)
DllStructSetData($tRECT, "Bottom", $top + $height - $groupBorder)
_WinAPI_RedrawWindow($frmBotEx, $tRECT, 0, $RDW_INVALIDATE)
Return 1
EndFunc
Func SetTime()
Local $time = _TicksToTime(Int(TimerDiff($sTimer) + $iTimePassed), $hour, $min, $sec)
If GUICtrlRead($hGUI_STATS_TAB, 1) = $hGUI_STATS_TAB_ITEM2 Then GUICtrlSetData($lblresultruntime, StringFormat("%02i:%02i:%02i", $hour, $min, $sec))
If GUICtrlGetState($lblResultGoldNow) <> $GUI_ENABLE + $GUI_SHOW Then GUICtrlSetData($lblResultRuntimeNow, StringFormat("%02i:%02i:%02i", $hour, $min, $sec))
EndFunc
Func tabMain()
$tabidx = GUICtrlRead($tabMain)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $hGUI_VILLAGE)
GUISetState(@SW_HIDE, $hGUI_ATTACK)
GUISetState(@SW_HIDE, $hGUI_BOT)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_LOG)
Case $tabidx = 1
GUISetState(@SW_HIDE, $hGUI_LOG)
GUISetState(@SW_HIDE, $hGUI_ATTACK)
GUISetState(@SW_HIDE, $hGUI_BOT)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_VILLAGE)
tabVillage()
Case $tabidx = 2
GUISetState(@SW_HIDE, $hGUI_LOG)
GUISetState(@SW_HIDE, $hGUI_VILLAGE)
GUISetState(@SW_HIDE, $hGUI_BOT)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_ATTACK)
tabAttack()
Case $tabidx = 3
GUISetState(@SW_HIDE, $hGUI_LOG)
GUISetState(@SW_HIDE, $hGUI_VILLAGE)
GUISetState(@SW_HIDE, $hGUI_ATTACK)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_BOT)
tabBot()
Case Else
GUISetState(@SW_HIDE, $hGUI_LOG)
GUISetState(@SW_HIDE, $hGUI_VILLAGE)
GUISetState(@SW_HIDE, $hGUI_ATTACK)
GUISetState(@SW_HIDE, $hGUI_BOT)
EndSelect
EndFunc
Func tabVillage()
$tabidx = GUICtrlRead($hGUI_VILLAGE_TAB)
Select
Case $tabidx = 1
GUISetState(@SW_HIDE, $hGUI_UPGRADE)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_DONATE)
GUISetState(@SW_HIDE, $hGUI_NOTIFY)
Case $tabidx = 2
GUISetState(@SW_HIDE, $hGUI_DONATE)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_UPGRADE)
GUISetState(@SW_HIDE, $hGUI_NOTIFY)
Case $tabidx = 4
GUISetState(@SW_HIDE, $hGUI_DONATE)
GUISetState(@SW_HIDE, $hGUI_UPGRADE)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_NOTIFY)
Case Else
GUISetState(@SW_HIDE, $hGUI_DONATE)
GUISetState(@SW_HIDE, $hGUI_UPGRADE)
GUISetState(@SW_HIDE, $hGUI_NOTIFY)
EndSelect
EndFunc
Func tabAttack()
$tabidx = GUICtrlRead($hGUI_ATTACK_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $hGUI_STRATEGIES)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_ARMY)
GUISetState(@SW_HIDE, $hGUI_SEARCH)
GUISetState(@SW_HIDE, $hGUI_NewSmartZap)
Case $tabidx = 1
GUISetState(@SW_HIDE, $hGUI_STRATEGIES)
GUISetState(@SW_HIDE, $hGUI_ARMY)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_SEARCH)
GUISetState(@SW_HIDE, $hGUI_NewSmartZap)
tabSEARCH()
Case $tabidx = 2
GUISetState(@SW_HIDE, $hGUI_ARMY)
GUISetState(@SW_HIDE, $hGUI_SEARCH)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_NewSmartZap)
GUISetState(@SW_HIDE, $hGUI_STRATEGIES)
Case $tabidx = 3
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_STRATEGIES)
GUISetState(@SW_HIDE, $hGUI_ARMY)
GUISetState(@SW_HIDE, $hGUI_SEARCH)
GUISetState(@SW_HIDE, $hGUI_NewSmartZap)
EndSelect
EndFunc
Func tabSEARCH()
$tabidx = GUICtrlRead($hGUI_SEARCH_TAB)
$tabdbx = _GUICtrlTab_GetItemRect($hGUI_SEARCH_TAB, 0)
$tababx = _GUICtrlTab_GetItemRect($hGUI_SEARCH_TAB, 1)
$tabtsx = _GUICtrlTab_GetItemRect($hGUI_SEARCH_TAB, 2)
$tabblx = _GUICtrlTab_GetItemRect($hGUI_SEARCH_TAB, 3)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $hGUI_THSNIPE)
GUISetState(@SW_HIDE, $hGUI_BullyMode)
GUISetState(@SW_HIDE, $hGUI_AttackOption)
If GUICtrlRead($DBcheck) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_DEADBASE)
GUICtrlSetState($lblDBdisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $hGUI_DEADBASE)
GUICtrlSetState($lblDBdisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($ABcheck, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($TScheck, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($Bullycheck, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($DBcheck, $tabdbx[2] - 15, $tabdbx[3] - 17)
tabDeadbase()
Case $tabidx = 1
GUISetState(@SW_HIDE, $hGUI_DEADBASE)
GUISetState(@SW_HIDE, $hGUI_THSNIPE)
GUISetState(@SW_HIDE, $hGUI_BullyMode)
GUISetState(@SW_HIDE, $hGUI_AttackOption)
If GUICtrlRead($ABcheck) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_ACTIVEBASE)
GUICtrlSetState($lblABdisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE)
GUICtrlSetState($lblABdisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($DBcheck, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($TScheck, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($Bullycheck, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($ABcheck, $tababx[2] - 15, $tababx[3] - 17)
tabActivebase()
Case $tabidx = 2
GUISetState(@SW_HIDE, $hGUI_DEADBASE)
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $hGUI_BullyMode)
GUISetState(@SW_HIDE, $hGUI_AttackOption)
If GUICtrlRead($TScheck) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_THSNIPE)
GUICtrlSetState($lblTSdisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $hGUI_THSNIPE)
GUICtrlSetState($lblTSdisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($DBcheck, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($ABcheck, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($Bullycheck, $tabblx[2] - 15, $tabblx[3] - 15)
GUICtrlSetPos($TScheck, $tabtsx[2] - 15, $tabtsx[3] - 17)
tabTHSnipe()
Case $tabidx = 3
GUISetState(@SW_HIDE, $hGUI_DEADBASE)
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $hGUI_THSNIPE)
GUISetState(@SW_HIDE, $hGUI_AttackOption)
If GUICtrlRead($Bullycheck) = $GUI_CHECKED Then
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_BullyMode)
GUICtrlSetState($lblBullydisabled, $GUI_HIDE)
Else
GUISetState(@SW_HIDE, $hGUI_BullyMode)
GUICtrlSetState($lblBullydisabled, $GUI_SHOW)
EndIf
GUICtrlSetPos($DBcheck, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($ABcheck, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($TScheck, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($Bullycheck, $tabblx[2] - 15, $tabblx[3] - 17)
Case $tabidx = 4
GUISetState(@SW_HIDE, $hGUI_DEADBASE)
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE)
GUISetState(@SW_HIDE, $hGUI_THSNIPE)
GUISetState(@SW_HIDE, $hGUI_BullyMode)
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_AttackOption)
GUICtrlSetPos($DBcheck, $tabdbx[2] - 15, $tabdbx[3] - 15)
GUICtrlSetPos($ABcheck, $tababx[2] - 15, $tababx[3] - 15)
GUICtrlSetPos($TScheck, $tabtsx[2] - 15, $tabtsx[3] - 15)
GUICtrlSetPos($Bullycheck, $tabblx[2] - 15, $tabblx[3] - 15)
EndSelect
EndFunc
Func tabBot()
$tabidx = GUICtrlRead($hGUI_BOT_TAB)
Select
Case $tabidx = 0
GUISetState(@SW_HIDE, $hGUI_STATS)
Case $tabidx = 1
GUISetState(@SW_HIDE, $hGUI_STATS)
Case $tabidx = 2
GUISetState(@SW_HIDE, $hGUI_STATS)
Case $tabidx = 3
GUISetState(@SW_HIDE, $hGUI_STATS)
Case $tabidx = 4
GUISetState(@SW_SHOWNOACTIVATE, $hGUI_STATS)
EndSelect
EndFunc
Func tabDeadbase()
$tabidx = GUICtrlRead($hGUI_DEADBASE_TAB)
Select
Case $tabidx = 1
cmbDBAlgorithm()
Case Else
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_SCRIPTED)
GUISetState(@SW_HIDE, $hGUI_DEADBASE_ATTACK_MILKING)
EndSelect
EndFunc
Func tabActivebase()
$tabidx = GUICtrlRead($hGUI_ACTIVEBASE_TAB)
Select
Case $tabidx = 1
cmbABAlgorithm()
Case Else
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE_ATTACK_STANDARD)
GUISetState(@SW_HIDE, $hGUI_ACTIVEBASE_ATTACK_SCRIPTED)
EndSelect
EndFunc
Func tabTHSnipe()
$tabidx = GUICtrlRead($hGUI_THSNIPE_TAB)
Select
Case $tabidx = 1
Case Else
EndSelect
EndFunc
Func dbCheck()
If $iBotLaunchTime > 0 Then _GUICtrlTab_SetCurFocus($hGUI_SEARCH_TAB, 0)
If BitAND(GUICtrlRead($chkDBActivateSearches), GUICtrlRead($chkDBActivateTropies), GUICtrlRead($chkDBActivateCamps), GUICtrlRead($chkDBSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($chkDBActivateSearches, $GUI_CHECKED)
chkDBActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func dbCheckAll()
If BitAND(GUICtrlRead($chkDBActivateSearches), GUICtrlRead($chkDBActivateTropies), GUICtrlRead($chkDBActivateCamps), GUICtrlRead($chkDBSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($DBcheck, $GUI_UNCHECKED)
Else
GUICtrlSetState($DBcheck, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func abCheck()
If $iBotLaunchTime > 0 Then _GUICtrlTab_SetCurFocus($hGUI_SEARCH_TAB, 1)
If BitAND(GUICtrlRead($chkABActivateSearches), GUICtrlRead($chkABActivateTropies), GUICtrlRead($chkABActivateCamps), GUICtrlRead($chkABSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($chkABActivateSearches, $GUI_CHECKED)
chkABActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func abCheckAll()
If BitAND(GUICtrlRead($chkABActivateSearches), GUICtrlRead($chkABActivateTropies), GUICtrlRead($chkABActivateCamps), GUICtrlRead($chkABSpellsWait)) = $GUI_UNCHECKED Then
GUICtrlSetState($ABcheck, $GUI_UNCHECKED)
Else
GUICtrlSetState($ABcheck, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func tsCheck()
If $iBotLaunchTime > 0 Then _GUICtrlTab_SetCurFocus($hGUI_SEARCH_TAB, 2)
If BitAND(GUICtrlRead($chkTSActivateSearches), GUICtrlRead($chkTSActivateTropies), GUICtrlRead($chkTSActivateCamps)) = $GUI_UNCHECKED Then
GUICtrlSetState($chkTSActivateSearches, $GUI_CHECKED)
chkTSActivateSearches()
Else
tabSEARCH()
EndIf
EndFunc
Func tsCheckAll()
If BitAND(GUICtrlRead($chkTSActivateSearches), GUICtrlRead($chkTSActivateTropies), GUICtrlRead($chkTSActivateCamps)) = $GUI_UNCHECKED Then
GUICtrlSetState($TScheck, $GUI_UNCHECKED)
Else
GUICtrlSetState($TScheck, $GUI_CHECKED)
EndIf
tabSEARCH()
EndFunc
Func bullyCheck()
If $iBotLaunchTime > 0 Then _GUICtrlTab_SetCurFocus($hGUI_SEARCH_TAB, 3)
tabSEARCH()
EndFunc
Func _DonateAllControls($TroopType, $Set)
Local $bWasRedraw = SetRedrawBotWindow(False)
If $Set = True Then
For $i = 0 To UBound($aLblBtnControls) - 1
If $i = $TroopType Then
GUICtrlSetBkColor($aLblBtnControls[$i], $COLOR_NAVY)
Else
GUICtrlSetBkColor($aLblBtnControls[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
Next
For $i = 0 To UBound($aChkDonateAllControls) - 1
If $i <> $TroopType Then
GUICtrlSetState($aChkDonateAllControls[$i], $GUI_UNCHECKED)
EndIf
Next
For $i = 0 To UBound($aChkDonateControls) - 1
GUICtrlSetState($aChkDonateControls[$i], $GUI_UNCHECKED)
Next
For $i = 0 To UBound($aTxtDonateControls) - 1
If BitAND(GUICtrlGetState($aTxtDonateControls[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($aTxtDonateControls[$i], $GUI_DISABLE)
Next
For $i = 0 To UBound($aTxtBlacklistControls) - 1
If BitAND(GUICtrlGetState($aTxtBlacklistControls[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($aTxtBlacklistControls[$i], $GUI_DISABLE)
Next
If BitAND(GUICtrlGetState($txtBlacklist), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($txtBlacklist, $GUI_DISABLE)
Else
GUICtrlSetBkColor($aLblBtnControls[$TroopType], $GUI_BKCOLOR_TRANSPARENT)
For $i = 0 To UBound($aTxtDonateControls) - 1
If BitAND(GUICtrlGetState($aTxtDonateControls[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($aTxtDonateControls[$i], $GUI_ENABLE)
Next
For $i = 0 To UBound($aTxtBlacklistControls) - 1
If BitAND(GUICtrlGetState($aTxtBlacklistControls[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($aTxtBlacklistControls[$i], $GUI_ENABLE)
Next
If BitAND(GUICtrlGetState($txtBlacklist), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($txtBlacklist, $GUI_ENABLE)
EndIf
SetRedrawBotWindowControls($bWasRedraw, $hGUI_DONATE_TAB)
EndFunc
Func _DonateAllControlsSpell($TroopType, $Set)
Local $bWasRedraw = SetRedrawBotWindow(False)
If $Set = True Then
For $i = 0 To UBound($aLblBtnControlsSpell) - 1
If $i = $TroopType Then
GUICtrlSetBkColor($aLblBtnControlsSpell[$i], $COLOR_NAVY)
Else
GUICtrlSetBkColor($aLblBtnControlsSpell[$i], $GUI_BKCOLOR_TRANSPARENT)
EndIf
Next
For $i = 0 To UBound($aChkDonateAllControlsSpell) - 1
If $i <> $TroopType Then
GUICtrlSetState($aChkDonateAllControlsSpell[$i], $GUI_UNCHECKED)
EndIf
Next
For $i = 0 To UBound($aChkDonateControlsSpell) - 1
GUICtrlSetState($aChkDonateControlsSpell[$i], $GUI_UNCHECKED)
Next
For $i = 0 To UBound($aTxtDonateControlsSpell) - 1
If BitAND(GUICtrlGetState($aTxtDonateControlsSpell[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($aTxtDonateControlsSpell[$i], $GUI_DISABLE)
Next
For $i = 0 To UBound($aTxtBlacklistControlsSpell) - 1
If BitAND(GUICtrlGetState($aTxtBlacklistControlsSpell[$i]), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($aTxtBlacklistControlsSpell[$i], $GUI_DISABLE)
Next
If BitAND(GUICtrlGetState($txtBlacklist), $GUI_ENABLE) = $GUI_ENABLE Then GUICtrlSetState($txtBlacklist, $GUI_DISABLE)
Else
GUICtrlSetBkColor($aLblBtnControlsSpell[$TroopType], $GUI_BKCOLOR_TRANSPARENT)
For $i = 0 To UBound($aTxtDonateControlsSpell) - 1
If BitAND(GUICtrlGetState($aTxtDonateControlsSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($aTxtDonateControlsSpell[$i], $GUI_ENABLE)
Next
For $i = 0 To UBound($aTxtBlacklistControlsSpell) - 1
If BitAND(GUICtrlGetState($aTxtBlacklistControlsSpell[$i]), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($aTxtBlacklistControlsSpell[$i], $GUI_ENABLE)
Next
If BitAND(GUICtrlGetState($txtBlacklist), $GUI_DISABLE) = $GUI_DISABLE Then GUICtrlSetState($txtBlacklist, $GUI_ENABLE)
EndIf
SetRedrawBotWindowControls($bWasRedraw, $hGUI_DONATE_TAB)
EndFunc
Func ImageList_Create()
$hImageList = DllCall("comctl32.dll", "hwnd", "ImageList_Create", "int", 16, "int", 16, "int", 0x0021, "int", 0, "int", 1)
$hImageList = $hImageList[0]
Return $hImageList
EndFunc
Func Bind_ImageList($nCtrl)
Local $aIconIndex = 0
$hImageList = ImageList_Create()
GUICtrlSendMsg($nCtrl, $TCM_SETIMAGELIST, 0, $hImageList)
$tTcItem = DllStructCreate("uint;dword;dword;ptr;int;int;int")
DllStructSetData($tTcItem, 1, 0x0002)
Switch $nCtrl
Case $tabMain
Local $aIconIndex[5] = [$eIcnHourGlass, $eIcnTH11, $eIcnCamp, $eIcnGUI, $eIcnInfo]
Case $hGUI_VILLAGE_TAB
Local $aIconIndex[5] = [$eIcnTH1, $eIcnCC, $eIcnLaboratory, $eIcnAchievements, $eIcnInfo]
Case $hGUI_ARMY_TAB
Local $aIconIndex[3] = [$eIcnBarbarian, $eIcnGem, $eIcnOptions]
Case $hGUI_DONATE_TAB
Local $aIconIndex[3] = [$eIcnCCRequest, $eIcnCCDonate, $eIcnHourGlass]
Case $hGUI_UPGRADE_TAB
Local $aIconIndex[4] = [$eIcnLaboratory, $eIcnKingAbility, $eIcnMortar, $eIcnWall]
Case $hGUI_NOTIFY_TAB
Local $aIconIndex[3] = [$eIcnPushBullet, $eIcnOptions, $eIcnHourGlass]
Case $hGUI_ATTACK_TAB
Local $aIconIndex[4] = [$eIcnCamp, $eIcnMagnifier, $eIcnLightSpell, $eIcnStrategies]
Case $hGUI_SEARCH_TAB
Local $aIconIndex[5] = [$eIcnCollector, $eIcnCC, $eIcnTH10, $eIcnTH1, $eIcnOptions]
Case $hGUI_DEADBASE_TAB
Local $aIconIndex[4] = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar, $eIcnCollector]
Case $hGUI_ACTIVEBASE_TAB
Local $aIconIndex[3] = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar]
Case $hGUI_THSNIPE_TAB
Local $aIconIndex[3] = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar]
Case $hGUI_AttackOption_TAB
Local $aIconIndex[5] = [$eIcnMagnifier, $eIcnCamp, $eIcnSilverStar, $eIcnTrophy, $eIcnOptions]
Case $hGUI_BOT_TAB
Local $aIconIndex[5] = [$eIcnOptions, $eIcnBrain ,$eIcnOptions, $eIcnProfile, $eIcnGold]
Case $hGUI_STRATEGIES_TAB
Local $aIconIndex[2] = [$eIcnReload, $eIcnCopy]
Case $hGUI_STATS_TAB
Local $aIconIndex[4] = [$eIcnGoldElixir, $eIcnOptions, $eIcnCamp, $eIcnCCDonate]
Case Else
EndSwitch
If IsArray($aIconIndex) Then
For $i = 0 To UBound($aIconIndex) - 1
DllStructSetData($tTcItem, 6, $i)
AddImageToTab($nCtrl, $i, $tTcItem, $pIconLib, $aIconIndex[$i] - 1)
Next
$aIconIndex = 0
EndIf
$tTcItem = 0
EndFunc
Func AddImageToTab($nCtrl, $nTabIndex, $nItem, $pIconLib, $nIconID)
$hIcon = DllStructCreate("int")
$Result = DllCall("shell32.dll", "int", "ExtractIconEx", "str", $pIconLib, "int", $nIconID, "hwnd", 0, "ptr", DllStructGetPtr($hIcon), "int", 1)
$Result = $Result[0]
If $Result > 0 Then
DllCall("comctl32.dll", "int", "ImageList_AddIcon", "hwnd", $hImageList, "hwnd", DllStructGetData($hIcon, 1))
DllCall("user32.dll", "int", "SendMessage", "hwnd", ControlGetHandle($frmBot, "", $nCtrl), "int", $TCM_SETITEM, "int", $nTabIndex, "ptr", DllStructGetPtr($nItem))
DllCall("user32.dll", "int", "DestroyIcon", "hwnd", $hIcon)
EndIf
$hIcon = 0
EndFunc
Func _GUICtrlListView_SetItemHeightByFont($hListView, $iHeight)
Local $hDC = _WinAPI_GetDC($hListView), $hFont = _SendMessage($hListView, $WM_GETFONT)
Local $hObject = _WinAPI_SelectObject($hDC, $hFont), $lvLOGFONT = DllStructCreate($tagLOGFONT)
_WinAPI_GetObject($hFont, DllStructGetSize($lvLOGFONT), DllStructGetPtr($lvLOGFONT))
Local $hLVfont = _WinAPI_CreateFontIndirect($lvLOGFONT)
_WinAPI_SelectObject($hDC, $hObject)
_WinAPI_ReleaseDC($hListView, $hDC)
_WinAPI_DeleteObject($hFont)
$hFont = _WinAPI_CreateFont($iHeight, 0)
_WinAPI_SetFont($hListView, $hFont)
_WinAPI_DeleteObject($hFont)
Local $hHeader = _GUICtrlListView_GetHeader($hListView)
If $hHeader Then _WinAPI_SetFont($hHeader, $hLVfont)
Return $hLVfont
EndFunc
Func _GUICtrlListView_GetHeightToFitRows($hListView, $iRows)
Local $tRECT = _WinAPI_GetClientRect($hListView)
Local $hHeader = _GUICtrlListView_GetHeader($hListView)
Local $tWindowPos = _GUICtrlHeader_Layout($hHeader, $tRECT)
Local $iHdrHeight = DllStructGetData($tWindowPos, "CY")
Local $aItemRect = _GUICtrlListView_GetItemRect($hListView, 0, 0)
Return ($aItemRect[3] - $aItemRect[1]) * $iRows + $iHdrHeight + 8
EndFunc
Func EnableControls($hWin, $Enable, ByRef $avArr, $bGUIControl_Disabled = True, $i = 0)
Local $initalCall = $i = 0
If UBound($avArr, 0) <> 2 Then
Local $avTmp[1][2] = [[0]]
$avArr = $avTmp
EndIf
If $initalCall And $bGUIControl_Disabled Then
_SendMessage($hWin, $WM_SETREDRAW, False, 0)
Local $GUIControl_Disabled_ = $GUIControl_Disabled
$GUIControl_Disabled = True
EndIf
Local $hChild = _WinAPI_GetWindow($hWin, $GW_CHILD)
While $hChild
$i += 1
If $avArr[0][0] + 1 > UBound($avArr, 1) - 1 Then
ReDim $avArr[$avArr[0][0] + 2][2]
$avArr[$avArr[0][0] + 1][0] = $hChild
$avArr[$avArr[0][0] + 1][1] = BitAND(WinGetState($hChild), 4) > 0
EndIf
If $Enable = Default Then
WinSetState($hChild, "", ($avArr[$i][1] = True ? @SW_ENABLE : @SW_DISABLE))
Else
WinSetState($hChild, "", ($Enable ? @SW_ENABLE : @SW_DISABLE))
EndIf
$avArr[0][0] += 1
$i = EnableControls($hChild, $Enable, $avArr, $bGUIControl_Disabled, $i)
$hChild = _WinAPI_GetWindow($hChild, $GW_HWNDNEXT)
WEnd
If $initalCall And $Enable = Default Then $avArr = 0
If $initalCall And $bGUIControl_Disabled Then
_SendMessage($hWin, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($hWin, 0, 0, $RDW_INVALIDATE)
$GUIControl_Disabled = $GUIControl_Disabled_
EndIf
Return $i
EndFunc
tabMain()
If FileExists($config) = 0 And $aCmdLine[0] > 0 Then
createProfile()
saveConfig()
setupProfileComboBox()
EndIf
selectProfile()
If FileExists($config) Or FileExists($building) Then
readConfig()
applyConfig()
EndIf
If $devmode = 1 Then
GUICtrlSetState($chkDebugSetlog, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($chkDebugOcr, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($chkDebugImageSave, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($chkdebugBuildingPos, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($chkdebugTrain, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($chkdebugOCRDonate, $GUI_SHOW + $GUI_ENABLE)
GUICtrlSetState($chkdebugDeadBaseImage, $GUI_SHOW + $GUI_ENABLE)
EndIf
GUISetOnEvent($GUI_EVENT_CLOSE, "GUIEvents", $frmBot)
GUISetOnEvent($GUI_EVENT_MINIMIZE, "GUIEvents", $frmBot)
GUISetOnEvent($GUI_EVENT_RESTORE, "GUIEvents", $frmBot)
GUIRegisterMsg($WM_COMMAND, "GUIControl_WM_COMMAND")
GUIRegisterMsg($WM_NOTIFY, "GUIControl_WM_NOTIFY")
For $i = $WM_MOUSEMOVE To $WM_MBUTTONDBLCLK
GUIRegisterMsg($i, "GUIControl_WM_MOUSE")
Next
Func frmBot_WNDPROC($hWin, $iMsg, $wParam, $lParam)
If $debugWindowMessages > 1 Then SetDebugLog("frmBot_WNDPROC: FORWARD $hWin=" & $hWin & ", $iMsg=" & Hex($iMsg) & ", $wParam=" & Hex($wParam) & ", $lParam=" & $lParam, Default, True)
Switch $iMsg
Case $WM_NCACTIVATE
GUIControl_WM_NCACTIVATE($hWin, $iMsg, $wParam, $lParam)
Case $WM_SETFOCUS, $WM_KILLFOCUS
GUIControl_WM_FOCUS($hWin, $iMsg, $wParam, $lParam)
Case $WM_MOVE
GUIControl_WM_MOVE($hWin, $iMsg, $wParam, $lParam)
Case $WM_KEYDOWN, $WM_KEYUP, $WM_SYSKEYDOWN, $WM_SYSKEYUP, $WM_MOUSEWHEEL, $WM_MOUSEHWHEEL
GUIControl_AndroidEmbedded($hWin, $iMsg, $wParam, $lParam)
EndSwitch
Return _WinAPI_CallWindowProc($frmBot_WNDPROC, $hWin, $iMsg, $wParam, $lParam)
EndFunc
Local $frmBot_WNDPROC_ptr = DllCallbackGetPtr(DllCallbackRegister("frmBot_WNDPROC", "ptr", "hwnd;uint;long;ptr"))
_WinAPI_SetWindowLong(ControlGetHandle($frmBot, "", $frmBotEmbeddedShieldInput), $GWL_WNDPROC, $frmBot_WNDPROC_ptr)
$frmBot_WNDPROC = _WinAPI_SetWindowLong($frmBot, $GWL_WNDPROC, $frmBot_WNDPROC_ptr)
cmbDBAlgorithm()
cmbABAlgorithm()
SetAccelerators()
Func AcquireMutex($mutexName, $scope = Default, $timout = Default)
Local $timer = TimerInit()
Local $hMutex_MyBot = 0
If $scope = Default Then
$scope = @AutoItPID + "/"
ElseIf $scope <> "" Then
$scope += "/"
EndIf
If $timout = Default Then $timeout = 30000
While $hMutex_MyBot = 0 And ($timout = 0 Or TimerDiff($timer) < $timout)
$hMutex_MyBot = _Singleton("MyBot.run/" + $scope + $mutexName, 1)
If $hMutex_MyBot <> 0 Then ExitLoop
If $timout = 0 Then ExitLoop
Sleep($iDelaySleep)
WEnd
Return $hMutex_MyBot
EndFunc
Func ReleaseMutex($hMutex, $ReturnValue = Default)
_WinAPI_CloseHandle($hMutex)
If $ReturnValue = Default Then Return
Return $ReturnValue
EndFunc
Func WaitForSemaphore($sSemaphore, $iInitial = 4096, $iMaximum = 4096, $tSecurity = 0)
Local $bAquired = False
While $bAquired = False
Local $hSemaphore = _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity)
$bAquired = _WinAPI_WaitForSingleObject($hSemaphore, 0) <> -1
If $bAquired = True Then
_WinAPI_ReleaseSemaphore($hSemaphore)
_WinAPI_CloseHandle($hSemaphore)
ExitLoop
EndIf
_Sleep($iDelaySleep, True, False)
WEnd
EndFunc
Func LockSemaphore($sSemaphore)
Local $bAquired = False
While $bAquired = False
Local $hSemaphore = _WinAPI_CreateSemaphore($sSemaphore, 0, 1)
$bAquired = _WinAPI_WaitForSingleObject($hSemaphore, 0) <> -1
If $bAquired = True And _WinAPI_WaitForSingleObject($hSemaphore, 0) = -1 Then
Return $hSemaphore
ExitLoop
EndIf
_WinAPI_ReleaseSemaphore($hSemaphore)
_WinAPI_CloseHandle($hSemaphore)
_Sleep($iDelaySleep, True, False)
WEnd
EndFunc
Func UnlockSemaphore($hSemaphore)
If $hSemaphore <> 0 And $hSemaphore <> -1 Then
_WinAPI_ReleaseSemaphore($hSemaphore)
Return _WinAPI_CloseHandle($hSemaphore)
EndIf
Return False
EndFunc
#Region Header
#EndRegion Header
#Region Global Variables
Global Enum  $iOAER_bSet_ErrLine, $iOAER_bIn_Proc, $iOAER_bUse_StdOut, $iOAER_iPID, $iOAER_hErr_Callback, $iOAER_hErr_WinHook, $iOAER_sUserFunc, $iOAER_vUserParams, $iOAER_iCOMErrorNumber, $iOAER_sCOMErrorDesc,  $iOAER_Total
Global $aOAER_DATA[$iOAER_Total]
#EndRegion Global Variables
#Region Public Functions
Func _OnAutoItErrorRegister()
If $aOAER_DATA[$iOAER_hErr_WinHook] Then
Return
EndIf
$aOAER_DATA[$iOAER_hErr_CallBack] = DllCallbackRegister('__OAER_OnErrorCallback', 'int', 'int;int;int')
$aOAER_DATA[$iOAER_hErr_WinHook] = _WinAPI_SetWindowsHookEx($WH_CBT, DllCallbackGetPtr($aOAER_DATA[$iOAER_hErr_CallBack]), 0, _WinAPI_GetCurrentThreadId())
If Not $aOAER_DATA[$iOAER_hErr_WinHook] Then
DllCallbackFree($aOAER_DATA[$iOAER_hErr_CallBack])
Return 0
Else
Return 1
EndIf
EndFunc
Func _OnAutoItErrorUnRegister()
__OAER_OnExit()
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __OAER_OnExit()
If $aOAER_DATA[$iOAER_hErr_WinHook] Then
_WinAPI_UnhookWindowsHookEx($aOAER_DATA[$iOAER_hErr_WinHook])
$aOAER_DATA[$iOAER_hErr_WinHook] = 0
EndIf
If $aOAER_DATA[$iOAER_hErr_CallBack] Then
DllCallbackFree($aOAER_DATA[$iOAER_hErr_CallBack])
$aOAER_DATA[$iOAER_hErr_CallBack] = 0
EndIf
EndFunc
Func __OAER_OnErrorCallback($nCode, $wParam, $lParam)
If $nCode < 0 Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
Switch $nCode
Case 5
If Not _WinAPI_FindWindow('#32770', 'AutoIt Error') Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
Local $hError_Wnd = HWnd($wParam)
Local $sError_Msg = StringRegExpReplace(ControlGetText($hError_Wnd, '', 'Static2'), '(?<!\r)\n', @CRLF)
If (_WinAPI_GetClassName($hError_Wnd) <> '#32770' And WinGetTitle($hError_Wnd) <> 'AutoIt Error') Or Not StringRegExp($sError_Msg, '(?is)^.*Line \d+\s+\(File "(.*?)"\):\s+.*Error: .*') Then
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndIf
SetDebugLog($sBotTitle & " AutoIt Error: " & $sError_Msg, Default, True)
BotClose(Default, False)
_WinAPI_FatalAppExit($sError_Msg)
EndSwitch
Return _WinAPI_CallNextHookEx($aOAER_DATA[$iOAER_hErr_WinHook], $nCode, $wParam, $lParam)
EndFunc
#EndRegion Internal Functions
Func WallsStatsMAJ()
Local $sVarNameOld = "itxtwall" & ($icmbWalls + 4 < 10 ? "0" : "") & ($icmbWalls + 4) & "ST"
Local $sVarNameNew = "itxtwall" & ($icmbWalls + 5 < 10 ? "0" : "") & ($icmbWalls + 5) & "ST"
Assign($sVarNameOld, Number(Eval($sVarNameOld)) - Number($iNbrOfWallsUpped))
Assign($sVarNameNew, Number(Eval($sVarNameNew)) + Number($iNbrOfWallsUpped))
$iNbrOfWallsUpped = 0
GUICtrlSetData($txtWall04ST, $itxtWall04ST)
GUICtrlSetData($txtWall05ST, $itxtWall05ST)
GUICtrlSetData($txtWall06ST, $itxtWall06ST)
GUICtrlSetData($txtWall07ST, $itxtWall07ST)
GUICtrlSetData($txtWall08ST, $itxtWall08ST)
GUICtrlSetData($txtWall09ST, $itxtWall09ST)
GUICtrlSetData($txtWall10ST, $itxtWall10ST)
GUICtrlSetData($txtWall11ST, $itxtWall11ST)
SaveConfig()
EndFunc
Func setupProfileComboBox()
Local $profileString = ""
Local $aProfiles = _FileListToArray($sProfilePath, "*", $FLTA_FOLDERS)
If @error Then
$profileString = "<No Profiles>"
Else
Local $aProfileList[$aProfiles[0]]
For $i = 1 To $aProfiles[0]
$aProfileList[$i - 1] = $aProfiles[$i]
Next
$profileString = _ArrayToString($aProfileList, "|")
EndIf
GUICtrlSetData($cmbProfile, "", "")
GUICtrlSetData($cmbProfile, $profileString, "<No Profiles>")
EndFunc
Func renameProfile()
Local $originalPath = $sProfilePath & "\" & GUICtrlRead($cmbProfile)
Local $newPath = $sProfilePath & "\" & $sCurrProfile
If FileExists($originalPath) Then
FileClose($hLogFileHandle)
FileClose($hAttackLogFileHandle)
DirMove($originalPath, $newPath, $FC_NOOVERWRITE)
EndIf
EndFunc
Func deleteProfile()
Local $sProfile = GUICtrlRead($cmbProfile)
Local $deletePath = $sProfilePath & "\" & $sProfile
If FileExists($deletePath) Then
If $sProfile = $sCurrProfile Then
FileClose($hLogFileHandle)
FileClose($hAttackLogFileHandle)
EndIf
DirRemove($deletePath, $DIR_REMOVE)
EndIf
EndFunc
Func createProfile($bCreateNew = False)
If $bCreateNew = True Then
setupProfileComboBox()
setupProfile()
saveConfig()
setupProfileComboBox()
selectProfile()
Return
EndIf
DirCreate($sProfilePath & "\" & $sCurrProfile)
If Not FileExists($sProfilePath & "\profile.ini") Then
Local $hFile = FileOpen($sProfilePath & "\profile.ini", $FO_APPEND + $FO_CREATEPATH)
FileWriteLine($hFile, "[general]")
FileClose($hFile)
EndIf
IniWrite($sProfilePath & "\profile.ini", "general", "defaultprofile", $sCurrProfile)
SetupProfileFolder()
DirCreate($dirLogs)
DirCreate($dirLoots)
DirCreate($dirTemp)
DirCreate($dirTempDebug)
If FileExists($config) = 0 Then SetLog("New Profile '" & $sCurrProfile & "' created")
EndFunc
Func setupProfile()
If GUICtrlRead($cmbProfile) = "<No Profiles>" Then
$sCurrProfile = StringRegExpReplace(GUICtrlRead($txtVillageName), '[/:*?"<>|]', '_')
Else
$sCurrProfile = GUICtrlRead($cmbProfile)
EndIf
createProfile()
GUICtrlSetData($grpVillage, GetTranslated(603, 32, "Village") & ": " & $sCurrProfile)
GUICtrlSetData($txbNotifyOrigin, $sCurrProfile)
EndFunc
Func selectProfile()
If _GUICtrlComboBox_FindStringExact($cmbProfile, String($sCurrProfile)) <> -1 Then
_GUICtrlComboBox_SelectString($cmbProfile, String($sCurrProfile))
Else
Local $comboBoxArray = _GUICtrlComboBox_GetListArray($cmbProfile)
$sCurrProfile = $comboBoxArray[1]
createProfile()
readConfig()
applyConfig()
_GUICtrlComboBox_SetCurSel($cmbProfile, 0)
EndIf
GUICtrlSetData($grpVillage, GetTranslated(603, 32, "Village") & ": " & $sCurrProfile)
GUICtrlSetData($txbNotifyOrigin, $sCurrProfile)
EndFunc
Func applyConfig($bRedrawAtExit = True)
SetDebugLog("Apply Config")
If $AndroidEmbedded = False Then
If $frmBotPosX > -30000 And $frmBotPosY > -30000 And $FrmBotMinimized = False Then WinMove2($frmBot, "", $frmBotPosX, $frmBotPosY)
If $AndroidPosX > -30000 And $AndroidPosY > -30000 And $Hide = False Then WinMove2($HWnD, "", $AndroidPosX, $AndroidPosY)
Else
If $frmBotDockedPosX > -30000 And $frmBotDockedPosY > -30000 And $FrmBotMinimized = False Then WinMove2($frmBot, "", $frmBotDockedPosX, $frmBotDockedPosY)
EndIf
SetRedrawBotWindow(False)
GUICtrlSetState($chkUpdatingWhenMinimized, ($iUpdatingWhenMinimized = 1 ? $GUI_CHECKED : $GUI_UNCHECKED))
GUICtrlSetState($chkHideWhenMinimized, ($iHideWhenMinimized = 1 ? $GUI_CHECKED : $GUI_UNCHECKED))
TrayItemSetState($tiHide, ($iHideWhenMinimized = 1 ? $TRAY_CHECKED : $TRAY_UNCHECKED))
_GUICtrlComboBox_SetCurSel($cmbLog, $iCmbLog)
cmbLog()
If $ichkBackground = 1 Then
GUICtrlSetState($chkBackground, $GUI_CHECKED)
Else
GUICtrlSetState($chkBackground, $GUI_UNCHECKED)
EndIf
chkBackground()
_GUICtrlComboBox_SetCurSel($cmbDBMeetGE, $iCmbMeetGE[$DB])
cmbDBGoldElixir()
If $iChkMeetDE[$DB] = 1 Then
GUICtrlSetState($chkDBMeetDE, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBMeetDE, $GUI_UNCHECKED)
EndIf
chkDBMeetDE()
If $iChkMeetTrophy[$DB] = 1 Then
GUICtrlSetState($chkDBMeetTrophy, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBMeetTrophy, $GUI_UNCHECKED)
EndIf
chkDBMeetTrophy()
If $iChkMeetTH[$DB] = 1 Then
GUICtrlSetState($chkDBMeetTH, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBMeetTH, $GUI_UNCHECKED)
EndIf
chkDBMeetTH()
If $iChkMeetTHO[$DB] = 1 Then
GUICtrlSetState($chkDBMeetTHO, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBMeetTHO, $GUI_UNCHECKED)
EndIf
If $iChkMaxMortar[$DB] = 1 Then
GUICtrlSetState($chkMaxMortar[$DB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxMortar[$DB], $GUI_UNCHECKED)
EndIf
If $iChkMaxWizTower[$DB] = 1 Then
GUICtrlSetState($chkMaxWizTower[$DB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxWizTower[$DB], $GUI_UNCHECKED)
EndIf
If $iChkMaxAirDefense[$DB] = 1 Then
GUICtrlSetState($chkMaxAirDefense[$DB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxAirDefense[$DB], $GUI_UNCHECKED)
EndIf
If $iChkMaxXBow[$DB] = 1 Then
GUICtrlSetState($chkMaxXBow[$DB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxXBow[$DB], $GUI_UNCHECKED)
EndIf
If $iChkMaxInferno[$DB] = 1 Then
GUICtrlSetState($chkMaxInferno[$DB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxInferno[$DB], $GUI_UNCHECKED)
EndIf
If $iChkMaxEagle[$DB] = 1 Then
GUICtrlSetState($chkMaxEagle[$DB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxEagle[$DB], $GUI_UNCHECKED)
EndIf
chkDBWeakBase()
If $iChkMeetOne[$DB] = 1 Then
GUICtrlSetState($chkDBMeetOne, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBMeetOne, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtDBSearchesMin, $iEnableAfterCount[$DB])
GUICtrlSetData($txtDBSearchesMax, $iEnableBeforeCount[$DB])
GUICtrlSetData($txtDBTropiesMin, $iEnableAfterTropies[$DB])
GUICtrlSetData($txtDBTropiesMax, $iEnableBeforeTropies[$DB])
GUICtrlSetData($txtDBArmyCamps, $iEnableAfterArmyCamps[$DB])
GUICtrlSetData($txtDBMinGold, $iMinGold[$DB])
GUICtrlSetData($txtDBMinElixir, $iMinElixir[$DB])
GUICtrlSetData($txtDBMinGoldPlusElixir, $iMinGoldPlusElixir[$DB])
GUICtrlSetData($txtDBMinDarkElixir, $iMinDark[$DB])
GUICtrlSetData($txtDBMinTrophy, $iMinTrophy[$DB])
_GUICtrlComboBox_SetCurSel($cmbDBTH, $iCmbTH[$DB])
$iMaxTH[$DB] = $THText[$iCmbTH[$DB]]
If $iEnableSearchSearches[$DB] = 1 Then
GUICtrlSetState($chkDBActivateSearches, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBActivateSearches, $GUI_UNCHECKED)
EndIf
If $iEnableSearchSearches[$LB] = 1 Then
GUICtrlSetState($chkABActivateSearches, $GUI_CHECKED)
Else
GUICtrlSetState($chkABActivateSearches, $GUI_UNCHECKED)
EndIf
If $iEnableSearchSearches[$TS] = 1 Then
GUICtrlSetState($chkTSActivateSearches, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSActivateSearches, $GUI_UNCHECKED)
EndIf
If $iEnableSearchTropies[$DB] = 1 Then
GUICtrlSetState($chkDBActivateTropies, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBActivateTropies, $GUI_UNCHECKED)
EndIf
chkDBActivateTropies()
If $iEnableSearchTropies[$LB] = 1 Then
GUICtrlSetState($chkABActivateTropies, $GUI_CHECKED)
Else
GUICtrlSetState($chkABActivateTropies, $GUI_UNCHECKED)
EndIf
chkABActivateTropies()
If $iEnableSearchTropies[$TS] = 1 Then
GUICtrlSetState($chkTSActivateTropies, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSActivateTropies, $GUI_UNCHECKED)
EndIf
chkTSActivateTropies()
If $iEnableSearchCamps[$DB] = 1 Then
GUICtrlSetState($chkDBActivateCamps, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBActivateCamps, $GUI_UNCHECKED)
EndIf
chkDBActivateCamps()
If $iEnableSearchCamps[$LB] = 1 Then
GUICtrlSetState($chkABActivateCamps, $GUI_CHECKED)
Else
GUICtrlSetState($chkABActivateCamps, $GUI_UNCHECKED)
EndIf
chkABActivateCamps()
If $iEnableSearchCamps[$TS] = 1 Then
GUICtrlSetState($chkTSActivateCamps, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSActivateCamps, $GUI_UNCHECKED)
EndIf
chkTSActivateCamps()
_GUICtrlComboBox_SetCurSel($cmbABMeetGE, $iCmbMeetGE[$LB])
cmbABGoldElixir()
If $iChkMeetDE[$LB] = 1 Then
GUICtrlSetState($chkABMeetDE, $GUI_CHECKED)
Else
GUICtrlSetState($chkABMeetDE, $GUI_UNCHECKED)
EndIf
chkABMeetDE()
If $iChkMeetTrophy[$LB] = 1 Then
GUICtrlSetState($chkABMeetTrophy, $GUI_CHECKED)
Else
GUICtrlSetState($chkABMeetTrophy, $GUI_UNCHECKED)
EndIf
chkABMeetTrophy()
If $iChkMeetTH[$LB] = 1 Then
GUICtrlSetState($chkABMeetTH, $GUI_CHECKED)
Else
GUICtrlSetState($chkABMeetTH, $GUI_UNCHECKED)
EndIf
chkABMeetTH()
If $iChkMeetTHO[$LB] = 1 Then
GUICtrlSetState($chkABMeetTHO, $GUI_CHECKED)
Else
GUICtrlSetState($chkABMeetTHO, $GUI_UNCHECKED)
EndIf
If $iChkMaxMortar[$LB] = 1 Then
GUICtrlSetState($chkMaxMortar[$LB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxMortar[$LB], $GUI_UNCHECKED)
EndIf
If $iChkMaxWizTower[$LB] = 1 Then
GUICtrlSetState($chkMaxWizTower[$LB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxWizTower[$LB], $GUI_UNCHECKED)
EndIf
If $iChkMaxAirDefense[$LB] = 1 Then
GUICtrlSetState($chkMaxAirDefense[$LB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxAirDefense[$LB], $GUI_UNCHECKED)
EndIf
If $iChkMaxXBow[$LB] = 1 Then
GUICtrlSetState($chkMaxXBow[$LB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxXBow[$LB], $GUI_UNCHECKED)
EndIf
If $iChkMaxInferno[$LB] = 1 Then
GUICtrlSetState($chkMaxInferno[$LB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxInferno[$LB], $GUI_UNCHECKED)
EndIf
If $iChkMaxEagle[$LB] = 1 Then
GUICtrlSetState($chkMaxEagle[$LB], $GUI_CHECKED)
Else
GUICtrlSetState($chkMaxEagle[$LB], $GUI_UNCHECKED)
EndIf
chkABWeakBase()
If $iChkMeetOne[$LB] = 1 Then
GUICtrlSetState($chkABMeetOne, $GUI_CHECKED)
Else
GUICtrlSetState($chkABMeetOne, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtABMinGold, $iMinGold[$LB])
GUICtrlSetData($txtABMinElixir, $iMinElixir[$LB])
GUICtrlSetData($txtABMinGoldPlusElixir, $iMinGoldPlusElixir[$LB])
GUICtrlSetData($txtABMinDarkElixir, $iMinDark[$LB])
GUICtrlSetData($txtABMinTrophy, $iMinTrophy[$LB])
GUICtrlSetData($txtABSearchesMin, $iEnableAfterCount[$LB])
GUICtrlSetData($txtABSearchesMax, $iEnableBeforeCount[$LB])
GUICtrlSetData($txtABTropiesMin, $iEnableAfterTropies[$LB])
GUICtrlSetData($txtABTropiesMax, $iEnableBeforeTropies[$LB])
GUICtrlSetData($txtABArmyCamps, $iEnableAfterArmyCamps[$LB])
_GUICtrlComboBox_SetCurSel($cmbABTH, $iCmbTH[$LB])
$iMaxTH[$LB] = $THText[$iCmbTH[$LB]]
If $iChkSearchReduction = 1 Then
GUICtrlSetState($chkSearchReduction, $GUI_CHECKED)
Else
GUICtrlSetState($chkSearchReduction, $GUI_UNCHECKED)
EndIf
chkSearchReduction()
If $iChkRestartSearchLimit = 1 Then
GUICtrlSetState($ChkRestartSearchLimit, $GUI_CHECKED)
Else
GUICtrlSetState($ChkRestartSearchLimit, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtRestartSearchlimit, $iRestartSearchlimit)
ChkRestartSearchLimit()
_GUICtrlComboBox_SetCurSel($cmbDBAlgorithm, $iAtkAlgorithm[$DB])
_GUICtrlComboBox_SetCurSel($cmbABAlgorithm, $iAtkAlgorithm[$LB])
_GUICtrlComboBox_SetCurSel($cmbDBSelectTroop, $iCmbSelectTroop[$DB])
_GUICtrlComboBox_SetCurSel($cmbABSelectTroop, $iCmbSelectTroop[$LB])
_GUICtrlComboBox_SetCurSel($cmbTSSelectTroop, $iCmbSelectTroop[$TS])
If BitAND($iHeroAttack[$DB], $HERO_KING) = $HERO_KING Then
GUICtrlSetState($chkDBKingAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBKingAttack, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroAttack[$LB], $HERO_KING) = $HERO_KING Then
GUICtrlSetState($chkABKingAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkABKingAttack, $GUI_UNCHECKED)
EndIf
If $KingAttack[$TS] = 1 Then
GUICtrlSetState($chkTSKingAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSKingAttack, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroWait[$DB], $HERO_KING) = $HERO_KING Then
GUICtrlSetState($chkDBKingWait, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBKingWait, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroWait[$LB], $HERO_KING) = $HERO_KING Then
GUICtrlSetState($chkABKingWait, $GUI_CHECKED)
Else
GUICtrlSetState($chkABKingWait, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroAttack[$DB], $HERO_QUEEN) = $HERO_QUEEN Then
GUICtrlSetState($chkDBQueenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBQueenAttack, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroAttack[$LB], $HERO_QUEEN) = $HERO_QUEEN Then
GUICtrlSetState($chkABQueenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkABQueenAttack, $GUI_UNCHECKED)
EndIf
If $QueenAttack[$TS] = 1 Then
GUICtrlSetState($chkTSQueenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSQueenAttack, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroWait[$DB], $HERO_QUEEN) = $HERO_QUEEN Then
GUICtrlSetState($chkDBQueenWait, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBQueenWait, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroWait[$LB], $HERO_QUEEN) = $HERO_QUEEN Then
GUICtrlSetState($chkABQueenWait, $GUI_CHECKED)
Else
GUICtrlSetState($chkABQueenWait, $GUI_UNCHECKED)
EndIf
If $iDropCC[$DB] = 1 Then
GUICtrlSetState($chkDBDropCC, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBDropCC, $GUI_UNCHECKED)
EndIf
If $iDropCC[$LB] = 1 Then
GUICtrlSetState($chkABDropCC, $GUI_CHECKED)
Else
GUICtrlSetState($chkABDropCC, $GUI_UNCHECKED)
EndIf
If $iDropCC[$TS] = 1 Then
GUICtrlSetState($chkTSDropCC, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSDropCC, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroAttack[$DB], $HERO_WARDEN) = $HERO_WARDEN Then
GUICtrlSetState($chkDBWardenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBWardenAttack, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroAttack[$LB], $HERO_WARDEN) = $HERO_WARDEN Then
GUICtrlSetState($chkABWardenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkABWardenAttack, $GUI_UNCHECKED)
EndIf
If $WardenAttack[$TS] = 1 Then
GUICtrlSetState($chkTSWardenAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSWardenAttack, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroWait[$DB], $HERO_WARDEN) = $HERO_WARDEN Then
GUICtrlSetState($chkDBWardenWait, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBWardenWait, $GUI_UNCHECKED)
EndIf
If BitAND($iHeroWait[$LB], $HERO_WARDEN) = $HERO_WARDEN Then
GUICtrlSetState($chkABWardenWait, $GUI_CHECKED)
Else
GUICtrlSetState($chkABWardenWait, $GUI_UNCHECKED)
EndIf
If $iChkUseCCBalanced = 1 Then
GUICtrlSetState($chkUseCCBalanced, $GUI_CHECKED)
Else
GUICtrlSetState($chkUseCCBalanced, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbCCDonated, $iCmbCCDonated - 1)
_GUICtrlComboBox_SetCurSel($cmbCCReceived, $iCmbCCReceived - 1)
chkBalanceDR()
Switch $iActivateKQCondition
Case "Manual"
GUICtrlSetState($radManAbilities, $GUI_CHECKED)
Case "Auto"
GUICtrlSetState($radAutoAbilities, $GUI_CHECKED)
EndSwitch
If $iActivateWardenCondition = 1 Then
GUICtrlSetState($chkUseWardenAbility, $GUI_CHECKED)
Else
GUICtrlSetState($chkUseWardenAbility, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtManAbilities, ($delayActivateKQ / 1000))
GUICtrlSetData($txtWardenAbility, ($delayActivateW / 1000))
If $TakeLootSnapShot = 1 Then
GUICtrlSetState($chkTakeLootSS, $GUI_CHECKED)
Else
GUICtrlSetState($chkTakeLootSS, $GUI_UNCHECKED)
EndIf
If $ScreenshotLootInfo = 1 Then
GUICtrlSetState($chkScreenshotLootInfo, $GUI_CHECKED)
Else
GUICtrlSetState($chkScreenshotLootInfo, $GUI_UNCHECKED)
EndIf
chkTakeLootSS()
If $ichkAttackNow = 1 Then
GUICtrlSetState($chkAttackNow, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackNow, $GUI_UNCHECKED)
EndIf
chkAttackNow()
_GUICtrlComboBox_SetCurSel($cmbAttackNowDelay, $iAttackNowDelay)
If $OptBullyMode = 1 Then
GUICtrlSetState($BullyCheck, $GUI_CHECKED)
ElseIf $OptBullyMode = 0 Then
GUICtrlSetState($BullyCheck, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtTHaddTiles, $THaddTiles)
GUICtrlSetData($txtTSSearchesMin, $iEnableAfterCount[$TS])
GUICtrlSetData($txtTSSearchesMax, $iEnableBeforeCount[$TS])
GUICtrlSetData($txtTSTropiesMin, $iEnableAfterTropies[$TS])
GUICtrlSetData($txtTSTropiesMax, $iEnableBeforeTropies[$TS])
GUICtrlSetData($txtTSArmyCamps, $iEnableAfterArmyCamps[$TS])
GUICtrlSetData($txtTSMinGold, $iMinGold[$TS])
GUICtrlSetData($txtTSMinElixir, $iMinElixir[$TS])
GUICtrlSetData($txtTSMinGoldPlusElixir, $iMinGoldPlusElixir[$TS])
GUICtrlSetData($txtTSMinDarkElixir, $iMinDark[$TS])
_GUICtrlComboBox_SetCurSel($cmbTSMeetGE, $iCmbMeetGE[$TS])
cmbTSGoldElixir()
chkDBActivateSearches()
chkABActivateSearches()
chkTSActivateSearches()
If $iDBcheck = 1 Then
GUICtrlSetState($DBcheck, $GUI_CHECKED)
Else
GUICtrlSetState($DBcheck, $GUI_UNCHECKED)
EndIf
If $iABcheck = 1 Then
GUICtrlSetState($ABcheck, $GUI_CHECKED)
Else
GUICtrlSetState($ABcheck, $GUI_UNCHECKED)
EndIf
If $iTScheck = 1 Then
GUICtrlSetState($TScheck, $GUI_CHECKED)
Else
GUICtrlSetState($TScheck, $GUI_UNCHECKED)
EndIf
If GUICtrlRead($hGUI_DEADBASE_TAB) = 1 Then cmbDBAlgorithm()
If GUICtrlRead($hGUI_ACTIVEBASE_TAB) = 1 Then cmbABAlgorithm()
GUICtrlSetData($txtDBTimeStopAtk, $sTimeStopAtk[$DB])
If $iChkTimeStopAtk[$DB] = 1 Then
GUICtrlSetState($chkDBTimeStopAtk, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBTimeStopAtk, $GUI_UNCHECKED)
EndIf
chkDBTimeStopAtk()
GUICtrlSetData($txtDBTimeStopAtk2, $sTimeStopAtk2[$DB])
If $iChkTimeStopAtk2[$DB] = 1 Then
GUICtrlSetState($chkDBTimeStopAtk2, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBTimeStopAtk2, $GUI_UNCHECKED)
EndIf
chkDBTimeStopAtk2()
GUICtrlSetData($txtDBMinGoldStopAtk2, $stxtMinGoldStopAtk2[$DB])
GUICtrlSetData($txtDBMinElixirStopAtk2, $stxtMinElixirStopAtk2[$DB])
GUICtrlSetData($txtDBMinDarkElixirStopAtk2, $stxtMinDarkElixirStopAtk2[$DB])
If $ichkEndOneStar[$DB] = 1 Then
GUICtrlSetState($chkDBEndOneStar, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBEndOneStar, $GUI_UNCHECKED)
EndIf
If $ichkEndTwoStars[$DB] = 1 Then
GUICtrlSetState($chkDBEndTwoStars, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBEndTwoStars, $GUI_UNCHECKED)
EndIf
If $ichkEndNoResources[$DB] = 1 Then
GUICtrlSetState($chkDBEndNoResources, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBEndNoResources, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtABTimeStopAtk, $sTimeStopAtk[$LB])
If $iChkTimeStopAtk[$LB] = 1 Then
GUICtrlSetState($chkABTimeStopAtk, $GUI_CHECKED)
Else
GUICtrlSetState($chkABTimeStopAtk, $GUI_UNCHECKED)
EndIf
chkABTimeStopAtk()
GUICtrlSetData($txtABTimeStopAtk2, $sTimeStopAtk2[$LB])
If $iChkTimeStopAtk2[$LB] = 1 Then
GUICtrlSetState($chkABTimeStopAtk2, $GUI_CHECKED)
Else
GUICtrlSetState($chkABTimeStopAtk2, $GUI_UNCHECKED)
EndIf
chkABTimeStopAtk2()
GUICtrlSetData($txtABMinGoldStopAtk2, $stxtMinGoldStopAtk2[$LB])
GUICtrlSetData($txtABMinElixirStopAtk2, $stxtMinElixirStopAtk2[$LB])
GUICtrlSetData($txtABMinDarkElixirStopAtk2, $stxtMinDarkElixirStopAtk2[$LB])
If $ichkEndOneStar[$LB] = 1 Then
GUICtrlSetState($chkABEndOneStar, $GUI_CHECKED)
Else
GUICtrlSetState($chkABEndOneStar, $GUI_UNCHECKED)
EndIf
If $ichkEndTwoStars[$LB] = 1 Then
GUICtrlSetState($chkABEndTwoStars, $GUI_CHECKED)
Else
GUICtrlSetState($chkABEndTwoStars, $GUI_UNCHECKED)
EndIf
If $ichkEndNoResources[$LB] = 1 Then
GUICtrlSetState($chkABEndNoResources, $GUI_CHECKED)
Else
GUICtrlSetState($chkABEndNoResources, $GUI_UNCHECKED)
EndIf
For $i = 0 To UBound($TroopName) - 1
If Eval($TroopName[$i] & "Comp") <> 0 Then
GUICtrlSetData(Eval("txtNum" & $TroopName[$i]), Eval($TroopName[$i] & "Comp"))
Else
GUICtrlSetData(Eval("txtNum" & $TroopName[$i]), 0)
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval($TroopDarkName[$i] & "Comp") <> 0 Then
GUICtrlSetData(Eval("txtNum" & $TroopDarkName[$i]), Eval($TroopDarkName[$i] & "Comp"))
Else
GUICtrlSetData(Eval("txtNum" & $TroopDarkName[$i]), 0)
EndIf
Next
SetComboTroopComp()
lblTotalCount()
GUICtrlSetData($txtFullTroop, $fulltroop)
If $ichkCloseWaitEnable = 1 Then
GUICtrlSetState($chkCloseWaitEnable, $GUI_CHECKED)
_GUI_Value_STATE("ENABLE", $groupCloseWaitTrain)
GUICtrlSetState($lblCloseWaitingTroops, $GUI_ENABLE)
GUICtrlSetState($cmbMinimumTimeClose, $GUI_ENABLE)
GUICtrlSetState($lblSymbolWaiting, $GUI_ENABLE)
GUICtrlSetState($lblWaitingInMinutes, $GUI_ENABLE)
ElseIf $ichkCloseWaitEnable = 0 Then
GUICtrlSetState($chkCloseWaitEnable, $GUI_UNCHECKED)
_GUI_Value_STATE("DISABLE", $groupCloseWaitTrain)
GUICtrlSetState($lblCloseWaitingTroops, $GUI_DISABLE)
GUICtrlSetState($cmbMinimumTimeClose, $GUI_DISABLE)
GUICtrlSetState($lblSymbolWaiting, $GUI_DISABLE)
GUICtrlSetState($lblWaitingInMinutes, $GUI_DISABLE)
EndIf
GUICtrlSetData($cmbMinimumTimeClose, $icmbMinimumTimeClose)
If $ichkCloseWaitTrain = 1 Then
GUICtrlSetState($chkCloseWaitTrain, $GUI_CHECKED)
ElseIf $ichkCloseWaitTrain = 0 Then
GUICtrlSetState($chkCloseWaitTrain, $GUI_UNCHECKED)
EndIf
If $ibtnCloseWaitStop = 1 Then
GUICtrlSetState($btnCloseWaitStop, $GUI_CHECKED)
Else
GUICtrlSetState($btnCloseWaitStop, $GUI_UNCHECKED)
EndIf
If $ibtnCloseWaitStopRandom  = 1 Then
GUICtrlSetState($btnCloseWaitStopRandom , $GUI_CHECKED)
Else
GUICtrlSetState($btnCloseWaitStopRandom , $GUI_UNCHECKED)
EndIf
btnCloseWaitStopRandom()
If $ibtnCloseWaitExact = 1 Then
GUICtrlSetState($btnCloseWaitExact, $GUI_CHECKED)
GUICtrlSetState($btnCloseWaitRandom, $GUI_UNCHECKED)
EndIf
If $ibtnCloseWaitRandom = 1 Then
GUICtrlSetState($btnCloseWaitRandom, $GUI_CHECKED)
GUICtrlSetState($btnCloseWaitExact, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbCloseWaitRdmPercent, $icmbCloseWaitRdmPercent)
btnCloseWaitRandom()
If $ichkTroopOrder = 1 Then
GUICtrlSetState($chkTroopOrder, $GUI_CHECKED)
ElseIf $ichkTroopOrder = 0 Then
GUICtrlSetState($chkTroopOrder, $GUI_UNCHECKED)
EndIf
chkTroopOrder(False)
For $z = 0 To UBound($DefaultTroopGroup) -1
_GUICtrlComboBox_SetCurSel($cmbTroopOrder[$z], $icmbTroopOrder[$z])
GUICtrlSetImage($ImgTroopOrder[$z], $pIconLib, $aTroopOrderIcon[$icmbTroopOrder[$z]+1])
Next
If $ichkTroopOrder = 1 Then
If ChangeTroopTrainOrder() = False Then
SetDefaultTroopGroup()
GUICtrlSetState($chkTroopOrder, $GUI_UNCHECKED)
$ichkTroopOrder = 0
GUICtrlSetState($btnTroopOrderSet, $GUI_DISABLE)
For $i = 0 To UBound($aTroopOrderList) - 2
GUICtrlSetState($cmbTroopOrder[$i], $GUI_DISABLE)
Next
EndIf
EndIf
If $ichkDarkTroopOrder = 1 Then
GUICtrlSetState($chkDarkTroopOrder, $GUI_CHECKED)
ElseIf $ichkDarkTroopOrder = 0 Then
GUICtrlSetState($chkDarkTroopOrder, $GUI_UNCHECKED)
EndIf
chkDarkTroopOrder(False)
For $z = 0 To UBound($DefaultTroopGroupDark) -1
_GUICtrlComboBox_SetCurSel($cmbDarkTroopOrder[$z], $icmbDarkTroopOrder[$z])
GUICtrlSetImage($ImgDarkTroopOrder[$z], $pIconLib, $aDarkTroopOrderIcon[$icmbDarkTroopOrder[$z]+1])
Next
If $ichkDarkTroopOrder = 1 Then
If ChangeDarkTroopTrainOrder() = False Then
SetDefaultTroopGroupDark()
GUICtrlSetState($chkDarkTroopOrder, $GUI_UNCHECKED)
$ichkDarkTroopOrder = 0
GUICtrlSetState($btnDarkTroopOrderSet, $GUI_DISABLE)
For $i = 0 To UBound($aDarkTroopOrderList) - 2
GUICtrlSetState($cmbDarkTroopOrder[$i], $GUI_DISABLE)
Next
EndIf
EndIf
GUICtrlSetData($txtNumLightningSpell, $LSpellComp)
GUICtrlSetData($txtNumRageSpell, $RSpellComp)
GUICtrlSetData($txtNumHealSpell, $HSpellComp)
GUICtrlSetData($txtNumJumpSpell, $JSpellComp)
GUICtrlSetData($txtNumFreezeSpell, $FSpellComp)
GUICtrlSetData($txtNumCloneSpell, $CSpellComp)
GUICtrlSetData($txtNumPoisonSpell, $PSpellComp)
GUICtrlSetData($txtNumEarthSpell, $ESpellComp)
GUICtrlSetData($txtNumHasteSpell, $HaSpellComp)
GUICtrlSetData($txtNumSkeletonSpell, $SkSpellComp)
GUICtrlSetData($txtTotalCountSpell, $iTotalCountSpell)
lblTotalCountSpell()
If $NotifyAlertVillageReport = 1 Then
GUICtrlSetState($chkNotifyAlertVillageStats, $GUI_CHECKED)
ElseIf $NotifyAlertVillageReport = 0 Then
GUICtrlSetState($chkNotifyAlertVillageStats, $GUI_UNCHECKED)
EndIf
If $NotifyAlertLastAttack = 1 Then
GUICtrlSetState($chkNotifyAlertLastAttack, $GUI_CHECKED)
ElseIf $NotifyAlertLastAttack = 0 Then
GUICtrlSetState($chkNotifyAlertLastAttack, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtWall04ST, $itxtWall04ST)
GUICtrlSetData($txtWall05ST, $itxtWall05ST)
GUICtrlSetData($txtWall06ST, $itxtWall06ST)
GUICtrlSetData($txtWall07ST, $itxtWall07ST)
GUICtrlSetData($txtWall08ST, $itxtWall08ST)
GUICtrlSetData($txtWall09ST, $itxtWall09ST)
GUICtrlSetData($txtWall10ST, $itxtWall10ST)
GUICtrlSetData($txtWall11ST, $itxtWall11ST)
_GUICtrlComboBox_SetCurSel($cmbWalls, $icmbWalls)
Switch $iUseStorage
Case 0
GUICtrlSetState($UseGold, $GUI_CHECKED)
Case 1
GUICtrlSetState($UseElixir, $GUI_CHECKED)
Case 2
GUICtrlSetState($UseElixirGold, $GUI_CHECKED)
EndSwitch
If $ichkTrap = 1 Then
GUICtrlSetState($chkTrap, $GUI_CHECKED)
Else
GUICtrlSetState($chkTrap, $GUI_UNCHECKED)
EndIf
chkTrap()
If $iChkCollect = 1 Then
GUICtrlSetState($chkCollect, $GUI_CHECKED)
Else
GUICtrlSetState($chkCollect, $GUI_UNCHECKED)
EndIf
If $ichkTombstones = 1 Then
GUICtrlSetState($chkTombstones, $GUI_CHECKED)
Else
GUICtrlSetState($chkTombstones, $GUI_UNCHECKED)
EndIf
If $ichkCleanYard = 1 Then
GUICtrlSetState($chkCleanYard, $GUI_CHECKED)
Else
GUICtrlSetState($chkCleanYard, $GUI_UNCHECKED)
EndIf
If $ichkGemsBox = 1 Then
GUICtrlSetState($chkGemsBox, $GUI_CHECKED)
Else
GUICtrlSetState($chkGemsBox, $GUI_UNCHECKED)
EndIf
If $iVSDelay > $iMaxVSDelay Then $iMaxVSDelay = $iVSDelay
If $iPlannedRequestCCHoursEnable = 1 Then
GUICtrlSetState($chkRequestCCHours, $GUI_CHECKED)
Else
GUICtrlSetState($chkRequestCCHours, $GUI_UNCHECKED)
EndIf
chkRequestCCHours()
If $iPlannedDonateHoursEnable = 1 Then
GUICtrlSetState($chkDonateHours, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateHours, $GUI_UNCHECKED)
EndIf
chkDonateHours()
If $iPlannedDropCCHoursEnable = 1 Then
GUICtrlSetState($chkDropCCHoursEnable, $GUI_CHECKED)
Else
GUICtrlSetState($chkDropCCHoursEnable, $GUI_UNCHECKED)
EndIf
chkDropCCHoursEnable()
For $i = 0 To 23
If $iPlannedDonateHours[$i] = 1 Then
GUICtrlSetState(Eval("chkDonateHours" & $i), $GUI_CHECKED)
Else
GUICtrlSetState(Eval("chkDonateHours" & $i), $GUI_UNCHECKED)
EndIf
Next
For $i = 0 To 23
If $iPlannedRequestCCHours[$i] = 1 Then
GUICtrlSetState(Eval("chkRequestCCHours" & $i), $GUI_CHECKED)
Else
GUICtrlSetState(Eval("chkRequestCCHours" & $i), $GUI_UNCHECKED)
EndIf
Next
For $i = 0 To 23
If $iPlannedDropCCHours[$i] = 1 Then
GUICtrlSetState(Eval("chkDropCCHours" & $i), $GUI_CHECKED)
Else
GUICtrlSetState(Eval("chkDropCCHours" & $i), $GUI_UNCHECKED)
EndIf
Next
For $i = 0 To 23
If $iPlannedattackHours[$i] = 1 Then
GUICtrlSetState(Eval("chkattackHours" & $i), $GUI_CHECKED)
Else
GUICtrlSetState(Eval("chkattackHours" & $i), $GUI_UNCHECKED)
EndIf
Next
For $i = 0 To 6
If $iPlannedAttackWeekDays[$i] = 1 Then
GUICtrlSetState(Eval("chkAttackWeekdays" & $i), $GUI_CHECKED)
Else
GUICtrlSetState(Eval("chkAttackWeekdays" & $i), $GUI_UNCHECKED)
EndIf
Next
If $ichkAttackPlannerEnable = 1 Then
GUICtrlSetState($chkAttackPlannerEnable, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackPlannerEnable, $GUI_UNCHECKED)
EndIf
If $ichkAttackPlannerCloseCoC  = 1 Then
GUICtrlSetState($chkAttackPlannerCloseCoC , $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackPlannerCloseCoC , $GUI_UNCHECKED)
EndIf
If $ichkAttackPlannerCloseAll = 1 Then
GUICtrlSetState($chkAttackPlannerCloseAll, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackPlannerCloseAll, $GUI_UNCHECKED)
EndIf
If $ichkAttackPlannerRandom  = 1 Then
GUICtrlSetState($chkAttackPlannerRandom , $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackPlannerRandom , $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbAttackPlannerRandom, $icmbAttackPlannerRandom)
If $ichkAttackPlannerDayLimit = 1 Then
GUICtrlSetState($chkAttackPlannerDayLimit, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackPlannerDayLimit, $GUI_UNCHECKED)
EndIf
chkAttackPlannerEnable()
GUICtrlSetData($cmbAttackPlannerDayMin, $icmbAttackPlannerDayMin)
GUICtrlSetData($cmbAttackPlannerDayMax, $icmbAttackPlannerDayMax)
_cmbAttackPlannerDayLimit()
GUICtrlSetData($txtSWTTiles, $itxtSWTtiles)
LoadThSnipeAttacks()
_GUICtrlComboBox_SetCurSel($cmbAttackTHType, _GUICtrlComboBox_FindStringExact($cmbAttackTHType, $scmbAttackTHType))
If $ichkLightSpell[$DB] = 1 Then
GUICtrlSetState($chkDBLightSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBLightSpell, $GUI_UNCHECKED)
EndIf
If $ichkLightSpell[$LB] = 1 Then
GUICtrlSetState($chkABLightSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkABLightSpell, $GUI_UNCHECKED)
EndIf
If $ichkLightSpell[$TS] = 1 Then
GUICtrlSetState($chkTSLightSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSLightSpell, $GUI_UNCHECKED)
EndIf
If $ichkHealSpell[$DB] = 1 Then
GUICtrlSetState($chkDBHealSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBHealSpell, $GUI_UNCHECKED)
EndIf
If $ichkHealSpell[$LB] = 1 Then
GUICtrlSetState($chkABHealSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkABHealSpell, $GUI_UNCHECKED)
EndIf
If $ichkHealSpell[$TS] = 1 Then
GUICtrlSetState($chkTSHealSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSHealSpell, $GUI_UNCHECKED)
EndIf
If $ichkRageSpell[$DB] = 1 Then
GUICtrlSetState($chkDBRageSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBRageSpell, $GUI_UNCHECKED)
EndIf
If $ichkRageSpell[$LB] = 1 Then
GUICtrlSetState($chkABRageSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkABRageSpell, $GUI_UNCHECKED)
EndIf
If $ichkRageSpell[$TS] = 1 Then
GUICtrlSetState($chkTSRageSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSRageSpell, $GUI_UNCHECKED)
EndIf
If $ichkJumpSpell[$DB] = 1 Then
GUICtrlSetState($chkDBJumpSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBJumpSpell, $GUI_UNCHECKED)
EndIf
If $ichkJumpSpell[$LB] = 1 Then
GUICtrlSetState($chkABJumpSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkABJumpSpell, $GUI_UNCHECKED)
EndIf
If $ichkJumpSpell[$TS] = 1 Then
GUICtrlSetState($chkTSJumpSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSJumpSpell, $GUI_UNCHECKED)
EndIf
If $ichkFreezeSpell[$DB] = 1 Then
GUICtrlSetState($chkDBFreezeSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBFreezeSpell, $GUI_UNCHECKED)
EndIf
If $ichkFreezeSpell[$LB] = 1 Then
GUICtrlSetState($chkABFreezeSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkABFreezeSpell, $GUI_UNCHECKED)
EndIf
If $ichkFreezeSpell[$TS] = 1 Then
GUICtrlSetState($chkTSFreezeSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSFreezeSpell, $GUI_UNCHECKED)
EndIf
If $ichkPoisonSpell[$DB] = 1 Then
GUICtrlSetState($chkDBPoisonSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBPoisonSpell, $GUI_UNCHECKED)
EndIf
If $ichkPoisonSpell[$LB] = 1 Then
GUICtrlSetState($chkABPoisonSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkABPoisonSpell, $GUI_UNCHECKED)
EndIf
If $ichkPoisonSpell[$TS] = 1 Then
GUICtrlSetState($chkTSPoisonSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSPoisonSpell, $GUI_UNCHECKED)
EndIf
If $ichkEarthquakeSpell[$DB] = 1 Then
GUICtrlSetState($chkDBEarthquakeSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBEarthquakeSpell, $GUI_UNCHECKED)
EndIf
If $ichkEarthquakeSpell[$LB] = 1 Then
GUICtrlSetState($chkABEarthquakeSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkABEarthquakeSpell, $GUI_UNCHECKED)
EndIf
If $ichkEarthquakeSpell[$TS] = 1 Then
GUICtrlSetState($chkTSEarthquakeSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSEarthquakeSpell, $GUI_UNCHECKED)
EndIf
If $ichkHasteSpell[$DB] = 1 Then
GUICtrlSetState($chkDBHasteSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBHasteSpell, $GUI_UNCHECKED)
EndIf
If $ichkHasteSpell[$LB] = 1 Then
GUICtrlSetState($chkABHasteSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkABHasteSpell, $GUI_UNCHECKED)
EndIf
If $ichkHasteSpell[$TS] = 1 Then
GUICtrlSetState($chkTSHasteSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSHasteSpell, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtRequestCC, $sTxtRequest)
If $iShareAttack = 1 Then
GUICtrlSetState($chkShareAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkShareAttack, $GUI_UNCHECKED)
EndIf
If $ichkDonateBarbarians = 1 Then
GUICtrlSetState($chkDonateBarbarians, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateBarbarians, $GUI_UNCHECKED)
EndIf
chkDonateBarbarians()
If $configLoaded Then GUICtrlSetData($txtDonateBarbarians, $sTxtDonateBarbarians)
If $configLoaded Then GUICtrlSetData($txtBlacklistBarbarians, $sTxtBlacklistBarbarians)
If $ichkDonateArchers = 1 Then
GUICtrlSetState($chkDonateArchers, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateArchers, $GUI_UNCHECKED)
EndIf
chkDonateArchers()
If $configLoaded Then GUICtrlSetData($txtDonateArchers, $sTxtDonateArchers)
If $configLoaded Then GUICtrlSetData($txtBlacklistArchers, $sTxtBlacklistArchers)
If $ichkDonateGiants = 1 Then
GUICtrlSetState($chkDonateGiants, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateGiants, $GUI_UNCHECKED)
EndIf
chkDonateGiants()
If $configLoaded Then GUICtrlSetData($txtDonateGiants, $sTxtDonateGiants)
If $configLoaded Then GUICtrlSetData($txtBlacklistGiants, $sTxtBlacklistGiants)
If $ichkDonateGoblins = 1 Then
GUICtrlSetState($chkDonateGoblins, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateGoblins, $GUI_UNCHECKED)
EndIf
chkDonateGoblins()
If $configLoaded Then GUICtrlSetData($txtDonateGoblins, $sTxtDonateGoblins)
If $configLoaded Then GUICtrlSetData($txtBlacklistGoblins, $sTxtBlacklistGoblins)
If $ichkDonateWallBreakers = 1 Then
GUICtrlSetState($chkDonateWallBreakers, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateWallBreakers, $GUI_UNCHECKED)
EndIf
chkDonateWallBreakers()
If $configLoaded Then GUICtrlSetData($txtDonateWallBreakers, $sTxtDonateWallBreakers)
If $configLoaded Then GUICtrlSetData($txtBlacklistWallBreakers, $sTxtBlacklistWallBreakers)
If $ichkDonateBalloons = 1 Then
GUICtrlSetState($chkDonateBalloons, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateBalloons, $GUI_UNCHECKED)
EndIf
chkDonateBalloons()
If $configLoaded Then GUICtrlSetData($txtDonateBalloons, $sTxtDonateBalloons)
If $configLoaded Then GUICtrlSetData($txtBlacklistBalloons, $sTxtBlacklistBalloons)
If $ichkDonateWizards = 1 Then
GUICtrlSetState($chkDonateWizards, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateWizards, $GUI_UNCHECKED)
EndIf
chkDonateWizards()
If $configLoaded Then GUICtrlSetData($txtDonateWizards, $sTxtDonateWizards)
If $configLoaded Then GUICtrlSetData($txtBlacklistWizards, $sTxtBlacklistWizards)
If $ichkDonateHealers = 1 Then
GUICtrlSetState($chkDonateHealers, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateHealers, $GUI_UNCHECKED)
EndIf
chkDonateHealers()
If $configLoaded Then GUICtrlSetData($txtDonateHealers, $sTxtDonateHealers)
If $configLoaded Then GUICtrlSetData($txtBlacklistHealers, $sTxtBlacklistHealers)
If $ichkDonateDragons = 1 Then
GUICtrlSetState($chkDonateDragons, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateDragons, $GUI_UNCHECKED)
EndIf
chkDonateDragons()
If $configLoaded Then GUICtrlSetData($txtDonateDragons, $sTxtDonateDragons)
If $configLoaded Then GUICtrlSetData($txtBlacklistDragons, $sTxtBlacklistDragons)
If $ichkDonatePekkas = 1 Then
GUICtrlSetState($chkDonatePekkas, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonatePekkas, $GUI_UNCHECKED)
EndIf
chkDonatePekkas()
If $configLoaded Then GUICtrlSetData($txtDonatePekkas, $sTxtDonatePekkas)
If $configLoaded Then GUICtrlSetData($txtBlacklistPekkas, $sTxtBlacklistPekkas)
If $ichkDonateBabyDragons = 1 Then
GUICtrlSetState($chkDonateBabyDragons, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateBabyDragons, $GUI_UNCHECKED)
EndIf
chkDonateBabyDragons()
If $configLoaded Then GUICtrlSetData($txtDonateBabyDragons, $sTxtDonateBabyDragons)
If $configLoaded Then GUICtrlSetData($txtBlacklistBabyDragons, $sTxtBlacklistBabyDragons)
If $ichkDonateMiners = 1 Then
GUICtrlSetState($chkDonateMiners, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateMiners, $GUI_UNCHECKED)
EndIf
chkDonateMiners()
If $configLoaded Then GUICtrlSetData($txtDonateMiners, $sTxtDonateMiners)
If $configLoaded Then GUICtrlSetData($txtBlacklistMiners, $sTxtBlacklistMiners)
If $ichkDonateMinions = 1 Then
GUICtrlSetState($chkDonateMinions, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateMinions, $GUI_UNCHECKED)
EndIf
chkDonateMinions()
If $configLoaded Then GUICtrlSetData($txtDonateMinions, $sTxtDonateMinions)
If $configLoaded Then GUICtrlSetData($txtBlacklistMinions, $sTxtBlacklistMinions)
If $ichkDonateHogRiders = 1 Then
GUICtrlSetState($chkDonateHogRiders, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateHogRiders, $GUI_UNCHECKED)
EndIf
chkDonateHogRiders()
If $configLoaded Then GUICtrlSetData($txtDonateHogRiders, $sTxtDonateHogRiders)
If $configLoaded Then GUICtrlSetData($txtBlacklistHogRiders, $sTxtBlacklistHogRiders)
If $ichkDonateValkyries = 1 Then
GUICtrlSetState($chkDonateValkyries, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateValkyries, $GUI_UNCHECKED)
EndIf
chkDonateValkyries()
If $configLoaded Then GUICtrlSetData($txtDonateValkyries, $sTxtDonateValkyries)
If $configLoaded Then GUICtrlSetData($txtBlacklistValkyries, $sTxtBlacklistValkyries)
If $ichkDonateGolems = 1 Then
GUICtrlSetState($chkDonateGolems, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateGolems, $GUI_UNCHECKED)
EndIf
chkDonateGolems()
If $configLoaded Then GUICtrlSetData($txtDonateGolems, $sTxtDonateGolems)
If $configLoaded Then GUICtrlSetData($txtBlacklistGolems, $sTxtBlacklistGolems)
If $ichkDonateWitches = 1 Then
GUICtrlSetState($chkDonateWitches, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateWitches, $GUI_UNCHECKED)
EndIf
chkDonateWitches()
If $configLoaded Then GUICtrlSetData($txtDonateWitches, $sTxtDonateWitches)
If $configLoaded Then GUICtrlSetData($txtBlacklistWitches, $sTxtBlacklistWitches)
If $ichkDonateLavaHounds = 1 Then
GUICtrlSetState($chkDonateLavaHounds, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateLavaHounds, $GUI_UNCHECKED)
EndIf
chkDonateLavaHounds()
If $configLoaded Then GUICtrlSetData($txtDonateLavaHounds, $sTxtDonateLavaHounds)
If $configLoaded Then GUICtrlSetData($txtBlacklistLavaHounds, $sTxtBlacklistLavaHounds)
If $ichkDonateBowlers = 1 Then
GUICtrlSetState($chkDonateBowlers, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateBowlers, $GUI_UNCHECKED)
EndIf
chkDonateBowlers()
If $configLoaded Then GUICtrlSetData($txtDonateBowlers, $sTxtDonateBowlers)
If $configLoaded Then GUICtrlSetData($txtBlacklistBowlers, $sTxtBlacklistBowlers)
If $ichkDonatePoisonSpells = 1 Then
GUICtrlSetState($chkDonatePoisonSpells, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonatePoisonSpells, $GUI_UNCHECKED)
EndIf
chkDonatePoisonSpells()
If $configLoaded Then GUICtrlSetData($txtDonatePoisonSpells, $sTxtDonatePoisonSpells)
If $configLoaded Then GUICtrlSetData($txtBlacklistPoisonSpells, $sTxtBlacklistPoisonSpells)
If $ichkDonateEarthQuakeSpells = 1 Then
GUICtrlSetState($chkDonateEarthQuakeSpells, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateEarthQuakeSpells, $GUI_UNCHECKED)
EndIf
chkDonateEarthQuakeSpells()
If $configLoaded Then GUICtrlSetData($txtDonateEarthQuakeSpells, $sTxtDonateEarthQuakeSpells)
If $configLoaded Then GUICtrlSetData($txtBlacklistEarthQuakeSpells, $sTxtBlacklistEarthQuakeSpells)
If $ichkDonateHasteSpells = 1 Then
GUICtrlSetState($chkDonateHasteSpells, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateHasteSpells, $GUI_UNCHECKED)
EndIf
chkDonateHasteSpells()
If $configLoaded Then GUICtrlSetData($txtDonateHasteSpells, $sTxtDonateHasteSpells)
If $configLoaded Then GUICtrlSetData($txtBlacklistHasteSpells, $sTxtBlacklistHasteSpells)
If $ichkDonateSkeletonSpells = 1 Then
GUICtrlSetState($chkDonateSkeletonSpells, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateSkeletonSpells, $GUI_UNCHECKED)
EndIf
chkDonateSkeletonSpells()
If $configLoaded Then GUICtrlSetData($txtDonateSkeletonSpells, $sTxtDonateSkeletonSpells)
If $configLoaded Then GUICtrlSetData($txtBlacklistSkeletonSpells, $sTxtBlacklistSkeletonSpells)
If $ichkDonateCustomA = 1 Then
GUICtrlSetState($chkDonateCustomA, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateCustomA, $GUI_UNCHECKED)
EndIf
chkDonateCustomA()
If $configLoaded Then GUICtrlSetData($txtDonateCustomA, $sTxtDonateCustomA)
If $configLoaded Then GUICtrlSetData($txtBlacklistCustomA, $sTxtBlacklistCustomA)
_GUICtrlComboBox_SetCurSel($cmbDonateCustomA1, $varDonateCustomA[0][0])
GUICtrlSetData($txtDonateCustomA1, $varDonateCustomA[0][1])
_GUICtrlComboBox_SetCurSel($cmbDonateCustomA2, $varDonateCustomA[1][0])
GUICtrlSetData($txtDonateCustomA2, $varDonateCustomA[1][1])
_GUICtrlComboBox_SetCurSel($cmbDonateCustomA3, $varDonateCustomA[2][0])
GUICtrlSetData($txtDonateCustomA3, $varDonateCustomA[2][1])
cmbDonateCustomA()
If $ichkDonateCustomB = 1 Then
GUICtrlSetState($chkDonateCustomB, $GUI_CHECKED)
Else
GUICtrlSetState($chkDonateCustomB, $GUI_UNCHECKED)
EndIf
chkDonateCustomB()
If $configLoaded Then GUICtrlSetData($txtDonateCustomB, $sTxtDonateCustomB)
If $configLoaded Then GUICtrlSetData($txtBlacklistCustomB, $sTxtBlacklistCustomB)
_GUICtrlComboBox_SetCurSel($cmbDonateCustomB1, $varDonateCustomB[0][0])
GUICtrlSetData($txtDonateCustomB1, $varDonateCustomB[0][1])
_GUICtrlComboBox_SetCurSel($cmbDonateCustomB2, $varDonateCustomB[1][0])
GUICtrlSetData($txtDonateCustomB2, $varDonateCustomB[1][1])
_GUICtrlComboBox_SetCurSel($cmbDonateCustomB3, $varDonateCustomB[2][0])
GUICtrlSetData($txtDonateCustomB3, $varDonateCustomB[2][1])
cmbDonateCustomB()
GUICtrlSetData($txtBlacklist, $sTxtBlacklist)
If $ichkDonateAllBarbarians = 1 Then
GUICtrlSetState($chkDonateAllBarbarians, $GUI_CHECKED)
_DonateAllControls($eBarb, True)
Else
GUICtrlSetState($chkDonateAllBarbarians, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllArchers = 1 Then
GUICtrlSetState($chkDonateAllArchers, $GUI_CHECKED)
_DonateAllControls($eArch, True)
Else
GUICtrlSetState($chkDonateAllArchers, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllGiants = 1 Then
GUICtrlSetState($chkDonateAllGiants, $GUI_CHECKED)
_DonateAllControls($eGiant, True)
Else
GUICtrlSetState($chkDonateAllGiants, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllGoblins = 1 Then
GUICtrlSetState($chkDonateAllGoblins, $GUI_CHECKED)
_DonateAllControls($eGobl, True)
Else
GUICtrlSetState($chkDonateAllGoblins, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllWallBreakers = 1 Then
GUICtrlSetState($chkDonateAllWallBreakers, $GUI_CHECKED)
_DonateAllControls($eWall, True)
Else
GUICtrlSetState($chkDonateAllWallBreakers, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllBalloons = 1 Then
GUICtrlSetState($chkDonateAllBalloons, $GUI_CHECKED)
_DonateAllControls($eBall, True)
Else
GUICtrlSetState($chkDonateAllBalloons, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllWizards = 1 Then
GUICtrlSetState($chkDonateAllWizards, $GUI_CHECKED)
_DonateAllControls($eWiza, True)
Else
GUICtrlSetState($chkDonateAllWizards, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllHealers = 1 Then
GUICtrlSetState($chkDonateAllHealers, $GUI_CHECKED)
_DonateAllControls($eHeal, True)
Else
GUICtrlSetState($chkDonateAllHealers, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllDragons = 1 Then
GUICtrlSetState($chkDonateAllDragons, $GUI_CHECKED)
_DonateAllControls($eDrag, True)
Else
GUICtrlSetState($chkDonateAllDragons, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllPekkas = 1 Then
GUICtrlSetState($chkDonateAllPekkas, $GUI_CHECKED)
_DonateAllControls($ePekk, True)
Else
GUICtrlSetState($chkDonateAllPekkas, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllBabyDragons = 1 Then
GUICtrlSetState($chkDonateAllBabyDragons, $GUI_CHECKED)
_DonateAllControls($eBabyD, True)
Else
GUICtrlSetState($chkDonateAllBabyDragons, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllMiners = 1 Then
GUICtrlSetState($chkDonateAllMiners, $GUI_CHECKED)
_DonateAllControls($eMine, True)
Else
GUICtrlSetState($chkDonateAllMiners, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllMinions = 1 Then
GUICtrlSetState($chkDonateAllMinions, $GUI_CHECKED)
_DonateAllControls($eMini, True)
Else
GUICtrlSetState($chkDonateAllMinions, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllHogRiders = 1 Then
GUICtrlSetState($chkDonateAllHogRiders, $GUI_CHECKED)
_DonateAllControls($eHogs, True)
Else
GUICtrlSetState($chkDonateAllHogRiders, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllValkyries = 1 Then
GUICtrlSetState($chkDonateAllValkyries, $GUI_CHECKED)
_DonateAllControls($eValk, True)
Else
GUICtrlSetState($chkDonateAllValkyries, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllGolems = 1 Then
GUICtrlSetState($chkDonateAllGolems, $GUI_CHECKED)
_DonateAllControls($eGole, True)
Else
GUICtrlSetState($chkDonateAllGolems, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllWitches = 1 Then
GUICtrlSetState($chkDonateAllWitches, $GUI_CHECKED)
_DonateAllControls($eWitc, True)
Else
GUICtrlSetState($chkDonateAllWitches, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllLavaHounds = 1 Then
GUICtrlSetState($chkDonateAllLavaHounds, $GUI_CHECKED)
_DonateAllControls($eLava, True)
Else
GUICtrlSetState($chkDonateAllLavaHounds, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllBowlers = 1 Then
GUICtrlSetState($chkDonateAllBowlers, $GUI_CHECKED)
_DonateAllControls($eLava, True)
Else
GUICtrlSetState($chkDonateAllBowlers, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllPoisonSpells = 1 Then
GUICtrlSetState($chkDonateAllPoisonSpells, $GUI_CHECKED)
_DonateAllControlsSpell(0, True)
Else
GUICtrlSetState($chkDonateAllPoisonSpells, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllEarthQuakeSpells = 1 Then
GUICtrlSetState($chkDonateAllEarthQuakeSpells, $GUI_CHECKED)
_DonateAllControlsSpell(1, True)
Else
GUICtrlSetState($chkDonateAllEarthQuakeSpells, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllHasteSpells = 1 Then
GUICtrlSetState($chkDonateAllHasteSpells, $GUI_CHECKED)
_DonateAllControlsSpell(2, True)
Else
GUICtrlSetState($chkDonateAllHasteSpells, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllSkeletonSpells = 1 Then
GUICtrlSetState($chkDonateAllSkeletonSpells, $GUI_CHECKED)
_DonateAllControlsSpell(2, True)
Else
GUICtrlSetState($chkDonateAllSkeletonSpells, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllCustomA = 1 Then
GUICtrlSetState($chkDonateAllCustomA, $GUI_CHECKED)
_DonateAllControls(19, True)
Else
GUICtrlSetState($chkDonateAllCustomA, $GUI_UNCHECKED)
EndIf
If $ichkDonateAllCustomB = 1 Then
GUICtrlSetState($chkDonateAllCustomB, $GUI_CHECKED)
_DonateAllControls(20, True)
Else
GUICtrlSetState($chkDonateAllCustomB, $GUI_UNCHECKED)
EndIf
If $ichkExtraAlphabets = 0 Then
GUICtrlSetState($chkExtraAlphabets, $GUI_UNCHECKED)
ElseIf $ichkExtraAlphabets = 1 Then
GUICtrlSetState($chkExtraAlphabets, $GUI_CHECKED)
EndIf
PopulatePresetComboBox()
MakeSavePresetMessage()
GUICtrlSetState($lblLoadPresetMessage, $GUI_SHOW)
GUICtrlSetState($txtPresetMessage, $GUI_HIDE)
GUICtrlSetState($btnGUIPresetLoadConf, $GUI_HIDE)
GUICtrlSetState($btnGUIPresetDeleteConf, $GUI_HIDE + $GUI_DISABLE)
GUICtrlSetState($chkCheckDeleteConf, $GUI_HIDE + $GUI_UNCHECKED)
GUICtrlSetState($chkCheckDeleteConf, $GUI_HIDE)
If $NotifyPBEnabled = 1 Then
GUICtrlSetState($chkNotifyPBEnabled, $GUI_CHECKED)
ElseIf $NotifyPBEnabled = 0 Then
GUICtrlSetState($chkNotifyPBEnabled, $GUI_UNCHECKED)
EndIf
If $NotifyTGEnabled = 1 Then
GUICtrlSetState($chkTGenabled, $GUI_CHECKED)
ElseIf $NotifyTGEnabled = 0 Then
GUICtrlSetState($chkTGenabled, $GUI_UNCHECKED)
EndIf
chkPBTGenabled()
If $NotifyRemoteEnable = 1 Then
GUICtrlSetState($chkNotifyRemote, $GUI_CHECKED)
ElseIf $NotifyRemoteEnable = 0 Then
GUICtrlSetState($chkNotifyRemote, $GUI_UNCHECKED)
EndIf
If $NotifyDeleteAllPushesOnStart = 1 Then
GUICtrlSetState($chkNotifyDeleteAllPBPushes, $GUI_CHECKED)
ElseIf $NotifyDeleteAllPushesOnStart = 0 Then
GUICtrlSetState($chkNotifyDeleteAllPBPushes, $GUI_UNCHECKED)
EndIf
If $NotifyDeletePushesOlderThan = 1 Then
GUICtrlSetState($chkNotifyDeleteOldPBPushes, $GUI_CHECKED)
ElseIf $NotifyDeletePushesOlderThan = 0 Then
GUICtrlSetState($chkNotifyDeleteOldPBPushes, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbNotifyPushHours, $NotifyDeletePushesOlderThanHours)
If $NotifyAlertMatchFound = 1 Then
GUICtrlSetState($chkNotifyAlertMatchFound, $GUI_CHECKED)
ElseIf $NotifyAlertMatchFound = 0 Then
GUICtrlSetState($chkNotifyAlertMatchFound, $GUI_UNCHECKED)
EndIf
If $NotifyAlerLastRaidIMG = 1 Then
GUICtrlSetState($chkNotifyAlertLastRaidIMG, $GUI_CHECKED)
ElseIf $NotifyAlerLastRaidIMG = 0 Then
GUICtrlSetState($chkNotifyAlertLastRaidIMG, $GUI_UNCHECKED)
EndIf
If $NotifyAlertUpgradeWalls = 1 Then
GUICtrlSetState($chkNotifyAlertUpgradeWall, $GUI_CHECKED)
ElseIf $NotifyAlertUpgradeWalls = 0 Then
GUICtrlSetState($chkNotifyAlertUpgradeWall, $GUI_UNCHECKED)
EndIf
If $NotifyAlertOutOfSync = 1 Then
GUICtrlSetState($chkNotifyAlertOutOfSync, $GUI_CHECKED)
ElseIf $NotifyAlertOutOfSync = 0 Then
GUICtrlSetState($chkNotifyAlertOutOfSync, $GUI_UNCHECKED)
EndIf
If $NotifyAlertTakeBreak = 1 Then
GUICtrlSetState($chkNotifyAlertTakeBreak, $GUI_CHECKED)
ElseIf $NotifyAlertTakeBreak = 0 Then
GUICtrlSetState($chkNotifyAlertTakeBreak, $GUI_UNCHECKED)
EndIf
If $NotifyAlertAnotherDevice = 1 Then
GUICtrlSetState($chkNotifyAlertAnotherDevice, $GUI_CHECKED)
ElseIf $NotifyAlertAnotherDevice = 0 Then
GUICtrlSetState($chkNotifyAlertAnotherDevice, $GUI_UNCHECKED)
EndIf
If $NotifyDeletePushesOlderThan = 1 Then
GUICtrlSetState($chkNotifyDeleteOldPBPushes, $GUI_CHECKED)
Else
GUICtrlSetState($chkNotifyDeleteOldPBPushes, $GUI_UNCHECKED)
EndIf
chkDeleteOldPBPushes()
If $NotifyAlerLastRaidTXT = 1 Then
GUICtrlSetState($chkNotifyAlertLastRaidTXT, $GUI_CHECKED)
ElseIf $NotifyAlerLastRaidTXT = 0 Then
GUICtrlSetState($chkNotifyAlertLastRaidTXT, $GUI_UNCHECKED)
EndIf
If $NotifyAlertCampFull = 1 Then
GUICtrlSetState($chkNotifyAlertCampFull, $GUI_CHECKED)
ElseIf $NotifyAlertCampFull = 0 Then
GUICtrlSetState($chkNotifyAlertCampFull, $GUI_UNCHECKED)
EndIf
If $NotifyAlertVillageReport = 1 Then
GUICtrlSetState($chkNotifyAlertVillageStats, $GUI_CHECKED)
ElseIf $NotifyAlertVillageReport = 0 Then
GUICtrlSetState($chkNotifyAlertVillageStats, $GUI_UNCHECKED)
EndIf
If $NotifyAlertLastAttack = 1 Then
GUICtrlSetState($chkNotifyAlertLastAttack, $GUI_CHECKED)
ElseIf $NotifyAlertLastAttack = 0 Then
GUICtrlSetState($chkNotifyAlertLastAttack, $GUI_UNCHECKED)
EndIf
If $NotifyAlertBulderIdle = 1 Then
GUICtrlSetState($chkNotifyAlertBuilderIdle, $GUI_CHECKED)
ElseIf $NotifyAlertBulderIdle = 0 Then
GUICtrlSetState($chkNotifyAlertBuilderIdle, $GUI_UNCHECKED)
EndIf
If $NotifyAlertMaintenance = 1 Then
GUICtrlSetState($chkNotifyAlertMaintenance, $GUI_CHECKED)
ElseIf $NotifyAlertMaintenance = 0 Then
GUICtrlSetState($chkNotifyAlertMaintenance, $GUI_UNCHECKED)
EndIf
If $NotifyAlertBAN = 1 Then
GUICtrlSetState($chkNotifyAlertBAN, $GUI_CHECKED)
ElseIf $NotifyAlertBAN = 0 Then
GUICtrlSetState($chkNotifyAlertBAN, $GUI_UNCHECKED)
EndIf
If $NotifyAlertBOTUpdate = 1 Then
GUICtrlSetState($chkNotifyBOTUpdate, $GUI_CHECKED)
ElseIf $NotifyAlertBOTUpdate = 0 Then
GUICtrlSetState($chkNotifyBOTUpdate, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txbNotifyPBToken, $NotifyPBToken)
GUICtrlSetData($txbNotifyTGToken, $NotifyTGToken)
GUICtrlSetData($txbNotifyOrigin, $NotifyOrigin)
If $NotifyScheduleHoursEnable = 1 Then
GUICtrlSetState($chkNotifyHours, $GUI_CHECKED)
Else
GUICtrlSetState($chkNotifyHours, $GUI_UNCHECKED)
EndIf
chkNotifyHours()
For $i = 0 To 23
If $NotifyScheduleHours[$i] = 1 Then
GUICtrlSetState(Eval("chkNotifyHours" & $i), $GUI_CHECKED)
Else
GUICtrlSetState(Eval("chkNotifyHours" & $i), $GUI_UNCHECKED)
EndIf
Next
If $NotifyScheduleWeekDaysEnable = 1 Then
GUICtrlSetState($chkNotifyWeekDays, $GUI_CHECKED)
Else
GUICtrlSetState($chkNotifyWeekDays, $GUI_UNCHECKED)
EndIf
chkNotifyWeekDays()
For $i = 0 To 6
If $NotifyScheduleWeekDays[$i] = 1 Then
GUICtrlSetState(Eval("chkNotifyWeekdays" & $i), $GUI_CHECKED)
Else
GUICtrlSetState(Eval("chkNotifyWeekdays" & $i), $GUI_UNCHECKED)
EndIf
Next
If $ichkLab = 1 Then
GUICtrlSetState($chkLab, $GUI_CHECKED)
Else
GUICtrlSetState($chkLab, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbLaboratory, $icmbLaboratory)
GUICtrlSetImage($icnLabUpgrade, $pIconLib, $aLabTroops[$icmbLaboratory][4])
chkLab()
If $ichkUpgradeKing = 1 Then
GUICtrlSetState($chkUpgradeKing, $GUI_CHECKED)
Else
GUICtrlSetState($chkUpgradeKing, $GUI_UNCHECKED)
EndIf
chkUpgradeKing()
chkDBKingWait()
chkABKingWait()
If $ichkUpgradeQueen = 1 Then
GUICtrlSetState($chkUpgradeQueen, $GUI_CHECKED)
Else
GUICtrlSetState($chkUpgradeQueen, $GUI_UNCHECKED)
EndIf
chkUpgradeQueen()
chkDBQueenWait()
chkABQueenWait()
If $ichkUpgradeWarden = 1 Then
GUICtrlSetState($chkUpgradeWarden, $GUI_CHECKED)
Else
GUICtrlSetState($chkUpgradeWarden, $GUI_UNCHECKED)
EndIf
chkUpgradeWarden()
chkDBWardenWait()
chkABWardenWait()
For $iz = 0 To UBound($aUpgrades, 1) - 1
GUICtrlSetImage($picUpgradeStatus[$iz], $pIconLib, $ipicUpgradeStatus[$iz])
If $aUpgrades[$iz][2] > 0 Then
GUICtrlSetData($txtUpgradeValue[$iz], _NumberFormat($aUpgrades[$iz][2]))
Else
GUICtrlSetData($txtUpgradeValue[$iz], "")
EndIf
GUICtrlSetData($txtUpgradeName[$iz], $aUpgrades[$iz][4])
GUICtrlSetData($txtUpgradeLevel[$iz], $aUpgrades[$iz][5])
GUICtrlSetData($txtUpgradeTime[$iz], StringStripWS($aUpgrades[$iz][6], $STR_STRIPALL))
Switch $aUpgrades[$iz][3]
Case "Gold"
GUICtrlSetImage($picUpgradeType[$iz], $pIconLib, $eIcnGold)
Case "Elixir"
GUICtrlSetImage($picUpgradeType[$iz], $pIconLib, $eIcnElixir)
Case "Dark"
GUICtrlSetImage($picUpgradeType[$iz], $pIconLib, $eIcnDark)
Case Else
GUICtrlSetImage($picUpgradeType[$iz], $pIconLib, $eIcnBlank)
EndSwitch
If $ichkbxUpgrade[$iz] = 1 Then
GUICtrlSetState($chkbxUpgrade[$iz], $GUI_CHECKED)
Else
GUICtrlSetState($chkbxUpgrade[$iz], $GUI_UNCHECKED)
EndIf
If $ichkUpgrdeRepeat[$iz] = 1 Then
GUICtrlSetState($chkUpgrdeRepeat[$iz], $GUI_CHECKED)
Else
GUICtrlSetState($chkUpgrdeRepeat[$iz], $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtUpgradeEndTime[$iz], $aUpgrades[$iz][7])
Next
GUICtrlSetData($txtUpgrMinGold, $itxtUpgrMinGold)
GUICtrlSetData($txtUpgrMinElixir, $itxtUpgrMinElixir)
GUICtrlSetData($txtUpgrMinDark, $itxtUpgrMinDark)
_GUICtrlComboBox_SetCurSel($cmbWalls, $icmbWalls)
Switch $iUseStorage
Case 0
GUICtrlSetState($UseGold, $GUI_CHECKED)
Case 1
GUICtrlSetState($UseElixir, $GUI_CHECKED)
Case 2
GUICtrlSetState($UseElixirGold, $GUI_CHECKED)
EndSwitch
GUICtrlSetData($txtWallMinGold, $itxtWallMinGold)
GUICtrlSetData($txtWallMinElixir, $itxtWallMinElixir)
cmbWalls()
If $ichkWalls = 1 Then
GUICtrlSetState($chkWalls, $GUI_CHECKED)
Else
GUICtrlSetState($chkWalls, $GUI_UNCHECKED)
EndIf
chkWalls()
GUICtrlSetData($sldMaxNbWall, $iMaxNbWall)
If $iSaveWallBldr = 1 Then
GUICtrlSetState($chkSaveWallBldr, $GUI_CHECKED)
Else
GUICtrlSetState($chkSaveWallBldr, $GUI_UNCHECKED)
EndIf
If $ichkUpgradeContinually = 1 Then
GUICtrlSetState($chkUpgradeContinually, $GUI_CHECKED)
Else
GUICtrlSetState($chkUpgradeContinually, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtWall04ST, $itxtWall04ST)
GUICtrlSetData($txtWall05ST, $itxtWall05ST)
GUICtrlSetData($txtWall06ST, $itxtWall06ST)
GUICtrlSetData($txtWall07ST, $itxtWall07ST)
GUICtrlSetData($txtWall08ST, $itxtWall08ST)
GUICtrlSetData($txtWall09ST, $itxtWall09ST)
GUICtrlSetData($txtWall10ST, $itxtWall10ST)
GUICtrlSetData($txtWall11ST, $itxtWall11ST)
GUICtrlSetData($txtUpgrMinGold, $itxtUpgrMinGold)
GUICtrlSetData($txtUpgrMinElixir, $itxtUpgrMinElixir)
GUICtrlSetData($txtUpgrMinDark, $itxtUpgrMinDark)
GUICtrlSetData($txtUnbreakable, $iUnbreakableWait)
GUICtrlSetData($txtUnBrkMinGold, $iUnBrkMinGold)
GUICtrlSetData($txtUnBrkMinElixir, $iUnBrkMinElixir)
GUICtrlSetData($txtUnBrkMinDark, $iUnBrkMinDark)
GUICtrlSetData($txtUnBrkMaxGold, $iUnBrkMaxGold)
GUICtrlSetData($txtUnBrkMaxElixir, $iUnBrkMaxElixir)
GUICtrlSetData($txtUnBrkMaxDark, $iUnBrkMaxDark)
If $iUnbreakableMode = 1 Then
GUICtrlSetState($chkUnbreakable, $GUI_CHECKED)
Else
GUICtrlSetState($chkUnbreakable, $GUI_UNCHECKED)
EndIf
chkUnbreakable()
If $ichkBotStop = 1 Then
GUICtrlSetState($chkBotStop, $GUI_CHECKED)
Else
GUICtrlSetState($chkBotStop, $GUI_UNCHECKED)
EndIf
chkBotStop()
_GUICtrlComboBox_SetCurSel($cmbBotCommand, $icmbBotCommand)
_GUICtrlComboBox_SetCurSel($cmbBotCond, $icmbBotCond)
_GUICtrlComboBox_SetCurSel($cmbHoursStop, $icmbHoursStop)
cmbBotCond()
GUICtrlSetData($txtTimeWakeUp, Int(Int($sTimeWakeUp) / 60))
GUICtrlSetData($txtRestartGold, $itxtRestartGold)
GUICtrlSetData($txtRestartElixir, $itxtRestartElixir)
GUICtrlSetData($txtRestartDark, $itxtRestartDark)
If $ichkDisableSplash = 1 Then
GUICtrlSetState($chkDisableSplash, $GUI_CHECKED)
Else
GUICtrlSetState($chkDisableSplash, $GUI_UNCHECKED)
EndIf
If $ichkVersion = 1 Then
GUICtrlSetState($chkVersion, $GUI_CHECKED)
Else
GUICtrlSetState($chkVersion, $GUI_UNCHECKED)
EndIf
If $ichkDeleteLogs = 1 Then
GUICtrlSetState($chkDeleteLogs, $GUI_CHECKED)
Else
GUICtrlSetState($chkDeleteLogs, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtDeleteLogsDays, $iDeleteLogsDays)
chkDeleteLogs()
If $ichkDeleteTemp = 1 Then
GUICtrlSetState($chkDeleteTemp, $GUI_CHECKED)
Else
GUICtrlSetState($chkDeleteTemp, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtDeleteTempDays, $iDeleteTempDays)
chkDeleteTemp()
If $ichkDeleteLoots = 1 Then
GUICtrlSetState($chkDeleteLoots, $GUI_CHECKED)
Else
GUICtrlSetState($chkDeleteLoots, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtDeleteLootsDays, $iDeleteLootsDays)
chkDeleteLoots()
If $ichkAutoStart = 1 Then
GUICtrlSetState($chkAutoStart, $GUI_CHECKED)
Else
GUICtrlSetState($chkAutoStart, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtAutoStartDelay, $ichkAutoStartDelay)
chkAutoStart()
If $ichkLanguage = 1 Then
GUICtrlSetState($ChkLanguage, $GUI_CHECKED)
Else
GUICtrlSetState($ChkLanguage, $GUI_UNCHECKED)
EndIf
If $iDisposeWindows = 1 Then
GUICtrlSetState($chkDisposeWindows, $GUI_CHECKED)
Else
GUICtrlSetState($chkDisposeWindows, $GUI_UNCHECKED)
EndIf
chkDisposeWindows()
_GUICtrlComboBox_SetCurSel($cmbDisposeWindowsCond, $icmbDisposeWindowsPos)
GUICtrlSetData($txtWAOffsetX, $iWAOffsetX)
GUICtrlSetData($txtWAOffsetY, $iWAOffsetY)
If $debugClick = 1 Then
GUICtrlSetState($chkDebugClick, $GUI_CHECKED)
Else
GUICtrlSetState($chkDebugClick, $GUI_UNCHECKED)
EndIf
If $DebugSetlog = 1 Then
GUICtrlSetState($chkDebugSetlog, $GUI_CHECKED)
Else
GUICtrlSetState($chkDebugSetlog, $GUI_UNCHECKED)
EndIf
If $debugOcr = 1 Then
GUICtrlSetState($chkDebugOcr, $GUI_CHECKED)
Else
GUICtrlSetState($chkDebugOcr, $GUI_UNCHECKED)
EndIf
If $DebugImageSave = 1 Then
GUICtrlSetState($chkDebugImageSave, $GUI_CHECKED)
Else
GUICtrlSetState($chkDebugImageSave, $GUI_UNCHECKED)
EndIf
If $debugBuildingPos = 1 Then
GUICtrlSetState($chkdebugBuildingPos, $GUI_CHECKED)
Else
GUICtrlSetState($chkdebugBuildingPos, $GUI_UNCHECKED)
EndIf
If $debugsetlogTrain = 1 Then
GUICtrlSetState($chkdebugTrain, $GUI_CHECKED)
Else
GUICtrlSetState($chkdebugTrain, $GUI_UNCHECKED)
EndIf
If $debugOCRdonate = 1 Then
GUICtrlSetState($chkdebugOCRDonate, $GUI_CHECKED)
Else
GUICtrlSetState($chkdebugOCRDonate, $GUI_UNCHECKED)
EndIf
If $ichkUseQTrain = 1 Then
GUICtrlSetState($hChk_UseQTrain, $GUI_CHECKED)
Else
GUICtrlSetState($hChk_UseQTrain, $GUI_UNCHECKED)
EndIf
chkUseQTrain()
If $ichkForceBrewBeforeAttack = 1 Then
GUICtrlSetState($chkForceBrewBeforeAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkForceBrewBeforeAttack, $GUI_UNCHECKED)
EndIf
If $ichkTotalCampForced = 1 Then
GUICtrlSetState($chkTotalCampForced, $GUI_CHECKED)
Else
GUICtrlSetState($chkTotalCampForced, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtTotalCampForced, $iValueTotalCampForced)
chkTotalCampForced()
If $ichkSinglePBTForced = 1 Then
GUICtrlSetState($chkSinglePBTForced, $GUI_CHECKED)
Else
GUICtrlSetState($chkSinglePBTForced, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtSinglePBTimeForced, $iValueSinglePBTimeForced)
GUICtrlSetData($txtPBTimeForcedExit, $iValuePBTimeForcedExit)
chkSinglePBTForced()
LoadLanguagesComboBox()
_GUICtrlComboBox_SetCurSel($cmbLanguage, _GUICtrlComboBox_FindStringExact($cmbLanguage, $aLanguageFile[_ArraySearch($aLanguageFile, $sLanguage)][1]))
If $iUseRandomClick = 1 Then
GUICtrlSetState($chkUseRandomClick, $GUI_CHECKED)
Else
GUICtrlSetState($chkUseRandomClick, $GUI_UNCHECKED)
EndIf
If $iScreenshotType = 1 Then
GUICtrlSetState($chkScreenshotType, $GUI_CHECKED)
Else
GUICtrlSetState($chkScreenshotType, $GUI_UNCHECKED)
EndIf
If $ichkScreenshotHideName = 1 Then
GUICtrlSetState($chkScreenshotHideName, $GUI_CHECKED)
Else
GUICtrlSetState($chkScreenshotHideName, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($sldVSDelay, $iVSDelay)
GUICtrlSetData($lblVSDelay, $iVSDelay)
GUICtrlSetData($sldMaxVSDelay, $iMaxVSDelay)
GUICtrlSetData($lblMaxVSDelay, $iMaxVSDelay)
GUICtrlSetData($sldTrainITDelay, $isldTrainITDelay)
sldTrainITDelay()
GUICtrlSetData($lbltxtTrainITDelayTime, $isldTrainITDelay & " ms")
If $AlertSearch = 1 Then
GUICtrlSetState($chkAlertSearch, $GUI_CHECKED)
Else
GUICtrlSetState($chkAlertSearch, $GUI_UNCHECKED)
EndIf
If $devmode = 1 Then
GUICtrlSetState($chkDebugSetlog, $GUI_ENABLE)
GUICtrlSetState($chkDebugOcr, $GUI_ENABLE)
GUICtrlSetState($chkDebugImageSave, $GUI_ENABLE)
GUICtrlSetState($chkdebugBuildingPos, $GUI_ENABLE)
GUICtrlSetState($chkdebugTrain, $GUI_ENABLE)
GUICtrlSetState($chkmakeIMGCSV, $GUI_ENABLE)
EndIf
_GUICtrlComboBox_SetCurSel($cmbBoostBarracks, $icmbBoostBarracks)
_GUICtrlComboBox_SetCurSel($cmbBoostSpellFactory, $icmbBoostSpellFactory)
_GUICtrlComboBox_SetCurSel($cmbBoostBarbarianKing, $icmbBoostBarbarianKing)
_GUICtrlComboBox_SetCurSel($cmbBoostArcherQueen, $icmbBoostArcherQueen)
_GUICtrlComboBox_SetCurSel($cmbBoostWarden, $icmbBoostWarden)
For $i = 0 To 23
If $iPlannedBoostBarracksHours[$i] = 1 Then
GUICtrlSetState(Eval("chkBoostBarracksHours" & $i), $GUI_CHECKED)
Else
GUICtrlSetState(Eval("chkBoostBarracksHours" & $i), $GUI_UNCHECKED)
EndIf
Next
GUICtrlSetData($txtSearchReduceCount, $ReduceCount)
GUICtrlSetData($txtSearchReduceGold, $ReduceGold)
GUICtrlSetData($txtSearchReduceElixir, $ReduceElixir)
GUICtrlSetData($txtSearchReduceGoldPlusElixir, $ReduceGoldPlusElixir)
GUICtrlSetData($txtSearchReduceDark, $ReduceDark)
GUICtrlSetData($txtSearchReduceTrophy, $ReduceTrophy)
GUICtrlSetData($txtATBullyMode, $ATBullyMode)
_GUICtrlComboBox_SetCurSel($cmbYourTH, $YourTH)
If $iTHBullyAttackMode = 0 Then
GUICtrlSetState($radUseDBAttack, $GUI_CHECKED)
ElseIf $iTHBullyAttackMode = 1 Then
GUICtrlSetState($radUseLBAttack, $GUI_CHECKED)
EndIf
If $iChkTrophyRange = 1 Then
GUICtrlSetState($chkTrophyRange, $GUI_CHECKED)
Else
GUICtrlSetState($chkTrophyRange, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtMaxTrophy, $itxtMaxTrophy)
GUICtrlSetData($txtdropTrophy, $itxtdropTrophy)
If $iChkTrophyHeroes = 1 Then
GUICtrlSetState($chkTrophyHeroes, $GUI_CHECKED)
Else
GUICtrlSetState($chkTrophyHeroes, $GUI_UNCHECKED)
EndIf
If $iChkTrophyAtkDead = 1 Then
GUICtrlSetState($chkTrophyAtkDead, $GUI_CHECKED)
Else
GUICtrlSetState($chkTrophyAtkDead, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtDTArmyMin, $itxtDTArmyMin)
chkTrophyRange()
_GUICtrlComboBox_SetCurSel($cmbWeakMortar[$DB], $iCmbWeakMortar[$DB])
_GUICtrlComboBox_SetCurSel($cmbWeakWizTower[$DB], $iCmbWeakWizTower[$DB])
_GUICtrlComboBox_SetCurSel($cmbWeakAirDefense[$DB], $iCmbWeakAirDefense[$DB])
_GUICtrlComboBox_SetCurSel($cmbWeakXbow[$DB], $iCmbWeakXbow[$DB])
_GUICtrlComboBox_SetCurSel($cmbWeakInferno[$DB], $iCmbWeakInferno[$DB])
_GUICtrlComboBox_SetCurSel($cmbWeakEagle[$DB], $iCmbWeakEagle[$DB])
chkDBWeakBase()
_GUICtrlComboBox_SetCurSel($cmbWeakMortar[$LB], $iCmbWeakMortar[$LB])
_GUICtrlComboBox_SetCurSel($cmbWeakWizTower[$LB], $iCmbWeakWizTower[$LB])
_GUICtrlComboBox_SetCurSel($cmbWeakAirDefense[$LB], $iCmbWeakAirDefense[$LB])
_GUICtrlComboBox_SetCurSel($cmbWeakXbow[$LB], $iCmbWeakXbow[$LB])
_GUICtrlComboBox_SetCurSel($cmbWeakInferno[$LB], $iCmbWeakInferno[$LB])
_GUICtrlComboBox_SetCurSel($cmbWeakEagle[$LB], $iCmbWeakEagle[$LB])
chkABWeakBase()
If $DESideEB = 1 Then
GUICtrlSetState($chkDESideEB, $GUI_CHECKED)
Else
GUICtrlSetState($chkDESideEB, $GUI_UNCHECKED)
EndIf
chkDESideEB()
GUICtrlSetData($txtDELowEndMin, $DELowEndMin)
If $DisableOtherEBO = 1 Then
GUICtrlSetState($chkDisableOtherEBO, $GUI_CHECKED)
Else
GUICtrlSetState($chkDisableOtherEBO, $GUI_UNCHECKED)
EndIf
If $DEEndOneStar = 1 Then
GUICtrlSetState($chkDEEndOneStar, $GUI_CHECKED)
Else
GUICtrlSetState($chkDEEndOneStar, $GUI_UNCHECKED)
EndIf
If $DEEndBk = 1 Then
GUICtrlSetState($chkDEEndBk, $GUI_CHECKED)
Else
GUICtrlSetState($chkDEEndBk, $GUI_UNCHECKED)
EndIf
If $DEEndAq = 1 Then
GUICtrlSetState($chkDEEndAq, $GUI_CHECKED)
Else
GUICtrlSetState($chkDEEndAq, $GUI_UNCHECKED)
EndIf
If UBound($MilkFarmElixirParam) = 9 Then
For $i = 0 To UBound($MilkFarmElixirParam) - 1
_GUICtrlComboBox_SetCurSel(Eval("cmbMilkLvl" & $i + 4), $MilkFarmElixirParam[$i] + 1)
Next
Else
For $i = 0 To 9 - 1
_GUICtrlComboBox_SetCurSel(Eval("cmbMilkLvl" & $i + 4), 0)
Next
EndIf
If $MilkFarmLocateElixir = 1 Then
GUICtrlSetState($chkAtkElixirExtractors, $GUI_CHECKED)
Else
GUICtrlSetState($chkAtkElixirExtractors, $GUI_UNCHECKED)
EndIf
If $MilkFarmLocateMine = 1 Then
GUICtrlSetState($chkAtkGoldMines, $GUI_CHECKED)
Else
GUICtrlSetState($chkAtkGoldMines, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbAtkGoldMinesLevel, $MilkFarmMineParam - 1)
If $MilkFarmLocateDrill = 1 Then
GUICtrlSetState($chkAtkDarkDrills, $GUI_CHECKED)
Else
GUICtrlSetState($chkAtkDarkDrills, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbAtkDarkDrillsLevel, $MilkFarmDrillParam - 1)
_GUICtrlComboBox_SetCurSel($cmbRedlineResDistance, $MilkFarmResMaxTilesFromBorder)
If $MilkFarmAttackElixirExtractors = 1 Then
GUICtrlSetState($chkAttackMinesifElixir, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackMinesifElixir, $GUI_UNCHECKED)
EndIf
If $MilkFarmAttackGoldMines = 1 Then
GUICtrlSetState($chkAttackMinesifGold, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackMinesifGold, $GUI_UNCHECKED)
EndIf
If $MilkFarmAttackDarkDrills = 1 Then
GUICtrlSetState($chkAttackMinesifDarkElixir, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackMinesifDarkElixir, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtAttackMinesIfGold, $MilkFarmLimitGold)
GUICtrlSetData($txtAttackMinesifElixir, $MilkFarmLimitElixir)
GUICtrlSetData($txtAttackMinesifDarkElixir, $MilkFarmLimitDark)
chkAttackMinesifGold()
chkAttackMinesifelixir()
chkAttackMinesifdarkElixir()
GUICtrlSetData($txtLowerXWave, $MilkFarmTroopForWaveMin)
GUICtrlSetData($txtUpperXWave, $MilkFarmTroopForWaveMax)
GUICtrlSetData($txtMaxWaves, $MilkFarmTroopMaxWaves)
GUICtrlSetData($txtLowerDelayWaves, $MilkFarmDelayFromWavesMin)
GUICtrlSetData($txtUpperDelayWaves, $MilkFarmDelayFromWavesMax)
GUICtrlSetData($txtMaxTilesMilk, $MilkFarmTHMaxTilesFromBorder)
Dim $FileSearch, $NewFile
$FileSearch = FileFindFirstFile($dirTHSnipesAttacks & "\*.csv")
Dim $output = ""
While True
$NewFile = FileFindNextFile($FileSearch)
If @error Then ExitLoop
$output = $output & StringLeft($NewFile, StringLen($NewFile) - 4) & "|"
WEnd
FileClose($FileSearch)
$output = StringLeft($output, StringLen($output) - 1)
GUICtrlSetData($cmbMilkSnipeAlgorithm, $output)
_GUICtrlComboBox_SetCurSel($cmbMilkSnipeAlgorithm, _GUICtrlComboBox_FindStringExact($cmbMilkSnipeAlgorithm, $MilkFarmAlgorithmTh))
If $MilkFarmSnipeEvenIfNoExtractorsFound = 1 Then
GUICtrlSetState($chkSnipeIfNoElixir, $GUI_CHECKED)
Else
GUICtrlSetState($chkSnipeIfNoElixir, $GUI_UNCHECKED)
EndIf
If $devmode = 1 Then
GUICtrlSetState($grpMilkingDebug, $GUI_SHOW)
GUICtrlSetState($chkMilkingDebugIMG, $GUI_SHOW)
GUICtrlSetState($chkMilkingDebugVillage, $GUI_SHOW)
GUICtrlSetState($chkMilkingVillageDebugIMG, $GUI_SHOW)
GUICtrlSetState($chkMilkingDebugFullSearch, $GUI_SHOW)
If $debugresourcesoffset = 1 Then
GUICtrlSetState($chkMilkingDebugIMG, $GUI_CHECKED)
Else
GUICtrlSetState($chkMilkingDebugIMG, $GUI_UNCHECKED)
EndIf
If $debugMilkingIMGmake = 1 Then
GUICtrlSetState($chkMilkingDebugVillage, $GUI_CHECKED)
Else
GUICtrlSetState($chkMilkingDebugVillage, $GUI_UNCHECKED)
EndIf
If $continuesearchelixirdebug = 1 Then
GUICtrlSetState($chkMilkingDebugFullSearch, $GUI_CHECKED)
Else
GUICtrlSetState($chkMilkingDebugFullSearch, $GUI_UNCHECKED)
EndIf
EndIf
If $MilkFarmForcetolerance = 1 Then
GUICtrlSetState($chkMilkFarmForcetolerance, $GUI_CHECKED)
Else
GUICtrlSetState($chkMilkFarmForcetolerance, $GUI_UNCHECKED)
EndIf
chkMilkFarmForcetolerance()
GUICtrlSetData($txtMilkFarmForcetolerancenormal, $MilkFarmForcetolerancenormal)
GUICtrlSetData($txtMilkFarmForcetoleranceboosted, $MilkFarmForcetoleranceboosted)
GUICtrlSetData($txtMilkFarmForcetolerancedestroyed, $MilkFarmForcetolerancedestroyed)
If $MilkAttackType = 1 Then
_GUICtrlComboBox_SetCurSel($cmbMilkAttackType, 1)
Else
_GUICtrlComboBox_SetCurSel($cmbMilkAttackType, 0)
EndIf
If $MilkingAttackCheckStructureDestroyedBeforeAttack = 1 Then
GUICtrlSetState($chkStructureDestroyedBeforeAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkStructureDestroyedBeforeAttack, $GUI_UNCHECKED)
EndIf
If $MilkingAttackCheckStructureDestroyedAfterAttack = 1 Then
GUICtrlSetState($chkStructureDestroyedAfterAttack, $GUI_CHECKED)
Else
GUICtrlSetState($chkStructureDestroyedAfterAttack, $GUI_UNCHECKED)
EndIf
If $MilkingAttackDropGoblinAlgorithm = 1 Then
_GUICtrlComboBox_SetCurSel($cmbMilkingAttackDropGoblinAlgorithm, 1)
Else
_GUICtrlComboBox_SetCurSel($cmbMilkingAttackDropGoblinAlgorithm, 0)
EndIf
_GUICtrlComboBox_SetCurSel($cmbStructureOrder, $MilkingAttackStructureOrder)
If $MilkAttackAfterScriptedAtk = 1 Then
GUICtrlSetState($chkMilkAfterAttackScripted, $GUI_CHECKED)
Else
GUICtrlSetState($chkMilkAfterAttackScripted, $GUI_UNCHECKED)
EndIf
PopulateComboMilkingCSVScriptsFiles()
Local $tempindex = _GUICtrlComboBox_FindStringExact($cmbMilkingCSVScriptName, $MilkAttackCSVscript)
If $tempindex = -1 Then
$tempindex = 0
Setlog("Previous saved Scripted Attack not found (deleted, renamed?)", $color_red)
Setlog("Automatically setted a default script, please check your config", $color_red)
EndIf
_GUICtrlComboBox_SetCurSel($cmbMilkingCSVScriptName, $tempindex)
If $MilkAttackAfterTHSnipe = 1 Then
GUICtrlSetState($chkMilkAfterAttackTHSnipe, $GUI_CHECKED)
Else
GUICtrlSetState($chkMilkAfterAttackTHSnipe, $GUI_UNCHECKED)
EndIf
chkMilkAfterAttackTHSnipe()
_GUICtrlComboBox_SetCurSel($cmbStandardAlgorithmDB, $iCmbStandardAlgorithm[$DB])
_GUICtrlComboBox_SetCurSel($cmbDeployDB, $iChkDeploySettings[$DB])
_GUICtrlComboBox_SetCurSel($cmbUnitDelayDB, $iCmbUnitDelay[$DB])
_GUICtrlComboBox_SetCurSel($cmbWaveDelayDB, $iCmbWaveDelay[$DB])
If $iChkRandomspeedatk[$DB] = 1 Then
GUICtrlSetState($chkRandomSpeedAtkDB, $GUI_CHECKED)
Else
GUICtrlSetState($chkRandomSpeedAtkDB, $GUI_UNCHECKED)
EndIf
chkRandomSpeedAtkDB()
If $iChkRedArea[$DB] = 1 Then
GUICtrlSetState($chkSmartAttackRedAreaDB, $GUI_CHECKED)
Else
GUICtrlSetState($chkSmartAttackRedAreaDB, $GUI_UNCHECKED)
EndIf
chkSmartAttackRedAreaDB()
If $iChkSmartAttack[$DB][0] = 1 Then
GUICtrlSetState($chkAttackNearGoldMineDB, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackNearGoldMineDB, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbSmartDeployDB, $iCmbSmartDeploy[$DB])
If $iChkSmartAttack[$DB][1] = 1 Then
GUICtrlSetState($chkAttackNearElixirCollectorDB, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackNearElixirCollectorDB, $GUI_UNCHECKED)
EndIf
If $iChkSmartAttack[$DB][2] = 1 Then
GUICtrlSetState($chkAttackNearDarkElixirDrillDB, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackNearDarkElixirDrillDB, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbStandardAlgorithmAB, $iCmbStandardAlgorithm[$LB])
_GUICtrlComboBox_SetCurSel($cmbDeployAB, $iChkDeploySettings[$LB])
_GUICtrlComboBox_SetCurSel($cmbUnitDelayAB, $iCmbUnitDelay[$LB])
_GUICtrlComboBox_SetCurSel($cmbWaveDelayAB, $iCmbWaveDelay[$LB])
If $iChkRandomspeedatk[$LB] = 1 Then
GUICtrlSetState($chkRandomSpeedAtkAB, $GUI_CHECKED)
Else
GUICtrlSetState($chkRandomSpeedAtkAB, $GUI_UNCHECKED)
EndIf
chkRandomSpeedAtkAB()
If $iChkRedArea[$LB] = 1 Then
GUICtrlSetState($chkSmartAttackRedAreaAB, $GUI_CHECKED)
Else
GUICtrlSetState($chkSmartAttackRedAreaAB, $GUI_UNCHECKED)
EndIf
chkSmartAttackRedAreaAB()
If $iChkSmartAttack[$LB][0] = 1 Then
GUICtrlSetState($chkAttackNearGoldMineAB, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackNearGoldMineAB, $GUI_UNCHECKED)
EndIf
_GUICtrlComboBox_SetCurSel($cmbSmartDeployAB, $iCmbSmartDeploy[$LB])
If $iChkSmartAttack[$LB][1] = 1 Then
GUICtrlSetState($chkAttackNearElixirCollectorAB, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackNearElixirCollectorAB, $GUI_UNCHECKED)
EndIf
If $iChkSmartAttack[$LB][2] = 1 Then
GUICtrlSetState($chkAttackNearDarkElixirDrillAB, $GUI_CHECKED)
Else
GUICtrlSetState($chkAttackNearDarkElixirDrillAB, $GUI_UNCHECKED)
EndIf
If $ichkEnableSuperXP = 1 Then
GUICtrlSetState($chkEnableSuperXP, $GUI_CHECKED)
Else
GUICtrlSetState($chkEnableSuperXP, $GUI_UNCHECKED)
EndIf
chkEnableSuperXP()
If $irbSXTraining = 1 Then
GUICtrlSetState($rbSXTraining, $GUI_CHECKED)
GUICtrlSetState($rbSXIAttacking, $GUI_UNCHECKED)
Else
GUICtrlSetState($rbSXIAttacking, $GUI_CHECKED)
GUICtrlSetState($rbSXTraining, $GUI_UNCHECKED)
EndIf
If $ichkSXBK = $HERO_KING Then
GUICtrlSetState($chkSXBK, $GUI_CHECKED)
Else
GUICtrlSetState($chkSXBK, $GUI_UNCHECKED)
EndIf
If $ichkSXAQ = $HERO_QUEEN Then
GUICtrlSetState($chkSXAQ, $GUI_CHECKED)
Else
GUICtrlSetState($chkSXAQ, $GUI_UNCHECKED)
EndIf
If $ichkSXGW = $HERO_WARDEN Then
GUICtrlSetState($chkSXGW, $GUI_CHECKED)
Else
GUICtrlSetState($chkSXGW, $GUI_UNCHECKED)
EndIf
PopulateComboScriptsFilesDB()
PopulateComboScriptsFilesAB()
Local $tempindex = _GUICtrlComboBox_FindStringExact($cmbScriptNameDB, $scmbDBScriptName)
If $tempindex = -1 Then
$tempindex = 0
Setlog("Previous saved Scripted Attack not found (deleted, renamed?)", $color_red)
Setlog("Automatically setted a default script, please check your config", $color_red)
EndIf
_GUICtrlComboBox_SetCurSel($cmbScriptNameDB, $tempindex)
Local $tempindex = _GUICtrlComboBox_FindStringExact($cmbScriptNameAB, $scmbABScriptName)
If $tempindex = -1 Then
$tempindex = 0
Setlog("Previous saved Scripted Attack not found (deleted, renamed?)", $color_red)
Setlog("Automatically setted a default script, please check your config", $color_red)
EndIf
_GUICtrlComboBox_SetCurSel($cmbScriptNameAB, $tempindex)
cmbScriptNameDB()
cmbScriptNameAB()
If $devmode = 1 Then GUICtrlSetState($chkmakeIMGCSV, $GUI_SHOW)
If $makeIMGCSV = 1 Then
GUICtrlSetState($chkmakeIMGCSV, $GUI_CHECKED)
Else
GUICtrlSetState($chkmakeIMGCSV, $GUI_UNCHECKED)
EndIf
If $chkLvl6Enabled = 1 Then
GUICtrlSetState($chkLvl6, $GUI_CHECKED)
GUICtrlSetState($cmbLvl6, $GUI_ENABLE)
Else
GUICtrlSetState($chkLvl6, $GUI_UNCHECKED)
GUICtrlSetState($cmbLvl6, $GUI_DISABLE)
EndIf
If $chkLvl7Enabled = 1 Then
GUICtrlSetState($chkLvl7, $GUI_CHECKED)
GUICtrlSetState($cmbLvl7, $GUI_ENABLE)
Else
GUICtrlSetState($chkLvl7, $GUI_UNCHECKED)
GUICtrlSetState($cmbLvl7, $GUI_DISABLE)
EndIf
If $chkLvl8Enabled = 1 Then
GUICtrlSetState($chkLvl8, $GUI_CHECKED)
GUICtrlSetState($cmbLvl8, $GUI_ENABLE)
Else
GUICtrlSetState($chkLvl8, $GUI_UNCHECKED)
GUICtrlSetState($cmbLvl8, $GUI_DISABLE)
EndIf
If $chkLvl9Enabled = 1 Then
GUICtrlSetState($chkLvl9, $GUI_CHECKED)
GUICtrlSetState($cmbLvl9, $GUI_ENABLE)
Else
GUICtrlSetState($chkLvl9, $GUI_UNCHECKED)
GUICtrlSetState($cmbLvl9, $GUI_DISABLE)
EndIf
If $chkLvl10Enabled = 1 Then
GUICtrlSetState($chkLvl10, $GUI_CHECKED)
GUICtrlSetState($cmbLvl10, $GUI_ENABLE)
Else
GUICtrlSetState($chkLvl10, $GUI_UNCHECKED)
GUICtrlSetState($cmbLvl10, $GUI_DISABLE)
EndIf
If $chkLvl11Enabled = 1 Then
GUICtrlSetState($chkLvl11, $GUI_CHECKED)
GUICtrlSetState($cmbLvl11, $GUI_ENABLE)
Else
GUICtrlSetState($chkLvl11, $GUI_UNCHECKED)
GUICtrlSetState($cmbLvl11, $GUI_DISABLE)
EndIf
If $chkLvl12Enabled = 1 Then
GUICtrlSetState($chkLvl12, $GUI_CHECKED)
GUICtrlSetState($cmbLvl12, $GUI_ENABLE)
Else
GUICtrlSetState($chkLvl12, $GUI_UNCHECKED)
GUICtrlSetState($cmbLvl12, $GUI_DISABLE)
EndIf
_GUICtrlComboBox_SetCurSel($cmbLvl6, $cmbLvl6Fill)
_GUICtrlComboBox_SetCurSel($cmbLvl7, $cmbLvl7Fill)
_GUICtrlComboBox_SetCurSel($cmbLvl8, $cmbLvl8Fill)
_GUICtrlComboBox_SetCurSel($cmbLvl9, $cmbLvl9Fill)
_GUICtrlComboBox_SetCurSel($cmbLvl10, $cmbLvl10Fill)
_GUICtrlComboBox_SetCurSel($cmbLvl11, $cmbLvl11Fill)
_GUICtrlComboBox_SetCurSel($cmbLvl12, $cmbLvl12Fill)
GUICtrlSetData($sldCollectorTolerance, $toleranceOffset)
checkCollectors()
GUICtrlSetData($txtShareMinGold, $iShareminGold)
GUICtrlSetData($txtShareMinElixir, $iShareminElixir)
GUICtrlSetData($txtShareMinDark, $iShareminDark)
GUICtrlSetData($txtShareMessage, $sShareMessage)
If $THSnipeBeforeDBEnable = 1 Then
GUICtrlSetState($chkTHSnipeBeforeDBEnable, $GUI_CHECKED)
Else
GUICtrlSetState($chkTHSnipeBeforeDBEnable, $GUI_UNCHECKED)
EndIf
chkTHSnipeBeforeDBEnable()
If $THSnipeBeforeLBEnable = 1 Then
GUICtrlSetState($chkTHSnipeBeforeLBEnable, $GUI_CHECKED)
Else
GUICtrlSetState($chkTHSnipeBeforeLBEnable, $GUI_UNCHECKED)
EndIf
chkTHSnipeBeforeLBEnable()
GUICtrlSetData($txtTHSnipeBeforeDBTiles, $THSnipeBeforeDBTiles)
GUICtrlSetData($txtTHSnipeBeforeLBTiles, $THSnipeBeforeLBTiles)
LoadDBSnipeAttacks()
_GUICtrlComboBox_SetCurSel($cmbTHSnipeBeforeDBScript, _GUICtrlComboBox_FindStringExact($cmbTHSnipeBeforeDBScript, $THSnipeBeforeDBScript))
LoadABSnipeAttacks()
_GUICtrlComboBox_SetCurSel($cmbTHSnipeBeforeLBScript, _GUICtrlComboBox_FindStringExact($cmbTHSnipeBeforeLBScript, $THSnipeBeforeLBScript))
If $iEnableSpellsWait[$DB] = 1 Then
GUICtrlSetState($chkDBSpellsWait, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBSpellsWait, $GUI_UNCHECKED)
EndIf
chkDBSpellsWait()
If $iEnableSpellsWait[$LB] = 1 Then
GUICtrlSetState($chkABSpellsWait, $GUI_CHECKED)
Else
GUICtrlSetState($chkABSpellsWait, $GUI_UNCHECKED)
EndIf
chkABSpellsWait()
If $iChkWaitForCastleSpell[$DB] = 1 Then
GUICtrlSetState($chkDBWaitForCastleSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBWaitForCastleSpell, $GUI_UNCHECKED)
EndIf
If $iChkWaitForCastleSpell[$LB] = 1 Then
GUICtrlSetState($chkABWaitForCastleSpell, $GUI_CHECKED)
Else
GUICtrlSetState($chkABWaitForCastleSpell, $GUI_UNCHECKED)
EndIf
If $iChkWaitForCastleTroops[$DB] = 1 Then
GUICtrlSetState($chkDBWaitForCastleTroops, $GUI_CHECKED)
Else
GUICtrlSetState($chkDBWaitForCastleTroops, $GUI_UNCHECKED)
EndIf
If $iChkWaitForCastleTroops[$LB] = 1 Then
GUICtrlSetState($chkABWaitForCastleTroops, $GUI_CHECKED)
Else
GUICtrlSetState($chkABWaitForCastleTroops, $GUI_UNCHECKED)
EndIf
chkDBWaitForCCSpell()
chkABWaitForCCSpell()
_GUICtrlComboBox_SetCurSel($cmbDBWaitForCastleSpell, $iCmbWaitForCastleSpell[$DB])
_GUICtrlComboBox_SetCurSel($cmbABWaitForCastleSpell, $iCmbWaitForCastleSpell[$LB])
If $ichkTSActivateCamps2 = 1 Then
GUICtrlSetState($chkTSActivateCamps2, $GUI_CHECKED)
Else
GUICtrlSetState($chkTSActivateCamps2, $GUI_UNCHECKED)
EndIf
chkTSActivateCamps2()
GUICtrlSetData($txtTSArmyCamps2, $iEnableAfterArmyCamps2)
If $iRadio_Army1 = 1 Then
GUICtrlSetState($hRadio_Army1, $GUI_CHECKED)
Else
GUICtrlSetState($hRadio_Army1, $GUI_UNCHECKED)
EndIf
If $iRadio_Army2 = 1 Then
GUICtrlSetState($hRadio_Army2, $GUI_CHECKED)
Else
GUICtrlSetState($hRadio_Army2, $GUI_UNCHECKED)
EndIf
If $iRadio_Army3 = 1 Then
GUICtrlSetState($hRadio_Army3, $GUI_CHECKED)
Else
GUICtrlSetState($hRadio_Army3, $GUI_UNCHECKED)
EndIf
If $ichkSmartZap = 1 Then
GUICtrlSetState($chkSmartLightSpell, $GUI_CHECKED)
GUICtrlSetState($chkSmartZapDB, $GUI_ENABLE)
GUICtrlSetState($chkSmartZapSaveHeroes, $GUI_ENABLE)
GUICtrlSetState($txtMinDark, $GUI_ENABLE)
GUICtrlSetState($chkNoobZap, $GUI_ENABLE)
Else
GUICtrlSetState($chkSmartZapDB, $GUI_DISABLE)
GUICtrlSetState($chkSmartZapSaveHeroes, $GUI_DISABLE)
GUICtrlSetState($txtMinDark, $GUI_DISABLE)
GUICtrlSetState($chkSmartLightSpell, $GUI_UNCHECKED)
GUICtrlSetState($chkNoobZap, $GUI_DISABLE)
EndIf
If $ichkNoobZap = 1 Then
GUICtrlSetState($chkNoobZap, $GUI_CHECKED)
GUICtrlSetState($txtExpectedDE, $GUI_ENABLE)
Else
GUICtrlSetState($chkNoobZap, $GUI_UNCHECKED)
GUICtrlSetState($txtExpectedDE, $GUI_DISABLE)
EndIf
If $ichkSmartZapDB = 1 Then
GUICtrlSetState($chkSmartZapDB, $GUI_CHECKED)
Else
GUICtrlSetState($chkSmartZapDB, $GUI_UNCHECKED)
EndIf
If $ichkSmartZapSaveHeroes = 1 Then
GUICtrlSetState($chkSmartZapSaveHeroes, $GUI_CHECKED)
Else
GUICtrlSetState($chkSmartZapSaveHeroes, $GUI_UNCHECKED)
EndIf
If $DebugSmartZap = 1 Then
GUICtrlSetState($chkDebugSmartZap, $GUI_CHECKED)
Else
GUICtrlSetState($chkDebugSmartZap, $GUI_UNCHECKED)
EndIf
GUICtrlSetData($txtMinDark, $itxtMinDE)
GUICtrlSetData($txtExpectedDE, $itxtExpectedDE)
GUICtrlSetData($MinTimeCloseATK, $sMinTimeCloseATK)
GUICtrlSetData ( $NameMyBot, $iNameMyBot, "" )
If $ichkUseBotHumanization = 1 Then
GUICtrlSetState($chkUseBotHumanization, $GUI_CHECKED)
Else
GUICtrlSetState($chkUseBotHumanization, $GUI_UNCHECKED)
EndIf
If $ichkUseAltRClick = 1 Then
GUICtrlSetState($chkUseAltRClick, $GUI_CHECKED)
Else
GUICtrlSetState($chkUseAltRClick, $GUI_UNCHECKED)
EndIf
If $ichkCollectAchievements = 1 Then
GUICtrlSetState($chkCollectAchievements, $GUI_CHECKED)
Else
GUICtrlSetState($chkCollectAchievements, $GUI_UNCHECKED)
EndIf
If $ichkLookAtRedNotifications = 1 Then
GUICtrlSetState($chkLookAtRedNotifications, $GUI_CHECKED)
Else
GUICtrlSetState($chkLookAtRedNotifications, $GUI_UNCHECKED)
EndIf
chkUseBotHumanization()
For $i = 0 To 12
_GUICtrlComboBox_SetCurSel($cmbPriority[$i], $icmbPriority[$i])
Next
For $i = 0 To 1
_GUICtrlComboBox_SetCurSel($cmbMaxSpeed[$i], $icmbMaxSpeed[$i])
Next
For $i = 0 To 1
_GUICtrlComboBox_SetCurSel($cmbPause[$i], $icmbPause[$i])
Next
For $i = 0 To 1
GUICtrlSetData($humanMessage[$i], $ihumanMessage[$i])
Next
_GUICtrlComboBox_SetCurSel($cmbMaxActionsNumber, $icmbMaxActionsNumber)
cmbStandardReplay()
cmbWarReplay()
If $bRedrawAtExit Then SetRedrawBotWindow(True)
EndFunc
Func IniReadS(ByRef $variable, $PrimaryInputFile, $section, $key, $defaultvalue, $valueType = Default)
Local $defaultvalueTest = "?"
Local $readValue = IniRead($SecondaryInputFile, $section, $key, $defaultvalueTest)
If $readValue = $defaultvalueTest Then
$readValue = IniRead($PrimaryInputFile, $section, $key, $defaultvalue)
EndIf
Switch $valueType
Case Default
$variable = $readValue
Case "Int"
$variable = Int($readValue)
Case Else
$variable = $readValue
EndSwitch
EndFunc
Func IniWriteS($filename, $section, $key, $value)
Local $s = $section
Local $k = $key
IniWrite($filename, $section, $key, $value)
If $SecondaryOutputFile <> "" Then
If $s = "search" Or $s = "attack" Or $s = "troop" Or $s = "spells" Or $s = "milkingattack" Or $s = "endbattle" or $s = "collectors" or ($s = "general" And $k = "version") Then
IniWrite($SecondaryOutputFile, $section, $key, $value)
EndIf
EndIf
EndFunc
Func readConfig($inputfile = $config, $partial = False)
$aWeakBaseStats = readWeakBaseStats()
$configLoaded = True
If FileExists($building) Then
SetDebugLog("Read Building Config " & $building)
IniReadS($TownHallPos[0], $building, "other", "xTownHall", "-1")
IniReadS($TownHallPos[1], $building, "other", "yTownHall", "-1")
IniReadS($iTownHallLevel, $building, "other", "LevelTownHall", "0")
IniReadS($aCCPos[0], $building, "other", "xCCPos", "0")
IniReadS($aCCPos[1], $building, "other", "yCCPos", "0")
IniReadS($IsCCAutoLocated[0], $building, "other", "CCAutoDetected", "0")
IniReadS($IsCCAutoLocated[1], $building, "other", "CCLevel", "0")
IniReadS($IsCCAutoLocated[2], $building, "other", "OffsetxCCPos", "33")
IniReadS($IsCCAutoLocated[3], $building, "other", "OffsetyCCPos", "2")
IniReadS($barrackPos[0][0], $building, "other", "xBarrack1", "0")
IniReadS($barrackPos[0][1], $building, "other", "yBarrack1", "0")
IniReadS($barrackPos[1][0], $building, "other", "xBarrack2", "0")
IniReadS($barrackPos[1][1], $building, "other", "yBarrack2", "0")
IniReadS($barrackPos[2][0], $building, "other", "xBarrack3", "0")
IniReadS($barrackPos[2][1], $building, "other", "yBarrack3", "0")
IniReadS($barrackPos[3][0], $building, "other", "xBarrack4", "0")
IniReadS($barrackPos[3][1], $building, "other", "yBarrack4", "0")
IniReadS($DarkbarrackPos[0][0], $building, "other", "xDarkBarrack1", "0")
IniReadS($DarkbarrackPos[0][1], $building, "other", "yDarkBarrack1", "0")
IniReadS($DarkbarrackPos[1][0], $building, "other", "xDarkBarrack2", "0")
IniReadS($DarkbarrackPos[1][1], $building, "other", "yDarkBarrack2", "0")
IniReadS($ArmyPos[0], $building, "other", "xArmy", "0")
IniReadS($ArmyPos[0], $building, "other", "yArmy", "0")
IniReadS($TotalCamp, $building, "other", "totalcamp", "0")
IniReadS($KingAltarPos[0], $building, "other", "xKingAltarPos", "-1")
IniReadS($KingAltarPos[1], $building, "other", "yKingAltarPos", "-1")
IniReadS($QueenAltarPos[0], $building, "other", "xQueenAltarPos", "-1")
IniReadS($QueenAltarPos[1], $building, "other", "yQueenAltarPos", "-1")
IniReadS($WardenAltarPos[0], $building, "other", "xWardenAltarPos", "-1")
IniReadS($WardenAltarPos[1], $building, "other", "yWardenAltarPos", "-1")
IniReadS($listResourceLocation, $building, "other", "listResource", "")
For $iz = 0 To UBound($aUpgrades, 1) - 1
$aUpgrades[$iz][0] = IniRead($building, "upgrade", "xupgrade" & $iz, "-1")
$aUpgrades[$iz][1] = IniRead($building, "upgrade", "yupgrade" & $iz, "-1")
$aUpgrades[$iz][2] = IniRead($building, "upgrade", "upgradevalue" & $iz, "-1")
$aUpgrades[$iz][3] = IniRead($building, "upgrade", "upgradetype" & $iz, "")
$aUpgrades[$iz][4] = IniRead($building, "upgrade", "upgradename" & $iz, "")
$aUpgrades[$iz][5] = IniRead($building, "upgrade", "upgradelevel" & $iz, "")
$aUpgrades[$iz][6] = IniRead($building, "upgrade", "upgradetime" & $iz, "")
$aUpgrades[$iz][7] = IniRead($building, "upgrade", "upgradeend" & $iz, "-1")
$ichkbxUpgrade[$iz] = IniRead($building, "upgrade", "upgradechk" & $iz, "0")
$ichkUpgrdeRepeat[$iz] = IniRead($building, "upgrade", "upgraderepeat" & $iz, "0")
$ipicUpgradeStatus[$iz] = IniRead($building, "upgrade", "upgradestatusicon" & $iz, $eIcnTroops)
Next
InireadS($ichkLab, $building, "upgrade", "upgradetroops", "0")
InireadS($icmbLaboratory, $building, "upgrade", "upgradetroopname", "0")
$sLabUpgradeTime = IniRead($building, "upgrade", "upgradelabtime", "")
InireadS($aLabPos[0], $building, "upgrade", "LabPosX", "0")
InireadS($aLabPos[1], $building, "upgrade", "LabPosY", "0")
EndIf
If FileExists($config) Then
SetDebugLog("Read Config " & $config)
IniReadS($frmBotPosX, $config, "general", "frmBotPosX", "-1")
IniReadS($frmBotPosY, $config, "general", "frmBotPosY", "-1")
If $frmBotPosX < -30000 Or $frmBotPosY < -30000 Then
$frmBotPosX = -1
$frmBotPosY = -1
EndIf
IniReadS($AndroidPosX, $config, "general", "AndroidPosX", "-1")
IniReadS($AndroidPosY, $config, "general", "AndroidPosY", "-1")
If $AndroidPosX < -30000 Or $AndroidPosY < -30000 Then
$AndroidPosX = -1
$AndroidPosY = -1
EndIf
IniReadS($frmBotDockedPosX, $config, "general", "frmBotDockedPosX", "-1")
IniReadS($frmBotDockedPosY, $config, "general", "frmBotDockedPosY", "-1")
If $frmBotDockedPosX < -30000 Or $frmBotDockedPosY < -30000 Then
$frmBotDockedPosX = -1
$frmBotDockedPosY = -1
EndIf
IniReadS($iUpdatingWhenMinimized, $config, "general", "UpdatingWhenMinimized", $iUpdatingWhenMinimized)
IniReadS($iHideWhenMinimized, $config, "general", "HideWhenMinimized", $iHideWhenMinimized)
IniReadS($iVillageName, $config, "general", "villageName", "")
IniReadS($iCmbLog, $config, "general", "logstyle", "0")
IniReadS($iDividerY, $config, "general", "LogDividerY", "243")
IniReadS($ichkAutoStart, $config, "general", "AutoStart", "0")
IniReadS($ichkAutoStartDelay, $config, "general", "AutoStartDelay", "10")
IniReadS($restarted, $config, "general", "Restarted", "0")
IniReadS($ichkBackground, $config, "general", "Background", "1")
IniReadS($ichkBotStop, $config, "general", "BotStop", "0")
IniReadS($icmbBotCommand, $config, "general", "Command", "0")
IniReadS($icmbBotCond, $config, "general", "Cond", "0")
IniReadS($icmbHoursStop, $config, "general", "Hour", "0")
IniReadS($iDisposeWindows, $config, "general", "DisposeWindows", "0")
IniReadS($icmbDisposeWindowsPos, $config, "general", "DisposeWindowsPos", "SNAP-TR")
IniReadS($AlertSearch, $config, "general", "AlertSearch", "0")
IniReadS($ichkAttackNow, $config, "general", "AttackNow", "0")
IniReadS($iAttackNowDelay, $config, "general", "attacknowdelay", "3")
IniReadS($ichkbtnScheduler, $config, "general", "BtnScheduler", "0")
IniReadS($RedrawBotWindowMode, $config, "general", "RedrawBotWindowMode", "2", "Int")
IniReadS($ichkUpgradeKing, $config, "upgrade", "UpgradeKing", "0")
IniReadS($ichkUpgradeQueen, $config, "upgrade", "UpgradeQueen", "0")
IniReadS($ichkUpgradeWarden, $config, "upgrade", "UpgradeWarden", "0")
IniReadS($itxtUpgrMinGold, $config, "upgrade", "minupgrgold", "100000")
IniReadS($itxtUpgrMinElixir, $config, "upgrade", "minupgrelixir", "100000")
IniReadS($itxtUpgrMinDark, $config, "upgrade", "minupgrdark", "2000")
IniReadS($ichkWalls, $config, "upgrade", "auto-wall", "0")
IniReadS($iSaveWallBldr, $config, "upgrade", "savebldr", "0")
IniReadS($ichkUpgradeContinually, $config, "upgrade", "upgradewallcontinually", "0")
IniReadS($iUseStorage, $config, "upgrade", "use-storage", "0")
IniReadS($icmbWalls, $config, "upgrade", "walllvl", "6")
IniReadS($iMaxNbWall, $config, "upgrade", "MaxNbWall", "8")
IniReadS($itxtWallMinGold, $config, "upgrade", "minwallgold", "0")
IniReadS($itxtWallMinElixir, $config, "upgrade", "minwallelixir", "0")
IniReadS($WallCost, $config, "upgrade", "WallCost", "0")
IniReadS($itxtWall04ST, $config, "Walls", "Wall04", "0")
IniReadS($itxtWall05ST, $config, "Walls", "Wall05", "0")
IniReadS($itxtWall06ST, $config, "Walls", "Wall06", "0")
IniReadS($itxtWall07ST, $config, "Walls", "Wall07", "0")
IniReadS($itxtWall08ST, $config, "Walls", "Wall08", "0")
IniReadS($itxtWall09ST, $config, "Walls", "Wall09", "0")
IniReadS($itxtWall10ST, $config, "Walls", "Wall10", "0")
IniReadS($itxtWall11ST, $config, "Walls", "Wall11", "0")
IniReadS($itxtRestartGold, $config, "other", "minrestartgold", "50000")
IniReadS($itxtRestartElixir, $config, "other", "minrestartelixir", "50000")
IniReadS($itxtRestartDark, $config, "other", "minrestartdark", "500")
Local $tempTroop
For $i = 0 To UBound($TroopName) - 1
IniReadS($tempTroop, $config, "troop", $TroopName[$i], "0")
Assign($TroopName[$i] & "Comp", $tempTroop)
Next
For $i = 0 To UBound($TroopDarkName) - 1
IniReadS($tempTroop, $config, "troop", $TroopDarkName[$i], "0")
Assign($TroopDarkName[$i] & "Comp", $tempTroop)
Next
For $i = 0 To 3
IniReadS($barrackTroop[$i], $config, "troop", "troop" & $i + 1, "0")
Next
For $i = 0 To 1
IniReadS($darkBarrackTroop[$i], $config, "troop", "Darktroop" & $i + 1, "0")
Next
IniReadS($fulltroop, $config, "troop", "fullTroop", "100")
IniReadS($isldTrainITDelay, $config, "other", "TrainITDelay", "40")
IniReadS($ichkCloseWaitEnable, $config, "other", "chkCloseWaitEnable", "1")
IniReadS($ichkCloseWaitTrain, $config, "other", "chkCloseWaitTrain", "0")
IniReadS($ibtnCloseWaitStop, $config, "other", "btnCloseWaitStop", "0")
IniReadS($ibtnCloseWaitStopRandom, $config, "other", "btnCloseWaitStopRandom", "0")
IniReadS($ibtnCloseWaitExact, $config, "other", "btnCloseWaitExact", "0")
IniReadS($ibtnCloseWaitRandom, $config, "other", "btnCloseWaitRandom", "1")
IniReadS($icmbCloseWaitRdmPercent, $config, "other", "CloseWaitRdmPercent", "10")
IniReadS($icmbMinimumTimeClose, $config, "other", "MinimumTimeToClose", "2")
IniReadS($ichkTroopOrder, $config, "troop", "chkTroopOrder", "0")
For $z = 0 To UBound($DefaultTroopGroup) -1
IniReadS($icmbTroopOrder[$z], $config, "troop", "cmbTroopOrder" & $z, "-1")
Next
IniReadS($ichkDarkTroopOrder, $config, "troop", "chkDarkTroopOrder", "0")
For $z = 0 To UBound($DefaultTroopGroupDark) -1
IniReadS($icmbDarkTroopOrder[$z], $config, "troop", "cmbDarkTroopOrder" & $z, "-1")
Next
Local $tempQtaSpell
IniReadS($LSpellComp, $config, "Spells", "LightningSpell", "0")
IniReadS($RSpellComp, $config, "Spells", "RageSpell", "0")
IniReadS($HSpellComp, $config, "Spells", "HealSpell", "0")
IniReadS($JSpellComp, $config, "Spells", "JumpSpell", "0")
IniReadS($FSpellComp, $config, "Spells", "FreezeSpell", "0")
IniReadS($CSpellComp, $config, "Spells", "CloneSpell", "0", "Int")
IniReadS($PSpellComp, $config, "Spells", "PoisonSpell", "0")
IniReadS($HaSpellComp, $config, "Spells", "HasteSpell", "0")
IniReadS($ESpellComp, $config, "Spells", "EarthSpell", "0")
IniReadS($SkSpellComp, $config, "Spells", "SkeletonSpell", "0", "Int")
IniReadS($iTotalCountSpell, $config, "Spells", "SpellFactory", "0")
$LSpellComp = Int($LSpellComp)
$RSpellComp = Int($RSpellComp)
$HSpellComp = Int($HSpellComp)
$JSpellComp = Int($JSpellComp)
$FSpellComp = Int($FSpellComp)
$CSpellComp = Int($CSpellComp)
$PSpellComp = Int($PSpellComp)
$HaSpellComp = Int($HaSpellComp)
$ESpellComp = Int($ESpellComp)
$SkSpellComp = Int($SkSpellComp)
$iTotalCountSpell = Int($iTotalCountSpell)
IniReadS($iChkEnableAfter[$DB], $config, "search", "DBEnableAfter", "0")
IniReadS($iCmbMeetGE[$DB], $config, "search", "DBMeetGE", "1")
IniReadS($iChkMeetDE[$DB], $config, "search", "DBMeetDE", "0")
IniReadS($iChkMeetTrophy[$DB], $config, "search", "DBMeetTrophy", "0")
IniReadS($iChkMeetTH[$DB], $config, "search", "DBMeetTH", "0")
IniReadS($iChkMeetTHO[$DB], $config, "search", "DBMeetTHO", "0")
IniReadS($iChkMeetOne[$DB], $config, "search", "DBMeetOne", "0")
IniReadS($iEnableAfterCount[$DB], $config, "search", "DBEnableAfterCount", "1")
IniReadS($iEnableBeforeCount[$DB], $config, "search", "DBEnableBeforeCount", "9999", "Int")
IniReadS($iEnableAfterTropies[$DB], $config, "search", "DBEnableAfterTropies", "100", "Int")
IniReadS($iEnableBeforeTropies[$DB], $config, "search", "DBEnableBeforeTropies", "6000", "Int")
IniReadS($iEnableAfterArmyCamps[$DB], $config, "search", "DBEnableAfterArmyCamps", "100", "Int")
IniReadS($iMinGold[$DB], $config, "search", "DBsearchGold", "80000", "Int")
IniReadS($iMinElixir[$DB], $config, "search", "DBsearchElixir", "80000")
IniReadS($iMinGoldPlusElixir[$DB], $config, "search", "DBsearchGoldPlusElixir", "160000", "Int")
IniReadS($iMinDark[$DB], $config, "search", "DBsearchDark", "0", "Int")
IniReadS($iMinTrophy[$DB], $config, "search", "DBsearchTrophy", "0", "Int")
IniReadS($iCmbTH[$DB], $config, "search", "DBTHLevel", "0")
IniReadS($iCmbWeakMortar[$DB], $config, "search", "DBWeakMortar", "5")
IniReadS($iCmbWeakWizTower[$DB], $config, "search", "DBWeakWizTower", "4")
IniReadS($iCmbWeakAirDefense[$DB], $config, "search", "DBWeakAirDefense", "7")
IniReadS($iCmbWeakXBow[$DB], $config, "search", "DBWeakXBow", "4")
IniReadS($iCmbWeakInferno[$DB], $config, "search", "DBWeakInferno", "1")
IniReadS($iCmbWeakEagle[$DB], $config, "search", "DBWeakEagle", "2")
IniReadS($iChkMaxMortar[$DB], $config, "search", "DBCheckMortar", "0")
IniReadS($iChkMaxWizTower[$DB], $config, "search", "DBCheckWizTower", "0")
IniReadS($iChkMaxAirDefense[$DB], $config, "search", "DBCheckAirDefense", "0")
IniReadS($iChkMaxXBow[$DB], $config, "search", "DBCheckXBow", "0")
IniReadS($iChkMaxInferno[$DB], $config, "search", "DBCheckInferno", "0")
IniReadS($iChkMaxEagle[$DB], $config, "search", "DBCheckEagle", "0")
IniReadS($iChkEnableAfter[$LB], $config, "search", "ABEnableAfter", "0")
IniReadS($iCmbMeetGE[$LB], $config, "search", "ABMeetGE", "2")
IniReadS($iChkMeetDE[$LB], $config, "search", "ABMeetDE", "0")
IniReadS($iChkMeetTrophy[$LB], $config, "search", "ABMeetTrophy", "0")
IniReadS($iChkMeetTH[$LB], $config, "search", "ABMeetTH", "0")
IniReadS($iChkMeetTHO[$LB], $config, "search", "ABMeetTHO", "0")
IniReadS($iChkMeetOne[$LB], $config, "search", "ABMeetOne", "0")
IniReadS($iEnableAfterCount[$LB], $config, "search", "ABEnableAfterCount", "1")
IniReadS($iEnableBeforeCount[$LB], $config, "search", "ABEnableBeforeCount", "9999", "Int")
IniReadS($iEnableAfterTropies[$LB], $config, "search", "ABEnableAfterTropies", "100", "Int")
IniReadS($iEnableBeforeTropies[$LB], $config, "search", "ABEnableBeforeTropies", "6000", "Int")
IniReadS($iEnableAfterArmyCamps[$LB], $config, "search", "ABEnableAfterArmyCamps", "100", "Int")
IniReadS($iMinGold[$LB], $config, "search", "ABsearchGold", "80000", "Int")
IniReadS($iMinElixir[$LB], $config, "search", "ABsearchElixir", "80000")
IniReadS($iMinGoldPlusElixir[$LB], $config, "search", "ABsearchGoldPlusElixir", "160000", "Int")
IniReadS($iMinDark[$LB], $config, "search", "ABsearchDark", "0", "Int")
IniReadS($iMinTrophy[$LB], $config, "search", "ABsearchTrophy", "0", "Int")
IniReadS($iCmbTH[$LB], $config, "search", "ABTHLevel", "0")
IniReadS($iCmbWeakMortar[$LB], $config, "search", "ABWeakMortar", "5")
IniReadS($iCmbWeakWizTower[$LB], $config, "search", "ABWeakWizTower", "4")
IniReadS($iCmbWeakAirDefense[$LB], $config, "search", "ABWeakAirDefense", "7")
IniReadS($iCmbWeakXBow[$LB], $config, "search", "ABWeakXBow", "4")
IniReadS($iCmbWeakInferno[$LB], $config, "search", "ABWeakInferno", "1")
IniReadS($iCmbWeakEagle[$LB], $config, "search", "ABWeakEagle", "2")
IniReadS($iChkMaxMortar[$LB], $config, "search", "ABCheckMortar", "0")
IniReadS($iChkMaxWizTower[$LB], $config, "search", "ABCheckWizTower", "0")
IniReadS($iChkMaxAirDefense[$LB], $config, "search", "ABCheckAirDefense", "0")
IniReadS($iChkMaxXBow[$LB], $config, "search", "ABCheckXBow", "0")
IniReadS($iChkMaxInferno[$LB], $config, "search", "ABCheckInferno", "0")
IniReadS($iChkMaxEagle[$LB], $config, "search", "ABCheckEagle", "0")
IniReadS($iChkSearchReduction, $config, "search", "reduction", "0")
IniReadS($ReduceCount, $config, "search", "reduceCount", "20")
IniReadS($ReduceGold, $config, "search", "reduceGold", "2000")
IniReadS($ReduceElixir, $config, "search", "reduceElixir", "2000")
IniReadS($ReduceGoldPlusElixir, $config, "search", "reduceGoldPlusElixir", "4000")
IniReadS($ReduceDark, $config, "search", "reduceDark", "100")
IniReadS($ReduceTrophy, $config, "search", "reduceTrophy", "2")
IniReadS($iChkRestartSearchLimit, $config, "search", "ChkRestartSearchLimit", "1")
IniReadS($iRestartSearchlimit, $config, "search", "RestartSearchLimit", "50")
IniReadS($iDBcheck, $config, "search", "DBcheck", "1")
IniReadS($iABcheck, $config, "search", "ABcheck", "0")
IniReadS($iTScheck, $config, "search", "TScheck", "0")
IniReadS($iEnableSearchSearches[$DB], $config, "search", "ChkDBSearchSearches", "1")
IniReadS($iEnableSearchSearches[$LB], $config, "search", "ChkABSearchSearches", "0")
IniReadS($iEnableSearchSearches[$TS], $config, "search", "ChkTSSearchSearches", "0")
IniReadS($iEnableSearchTropies[$DB], $config, "search", "ChkDBSearchTropies", "0")
IniReadS($iEnableSearchTropies[$LB], $config, "search", "ChkABSearchTropies", "0")
IniReadS($iEnableSearchTropies[$TS], $config, "search", "ChkTSSearchTropies", "0")
IniReadS($iEnableSearchCamps[$DB], $config, "search", "ChkDBSearchCamps", "0")
IniReadS($iEnableSearchCamps[$LB], $config, "search", "ChkABSearchCamps", "0")
IniReadS($iEnableSearchCamps[$TS], $config, "search", "ChkTSSearchCamps", "0")
IniReadS($OptBullyMode, $config, "search", "BullyMode", "0")
IniReadS($ATBullyMode, $config, "search", "ATBullyMode", "0")
IniReadS($YourTH, $config, "search", "YourTH", "0")
IniReadS($iTHBullyAttackMode, $config, "search", "THBullyAttackMode", "0")
IniReadS($THaddtiles, $config, "search", "THaddTiles", "2")
IniReadS($iEnableAfterCount[$TS], $config, "search", "TSEnableAfterCount", "1")
IniReadS($iEnableBeforeCount[$TS], $config, "search", "TSEnableBeforeCount", "9999", "Int")
IniReadS($iEnableAfterTropies[$TS], $config, "search", "TSEnableAfterTropies", "100", "Int")
IniReadS($iEnableBeforeTropies[$TS], $config, "search", "TSEnableBeforeTropies", "6000", "Int")
IniReadS($iEnableAfterArmyCamps[$TS], $config, "search", "TSEnableAfterArmyCamps", "100", "Int")
IniReadS($iMinGold[$TS], $config, "search", "TSsearchGold", "80000", "Int")
IniReadS($iMinElixir[$TS], $config, "search", "TSsearchElixir", "80000", "Int")
IniReadS($iMinGoldPlusElixir[$TS], $config, "search", "TSsearchGoldPlusElixir", "160000", "Int")
IniReadS($iMinDark[$TS], $config, "search", "TSsearchDark", "600", "Int")
IniReadS($iCmbMeetGE[$TS], $config, "search", "TSMeetGE", "1")
IniReadS($iChkTrophyRange, $config, "search", "TrophyRange", "0")
IniReadS($itxtdropTrophy, $config, "search", "MinTrophy", "5000", "Int")
IniReadS($itxtMaxTrophy, $config, "search", "MaxTrophy", "5000", "Int")
IniReadS($iChkTrophyHeroes, $config, "search", "chkTrophyHeroes", "0")
IniReadS($iChkTrophyAtkDead, $config, "search", "chkTrophyAtkDead", "0")
IniReadS($itxtDTArmyMin, $config, "search", "DTArmyMin", "70")
IniReadS($itxtSWTtiles, $config, "search", "SWTtiles", "1")
IniReadS($iAtkAlgorithm[$DB], $config, "attack", "DBAtkAlgorithm", "0")
IniReadS($iAtkAlgorithm[$LB], $config, "attack", "ABAtkAlgorithm", "0")
IniReadS($iChkDeploySettings[$DB], $config, "attack", "DBDeploy", "3")
IniReadS($iCmbUnitDelay[$DB], $config, "attack", "DBUnitD", "4")
IniReadS($iCmbWaveDelay[$DB], $config, "attack", "DBWaveD", "4")
IniReadS($iChkRandomspeedatk[$DB], $config, "attack", "DBRandomSpeedAtk", "1")
IniReadS($iChkDeploySettings[$LB], $config, "attack", "ABDeploy", "0")
IniReadS($iCmbUnitDelay[$LB], $config, "attack", "ABUnitD", "4")
IniReadS($iCmbWaveDelay[$LB], $config, "attack", "ABWaveD", "4")
IniReadS($iChkRandomspeedatk[$LB], $config, "attack", "ABRandomSpeedAtk", "1")
IniReadS($iCmbSelectTroop[$DB], $config, "attack", "DBSelectTroop", "0")
IniReadS($iCmbSelectTroop[$LB], $config, "attack", "ABSelectTroop", "0")
IniReadS($iCmbSelectTroop[$TS], $config, "attack", "TSSelectTroop", "0")
IniReadS($iChkRedArea[$DB], $config, "attack", "DBSmartAttackRedArea", "1")
IniReadS($iCmbSmartDeploy[$DB], $config, "attack", "DBSmartAttackDeploy", "0")
IniReadS($iChkSmartAttack[$DB][0], $config, "attack", "DBSmartAttackGoldMine", "0")
IniReadS($iChkSmartAttack[$DB][1], $config, "attack", "DBSmartAttackElixirCollector", "0")
IniReadS($iChkSmartAttack[$DB][2], $config, "attack", "DBSmartAttackDarkElixirDrill", "0")
IniReadS($iChkRedArea[$LB], $config, "attack", "ABSmartAttackRedArea", "1")
IniReadS($iCmbSmartDeploy[$LB], $config, "attack", "ABSmartAttackDeploy", "1")
IniReadS($iChkSmartAttack[$LB][0], $config, "attack", "ABSmartAttackGoldMine", "0")
IniReadS($iChkSmartAttack[$LB][1], $config, "attack", "ABSmartAttackElixirCollector", "0")
IniReadS($iChkSmartAttack[$LB][2], $config, "attack", "ABSmartAttackDarkElixirDrill", "0")
IniReadS($KingAttack[$DB], $config, "attack", "DBKingAtk", "0")
IniReadS($KingAttack[$LB], $config, "attack", "ABKingAtk", "0")
IniReadS($KingAttack[$TS], $config, "attack", "TSKingAtk", "0")
IniReadS($QueenAttack[$DB], $config, "attack", "DBQueenAtk", "0")
IniReadS($QueenAttack[$LB], $config, "attack", "ABQueenAtk", "0")
IniReadS($QueenAttack[$TS], $config, "attack", "TSQueenAtk", "0")
IniReadS($iCmbStandardAlgorithm[$DB], $config, "attack", "DBStandardAlgorithm", "0")
IniReadS($iCmbStandardAlgorithm[$LB], $config, "attack", "LBStandardAlgorithm", "0")
Local $temp1, $temp2, $temp3
IniReadS($temp1, $config, "attack", "DBKingAtk", $HERO_NOHERO)
IniReadS($temp2, $config, "attack", "DBQueenAtk", $HERO_NOHERO)
IniReadS($temp3, $config, "attack", "DBWardenAtk", $HERO_NOHERO)
$iHeroAttack[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($temp1, $config, "attack", "ABKingAtk", $HERO_NOHERO)
IniReadS($temp2, $config, "attack", "ABQueenAtk", $HERO_NOHERO)
IniReadS($temp3, $config, "attack", "ABWardenAtk", $HERO_NOHERO)
$iHeroAttack[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($temp1, $config, "attack", "DBKingWait", $HERO_NOHERO)
IniReadS($temp2, $config, "attack", "DBQueenWait", $HERO_NOHERO)
IniReadS($temp3, $config, "attack", "DBWardenWait", $HERO_NOHERO)
$iHeroWait[$DB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($temp1, $config, "attack", "ABKingWait", $HERO_NOHERO)
IniReadS($temp2, $config, "attack", "ABQueenWait", $HERO_NOHERO)
IniReadS($temp3, $config, "attack", "ABWardenWait", $HERO_NOHERO)
$iHeroWait[$LB] = BitOR(Int($temp1), Int($temp2), Int($temp3))
IniReadS($iDropCC[$DB], $config, "attack", "DBDropCC", "0")
IniReadS($iDropCC[$LB], $config, "attack", "ABDropCC", "0")
IniReadS($iDropCC[$TS], $config, "attack", "TSDropCC", "0")
IniReadS($WardenAttack[$DB], $config, "attack", "DBWardenAtk", "0")
IniReadS($WardenAttack[$LB], $config, "attack", "ABWardenAtk", "0")
IniReadS($WardenAttack[$TS], $config, "attack", "TSWardenAtk", "0")
IniReadS($ichkLightSpell[$DB], $config, "attack", "DBLightSpell", "0")
IniReadS($ichkLightSpell[$LB], $config, "attack", "ABLightSpell", "0")
IniReadS($ichkLightSpell[$TS], $config, "attack", "TSLightSpell", "0")
IniReadS($ichkHealSpell[$DB], $config, "attack", "DBHealSpell", "0")
IniReadS($ichkHealSpell[$LB], $config, "attack", "ABHealSpell", "0")
IniReadS($ichkHealSpell[$TS], $config, "attack", "TSHealSpell", "0")
IniReadS($ichkRageSpell[$DB], $config, "attack", "DBRageSpell", "0")
IniReadS($ichkRageSpell[$LB], $config, "attack", "ABRageSpell", "0")
IniReadS($ichkRageSpell[$TS], $config, "attack", "TSRageSpell", "0")
IniReadS($ichkJumpSpell[$DB], $config, "attack", "DBJumpSpell", "0")
IniReadS($ichkJumpSpell[$LB], $config, "attack", "ABJumpSpell", "0")
IniReadS($ichkJumpSpell[$TS], $config, "attack", "TSJumpSpell", "0")
IniReadS($ichkFreezeSpell[$DB], $config, "attack", "DBFreezeSpell", "0")
IniReadS($ichkFreezeSpell[$LB], $config, "attack", "ABFreezeSpell", "0")
IniReadS($ichkFreezeSpell[$TS], $config, "attack", "TSFreezeSpell", "0")
IniReadS($ichkPoisonSpell[$DB], $config, "attack", "DBPoisonSpell", "0")
IniReadS($ichkPoisonSpell[$LB], $config, "attack", "ABPoisonSpell", "0")
IniReadS($ichkPoisonSpell[$TS], $config, "attack", "TSPoisonSpell", "0")
IniReadS($ichkEarthquakeSpell[$DB], $config, "attack", "DBEarthquakeSpell", "0")
IniReadS($ichkEarthquakeSpell[$LB], $config, "attack", "ABEarthquakeSpell", "0")
IniReadS($ichkEarthquakeSpell[$TS], $config, "attack", "TSEarthquakeSpell", "0")
IniReadS($ichkHasteSpell[$DB], $config, "attack", "DBHasteSpell", "0")
IniReadS($ichkHasteSpell[$LB], $config, "attack", "ABHasteSpell", "0")
IniReadS($ichkHasteSpell[$TS], $config, "attack", "TSHasteSpell", "0")
IniReadS($scmbDBScriptName, $config, "attack", "ScriptDB", "Barch four fingers")
IniReadS($scmbABScriptName, $config, "attack", "ScriptAB", "Barch four fingers")
IniReadS($iActivateKQCondition, $config, "attack", "ActivateKQ", "Auto")
IniReadS($delayActivateKQ, $config, "attack", "delayActivateKQ", "9")
$delayActivateKQ *= 1000
IniReadS($iActivateWardenCondition, $config, "attack", "ActivateWarden", "1")
IniReadS($delayActivateW, $config, "attack", "delayActivateW", "9")
$delayActivateW *= 1000
IniReadS($TakeLootSnapShot, $config, "attack", "TakeLootSnapShot", "0")
IniReadS($ScreenshotLootInfo, $config, "attack", "ScreenshotLootInfo", "0")
IniReadS($scmbAttackTHType, $config, "attack", "AttackTHType", "bam")
IniReadS($THSnipeBeforeDBEnable, $config, "attack", "THSnipeBeforeDBEnable", "0")
IniReadS($THSnipeBeforeLBEnable, $config, "attack", "THSnipeBeforeLBEnable", "0")
IniReadS($THSnipeBeforeDBTiles, $config, "attack", "THSnipeBeforeDBTiles", "0")
IniReadS($THSnipeBeforeLBTiles, $config, "attack", "THSnipeBeforeLBTiles", "0")
IniReadS($THSnipeBeforeDBScript, $config, "attack", "THSnipeBeforeDBScript", "bam")
IniReadS($THSnipeBeforeLBScript, $config, "attack", "THSnipeBeforeLBScript", "bam")
IniReadS($MilkFarmLocateMine, $config, "MilkingAttack", "LocateMine", "1")
IniReadS($MilkFarmLocateElixir, $config, "MilkingAttack", "LocateElixir", "1")
IniReadS($MilkFarmLocateDrill, $config, "MilkingAttack", "LocateDrill", "1")
Local $tempMilkFarmElixirParam
IniReadS($tempMilkFarmElixirParam, $config, "MilkingAttack", "LocateElixirLevel", "-1|-1|-1|-1|-1|-1|2|2|2")
$MilkFarmElixirParam = StringSplit($tempMilkFarmElixirParam, "|", 2)
If UBound($MilkFarmElixirParam) <> 9 Then $MilkFarmElixirParam = StringSplit("-1|-1|-1|-1|-1|-1|2|2|2", "|", 2)
IniReadS($MilkFarmMineParam, $config, "MilkingAttack", "MineParam", "5")
IniReadS($MilkFarmDrillParam, $config, "MilkingAttack", "DrillParam", "1")
IniReadS($MilkFarmAttackElixirExtractors, $config, "MilkingAttack", "AttackElixir", "1")
IniReadS($MilkFarmAttackGoldMines, $config, "MilkingAttack", "AttackMine", "1")
IniReadS($MilkFarmAttackDarkDrills, $config, "MilkingAttack", "AttackDrill", "1")
IniReadS($MilkFarmLimitGold, $config, "MilkingAttack", "LimitGold", "9950000")
IniReadS($MilkFarmLimitElixir, $config, "MilkingAttack", "LimitElixir", "9950000")
IniReadS($MilkFarmLimitDark, $config, "MilkingAttack", "LimitDark", "200000")
IniReadS($MilkFarmResMaxTilesFromBorder, $config, "MilkingAttack", "MaxTiles", "1")
IniReadS($MilkFarmTroopForWaveMin, $config, "MilkingAttack", "TroopForWaveMin", "4")
IniReadS($MilkFarmTroopForWaveMax, $config, "MilkingAttack", "TroopForWaveMax", "6")
IniReadS($MilkFarmTroopMaxWaves, $config, "MilkingAttack", "MaxWaves", "4")
IniReadS($MilkFarmDelayFromWavesMin, $config, "MilkingAttack", "DelayBetweenWavesMin", "3000")
IniReadS($MilkFarmDelayFromWavesMax, $config, "MilkingAttack", "DelayBetweenWavesMax", "5000")
IniReadS($MilkFarmForcetolerance, $config, "MilkingAttack", "MilkFarmForceTolerance", "0")
IniReadS($MilkFarmForcetolerancenormal, $config, "MilkingAttack", "MilkFarmForcetolerancenormal", "60")
IniReadS($MilkFarmForcetoleranceboosted, $config, "MilkingAttack", "MilkFarmForcetoleranceboosted", "60")
IniReadS($MilkFarmForcetolerancedestroyed, $config, "MilkingAttack", "MilkFarmForcetolerancedestroyed", "60")
IniReadS($MilkingAttackCheckStructureDestroyedBeforeAttack, $config, "MilkingAttack", "CheckStructureDestroyedBeforeAttack", "0")
IniReadS($MilkingAttackCheckStructureDestroyedAfterAttack, $config, "MilkingAttack", "CheckStructureDestroyedAfterAttack", "0")
IniReadS($MilkingAttackDropGoblinAlgorithm, $config, "MilkingAttack", "DropRandomPlace", "0")
IniReadS($MilkFarmTHMaxTilesFromBorder, $config, "MilkingAttack", "TownhallTiles", "0")
IniReadS($MilkFarmAlgorithmTh, $config, "MilkingAttack", "TownHallAlgorithm", "Bam")
IniReadS($MilkFarmSnipeEvenIfNoExtractorsFound, $config, "MilkingAttack", "TownHallHitAnyway", "0")
IniReadS($MilkingAttackStructureOrder, $config, "MilkingAttack", "StructureOrder", "1")
IniReadS($MilkAttackAfterTHSnipe, $config, "MilkingAttack", "MilkAttackAfterTHSnipe", "0")
IniReadS($MilkAttackAfterScriptedAtk, $config, "MilkingAttack", "MilkAttackAfterScriptedAtk", "0")
IniReadS($MilkAttackCSVscript, $config, "MilkingAttack", "MilkAttackCSVscript", "0")
IniReadS($MilkAttackType, $config, "MilkingAttack", "MilkAttackType", "0")
IniReadS($sTimeStopAtk[$DB], $config, "endbattle", "txtDBTimeStopAtk", "20")
IniReadS($iChkTimeStopAtk[$DB], $config, "endbattle", "chkDBTimeStopAtk", "1")
IniReadS($sTimeStopAtk2[$DB], $config, "endbattle", "txtDBTimeStopAtk2", "7")
IniReadS($iChkTimeStopAtk2[$DB], $config, "endbattle", "chkDBTimeStopAtk2", "0")
IniReadS($stxtMinGoldStopAtk2[$DB], $config, "endbattle", "txtDBMinGoldStopAtk2", "1000")
IniReadS($stxtMinElixirStopAtk2[$DB], $config, "endbattle", "txtDBMinElixirStopAtk2", "1000")
IniReadS($stxtMinDarkElixirStopAtk2[$DB], $config, "endbattle", "txtDBMinDarkElixirStopAtk2", "50")
IniReadS($ichkEndOneStar[$DB], $config, "endbattle", "chkDBEndOneStar", "0")
IniReadS($ichkEndTwoStars[$DB], $config, "endbattle", "chkDBEndTwoStars", "0")
IniReadS($ichkEndNoResources[$DB], $config, "endbattle", "chkDBEndNoResources", "0")
IniReadS($sTimeStopAtk[$LB], $config, "endbattle", "txtABTimeStopAtk", "20")
IniReadS($iChkTimeStopAtk[$LB], $config, "endbattle", "chkABTimeStopAtk", "1")
IniReadS($sTimeStopAtk2[$LB], $config, "endbattle", "txtABTimeStopAtk2", "7")
IniReadS($iChkTimeStopAtk2[$LB], $config, "endbattle", "chkABTimeStopAtk2", "0")
IniReadS($stxtMinGoldStopAtk2[$LB], $config, "endbattle", "txtABMinGoldStopAtk2", "1000")
IniReadS($stxtMinElixirStopAtk2[$LB], $config, "endbattle", "txtABMinElixirStopAtk2", "1000")
IniReadS($stxtMinDarkElixirStopAtk2[$LB], $config, "endbattle", "txtABMinDarkElixirStopAtk2", "50")
IniReadS($ichkEndOneStar[$LB], $config, "endbattle", "chkABEndOneStar", "0")
IniReadS($ichkEndTwoStars[$LB], $config, "endbattle", "chkABEndTwoStars", "0")
IniReadS($ichkEndNoResources[$LB], $config, "endbattle", "chkABEndNoResources", "0")
IniReadS($DESideEB, $config, "endbattle", "chkDESideEB", "0")
IniReadS($DELowEndMin, $config, "endbattle", "txtDELowEndMin", "25")
IniReadS($DisableOtherEBO, $config, "endbattle", "chkDisableOtherEBO", "0")
IniReadS($DEEndOneStar, $config, "endbattle", "chkDEEndOneStar", "0")
IniReadS($DEEndBk, $config, "endbattle", "chkDEEndBk", "0")
IniReadS($DEEndAq, $config, "endbattle", "chkDEEndAq", "0")
IniReadS($iUnbreakableMode, $config, "Unbreakable", "chkUnbreakable", "0")
IniReadS($iUnbreakableWait, $config, "Unbreakable", "UnbreakableWait", "5")
IniReadS($iUnBrkMinGold, $config, "Unbreakable", "minUnBrkgold", "50000")
IniReadS($iUnBrkMinElixir, $config, "Unbreakable", "minUnBrkelixir", "50000")
IniReadS($iUnBrkMinDark, $config, "Unbreakable", "minUnBrkdark", "5000")
IniReadS($iUnBrkMaxGold, $config, "Unbreakable", "maxUnBrkgold", "600000")
IniReadS($iUnBrkMaxElixir, $config, "Unbreakable", "maxUnBrkelixir", "600000")
IniReadS($iUnBrkMaxDark, $config, "Unbreakable", "maxUnBrkdark", "10000")
IniReadS($iChkUseCCBalanced, $config, "ClanClastle", "BalanceCC", "0")
IniReadS($iCmbCCDonated, $config, "ClanClastle", "BalanceCCDonated", "1")
IniReadS($iCmbCCReceived, $config, "ClanClastle", "BalanceCCReceived", "1")
IniReadS($ichkTrap, $config, "other", "chkTrap", "1")
IniReadS($iChkCollect, $config, "other", "chkCollect", "1")
IniReadS($ichkTombstones, $config, "other", "chkTombstones", "1")
IniReadS($ichkCleanYard, $config, "other", "chkCleanYard", "0")
IniReadS($ichkGemsBox, $config, "other", "chkGemsBox", "0")
IniReadS($sTimeWakeUp, $config, "other", "txtTimeWakeUp", "0")
IniReadS($iVSDelay, $config, "other", "VSDelay", "0")
IniReadS($iMaxVSDelay, $config, "other", "MaxVSDelay", "4")
IniReadS($iWAOffsetX, $config, "other", "WAOffsetX", "0")
IniReadS($iWAOffsetY, $config, "other", "WAOffsetY", "0")
IniReadS($NotifyPBToken, $config, "notify", "AccountToken", "")
IniReadS($NotifyTGToken, $config, "notify", "TGToken", "")
IniReadS($NotifyOrigin, $config, "notify", "OrigPushBullet", $sCurrProfile)
IniReadS($NotifyAlerLastRaidTXT, $config, "notify", "AlertPBLastRaidTxt", "0")
IniReadS($NotifyPBEnabled, $config, "notify", "PBEnabled", "0")
IniReadS($NotifyTGEnabled, $config, "notify", "TGEnabled", "0")
IniReadS($NotifyRemoteEnable, $config, "notify", "PBRemote", "0")
IniReadS($NotifyDeleteAllPushesOnStart, $config, "notify", "DeleteAllPBPushes", "0")
IniReadS($NotifyAlertMatchFound, $config, "notify", "AlertPBVMFound", "0")
IniReadS($NotifyAlerLastRaidIMG, $config, "notify", "AlertPBLastRaid", "0")
IniReadS($NotifyAlertUpgradeWalls, $config, "notify", "AlertPBWallUpgrade", "0")
IniReadS($NotifyAlertOutOfSync, $config, "notify", "AlertPBOOS", "0")
IniReadS($NotifyAlertTakeBreak, $config, "notify", "AlertPBVBreak", "0")
IniReadS($NotifyAlertAnotherDevice, $config, "notify", "AlertPBOtherDevice", "0")
IniReadS($NotifyDeletePushesOlderThanHours, $config, "notify", "HoursPushBullet", "4")
IniReadS($NotifyDeletePushesOlderThan, $config, "notify", "DeleteOldPBPushes", "0")
IniReadS($NotifyAlertCampFull, $config, "notify", "AlertPBCampFull", "0")
IniReadS($NotifyAlertVillageReport, $config, "notify", "AlertPBVillage", "0")
IniReadS($NotifyAlertLastAttack, $config, "notify", "AlertPBLastAttack", "0")
IniReadS($NotifyAlertBulderIdle, $config, "notify", "AlertBuilderIdle", "0")
IniReadS($NotifyAlertMaintenance, $config, "notify", "AlertPBMaintenance", "0")
IniReadS($NotifyAlertBAN, $config, "notify", "AlertPBBAN", "0")
IniReadS($NotifyAlertBOTUpdate, $config, "notify", "AlertPBUpdate", "0")
$NotifyScheduleWeekDaysEnable = IniRead($config, "notify", "NotifyWeekDaysEnable", "0")
$NotifyScheduleWeekDays = StringSplit(IniRead($config, "notify", "NotifyWeekDays", "1|1|1|1|1|1|1"),"|", $STR_NOCOUNT)
$NotifyScheduleHoursEnable = IniRead($config, "notify", "NotifyHoursEnable", "0")
$NotifyScheduleHours = StringSplit(IniRead($config, "notify", "NotifyHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"),"|", $STR_NOCOUNT)
IniReadS($ichkDeleteLogs, $config, "deletefiles", "DeleteLogs", "1")
IniReadS($iDeleteLogsDays, $config, "deletefiles", "DeleteLogsDays", "2")
IniReadS($ichkDeleteTemp, $config, "deletefiles", "DeleteTemp", "1")
IniReadS($iDeleteTempDays, $config, "deletefiles", "DeleteTempDays", "2")
IniReadS($ichkDeleteLoots, $config, "deletefiles", "DeleteLoots", "1")
IniReadS($iDeleteLootsDays, $config, "deletefiles", "DeleteLootsDays", "2")
$DebugClick = BitOR($DebugClick, IniRead($config, "debug", "debugsetclick", "0"))
If $DevMode = 1 Then
$DebugSetlog = BitOR($DebugSetlog, IniRead($config, "debug", "debugsetlog", "0"))
$DebugOcr = BitOR($DebugOcr, IniRead($config, "debug", "debugocr", "0"))
$DebugImageSave = BitOR($DebugImageSave, IniRead($config, "debug", "debugimagesave", "0"))
$debugBuildingPos = BitOR($debugBuildingPos, IniRead($config, "debug", "debugbuildingpos", "0"))
$debugsetlogTrain = BitOR($debugsetlogTrain, IniRead($config, "debug", "debugtrain", "0"))
$makeIMGCSV = BitOR($debugBuildingPos, IniRead($config, "debug", "debugmakeimgcsv", "0"))
$debugresourcesoffset = BitOR($debugresourcesoffset, IniRead($config, "debug", "debugresourcesoffset", "0"))
$continuesearchelixirdebug = BitOR($continuesearchelixirdebug, IniRead($config, "debug", "continuesearchelixirdebug", "0"))
$debugMilkingIMGmake = BitOR($debugMilkingIMGmake, IniRead($config, "debug", "debugMilkingIMGmake", "0"))
$debugOCRdonate = BitOR($debugOCRdonate, IniRead($config, "debug", "debugOCRDonate", "0"))
EndIf
$iPlannedDonateHours = StringSplit(IniRead($config, "planned", "DonateHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
$iPlannedRequestCCHours = StringSplit(IniRead($config, "planned", "RequestHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
$iPlannedDropCCHours = StringSplit(IniRead($config, "planned", "DropCCHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
$iPlannedDonateHoursEnable = IniRead($config, "planned", "DonateHoursEnable", "0")
$iPlannedRequestCCHoursEnable = IniRead($config, "planned", "RequestHoursEnable", "0")
$iPlannedDropCCHoursEnable = IniRead($config, "planned", "DropCCEnable", "0")
$iPlannedBoostBarracksEnable = IniRead($config, "planned", "BoostBarracksHoursEnable", "0")
$iPlannedBoostBarracksHours = StringSplit(IniRead($config, "planned", "BoostBarracksHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
$iPlannedattackHours = StringSplit(IniRead($config, "planned", "attackHours", "1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
$iPlannedAttackWeekDays = StringSplit(IniRead($config, "planned", "attackDays", "1|1|1|1|1|1|1"), "|", $STR_NOCOUNT)
$ichkAttackPlannerEnable = IniRead($config, "planned", "chkAttackPlannerEnable", "0")
$ichkAttackPlannerCloseCoC = IniRead($config, "planned", "chkAttackPlannerCloseCoC", "0")
$ichkAttackPlannerCloseAll = IniRead($config, "planned", "chkAttackPlannerCloseAll", "0")
$ichkAttackPlannerRandom = IniRead($config, "planned", "chkAttackPlannerRandom", "0")
$icmbAttackPlannerRandom = IniRead($config, "planned", "cmbAttackPlannerRandom", "4")
$ichkAttackPlannerDayLimit = IniRead($config, "planned", "chkAttackPlannerDayLimit", "0")
$icmbAttackPlannerDayMin = IniRead($config, "planned", "cmbAttackPlannerDayMin", "12")
$icmbAttackPlannerDayMax = IniRead($config, "planned", "cmbAttackPlannerDayMax", "15")
$iShareminGold = IniRead($config, "shareattack", "minGold", "200000")
$iShareminElixir = IniRead($config, "shareattack", "minElixir", "200000")
$iSharemindark = IniRead($config, "shareattack", "minDark", "100")
$iShareAttack = IniRead($config, "shareattack", "ShareAttack", "0")
$sShareMessage = StringReplace(IniRead($config, "shareattack", "Message", "Nice|Good|Thanks|Wowwww"), "|", @CRLF)
$iUseRandomClick = IniRead($config, "other", "UseRandomClick", "0")
$iScreenshotType = IniRead($config, "other", "ScreenshotType", "0")
$ichkScreenshotHideName = IniRead($config, "other", "ScreenshotHideName", "1")
$ichkUseQTrain = IniRead($config, "other", "ChkUseQTrain", "0")
$ichkForceBrewBeforeAttack = IniRead($config, "other", "ChkForceBrewBeforeAttack", "0")
$ichkTotalCampForced = IniRead($config, "other", "ChkTotalCampForced", "1")
$iValueTotalCampForced = IniRead($config, "other", "ValueTotalCampForced", "200")
$ichkSinglePBTForced = IniRead($config, "other", "chkSinglePBTForced", "0")
$iValueSinglePBTimeForced = IniRead($config, "other", "ValueSinglePBTimeForced", "18")
$iValuePBTimeForcedExit = IniRead($config, "other", "ValuePBTimeForcedExit", "15")
$ichkLanguage = IniRead($config, "General", "ChkLanguage", "1")
$ichkDisableSplash = IniRead($config, "General", "ChkDisableSplash", $ichkDisableSplash)
$ichkVersion = IniRead($config, "General", "ChkVersion", "1")
$sTxtRequest = IniRead($config, "donate", "txtRequest", "")
$ichkDonateBarbarians = IniRead($config, "donate", "chkDonateBarbarians", "0")
$ichkDonateAllBarbarians = IniRead($config, "donate", "chkDonateAllBarbarians", "0")
$sTxtDonateBarbarians = StringReplace(IniRead($config, "donate", "txtDonateBarbarians", "barbarians|barbarian|barb"), "|", @CRLF)
$sTxtBlacklistBarbarians = StringReplace(IniRead($config, "donate", "txtBlacklistBarbarians", "no barbarians|no barb|barbarian no|barb no"), "|", @CRLF)
$aDonBarbarians = StringSplit($sTxtDonateBarbarians, @CRLF, $STR_ENTIRESPLIT)
$aBlkBarbarians = StringSplit($sTxtBlacklistBarbarians, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateArchers = IniRead($config, "donate", "chkDonateArchers", "0")
$ichkDonateAllArchers = IniRead($config, "donate", "chkDonateAllArchers", "0")
$sTxtDonateArchers = StringReplace(IniRead($config, "donate", "txtDonateArchers", "archers|archer|arch"), "|", @CRLF)
$sTxtBlacklistArchers = StringReplace(IniRead($config, "donate", "txtBlacklistArchers", "no archers|no arch|archer no|arch no"), "|", @CRLF)
$aDonArchers = StringSplit($sTxtDonateArchers, @CRLF, $STR_ENTIRESPLIT)
$aBlkArchers = StringSplit($sTxtBlacklistArchers, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateGiants = IniRead($config, "donate", "chkDonateGiants", "0")
$ichkDonateAllGiants = IniRead($config, "donate", "chkDonateAllGiants", "0")
$sTxtDonateGiants = StringReplace(IniRead($config, "donate", "txtDonateGiants", "giants|giant|any"), "|", @CRLF)
$sTxtBlacklistGiants = StringReplace(IniRead($config, "donate", "txtBlacklistGiants", "no giants|giants no"), "|", @CRLF)
$aDonGiants = StringSplit($sTxtDonateGiants, @CRLF, $STR_ENTIRESPLIT)
$aBlkGiants = StringSplit($sTxtBlacklistGiants, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateGoblins = IniRead($config, "donate", "chkDonateGoblins", "0")
$ichkDonateAllGoblins = IniRead($config, "donate", "chkDonateAllGoblins", "0")
$sTxtDonateGoblins = StringReplace(IniRead($config, "donate", "txtDonateGoblins", "goblins|goblin"), "|", @CRLF)
$sTxtBlacklistGoblins = StringReplace(IniRead($config, "donate", "txtBlacklistGoblins", "no goblins|goblins no"), "|", @CRLF)
$aDonGoblins = StringSplit($sTxtDonateGoblins, @CRLF, $STR_ENTIRESPLIT)
$aBlkGoblins = StringSplit($sTxtBlacklistGoblins, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateWallBreakers = IniRead($config, "donate", "chkDonateWallBreakers", "0")
$ichkDonateAllWallBreakers = IniRead($config, "donate", "chkDonateAllWallBreakers", "0")
$sTxtDonateWallBreakers = StringReplace(IniRead($config, "donate", "txtDonateWallBreakers", "wall breakers|wb"), "|", @CRLF)
$sTxtBlacklistWallBreakers = StringReplace(IniRead($config, "donate", "txtBlacklistWallBreakers", "no wallbreakers|wb no"), "|", @CRLF)
$aDonWallBreakers = StringSplit($sTxtDonateWallBreakers, @CRLF, $STR_ENTIRESPLIT)
$aBlkWallBreakers = StringSplit($sTxtBlacklistWallBreakers, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateBalloons = IniRead($config, "donate", "chkDonateBalloons", "0")
$ichkDonateAllBalloons = IniRead($config, "donate", "chkDonateAllBalloons", "0")
$sTxtDonateBalloons = StringReplace(IniRead($config, "donate", "txtDonateBalloons", "balloons|balloon"), "|", @CRLF)
$sTxtBlacklistBalloons = StringReplace(IniRead($config, "donate", "txtBlacklistBalloons", "no balloon|balloons no"), "|", @CRLF)
$aDonBalloons = StringSplit($sTxtDonateBalloons, @CRLF, $STR_ENTIRESPLIT)
$aBlkBalloons = StringSplit($sTxtBlacklistBalloons, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateWizards = IniRead($config, "donate", "chkDonateWizards", "0")
$ichkDonateAllWizards = IniRead($config, "donate", "chkDonateAllWizards", "0")
$sTxtDonateWizards = StringReplace(IniRead($config, "donate", "txtDonateWizards", "wizards|wizard|wiz"), "|", @CRLF)
$sTxtBlacklistWizards = StringReplace(IniRead($config, "donate", "txtBlacklistWizards", "no wizards|wizards no|no wizard|wizard no"), "|", @CRLF)
$aDonWizards = StringSplit($sTxtDonateWizards, @CRLF, $STR_ENTIRESPLIT)
$aBlkWizards = StringSplit($sTxtBlacklistWizards, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateHealers = IniRead($config, "donate", "chkDonateHealers", "0")
$ichkDonateAllHealers = IniRead($config, "donate", "chkDonateAllHealers", "0")
$sTxtDonateHealers = StringReplace(IniRead($config, "donate", "txtDonateHealers", "healer"), "|", @CRLF)
$sTxtBlacklistHealers = StringReplace(IniRead($config, "donate", "txtBlacklistHealers", "no healer|healer no"), "|", @CRLF)
$aDonHealers = StringSplit($sTxtDonateHealers, @CRLF, $STR_ENTIRESPLIT)
$aBlkHealers = StringSplit($sTxtBlacklistHealers, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateDragons = IniRead($config, "donate", "chkDonateDragons", "0")
$ichkDonateAllDragons = IniRead($config, "donate", "chkDonateAllDragons", "0")
$sTxtDonateDragons = StringReplace(IniRead($config, "donate", "txtDonateDragons", "dragon"), "|", @CRLF)
$sTxtBlacklistDragons = StringReplace(IniRead($config, "donate", "txtBlacklistDragons", "no dragon|dragon no"), "|", @CRLF)
$aDonDragons = StringSplit($sTxtDonateDragons, @CRLF, $STR_ENTIRESPLIT)
$aBlkDragons = StringSplit($sTxtBlacklistDragons, @CRLF, $STR_ENTIRESPLIT)
$ichkDonatePekkas = IniRead($config, "donate", "chkDonatePekkas", "0")
$ichkDonateAllPekkas = IniRead($config, "donate", "chkDonateAllPekkas", "0")
$sTxtDonatePekkas = StringReplace(IniRead($config, "donate", "txtDonatePekkas", "PEKKA|pekka"), "|", @CRLF)
$sTxtBlacklistPekkas = StringReplace(IniRead($config, "donate", "txtBlacklistPekkas", "no PEKKA|pekka no"), "|", @CRLF)
$aDonPekkas = StringSplit($sTxtDonatePekkas, @CRLF, $STR_ENTIRESPLIT)
$aBlkPekkas = StringSplit($sTxtBlacklistPekkas, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateBabyDragons = IniRead($config, "donate", "chkDonateBabyDragons", "0")
$ichkDonateAllBabyDragons = IniRead($config, "donate", "chkDonateAllBabyDragons", "0")
$sTxtDonateBabyDragons = StringReplace(IniRead($config, "donate", "txtDonateBabyDragons", "baby dragon|baby"), "|", @CRLF)
$sTxtBlacklistBabyDragons = StringReplace(IniRead($config, "donate", "txtBlacklistBabyDragons", "no baby dragon|baby dragon no|no baby|baby no"), "|", @CRLF)
$aDonBabyDragons = StringSplit($sTxtDonateBabyDragons, @CRLF, $STR_ENTIRESPLIT)
$aBlkBabyDragons = StringSplit($sTxtBlacklistBabyDragons, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateMiners = IniRead($config, "donate", "chkDonateMiners", "0")
$ichkDonateAllMiners = IniRead($config, "donate", "chkDonateAllMiners", "0")
$sTxtDonateMiners = StringReplace(IniRead($config, "donate", "txtDonateMiners", "miner|mine"), "|", @CRLF)
$sTxtBlacklistMiners = StringReplace(IniRead($config, "donate", "txtBlacklistMiners", "no miner|miner no|no mine|mine no"), "|", @CRLF)
$aDonMiners = StringSplit($sTxtDonateMiners, @CRLF, $STR_ENTIRESPLIT)
$aBlkMiners = StringSplit($sTxtBlacklistMiners, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateMinions = IniRead($config, "donate", "chkDonateMinions", "0")
$ichkDonateAllMinions = IniRead($config, "donate", "chkDonateAllMinions", "0")
$sTxtDonateMinions = StringReplace(IniRead($config, "donate", "txtDonateMinions", "minions|minion"), "|", @CRLF)
$sTxtBlacklistMinions = StringReplace(IniRead($config, "donate", "txtBlacklistMinions", "no minion|minions no"), "|", @CRLF)
$aDonMinions = StringSplit($sTxtDonateMinions, @CRLF, $STR_ENTIRESPLIT)
$aBlkMinions = StringSplit($sTxtBlacklistMinions, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateHogRiders = IniRead($config, "donate", "chkDonateHogRiders", "0")
$ichkDonateAllHogRiders = IniRead($config, "donate", "chkDonateAllHogRiders", "0")
$sTxtDonateHogRiders = StringReplace(IniRead($config, "donate", "txtDonateHogRiders", "hogriders|hogs|hog"), "|", @CRLF)
$sTxtBlacklistHogRiders = StringReplace(IniRead($config, "donate", "txtBlacklistHogRiders", "no hogriders|hogriders no|no hog|hogs no"), "|", @CRLF)
$aDonHogRiders = StringSplit($sTxtDonateHogRiders, @CRLF, $STR_ENTIRESPLIT)
$aBlkHogRiders = StringSplit($sTxtBlacklistHogRiders, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateValkyries = IniRead($config, "donate", "chkDonateValkyries", "0")
$ichkDonateAllValkyries = IniRead($config, "donate", "chkDonateAllValkyries", "0")
$sTxtDonateValkyries = StringReplace(IniRead($config, "donate", "txtDonateValkyries", "valkyries|valkyrie|valk"), "|", @CRLF)
$sTxtBlacklistValkyries = StringReplace(IniRead($config, "donate", "txtBlacklistValkyries", "no valkyrie|valkyries no|no valk|valk no"), "|", @CRLF)
$aDonValkyries = StringSplit($sTxtDonateValkyries, @CRLF, $STR_ENTIRESPLIT)
$aBlkValkyries = StringSplit($sTxtBlacklistValkyries, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateGolems = IniRead($config, "donate", "chkDonateGolems", "0")
$ichkDonateAllGolems = IniRead($config, "donate", "chkDonateAllGolems", "0")
$sTxtDonateGolems = StringReplace(IniRead($config, "donate", "txtDonateGolems", "golem"), "|", @CRLF)
$sTxtBlacklistGolems = StringReplace(IniRead($config, "donate", "txtBlacklistGolems", "no golem|golem no"), "|", @CRLF)
$aDonGolems = StringSplit($sTxtDonateGolems, @CRLF, $STR_ENTIRESPLIT)
$aBlkGolems = StringSplit($sTxtBlacklistGolems, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateWitches = IniRead($config, "donate", "chkDonateWitches", "0")
$ichkDonateAllWitches = IniRead($config, "donate", "chkDonateAllWitches", "0")
$sTxtDonateWitches = StringReplace(IniRead($config, "donate", "txtDonateWitches", "witches|witch"), "|", @CRLF)
$sTxtBlacklistWitches = StringReplace(IniRead($config, "donate", "txtBlacklistWitches", "no witches|witches no|no witch|witch no"), "|", @CRLF)
$aDonWitches = StringSplit($sTxtDonateWitches, @CRLF, $STR_ENTIRESPLIT)
$aBlkWitches = StringSplit($sTxtBlacklistWitches, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateLavaHounds = IniRead($config, "donate", "chkDonateLavaHounds", "0")
$ichkDonateAllLavaHounds = IniRead($config, "donate", "chkDonateAllLavaHounds", "0")
$sTxtDonateLavaHounds = StringReplace(IniRead($config, "donate", "txtDonateLavaHounds", "lavahounds|lava|hound"), "|", @CRLF)
$sTxtBlacklistLavaHounds = StringReplace(IniRead($config, "donate", "txtBlacklistLavaHounds", "no lavahound|lavahound no|no lava|lava no|nohound|hound no"), "|", @CRLF)
$aDonLavaHounds = StringSplit($sTxtDonateLavaHounds, @CRLF, $STR_ENTIRESPLIT)
$aBlkLavaHounds = StringSplit($sTxtBlacklistLavaHounds, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateBowlers = IniRead($config, "donate", "chkDonateBowlers", "0")
$ichkDonateAllBowlers = IniRead($config, "donate", "chkDonateAllBowlers", "0")
$sTxtDonateBowlers = StringReplace(IniRead($config, "donate", "txtDonateBowlers", "bowler|bowl"), "|", @CRLF)
$sTxtBlacklistBowlers = StringReplace(IniRead($config, "donate", "txtBlacklistBowlers", "no bowler|bowl no"), "|", @CRLF)
$aDonBowlers = StringSplit($sTxtDonateBowlers, @CRLF, $STR_ENTIRESPLIT)
$aBlkBowlers = StringSplit($sTxtBlacklistBowlers, @CRLF, $STR_ENTIRESPLIT)
$ichkDonatePoisonSpells = IniRead($config, "donate", "chkDonatePoisonSpells", "0")
$ichkDonateAllPoisonSpells = IniRead($config, "donate", "chkDonateAllPoisonSpells", "0")
$sTxtDonatePoisonSpells = StringReplace(IniRead($config, "donate", "txtDonatePoisonSpells", "poison"), "|", @CRLF)
$sTxtBlacklistPoisonSpells = StringReplace(IniRead($config, "donate", "txtBlacklistPoisonSpells", "no poison|poison no"), "|", @CRLF)
$aDonPoisonSpells = StringSplit($sTxtDonatePoisonSpells, @CRLF, $STR_ENTIRESPLIT)
$aBlkPoisonSpells = StringSplit($sTxtBlacklistPoisonSpells, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateEarthQuakeSpells = IniRead($config, "donate", "chkDonateEarthQuakeSpells", "0")
$ichkDonateAllEarthQuakeSpells = IniRead($config, "donate", "chkDonateAllEarthQuakeSpells", "0")
$sTxtDonateEarthQuakeSpells = StringReplace(IniRead($config, "donate", "txtDonateEarthQuakeSpells", "earthquake|quake"), "|", @CRLF)
$sTxtBlacklistEarthQuakeSpells = StringReplace(IniRead($config, "donate", "txtBlacklistEarthQuakeSpells", "no earthquake|quake no"), "|", @CRLF)
$aDonEarthQuakeSpells = StringSplit($sTxtDonateEarthQuakeSpells, @CRLF, $STR_ENTIRESPLIT)
$aBlkEarthQuakeSpells = StringSplit($sTxtBlacklistEarthQuakeSpells, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateHasteSpells = IniRead($config, "donate", "chkDonateHasteSpells", "0")
$ichkDonateAllHasteSpells = IniRead($config, "donate", "chkDonateAllHasteSpells", "0")
$sTxtDonateHasteSpells = StringReplace(IniRead($config, "donate", "txtDonateHasteSpells", "haste"), "|", @CRLF)
$sTxtBlacklistHasteSpells = StringReplace(IniRead($config, "donate", "txtBlacklistHasteSpells", "no haste|haste no"), "|", @CRLF)
$aDonHasteSpells = StringSplit($sTxtDonateHasteSpells, @CRLF, $STR_ENTIRESPLIT)
$aBlkHasteSpells = StringSplit($sTxtBlacklistHasteSpells, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateSkeletonSpells = IniRead($config, "donate", "chkDonateSkeletonSpells", "0")
$ichkDonateAllSkeletonSpells = IniRead($config, "donate", "chkDonateAllSkeletonSpells", "0")
$sTxtDonateSkeletonSpells = StringReplace(IniRead($config, "donate", "txtDonateSkeletonSpells", "skeleton"), "|", @CRLF)
$sTxtBlacklistSkeletonSpells = StringReplace(IniRead($config, "donate", "txtBlacklistSkeletonSpells", "no skeleton|skeleton no"), "|", @CRLF)
$aDonSkeletonSpells = StringSplit($sTxtDonateSkeletonSpells, @CRLF, $STR_ENTIRESPLIT)
$aBlkSkeletonSpells = StringSplit($sTxtBlacklistSkeletonSpells, @CRLF, $STR_ENTIRESPLIT)
$ichkDonateCustomA = IniRead($config, "donate", "chkDonateCustomA", "0")
$ichkDonateAllCustomA = IniRead($config, "donate", "chkDonateAllCustomA", "0")
$sTxtDonateCustomA = StringReplace(IniRead($config, "donate", "txtDonateCustomA", "ground support|ground"), "|", @CRLF)
$sTxtBlacklistCustomA = StringReplace(IniRead($config, "donate", "txtBlacklistCustomA", "no ground|ground no|nonly"), "|", @CRLF)
$aDonCustomA = StringSplit($sTxtDonateCustomA, @CRLF, $STR_ENTIRESPLIT)
$aBlkCustomA = StringSplit($sTxtBlacklistCustomA, @CRLF, $STR_ENTIRESPLIT)
$varDonateCustomA[0][0] = IniRead($config, "donate", "cmbDonateCustomA1", "6")
$varDonateCustomA[1][0] = IniRead($config, "donate", "cmbDonateCustomA2", "1")
$varDonateCustomA[2][0] = IniRead($config, "donate", "cmbDonateCustomA3", "0")
$varDonateCustomA[0][1] = IniRead($config, "donate", "txtDonateCustomA1", "2")
$varDonateCustomA[1][1] = IniRead($config, "donate", "txtDonateCustomA2", "3")
$varDonateCustomA[2][1] = IniRead($config, "donate", "txtDonateCustomA3", "1")
$ichkDonateCustomB = IniRead($config, "donate", "chkDonateCustomB", "0")
$ichkDonateAllCustomB = IniRead($config, "donate", "chkDonateAllCustomB", "0")
$sTxtDonateCustomB = StringReplace(IniRead($config, "donate", "txtDonateCustomB", "air support|any air"), "|", @CRLF)
$sTxtBlacklistCustomB = StringReplace(IniRead($config, "donate", "txtBlacklistCustomB", "no air|air no|only|just"), "|", @CRLF)
$aDonCustomB = StringSplit($sTxtDonateCustomB, @CRLF, $STR_ENTIRESPLIT)
$aBlkCustomB = StringSplit($sTxtBlacklistCustomB, @CRLF, $STR_ENTIRESPLIT)
$varDonateCustomB[0][0] = IniRead($config, "donate", "cmbDonateCustomB1", "11")
$varDonateCustomB[1][0] = IniRead($config, "donate", "cmbDonateCustomB2", "1")
$varDonateCustomB[2][0] = IniRead($config, "donate", "cmbDonateCustomB3", "6")
$varDonateCustomB[0][1] = IniRead($config, "donate", "txtDonateCustomB1", "3")
$varDonateCustomB[1][1] = IniRead($config, "donate", "txtDonateCustomB2", "13")
$varDonateCustomB[2][1] = IniRead($config, "donate", "txtDonateCustomB3", "5")
$sTxtBlacklist = StringReplace(IniRead($config, "donate", "txtBlacklist", "clan war|war|cw"), "|", @CRLF)
$aBlackList = StringSplit($sTxtBlacklist, @CRLF, $STR_ENTIRESPLIT)
$ichkExtraAlphabets = IniRead($config, "donate", "chkExtraAlphabets", "0")
InireadS($chkLvl6Enabled, $config, "collectors", "lvl6Enabled", "1", "Int")
InireadS($chkLvl7Enabled, $config, "collectors", "lvl7Enabled", "1", "Int")
InireadS($chkLvl8Enabled, $config, "collectors", "lvl8Enabled", "1", "Int")
InireadS($chkLvl9Enabled, $config, "collectors", "lvl9Enabled", "1", "Int")
InireadS($chkLvl10Enabled, $config, "collectors", "lvl10Enabled", "1", "Int")
InireadS($chkLvl11Enabled, $config, "collectors", "lvl11Enabled", "1", "Int")
InireadS($chkLvl12Enabled, $config, "collectors", "lvl12Enabled", "1", "Int")
InireadS($cmbLvl6Fill, $config, "collectors", "lvl6fill", "2")
InireadS($cmbLvl7Fill, $config, "collectors", "lvl7fill", "2")
InireadS($cmbLvl8Fill, $config, "collectors", "lvl8fill", "2")
InireadS($cmbLvl9Fill, $config, "collectors", "lvl9fill", "1")
InireadS($cmbLvl10Fill, $config, "collectors", "lvl10fill", "0")
InireadS($cmbLvl11Fill, $config, "collectors", "lvl11fill", "0")
InireadS($cmbLvl12Fill, $config, "collectors", "lvl12fill", "0")
InireadS($toleranceOffset, $config, "collectors", "tolerance", "0")
$AndroidGamePackage = IniRead($config, "android", "game.package", $AndroidGamePackage)
$AndroidGameClass = IniRead($config, "android", "game.class", $AndroidGameClass)
$AndroidCheckTimeLagEnabled = IniRead($config, "android", "check.time.lag.enabled", ($AndroidCheckTimeLagEnabled ? "1" : "0")) = "1"
$AndroidAdbScreencapTimeoutMin = Int(IniRead($config, "android", "adb.screencap.timeout.min", $AndroidAdbScreencapTimeoutMin))
$AndroidAdbScreencapTimeoutMax = Int(IniRead($config, "android", "adb.screencap.timeout.max", $AndroidAdbScreencapTimeoutMax))
$AndroidAdbScreencapTimeoutDynamic = Int(IniRead($config, "android", "adb.screencap.timeout.dynamic", $AndroidAdbScreencapTimeoutDynamic))
$AndroidAdbInputEnabled = IniRead($config, "android", "adb.input.enabled", ($AndroidAdbInputEnabled ? "1" : "0")) = "1"
$AndroidAdbClickEnabled = IniRead($config, "android", "adb.click.enabled", ($AndroidAdbClickEnabled ? "1" : "0")) = "1"
$AndroidAdbClickGroup = Int(IniRead($config, "android", "adb.click.group", $AndroidAdbClickGroup))
$AndroidAdbClicksEnabled = IniRead($config, "android", "adb.clicks.enabled", ($AndroidAdbClicksEnabled ? "1" : "0")) = "1"
$AndroidAdbClicksTroopDeploySize = Int(IniRead($config, "android", "adb.clicks.troop.deploy.size", $AndroidAdbClicksTroopDeploySize))
$NoFocusTampering = IniRead($config, "android", "no.focus.tampering", ($NoFocusTampering ? "1" : "0")) = "1"
$AndroidShieldColor = Dec(IniRead($config, "android", "shield.color", Hex($AndroidShieldColor, 6)))
$AndroidShieldTransparency = Int(IniRead($config, "android", "shield.transparency", $AndroidShieldTransparency))
$AndroidActiveColor = Dec(IniRead($config, "android", "active.color", Hex($AndroidActiveColor, 6)))
$AndroidActiveTransparency = Int(IniRead($config, "android", "active.transparency", $AndroidActiveTransparency))
$AndroidInactiveColor = Dec(IniRead($config, "android", "inactive.color", Hex($AndroidInactiveColor, 6)))
$AndroidInactiveTransparency = Int(IniRead($config, "android", "inactive.transparency", $AndroidInactiveTransparency))
IniReadS($ichkTSActivateCamps2, $config, "search", "ChkTSSearchCamps2", "0")
IniReadS($iEnableAfterArmyCamps2, $config, "search", "TSEnableAfterArmyCamps2", "100")
IniReadS($iEnableSpellsWait[$DB], $config, "search", "ChkDBSpellsWait", "0")
IniReadS($iEnableSpellsWait[$LB], $config, "search", "ChkABSpellsWait", "0")
IniReadS($iChkWaitForCastleSpell[$DB], $config, "search", "ChkDBCastleSpellWait", "0")
IniReadS($iChkWaitForCastleSpell[$LB], $config, "search", "ChkABCastleSpellWait", "0")
IniReadS($iChkWaitForCastleTroops[$DB], $config, "search", "ChkDBCastleTroopsWait", "0")
IniReadS($iChkWaitForCastleTroops[$LB], $config, "search", "ChkABCastleTroopsWait", "0")
IniReadS($iCmbWaitForCastleSpell[$DB], $config, "search", "cmbDBWaitForCastleSpell", "0")
IniReadS($iCmbWaitForCastleSpell[$LB], $config, "search", "cmbABWaitForCastleSpell", "0")
IniReadS($iTotalTrainSpaceSpell, $config, "search", "TotalTrainSpaceSpell", "0")
IniReadS($iRadio_Army1, $config, "troop", "QuickTrain1", "1")
IniReadS($iRadio_Army2, $config, "troop", "QuickTrain2", "0")
IniReadS($iRadio_Army3, $config, "troop", "QuickTrain3", "0")
IniReadS($ichkEnableSuperXP, $config, "attack", "EnableSuperXP", "0")
IniReadS($irbSXTraining, $config, "attack", "SXTraining", "1")
IniReadS($ichkSXBK, $config, "attack", "SXBK", $HERO_NOHERO)
IniReadS($ichkSXAQ, $config, "attack", "SXAQ", $HERO_NOHERO)
IniReadS($ichkSXGW, $config, "attack", "SXGW", $HERO_NOHERO)
$ichkUseBotHumanization = IniRead($config, "Humanization", "chkUseBotHumanization", "0")
$ichkUseAltRClick = IniRead($config, "Humanization", "chkUseAltRClick", "0")
$ichkCollectAchievements = IniRead($config, "Humanization", "chkCollectAchievements", "0")
$ichkLookAtRedNotifications = IniRead($config, "Humanization", "chkLookAtRedNotifications", "0")
For $i = 0 To 12
$icmbPriority[$i] = IniRead($config, "Humanization", "cmbPriority[" & $i & "]", "0")
Next
For $i = 0 To 1
$icmbMaxSpeed[$i] = IniRead($config, "Humanization", "cmbMaxSpeed[" & $i & "]", "1")
Next
For $i = 0 To 1
$icmbPause[$i] = IniRead($config, "Humanization", "cmbPause[" & $i & "]", "0")
Next
For $i = 0 To 1
$ihumanMessage[$i] = IniRead($config, "Humanization", "humanMessage[" & $i & "]", "")
Next
$icmbMaxActionsNumber = IniRead($config, "Humanization", "cmbMaxActionsNumber", "1")
$ichkSmartZap = IniRead($config, "SmartZap", "UseSmartZap", "0")
$ichkSmartZapDB = IniRead($config, "SmartZap", "ZapDBOnly", "1")
$ichkSmartZapSaveHeroes = IniRead($config, "SmartZap", "THSnipeSaveHeroes", "1")
$itxtMinDE = IniRead($config, "SmartZap", "MinDE", "250")
$ichkNoobZap = IniRead($config, "SmartZap", "UseNoobZap", "0")
$itxtExpectedDE = IniRead($config, "SmartZap", "ExpectedDE", "95")
$DebugSmartZap = IniRead($config, "SmartZap", "DebugSmartZap", "0")
IniReadS($sMinTimeCloseATK, $config, "SmartZap", "MinTimeCloseATK", "15")
$iNameMyBot = IniRead($config, "MyBotName", "Name", "")
Else
Return False
EndIf
EndFunc
Func saveConfig()
If GUICtrlRead($chkDonateBarbarians) = $GUI_CHECKED Then
$ichkDonateBarbarians = 1
Else
$ichkDonateBarbarians = 0
EndIf
$sTxtDonateBarbarians = GUICtrlRead($txtDonateBarbarians)
$sTxtBlacklistBarbarians = GUICtrlRead($txtBlacklistBarbarians)
If GUICtrlRead($chkDonateArchers) = $GUI_CHECKED Then
$ichkDonateArchers = 1
Else
$ichkDonateArchers = 0
EndIf
$sTxtDonateArchers = GUICtrlRead($txtDonateArchers)
$sTxtBlacklistArchers = GUICtrlRead($txtBlacklistArchers)
If GUICtrlRead($chkDonateGiants) = $GUI_CHECKED Then
$ichkDonateGiants = 1
Else
$ichkDonateGiants = 0
EndIf
$sTxtDonateGiants = GUICtrlRead($txtDonateGiants)
$sTxtBlacklistGiants = GUICtrlRead($txtBlacklistGiants)
If GUICtrlRead($chkDonateGoblins) = $GUI_CHECKED Then
$ichkDonateGoblins = 1
Else
$ichkDonateGoblins = 0
EndIf
$sTxtDonateGoblins = GUICtrlRead($txtDonateGoblins)
$sTxtBlacklistGoblins = GUICtrlRead($txtBlacklistGoblins)
If GUICtrlRead($chkDonateWallBreakers) = $GUI_CHECKED Then
$ichkDonateWallBreakers = 1
Else
$ichkDonateWallBreakers = 0
EndIf
$sTxtDonateWallBreakers = GUICtrlRead($txtDonateWallBreakers)
$sTxtBlacklistWallBreakers = GUICtrlRead($txtBlacklistWallBreakers)
If GUICtrlRead($chkDonateBalloons) = $GUI_CHECKED Then
$ichkDonateBalloons = 1
Else
$ichkDonateBalloons = 0
EndIf
$sTxtDonateBalloons = GUICtrlRead($txtDonateBalloons)
$sTxtBlacklistBalloons = GUICtrlRead($txtBlacklistBalloons)
If GUICtrlRead($chkDonateWizards) = $GUI_CHECKED Then
$ichkDonateWizards = 1
Else
$ichkDonateWizards = 0
EndIf
$sTxtDonateWizards = GUICtrlRead($txtDonateWizards)
$sTxtBlacklistWizards = GUICtrlRead($txtBlacklistWizards)
If GUICtrlRead($chkDonateHealers) = $GUI_CHECKED Then
$ichkDonateHealers = 1
Else
$ichkDonateHealers = 0
EndIf
$sTxtDonateHealers = GUICtrlRead($txtDonateHealers)
$sTxtBlacklistHealers = GUICtrlRead($txtBlacklistHealers)
If GUICtrlRead($chkDonateDragons) = $GUI_CHECKED Then
$ichkDonateDragons = 1
Else
$ichkDonateDragons = 0
EndIf
$sTxtDonateDragons = GUICtrlRead($txtDonateDragons)
$sTxtBlacklistDragons = GUICtrlRead($txtBlacklistDragons)
If GUICtrlRead($chkDonatePekkas) = $GUI_CHECKED Then
$ichkDonatePekkas = 1
Else
$ichkDonatePekkas = 0
EndIf
$sTxtDonatePekkas = GUICtrlRead($txtDonatePekkas)
$sTxtBlacklistPekkas = GUICtrlRead($txtBlacklistPekkas)
If GUICtrlRead($chkDonateBabyDragons) = $GUI_CHECKED Then
$ichkDonateBabyDragons = 1
Else
$ichkDonateBabyDragons = 0
EndIf
$sTxtDonateBabyDragons = GUICtrlRead($txtDonateBabyDragons)
$sTxtBlacklistBabyDragons = GUICtrlRead($txtBlacklistBabyDragons)
If GUICtrlRead($chkDonateMiners) = $GUI_CHECKED Then
$ichkDonateMiners = 1
Else
$ichkDonateMiners = 0
EndIf
$sTxtDonateMiners = GUICtrlRead($txtDonateMiners)
$sTxtBlacklistMiners = GUICtrlRead($txtBlacklistMiners)
If GUICtrlRead($chkDonateMinions) = $GUI_CHECKED Then
$ichkDonateMinions = 1
Else
$ichkDonateMinions = 0
EndIf
$sTxtDonateMinions = GUICtrlRead($txtDonateMinions)
$sTxtBlacklistMinions = GUICtrlRead($txtBlacklistMinions)
If GUICtrlRead($chkDonateHogRiders) = $GUI_CHECKED Then
$ichkDonateHogRiders = 1
Else
$ichkDonateHogRiders = 0
EndIf
$sTxtDonateHogRiders = GUICtrlRead($txtDonateHogRiders)
$sTxtBlacklistHogRiders = GUICtrlRead($txtBlacklistHogRiders)
If GUICtrlRead($chkDonateValkyries) = $GUI_CHECKED Then
$ichkDonateValkyries = 1
Else
$ichkDonateValkyries = 0
EndIf
$sTxtDonateValkyries = GUICtrlRead($txtDonateValkyries)
$sTxtBlacklistValkyries = GUICtrlRead($txtBlacklistValkyries)
If GUICtrlRead($chkDonateGolems) = $GUI_CHECKED Then
$ichkDonateGolems = 1
Else
$ichkDonateGolems = 0
EndIf
$sTxtDonateGolems = GUICtrlRead($txtDonateGolems)
$sTxtBlacklistGolems = GUICtrlRead($txtBlacklistGolems)
If GUICtrlRead($chkDonateWitches) = $GUI_CHECKED Then
$ichkDonateWitches = 1
Else
$ichkDonateWitches = 0
EndIf
$sTxtDonateWitches = GUICtrlRead($txtDonateWitches)
$sTxtBlacklistWitches = GUICtrlRead($txtBlacklistWitches)
If GUICtrlRead($chkDonateLavaHounds) = $GUI_CHECKED Then
$ichkDonateLavaHounds = 1
Else
$ichkDonateLavaHounds = 0
EndIf
$sTxtDonateLavaHounds = GUICtrlRead($txtDonateLavaHounds)
$sTxtBlacklistLavaHounds = GUICtrlRead($txtBlacklistLavaHounds)
If GUICtrlRead($chkDonateBowlers) = $GUI_CHECKED Then
$ichkDonateBowlers = 1
Else
$ichkDonateBowlers = 0
EndIf
$sTxtDonateBowlers = GUICtrlRead($txtDonateBowlers)
$sTxtBlacklistBowlers = GUICtrlRead($txtBlacklistBowlers)
If GUICtrlRead($chkDonatePoisonSpells) = $GUI_CHECKED Then
$ichkDonatePoisonSpells = 1
Else
$ichkDonatePoisonSpells = 0
EndIf
$sTxtDonatePoisonSpells = GUICtrlRead($txtDonatePoisonSpells)
$sTxtBlacklistPoisonSpells = GUICtrlRead($txtBlacklistPoisonSpells)
If GUICtrlRead($chkDonateEarthQuakeSpells) = $GUI_CHECKED Then
$ichkDonateEarthQuakeSpells = 1
Else
$ichkDonateEarthQuakeSpells = 0
EndIf
$sTxtDonateEarthQuakeSpells = GUICtrlRead($txtDonateEarthQuakeSpells)
$sTxtBlacklistEarthQuakeSpells = GUICtrlRead($txtBlacklistEarthQuakeSpells)
If GUICtrlRead($chkDonateHasteSpells) = $GUI_CHECKED Then
$ichkDonateHasteSpells = 1
Else
$ichkDonateHasteSpells = 0
EndIf
$sTxtDonateHasteSpells = GUICtrlRead($txtDonateHasteSpells)
$sTxtBlacklistHasteSpells = GUICtrlRead($txtBlacklistHasteSpells)
If GUICtrlRead($chkDonateSkeletonSpells) = $GUI_CHECKED Then
$ichkDonateSkeletonSpells = 1
Else
$ichkDonateSkeletonSpells = 0
EndIf
$sTxtDonateSkeletonSpells = GUICtrlRead($txtDonateSkeletonSpells)
$sTxtBlacklistSkeletonSpells = GUICtrlRead($txtBlacklistSkeletonSpells)
If GUICtrlRead($chkDonateCustomA) = $GUI_CHECKED Then
$ichkDonateCustomA = 1
Else
$ichkDonateCustomA = 0
EndIf
$sTxtDonateCustomA = GUICtrlRead($txtDonateCustomA)
$sTxtBlacklistCustomA = GUICtrlRead($txtBlacklistCustomA)
$varDonateCustomA[0][0] = _GUICtrlComboBox_GetCurSel($cmbDonateCustomA1)
$varDonateCustomA[0][1] = GUICtrlRead($txtDonateCustomA1)
$varDonateCustomA[1][0] = _GUICtrlComboBox_GetCurSel($cmbDonateCustomA2)
$varDonateCustomA[1][1] = GUICtrlRead($txtDonateCustomA2)
$varDonateCustomA[2][0] = _GUICtrlComboBox_GetCurSel($cmbDonateCustomA3)
$varDonateCustomA[2][1] = GUICtrlRead($txtDonateCustomA3)
If GUICtrlRead($chkDonateCustomB) = $GUI_CHECKED Then
$ichkDonateCustomB = 1
Else
$ichkDonateCustomB = 0
EndIf
$sTxtDonateCustomB = GUICtrlRead($txtDonateCustomB)
$sTxtBlacklistCustomB = GUICtrlRead($txtBlacklistCustomB)
$varDonateCustomB[0][0] = _GUICtrlComboBox_GetCurSel($cmbDonateCustomB1)
$varDonateCustomB[0][1] = GUICtrlRead($txtDonateCustomB1)
$varDonateCustomB[1][0] = _GUICtrlComboBox_GetCurSel($cmbDonateCustomB2)
$varDonateCustomB[1][1] = GUICtrlRead($txtDonateCustomB2)
$varDonateCustomB[2][0] = _GUICtrlComboBox_GetCurSel($cmbDonateCustomB3)
$varDonateCustomB[2][1] = GUICtrlRead($txtDonateCustomB3)
$sTxtBlacklist = GUICtrlRead($txtBlacklist)
If GUICtrlRead($chkDonateAllBarbarians) = $GUI_CHECKED Then
$ichkDonateAllBarbarians = 1
Else
$ichkDonateAllBarbarians = 0
EndIf
If GUICtrlRead($chkDonateAllArchers) = $GUI_CHECKED Then
$ichkDonateAllArchers = 1
Else
$ichkDonateAllArchers = 0
EndIf
If GUICtrlRead($chkDonateAllGiants) = $GUI_CHECKED Then
$ichkDonateAllGiants = 1
Else
$ichkDonateAllGiants = 0
EndIf
If GUICtrlRead($chkDonateAllGoblins) = $GUI_CHECKED Then
$ichkDonateAllGoblins = 1
Else
$ichkDonateAllGoblins = 0
EndIf
If GUICtrlRead($chkDonateAllWallBreakers) = $GUI_CHECKED Then
$ichkDonateAllWallBreakers = 1
Else
$ichkDonateAllWallBreakers = 0
EndIf
If GUICtrlRead($chkDonateAllBalloons) = $GUI_CHECKED Then
$ichkDonateAllBalloons = 1
Else
$ichkDonateAllBalloons = 0
EndIf
If GUICtrlRead($chkDonateAllWizards) = $GUI_CHECKED Then
$ichkDonateAllWizards = 1
Else
$ichkDonateAllWizards = 0
EndIf
If GUICtrlRead($chkDonateAllHealers) = $GUI_CHECKED Then
$ichkDonateAllHealers = 1
Else
$ichkDonateAllHealers = 0
EndIf
If GUICtrlRead($chkDonateAllDragons) = $GUI_CHECKED Then
$ichkDonateAllDragons = 1
Else
$ichkDonateAllDragons = 0
EndIf
If GUICtrlRead($chkDonateAllPekkas) = $GUI_CHECKED Then
$ichkDonateAllPekkas = 1
Else
$ichkDonateAllPekkas = 0
EndIf
If GUICtrlRead($chkDonateAllBabyDragons) = $GUI_CHECKED Then
$ichkDonateAllBabyDragons = 1
Else
$ichkDonateAllBabyDragons = 0
EndIf
If GUICtrlRead($chkDonateAllMiners) = $GUI_CHECKED Then
$ichkDonateAllMiners = 1
Else
$ichkDonateAllMiners = 0
EndIf
If GUICtrlRead($chkDonateAllMinions) = $GUI_CHECKED Then
$ichkDonateAllMinions = 1
Else
$ichkDonateAllMinions = 0
EndIf
If GUICtrlRead($chkDonateAllHogRiders) = $GUI_CHECKED Then
$ichkDonateAllHogRiders = 1
Else
$ichkDonateAllHogRiders = 0
EndIf
If GUICtrlRead($chkDonateAllValkyries) = $GUI_CHECKED Then
$ichkDonateAllValkyries = 1
Else
$ichkDonateAllValkyries = 0
EndIf
If GUICtrlRead($chkDonateAllGolems) = $GUI_CHECKED Then
$ichkDonateAllGolems = 1
Else
$ichkDonateAllGolems = 0
EndIf
If GUICtrlRead($chkDonateAllWitches) = $GUI_CHECKED Then
$ichkDonateAllWitches = 1
Else
$ichkDonateAllWitches = 0
EndIf
If GUICtrlRead($chkDonateAllLavaHounds) = $GUI_CHECKED Then
$ichkDonateAllLavaHounds = 1
Else
$ichkDonateAllLavaHounds = 0
EndIf
If GUICtrlRead($chkDonateAllBowlers) = $GUI_CHECKED Then
$ichkDonateAllBowlers = 1
Else
$ichkDonateAllBowlers = 0
EndIf
If GUICtrlRead($chkDonateAllPoisonSpells) = $GUI_CHECKED Then
$ichkDonateAllPoisonSpells = 1
Else
$ichkDonateAllPoisonSpells = 0
EndIf
If GUICtrlRead($chkDonateAllEarthQuakeSpells) = $GUI_CHECKED Then
$ichkDonateAllEarthQuakeSpells = 1
Else
$ichkDonateAllEarthQuakeSpells = 0
EndIf
If GUICtrlRead($chkDonateAllHasteSpells) = $GUI_CHECKED Then
$ichkDonateAllHasteSpells = 1
Else
$ichkDonateAllHasteSpells = 0
EndIf
If GUICtrlRead($chkDonateAllSkeletonSpells) = $GUI_CHECKED Then
$ichkDonateAllSkeletonSpells = 1
Else
$ichkDonateAllSkeletonSpells = 0
EndIf
If GUICtrlRead($chkDonateAllCustomA) = $GUI_CHECKED Then
$ichkDonateAllCustomA = 1
Else
$ichkDonateAllCustomA = 0
EndIf
If GUICtrlRead($chkDonateAllCustomB) = $GUI_CHECKED Then
$ichkDonateAllCustomB = 1
Else
$ichkDonateAllCustomB = 0
EndIf
If GUICtrlRead($chkExtraAlphabets) = $GUI_CHECKED Then
$ichkExtraAlphabets = 1
Else
$ichkExtraAlphabets = 0
EndIf
If GUICtrlRead($chkNotifyPBEnabled) = $GUI_CHECKED Then
$NotifyPBEnabled = 1
Else
$NotifyPBEnabled = 0
EndIf
If GUICtrlRead($chkNotifyRemote) = $GUI_CHECKED Then
$NotifyRemoteEnable = 1
Else
$NotifyRemoteEnable = 0
EndIf
If GUICtrlRead($chkNotifyDeleteAllPBPushes) = $GUI_CHECKED Then
$NotifyDeleteAllPushesOnStart = 1
Else
$NotifyDeleteAllPushesOnStart = 0
EndIf
If GUICtrlRead($chkNotifyDeleteOldPBPushes) = $GUI_CHECKED Then
$NotifyDeletePushesOlderThan = 1
Else
$NotifyDeletePushesOlderThan = 0
EndIf
If GUICtrlRead($chkNotifyDeleteOldPBPushes) = $GUI_CHECKED Then
$NotifyDeletePushesOlderThan = 1
Else
$NotifyDeletePushesOlderThan = 0
EndIf
$NotifyDeletePushesOlderThanHours = _GUICtrlComboBox_GetCurSel($cmbNotifyPushHours)
If GUICtrlRead($chkNotifyAlertMatchFound) = $GUI_CHECKED Then
$NotifyAlertMatchFound = 1
Else
$NotifyAlertMatchFound = 0
EndIf
If GUICtrlRead($chkNotifyAlertLastRaidIMG) = $GUI_CHECKED Then
$NotifyAlerLastRaidIMG = 1
Else
$NotifyAlerLastRaidIMG = 0
EndIf
If GUICtrlRead($chkNotifyAlertUpgradeWall) = $GUI_CHECKED Then
$NotifyAlertUpgradeWalls = 1
Else
$NotifyAlertUpgradeWalls = 0
EndIf
If GUICtrlRead($chkNotifyAlertOutOfSync) = $GUI_CHECKED Then
$NotifyAlertOutOfSync = 1
Else
$NotifyAlertOutOfSync = 0
EndIf
If GUICtrlRead($chkNotifyAlertAnotherDevice) = $GUI_CHECKED Then
$NotifyAlertAnotherDevice = 1
Else
$NotifyAlertAnotherDevice = 0
EndIf
If GUICtrlRead($chkNotifyAlertBuilderIdle) = $GUI_CHECKED Then
$NotifyAlertBulderIdle = 1
Else
$NotifyAlertBulderIdle = 0
EndIf
If GUICtrlRead($chkNotifyAlertMaintenance) = $GUI_CHECKED Then
$NotifyAlertMaintenance = 1
ElseIf $NotifyAlertMaintenance = 0 Then
$NotifyAlertMaintenance = 0
EndIf
If GUICtrlRead($chkNotifyAlertBAN) = $GUI_CHECKED Then
$NotifyAlertBAN = 1
Else
$NotifyAlertBAN = 0
EndIf
If GUICtrlRead($chkNotifyBOTUpdate) = $GUI_CHECKED Then
$NotifyAlertBOTUpdate = 1
Else
$NotifyAlertBOTUpdate = 0
EndIf
If GUICtrlRead($chkNotifyDeleteOldPBPushes) = $GUI_CHECKED Then
$NotifyDeletePushesOlderThan = 1
Else
$NotifyDeletePushesOlderThan = 0
EndIf
$NotifyPBToken = GUICtrlRead($txbNotifyPBToken)
$NotifyTGToken = GUICtrlRead($txbNotifyTGToken)
$NotifyOrigin = GUICtrlRead($txbNotifyOrigin)
If GUICtrlRead($chkNotifyAlertLastRaidTXT) = $GUI_CHECKED Then
$NotifyAlerLastRaidTXT = 1
Else
$NotifyAlerLastRaidTXT = 0
EndIf
If GUICtrlRead($chkNotifyAlertLastAttack) = $GUI_CHECKED Then
$NotifyAlertLastAttack = 1
Else
$NotifyAlertLastAttack = 0
EndIf
If GUICtrlRead($chkNotifyAlertCampFull) = $GUI_CHECKED Then
$NotifyAlertCampFull = 1
Else
$NotifyAlertCampFull = 0
EndIf
If GUICtrlRead($chkNotifyAlertVillageStats) = $GUI_CHECKED Then
$NotifyAlertVillageReport = 1
Else
$NotifyAlertVillageReport = 0
EndIf
If GUICtrlRead($chkNotifyAlertLastAttack) = $GUI_CHECKED Then
$NotifyAlertLastAttack = 1
Else
$NotifyAlertLastAttack = 0
EndIf
If GUICtrlRead($chkNotifyAlertTakeBreak) = $GUI_CHECKED Then
$NotifyAlertTakeBreak = 1
Else
$NotifyAlertTakeBreak = 0
EndIf
If GUICtrlRead($chkNotifyWeekDays) = $GUI_CHECKED Then
IniWrite($config, "notify", "NotifyWeekDaysEnable", 1)
Else
IniWrite($config, "notify", "NotifyWeekDaysEnable", 0)
EndIf
Local $string = ""
For $i = 0 To 6
If GUICtrlRead(Eval("chkNotifyWeekdays" & $i)) = $GUI_CHECKED Then
$string &= "1|"
Else
$string &= "0|"
EndIf
Next
IniWrite($config, "notify", "NotifyWeekDays", $string)
If GUICtrlRead($chkNotifyHours) = $GUI_CHECKED Then
IniWrite($config, "notify", "NotifyHoursEnable", 1)
Else
IniWrite($config, "notify", "NotifyHoursEnable", 0)
EndIf
If GUICtrlRead($chkLab) = $GUI_CHECKED Then
$ichkLab = 1
Else
$ichkLab = 0
EndIf
$icmbLaboratory = _GUICtrlComboBox_GetCurSel($cmbLaboratory)
If GUICtrlRead($chkUpgradeKing) = $GUI_CHECKED Then
$ichkUpgradeKing = 1
Else
$ichkUpgradeKing = 0
EndIf
If GUICtrlRead($chkUpgradeQueen) = $GUI_CHECKED Then
$ichkUpgradeQueen = 1
Else
$ichkUpgradeQueen = 0
EndIf
If GUICtrlRead($chkUpgradeWarden) = $GUI_CHECKED Then
$ichkUpgradeWarden = 1
Else
$ichkUpgradeWarden = 0
EndIf
For $iz = 0 To UBound($aUpgrades, 1) - 1
If GUICtrlRead($chkbxUpgrade[$iz]) = $GUI_CHECKED Then
$ichkbxUpgrade[$iz] = 1
Else
$ichkbxUpgrade[$iz] = 0
EndIf
If GUICtrlRead($chkUpgrdeRepeat[$iz]) = $GUI_CHECKED Then
$ichkUpgrdeRepeat[$iz] = 1
Else
$ichkUpgrdeRepeat[$iz] = 0
EndIf
Next
$itxtUpgrMinGold = GUICtrlRead($txtUpgrMinGold)
$itxtUpgrMinElixir = GUICtrlRead($txtUpgrMinElixir)
$itxtUpgrMinDark = GUICtrlRead($txtUpgrMinDark)
If GUICtrlRead($chkWalls) = $GUI_CHECKED Then
$ichkWalls = 1
Else
$ichkWalls = 0
EndIf
$itxtWallMinGold = GUICtrlRead($txtWallMinGold)
$itxtWallMinElixir = GUICtrlRead($txtWallMinElixir)
$iMaxNbWall = GUICtrlRead($sldMaxNbWall)
If GUICtrlRead($UseGold) = $GUI_CHECKED Then
$iUseStorage = 0
ElseIf GUICtrlRead($UseElixir) = $GUI_CHECKED Then
$iUseStorage = 1
ElseIf GUICtrlRead($UseElixirGold) = $GUI_CHECKED Then
$iUseStorage = 2
EndIf
$itxtWall04ST = GUICtrlRead($txtWall04ST)
$itxtWall05ST = GUICtrlRead($txtWall05ST)
$itxtWall06ST = GUICtrlRead($txtWall06ST)
$itxtWall07ST = GUICtrlRead($txtWall07ST)
$itxtWall08ST = GUICtrlRead($txtWall08ST)
$itxtWall09ST = GUICtrlRead($txtWall09ST)
$itxtWall10ST = GUICtrlRead($txtWall10ST)
$itxtWall11ST = GUICtrlRead($txtWall11ST)
If GUICtrlRead($chkSaveWallBldr) = $GUI_CHECKED Then
$iSaveWallBldr = 1
Else
$iSaveWallBldr = 0
EndIf
If GUICtrlRead($chkUpgradeContinually) = $GUI_CHECKED Then
$ichkUpgradeContinually = 1
Else
$ichkUpgradeContinually = 0
EndIf
$icmbWalls = _GUICtrlComboBox_GetCurSel($cmbWalls)
$iUnbreakableWait = GUICtrlRead($txtUnbreakable)
$iUnBrkMinGold = GUICtrlRead($txtUnBrkMinGold)
$iUnBrkMinElixir = GUICtrlRead($txtUnBrkMinElixir)
$iUnBrkMinDark = GUICtrlRead($txtUnBrkMinDark)
$iUnBrkMaxGold = GUICtrlRead($txtUnBrkMaxGold)
$iUnBrkMaxElixir = GUICtrlRead($txtUnBrkMaxElixir)
$iUnBrkMaxDark = GUICtrlRead($txtUnBrkMaxDark)
If GUICtrlRead($chkUnbreakable) = $GUI_CHECKED Then
$iUnbreakableMode = 1
Else
$iUnbreakableMode = 0
EndIf
If GUICtrlRead($chkBotStop) = $GUI_CHECKED Then
$ichkBotStop = 1
Else
$ichkBotStop = 0
EndIf
$icmbBotCommand = _GUICtrlComboBox_GetCurSel($cmbBotCommand)
$icmbBotCond = _GUICtrlComboBox_GetCurSel($cmbBotCond)
$icmbHoursStop = _GUICtrlComboBox_GetCurSel($cmbHoursStop)
$sTimeWakeUp = Int(GUICtrlRead($txtTimeWakeUp)) * 60
$itxtRestartGold = GUICtrlRead($txtRestartGold)
$itxtRestartElixir = GUICtrlRead($txtRestartElixir)
$itxtRestartDark = GUICtrlRead($txtRestartDark)
If GUICtrlRead($chkDisableSplash) = $GUI_CHECKED Then
$ichkDisableSplash = 1
Else
$ichkDisableSplash = 0
EndIf
If GUICtrlRead($chkVersion) = $GUI_CHECKED Then
$ichkVersion = 1
Else
$ichkVersion = 0
EndIf
If GUICtrlRead($chkDeleteLogs) = $GUI_CHECKED Then
$ichkDeleteLogs = 1
Else
$ichkDeleteLogs = 0
EndIf
$iDeleteLogsDays = GUICtrlRead($txtDeleteLogsDays)
If GUICtrlRead($chkDeleteTemp) = $GUI_CHECKED Then
$ichkDeleteTemp = 1
Else
$ichkDeleteTemp = 0
EndIf
$iDeleteTempDays = GUICtrlRead($txtDeleteTempDays)
If GUICtrlRead($chkDeleteLoots) = $GUI_CHECKED Then
$ichkDeleteLoots = 1
Else
$ichkDeleteLoots = 0
EndIf
$iDeleteLootsDays = GUICtrlRead($txtDeleteLootsDays)
If GUICtrlRead($chkAutoStart) = $GUI_CHECKED Then
$ichkAutoStart = 1
Else
$ichkAutoStart = 0
EndIf
$ichkAutoStartDelay = GUICtrlRead($txtAutoStartDelay)
If GUICtrlRead($ChkLanguage) = $GUI_CHECKED Then
$ichkLanguage = 1
Else
$ichkLanguage = 0
EndIf
If GUICtrlRead($chkDisposeWindows) = $GUI_CHECKED Then
$iDisposeWindows = 1
Else
$iDisposeWindows = 0
EndIf
$icmbDisposeWindowsPos = _GUICtrlComboBox_GetCurSel($cmbDisposeWindowsCond)
$iWAOffsetX = GUICtrlRead($txtWAOffsetX)
$iWAOffsetY = GUICtrlRead($txtWAOffsetY)
If GUICtrlRead($chkDebugClick) = $GUI_CHECKED Then
$debugClick = 1
Else
$debugClick = 0
EndIf
If $devmode = 1 Then
If GUICtrlRead($chkDebugSetlog) = $GUI_CHECKED Then
$DebugSetlog = 1
Else
$DebugSetlog = 0
EndIf
If GUICtrlRead($chkDebugOcr) = $GUI_CHECKED Then
$debugOcr = 1
Else
$debugOcr = 0
EndIf
If GUICtrlRead($chkDebugImageSave) = $GUI_CHECKED Then
$DebugImageSave = 1
Else
$DebugImageSave = 0
EndIf
If GUICtrlRead($chkdebugBuildingPos) = $GUI_CHECKED Then
$debugBuildingPos = 1
Else
$debugBuildingPos = 0
EndIf
If GUICtrlRead($chkdebugTrain) = $GUI_CHECKED Then
$debugsetlogTrain = 1
Else
$debugsetlogTrain = 0
EndIf
If GUICtrlRead($chkdebugOCRDonate) = $GUI_CHECKED Then
$debugOCRdonate = 1
Else
$debugOCRdonate = 0
EndIf
EndIf
If GUICtrlRead($hChk_UseQTrain) = $GUI_CHECKED Then
$ichkUseQTrain = 1
Else
$ichkUseQTrain = 0
EndIf
If GUICtrlRead($chkForceBrewBeforeAttack) = $GUI_CHECKED Then
$ichkForceBrewBeforeAttack = 1
Else
$ichkForceBrewBeforeAttack = 0
EndIf
If GUICtrlRead($chkTotalCampForced) = $GUI_CHECKED Then
$ichkTotalCampForced = 1
Else
$ichkTotalCampForced = 0
EndIf
$iValueTotalCampForced = GUICtrlRead($txtTotalCampForced)
If GUICtrlRead($chkSinglePBTForced) = $GUI_CHECKED Then
$ichkSinglePBTForced = 1
Else
$ichkSinglePBTForced = 0
EndIf
$iValueSinglePBTimeForced = GUICtrlRead($txtSinglePBTimeForced)
$iValuePBTimeForcedExit = GUICtrlRead($txtPBTimeForcedExit)
If GUICtrlRead($chkUseRandomClick) = $GUI_CHECKED Then
$iUseRandomClick = 1
Else
$iUseRandomClick = 0
EndIf
If GUICtrlRead($chkScreenshotType) = $GUI_CHECKED Then
$iScreenshotType = 1
Else
$iScreenshotType = 0
EndIf
If GUICtrlRead($chkScreenshotHideName) = $GUI_CHECKED Then
$ichkScreenshotHideName = 1
Else
$ichkScreenshotHideName = 0
EndIf
$iVSDelay = GUICtrlRead($sldVSDelay)
$iMaxVSDelay = GUICtrlRead($sldMaxVSDelay)
$isldTrainITDelay = GUICtrlRead($sldTrainITDelay)
If GUICtrlRead($chkAlertSearch) = $GUI_CHECKED Then
$AlertSearch = 1
Else
$AlertSearch = 0
EndIf
$icmbQuantBoostBarracks = GUICtrlRead($cmbQuantBoostBarracks)
$icmbBoostBarracks = GUICtrlRead($cmbBoostBarracks)
$icmbQuantBoostDarkBarracks = GUICtrlRead($cmbQuantBoostDarkBarracks)
$icmbBoostDarkBarracks = GUICtrlRead($cmbBoostDarkBarracks)
$icmbBoostSpellFactory = GUICtrlRead($cmbBoostSpellFactory)
$icmbBoostDarkSpellFactory = GUICtrlRead($cmbBoostDarkSpellFactory)
$icmbBoostBarbarianKing = GUICtrlRead($cmbBoostBarbarianKing)
$icmbBoostArcherQueen = GUICtrlRead($cmbBoostArcherQueen)
$icmbBoostWarden = GUICtrlRead($cmbBoostWarden)
For $i = 0 To 23
If GUICtrlRead(Eval("chkBoostBarracksHours" & $i)) = $GUI_CHECKED Then
$iPlannedBoostBarracksHours[$i] = 1
Else
$iPlannedBoostBarracksHours[$i] = 0
EndIf
Next
$ReduceCount = GUICtrlRead($txtSearchReduceCount)
$ReduceGold = GUICtrlRead($txtSearchReduceGold)
$ReduceElixir = GUICtrlRead($txtSearchReduceElixir)
$ReduceGoldPlusElixir = GUICtrlRead($txtSearchReduceGoldPlusElixir)
$ReduceDark = GUICtrlRead($txtSearchReduceDark)
$ReduceTrophy = GUICtrlRead($txtSearchReduceTrophy)
$ATBullyMode = GUICtrlRead($txtATBullyMode)
$YourTH = _GUICtrlComboBox_GetCurSel($cmbYourTH)
If GUICtrlRead($radUseDBAttack) = $GUI_CHECKED Then
$iTHBullyAttackMode = 0
Else
$iTHBullyAttackMode = 1
EndIf
$itxtMaxTrophy = GUICtrlRead($txtMaxTrophy)
$itxtdropTrophy = GUICtrlRead($txtdropTrophy)
If GUICtrlRead($chkTrophyRange) = $GUI_CHECKED Then
$iChkTrophyRange = 1
Else
$iChkTrophyRange = 0
EndIf
If GUICtrlRead($chkTrophyHeroes) = $GUI_CHECKED Then
$iChkTrophyHeroes = 1
Else
$iChkTrophyHeroes = 0
EndIf
If GUICtrlRead($chkTrophyAtkDead) = $GUI_CHECKED Then
$iChkTrophyAtkDead = 1
Else
$iChkTrophyAtkDead = 0
EndIf
$itxtDTArmyMin = GUICtrlRead($txtDTArmyMin)
If GUICtrlRead($chkDESideEB) = $GUI_CHECKED Then
$DESideEB = 1
Else
$DESideEB = 0
EndIf
$DELowEndMin = GUICtrlRead($txtDELowEndMin)
If GUICtrlRead($chkDisableOtherEBO) = $GUI_CHECKED Then
$DisableOtherEBO = 1
Else
$DisableOtherEBO = 0
EndIf
If GUICtrlRead($chkDEEndAq) = $GUI_CHECKED Then
$DEEndAq = 1
Else
$DEEndAq = 0
EndIf
If GUICtrlRead($chkDEEndBk) = $GUI_CHECKED Then
$DEEndBk = 1
Else
$DEEndBk = 0
EndIf
If GUICtrlRead($chkDEEndOneStar) = $GUI_CHECKED Then
$DEEndOneStar = 1
Else
$DEEndOneStar = 0
EndIf
Local $TempMilkFarmElixirParam = ""
For $i = 0 To 8
$TempMilkFarmElixirParam &= _GUICtrlComboBox_GetCurSel(Eval("cmbMilkLvl" & $i + 4)) - 1 & "|"
Next
$MilkFarmElixirParam = StringSplit(StringLeft($TempMilkFarmElixirParam, StringLen($TempMilkFarmElixirParam) - 1), "|", 2)
If GUICtrlRead($chkAtkElixirExtractors) = $GUI_CHECKED Then
$MilkFarmLocateElixir = 1
Else
$MilkFarmLocateElixir = 0
EndIf
If GUICtrlRead($chkAtkGoldMines) = $GUI_CHECKED Then
$MilkFarmLocateMine = 1
Else
$MilkFarmLocateMine = 0
EndIf
$MilkFarmMineParam = _GUICtrlComboBox_GetCurSel($cmbAtkGoldMinesLevel) + 1
If GUICtrlRead($chkAtkDarkDrills) = $GUI_CHECKED Then
$MilkFarmLocateDrill = 1
Else
$MilkFarmLocateDrill = 0
EndIf
$MilkFarmDrillParam = _GUICtrlComboBox_GetCurSel($cmbAtkDarkDrillsLevel) + 1
$MilkFarmResMaxTilesFromBorder = _GUICtrlComboBox_GetCurSel($cmbRedlineResDistance)
If GUICtrlRead($chkAttackMinesifGold) = $GUI_CHECKED Then
$MilkFarmAttackGoldMines = 1
Else
$MilkFarmAttackGoldMines = 0
EndIf
If GUICtrlRead($chkAttackMinesifElixir) = $GUI_CHECKED Then
$MilkFarmAttackElixirExtractors = 1
Else
$MilkFarmAttackElixirExtractors = 0
EndIf
If GUICtrlRead($chkAttackMinesifDarkElixir) = $GUI_CHECKED Then
$MilkFarmAttackDarkDrills = 1
Else
$MilkFarmAttackDarkDrills = 0
EndIf
$MilkFarmLimitGold = GUICtrlRead($txtAttackMinesIfGold)
$MilkFarmLimitElixir = GUICtrlRead($txtAttackMinesifElixir)
$MilkFarmLimitDark = GUICtrlRead($txtAttackMinesifDarkElixir)
$MilkFarmTroopForWaveMin = GUICtrlRead($txtLowerXWave)
$MilkFarmTroopForWaveMax = GUICtrlRead($txtUpperXWave)
$MilkFarmTroopMaxWaves = GUICtrlRead($txtMaxWaves)
$MilkFarmDelayFromWavesMin = GUICtrlRead($txtLowerDelayWaves)
$MilkFarmDelayFromWavesMax = GUICtrlRead($txtUpperDelayWaves)
$MilkFarmTHMaxTilesFromBorder = GUICtrlRead($txtMaxTilesMilk)
$MilkFarmAlgorithmTh = GUICtrlRead($cmbMilkSnipeAlgorithm)
If GUICtrlRead($chkSnipeIfNoElixir) = $GUI_CHECKED Then
$MilkFarmSnipeEvenIfNoExtractorsFound = 1
Else
$MilkFarmSnipeEvenIfNoExtractorsFound = 0
EndIf
If $devmode = 1 Then
If GUICtrlRead($chkMilkingDebugIMG) = $GUI_CHECKED Then
$debugresourcesoffset = 1
Else
$debugresourcesoffset = 0
EndIf
If GUICtrlRead($chkMilkingDebugVillage) = $GUI_CHECKED Then
$debugMilkingIMGmake = 1
Else
$debugMilkingIMGmake = 0
EndIf
If GUICtrlRead($chkMilkingDebugFullSearch) = $GUI_CHECKED Then
$continuesearchelixirdebug = 1
Else
$continuesearchelixirdebug = 0
EndIf
EndIf
If GUICtrlRead($chkMilkFarmForcetolerance) = $GUI_CHECKED Then
$MilkFarmForcetolerance = 1
Else
$MilkFarmForcetolerance = 0
EndIf
$MilkFarmForcetolerancenormal = GUICtrlRead($txtMilkFarmForcetolerancenormal)
$MilkFarmForcetoleranceboosted = GUICtrlRead($txtMilkFarmForcetoleranceboosted)
$MilkFarmForcetolerancedestroyed = GUICtrlRead($txtMilkFarmForcetolerancedestroyed)
$MilkAttackType = _GUICtrlComboBox_GetCurSel($cmbMilkAttackType)
If GUICtrlRead($chkStructureDestroyedBeforeAttack) = $GUI_CHECKED Then
$MilkingAttackCheckStructureDestroyedBeforeAttack = 1
Else
$MilkingAttackCheckStructureDestroyedBeforeAttack = 0
EndIf
If GUICtrlRead($chkStructureDestroyedAfterAttack) = $GUI_CHECKED Then
$MilkingAttackCheckStructureDestroyedAfterAttack = 1
Else
$MilkingAttackCheckStructureDestroyedAfterAttack = 0
EndIf
$MilkingAttackDropGoblinAlgorithm = _GUICtrlComboBox_GetCurSel($cmbMilkingAttackDropGoblinAlgorithm)
$MilkingAttackStructureOrder = _GUICtrlComboBox_GetCurSel($cmbStructureOrder)
If GUICtrlRead($chkMilkAfterAttackScripted) = $GUI_CHECKED Then
$MilkAttackAfterScriptedAtk = 1
Else
$MilkAttackAfterScriptedAtk = 0
EndIf
Local $indexofscript = _GUICtrlComboBox_GetCurSel($cmbMilkingCSVScriptName)
Local $scriptname
_GUICtrlComboBox_GetLBText($cmbMilkingCSVScriptName, $indexofscript, $scriptname)
$MilkAttackCSVscript = $scriptname
If GUICtrlRead($chkMilkAfterAttackTHSnipe) = $GUI_CHECKED Then
$MilkAttackAfterTHSnipe = 1
Else
$MilkAttackAfterTHSnipe = 0
EndIf
$iCmbStandardAlgorithm[$DB] = _GUICtrlComboBox_GetCurSel($cmbStandardAlgorithmDB)
$iChkDeploySettings[$DB] = _GUICtrlComboBox_GetCurSel($cmbDeployDB)
$iCmbUnitDelay[$DB] = _GUICtrlComboBox_GetCurSel($cmbUnitDelayDB)
$iCmbWaveDelay[$DB] = _GUICtrlComboBox_GetCurSel($cmbWaveDelayDB)
If GUICtrlRead($chkRandomSpeedAtkDB) = $GUI_CHECKED Then
$iChkRandomspeedatk[$DB] = 1
Else
$iChkRandomspeedatk[$DB] = 0
EndIf
If GUICtrlRead($chkSmartAttackRedAreaDB) = $GUI_CHECKED Then
$iChkRedArea[$DB] = 1
Else
$iChkRedArea[$DB] = 0
EndIf
$iCmbSmartDeploy[$DB] = _GUICtrlComboBox_GetCurSel($cmbSmartDeployDB)
If GUICtrlRead($chkAttackNearGoldMinEDB) = $GUI_CHECKED Then
$iChkSmartAttack[$DB][0] = 1
Else
$iChkSmartAttack[$DB][0] = 0
EndIf
If GUICtrlRead($chkAttackNearElixirCollectorDB) = $GUI_CHECKED Then
$iChkSmartAttack[$DB][1] = 1
Else
$iChkSmartAttack[$DB][1] = 0
EndIf
If GUICtrlRead($chkAttackNearDarkElixirDrillDB) = $GUI_CHECKED Then
$iChkSmartAttack[$DB][2] = 1
Else
$iChkSmartAttack[$DB][2] = 0
EndIf
If GUICtrlRead($chkAttackTH) = $GUI_CHECKED Then
$chkATH = 1
Else
$chkATH = 0
EndIf
$iCmbStandardAlgorithm[$LB] = _GUICtrlComboBox_GetCurSel($cmbStandardAlgorithmAB)
$iChkDeploySettings[$LB] = _GUICtrlComboBox_GetCurSel($cmbDeployAB)
$iCmbUnitDelay[$LB] = _GUICtrlComboBox_GetCurSel($cmbUnitDelayAB)
$iCmbWaveDelay[$LB] = _GUICtrlComboBox_GetCurSel($cmbWaveDelayAB)
If GUICtrlRead($chkRandomSpeedAtkAB) = $GUI_CHECKED Then
$iChkRandomspeedatk[$LB] = 1
Else
$iChkRandomspeedatk[$LB] = 0
EndIf
If GUICtrlRead($chkSmartAttackRedAreaAB) = $GUI_CHECKED Then
$iChkRedArea[$LB] = 1
Else
$iChkRedArea[$LB] = 0
EndIf
$iCmbSmartDeploy[$LB] = _GUICtrlComboBox_GetCurSel($cmbSmartDeployAB)
If GUICtrlRead($chkAttackNearGoldMineAB) = $GUI_CHECKED Then
$iChkSmartAttack[$LB][0] = 1
Else
$iChkSmartAttack[$LB][0] = 0
EndIf
If GUICtrlRead($chkAttackNearElixirCollectorAB) = $GUI_CHECKED Then
$iChkSmartAttack[$LB][1] = 1
Else
$iChkSmartAttack[$LB][1] = 0
EndIf
If GUICtrlRead($chkAttackNearDarkElixirDrillAB) = $GUI_CHECKED Then
$iChkSmartAttack[$LB][2] = 1
Else
$iChkSmartAttack[$LB][2] = 0
EndIf
If GUICtrlRead($chkEnableSuperXP) = $GUI_CHECKED Then
$ichkEnableSuperXP = 1
Else
$ichkEnableSuperXP = 0
EndIf
If GUICtrlRead($rbSXTraining) = $GUI_CHECKED Then
$irbSXTraining = 1
Else
$irbSXTraining = 2
EndIf
If GUICtrlRead($chkSXBK) = $GUI_CHECKED Then
$ichkSXBK = $HERO_KING
Else
$ichkSXBK = $HERO_NOHERO
EndIf
If GUICtrlRead($chkSXAQ) = $GUI_CHECKED Then
$ichkSXAQ = $HERO_QUEEN
Else
$ichkSXAQ = $HERO_NOHERO
EndIf
If GUICtrlRead($chkSXGW) = $GUI_CHECKED Then
$ichkSXGW = $HERO_WARDEN
Else
$ichkSXGW = $HERO_NOHERO
EndIf
Local $indexofscript = _GUICtrlComboBox_GetCurSel($cmbScriptNameDB)
Local $scriptname
_GUICtrlComboBox_GetLBText($cmbScriptNameDB, $indexofscript, $scriptname)
$scmbDBScriptName = $scriptname
Local $indexofscript = _GUICtrlComboBox_GetCurSel($cmbScriptNameAB)
Local $scriptname
_GUICtrlComboBox_GetLBText($cmbScriptNameAB, $indexofscript, $scriptname)
$scmbABScriptName = $scriptname
If $devmode = 1 Then
If GUICtrlRead($chkmakeIMGCSV) = $GUI_CHECKED Then
$makeIMGCSV = 1
Else
$makeIMGCSV = 0
EndIf
EndIf
SetDebugLog("Save Config " & $config)
For $collectorLevel = 6 To 12
If GUICtrlRead(Eval("chkLvl" & $collectorLevel)) = $GUI_CHECKED Then
Assign("chkLvl" & $collectorLevel & "Enabled", 1)
Else
Assign("chkLvl" & $collectorLevel & "Enabled", 0)
EndIf
Assign("cmbLvl" & $collectorLevel & "Fill", _GUICtrlComboBox_GetCurSel(Eval("cmbLvl" & $collectorLevel)))
Next
IniWriteS($config, "collectors", "tolerance", GUICtrlRead($sldCollectorTolerance))
$iShareminGold = GUICtrlRead($txtShareMinGold)
$iShareminElixir = GUICtrlRead($txtShareMinElixir)
$iShareminDark = GUICtrlRead($txtShareMinDark)
$sShareMessage = GUICtrlRead($txtShareMessage)
saveWeakBaseStats()
Local $hFile = -1
If $ichkExtraAlphabets = 1 Then $hFile = FileOpen($config, $FO_UTF16_LE + $FO_OVERWRITE)
IniWriteS($config, "general", "version", GetVersionNormalized($sBotVersion))
IniWriteS($config, "general", "cmbProfile", _GUICtrlComboBox_GetCurSel($cmbProfile))
IniWriteS($config, "general", "frmBotPosX", $frmBotPosX)
IniWriteS($config, "general", "frmBotPosY", $frmBotPosY)
If $HWnD <> 0 Then WinGetAndroidHandle()
IniWriteS($config, "general", "AndroidPosX", $AndroidPosX)
IniWriteS($config, "general", "AndroidPosY", $AndroidPosY)
IniWriteS($config, "general", "frmBotDockedPosX", $frmBotDockedPosX)
IniWriteS($config, "general", "frmBotDockedPosY", $frmBotDockedPosY)
IniWriteS($config, "general", "UpdatingWhenMinimized", $iUpdatingWhenMinimized)
IniWriteS($config, "general", "HideWhenMinimized", $iHideWhenMinimized)
IniWriteS($config, "general", "villageName", GUICtrlRead($txtVillageName))
IniWriteS($config, "general", "logstyle", _GUICtrlComboBox_GetCurSel($cmbLog))
IniWriteS($config, "general", "LogDividerY", $iDividerY)
IniWriteS($config, "general", "AutoStart", $ichkAutoStart)
IniWriteS($config, "general", "AutoStartDelay", $ichkAutoStartDelay)
If GUICtrlRead($chkBackground) = $GUI_CHECKED Then
IniWriteS($config, "general", "Background", 1)
Else
IniWriteS($config, "general", "Background", 0)
EndIf
IniWriteS($config, "general", "BotStop", $ichkBotStop)
IniWriteS($config, "general", "Command", $icmbBotCommand)
IniWriteS($config, "general", "Cond", $icmbBotCond)
IniWriteS($config, "general", "Hour", $icmbHoursStop)
IniWriteS($config, "general", "DisposeWindows", $iDisposeWindows)
IniWriteS($config, "general", "DisposeWindowsPos", $icmbDisposeWindowsPos)
IniWriteS($config, "general", "GUIStyle", $iGUIStyle)
IniWriteS($config, "general", "RedrawBotWindowMode", $RedrawBotWindowMode)
IniWriteS($config, "general", "AlertSearch", $AlertSearch)
IniWriteS($config, "search", "DBMeetGE", _GUICtrlComboBox_GetCurSel($cmbDBMeetGE))
If GUICtrlRead($chkDBMeetDE) = $GUI_CHECKED Then
IniWriteS($config, "search", "DBMeetDE", 1)
Else
IniWriteS($config, "search", "DBMeetDE", 0)
EndIf
If GUICtrlRead($chkDBMeetTrophy) = $GUI_CHECKED Then
IniWriteS($config, "search", "DBMeetTrophy", 1)
Else
IniWriteS($config, "search", "DBMeetTrophy", 0)
EndIf
If GUICtrlRead($chkDBMeetTH) = $GUI_CHECKED Then
IniWriteS($config, "search", "DBMeetTH", 1)
Else
IniWriteS($config, "search", "DBMeetTH", 0)
EndIf
If GUICtrlRead($chkDBMeetTHO) = $GUI_CHECKED Then
IniWriteS($config, "search", "DBMeetTHO", 1)
Else
IniWriteS($config, "search", "DBMeetTHO", 0)
EndIf
$iCmbWeakMortar[$DB] = _GUICtrlComboBox_GetCurSel($cmbWeakMortar[$DB])
$iCmbWeakWizTower[$DB] = _GUICtrlComboBox_GetCurSel($cmbWeakWizTower[$DB])
$iCmbWeakAirDefense[$DB] = _GUICtrlComboBox_GetCurSel($cmbWeakAirDefense[$DB])
$iCmbWeakXBow[$DB] = _GUICtrlComboBox_GetCurSel($cmbWeakXBow[$DB])
$iCmbWeakInferno[$DB] = _GUICtrlComboBox_GetCurSel($cmbWeakInferno[$DB])
$iCmbWeakEagle[$DB] = _GUICtrlComboBox_GetCurSel($cmbWeakEagle[$DB])
$iCmbWeakMortar[$LB] = _GUICtrlComboBox_GetCurSel($cmbWeakMortar[$LB])
$iCmbWeakWizTower[$LB] = _GUICtrlComboBox_GetCurSel($cmbWeakWizTower[$LB])
$iCmbWeakAirDefense[$LB] = _GUICtrlComboBox_GetCurSel($cmbWeakAirDefense[$LB])
$iCmbWeakXBow[$LB] = _GUICtrlComboBox_GetCurSel($cmbWeakXBow[$LB])
$iCmbWeakInferno[$LB] = _GUICtrlComboBox_GetCurSel($cmbWeakInferno[$LB])
$iCmbWeakEagle[$LB] = _GUICtrlComboBox_GetCurSel($cmbWeakEagle[$LB])
For $mode = $DB To $iModeCount - 1
If GUICtrlRead($chkMaxMortar[$mode]) = $GUI_CHECKED Then
$iChkMaxMortar[$mode] = 1
Else
$iChkMaxMortar[$mode] = 0
EndIf
If GUICtrlRead($chkMaxWizTower[$mode]) = $GUI_CHECKED Then
$iChkMaxWizTower[$mode] = 1
Else
$iChkMaxWizTower[$mode] = 0
EndIf
If GUICtrlRead($chkMaxAirDefense[$mode]) = $GUI_CHECKED Then
$iChkMaxAirDefense[$mode] = 1
Else
$iChkMaxAirDefense[$mode] = 0
EndIf
If GUICtrlRead($chkMaxXBow[$mode]) = $GUI_CHECKED Then
$iChkMaxXBow[$mode] = 1
Else
$iChkMaxXBow[$mode] = 0
EndIf
If GUICtrlRead($chkMaxInferno[$mode]) = $GUI_CHECKED Then
$iChkMaxInferno[$mode] = 1
Else
$iChkMaxInferno[$mode] = 0
EndIf
If GUICtrlRead($chkMaxEagle[$mode]) = $GUI_CHECKED Then
$iChkMaxEagle[$mode] = 1
Else
$iChkMaxEagle[$mode] = 0
EndIf
Next
If GUICtrlRead($chkDBMeetOne) = $GUI_CHECKED Then
IniWriteS($config, "search", "DBMeetOne", 1)
Else
IniWriteS($config, "search", "DBMeetOne", 0)
EndIf
IniWriteS($config, "search", "DBEnableAfterCount", GUICtrlRead($txtDBSearchesMin))
IniWriteS($config, "search", "DBEnableBeforeCount", GUICtrlRead($txtDBSearchesMax))
IniWriteS($config, "search", "DBEnableAfterTropies", GUICtrlRead($txtDBTropiesMin))
IniWriteS($config, "search", "DBEnableBeforeTropies", GUICtrlRead($txtDBTropiesMax))
IniWriteS($config, "search", "DBEnableAfterArmyCamps", GUICtrlRead($txtDBArmyCamps))
IniWriteS($config, "search", "DBsearchGold", GUICtrlRead($txtDBMinGold))
IniWriteS($config, "search", "DBsearchElixir", GUICtrlRead($txtDBMinElixir))
IniWriteS($config, "search", "DBsearchGoldPlusElixir", GUICtrlRead($txtDBMinGoldPlusElixir))
IniWriteS($config, "search", "DBsearchDark", GUICtrlRead($txtDBMinDarkElixir))
IniWriteS($config, "search", "DBsearchTrophy", GUICtrlRead($txtDBMinTrophy))
IniWriteS($config, "search", "DBTHLevel", _GUICtrlComboBox_GetCurSel($cmbDBTH))
IniWriteS($config, "search", "DBWeakMortar", $iCmbWeakMortar[$DB])
IniWriteS($config, "search", "DBWeakWizTower", $iCmbWeakWizTower[$DB])
IniWriteS($config, "search", "DBWeakAirDefense", $iCmbWeakAirDefense[$DB])
IniWriteS($config, "search", "DBWeakXBow", $iCmbWeakXBow[$DB])
IniWriteS($config, "search", "DBWeakInferno", $iCmbWeakInferno[$DB])
IniWriteS($config, "search", "DBWeakEagle", $iCmbWeakEagle[$DB])
IniWriteS($config, "search", "DBCheckMortar", $iChkMaxMortar[$DB])
IniWriteS($config, "search", "DBCheckWizTower", $iChkMaxWizTower[$DB])
IniWriteS($config, "search", "DBCheckAirDefense", $iChkMaxAirDefense[$DB])
IniWriteS($config, "search", "DBCheckXBow", $iChkMaxXBow[$DB])
IniWriteS($config, "search", "DBCheckInferno", $iChkMaxInferno[$DB])
IniWriteS($config, "search", "DBCheckEagle", $iChkMaxEagle[$DB])
If GUICtrlRead($DBcheck) = $GUI_CHECKED Then
IniWriteS($config, "search", "DBcheck", 1)
Else
IniWriteS($config, "search", "DBcheck", 0)
EndIf
If GUICtrlRead($ABcheck) = $GUI_CHECKED Then
IniWriteS($config, "search", "ABcheck", 1)
Else
IniWriteS($config, "search", "ABcheck", 0)
EndIf
If GUICtrlRead($TScheck) = $GUI_CHECKED Then
IniWriteS($config, "search", "TScheck", 1)
Else
IniWriteS($config, "search", "TScheck", 0)
EndIf
If GUICtrlRead($chkDBActivateSearches) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkDBSearchSearches", 1)
Else
IniWriteS($config, "search", "ChkDBSearchSearches", 0)
EndIf
If GUICtrlRead($chkABActivateSearches) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkABSearchSearches", 1)
Else
IniWriteS($config, "search", "ChkABSearchSearches", 0)
EndIf
If GUICtrlRead($chkTSActivateSearches) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkTSSearchSearches", 1)
Else
IniWriteS($config, "search", "ChkTSSearchSearches", 0)
EndIf
If GUICtrlRead($chkDBActivateTropies) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkDBSearchTropies", 1)
Else
IniWriteS($config, "search", "ChkDBSearchTropies", 0)
EndIf
If GUICtrlRead($chkABActivateTropies) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkABSearchTropies", 1)
Else
IniWriteS($config, "search", "ChkABSearchTropies", 0)
EndIf
If GUICtrlRead($chkTSActivateTropies) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkTSSearchTropies", 1)
Else
IniWriteS($config, "search", "ChkTSSearchTropies", 0)
EndIf
If GUICtrlRead($chkDBActivateCamps) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkDBSearchCamps", 1)
Else
IniWriteS($config, "search", "ChkDBSearchCamps", 0)
EndIf
If GUICtrlRead($chkABActivateCamps) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkABSearchCamps", 1)
Else
IniWriteS($config, "search", "ChkABSearchCamps", 0)
EndIf
If GUICtrlRead($chkTSActivateCamps) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkTSSearchCamps", 1)
Else
IniWriteS($config, "search", "ChkTSSearchCamps", 0)
EndIf
IniWriteS($config, "search", "ABMeetGE", _GUICtrlComboBox_GetCurSel($cmbABMeetGE))
If GUICtrlRead($chkABMeetDE) = $GUI_CHECKED Then
IniWriteS($config, "search", "ABMeetDE", 1)
Else
IniWriteS($config, "search", "ABMeetDE", 0)
EndIf
If GUICtrlRead($chkABMeetTrophy) = $GUI_CHECKED Then
IniWriteS($config, "search", "ABMeetTrophy", 1)
Else
IniWriteS($config, "search", "ABMeetTrophy", 0)
EndIf
If GUICtrlRead($chkABMeetTH) = $GUI_CHECKED Then
IniWriteS($config, "search", "ABMeetTH", 1)
Else
IniWriteS($config, "search", "ABMeetTH", 0)
EndIf
If GUICtrlRead($chkABMeetTHO) = $GUI_CHECKED Then
IniWriteS($config, "search", "ABMeetTHO", 1)
Else
IniWriteS($config, "search", "ABMeetTHO", 0)
EndIf
If GUICtrlRead($chkABMeetOne) = $GUI_CHECKED Then
IniWriteS($config, "search", "ABMeetOne", 1)
Else
IniWriteS($config, "search", "ABMeetOne", 0)
EndIf
IniWriteS($config, "search", "ABEnableAfterCount", GUICtrlRead($txtABSearchesMin))
IniWriteS($config, "search", "ABEnableBeforeCount", GUICtrlRead($txtABSearchesMax))
IniWriteS($config, "search", "ABEnableAfterTropies", GUICtrlRead($txtABTropiesMin))
IniWriteS($config, "search", "ABEnableBeforeTropies", GUICtrlRead($txtABTropiesMax))
IniWriteS($config, "search", "ABEnableAfterArmyCamps", GUICtrlRead($txtABArmyCamps))
IniWriteS($config, "search", "ABsearchGold", GUICtrlRead($txtABMinGold))
IniWriteS($config, "search", "ABsearchElixir", GUICtrlRead($txtABMinElixir))
IniWriteS($config, "search", "ABsearchGoldPlusElixir", GUICtrlRead($txtABMinGoldPlusElixir))
IniWriteS($config, "search", "ABsearchDark", GUICtrlRead($txtABMinDarkElixir))
IniWriteS($config, "search", "ABsearchTrophy", GUICtrlRead($txtABMinTrophy))
IniWriteS($config, "search", "ABTHLevel", _GUICtrlComboBox_GetCurSel($cmbABTH))
IniWriteS($config, "search", "ABWeakMortar", $iCmbWeakMortar[$LB])
IniWriteS($config, "search", "ABWeakWizTower", $iCmbWeakWizTower[$LB])
IniWriteS($config, "search", "ABWeakAirDefense", $iCmbWeakAirDefense[$LB])
IniWriteS($config, "search", "ABWeakXBow", $iCmbWeakXBow[$LB])
IniWriteS($config, "search", "ABWeakInferno", $iCmbWeakInferno[$LB])
IniWriteS($config, "search", "ABWeakEagle", $iCmbWeakEagle[$LB])
IniWriteS($config, "search", "ABCheckMortar", $iChkMaxMortar[$LB])
IniWriteS($config, "search", "ABCheckWizTower", $iChkMaxWizTower[$LB])
IniWriteS($config, "search", "ABCheckAirDefense", $iChkMaxAirDefense[$LB])
IniWriteS($config, "search", "ABCheckXBow", $iChkMaxXBow[$LB])
IniWriteS($config, "search", "ABCheckInferno", $iChkMaxInferno[$LB])
IniWriteS($config, "search", "ABCheckEagle", $iChkMaxEagle[$LB])
If GUICtrlRead($chkSearchReduction) = $GUI_CHECKED Then
IniWriteS($config, "search", "reduction", 1)
Else
IniWriteS($config, "search", "reduction", 0)
EndIf
IniWriteS($config, "search", "reduceCount", $ReduceCount)
IniWriteS($config, "search", "reduceGold", $ReduceGold)
IniWriteS($config, "search", "reduceElixir", $ReduceElixir)
IniWriteS($config, "search", "reduceGoldPlusElixir", $ReduceGoldPlusElixir)
IniWriteS($config, "search", "reduceDark", $ReduceDark)
IniWriteS($config, "search", "reduceTrophy", $ReduceTrophy)
If GUICtrlRead($ChkRestartSearchLimit) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkRestartSearchLimit", 1)
Else
IniWriteS($config, "search", "ChkRestartSearchLimit", 0)
EndIf
IniWriteS($config, "search", "RestartSearchLimit", GUICtrlRead($TxtRestartSearchlimit))
IniWriteS($config, "attack", "DBAtkAlgorithm", _GUICtrlComboBox_GetCurSel($cmbDBAlgorithm))
IniWriteS($config, "attack", "ABAtkAlgorithm", _GUICtrlComboBox_GetCurSel($cmbABAlgorithm))
IniWriteS($config, "attack", "DBSelectTroop", _GUICtrlComboBox_GetCurSel($cmbDBSelectTroop))
IniWriteS($config, "attack", "ABSelectTroop", _GUICtrlComboBox_GetCurSel($cmbABSelectTroop))
IniWriteS($config, "attack", "TSSelectTroop", _GUICtrlComboBox_GetCurSel($cmbTSSelectTroop))
IniWriteS($config, "attack", "DBStandardAlgorithm", $icmbStandardAlgorithm[$DB])
IniWriteS($config, "attack", "LBStandardAlgorithm", $icmbStandardAlgorithm[$LB])
IniWriteS($config, "attack", "DBDeploy", $iChkDeploySettings[$DB])
IniWriteS($config, "attack", "DBUnitD", $iCmbUnitDelay[$DB])
IniWriteS($config, "attack", "DBWaveD", $iCmbWaveDelay[$DB])
IniWriteS($config, "attack", "DBRandomSpeedAtk", $iChkRandomspeedatk[$DB])
IniWriteS($config, "attack", "DBSmartAttackGoldMine", $iChkSmartAttack[$DB][0])
IniWriteS($config, "attack", "DBSmartAttackElixirCollector", $iChkSmartAttack[$DB][1])
IniWriteS($config, "attack", "DBSmartAttackDarkElixirDrill", $iChkSmartAttack[$DB][2])
IniWriteS($config, "attack", "DBSmartAttackRedArea", $iChkRedArea[$DB])
IniWriteS($config, "attack", "DBSmartAttackGoldMine", $iChkSmartAttack[$DB][0])
IniWriteS($config, "attack", "$chkDBAttackNearElixirCollector", $iChkSmartAttack[$DB][1])
IniWriteS($config, "attack", "$chkDBAttackNearDarkElixirDrill", $iChkSmartAttack[$DB][2])
IniWriteS($config, "attack", "DBSmartAttackDeploy", $iCmbSmartDeploy[$DB])
IniWriteS($config, "attack", "ABDeploy", $iChkDeploySettings[$LB])
IniWriteS($config, "attack", "ABUnitD", $iCmbUnitDelay[$LB])
IniWriteS($config, "attack", "ABWaveD", $iCmbWaveDelay[$LB])
IniWriteS($config, "attack", "ABRandomSpeedAtk", $iChkRandomspeedatk[$LB])
IniWriteS($config, "attack", "ABSmartAttackGoldMine", $iChkSmartAttack[$LB][0])
IniWriteS($config, "attack", "ABSmartAttackElixirCollector", $iChkSmartAttack[$LB][1])
IniWriteS($config, "attack", "ABSmartAttackDarkElixirDrill", $iChkSmartAttack[$LB][2])
IniWriteS($config, "attack", "ABSmartAttackRedArea", $iChkRedArea[$LB])
IniWriteS($config, "attack", "ABSmartAttackGoldMine", $iChkSmartAttack[$LB][0])
IniWriteS($config, "attack", "$chkABAttackNearElixirCollector", $iChkSmartAttack[$LB][1])
IniWriteS($config, "attack", "$chkABAttackNearDarkElixirDrill", $iChkSmartAttack[$LB][2])
IniWriteS($config, "attack", "ABSmartAttackDeploy", $iCmbSmartDeploy[$LB])
IniWriteS($config, "attack", "EnableSuperXP", $ichkEnableSuperXP)
IniWriteS($config, "attack", "SXTraining", $irbSXTraining)
IniWriteS($config, "attack", "SXBK", $ichkSXBK)
IniWriteS($config, "attack", "SXAQ", $ichkSXAQ)
IniWriteS($config, "attack", "SXGW", $ichkSXGW)
If GUICtrlRead($chkDBKingAttack) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBKingAtk", $HERO_KING)
Else
IniWriteS($config, "attack", "DBKingAtk", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkDBKingWait) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBKingWait", $HERO_KING)
Else
IniWriteS($config, "attack", "DBKingWait", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkABKingAttack) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABKingAtk", $HERO_KING)
Else
IniWriteS($config, "attack", "ABKingAtk", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkABKingWait) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABKingWait", $HERO_KING)
Else
IniWriteS($config, "attack", "ABKingWait", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkTSKingAttack) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSKingAtk", 1)
Else
IniWriteS($config, "attack", "TSKingAtk", 0)
EndIf
If GUICtrlRead($chkDBQueenAttack) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBQueenAtk", $HERO_QUEEN)
Else
IniWriteS($config, "attack", "DBQueenAtk", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkDBQueenWait) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBQueenWait", $HERO_QUEEN)
Else
IniWriteS($config, "attack", "DBQueenWait", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkABQueenAttack) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABQueenAtk", $HERO_QUEEN)
Else
IniWriteS($config, "attack", "ABQueenAtk", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkABQueenWait) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABQueenWait", $HERO_QUEEN)
Else
IniWriteS($config, "attack", "ABQueenWait", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkTSQueenAttack) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSQueenAtk", 1)
Else
IniWriteS($config, "attack", "TSQueenAtk", 0)
EndIf
If GUICtrlRead($chkDBDropCC) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBDropCC", 1)
Else
IniWriteS($config, "attack", "DBDropCC", 0)
EndIf
If GUICtrlRead($chkDBWardenAttack) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBWardenAtk", $HERO_WARDEN)
Else
IniWriteS($config, "attack", "DBWardenAtk", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkDBWardenWait) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBWardenWait", $HERO_WARDEN)
Else
IniWriteS($config, "attack", "DBWardenWait", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkABWardenAttack) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABWardenAtk", $HERO_WARDEN)
Else
IniWriteS($config, "attack", "ABWardenAtk", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkABWardenWait) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABWardenWait", $HERO_WARDEN)
Else
IniWriteS($config, "attack", "ABWardenWait", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkTSWardenAttack) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSWardenAtk", $HERO_WARDEN)
Else
IniWriteS($config, "attack", "TSWardenAtk", $HERO_NOHERO)
EndIf
If GUICtrlRead($chkABDropCC) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABDropCC", 1)
Else
IniWriteS($config, "attack", "ABDropCC", 0)
EndIf
If GUICtrlRead($chkUseCCBalanced) = $GUI_CHECKED Then
IniWrite($config, "attack", "BalanceCC", 1)
Else
IniWrite($config, "attack", "BalanceCC", 0)
EndIf
IniWrite($config, "attack", "BalanceCCDonated", _GUICtrlComboBox_GetCurSel($cmbCCDonated) + 1)
IniWrite($config, "attack", "BalanceCCReceived", _GUICtrlComboBox_GetCurSel($cmbCCReceived) + 1)
If GUICtrlRead($radManAbilities) = $GUI_CHECKED Then
IniWrite($config, "attack", "ActivateKQ", "Manual")
ElseIf GUICtrlRead($radAutoAbilities) = $GUI_CHECKED Then
IniWrite($config, "attack", "ActivateKQ", "Auto")
EndIf
If GUICtrlRead($chkUseWardenAbility) = $GUI_CHECKED Then
IniWrite($config, "attack", "ActivateWarden", 1)
Else
IniWrite($config, "attack", "ActivateWarden", 0)
EndIf
IniWrite($config, "attack", "delayActivateKQ", GUICtrlRead($txtManAbilities))
IniWrite($config, "attack", "delayActivateW", GUICtrlRead($txtWardenAbility))
If GUICtrlRead($chkTakeLootSS) = $GUI_CHECKED Then
IniWrite($config, "attack", "TakeLootSnapShot", 1)
Else
IniWrite($config, "attack", "TakeLootSnapShot", 0)
EndIf
If GUICtrlRead($chkScreenshotLootInfo) = $GUI_CHECKED Then
IniWrite($config, "attack", "ScreenshotLootInfo", 1)
Else
IniWrite($config, "attack", "ScreenshotLootInfo", 0)
EndIf
If GUICtrlRead($chkTSDropCC) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSDropCC", 1)
Else
IniWriteS($config, "attack", "TSDropCC", 0)
EndIf
If GUICtrlRead($chkUseCCBalanced) = $GUI_CHECKED Then
IniWriteS($config, "ClanClastle", "BalanceCC", 1)
Else
IniWriteS($config, "ClanClastle", "BalanceCC", 0)
EndIf
If GUICtrlRead($chkDBLightSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBLightSpell", 1)
Else
IniWriteS($config, "attack", "DBLightSpell", 0)
EndIf
If GUICtrlRead($chkABLightSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABLightSpell", 1)
Else
IniWriteS($config, "attack", "ABLightSpell", 0)
EndIf
If GUICtrlRead($chkTSLightSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSLightSpell", 1)
Else
IniWriteS($config, "attack", "TSLightSpell", 0)
EndIf
If GUICtrlRead($chkDBHealSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBHealSpell", 1)
Else
IniWriteS($config, "attack", "DBHealSpell", 0)
EndIf
If GUICtrlRead($chkABHealSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABHealSpell", 1)
Else
IniWriteS($config, "attack", "ABHealSpell", 0)
EndIf
If GUICtrlRead($chkTSHealSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSHealSpell", 1)
Else
IniWriteS($config, "attack", "TSHealSpell", 0)
EndIf
If GUICtrlRead($chkDBRageSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBRageSpell", 1)
Else
IniWriteS($config, "attack", "DBRageSpell", 0)
EndIf
If GUICtrlRead($chkABRageSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABRageSpell", 1)
Else
IniWriteS($config, "attack", "ABRageSpell", 0)
EndIf
If GUICtrlRead($chkTSRageSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSRageSpell", 1)
Else
IniWriteS($config, "attack", "TSRageSpell", 0)
EndIf
If GUICtrlRead($chkDBJumpSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBJumpSpell", 1)
Else
IniWriteS($config, "attack", "DBJumpSpell", 0)
EndIf
If GUICtrlRead($chkABJumpSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABJumpSpell", 1)
Else
IniWriteS($config, "attack", "ABJumpSpell", 0)
EndIf
If GUICtrlRead($chkTSJumpSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSJumpSpell", 1)
Else
IniWriteS($config, "attack", "TSJumpSpell", 0)
EndIf
If GUICtrlRead($chkDBFreezeSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBFreezeSpell", 1)
Else
IniWriteS($config, "attack", "DBFreezeSpell", 0)
EndIf
If GUICtrlRead($chkABFreezeSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABFreezeSpell", 1)
Else
IniWriteS($config, "attack", "ABFreezeSpell", 0)
EndIf
If GUICtrlRead($chkTSFreezeSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSFreezeSpell", 1)
Else
IniWriteS($config, "attack", "TSFreezeSpell", 0)
EndIf
If GUICtrlRead($chkDBPoisonSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBPoisonSpell", 1)
Else
IniWriteS($config, "attack", "DBPoisonSpell", 0)
EndIf
If GUICtrlRead($chkABPoisonSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABPoisonSpell", 1)
Else
IniWriteS($config, "attack", "ABPoisonSpell", 0)
EndIf
If GUICtrlRead($chkTSPoisonSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSPoisonSpell", 1)
Else
IniWriteS($config, "attack", "TSPoisonSpell", 0)
EndIf
If GUICtrlRead($chkDBEarthquakeSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBEarthquakeSpell", 1)
Else
IniWriteS($config, "attack", "DBEarthquakeSpell", 0)
EndIf
If GUICtrlRead($chkABEarthquakeSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABEarthquakeSpell", 1)
Else
IniWriteS($config, "attack", "ABEarthquakeSpell", 0)
EndIf
If GUICtrlRead($chkTSEarthquakeSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSEarthquakeSpell", 1)
Else
IniWriteS($config, "attack", "TSEarthquakeSpell", 0)
EndIf
If GUICtrlRead($chkDBHasteSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "DBHasteSpell", 1)
Else
IniWriteS($config, "attack", "DBHasteSpell", 0)
EndIf
If GUICtrlRead($chkABHasteSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ABHasteSpell", 1)
Else
IniWriteS($config, "attack", "ABHasteSpell", 0)
EndIf
If GUICtrlRead($chkTSHasteSpell) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TSHasteSpell", 1)
Else
IniWriteS($config, "attack", "TSHasteSpell", 0)
EndIf
If GUICtrlRead($chkTHSnipeBeforeDBEnable) = $GUI_CHECKED Then
$THSnipeBeforeDBEnable = 1
Else
$THSnipeBeforeDBEnable = 0
EndIf
If GUICtrlRead($chkTHSnipeBeforeLBEnable) = $GUI_CHECKED Then
$THSnipeBeforeLBEnable = 1
Else
$THSnipeBeforeLBEnable = 0
EndIf
$THSnipeBeforeDBTiles = GUICtrlRead($txtTHSnipeBeforeDBTiles)
$THSnipeBeforeLBTiles = GUICtrlRead($txtTHSnipeBeforeLBTiles)
$THSnipeBeforeDBScript = GUICtrlRead($cmbTHSnipeBeforeDBScript)
$THSnipeBeforeLBScript = GUICtrlRead($cmbTHSnipeBeforeLBScript)
IniWriteS($config, "attack", "THSnipeBeforeDBEnable", $THSnipeBeforeDBEnable)
IniWriteS($config, "attack", "THSnipeBeforeLBEnable", $THSnipeBeforeLBEnable)
IniWriteS($config, "attack", "THSnipeBeforeDBTiles", $THSnipeBeforeDBTiles)
IniWriteS($config, "attack", "THSnipeBeforeLBTiles", $THSnipeBeforeLBTiles)
IniWriteS($config, "attack", "THSnipeBeforeDBScript", $THSnipeBeforeDBScript)
IniWriteS($config, "attack", "THSnipeBeforeLBScript", $THSnipeBeforeLBScript)
If GUICtrlRead($chkUseCCBalanced) = $GUI_CHECKED Then
IniWriteS($config, "attack", "BalanceCC", 1)
Else
IniWriteS($config, "attack", "BalanceCC", 0)
EndIf
IniWriteS($config, "ClanClastle", "BalanceCCDonated", _GUICtrlComboBox_GetCurSel($cmbCCDonated) + 1)
IniWriteS($config, "ClanClastle", "BalanceCCReceived", _GUICtrlComboBox_GetCurSel($cmbCCReceived) + 1)
If GUICtrlRead($radManAbilities) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ActivateKQ", "Manual")
ElseIf GUICtrlRead($radAutoAbilities) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ActivateKQ", "Auto")
EndIf
If GUICtrlRead($chkUseWardenAbility) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ActivateWarden", 1)
Else
IniWriteS($config, "attack", "ActivateWarden", 0)
EndIf
IniWriteS($config, "attack", "delayActivateKQ", GUICtrlRead($txtManAbilities))
IniWriteS($config, "attack", "delayActivateW", GUICtrlRead($txtWardenAbility))
If GUICtrlRead($chkTakeLootSS) = $GUI_CHECKED Then
IniWriteS($config, "attack", "TakeLootSnapShot", 1)
Else
IniWriteS($config, "attack", "TakeLootSnapShot", 0)
EndIf
If GUICtrlRead($chkScreenshotLootInfo) = $GUI_CHECKED Then
IniWriteS($config, "attack", "ScreenshotLootInfo", 1)
Else
IniWriteS($config, "attack", "ScreenshotLootInfo", 0)
EndIf
IniWriteS($config, "endbattle", "txtDBTimeStopAtk", GUICtrlRead($txtDBTimeStopAtk))
IniWriteS($config, "endbattle", "chkDBTimeStopAtk", GUICtrlRead($chkDBTimeStopAtk))
IniWriteS($config, "endbattle", "txtDBTimeStopAtk2", GUICtrlRead($txtDBTimeStopAtk2))
IniWriteS($config, "endbattle", "chkDBTimeStopAtk2", GUICtrlRead($chkDBTimeStopAtk2))
IniWriteS($config, "endbattle", "txtDBMinGoldStopAtk2", GUICtrlRead($txtDBMinGoldStopAtk2))
IniWriteS($config, "endbattle", "txtDBMinElixirStopAtk2", GUICtrlRead($txtDBMinElixirStopAtk2))
IniWriteS($config, "endbattle", "txtDBMinDarkElixirStopAtk2", GUICtrlRead($txtDBMinDarkElixirStopAtk2))
IniWriteS($config, "endbattle", "chkDBEndOneStar", GUICtrlRead($chkDBEndOneStar))
IniWriteS($config, "endbattle", "chkDBEndTwoStars", GUICtrlRead($chkDBEndTwoStars))
If GUICtrlRead($chkDBEndNoResources) = $GUI_CHECKED Then
IniWriteS($config, "endbattle", "chkDBEndNoResources", 1)
Else
IniWriteS($config, "endbattle", "chkDBEndNoResources", 0)
EndIf
IniWriteS($config, "endBattle", "txtABTimeStopAtk", GUICtrlRead($txtABTimeStopAtk))
IniWriteS($config, "endBattle", "chkABTimeStopAtk", GUICtrlRead($chkABTimeStopAtk))
IniWriteS($config, "endBattle", "txtABTimeStopAtk2", GUICtrlRead($txtABTimeStopAtk2))
IniWriteS($config, "endBattle", "chkABTimeStopAtk2", GUICtrlRead($chkABTimeStopAtk2))
IniWriteS($config, "endBattle", "txtABMinGoldStopAtk2", GUICtrlRead($txtABMinGoldStopAtk2))
IniWriteS($config, "endBattle", "txtABMinElixirStopAtk2", GUICtrlRead($txtABMinElixirStopAtk2))
IniWriteS($config, "endBattle", "txtABMinDarkElixirStopAtk2", GUICtrlRead($txtABMinDarkElixirStopAtk2))
IniWriteS($config, "endBattle", "chkABEndOneStar", GUICtrlRead($chkABEndOneStar))
IniWriteS($config, "endBattle", "chkABEndTwoStars", GUICtrlRead($chkABEndTwoStars))
If GUICtrlRead($chkABEndNoResources) = $GUI_CHECKED Then
IniWriteS($config, "endBattle", "chkABEndNoResources", 1)
Else
IniWriteS($config, "endBattle", "chkABEndNoResources", 0)
EndIf
IniWriteS($config, "endbattle", "chkDESideEB", $DESideEB)
IniWriteS($config, "endbattle", "txtDELowEndMin", $DELowEndMin)
IniWriteS($config, "endbattle", "chkDisableOtherEBO", $DisableOtherEBO)
IniWriteS($config, "endbattle", "chkDEEndAq", $DEEndAq)
IniWriteS($config, "endbattle", "chkDEEndBk", $DEEndBk)
IniWriteS($config, "endbattle", "chkDEEndOneStar", $DEEndOneStar)
If GUICtrlRead($chkAttackNow) = $GUI_CHECKED Then
IniWriteS($config, "general", "attacknow", 1)
Else
IniWriteS($config, "general", "attacknow", 0)
EndIf
IniWriteS($config, "general", "attacknowdelay", _GUICtrlComboBox_GetCurSel($cmbAttackNowDelay))
If GUICtrlRead($chkbtnScheduler) = $GUI_CHECKED Then
IniWriteS($config, "general", "BtnScheduler", 1)
Else
IniWriteS($config, "general", "BtnScheduler", 0)
EndIf
If GUICtrlRead($BullyCheck) = $GUI_CHECKED Then
IniWriteS($config, "search", "BullyMode", 1)
Else
IniWriteS($config, "search", "BullyMode", 0)
EndIf
IniWriteS($config, "search", "ATBullyMode", $ATBullyMode)
IniWriteS($config, "search", "YourTH", $YourTH)
IniWriteS($config, "search", "THBullyAttackMode", $iTHBullyAttackMode)
IniWriteS($config, "search", "THaddTiles", GUICtrlRead($txtTHaddtiles))
$txtAttackTHType = GUICtrlRead($cmbAttackTHType)
IniWriteS($config, "attack", "AttackTHType", $scmbAttackTHType)
IniWriteS($config, "search", "TSMeetGE", _GUICtrlComboBox_GetCurSel($cmbTSMeetGE))
IniWriteS($config, "search", "TSEnableAfterCount", GUICtrlRead($txtTSSearchesMin))
IniWriteS($config, "search", "TSEnableBeforeCount", GUICtrlRead($txtTSSearchesMax))
IniWriteS($config, "search", "TSEnableAfterTropies", GUICtrlRead($txtTSTropiesMin))
IniWriteS($config, "search", "TSEnableBeforeTropies", GUICtrlRead($txtTSTropiesMax))
IniWriteS($config, "search", "TSEnableAfterArmyCamps", GUICtrlRead($txtTSArmyCamps))
IniWriteS($config, "search", "TSsearchGold", GUICtrlRead($txtTSMinGold))
IniWriteS($config, "search", "TSsearchElixir", GUICtrlRead($txtTSMinElixir))
IniWriteS($config, "search", "TSsearchGoldPlusElixir", GUICtrlRead($txtTSMinGoldPlusElixir))
IniWriteS($config, "search", "TSsearchDark", GUICtrlRead($txtTSMinDarkElixir))
IniWriteS($config, "Unbreakable", "chkUnbreakable", $iUnbreakableMode)
IniWriteS($config, "Unbreakable", "UnbreakableWait", $iUnbreakableWait)
IniWriteS($config, "Unbreakable", "minUnBrkgold", $iUnBrkMinGold)
IniWriteS($config, "Unbreakable", "minUnBrkelixir", $iUnBrkMinElixir)
IniWriteS($config, "Unbreakable", "minUnBrkdark", $iUnBrkMinDark)
IniWriteS($config, "Unbreakable", "maxUnBrkgold", $iUnBrkMaxGold)
IniWriteS($config, "Unbreakable", "maxUnBrkelixir", $iUnBrkMaxElixir)
IniWriteS($config, "Unbreakable", "maxUnBrkdark", $iUnBrkMaxDark)
IniWriteS($config, "donate", "txtRequest", GUICtrlRead($txtRequestCC))
IniWriteS($config, "donate", "chkDonateBarbarians", $ichkDonateBarbarians)
IniWriteS($config, "donate", "chkDonateAllBarbarians", $ichkDonateAllBarbarians)
IniWriteS($config, "donate", "txtDonateBarbarians", StringReplace($sTxtDonateBarbarians, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistBarbarians", StringReplace($sTxtBlacklistBarbarians, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateArchers", $ichkDonateArchers)
IniWriteS($config, "donate", "chkDonateAllArchers", $ichkDonateAllArchers)
IniWriteS($config, "donate", "txtDonateArchers", StringReplace($sTxtDonateArchers, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistArchers", StringReplace($sTxtBlacklistArchers, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateGiants", $ichkDonateGiants)
IniWriteS($config, "donate", "chkDonateAllGiants", $ichkDonateAllGiants)
IniWriteS($config, "donate", "txtDonateGiants", StringReplace($sTxtDonateGiants, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistGiants", StringReplace($sTxtBlacklistGiants, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateGoblins", $ichkDonateGoblins)
IniWriteS($config, "donate", "chkDonateAllGoblins", $ichkDonateAllGoblins)
IniWriteS($config, "donate", "txtDonateGoblins", StringReplace($sTxtDonateGoblins, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistGoblins", StringReplace($sTxtBlacklistGoblins, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateWallBreakers", $ichkDonateWallBreakers)
IniWriteS($config, "donate", "chkDonateAllWallBreakers", $ichkDonateAllWallBreakers)
IniWriteS($config, "donate", "txtDonateWallBreakers", StringReplace($sTxtDonateWallBreakers, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistWallBreakers", StringReplace($sTxtBlacklistWallBreakers, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateBalloons", $ichkDonateBalloons)
IniWriteS($config, "donate", "chkDonateAllBalloons", $ichkDonateAllBalloons)
IniWriteS($config, "donate", "txtDonateBalloons", StringReplace($sTxtDonateBalloons, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistBalloons", StringReplace($sTxtBlacklistBalloons, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateWizards", $ichkDonateWizards)
IniWriteS($config, "donate", "chkDonateAllWizards", $ichkDonateAllWizards)
IniWriteS($config, "donate", "txtDonateWizards", StringReplace($sTxtDonateWizards, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistWizards", StringReplace($sTxtBlacklistWizards, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateHealers", $ichkDonateHealers)
IniWriteS($config, "donate", "chkDonateAllHealers", $ichkDonateAllHealers)
IniWriteS($config, "donate", "txtDonateHealers", StringReplace($sTxtDonateHealers, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistHealers", StringReplace($sTxtBlacklistHealers, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateDragons", $ichkDonateDragons)
IniWriteS($config, "donate", "chkDonateAllDragons", $ichkDonateAllDragons)
IniWriteS($config, "donate", "txtDonateDragons", StringReplace($sTxtDonateDragons, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistDragons", StringReplace($sTxtBlacklistDragons, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonatePekkas", $ichkDonatePekkas)
IniWriteS($config, "donate", "chkDonateAllPekkas", $ichkDonateAllPekkas)
IniWriteS($config, "donate", "txtDonatePekkas", StringReplace($sTxtDonatePekkas, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistPekkas", StringReplace($sTxtBlacklistPekkas, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateBabyDragons", $ichkDonateBabyDragons)
IniWriteS($config, "donate", "chkDonateAllBabyDragons", $ichkDonateAllBabyDragons)
IniWriteS($config, "donate", "txtDonateBabyDragons", StringReplace($sTxtDonateBabyDragons, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistBabyDragons", StringReplace($sTxtBlacklistBabyDragons, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateMiners", $ichkDonateMiners)
IniWriteS($config, "donate", "chkDonateAllMiners", $ichkDonateAllMiners)
IniWriteS($config, "donate", "txtDonateMiners", StringReplace($sTxtDonateMiners, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistMiners", StringReplace($sTxtBlacklistMiners, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateMinions", $ichkDonateMinions)
IniWriteS($config, "donate", "chkDonateAllMinions", $ichkDonateAllMinions)
IniWriteS($config, "donate", "txtDonateMinions", StringReplace($sTxtDonateMinions, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistMinions", StringReplace($sTxtBlacklistMinions, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateHogRiders", $ichkDonateHogRiders)
IniWriteS($config, "donate", "chkDonateAllHogRiders", $ichkDonateAllHogRiders)
IniWriteS($config, "donate", "txtDonateHogRiders", StringReplace($sTxtDonateHogRiders, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistHogRiders", StringReplace($sTxtBlacklistHogRiders, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateValkyries", $ichkDonateValkyries)
IniWriteS($config, "donate", "chkDonateAllValkyries", $ichkDonateAllValkyries)
IniWriteS($config, "donate", "txtDonateValkyries", StringReplace($sTxtDonateValkyries, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistValkyries", StringReplace($sTxtBlacklistValkyries, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateGolems", $ichkDonateGolems)
IniWriteS($config, "donate", "chkDonateAllGolems", $ichkDonateAllGolems)
IniWriteS($config, "donate", "txtDonateGolems", StringReplace($sTxtDonateGolems, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistGolems", StringReplace($sTxtBlacklistGolems, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateWitches", $ichkDonateWitches)
IniWriteS($config, "donate", "chkDonateAllWitches", $ichkDonateAllWitches)
IniWriteS($config, "donate", "txtDonateWitches", StringReplace($sTxtDonateWitches, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistWitches", StringReplace($sTxtBlacklistWitches, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateLavaHounds", $ichkDonateLavaHounds)
IniWriteS($config, "donate", "chkDonateAllLavaHounds", $ichkDonateAllLavaHounds)
IniWriteS($config, "donate", "txtDonateLavaHounds", StringReplace($sTxtDonateLavaHounds, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistLavaHounds", StringReplace($sTxtBlacklistLavaHounds, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateBowlers", $ichkDonateBowlers)
IniWriteS($config, "donate", "chkDonateAllBowlers", $ichkDonateAllBowlers)
IniWriteS($config, "donate", "txtDonateBowlers", StringReplace($sTxtDonateBowlers, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistBowlers", StringReplace($sTxtBlacklistBowlers, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonatePoisonSpells", $ichkDonatePoisonSpells)
IniWriteS($config, "donate", "chkDonateAllPoisonSpells", $ichkDonateAllPoisonSpells)
IniWriteS($config, "donate", "txtDonatePoisonSpells", StringReplace($sTxtDonatePoisonSpells, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistPoisonSpells", StringReplace($sTxtBlacklistPoisonSpells, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateEarthQuakeSpells", $ichkDonateEarthQuakeSpells)
IniWriteS($config, "donate", "chkDonateAllEarthQuakeSpells", $ichkDonateAllEarthQuakeSpells)
IniWriteS($config, "donate", "txtDonateEarthQuakeSpells", StringReplace($sTxtDonateEarthQuakeSpells, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistEarthQuakeSpells", StringReplace($sTxtBlacklistEarthQuakeSpells, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateHasteSpells", $ichkDonateHasteSpells)
IniWriteS($config, "donate", "chkDonateAllHasteSpells", $ichkDonateAllHasteSpells)
IniWriteS($config, "donate", "txtDonateHasteSpells", StringReplace($sTxtDonateHasteSpells, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistHasteSpells", StringReplace($sTxtBlacklistHasteSpells, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateSkeletonSpells", $ichkDonateSkeletonSpells)
IniWriteS($config, "donate", "chkDonateAllSkeletonSpells", $ichkDonateAllSkeletonSpells)
IniWriteS($config, "donate", "txtDonateSkeletonSpells", StringReplace($sTxtDonateSkeletonSpells, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistSkeletonSpells", StringReplace($sTxtBlacklistSkeletonSpells, @CRLF, "|"))
IniWriteS($config, "donate", "chkDonateCustomA", $ichkDonateCustomA)
IniWriteS($config, "donate", "chkDonateAllCustomA", $ichkDonateAllCustomA)
IniWriteS($config, "donate", "txtDonateCustomA", StringReplace($sTxtDonateCustomA, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistCustomA", StringReplace($sTxtBlacklistCustomA, @CRLF, "|"))
IniWriteS($config, "donate", "cmbDonateCustomA1", $varDonateCustomA[0][0])
IniWriteS($config, "donate", "txtDonateCustomA1", $varDonateCustomA[0][1])
IniWriteS($config, "donate", "cmbDonateCustomA2", $varDonateCustomA[1][0])
IniWriteS($config, "donate", "txtDonateCustomA2", $varDonateCustomA[1][1])
IniWriteS($config, "donate", "cmbDonateCustomA3", $varDonateCustomA[2][0])
IniWriteS($config, "donate", "txtDonateCustomA3", $varDonateCustomA[2][1])
IniWriteS($config, "donate", "chkDonateCustomB", $ichkDonateCustomB)
IniWriteS($config, "donate", "chkDonateAllCustomB", $ichkDonateAllCustomB)
IniWriteS($config, "donate", "txtDonateCustomB", StringReplace($sTxtDonateCustomB, @CRLF, "|"))
IniWriteS($config, "donate", "txtBlacklistCustomB", StringReplace($sTxtBlacklistCustomB, @CRLF, "|"))
IniWriteS($config, "donate", "cmbDonateCustomB1", $varDonateCustomB[0][0])
IniWriteS($config, "donate", "txtDonateCustomB1", $varDonateCustomB[0][1])
IniWriteS($config, "donate", "cmbDonateCustomB2", $varDonateCustomB[1][0])
IniWriteS($config, "donate", "txtDonateCustomB2", $varDonateCustomB[1][1])
IniWriteS($config, "donate", "cmbDonateCustomB3", $varDonateCustomB[2][0])
IniWriteS($config, "donate", "txtDonateCustomB3", $varDonateCustomB[2][1])
IniWriteS($config, "donate", "txtBlacklist", StringReplace($sTxtBlacklist, @CRLF, "|"))
IniWriteS($config, "donate", "chkExtraAlphabets", $ichkExtraAlphabets)
For $i = 0 To UBound($TroopName) - 1
IniWriteS($config, "troop", $TroopName[$i], GUICtrlRead(Eval("txtNum" & $TroopName[$i])))
Next
For $i = 0 To UBound($TroopDarkName) - 1
IniWriteS($config, "troop", $TroopDarkName[$i], GUICtrlRead(Eval("txtNum" & $TroopDarkName[$i])))
Next
IniWriteS($config, "troop", "fulltroop", GUICtrlRead($txtFullTroop))
IniWriteS($config, "other", "TrainITDelay", $isldTrainITDelay)
IniWriteS($config, "other", "chkCloseWaitEnable", $ichkCloseWaitEnable)
IniWriteS($config, "other", "chkCloseWaitTrain", $ichkCloseWaitTrain)
IniWriteS($config, "other", "btnCloseWaitStop", $ibtnCloseWaitStop)
IniWriteS($config, "other", "btnCloseWaitStopRandom", $ibtnCloseWaitStopRandom)
IniWriteS($config, "other", "btnCloseWaitExact", $ibtnCloseWaitExact)
IniWriteS($config, "other", "btnCloseWaitRandom", $ibtnCloseWaitRandom)
IniWriteS($config, "other", "CloseWaitRdmPercent", _GUICtrlComboBox_GetCurSel($cmbCloseWaitRdmPercent))
IniWriteS($config, "other", "MinimumTimeToClose", GUICtrlRead($cmbMinimumTimeClose))
IniWriteS($config, "troop", "chkTroopOrder", $ichkTroopOrder)
For $z = 0 To UBound($DefaultTroopGroup) -1
IniWriteS($config, "troop", "cmbTroopOrder" & $z, _GUICtrlComboBox_GetCurSel($cmbTroopOrder[$z]))
Next
IniWriteS($config, "troop", "chkDarkTroopOrder", $ichkDarkTroopOrder)
For $z = 0 To UBound($DefaultTroopGroupDark) -1
IniWriteS($config, "troop", "cmbDarkTroopOrder" & $z, _GUICtrlComboBox_GetCurSel($cmbDarkTroopOrder[$z]))
Next
IniWriteS($config, "Spells", "LightningSpell", GUICtrlRead($txtNumLightningSpell))
IniWriteS($config, "Spells", "RageSpell", GUICtrlRead($txtNumRageSpell))
IniWriteS($config, "Spells", "HealSpell", GUICtrlRead($txtNumHealSpell))
IniWriteS($config, "Spells", "JumpSpell", GUICtrlRead($txtNumJumpSpell))
IniWriteS($config, "Spells", "FreezeSpell", GUICtrlRead($txtNumFreezeSpell))
IniWriteS($config, "Spells", "CloneSpell", GUICtrlRead($txtNumCloneSpell))
IniWriteS($config, "Spells", "PoisonSpell", GUICtrlRead($txtNumPoisonSpell))
IniWriteS($config, "Spells", "EarthSpell", GUICtrlRead($txtNumEarthSpell))
IniWriteS($config, "Spells", "HasteSpell", GUICtrlRead($txtNumHasteSpell))
IniWriteS($config, "Spells", "SkeletonSpell", GUICtrlRead($txtNumSkeletonSpell))
IniWriteS($config, "Spells", "SpellFactory", GUICtrlRead($txtTotalCountSpell))
IniWriteS($building, "upgrade", "upgradetroops", $ichkLab)
IniWriteS($building, "upgrade", "upgradetroopname", $icmbLaboratory)
IniWrite($building, "upgrade", "upgradelabtime", $sLabUpgradeTime)
IniWriteS($building, "upgrade", "LabPosX", $aLabPos[0])
IniWriteS($building, "upgrade", "LabPosY", $aLabPos[1])
IniWriteS($config, "upgrade", "UpgradeKing", $ichkUpgradeKing)
IniWriteS($config, "upgrade", "UpgradeQueen", $ichkUpgradeQueen)
IniWriteS($config, "upgrade", "UpgradeWarden", $ichkUpgradeWarden)
IniWriteS($config, "upgrade", "auto-wall", $ichkWalls)
IniWriteS($config, "upgrade", "savebldr", $iSaveWallBldr)
IniWriteS($config, "upgrade", "upgradewallcontinually", $ichkUpgradeContinually)
IniWriteS($config, "upgrade", "use-storage", $iUseStorage)
IniWriteS($config, "upgrade", "walllvl", $icmbWalls)
IniWriteS($config, "upgrade", "MaxNbWall", $iMaxNbWall)
IniWriteS($config, "upgrade", "minwallgold", $itxtWallMinGold)
IniWriteS($config, "upgrade", "minwallelixir", $itxtWallMinElixir)
IniWriteS($config, "upgrade", "minupgrgold", $itxtUpgrMinGold)
IniWriteS($config, "upgrade", "minupgrelixir", $itxtUpgrMinElixir)
IniWriteS($config, "upgrade", "minupgrdark", $itxtUpgrMinDark)
IniWriteS($config, "upgrade", "WallCost", $WallCost)
IniWriteS($config, "Walls", "Wall04", $itxtWall04ST)
IniWriteS($config, "Walls", "Wall05", $itxtWall05ST)
IniWriteS($config, "Walls", "Wall06", $itxtWall06ST)
IniWriteS($config, "Walls", "Wall07", $itxtWall07ST)
IniWriteS($config, "Walls", "Wall08", $itxtWall08ST)
IniWriteS($config, "Walls", "Wall09", $itxtWall09ST)
IniWriteS($config, "Walls", "Wall10", $itxtWall10ST)
IniWriteS($config, "Walls", "Wall11", $itxtWall11ST)
For $iz = 0 To UBound($aUpgrades, 1) - 1
IniWrite($building, "upgrade", "xupgrade" & $iz, $aUpgrades[$iz][0])
IniWrite($building, "upgrade", "yupgrade" & $iz, $aUpgrades[$iz][1])
IniWrite($building, "upgrade", "upgradevalue" & $iz, $aUpgrades[$iz][2])
IniWrite($building, "upgrade", "upgradetype" & $iz, $aUpgrades[$iz][3])
IniWrite($building, "upgrade", "upgradename" & $iz, $aUpgrades[$iz][4])
IniWrite($building, "upgrade", "upgradelevel" & $iz, $aUpgrades[$iz][5])
IniWrite($building, "upgrade", "upgradetime" & $iz, $aUpgrades[$iz][6])
IniWrite($building, "upgrade", "upgradeend" & $iz, $aUpgrades[$iz][7])
IniWrite($building, "upgrade", "upgradestatusicon" & $iz, $ipicUpgradeStatus[$iz])
IniWrite($building, "upgrade", "upgradechk" & $iz, $ichkbxUpgrade[$iz])
IniWrite($building, "upgrade", "upgraderepeat" & $iz, $ichkUpgrdeRepeat[$iz])
Next
IniWriteS($config, "other", "minrestartgold", $itxtRestartGold)
IniWriteS($config, "other", "minrestartelixir", $itxtRestartElixir)
IniWriteS($config, "other", "minrestartdark", $itxtRestartDark)
If GUICtrlRead($chkTrap) = $GUI_CHECKED Then
IniWriteS($config, "other", "chkTrap", 1)
Else
IniWriteS($config, "other", "chkTrap", 0)
EndIf
If GUICtrlRead($chkCollect) = $GUI_CHECKED Then
IniWriteS($config, "other", "chkCollect", 1)
Else
IniWriteS($config, "other", "chkCollect", 0)
EndIf
If GUICtrlRead($chkTombstones) = $GUI_CHECKED Then
IniWriteS($config, "other", "chkTombstones", 1)
Else
IniWriteS($config, "other", "chkTombstones", 0)
EndIf
IniWriteS($config, "other", "txtTimeWakeUp", $sTimeWakeUp)
IniWriteS($config, "other", "VSDelay", $iVSDelay)
IniWriteS($config, "other", "MaxVSDelay", $iMaxVSDelay)
If GUICtrlRead($chkCleanYard) = $GUI_CHECKED Then
IniWriteS($config, "other", "chkCleanYard", 1)
Else
IniWriteS($config, "other", "chkCleanYard", 0)
EndIf
If GUICtrlRead($chkGemsBox) = $GUI_CHECKED Then
IniWriteS($config, "other", "chkGemsBox", 1)
Else
IniWriteS($config, "other", "chkGemsBox", 0)
EndIf
IniWriteS($config, "search", "TrophyRange", $iChkTrophyRange)
IniWriteS($config, "search", "MaxTrophy", $itxtMaxTrophy)
IniWriteS($config, "search", "MinTrophy", $itxtdropTrophy)
IniWriteS($config, "search", "chkTrophyHeroes", $iChkTrophyHeroes)
IniWriteS($config, "search", "chkTrophyAtkDead", $iChkTrophyAtkDead)
IniWriteS($config, "search", "DTArmyMin", $itxtDTArmyMin)
SetDebugLog("Save Building Config " & $building)
IniWriteS($building, "general", "version", GetVersionNormalized($sBotVersion))
IniWriteS($building, "other", "xTownHall", $TownHallPos[0])
IniWriteS($building, "other", "yTownHall", $TownHallPos[1])
IniWriteS($building, "other", "LevelTownHall", $iTownHallLevel)
IniWriteS($building, "other", "xCCPos", $aCCPos[0])
IniWriteS($building, "other", "yCCPos", $aCCPos[1])
IniWriteS($building, "other", "CCAutoDetected", $IsCCAutoLocated[0])
IniWriteS($building, "other", "CCLevel", $IsCCAutoLocated[1])
IniWriteS($building, "other", "OffsetxCCPos", $IsCCAutoLocated[2])
IniWriteS($building, "other", "OffsetyCCPos", $IsCCAutoLocated[3])
IniWriteS($building, "other", "xArmy", $ArmyPos[0])
IniWriteS($building, "other", "yArmy", $ArmyPos[1])
IniWriteS($building, "other", "totalcamp", $TotalCamp)
IniWriteS($building, "other", "listResource", $listResourceLocation)
IniWriteS($building, "other", "xBarrack1", $barrackPos[0][0])
IniWriteS($building, "other", "yBarrack1", $barrackPos[0][1])
IniWriteS($building, "other", "xBarrack2", $barrackPos[1][0])
IniWriteS($building, "other", "yBarrack2", $barrackPos[1][1])
IniWriteS($building, "other", "xBarrack3", $barrackPos[2][0])
IniWriteS($building, "other", "yBarrack3", $barrackPos[2][1])
IniWriteS($building, "other", "xBarrack4", $barrackPos[3][0])
IniWriteS($building, "other", "yBarrack4", $barrackPos[3][1])
IniWriteS($building, "other", "xDarkBarrack1", $DarkbarrackPos[0][0])
IniWriteS($building, "other", "yDarkBarrack1", $DarkbarrackPos[0][1])
IniWriteS($building, "other", "xDarkBarrack2", $DarkbarrackPos[1][0])
IniWriteS($building, "other", "yDarkBarrack2", $DarkbarrackPos[1][1])
IniWriteS($building, "other", "xKingAltarPos", $KingAltarPos[0])
IniWriteS($building, "other", "yKingAltarPos", $KingAltarPos[1])
IniWriteS($building, "other", "xQueenAltarPos", $QueenAltarPos[0])
IniWriteS($building, "other", "yQueenAltarPos", $QueenAltarPos[1])
IniWriteS($building, "other", "xWardenAltarPos", $WardenAltarPos[0])
IniWriteS($building, "other", "yWardenAltarPos", $WardenAltarPos[1])
IniWriteS($config, "notify", "PBEnabled", $NotifyPBEnabled)
IniWriteS($config, "notify", "AccountToken", $NotifyPBToken)
IniWriteS($config, "notify", "OrigPushBullet", $NotifyOrigin)
IniWriteS($config, "notify", "PBRemote", $NotifyRemoteEnable)
IniWriteS($config, "notify", "DeleteAllPBPushes", $NotifyDeleteAllPushesOnStart)
IniWriteS($config, "notify", "DeleteOldPBPushes", $NotifyDeletePushesOlderThan)
IniWriteS($config, "notify", "HoursPushBullet", $NotifyDeletePushesOlderThanHours)
IniWriteS($config, "notify", "TGEnabled", $NotifyTGEnabled)
IniWriteS($config, "notify", "TGToken", $NotifyTGToken)
IniWriteS($config, "notify", "AlertPBVMFound", $NotifyAlertMatchFound)
IniWriteS($config, "notify", "AlertPBLastRaid", $NotifyAlerLastRaidIMG)
IniWriteS($config, "notify", "AlertPBWallUpgrade", $NotifyAlertUpgradeWalls)
IniWriteS($config, "notify", "AlertPBOOS", $NotifyAlertOutOfSync)
IniWriteS($config, "notify", "AlertPBOtherDevice", $NotifyAlertAnotherDevice)
IniWriteS($config, "notify", "AlertPBLastRaidTxt", $NotifyAlerLastRaidTXT)
IniWriteS($config, "notify", "AlertPBCampFull", $NotifyAlertCampFull)
IniWriteS($config, "notify", "AlertPBVillage", $NotifyAlertVillageReport)
IniWriteS($config, "notify", "AlertPBLastAttack", $NotifyAlertLastAttack)
IniWriteS($config, "notify", "AlertPBVBreak", $NotifyAlertTakeBreak)
IniWriteS($config, "notify", "AlertBuilderIdle", $NotifyAlertBulderIdle)
IniWriteS($config, "notify", "AlertPBMaintenance", $NotifyAlertMaintenance)
IniWriteS($config, "notify", "AlertPBBAN", $NotifyAlertBAN)
IniWriteS($config, "notify", "AlertPBUpdate", $NotifyAlertBOTUpdate)
If GUICtrlRead($chkNotifyWeekDays) = $GUI_CHECKED Then
IniWrite($config, "notify", "NotifyWeekDaysEnable", 1)
Else
IniWrite($config, "notify", "NotifyWeekDaysEnable", 0)
EndIf
Local $string = ""
For $i = 0 To 6
If GUICtrlRead(Eval("chkNotifyWeekdays" & $i)) = $GUI_CHECKED Then
$string &= "1|"
Else
$string &= "0|"
EndIf
Next
IniWrite($config, "notify", "NotifyWeekDays", $string)
If GUICtrlRead($chkNotifyHours) = $GUI_CHECKED Then
IniWrite($config, "notify", "NotifyHoursEnable", 1)
Else
IniWrite($config, "notify", "NotifyHoursEnable", 0)
EndIf
Local $string = ""
For $i = 0 To 23
If GUICtrlRead(Eval("chkNotifyHours" & $i)) = $GUI_CHECKED Then
$string &= "1|"
Else
$string &= "0|"
EndIf
Next
IniWrite($config, "notify", "NotifyHours", $string)
IniWriteS($config, "other", "WAOffsetX", $iWAOffsetX)
IniWriteS($config, "other", "WAOffsetY", $iWAOffsetY)
IniWriteS($config, "deletefiles", "DeleteLogs", $ichkDeleteLogs)
IniWriteS($config, "deletefiles", "DeleteLogsDays", $iDeleteLogsDays)
IniWriteS($config, "deletefiles", "DeleteTemp", $ichkDeleteTemp)
IniWriteS($config, "deletefiles", "DeleteTempDays", $iDeleteTempDays)
IniWriteS($config, "deletefiles", "DeleteLoots", $ichkDeleteLoots)
IniWriteS($config, "deletefiles", "DeleteLootsDays", $iDeleteLootsDays)
If GUICtrlRead($chkRequestCCHours) = $GUI_CHECKED Then
IniWriteS($config, "planned", "RequestHoursEnable", 1)
Else
IniWriteS($config, "planned", "RequestHoursEnable", 0)
EndIf
If GUICtrlRead($chkDonateHours) = $GUI_CHECKED Then
IniWriteS($config, "planned", "DonateHoursEnable", 1)
Else
IniWriteS($config, "planned", "DonateHoursEnable", 0)
EndIf
Local $string = ""
For $i = 0 To 23
If GUICtrlRead(Eval("chkDonateHours" & $i)) = $GUI_CHECKED Then
$string &= "1|"
Else
$string &= "0|"
EndIf
Next
IniWriteS($config, "planned", "DonateHours", $string)
Local $string = ""
For $i = 0 To 23
If GUICtrlRead(Eval("chkRequestCCHours" & $i)) = $GUI_CHECKED Then
$string &= "1|"
Else
$string &= "0|"
EndIf
Next
IniWriteS($config, "planned", "RequestHours", $string)
If GUICtrlRead($chkDropCCHoursEnable) = $GUI_CHECKED Then
IniWriteS($config, "planned", "DropCCEnable", 1)
Else
IniWriteS($config, "planned", "DropCCEnable", 0)
EndIf
Local $string = ""
For $i = 0 To 23
If GUICtrlRead(Eval("chkDropCCHours" & $i)) = $GUI_CHECKED Then
$string &= "1|"
Else
$string &= "0|"
EndIf
Next
IniWriteS($config, "planned", "DropCCHours", $string)
Local $string = ""
For $i = 0 To 23
If $iPlannedBoostBarracksHours[$i] = 1 Then
$string &= "1|"
Else
$string &= "0|"
EndIf
Next
IniWriteS($config, "planned", "BoostBarracksHours", $string)
Local $string = ""
For $i = 0 To 23
If GUICtrlRead(Eval("chkattackHours" & $i)) = $GUI_CHECKED Then
$string &= "1|"
Else
$string &= "0|"
EndIf
Next
IniWriteS($config, "planned", "attackHours", $string)
Local $string = ""
For $i = 0 To 6
If GUICtrlRead(Eval("chkAttackWeekdays" & $i)) = $GUI_CHECKED Then
$string &= "1|"
Else
$string &= "0|"
EndIf
Next
IniWriteS($config, "planned", "attackDays", $string)
IniWriteS($config, "planned", "chkAttackPlannerEnable", $ichkAttackPlannerEnable)
IniWriteS($config, "planned", "chkAttackPlannerCloseCoC", $ichkAttackPlannerCloseCoC)
IniWriteS($config, "planned", "chkAttackPlannerCloseAll", $ichkAttackPlannerCloseAll)
IniWriteS($config, "planned", "chkAttackPlannerRandom", $ichkAttackPlannerRandom)
IniWriteS($config, "planned", "cmbAttackPlannerRandom", _GUICtrlComboBox_GetCurSel($cmbAttackPlannerRandom))
IniWriteS($config, "planned", "chkAttackPlannerDayLimit", $ichkAttackPlannerDayLimit)
$icmbAttackPlannerDayMin = GUICtrlRead($cmbAttackPlannerDayMin)
$icmbAttackPlannerDayMax = GUICtrlRead($cmbAttackPlannerDayMax)
IniWriteS($config, "planned", "cmbAttackPlannerDayMin", $icmbAttackPlannerDayMin)
IniWriteS($config, "planned", "cmbAttackPlannerDayMax", $icmbAttackPlannerDayMax)
IniWriteS($config, "shareattack", "minGold", $iShareminGold)
IniWriteS($config, "shareattack", "minElixir", $iShareminElixir)
IniWriteS($config, "shareattack", "minDark", $iShareminDark)
IniWriteS($config, "shareattack", "Message", StringReplace($sShareMessage, @CRLF, "|"))
If GUICtrlRead($chkShareAttack) = $GUI_CHECKED Then
IniWriteS($config, "shareattack", "ShareAttack", 1)
Else
IniWriteS($config, "shareattack", "ShareAttack", 0)
EndIf
IniWriteS($config, "other", "UseRandomClick", $iUseRandomClick)
IniWriteS($config, "other", "ScreenshotType", $iScreenshotType)
IniWriteS($config, "other", "ScreenshotHideName", $ichkScreenshotHideName)
IniWriteS($config, "debug", "debugsetclick", $debugClick)
If $devmode = 1 Then
IniWriteS($config, "debug", "debugsetlog", $DebugSetlog)
IniWriteS($config, "debug", "debugocr", $debugOcr)
IniWriteS($config, "debug", "debugimagesave", $DebugImageSave)
IniWriteS($config, "debug", "debugbuildingpos", $debugBuildingPos)
IniWriteS($config, "debug", "debugtrain", $debugsetlogTrain)
IniWriteS($config, "debug", "debugmakeimgcsv", $makeIMGCSV)
IniWriteS($config, "debug", "debugresourcesoffset", $debugresourcesoffset)
IniWriteS($config, "debug", "continuesearchelixirdebug", $continuesearchelixirdebug)
IniWriteS($config, "debug", "debugMilkingIMGmake", $debugMilkingIMGmake)
IniWriteS($config, "debug", "debugOCRDonate", $debugOCRdonate)
Else
IniDelete($config, "debug", "debugocr")
IniDelete($config, "debug", "debugsetlog")
IniDelete($config, "debug", "debugimagesave")
IniDelete($config, "debug", "debugbuildingpos")
IniDelete($config, "debug", "debugtrain")
IniDelete($config, "debug", "debugresourcesoffset")
IniDelete($config, "debug", "continuesearchelixirdebug")
IniDelete($config, "debug", "debugOCRDonate")
EndIf
IniWriteS($config, "other", "ChkUseQTrain", $ichkUseQTrain)
IniWriteS($config, "other", "ChkForceBrewBeforeAttack", $ichkForceBrewBeforeAttack)
IniWriteS($config, "other", "ChkTotalCampForced", $ichkTotalCampForced)
IniWriteS($config, "other", "ValueTotalCampForced", $iValueTotalCampForced)
IniWriteS($config, "other", "chkSinglePBTForced", $ichkSinglePBTForced)
IniWriteS($config, "other", "ValueSinglePBTimeForced", $iValueSinglePBTimeForced)
IniWriteS($config, "other", "ValuePBTimeForcedExit", $iValuePBTimeForcedExit)
IniWriteS($config, "General", "ChkLanguage", $ichkLanguage)
IniWriteS($config, "General", "ChkDisableSplash", $ichkDisableSplash)
IniWriteS($config, "General", "ChkVersion", $ichkVersion)
IniWriteS($config, "search", "SWTtiles", GUICtrlRead($txtSWTTiles))
IniWriteS($config, "other", "language", $sLanguage)
If $ichkExtraAlphabets = 1 Then FileClose($config)
SaveStatChkDeadBase()
IniWriteS($config, "attack", "ScriptDB", $scmbDBScriptName)
IniWriteS($config, "attack", "ScriptAB", $scmbABScriptName)
IniWriteS($config, "MilkingAttack", "LocateMine", $MilkFarmLocateMine)
IniWriteS($config, "MilkingAttack", "LocateElixir", $MilkFarmLocateElixir)
IniWriteS($config, "MilkingAttack", "LocateDrill", $MilkFarmLocateDrill)
Local $tempElixirParam = ""
For $i = 0 To UBound($MilkFarmElixirParam) - 1
$tempElixirParam &= $MilkFarmElixirParam[$i] & "|"
Next
$tempElixirParam = StringLeft($tempElixirParam, StringLen($tempElixirParam) - 1)
IniWriteS($config, "MilkingAttack", "LocateElixirLevel", $tempElixirParam)
IniWriteS($config, "MilkingAttack", "MineParam", $MilkFarmMineParam)
IniWriteS($config, "MilkingAttack", "DrillParam", $MilkFarmDrillParam)
IniWriteS($config, "MilkingAttack", "AttackElixir", $MilkFarmAttackElixirExtractors)
IniWriteS($config, "MilkingAttack", "AttackMine", $MilkFarmAttackGoldMines)
IniWriteS($config, "MilkingAttack", "AttackDrill", $MilkFarmAttackDarkDrills)
IniWriteS($config, "MilkingAttack", "LimitGold", $MilkFarmLimitGold)
IniWriteS($config, "MilkingAttack", "LimitElixir", $MilkFarmLimitElixir)
IniWriteS($config, "MilkingAttack", "LimitDark", $MilkFarmLimitDark)
IniWriteS($config, "MilkingAttack", "MaxTiles", $MilkFarmResMaxTilesFromBorder)
IniWriteS($config, "MilkingAttack", "TroopForWaveMin", $MilkFarmTroopForWaveMin)
IniWriteS($config, "MilkingAttack", "TroopForWaveMax", $MilkFarmTroopForWaveMax)
IniWriteS($config, "MilkingAttack", "MaxWaves", $MilkFarmTroopMaxWaves)
IniWriteS($config, "MilkingAttack", "DelayBetweenWavesMin", $MilkFarmDelayFromWavesMin)
IniWriteS($config, "MilkingAttack", "DelayBetweenWavesMax", $MilkFarmDelayFromWavesMax)
IniWriteS($config, "MilkingAttack", "TownhallTiles", $MilkFarmTHMaxTilesFromBorder)
IniWriteS($config, "MilkingAttack", "TownHallAlgorithm", $MilkFarmAlgorithmTh)
IniWriteS($config, "MilkingAttack", "TownHallHitAnyway", $MilkFarmSnipeEvenIfNoExtractorsFound)
IniWriteS($config, "MilkingAttack", "MilkFarmForceTolerance", $MilkFarmForcetolerance)
IniWriteS($config, "MilkingAttack", "MilkFarmForcetolerancenormal", $MilkFarmForcetolerancenormal)
IniWriteS($config, "MilkingAttack", "MilkFarmForcetoleranceboosted", $MilkFarmForcetoleranceboosted)
IniWriteS($config, "MilkingAttack", "MilkFarmForcetolerancedestroyed", $MilkFarmForcetolerancedestroyed)
IniWriteS($config, "MilkingAttack", "CheckStructureDestroyedBeforeAttack", $MilkingAttackCheckStructureDestroyedBeforeAttack)
IniWriteS($config, "MilkingAttack", "CheckStructureDestroyedAfterAttack", $MilkingAttackCheckStructureDestroyedAfterAttack)
IniWriteS($config, "MilkingAttack", "DropRandomPlace", $MilkingAttackDropGoblinAlgorithm)
IniWriteS($config, "MilkingAttack", "StructureOrder", $MilkingAttackStructureOrder)
IniWriteS($config, "MilkingAttack", "MilkAttackAfterTHSnipe", $MilkAttackAfterTHSnipe)
IniWriteS($config, "MilkingAttack", "MilkAttackAfterScriptedAtk", $MilkAttackAfterScriptedAtk)
IniWriteS($config, "MilkingAttack", "MilkAttackCSVscript", $MilkAttackCSVscript)
IniWriteS($config, "MilkingAttack", "MilkAttackType", $MilkAttackType)
IniWriteS($config, "collectors", "lvl6Enabled", $chkLvl6Enabled)
IniWriteS($config, "collectors", "lvl7Enabled", $chkLvl7Enabled)
IniWriteS($config, "collectors", "lvl8Enabled", $chkLvl8Enabled)
IniWriteS($config, "collectors", "lvl9Enabled", $chkLvl9Enabled)
IniWriteS($config, "collectors", "lvl10Enabled", $chkLvl10Enabled)
IniWriteS($config, "collectors", "lvl11Enabled", $chkLvl11Enabled)
IniWriteS($config, "collectors", "lvl12Enabled", $chkLvl12Enabled)
IniWriteS($config, "collectors", "lvl6fill", $cmbLvl6Fill)
IniWriteS($config, "collectors", "lvl7fill", $cmbLvl7Fill)
IniWriteS($config, "collectors", "lvl8fill", $cmbLvl8Fill)
IniWriteS($config, "collectors", "lvl9fill", $cmbLvl9Fill)
IniWriteS($config, "collectors", "lvl10fill", $cmbLvl10Fill)
IniWriteS($config, "collectors", "lvl11fill", $cmbLvl11Fill)
IniWriteS($config, "collectors", "lvl12fill", $cmbLvl12Fill)
IniWriteS($config, "collectors", "tolerance", $toleranceOffset)
IniWriteS($config, "android", "game.package", $AndroidGamePackage)
IniWriteS($config, "android", "game.class", $AndroidGameClass)
IniWriteS($config, "android", "check.time.lag.enabled", ($AndroidCheckTimeLagEnabled ? "1" : "0"))
IniWriteS($config, "android", "adb.screencap.timeout.min", $AndroidAdbScreencapTimeoutMin)
IniWriteS($config, "android", "adb.screencap.timeout.max", $AndroidAdbScreencapTimeoutMax)
IniWriteS($config, "android", "adb.screencap.timeout.dynamic", $AndroidAdbScreencapTimeoutDynamic)
IniWriteS($config, "android", "adb.input.enabled", ($AndroidAdbInputEnabled ? "1" : "0"))
IniWriteS($config, "android", "adb.click.enabled", ($AndroidAdbClickEnabled ? "1" : "0"))
IniWriteS($config, "android", "adb.click.group", $AndroidAdbClickGroup)
IniWriteS($config, "android", "adb.clicks.enabled", ($AndroidAdbClicksEnabled ? "1" : "0"))
IniWriteS($config, "android", "adb.clicks.troop.deploy.size", $AndroidAdbClicksTroopDeploySize)
IniWriteS($config, "android", "no.focus.tampering", ($NoFocusTampering ? "1" : "0"))
IniWriteS($config, "android", "shield.color", Hex($AndroidShieldColor, 6))
IniWriteS($config, "android", "shield.transparency", $AndroidShieldTransparency)
IniWriteS($config, "android", "active.color", Hex($AndroidActiveColor, 6))
IniWriteS($config, "android", "active.transparency", $AndroidActiveTransparency)
IniWriteS($config, "android", "inactive.color", Hex($AndroidInactiveColor, 6))
IniWriteS($config, "android", "inactive.transparency", $AndroidInactiveTransparency)
If GUICtrlRead($chkTSActivateCamps2) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkTSSearchCamps2", 1)
Else
IniWriteS($config, "search", "ChkTSSearchCamps2", 0)
EndIf
IniWriteS($config, "search", "TSEnableAfterArmyCamps2", GUICtrlRead($txtTSArmyCamps2))
If GUICtrlRead($chkDBSpellsWait) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkDBSpellsWait", 1)
Else
IniWriteS($config, "search", "ChkDBSpellsWait", 0)
EndIf
If GUICtrlRead($chkDBWaitForCastleSpell) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkDBCastleSpellWait", 1)
Else
IniWriteS($config, "search", "ChkDBCastleSpellWait", 0)
EndIf
If GUICtrlRead($chkABSpellsWait) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkABSpellsWait", 1)
Else
IniWriteS($config, "search", "ChkABSpellsWait", 0)
EndIf
IniWriteS($config, "search", "TotalTrainSpaceSpell", 0)
If GUICtrlRead($chkABWaitForCastleSpell) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkABCastleSpellWait", 1)
Else
IniWriteS($config, "search", "ChkABCastleSpellWait", 0)
EndIf
If GUICtrlRead($chkDBWaitForCastleTroops) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkDBCastleTroopsWait", 1)
Else
IniWriteS($config, "search", "ChkDBCastleTroopsWait", 0)
EndIf
If GUICtrlRead($chkABWaitForCastleTroops) = $GUI_CHECKED Then
IniWriteS($config, "search", "ChkABCastleTroopsWait", 1)
Else
IniWriteS($config, "search", "ChkABCastleTroopsWait", 0)
EndIf
IniWriteS($config, "search", "cmbDBWaitForCastleSpell", _GUICtrlComboBox_GetCurSel($cmbDBWaitForCastleSpell))
IniWriteS($config, "search", "cmbABWaitForCastleSpell", _GUICtrlComboBox_GetCurSel($cmbABWaitForCastleSpell))
If GUICtrlRead($hRadio_Army1) = $GUI_CHECKED Then
IniWriteS($config, "troop", "QuickTrain1", 1)
Else
IniWriteS($config, "troop", "QuickTrain1", 0)
EndIf
If GUICtrlRead($hRadio_Army2) = $GUI_CHECKED Then
IniWriteS($config, "troop", "QuickTrain2", 1)
Else
IniWriteS($config, "troop", "QuickTrain2", 0)
EndIf
If GUICtrlRead($hRadio_Army3) = $GUI_CHECKED Then
IniWriteS($config, "troop", "QuickTrain3", 1)
Else
IniWriteS($config, "troop", "QuickTrain3", 0)
EndIf
If GUICtrlRead($chkSmartLightSpell) = $GUI_CHECKED Then
IniWrite($config, "SmartZap", "UseSmartZap", 1)
Else
IniWrite($config, "SmartZap", "UseSmartZap", 0)
EndIf
If GUICtrlRead($chkNoobZap) = $GUI_CHECKED Then
IniWrite($config, "SmartZap", "UseNoobZap", 1)
Else
IniWrite($config, "SmartZap", "UseNoobZap", 0)
EndIf
If GUICtrlRead($chkSmartZapDB) = $GUI_CHECKED Then
IniWrite($config, "SmartZap", "ZapDBOnly", 1)
Else
IniWrite($config, "SmartZap", "ZapDBOnly", 0)
EndIf
If GUICtrlRead($chkSmartZapSaveHeroes) = $GUI_CHECKED Then
IniWrite($config, "SmartZap", "THSnipeSaveHeroes", 1)
Else
IniWrite($config, "SmartZap", "THSnipeSaveHeroes", 0)
EndIf
If GUICtrlRead($chkDebugSmartZap) = $GUI_CHECKED Then
IniWrite($config, "SmartZap", "DebugSmartZap", 1)
Else
IniWrite($config, "SmartZap", "DebugSmartZap", 0)
EndIf
IniWrite($config, "SmartZap", "MinDE", GUICtrlRead($txtMinDark))
IniWrite($config, "SmartZap", "ExpectedDE", GUICtrlRead($txtExpectedDE))
IniWriteS($config, "SmartZap", "MinTimeCloseATK", GUICtrlRead($MinTimeCloseATK))
IniWrite($config, "Humanization", "chkUseBotHumanization", $ichkUseBotHumanization)
IniWrite($config, "Humanization", "chkUseAltRClick", $ichkUseAltRClick)
IniWrite($config, "Humanization", "chkCollectAchievements", $ichkCollectAchievements)
IniWrite($config, "Humanization", "chkLookAtRedNotifications", $ichkLookAtRedNotifications)
For $i = 0 To 12
IniWrite($config, "Humanization", "cmbPriority[" & $i & "]", _GUICtrlComboBox_GetCurSel($cmbPriority[$i]))
Next
For $i = 0 To 1
IniWrite($config, "Humanization", "cmbMaxSpeed[" & $i & "]", _GUICtrlComboBox_GetCurSel($cmbMaxSpeed[$i]))
Next
For $i = 0 To 1
IniWrite($config, "Humanization", "cmbPause[" & $i & "]", _GUICtrlComboBox_GetCurSel($cmbPause[$i]))
Next
For $i = 0 To 1
IniWrite($config, "Humanization", "humanMessage[" & $i & "]", GUICtrlRead($humanMessage[$i]))
Next
IniWrite($config, "Humanization", "cmbMaxActionsNumber", _GUICtrlComboBox_GetCurSel($cmbMaxActionsNumber))
IniWrite($config, "MyBotName", "Name", GUICtrlRead($NameMyBot))
If $hFile <> -1 Then FileClose($hFile)
EndFunc
Func AttackReport()
Local $iCount
$lootGold = ""
$lootElixir = ""
$lootDarkElixir = ""
$lootTrophies = ""
$iCount = 0
While _CheckPixel($aEndFightSceneAvl, True) = False
$iCount += 1
If _Sleep($iDelayAttackReport1) Then Return
If $debugSetlog = 1 Then Setlog("Waiting Attack Report Ready, " & ($iCount / 2) & " Seconds.", $COLOR_DEBUG)
If $iCount > 30 Then ExitLoop
WEnd
If $iCount > 30 Then Setlog("End of Attack scene slow to appear, attack values my not be correct", $COLOR_BLUE)
$iCount = 0
While getResourcesLoot(333, 289 + $midOffsetY) = ""
$iCount += 1
If _Sleep($iDelayAttackReport1) Then Return
If $debugSetlog = 1 Then Setlog("Waiting Attack Report Ready, " & ($iCount / 2) & " Seconds.", $COLOR_DEBUG)
If $iCount > 20 Then ExitLoop
WEnd
If $iCount > 20 Then Setlog("End of Attack scene read gold error, attack values my not be correct", $COLOR_BLUE)
If _ColorCheck(_GetPixelColor($aAtkRprtDECheck[0], $aAtkRprtDECheck[1], True), Hex($aAtkRprtDECheck[2], 6), $aAtkRprtDECheck[3]) Then
$iGoldLast = getResourcesLoot(333, 289 + $midOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$iElixirLast = getResourcesLoot(333, 328 + $midOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$iDarkLast = getResourcesLootDE(365, 365 + $midOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$iTrophyLast = getResourcesLootT(403, 402 + $midOffsetY)
If _ColorCheck(_GetPixelColor($aAtkRprtTrophyCheck[0], $aAtkRprtTrophyCheck[1], True), Hex($aAtkRprtTrophyCheck[2], 6), $aAtkRprtTrophyCheck[3]) Then
$iTrophyLast = -$iTrophyLast
EndIf
SetLog("Loot: [G]: " & _NumberFormat($iGoldLast) & " [E]: " & _NumberFormat($iElixirLast) & " [DE]: " & _NumberFormat($iDarkLast) & " [T]: " & $iTrophyLast, $COLOR_GREEN)
Else
$iGoldLast = getResourcesLoot(333, 289 + $midOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$iElixirLast = getResourcesLoot(333, 328 + $midOffsetY)
If _Sleep($iDelayAttackReport2) Then Return
$iTrophyLast = getResourcesLootT(403, 365 + $midOffsetY)
If _ColorCheck(_GetPixelColor($aAtkRprtTrophyCheck[0], $aAtkRprtTrophyCheck[1], True), Hex($aAtkRprtTrophyCheck[2], 6), $aAtkRprtTrophyCheck[3]) Then
$iTrophyLast = -$iTrophyLast
EndIf
$iDarkLast = ""
SetLog("Loot: [G]: " & _NumberFormat($iGoldLast) & " [E]: " & _NumberFormat($iElixirLast) & " [T]: " & $iTrophyLast, $COLOR_GREEN)
EndIf
If $iTrophyLast >= 0 Then
$iBonusLast = Number(getResourcesBonusPerc(570, 309 + $midOffsetY))
If $iBonusLast > 0 Then
SetLog("Bonus Percentage: " & $iBonusLast & "%")
Local $iCalcMaxBonus = 0, $iCalcMaxBonusDark = 0
If _ColorCheck(_GetPixelColor($aAtkRprtDECheck2[0], $aAtkRprtDECheck2[1], True), Hex($aAtkRprtDECheck2[2], 6), $aAtkRprtDECheck2[3]) Then
If _Sleep($iDelayAttackReport2) Then Return
$iGoldLastBonus = getResourcesBonus(590, 340 + $midOffsetY)
$iGoldLastBonus = StringReplace($iGoldLastBonus, "+", "")
If _Sleep($iDelayAttackReport2) Then Return
$iElixirLastBonus = getResourcesBonus(590, 371 + $midOffsetY)
$iElixirLastBonus = StringReplace($iElixirLastBonus, "+", "")
If _Sleep($iDelayAttackReport2) Then Return
$iDarkLastBonus = getResourcesBonus(621, 402 + $midOffsetY)
$iDarkLastBonus = StringReplace($iDarkLastBonus, "+", "")
If $iBonusLast = 100 Then
$iCalcMaxBonus = $iGoldLastBonus
SetLog("Bonus [G]: " & _NumberFormat($iGoldLastBonus) & " [E]: " & _NumberFormat($iElixirLastBonus) & " [DE]: " & _NumberFormat($iDarkLastBonus), $COLOR_GREEN)
Else
$iCalcMaxBonus = Number($iGoldLastBonus / ($iBonusLast / 100))
$iCalcMaxBonusDark = Number($iDarkLastBonus / ($iBonusLast / 100))
SetLog("Bonus [G]: " & _NumberFormat($iGoldLastBonus) & " out of " & _NumberFormat($iCalcMaxBonus) & " [E]: " & _NumberFormat($iElixirLastBonus) & " out of " & _NumberFormat($iCalcMaxBonus) & " [DE]: " & _NumberFormat($iDarkLastBonus) & " out of " & _NumberFormat($iCalcMaxBonusDark), $COLOR_GREEN)
EndIf
Else
If _Sleep($iDelayAttackReport2) Then Return
$iGoldLastBonus = getResourcesBonus(590, 340 + $midOffsetY)
$iGoldLastBonus = StringReplace($iGoldLastBonus, "+", "")
If _Sleep($iDelayAttackReport2) Then Return
$iElixirLastBonus = getResourcesBonus(590, 371 + $midOffsetY)
$iElixirLastBonus = StringReplace($iElixirLastBonus, "+", "")
$iDarkLastBonus = 0
If $iBonusLast = 100 Then
$iCalcMaxBonus = $iGoldLastBonus
SetLog("Bonus [G]: " & _NumberFormat($iGoldLastBonus) & " [E]: " & _NumberFormat($iElixirLastBonus), $COLOR_GREEN)
Else
$iCalcMaxBonus = Number($iGoldLastBonus / ($iBonusLast / 100))
SetLog("Bonus [G]: " & _NumberFormat($iGoldLastBonus) & " out of " & _NumberFormat($iCalcMaxBonus) & " [E]: " & _NumberFormat($iElixirLastBonus) & " out of " & _NumberFormat($iCalcMaxBonus), $COLOR_GREEN)
EndIf
EndIf
$LeagueShort = "--"
For $i = 1 To 21
If _Sleep($iDelayAttackReport2) Then Return
If $League[$i][0] = $iCalcMaxBonus Then
SetLog("Your league level is: " & $League[$i][1])
$LeagueShort = $League[$i][3]
ExitLoop
EndIf
Next
Else
SetLog("No Bonus")
$LeagueShort = "--"
If $iTrophyCurrent + $iTrophyLast >= 400 And $iTrophyCurrent + $iTrophyLast < 500 Then
SetLog("Your league level is: " & $League[0][1])
$LeagueShort = $League[0][3]
EndIf
EndIf
GUICtrlSetData($lblLeague, "")
If StringInStr($LeagueShort, "1") > 1 Then
GUICtrlSetData($lblLeague, "1")
ElseIf StringInStr($LeagueShort, "2") > 1 Then
GUICtrlSetData($lblLeague, "2")
ElseIf StringInStr($LeagueShort, "3") > 1 Then
GUICtrlSetData($lblLeague, "3")
EndIf
_GUI_Value_STATE("HIDE", $groupLeague)
If StringInStr($LeagueShort, "B") > 0 Then
GUICtrlSetState($BronzeLeague, $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "S") > 0 Then
GUICtrlSetState($SilverLeague, $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "G") > 0 Then
GUICtrlSetState($GoldLeague, $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "c", $STR_CASESENSE) > 0 Then
GUICtrlSetState($CrystalLeague, $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "M") > 0 Then
GUICtrlSetState($MasterLeague, $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "C", $STR_CASESENSE) > 0 Then
GUICtrlSetState($ChampionLeague, $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "T") > 0 Then
GUICtrlSetState($TitanLeague, $GUI_SHOW)
ElseIf StringInStr($LeagueShort, "LE") > 0 Then
GUICtrlSetState($LegendLeague, $GUI_SHOW)
Else
GUICtrlSetState($UnrankedLeague, $GUI_SHOW)
EndIf
Else
$iGoldLastBonus = 0
$iElixirLastBonus = 0
$iDarkLastBonus = 0
$LeagueShort = "--"
EndIf
Local $starsearned = 0
If _ColorCheck(_GetPixelColor($aWonOneStarAtkRprt[0], $aWonOneStarAtkRprt[1], True), Hex($aWonOneStarAtkRprt[2], 6), $aWonOneStarAtkRprt[3]) Then $starsearned += 1
If _ColorCheck(_GetPixelColor($aWonTwoStarAtkRprt[0], $aWonTwoStarAtkRprt[1], True), Hex($aWonTwoStarAtkRprt[2], 6), $aWonTwoStarAtkRprt[3]) Then $starsearned += 1
If _ColorCheck(_GetPixelColor($aWonThreeStarAtkRprt[0], $aWonThreeStarAtkRprt[1], True), Hex($aWonThreeStarAtkRprt[2], 6), $aWonThreeStarAtkRprt[3]) Then $starsearned += 1
SetLog("Stars earned: " & $starsearned)
Local $AtkLogTxt
$AtkLogTxt = "" & _NowTime(4) & "|"
$AtkLogTxt &= StringFormat("%5d", $iTrophyCurrent) & "|"
$AtkLogTxt &= StringFormat("%6d", $SearchCount) & "|"
$AtkLogTxt &= StringFormat("%7d", $iGoldLast) & "|"
$AtkLogTxt &= StringFormat("%7d", $iElixirLast) & "|"
$AtkLogTxt &= StringFormat("%7d", $iDarkLast) & "|"
$AtkLogTxt &= StringFormat("%3d", $iTrophyLast) & "|"
$AtkLogTxt &= StringFormat("%1d", $starsearned) & "|"
$AtkLogTxt &= StringFormat("%6d", $iGoldLastBonus) & "|"
$AtkLogTxt &= StringFormat("%6d", $iElixirLastBonus) & "|"
$AtkLogTxt &= StringFormat("%4d", $iDarkLastBonus) & "|"
$AtkLogTxt &= $LeagueShort & "|"
Local $AtkLogTxtExtend
$AtkLogTxtExtend = "|"
$AtkLogTxtExtend &= $CurCamp & "/" & $TotalCamp & "|"
If Int($iTrophyLast) >= 0 Then
SetAtkLog($AtkLogTxt, $AtkLogTxtExtend, $COLOR_BLACK)
Else
SetAtkLog($AtkLogTxt, $AtkLogTxtExtend, $COLOR_RED)
EndIf
If $iShareAttack = 1 Then
If (Number($iGoldLast) >= Number($iShareminGold)) And (Number($iElixirLast) >= Number($iShareminElixir)) And (Number($iDarkLast) >= Number($iSharemindark)) Then
SetLog("Reached miminum Loot values... Share Replay")
$iShareAttackNow = 1
Else
SetLog("Below miminum Loot values... No Share Replay")
$iShareAttackNow = 0
EndIf
EndIf
If $FirstAttack = 0 Then $FirstAttack = 1
$iGoldTotal += $iGoldLast + $iGoldLastBonus
$iTotalGoldGain[$iMatchMode] += $iGoldLast + $iGoldLastBonus
$iElixirTotal += $iElixirLast + $iElixirLastBonus
$iTotalElixirGain[$iMatchMode] += $iElixirLast + $iElixirLastBonus
If $iDarkStart <> "" Then
$iDarkTotal += $iDarkLast + $iDarkLastBonus
$iTotalDarkGain[$iMatchMode] += $iDarkLast + $iDarkLastBonus
EndIf
$iTrophyTotal += $iTrophyLast
$iTotalTrophyGain[$iMatchMode] += $iTrophyLast
If $iMatchMode = $TS Then
If $starsearned > 0 Then
$iNbrOfTHSnipeSuccess += 1
Else
$iNbrOfTHSnipeFails += 1
EndIf
EndIf
$iAttackedVillageCount[$iMatchMode] += 1
UpdateStats()
If $iAttackedCount = 1 Then
ChartAddDataPoint1hr("Rate",True)
ChartAddDataPoint1hr("Attack",True)
Else
ChartAddDataPoint1hr("Rate",False)
ChartAddDataPoint1hr("Attack",False)
EndIf
EndFunc
Func GetBuildingEdge($TypeBuilding = $eSideBuildingDES)
Local $TypeBuildingName
BuildingXY($TypeBuilding)
Switch $TypeBuilding
Case $eSideBuildingDES
$TypeBuildingName = "DE Storage"
Case $eSideBuildingTH
$TypeBuildingName = "TownHall"
EndSwitch
If $BuildingLoc = 1 Then
If ($BuildingLocx = 430) And ($BuildingLocy = 313) Then
SetLog($TypeBuildingName & " Located in Middle... Attacking Random Side", $COLOR_BLUE)
$BuildingEdge = (Random(Round(0, 3)))
ElseIf ($BuildingLocx >= 430) And ($BuildingLocy >= 313) Then
SetLog($TypeBuildingName & " Located Bottom Right... Attacking Bottom Right", $COLOR_BLUE)
$BuildingEdge = 0
ElseIf ($BuildingLocx > 430) And ($BuildingLocy < 313) Then
SetLog($TypeBuildingName & " Located Top Right... Attacking Top Right", $COLOR_BLUE)
$BuildingEdge = 3
ElseIf ($BuildingLocx <= 430) And ($BuildingLocy <= 313) Then
SetLog($TypeBuildingName & " Located Top Left... Attacking Top Left", $COLOR_BLUE)
$BuildingEdge = 1
ElseIf ($BuildingLocx < 430) And ($BuildingLocy > 313) Then
SetLog($TypeBuildingName & " Located Bottom Left... Attacking Bottom Left", $COLOR_BLUE)
$BuildingEdge = 2
EndIf
ElseIf $BuildingLoc = 0 Then
SetLog($TypeBuildingName & " Not Located... Attacking Random Side", $COLOR_BLUE)
$BuildingEdge = (Random(Round(0, 3)))
EndIf
EndFunc
Func BuildingXY($TypeBuilding = $eSideBuildingDES)
Local $TypeBuildingName
_CaptureRegion2(230, 170, 630, 440)
Switch $TypeBuilding
Case $eSideBuildingDES
$TypeBuildingName = "DE Storage"
$BuildingToLoc = GetLocationDarkElixirStorage()
Case $eSideBuildingTH
$TypeBuildingName = "TownHall"
$BuildingToLoc = GetLocationTownHall()
EndSwitch
If (UBound($BuildingToLoc) > 1) Then
Local $centerPixel[2] = [430, 313]
Local $arrPixelCloser = _FindPixelCloser($BuildingToLoc, $centerPixel, 1)
$pixel = $arrPixelCloser[0]
ElseIf (UBound($BuildingToLoc) > 0) Then
$pixel = $BuildingToLoc[0]
Else
$pixel = -1
EndIf
If $pixel = -1 Then
$BuildingLoc = 0
SetLog(" == " & $TypeBuildingName & " Not Found ==")
Else
$pixel[0] += 230
$pixel[1] += 170
SetLog("== " & $TypeBuildingName & " : [" & $pixel[0] & "," & $pixel[1] & "] ==", $COLOR_BLUE)
If _Sleep(1000) Then Return False
$BuildingLocx = $pixel[0]
$BuildingLocy = $pixel[1]
$BuildingLoc = 1
EndIf
EndFunc
Func DELow()
Local $DarkE = ""
Local $Dchk = 0
While $DarkE = ""
$DarkE = getDarkElixirVillageSearch(48, 125)
$Dchk += 1
If _Sleep(50) Then Return
If $Dchk >= 10 Then
SetLog("Can't find De", $COLOR_RED)
Return False
EndIf
WEnd
If Number($DarkE) < (Number($searchDark) * (Number($DELowEndMin) / 100)) Then
If _Sleep(50) Then Return
$DarkE = getDarkElixirVillageSearch(48, 125)
If _Sleep(50) Then Return
If Number($DarkE) < (Number($searchDark) * (Number($DELowEndMin) / 100)) Then
If $DEEndAq And $dropQueen And $checkQPower = False Then
If $iActivateKQCondition = "Auto" Then
$DarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and AQ health Low. Return to protect Royals.  Returning immediately", $COLOR_GREEN)
Return False
ElseIf Not _ColorCheck(_GetPixelColor(68 + (72 * $Queen), 572, True), Hex(0x72F50B, 6), 120, "Heroes") Then
$DarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and AQ health Low. Return to protect Royals.  Returning immediately", $COLOR_GREEN)
Return False
EndIf
EndIf
If $DEEndBk And $dropKing And $checkKPower = False Then
If $iActivateKQCondition = "Auto" Then
$DarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and BK health Low. Return to protect Royals.  Returning immediately", $COLOR_GREEN)
Return False
ElseIf Not _ColorCheck(_GetPixelColor(68 + (72 * $King), 572, True), Hex(0x4FD404, 6), 120, "Heroes") Then
$DarkLow = 1
SetLog("Low De. De = ( " & $DarkE & " ) and BK health Low. Return to protect Royals.  Returning immediately", $COLOR_GREEN)
Return False
EndIf
EndIf
If $DEEndOneStar Then
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) Then
SetLog("Low De. De = ( " & $DarkE & " ) and 1 star achieved. Return to protect Royals.  Returning immediately", $COLOR_GREEN)
$DarkLow = 1
Return False
Else
SetLog("Low De. ( " & $DarkE & " ) Waiting for 1 star", $COLOR_GREEN)
$DarkLow = 2
Return False
EndIf
EndIf
If $DEEndAq = 0 And $DEEndBk = 0 And $DEEndOneStar = 0 Then
SetLog("Low De. De = ( " & $DarkE & " ). Return to protect Royals.  Returning immediately", $COLOR_GREEN)
Return False
EndIf
EndIf
Else
$DarkLow = 0
EndIf
EndFunc
Func SaveandDisableEBO()
$saveichkEndOneStar[$iMatchMode] = $ichkEndOneStar[$iMatchMode]
$saveichkEndTwoStars[$iMatchMode] = $ichkEndTwoStars[$iMatchMode]
$saveichkTimeStopAtk[$iMatchMode] = $ichkTimeStopAtk[$iMatchMode]
$saveiChkTimeStopAtk2[$iMatchMode] = $iChkTimeStopAtk2[$iMatchMode]
$ichkEndOneStar[$iMatchMode] = 0
$ichkEndTwoStars[$iMatchMode] = 0
$ichkTimeStopAtk[$iMatchMode] = 0
$iChkTimeStopAtk2[$iMatchMode] = 0
EndFunc
Func RevertEBO()
$ichkEndOneStar[$iMatchMode] = $saveichkEndOneStar
$ichkEndTwoStars[$iMatchMode] = $saveichkEndTwoStars
$ichkTimeStopAtk[$iMatchMode] = $saveichkTimeStopAtk
$iChkTimeStopAtk2[$iMatchMode] = $saveiChkTimeStopAtk2
EndFunc
Func GoldElixirChange()
Local $Gold1, $Gold2
Local $GoldChange, $ElixirChange
Local $Elixir1, $Elixir2
SetLog("Checking if the battle has finished", $COLOR_BLUE)
While 1
$Gold1 = getGoldVillageSearch(48, 69)
$Elixir1 = getElixirVillageSearch(48, 69 + 29)
If $ichkSmartZap = 0 Then
Local $iBegin = TimerInit(), $x = $sTimeStopAtk * 1000
Else
Local $iBegin = TimerInit(), $x = $sMinTimeCloseATK * 1000
EndIf
While TimerDiff($iBegin) < $x
CheckHeroesHealth()
If $checkKPower Or $checkQPower Then
If _Sleep($iDelayGoldElixirChange1) Then Return
Else
If _Sleep($iDelayGoldElixirChange2) Then Return
EndIf
$Gold2 = getGoldVillageSearch(48, 69)
If $Gold2 = "" Then
If _Sleep($iDelayGoldElixirChange1) Then Return
$Gold2 = getGoldVillageSearch(48, 69)
EndIf
$Elixir2 = getElixirVillageSearch(48, 69 + 29)
If $Gold2 <> "" Or $Elixir2 <> "" Then
$GoldChange = $Gold2
$ElixirChange = $Elixir2
EndIf
If ($Gold2 = "" And $Elixir2 = "") Then
If _Sleep($iDelayGoldElixirChange1) Then Return
If getGoldVillageSearch(48, 69) = "" And getElixirVillageSearch(48, 69 + 29) = "" Then
SetLog("Battle has finished", $COLOR_GREEN)
ExitLoop
EndIf
EndIf
WEnd
If ($Gold1 = $Gold2 And $Elixir1 = $Elixir2) Or ($Gold2 = "" And $Elixir2 = "") Then
GUICtrlSetData($lblresultvillagesattacked, GUICtrlRead($lblresultvillagesattacked) + 1)
GUICtrlSetData($lblResultAttackedHourNow, GUICtrlRead($lblResultAttackedHourNow) + 1)
Return False
Else
SetLog("Gold & Elixir change detected, waiting...", $COLOR_GREEN)
Return True
EndIf
ExitLoop
WEnd
EndFunc
Func GoldElixirChangeThSnipes($x)
Local $Gold1, $Gold2
Local $GoldChange, $ElixirChange
Local $Elixir1, $Elixir2
SetLog("Checking if the Gold6Elixir are changing...", $COLOR_BLUE)
For $y = 0 To $x
$Gold1 = getGoldVillageSearch(48, 69)
$Elixir1 = getElixirVillageSearch(48, 69 + 29)
Local $iBegin = TimerInit()
While TimerDiff($iBegin) < 2000
CheckHeroesHealth()
If $checkKPower Or $checkQPower Then
If _Sleep($iDelayGoldElixirChange1) Then Return
Else
If _Sleep($iDelayGoldElixirChange2) Then Return
EndIf
$Gold2 = getGoldVillageSearch(48, 69)
If $Gold2 = "" Then
If _Sleep($iDelayGoldElixirChange1) Then Return
$Gold2 = getGoldVillageSearch(48, 69)
EndIf
$Elixir2 = getElixirVillageSearch(48, 69 + 29)
If $Gold2 <> "" Or $Elixir2 <> "" Then
$GoldChange = $Gold2
$ElixirChange = $Elixir2
EndIf
If ($Gold2 = "" And $Elixir2 = "") Then
If _Sleep($iDelayGoldElixirChange1) Then Return
If getGoldVillageSearch(48, 69) = "" And getElixirVillageSearch(48, 69 + 29) = "" Then
SetLog("Battle has finished", $COLOR_GREEN)
Return True
ExitLoop
EndIf
EndIf
WEnd
If ($Gold1 = $Gold2 And $Elixir1 = $Elixir2) Or ($Gold2 = "" And $Elixir2 = "") Then
ExitLoop
Else
SetLog("Gold & Elixir change detected, waiting...", $COLOR_GREEN)
ContinueLoop
EndIf
$x += 1
If Sleep(1000) Then Return
Return False
Next
EndFunc
Func GoldElixirChangeEBO()
Local $Gold1, $Gold2
Local $GoldChange, $ElixirChange
Local $Elixir1, $Elixir2
Local $DarkElixir1, $DarkElixir2
Local $DarkElixirChange
Local $Trophies
Local $txtDiff
Local $exitOneStar = 0, $exitTwoStars = 0
$DarkLow = 0
$Gold1 = getGoldVillageSearch(48, 69)
$Elixir1 = getElixirVillageSearch(48, 69 + 29)
$Trophies = getTrophyVillageSearch(48, 69 + 99)
If $Trophies <> "" Then
If _Sleep($iDelayGoldElixirChangeEBO1) Then Return
$DarkElixir1 = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir1 = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
If $ichkSmartZap = 0 Then
Local $iBegin = TimerInit(), $x = $sTimeStopAtk[$iMatchMode] * 1000, $y = $sTimeStopAtk2[$iMatchMode] * 1000, $z
Else
Local $iBegin = TimerInit(), $x = $sMinTimeCloseATK * 1000, $y = $sTimeStopAtk2[$iMatchMode] * 1000, $z
EndIf
If Number($Gold1) < Number($stxtMinGoldStopAtk2[$iMatchMode]) And Number($Elixir1) < Number($stxtMinElixirStopAtk2[$iMatchMode]) And Number($DarkElixir1) < Number($stxtMinDarkElixirStopAtk2[$iMatchMode]) And $iChkTimeStopAtk2[$iMatchMode] = 1 Then
$z = $y
Else
If $ichkTimeStopAtk[$iMatchMode] = 1 Or $ichkSmartZap = 1 Then
$z = $x
Else
$z = 60 * 3 * 1000
EndIf
EndIf
If $ichkEndTwoStars[$iMatchMode] = 1 And _CheckPixel($aWonTwoStar, True) Then
SetLog("Two Star Reach, exit", $COLOR_GREEN)
$exitTwoStars = 1
$z = 0
EndIf
If $ichkEndOneStar[$iMatchMode] = 1 And _CheckPixel($aWonOneStar, True) Then
SetLog("One Star Reach, exit", $COLOR_GREEN)
$exitOneStar = 1
$z = 0
EndIf
While TimerDiff($iBegin) < $z
CheckHeroesHealth()
If $iMatchMode = $LB And $iChkDeploySettings[$LB] = 4 And $DESideEB Then
If $dropQueen Or $dropKing Then DELow()
If $DarkLow = 1 Then ExitLoop
EndIf
If $checkKPower Or $checkQPower Or $DarkLow = 2 Then
If _Sleep($iDelayGoldElixirChangeEBO1) Then Return
Else
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
EndIf
$Gold2 = getGoldVillageSearch(48, 69)
If $Gold2 = "" Then
If _Sleep($iDelayGoldElixirChangeEBO1) Then Return
$Gold2 = getGoldVillageSearch(48, 69)
EndIf
$Elixir2 = getElixirVillageSearch(48, 69 + 29)
$Trophies = getTrophyVillageSearch(48, 69 + 99)
If $Trophies <> "" Then
If _Sleep($iDelayGoldElixirChangeEBO1) Then Return
$DarkElixir2 = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir2 = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
$txtDiff = Round(($z - TimerDiff($iBegin)) / 1000, 1)
If Number($txtDiff) < 0 Then $txtDiff = 0
If $Gold2 = "" And $Elixir2 = "" And $DarkElixir2 = "" Then
SetLog("detected [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " |  Exit now ", $COLOR_BLUE)
Else
SetLog("detected [G]: " & $Gold2 & " [E]: " & $Elixir2 & " [DE]: " & $DarkElixir2 & " |  Exit in " & StringReplace(StringFormat("%2i", $txtDiff), "-", "") & " sec.", $COLOR_BLUE)
OverallDamage(50,True)
EndIf
If $Gold2 <> "" Or $Elixir2 <> "" Or $DarkElixir2 <> "" Then
$GoldChange = $Gold2
$ElixirChange = $Elixir2
$DarkElixirChange = $DarkElixir2
EndIf
If $ichkEndNoResources[$iMatchMode] = 1 And Number($Gold2) = 0 And Number($Elixir2) = 0 And Number($DarkElixir2) = 0 Then
SetLog("Gold & Elixir & DE = 0, end battle ", $COLOR_GREEN)
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
ExitLoop
EndIf
If $ichkEndTwoStars[$iMatchMode] = 1 And _CheckPixel($aWonTwoStar, True) Then
SetLog("Two Star Reach, exit", $COLOR_GREEN)
$exitTwoStars = 1
ExitLoop
EndIf
If $ichkEndOneStar[$iMatchMode] = 1 And _CheckPixel($aWonOneStar, True) Then
SetLog("One Star Reach, exit", $COLOR_GREEN)
$exitOneStar = 1
ExitLoop
EndIf
If getGoldVillageSearch(48, 69) = "" And getElixirVillageSearch(48, 69 + 29) = "" And $DarkElixir2 = "" Then
ExitLoop
EndIf
If ($Gold1 <> $Gold2 Or $Elixir1 <> $Elixir2 Or $DarkElixir1 <> $DarkElixir2) Then
ExitLoop
EndIf
WEnd
If $iMatchMode = $LB And $iChkDeploySettings[$LB] = 4 And $DESideEB And $DarkLow = 1 Then
SetLog("Returning Now -DE-", $COLOR_GREEN)
Return False
EndIf
If $ichkEndOneStar[$iMatchMode] = 1 And $exitOneStar = 1 Then
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
Return False
EndIf
If $ichkEndTwoStars[$iMatchMode] = 1 And $exitTwoStars = 1 Then
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
Return False
EndIf
If ($Gold2 = "" And $Elixir2 = "" And $DarkElixir2 = "") Then
SetLog("Battle has finished", $COLOR_GREEN)
Return False
EndIf
If $ichkEndNoResources[$iMatchMode] = 1 And Number($Gold2) = 0 And Number($Elixir2) = 0 And Number($DarkElixir2) = 0 Then
SetLog("Gold & Elixir & DE = 0, end battle ", $COLOR_GREEN)
If _Sleep($iDelayGoldElixirChangeEBO2) Then Return
Return False
EndIf
If (Number($Gold1) = Number($Gold2) And Number($Elixir1) = Number($Elixir2) And Number($DarkElixir1) = Number($DarkElixir2)) Then
SetLog("Gold & Elixir & DE no change detected, exit", $COLOR_GREEN)
Return False
Else
If $debugsetlog = 1 Then
Setlog("Gold1: " & Number($Gold1) & "  Gold2: " & Number($Gold2), $COLOR_DEBUG)
Setlog("Elixir1: " & Number($Elixir1) & "  Elixir2: " & Number($Elixir2), $COLOR_DEBUG)
Setlog("Dark Elixir1: " & Number($DarkElixir1) & "  Dark Elixir2: " & Number($DarkElixir2), $COLOR_DEBUG)
EndIf
SetLog("Gold & Elixir & DE change detected, waiting...", $COLOR_GREEN)
Return True
EndIf
EndFunc
Func OverallDamage($OverallDamage = 30, $SetLog = True)
Local $Damage = Number(getOcrOverAllDamage(780, 527 + $bottomOffsetY))
If $SetLog = True Then
SetLog("Overall Damage: " & $Damage & "%")
EndIf
If $Damage >= $OverallDamage Then
Return True
Else
Return False
EndIf
EndFunc
Func PrepareAttack($pMatchMode, $Remaining = False)
Local $troopsnumber = 0
If $debugSetlog = 1 Then SetLog("PrepareAttack for " & $pMatchMode & " " & $sModeText[$pMatchMode], $COLOR_DEBUG)
If $Remaining Then
SetLog("Checking remaining unused troops for: " & $sModeText[$pMatchMode], $COLOR_BLUE)
Else
SetLog("Initiating attack for: " & $sModeText[$pMatchMode], $COLOR_RED)
EndIf
_CaptureRegion2(0, 571 + $bottomOffsetY, 859, 671 + $bottomOffsetY)
If _Sleep($iDelayPrepareAttack1) Then Return
Local $Plural = 0
Local $result = AttackBarCheck()
If $debugSetlog = 1 Then Setlog("DLL Troopsbar list: " & $result, $COLOR_DEBUG)
Local $aTroopDataList = StringSplit($result, "|")
Local $aTemp[12][3]
If $result <> "" Then
For $i = 1 To $aTroopDataList[0]
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
$aTemp[Number($troopData[1])][0] = $troopData[0]
$aTemp[Number($troopData[1])][1] = Number($troopData[2])
$aTemp[Number($troopData[1])][2] = Number($troopData[1])
Next
EndIf
For $i = 0 To UBound($aTemp) - 1
If $aTemp[$i][0] = "" And $aTemp[$i][1] = "" Then
$atkTroops[$i][0] = -1
$atkTroops[$i][1] = 0
Else
$troopKind = $aTemp[$i][0]
If $troopKind < $eKing Then
If Not IsTroopToBeUsed($pMatchMode, $troopKind) Then
If $debugSetlog = 1 Then Setlog("Discard use of troop " & $troopKind &  " " & NameOfTroop($troopKind), $COLOR_DEBUG)
$atkTroops[$i][0] = -1
$troopKind = -1
Else
$atkTroops[$i][0] = $aTemp[$i][0]
$atkTroops[$i][1] = $aTemp[$i][1]
$troopKind = $aTemp[$i][1]
$troopsnumber +=  $aTemp[$i][1]
EndIf
Else
$atkTroops[$i][0] = $troopKind
If IsSpecialTroopToBeUsed($pMatchMode, $TroopKind) then
$troopsnumber += 1
$atkTroops[$i][0] = $aTemp[$i][0]
$troopKind = $aTemp[$i][1]
$troopsnumber +=  1
Else
If $debugSetlog = 1 Then Setlog("Discard use hero/poison " & $troopKind &  " " & NameOfTroop($troopKind), $COLOR_DEBUG)
$troopKind = -1
EndIf
EndIf
$Plural = 0
If $aTemp[$i][1] > 1 then $Plural = 1
If $troopKind <> -1 Then SetLog($aTemp[$i][2] & " Â» " & $aTemp[$i][1] & " " & NameOfTroop($atkTroops[$i][0], $Plural), $COLOR_GREEN)
EndIf
Next
If $debugSetLog=1 Then Setlog("troopsnumber  = " & $troopsnumber)
Return $troopsnumber
EndFunc
Func IsTroopToBeUsed($pMatchMode, $pTroopType)
If $pMatchMode = $DT Or $pMatchMode = $TB  Then Return True
If $pMatchMode = $MA Then
Local $tempArr = $troopsToBeUsed[$iCmbSelectTroop[$DB]]
Else
Local $tempArr = $troopsToBeUsed[$iCmbSelectTroop[$pMatchMode]]
EndIf
For $x = 0 To UBound($tempArr) - 1
If $tempArr[$x] = $pTroopType Then
If $pMatchMode =$MA and $pTroopType = $eGobl Then
Return False
Else
Return True
EndIf
EndIf
Next
Return False
EndFunc
Func IsSpecialTroopToBeUsed($pMatchMode, $pTroopType)
If $pmatchMode <> $DB and $pmatchMode <> $LB and $pmatchMode <> $TS and $pmatchMode <> $MA Then
Return True
Else
Switch $pTroopType
Case $eKing
Switch $pmatchMode
Case $DB
If BitAND($iHeroAttack[$DB], $HERO_KING) = $HERO_KING Then Return True
Case $LB
If BitAND($iHeroAttack[$LB], $HERO_KING) = $HERO_KING Then Return True
Case $TS
If BitAND($iHeroAttack[$TS], $HERO_KING) = $HERO_KING Then Return True
Case $MA
If BitAND($iHeroAttack[$DB], $HERO_KING) = $HERO_KING Then Return True
EndSwitch
Case $eQueen
Switch $pmatchMode
Case $DB
If BitAND($iHeroAttack[$DB], $HERO_QUEEN) = $HERO_QUEEN Then Return True
Case $LB
If BitAND($iHeroAttack[$LB], $HERO_QUEEN) = $HERO_QUEEN Then Return True
Case $TS
If BitAND($iHeroAttack[$TS], $HERO_QUEEN) = $HERO_QUEEN Then Return True
Case $MA
If BitAND($iHeroAttack[$DB], $HERO_QUEEN) = $HERO_QUEEN Then Return True
EndSwitch
case $eWarden
Switch $pmatchMode
Case $DB
If BitAND($iHeroAttack[$DB], $HERO_WARDEN) = $HERO_WARDEN Then Return True
Case $LB
If BitAND($iHeroAttack[$LB], $HERO_WARDEN) = $HERO_WARDEN Then Return True
Case $TS
If BitAND($iHeroAttack[$TS], $HERO_WARDEN) = $HERO_WARDEN Then Return True
Case $MA
If BitAND($iHeroAttack[$DB], $HERO_WARDEN) = $HERO_WARDEN Then Return True
EndSwitch
Case $eCastle
Switch $pmatchMode
Case $DB
If $iDropCC[$DB] = 1 Then Return True
Case $LB
If $iDropCC[$LB] = 1 Then Return True
Case $TS
If $iDropCC[$TS] = 1 Then Return True
Case $MA
If $iDropCC[$DB] = 1 Then Return True
EndSwitch
Case  $eLSpell
Switch $pmatchMode
Case $DB
If $ichkLightSpell[$DB] = 1 Or $ichkSmartZap = 1 Then Return True
Case $LB
If $ichkLightSpell[$LB] = 1 Or $ichkSmartZap = 1 Then Return True
Case $TS
If $ichkLightSpell[$TS] = 1 Or $ichkSmartZap = 1 Then Return True
Case $MA
If $ichkLightSpell[$DB] = 1 Or $ichkSmartZap = 1 Then Return True
EndSwitch
Case  $eHSpell
Switch $pmatchMode
Case $DB
If $ichkHealSpell[$DB] = 1 Then Return True
Case $LB
If $ichkHealSpell[$LB] = 1 Then Return True
Case $TS
If $ichkHealSpell[$TS] = 1 Then Return True
Case $MA
If $ichkHealSpell[$DB] = 1 Then Return True
EndSwitch
Case  $eRSpell
Switch $pmatchMode
Case $DB
If $ichkRageSpell[$DB] = 1 Then Return True
Case $LB
If $ichkRageSpell[$LB] = 1 Then Return True
Case $TS
If $ichkRageSpell[$TS] = 1 Then Return True
Case $MA
If $ichkRageSpell[$DB] = 1 Then Return True
EndSwitch
Case  $eJSpell
Switch $pmatchMode
Case $DB
If $ichkJumpSpell[$DB] = 1 Then Return True
Case $LB
If $ichkJumpSpell[$LB] = 1 Then Return True
Case $TS
If $ichkJumpSpell[$TS] = 1 Then Return True
Case $MA
If $ichkJumpSpell[$DB] = 1 Then Return True
EndSwitch
Case  $eFSpell
Switch $pmatchMode
Case $DB
If $ichkFreezeSpell[$DB] = 1 Then Return True
Case $LB
If $ichkFreezeSpell[$LB] = 1 Then Return True
Case $TS
If $ichkFreezeSpell[$TS] = 1 Then Return True
Case $MA
If $ichkFreezeSpell[$DB] = 1 Then Return True
EndSwitch
Case  $ePSpell
Switch $pmatchMode
Case $DB
If $ichkPoisonSpell[$DB]  = 1 Then Return True
Case $LB
If $ichkPoisonSpell[$LB] = 1 Then Return True
Case $TS
If $ichkPoisonSpell[$TS] = 1 Then Return True
Case $MA
If $ichkPoisonSpell[$DB] = 1 Then Return True
EndSwitch
Case  $eESpell
Switch $pmatchMode
Case $DB
If $ichkEarthquakeSpell[$DB] = 1 Then Return True
Case $LB
If $ichkEarthquakeSpell[$LB] = 1 Then Return True
Case $TS
If $ichkEarthquakeSpell[$TS] = 1 Then Return True
Case $MA
If $ichkEarthquakeSpell[$DB] = 1 Then Return True
EndSwitch
Case  $eHaSpell
Switch $pmatchMode
Case $DB
If $ichkHasteSpell[$DB] = 1 Then Return True
Case $LB
If $ichkHasteSpell[$LB] = 1 Then Return True
Case $TS
If $ichkHasteSpell[$TS] = 1 Then Return True
Case $MA
If $ichkHasteSpell[$DB] = 1 Then Return True
EndSwitch
Case Else
Return False
EndSwitch
Return False
EndIf
EndFunc
Func ReturnHome($TakeSS = 1, $GoldChangeCheck = True)
ResetRedLines()
If $DebugSetLog = 1 Then Setlog("ReturnHome function... (from matchmode=" & $iMatchMode & " - " & $sModeText[$iMatchMode] & ")", $COLOR_DEBUG)
Local $counter = 0
Local $hBitmap_Scaled
Local $i, $j
If $DisableOtherEBO And $iMatchMode = $LB And $iChkDeploySettings[$LB] = 4 And $DESideEB And ($dropQueen Or $dropKing) Then
SaveandDisableEBO()
SetLog("Disabling Normal End Battle Options", $COLOR_GREEN)
EndIf
If $GoldChangeCheck = True Then
If Not (IsReturnHomeBattlePage(True, False)) Then
SetLog("Checking if the battle has finished", $COLOR_BLUE)
While GoldElixirChangeEBO()
If _Sleep($iDelayReturnHome1) Then Return
WEnd
If IsAttackPage() Then smartZap()
If ($checkKPower = True Or $checkQPower = True) And $iActivateKQCondition = "Auto" Then
If _ColorCheck(_GetPixelColor($aRtnHomeCheck1[0], $aRtnHomeCheck1[1], True), Hex($aRtnHomeCheck1[2], 6), $aRtnHomeCheck1[3]) = False And _ColorCheck(_GetPixelColor($aRtnHomeCheck2[0], $aRtnHomeCheck2[1], True), Hex($aRtnHomeCheck2[2], 6), $aRtnHomeCheck2[3]) = False Then
If $checkKPower = True Then
SetLog("Activating King's power to restore some health before EndBattle", $COLOR_BLUE)
If IsAttackPage() Then SelectDropTroop($King)
EndIf
If $checkQPower = True Then
SetLog("Activating Queen's power to restore some health before EndBattle", $COLOR_BLUE)
If IsAttackPage() Then SelectDropTroop($Queen)
EndIf
EndIf
EndIf
Else
If $DebugSetLog = 1 Then Setlog("Battle already over", $COLOR_DEBUG)
EndIf
EndIf
If $DisableOtherEBO And $iMatchMode = $LB And $iChkDeploySettings[$LB] = 4 And $DESideEB And ($dropQueen Or $dropKing) Then
RevertEBO()
EndIf
$checkKPower = False
$checkQPower = False
$checkWPower = False
If $iTScheck = 1 And $iMatchMode = $TS Then $FirstStart = True
SetLog("Returning Home", $COLOR_BLUE)
If $RunState = False Then Return
If Not (IsReturnHomeBattlePage(True, False)) Then
$i = 0
While 1
If _CheckPixel($aSurrenderButton, $bCapturePixel) Then
If IsAttackPage() Then
ClickP($aSurrenderButton, 1, 0, "#0099")
$j = 0
While 1
If IsEndBattlePage(False) Then
ClickOkay("SurrenderOkay")
ExitLoop 2
Else
$j += 1
EndIf
If $j > 10 Then ExitLoop
If _Sleep($iDelayReturnHome5) Then Return
WEnd
Else
$i += 1
EndIf
Else
$i += 1
EndIf
If $i > 5 Then ExitLoop
If _Sleep($iDelayReturnHome5) Then Return
WEnd
Else
If $DebugSetLog = 1 Then Setlog("Battle already over.", $COLOR_DEBUG)
EndIf
If _Sleep($iDelayReturnHome2) Then Return
TrayTip($sBotTitle, "", BitOR($TIP_ICONASTERISK, $TIP_NOSOUND))
checkAndroidTimeLag(False)
If $GoldChangeCheck = True Then
If IsAttackPage() Then
$counter = 0
While _ColorCheck(_GetPixelColor($aRtnHomeCheck1[0], $aRtnHomeCheck1[1], True), Hex($aRtnHomeCheck1[2], 6), $aRtnHomeCheck1[3]) = False And _ColorCheck(_GetPixelColor($aRtnHomeCheck2[0], $aRtnHomeCheck2[1], True), Hex($aRtnHomeCheck2[2], 6), $aRtnHomeCheck2[3]) = False
If _Sleep($iDelayReturnHome2) Then ExitLoop
$counter += 1
If $counter > 40 Then ExitLoop
WEnd
EndIf
If _Sleep($iDelayReturnHome3) Then Return
_CaptureRegion()
AttackReport()
EndIf
If $TakeSS = 1 And $GoldChangeCheck = True Then
SetLog("Taking snapshot of your loot", $COLOR_GREEN)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion()
$hBitmap_Scaled = _GDIPlus_ImageResize($hBitmap, _GDIPlus_ImageGetWidth($hBitmap) / 2, _GDIPlus_ImageGetHeight($hBitmap) / 2)
If $ScreenshotLootInfo = 1 Then
$LootFileName = $Date & "_" & $Time & " G" & $iGoldLast & " E" & $iElixirLast & " DE" & $iDarkLast & " T" & $iTrophyLast & " S" & StringFormat("%3s", $SearchCount) & ".jpg"
Else
$LootFileName = $Date & "_" & $Time & ".jpg"
EndIf
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $dirLoots & $LootFileName)
_GDIPlus_ImageDispose($hBitmap_Scaled)
EndIf
If $GoldChangeCheck = True Then
PushMsg("LastRaid")
EndIf
$i = 0
While 1
If _CheckPixel($aEndFightSceneAvl, $bCapturePixel) Then
If IsReturnHomeBattlePage() Then ClickP($aReturnHomeButton, 1, 0, "#0101")
ExitLoop
Else
$i += 1
EndIf
If $i > 10 Then ExitLoop
If _Sleep($iDelayReturnHome5) Then Return
WEnd
If _Sleep($iDelayReturnHome2) Then Return
$counter = 0
While 1
If _Sleep($iDelayReturnHome4) Then Return
If StarBonus() = True Then Setlog("Star Bonus window closed chief!", $COLOR_BLUE)
If IsMainPage() Then
_GUICtrlEdit_SetText($txtLog, _PadStringCenter(" BOT LOG ", 71, "="))
_GUICtrlRichEdit_SetFont($txtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($txtLog, "" & @CRLF, _ColorConvert($Color_Black))
Return
EndIf
$counter += 1
If $counter >= 50 Or isProblemAffect(True) Then
SetLog("Cannot return home.", $COLOR_RED)
checkMainScreen()
Return
EndIf
WEnd
EndFunc
Func SnipeWhileTrain()
If $DebugSetLog = 1 Then Setlog("SnipeWhileTrain function ", $COLOR_DEBUG)
If $iChkSnipeWhileTrain = 1 And $CommandStop <> 0 And $CommandStop <> 3 Then
If ($CurCamp <= ($TotalCamp * $itxtminArmyCapacityTHSnipe / 100)) Then
SetLog("army Capacity below " & $itxtminArmyCapacityTHSnipe & "%, not enough for Snipe While Train")
Return False
EndIf
If $fullArmy = False And ($CurCamp / $TotalCamp >= ($itxtminArmyCapacityTHSnipe / 100)) = True Then
$tempSnipeWhileTrain[0] = $iChkMeetTrophy[$DB]
$tempSnipeWhileTrain[1] = $iChkMeetTrophy[$LB]
$tempSnipeWhileTrain[2] = $iMinTrophy[$DB]
$tempSnipeWhileTrain[3] = $iMinTrophy[$LB]
$tempSnipeWhileTrain[4] = $iChkMeetOne[$LB]
$tempSnipeWhileTrain[5] = $iChkMeetOne[$DB]
$tempSnipeWhileTrain[7] = $THaddtiles
$iChkMeetTrophy[$DB] = 1
$iChkMeetTrophy[$LB] = 1
$iMinTrophy[$DB] = 99
$iMinTrophy[$LB] = 99
$iChkMeetOne[$LB] = 0
$iChkMeetOne[$DB] = 0
$THaddtiles = $itxtSWTtiles
$SnipeChangedSettings = True
SetLog("***[Trying TH snipe while training army]***", 0x808000)
$isSnipeWhileTrain = True
$Is_ClientSyncError = False
AttackMain()
$Restart = False
$Is_ClientSyncError = False
$isSnipeWhileTrain = False
SetLog("***[End trying TH snipe while training army]***", 0x808000)
SWHTrainRevertNormal()
Return True
EndIf
EndIf
EndFunc
Func SWHTrainRevertNormal()
If $SnipeChangedSettings = True Then
$iChkMeetTrophy[$DB] = $tempSnipeWhileTrain[0]
$iChkMeetTrophy[$LB] = $tempSnipeWhileTrain[1]
$iMinTrophy[$DB] = $tempSnipeWhileTrain[2]
$iMinTrophy[$LB] = $tempSnipeWhileTrain[3]
$iChkMeetOne[$LB] = $tempSnipeWhileTrain[4]
$iChkMeetOne[$DB] = $tempSnipeWhileTrain[5]
$OptTrophyMode = $tempSnipeWhileTrain[6]
$THaddtiles = $tempSnipeWhileTrain[7]
$Is_ClientSyncError = False
EndIf
$SnipeChangedSettings = False
$isSnipeWhileTrain = False
EndFunc
Func SWHTSearchLimit($iSkipped)
If $isSnipeWhileTrain And $iSkipped >= Number($itxtSearchlimit) Then
Local $Wcount = 0
While Not (_CheckPixel($aSurrenderButton, $bCapturepixel))
$Wcount += 1
If $DebugSetLog = 1 Then setlog("wait surrender button " & $Wcount, $COLOR_DEBUG)
If $Wcount >= 50 Then ExitLoop
WEnd
If IsAttackPage() Then ClickP($aSurrenderButton, 1, 0, "#9999")
$Restart = True
Local $mCount
$mCcount = 0
While Not (_CheckPixel($aIsMain, $bCapturepixel))
If _Sleep($iDelaySearchLimit2) Then Return
$mCcount += 1
If $DebugSetLog = 1 Then setlog("Wait main screen " & $mCcount, $COLOR_DEBUG)
If $mCount >= 50 Then ExitLoop
WEnd
Return True
Else
Return False
EndIf
EndFunc
Func Unbreakable()
Local $x, $y, $i, $iTime, $iCount
Switch $iUnbreakableMode
Case 2
If (Number($iGoldCurrent) > Number($iUnBrkMaxGold)) And (Number($iElixirCurrent) > Number($iUnBrkMaxElixir)) And (Number($iDarkCurrent) > Number($iUnBrkMaxDark)) Then
SetLog(" ====== Unbreakable Mode restarted! ====== ", $COLOR_GREEN)
$iUnbreakableMode = 1
Else
SetLog(" = Unbreakable Mode Paused, Farming to Refill Storages =", $COLOR_BLUE)
Return False
EndIf
Case 1
SetLog(" ====== Unbreakable Mode enabled! ====== ", $COLOR_GREEN)
Case Else
SetLog(">>> Programmer Humor, You shouldn't ever see this message, RUN! <<<", $COLOR_DEBUG)
EndSwitch
Select
Case $iChkTrophyAtkDead = 1
If ($CurCamp <= ($TotalCamp * 70 / 100)) Then
SetLog("Oops, wait for 70% troops due attack dead base checked", $COLOR_RED)
Return True
EndIf
Case $iChkTrophyAtkDead = 0
If ($CurCamp <= ($TotalCamp * 20 / 100)) Then
SetLog("Oops, wait for 20% troops for use in trophy drop", $COLOR_RED)
Return True
EndIf
Case Else
SetLog("You should not see this, silly programmer made a mistake, RUN!", $COLOR_MAROON)
EndSelect
Local $sMissingLoot = ""
If ((Number($iGoldCurrent) - Number($iUnBrkMinGold)) < 0) Then
$sMissingLoot &= "Gold, "
EndIf
If ((Number($iElixirCurrent) - Number($iUnBrkMinElixir)) < 0) Then
$sMissingLoot &= "Elixir, "
EndIf
If ((Number($iDarkCurrent) - Number($iUnBrkMinDark)) < 0) Then
$sMissingLoot &= "Dark Elixir"
EndIf
If $sMissingLoot <> "" Then
SetLog("Oops, Out of " & $sMissingLoot & " - back to farming", $COLOR_RED)
$iUnbreakableMode = 2
Return False
EndIf
DropTrophy()
If _Sleep($iDelayUnbreakable2) Then Return True
ClickP($aAway, 1, $iDelayUnbreakable7, "#0112")
If _Sleep($iDelayUnbreakable1) Then Return True
If $Restart = True Then Return True
$iCount = 0
Local $iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If $debugSetlog = 1 Then Setlog("Trophy Count Read = " & $iTrophyCurrent, $COLOR_DEBUG)
While Number($iTrophyCurrent) > Number($itxtMaxTrophy)
If $debugSetlog = 1 Then Setlog("Drop Trophy Loop #" & $iCount + 1, $COLOR_DEBUG)
DropTrophy()
If _Sleep($iDelayUnbreakable2) Then Return
ClickP($aAway, 1, 0, "#0395")
If _Sleep($iDelayUnbreakable1) Then Return
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If ($iCount > 2) And (Number($iTrophyCurrent) > Number($itxtMaxTrophy)) Then
Setlog("Unable to drop trophy, trying again", $COLOR_RED)
If _Sleep(500) Then Return
Return True
EndIf
$iCount += 1
WEnd
If $Restart = True Then Return True
BreakPersonalShield()
If @error Then
If @extended <> "" Then Setlog("PersonalShield button problem: " & @extended, $COLOR_RED)
Return True
EndIf
ClickP($aAway, 2, $iDelayUnbreakable8, "#0115")
If _Sleep($iDelayUnbreakable1) Then Return True
If CheckObstacles() = True Then Setlog("Window clean required, but no problem for MyBot!", $COLOR_BLUE)
SetLog("Closing Clash Of Clans", $COLOR_BLUE)
$i = 0
While 1
AndroidBackButton()
If _Sleep($iDelayUnbreakable1) Then Return True
Local $offColors[3][3] = [[0x000000, 144, 0], [0xFFFFFF, 54, 17], [0xCBE870, 54, 10]]
Global $ButtonPixel = _MultiPixelSearch(438, 372 + $midOffsetY, 590, 404 + $midOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $debugSetlog = 1 Then Setlog("Exit btn chk-#1: " & _GetPixelColor(441, 374, True) & ", #2: " & _GetPixelColor(441 + 144, 374, True) & ", #3: " & _GetPixelColor(441 + 54, 374 + 17, True) & ", #4: " & _GetPixelColor(441 + 54, 374 + 10, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
ExitLoop
EndIf
If $i > 15 Then ExitLoop
$i += 1
WEnd
$iTime = Number($iUnbreakableWait)
If $iTime < 1 Then $iTime = 1
Local Const $iGracePeriodTime = 5
$iTime = ($iTime + $iGracePeriodTime) * 60 * 1000
WaitnOpenCoC($iTime, False)
$iCount = 0
While 1
If $debugSetlog = 1 Then Setlog("Under Attack Pixels = " & _GetPixelColor(841, 342 + $midOffsetY, True) & "/" & _GetPixelColor(842, 348 + $midOffsetY, True), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(841, 342 + $midOffsetY, True), Hex(0x711C0A, 6), 20) And _ColorCheck(_GetPixelColor(842, 348 + $midOffsetY, True), Hex(0x721C0E, 6), 20) Then
Setlog("Base is under attack, waiting 30 seocnds for end", $COLOR_BLUE)
Else
ExitLoop
EndIf
If _SleepStatus($iDelayUnbreakable6) Then Return True
If $iCount > 7 Then ExitLoop
$iCount += 1
WEnd
If _Sleep($iDelayUnbreakable4) Then Return True
Local $Message = _PixelSearch(20, 624, 105, 627, Hex(0xE1E3CB, 6), 15)
If IsArray($Message) Then
If $debugSetlog = 1 Then Setlog("Return Home Pixel = " & _GetPixelColor($Message[0], $Message[1], True) & ", Pos: " & $Message[0] & "/" & $Message[1], $COLOR_DEBUG)
PureClick(67, 602 + $bottomOffsetY, 1, 0, "#0138")
If _Sleep($iDelayUnbreakable3) Then Return True
EndIf
If _ColorCheck(_GetPixelColor(235, 209 + $midOffsetY, True), Hex(0x9E3826, 6), 20) And _ColorCheck(_GetPixelColor(242, 140 + $midOffsetY, True), Hex(0xFFFFFF, 6), 20) Then
If $debugSetlog = 1 Then Setlog("Village Attacked Pixels = " & _GetPixelColor(235, 209 + $midOffsetY, True) & "/" & _GetPixelColor(242, 140 + $midOffsetY, True), $COLOR_DEBUG)
PureClick(429, 493 + $midOffsetY, 1, 0, "#0132")
If _Sleep($iDelayUnbreakable3) Then Return True
EndIf
If CheckObstacles() = True Then
If _Sleep($iDelayUnbreakable3) Then Return
If CheckObstacles() = True Then CheckMainScreen(False)
Return
EndIf
ZoomOut()
If _Sleep($iDelayUnbreakable1) Then Return True
Return True
EndFunc
Func algorithm_AllTroops()
If $debugSetlog = 1 Then Setlog("algorithm_AllTroops", $COLOR_DEBUG)
SetSlotSpecialTroops()
If _Sleep($iDelayalgorithm_AllTroops1) Then Return
SmartAttackStrategy($iMatchMode)
If $searchTH = "-"  and  ($iMatchMode = $DB and $THSnipeBeforeDBEnable = 1 ) or ($iMatchMode = $LB and $THSnipeBeforeDBEnable = 1 ) Then townHallCheck(True)
If $iMatchMode = $TS or  ( ( ($iMatchMode = $DB and $THSnipeBeforeDBEnable = 1 ) or ($iMatchMode = $LB and $THSnipeBeforeDBEnable = 1 ) )  and   SearchTownHallLoc()  ) Then
SwitchAttackTHType()
If $zoomedin = True Then
ZoomOut()
$zoomedin = False
$zCount = 0
$sCount = 0
EndIf
EndIf
If $iMatchMode = $TS Then
If ($THusedKing = 1 Or $THusedQueen = 1) And ($ichkSmartZap = 1 And $ichkSmartZapSaveHeroes = 1) Then
SetLog("King and/or Queen dropped, close attack")
If $ichkSmartZap = 1 Then SetLog("Skipping SmartZap to protect your royals!", $COLOR_FUCHSIA)
ElseIf IsAttackPage() And Not SmartZap() And $THusedKing = 0 And $THusedQueen = 0 Then
Setlog("Wait few sec before close attack")
If _Sleep(Random(0, 2, 1) * 1000) Then Return
EndIf
If CompareResources($DB) And $iAtkAlgorithm[$DB] = 0 And $ichkTSActivateCamps2 = 1 And Int($CurCamp / $TotalCamp * 100) >= Int($iEnableAfterArmyCamps2) then
$iMatchMode = $DB
Else
CloseBattle()
Return
EndIf
EndIf
Local $nbSides = 0
Switch $iChkDeploySettings[$iMatchMode]
Case 0
SetLog("Attacking on a single side", $COLOR_BLUE)
$nbSides = 1
Case 1
SetLog("Attacking on two sides", $COLOR_BLUE)
$nbSides = 2
Case 2
SetLog("Attacking on three sides", $COLOR_BLUE)
$nbSides = 3
Case 3
SetLog("Attacking on all sides", $COLOR_BLUE)
$nbSides = 4
Case 4
SetLog("Attacking on Dark Elixir Side.", $COLOR_BLUE)
$nbSides = 1
If Not ($iChkRedArea[$iMatchMode]) Then GetBuildingEdge($eSideBuildingDES)
Case 5
SetLog("Attacking on Town Hall Side.", $COLOR_BLUE)
$nbSides = 1
If Not ($iChkRedArea[$iMatchMode]) Then GetBuildingEdge($eSideBuildingTH)
EndSwitch
If ($nbSides = 0) Then Return
If _Sleep($iDelayalgorithm_AllTroops2) Then Return
If $iMatchMode = $LB And $iChkDeploySettings[$LB] = 4 Then
Switch $icmbStandardAlgorithm[$iMatchMode]
Case 0
Local $listInfoDeploy[21][5] = [[$eGole, $nbSides, 1, 1, 2]  , [$eLava, $nbSides, 1, 1, 2]  , [$eGiant, $nbSides, 1, 1, 2]  , [$eDrag, $nbSides, 1, 1, 0]  , [$eBall, $nbSides, 1, 1, 0]  , [$eBabyD, $nbSides, 1, 1, 1]  , [$eHogs, $nbSides, 1, 1, 1]  , [$eValk, $nbSides, 1, 1, 0]  , [$eBowl, $nbSides, 1, 1, 0]  , [$eMine, $nbSides, 1, 1, 0]  , [$eBarb, $nbSides, 1, 1, 0]  , [$eWall, $nbSides, 1, 1, 1]  , [$eArch, $nbSides, 1, 1, 0]  , [$eWiza, $nbSides, 1, 1, 0]  , [$eMini, $nbSides, 1, 1, 0]  , [$eWitc, $nbSides, 1, 1, 1]  , [$eGobl, $nbSides, 1, 1, 0]  , ["CC", 1, 1, 1, 1]  , [$eHeal, $nbSides, 1, 1, 1]  , [$ePekk, $nbSides, 1, 1, 1]  , ["HEROES", 1, 2, 1, 1]  ]
Case 1
Local $listInfoDeploy[6][5] = [[$eBarb, $nbSides, 1, 1, 0]  , [$eArch, $nbSides, 1, 1, 0]  , [$eGobl, $nbSides, 1, 1, 0]  , [$eMini, $nbSides, 1, 1, 0]  , ["CC", 1, 1, 1, 1]  , ["HEROES", 1, 2, 1, 1]  ]
Case 2
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, 2]  , [$eWall, $nbSides, 1, 1, 2]  , [$eBarb, $nbSides, 1, 2, 2]  , [$eArch, $nbSides, 1, 3, 3]  , [$eBarb, $nbSides, 2, 2, 2]  , [$eArch, $nbSides, 2, 3, 3]  , ["CC", 1, 1, 1, 1]  , ["HEROES", 1, 2, 1, 0]  , [$eHogs, $nbSides, 1, 1, 1]  , [$eWiza, $nbSides, 1, 1, 0]  , [$eMini, $nbSides, 1, 1, 0]  , [$eArch, $nbSides, 3, 3, 2]  , [$eGobl, $nbSides, 1, 1, 1]  ]
EndSwitch
Else
If $debugSetlog = 1 Then SetLog("listdeploy standard for attack", $COLOR_DEBUG)
Switch $icmbStandardAlgorithm[$iMatchMode]
Case 0
Local $listInfoDeploy[21][5] = [[$eGole, $nbSides, 1, 1, 2]  , [$eLava, $nbSides, 1, 1, 2]  , [$eGiant, $nbSides, 1, 1, 2]  , [$eDrag, $nbSides, 1, 1, 0]  , [$eBall, $nbSides, 1, 1, 0]  , [$eBabyD, $nbSides, 1, 1, 0]  , [$eHogs, $nbSides, 1, 1, 1]  , [$eValk, $nbSides, 1, 1, 0]  , [$eBowl, $nbSides, 1, 1, 0]  , [$eMine, $nbSides, 1, 1, 0]  , [$eBarb, $nbSides, 1, 1, 0]  , [$eWall, $nbSides, 1, 1, 1]  , [$eArch, $nbSides, 1, 1, 0]  , [$eWiza, $nbSides, 1, 1, 0]  , [$eMini, $nbSides, 1, 1, 0]  , [$eWitc, $nbSides, 1, 1, 1]  , [$eGobl, $nbSides, 1, 1, 0]  , ["CC", 1, 1, 1, 1]  , [$eHeal, $nbSides, 1, 1, 1]  , [$ePekk, $nbSides, 1, 1, 1]  , ["HEROES", 1, 2, 1, 1]  ]
Case 1
Local $listInfoDeploy[6][5] = [[$eBarb, $nbSides, 1, 1, 0]  , [$eArch, $nbSides, 1, 1, 0]  , [$eGobl, $nbSides, 1, 1, 0]  , [$eMini, $nbSides, 1, 1, 0]  , ["CC", 1, 1, 1, 1]  , ["HEROES", 1, 2, 1, 1]  ]
Case 2
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, 2]  , [$eBarb, $nbSides, 1, 2, 0]  , [$eWall, $nbSides, 1, 1, 1]  , [$eArch, $nbSides, 1, 2, 0]  , [$eBarb, $nbSides, 2, 2, 0]  , [$eGobl, $nbSides, 1, 2, 0]  , ["CC", 1, 1, 1, 1]  , [$eHogs, $nbSides, 1, 1, 1]  , [$eWiza, $nbSides, 1, 1, 0]  , [$eMini, $nbSides, 1, 1, 0]  , [$eArch, $nbSides, 2, 2, 0]  , [$eGobl, $nbSides, 2, 2, 0]  , ["HEROES", 1, 2, 1, 1]  ]
Case Else
SetLog("Algorithm type unavailable, defaulting to regular", $COLOR_RED)
Local $listInfoDeploy[13][5] = [[$eGiant, $nbSides, 1, 1, 2]  , [$eBarb, $nbSides, 1, 2, 0]  , [$eWall, $nbSides, 1, 1, 1]  , [$eArch, $nbSides, 1, 2, 0]  , [$eBarb, $nbSides, 2, 2, 0]  , [$eGobl, $nbSides, 1, 2, 0]  , ["CC", 1, 1, 1, 1]  , [$eHogs, $nbSides, 1, 1, 1]  , [$eWiza, $nbSides, 1, 1, 0]  , [$eMini, $nbSides, 1, 1, 0]  , [$eArch, $nbSides, 2, 2, 0]  , [$eGobl, $nbSides, 2, 2, 0]  , ["HEROES", 1, 2, 1, 1]  ]
EndSwitch
EndIf
$isCCDropped = False
$DeployCCPosition[0] = -1
$DeployCCPosition[1] = -1
$isHeroesDropped = False
$DeployHeroesPosition[0] = -1
$DeployHeroesPosition[1] = -1
LaunchTroop2($listInfoDeploy, $CC, $King, $Queen, $Warden)
If _Sleep($iDelayalgorithm_AllTroops4) Then Return
SetLog("Dropping left over troops", $COLOR_BLUE)
For $x = 0 To 1
IF PrepareAttack($iMatchMode, True) = 0 Then
If $debugsetlog = 1 Then Setlog("No Wast time... exit, no troops usable left", $COLOR_DEBUG)
ExitLoop
EndIf
For $i = $eBarb To $eBowl
LauchTroop($i, $nbSides, 0, 1)
CheckHeroesHealth()
If _Sleep($iDelayalgorithm_AllTroops5) Then Return
Next
Next
If ($checkKPower Or $checkQPower) And $iActivateKQCondition = "Manual" Then
SetLog("Waiting " & $delayActivateKQ / 1000 & " seconds before activating Hero abilities", $COLOR_BLUE)
If _Sleep($delayActivateKQ) Then Return
If $checkKPower Then
SetLog("Activating King's power", $COLOR_BLUE)
SelectDropTroop($King)
$checkKPower = False
EndIf
If $checkQPower Then
SetLog("Activating Queen's power", $COLOR_BLUE)
SelectDropTroop($Queen)
$checkQPower = False
EndIf
EndIf
SetLog("Finished Attacking, waiting for the battle to end")
EndFunc
Func SetSlotSpecialTroops()
$King = -1
$Queen = -1
$CC = -1
$Warden = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $eCastle Then
$CC = $i
ElseIf $atkTroops[$i][0] = $eKing Then
$King = $i
ElseIf $atkTroops[$i][0] = $eQueen Then
$Queen = $i
ElseIf $atkTroops[$i][0] = $eWarden Then
$Warden = $i
EndIf
Next
If $debugSetlog = 1 Then SetLog("Use king SLOT # " & $King, $COLOR_DEBUG)
If $debugSetlog = 1 Then SetLog("Use queen SLOT # " & $Queen, $COLOR_DEBUG)
If $debugSetlog = 1 Then SetLog("Use CC SLOT # " & $CC, $COLOR_DEBUG)
If $debugSetlog = 1 Then SetLog("Use Warden SLOT # " & $Warden, $COLOR_DEBUG)
EndFunc
Func CloseBattle()
If IsAttackPage() Then
For $i = 1 To 30
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) = True Then ExitLoop
If _Sleep($iDelayalgorithm_AllTroops2) Then Return
Next
EndIf
If IsAttackPage() Then ClickP($aSurrenderButton, 1, 0, "#0030")
If _Sleep($iDelayalgorithm_AllTroops3) Then Return
If IsEndBattlePage() Then
ClickP($aConfirmSurrender, 1, 0, "#0031")
If _Sleep($iDelayalgorithm_AllTroops1) Then Return
EndIf
EndFunc
Func SmartAttackStrategy($imode)
If $iMatchMode <> $MA then
If ($iChkRedArea[$imode]) Then
SetLog("Calculating Smart Attack Strategy", $COLOR_BLUE)
Local $hTimer = TimerInit()
_CaptureRegion2()
_GetRedArea()
SetLog("Calculated  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds) :")
If ($iChkSmartAttack[$imode][0] = 1 Or $iChkSmartAttack[$imode][1] = 1 Or $iChkSmartAttack[$imode][2] = 1) Then
SetLog("Locating Mines, Collectors & Drills", $COLOR_BLUE)
$hTimer = TimerInit()
Global $PixelMine[0]
Global $PixelElixir[0]
Global $PixelDarkElixir[0]
Global $PixelNearCollector[0]
If ($iChkSmartAttack[$imode][0] = 1) Then
$PixelMine = GetLocationMine()
If (IsArray($PixelMine)) Then
_ArrayAdd($PixelNearCollector, $PixelMine)
EndIf
EndIf
If ($iChkSmartAttack[$imode][1] = 1) Then
$PixelElixir = GetLocationElixir()
If (IsArray($PixelElixir)) Then
_ArrayAdd($PixelNearCollector, $PixelElixir)
EndIf
EndIf
If ($iChkSmartAttack[$imode][2] = 1) Then
$PixelDarkElixir = GetLocationDarkElixir()
If (IsArray($PixelDarkElixir)) Then
_ArrayAdd($PixelNearCollector, $PixelDarkElixir)
EndIf
EndIf
SetLog("Located  (in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds) :")
SetLog("[" & UBound($PixelMine) & "] Gold Mines")
SetLog("[" & UBound($PixelElixir) & "] Elixir Collectors")
SetLog("[" & UBound($PixelDarkElixir) & "] Dark Elixir Drill/s")
$iNbrOfDetectedMines[$imode] += UBound($PixelMine)
$iNbrOfDetectedCollectors[$imode] += UBound($PixelElixir)
$iNbrOfDetectedDrills[$imode] += UBound($PixelDarkElixir)
UpdateStats()
EndIf
EndIf
EndIf
EndFunc
Func Barch()
While 1
Local $Barb = -1, $Arch = -1, $CC = -1
Global $King = -1, $Queen = -1, $Warden = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = "Barbarian" Then
$Barb = $i
ElseIf $atkTroops[$i][0] = "Archer" Then
$Arch = $i
ElseIf $atkTroops[$i][0] = "Clan Castle" Then
$CC = $i
ElseIf $atkTroops[$i][0] = "King" Then
$King = $i
ElseIf $atkTroops[$i][0] = "Queen" Then
$Queen = $i
ElseIf $atkTroops[$i][0] = "Warden" Then
$Warden = $i
EndIf
Next
If _Sleep($iDelayBarch2) Then ExitLoop
Switch $iChkDeploySettings[$iMatchMode]
Case 0
SetLog("~Attacking from two sides...")
If _Sleep($iDelayBarch3) Then ExitLoop
Local $numBarbPerSpot = Ceiling((($atkTroops[$Barb][1] / 2) / 5) / 2)
Local $numArchPerSpot = Ceiling((($atkTroops[$Arch][1] / 2) / 5) / 2)
SetLog("Dropping first wave of Barbarians", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $bottomOffsetY, 1, 0, "#0032")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0033")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0034")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping first wave of Archers", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $bottomOffsetY, 1, 0, "#0035")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0036")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0037")
Next
If _Sleep(2000) Then ExitLoop
SetLog("Dropping second wave of Barbarians", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $bottomOffsetY, 1, 0, "#0038")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0039")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0040")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping second wave of Archers", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $bottomOffsetY, 1, 0, "#0041")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0042")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0043")
Next
dropHeroes($TopLeft[3][0], $TopLeft[3][1], $King, $Queen, $Warden)
If _Sleep($iDelayBarch3) Then ExitLoop
dropCC($TopLeft[3][0], $TopLeft[3][1], $CC)
Case 1
SetLog("~Attacking from three sides...")
If _Sleep($iDelayBarch3) Then ExitLoop
Local $numBarbPerSpot = Ceiling((($atkTroops[$Barb][1] / 3) / 5) / 2)
Local $numArchPerSpot = Ceiling((($atkTroops[$Arch][1] / 3) / 5) / 2)
SetLog("Dropping first wave of Barbarians", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $bottomOffsetY, 1, 0, "#0044")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0045")
Click($TopRight[$i][0], $TopRight[$i][1], $numBarbPerSpot, 1, "#0046")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0047")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping first wave of Archers", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $bottomOffsetY, 1, 0, "#0048")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0049")
Click($TopRight[$i][0], $TopRight[$i][1], $numArchPerSpot, 1, "#0050")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0051")
Next
If _Sleep(2000) Then ExitLoop
SetLog("Dropping second wave of Barbarians", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $bottomOffsetY, 1, 0, "#0052")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0053")
Click($TopRight[$i][0], $TopRight[$i][1], $numBarbPerSpot, 1, "#0054")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0055")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping second wave of Archers", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $bottomOffsetY, 1, 0, "#0085")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0056")
Click($TopRight[$i][0], $TopRight[$i][1], $numArchPerSpot, 1, "#0057")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0058")
Next
dropHeroes($TopRight[3][0], $TopRight[3][1], $King, $Queen, $Warden)
If _Sleep($iDelayBarch3) Then ExitLoop
dropCC($TopRight[3][0], $TopRight[3][1], $CC)
Case 2
SetLog("~Attacking from all sides...")
If _Sleep($iDelayBarch3) Then ExitLoop
Local $numBarbPerSpot = Ceiling((($atkTroops[$Barb][1] / 4) / 5) / 2)
Local $numArchPerSpot = Ceiling((($atkTroops[$Arch][1] / 4) / 5) / 2)
SetLog("Dropping first wave of Barbarians", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $bottomOffsetY, 1, 0, "#0059")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0060")
Click($TopRight[$i][0], $TopRight[$i][1], $numBarbPerSpot, 1, "#0061")
Click($BottomLeft[$i][0], $BottomLeft[$i][1], $numBarbPerSpot, 1, "#0062")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0063")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping first wave of Archers", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $bottomOffsetY, 1, 0, "#0064")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0065")
Click($TopRight[$i][0], $TopRight[$i][1], $numArchPerSpot, 1, "#0066")
Click($BottomLeft[$i][0], $BottomLeft[$i][1], $numArchPerSpot, 1, "#0067")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0068")
Next
If _Sleep(2000) Then ExitLoop
SetLog("Dropping second wave of Barbarians", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Barb, 68), 595 + $bottomOffsetY, 1, 0, "#0069")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numBarbPerSpot, 1, "#0070")
Click($TopRight[$i][0], $TopRight[$i][1], $numBarbPerSpot, 1, "#0071")
Click($BottomLeft[$i][0], $BottomLeft[$i][1], $numBarbPerSpot, 1, "#0072")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numBarbPerSpot, 1, "#0073")
Next
If _Sleep($iDelayBarch3) Then ExitLoop
SetLog("Dropping second wave of Archers", $COLOR_BLUE)
For $i = 0 To 4
Click(GetXPosOfArmySlot($Arch, 68), 595 + $bottomOffsetY, 1, 0, "#0074")
If _Sleep($iDelayBarch1) Then ExitLoop (2)
Click($TopLeft[$i][0], $TopLeft[$i][1], $numArchPerSpot, 1, "#0075")
Click($TopRight[$i][0], $TopRight[$i][1], $numArchPerSpot, 1, "#0076")
Click($BottomLeft[$i][0], $BottomLeft[$i][1], $numArchPerSpot, 1, "#0077")
Click($BottomRight[$i][0], $BottomRight[$i][1], $numArchPerSpot, 1, "#0078")
Next
dropHeroes($BottomLeft[3][0], $BottomLeft[3][1], $King, $Queen, $Warden)
If _Sleep($iDelayBarch3) Then ExitLoop
dropCC($BottomLeft[3][0], $BottomLeft[3][1], $CC)
EndSwitch
If _Sleep($iDelayBarch1) Then ExitLoop
SetLog("Dropping left over troops", $COLOR_BLUE)
$atkTroops[$Barb][1] = Number(ReadTroopQuantity($Barb))
$atkTroops[$Arch][1] = Number(ReadTroopQuantity($Arch))
While $atkTroops[$Barb][1] <> 0
Click(GetXPosOfArmySlot($Barb, 68), 595 + $bottomOffsetY, 1, 0, "#0079")
Click($TopLeft[3][0], $TopLeft[3][1], $atkTroops[$Barb][1], 1, "#0080")
$atkTroops[$Barb][1] = Number(ReadTroopQuantity($Barb))
WEnd
If _Sleep($iDelayBarch3) Then ExitLoop
While $atkTroops[$Arch][1] <> 0
Click(GetXPosOfArmySlot($Arch, 68), 595 + $bottomOffsetY, 1, 0, "#0081")
Click($TopLeft[3][0], $TopLeft[3][1], $atkTroops[$Arch][1], 1, "#0082")
$atkTroops[$Arch][1] = Number(ReadTroopQuantity($Arch))
WEnd
If _Sleep($iDelayBarch1) Then ExitLoop
If $checkKPower = True Or $checkQPower = True Then
SetLog("Waiting " & $delayActivateKQ / 1000 & " seconds before activating Hero abilities", $COLOR_GREEN)
If _Sleep($delayActivateKQ) Then Return
If $checkKPower = True Then
SetLog("Activate King's power", $COLOR_BLUE)
Click(GetXPosOfArmySlot($King, 68), 595 + $bottomOffsetY, 1, 0, "#0083")
EndIf
If $checkQPower = True Then
SetLog("Activate Queen's power", $COLOR_BLUE)
Click(GetXPosOfArmySlot($Queen, 68), 595 + $bottomOffsetY, 1, 0, "#0084")
EndIf
EndIf
SetLog("~Finished Attacking, waiting to finish")
ExitLoop
WEnd
EndFunc
Func AttackTHGrid($troopKind, $iNbOfSpots = 1, $iAtEachSpot = 1, $Sleep = Random(800, 900, 1), $waveNb = 0)
Local $aThx, $aThy, $num
Local $TroopCountBeg
Local $THtroop = -1
Local $troopNb = 0
Local $name = ""
Local $plural = 0
Local $waveName = "first"
Local $NumTroopDeployed = 0
If _Sleep(5) Then Return
If $Restart = True Then Return
If CheckOneStar(0, False, True) Then Return
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $troopKind Then
$THtroop = $i
EndIf
Next
If ($THtroop = -1) And $debugSetlog = 1 Then SetLog("No " & $name & " Found!!!", $COLOR_DEBUG)
If ($THtroop = -1) Then Return False
If $troopKind >= $eKing And $troopKind <= $eCastle Then
$iNbOfSpots = 1
$iAtEachSpot = 1
$troopNb = 1
If $troopKind = $eKing Then
If $duringMilkingAttack = 0 and $KingAttack[$TS] = 0 Then Return
If $duringMilkingAttack = 1 and $KingAttack[$DB] = 0 Then Return
$checkKPower = True
SetLog("Dropping King", $COLOR_GREEN)
$THusedKing = 1
EndIf
If $troopKind = $eQueen Then
If $duringMilkingAttack = 0 and $QueenAttack[$TS] = 0 Then Return
If $duringMilkingAttack = 1 and $QueenAttack[$DB] = 0 Then Return
$checkQPower = True
SetLog("Dropping Queen", $COLOR_GREEN)
$THusedQueen = 1
EndIf
If $troopKind = $eWarden Then
If  $duringMilkingAttack = 0 and $WardenAttack[$TS] = 0 Then Return
If $duringMilkingAttack = 1 and $WardenAttack[$DB] = 0 Then Return
$checkWPower = True
SetLog("Dropping Grand Warden", $COLOR_GREEN)
$THusedWarden = 1
EndIf
If $troopKind = $eCastle Then
If $duringMilkingAttack = 0 and $iDropCC[$TS] = 0 Then Return
If $duringMilkingAttack = 1 and $iDropCC[$DB] = 0 Then Return
If $iPlannedDropCCHoursEnable = 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $iPlannedDropCCHours[$hour[0]] = 0 Then
SetLog("Drop Clan Castle not Planned, Skipped..", $COLOR_GREEN)
Return
EndIf
EndIf
If $iChkUseCCBalanced = 1 Then
If Number($TroopsReceived) <> 0 Then
If Number(Number($TroopsDonated) / Number($TroopsReceived)) >= (Number($iCmbCCDonated) / Number($iCmbCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") >= " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_BLUE)
Else
SetLog("Not Dropping Clan Castle, donated  (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") < " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_BLUE)
Return
EndIf
Else
If Number(Number($TroopsDonated) / 1) >= (Number($iCmbCCDonated) / Number($iCmbCCReceived)) Then
SetLog("Dropping Clan Castle, donated (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") >= " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_BLUE)
Else
SetLog("Not Dropping Clan Castle, donated  (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") < " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_BLUE)
Return
EndIf
EndIf
EndIf
EndIf
EndIf
If $troopKind >= $eBarb And $troopKind <= $eBowl Then
$troopNb = $iNbOfSpots * $iAtEachSpot
If $troopNb > 1 Then $plural = 1
$name = NameOfTroop($troopKind, $plural)
$TroopCountBeg = Number(ReadTroopQuantity($THtroop))
If ($TroopCountBeg = 0) And $debugSetlog = 1 Then SetLog("No " & $name & " Remaining!!!", $COLOR_DEBUG)
If ($TroopCountBeg = 0) Then Return False
If $waveNb = 0 Then $waveName = "Only"
If $waveNb = 1 Then $waveName = "First"
If $waveNb = 2 Then $waveName = "Second"
If $waveNb = 3 Then $waveName = "Third"
If $waveNb = 4 Then $waveName = "Last"
SetLog("Dropping " & $waveName & " wave of " & $troopNb & " " & $name, $COLOR_GREEN)
EndIf
SelectDropTroop($THtroop)
If _Sleep($iDelayAttackTHGrid1) Then Return
DeployTHNormal($iAtEachSpot, $iNbOfSpots)
If $troopKind >= $eBarb And $troopKind <= $eBowl Then
If $TroopCountBeg <> Number(ReadTroopQuantity($THtroop)) Then
$NumTroopDeployed = $TroopCountBeg - Number(ReadTroopQuantity($THtroop))
SetLog("Deployment of " & $NumTroopDeployed & " " & $name & " was Successful!")
If _Sleep($Sleep) Then Return
Else
SetLog("Deployment of " & $name & " wasn't Successful!")
EndIf
EndIf
If $troopKind >= $eKing And $troopKind <= $eCastle Then
SelectDropTroop(0)
If _Sleep($Sleep) Then Return
EndIf
EndFunc
Func DeployTHNormal($iAtEachSpot, $iNbOfSpots)
Switch $THside
Case 0
For $num = 0 To $iAtEachSpot - 1
For $i = $THi - 1 To $THi - 1 + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 25 - $i * 16
$aThy = 314 + $i * 12
Next
For $ii = $THi - 1 To $THi - 1 + ($iNbOfSpots - 1)
$aThx = 25 + $ii * 16
$aThy = 314 - $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0019")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 1
For $num = 0 To $iAtEachSpot - 1
For $i = $THi To $THi + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 25 - $i * 16
$aThy = 314 - $i * 12
Next
For $ii = $THi To $THi + ($iNbOfSpots - 1)
$aThx = 25 + $ii * 16
$aThy = 314 + $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0020")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 2
For $num = 0 To $iAtEachSpot - 1
For $i = $THi To $THi + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 830 + $i * 16
$aThy = 314 + $i * 12
Next
For $ii = $THi To $THi + ($iNbOfSpots - 1)
$aThx = 830 - $ii * 16
$aThy = 314 - $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0021")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
Case 3
For $num = 0 To $iAtEachSpot - 1
For $i = $THi + 1 To $THi + 1 + Ceiling(($iNbOfSpots - 1) / 2)
$aThx = 830 + $i * 16
$aThy = 314 - $i * 12
Next
For $ii = $THi + 1 To $THi + 1 + ($iNbOfSpots - 1)
$aThx = 830 - $ii * 16
$aThy = 314 + $ii * 12
If CheckOneStar(0, False, False) Then Return
If IsAttackPage() Then Click(Random($aThx - 5, $aThx + 5, 1), Random($aThy - 5, $aThy + 5, 1), 1, 0, "#0022")
If _Sleep(Random(20, 40, 1)) Then Return
Next
Next
EndSwitch
EndFunc
Func SpellTHGrid($S)
If 	$duringMilkingAttack = 0 and ( ($S = $eHSpell And $ichkHealSpell[$TS] = 1) Or ($S = $eLSpell And $ichkLightSpell[$TS] = 1) Or ($S = $eRSpell And $ichkRageSpell[$TS] = 1) Or ($S = $eJSpell And $ichkJumpSpell[$TS] = 1) Or ($S = $eFSpell And $ichkFreezeSpell[$TS] = 1) Or ($S = $ePSpell And $ichkPoisonSpell[$TS] = 1) Or ($S = $eHaSpell And $ichkHasteSpell[$TS] = 1) Or ($S = $eESpell And $ichkEarthquakeSpell[$TS] = 1)) or  $duringMilkingAttack = 1 and ( ($S = $eHSpell And $ichkHealSpell[$DB] = 1) Or ($S = $eLSpell And $ichkLightSpell[$DB] = 1) Or ($S = $eRSpell And $ichkRageSpell[$DB] = 1) Or ($S = $eJSpell And $ichkJumpSpell[$DB] = 1) Or ($S = $eFSpell And $ichkFreezeSpell[$DB] = 1) Or ($S = $ePSpell And $ichkPoisonSpell[$DB] = 1) Or ($S = $eHaSpell And $ichkHasteSpell[$DB] = 1) Or ($S = $eESpell And $ichkEarthquakeSpell[$DB] = 1))  Then
If _Sleep(10) Then Return
If $Restart = True Then Return
If CheckOneStar(0, False, True) Then Return
If $THi <= 15 Or $THside = 0 Or $THside = 2 Then
Switch $THside
Case 0
CastSpell($S, 114 + $THi * 16 + Ceiling(-2 * 16), 359 - $THi * 12 + Ceiling(-2 * 12))
Case 1
CastSpell($S, 117 + $THi * 16 + Ceiling(-2 * 16), 268 + $THi * 12 - Floor(-2 * 12))
Case 2
CastSpell($S, 743 - $THi * 16 - Floor(-2 * 16), 358 - $THi * 12 + Ceiling(-2 * 12))
Case 3
CastSpell($S, 742 - $THi * 16 - Floor(-2 * 16), 268 + $THi * 12 - Floor(-2 * 12))
EndSwitch
EndIf
If $THi > 15 And ($THside = 1 Or $THside = 3) Then
CastSpell($S, $THx, $THy)
EndIf
EndIf
EndFunc
Func CastSpell($THSpell, $x, $y)
Local $Spell = -1
Local $name = ""
If ($THSpell = $eHSpell And $ichkUseHSpellsTH = 1) Or ($THSpell = $eLSpell And $ichkUseLSpellsTH = 1) Or ($THSpell = $eRSpell And $ichkUseRSpellsTH = 1) Then
If _Sleep(10) Then Return
If $Restart = True Then Return
If CheckOneStar(0, False, True) Then Return
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $THSpell Then
$Spell = $i
$name = NameOfTroop($THSpell, 0)
EndIf
Next
If $Spell > -1 Then
SetLog("Dropping " & $name)
SelectDropTroop($Spell)
If _Sleep($iDelayCastSpell1) Then Return
If IsAttackPage() Then Click($x, $y, 1, 0, "#0029")
Else
If $debugSetlog = 1 Then SetLog("No " & $name & " Found", $COLOR_DEBUG)
EndIf
EndIf
EndFunc
Func CheckOneStar($DelayInSec = 0, $Log = True, $CheckHeroes = True)
For $i = 0 To $DelayInSec
If _Sleep(5) Then Return True
If $Restart = True Then Return True
If $CheckHeroes = True And ($checkQPower = True Or $checkKPower = True) Then CheckHeroesHealth()
If _ColorCheck(_GetPixelColor($aWonOneStar[0], $aWonOneStar[1], True), Hex($aWonOneStar[2], 6), $aWonOneStar[3]) Then
If $Log = True Then SetLog("Townhall has been destroyed!", $COLOR_ORANGE)
If $Restart = True Then Return True
If $checkQPower = True Then
SetLog("Activating Queen's power to restore some health before EndBattle", $COLOR_BLUE)
SelectDropTroop($Queen)
$checkQPower = False
EndIf
If _Sleep(500) Then Return True
If $Restart = True Then Return True
If $checkKPower = True Then
SetLog("Activating King's power to restore some health before EndBattle", $COLOR_BLUE)
SelectDropTroop($King)
$checkKPower = False
EndIf
If $Log = True Then
If _Sleep(1000) Then Return
EndIf
Return True
Else
If $i <> 0 Then
If _Sleep(1000) Then Return True
If $Restart = True Then Return True
EndIf
EndIf
Next
Return False
EndFunc
Func SwitchAttackTHType()
$THusedKing = 0
$THusedQueen = 0
AttackTHParseCSV()
EndFunc
Func AttackTHParseCSV($test = False)
If $debugsetlog = 1 Then Setlog("AttackTHParseCSV start", $COLOR_DEBUG)
Local $f, $line, $acommand, $command
Local $attackCSVtoUse = ""
Switch $iMatchMode
Case $TS
$attackCSVtoUse = $scmbAttackTHType
Case $LB
$attackCSVtoUse = $THSnipeBeforeLBScript
Case $DB
If $duringMilkingAttack = 1 Then
$attackCSVtoUse = $MilkFarmAlgorithmTh
Else
$attackCSVtoUse = $THSnipeBeforeDBScript
EndIf
EndSwitch
If FileExists($dirTHSnipesAttacks & "\" & $attackCSVtoUse & ".csv") Then
$f = FileOpen($dirTHSnipesAttacks & "\" & $attackCSVtoUse & ".csv", 0)
If $debugsetlog=1 Then Setlog("Use algorithm " & $attackCSVtoUse &".csv", $COLOR_DEBUG)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
Select
Case $command = "TROOP" Or $command = ""
Case $command = "TEXT"
If $debugsetlog = 1 Then Setlog(">> SETLOG(""" & $acommand[8] & """)", $COLOR_DEBUG)
SetLog($acommand[8], $COLOR_BLUE)
Case StringInStr(StringUpper("-Barb-Arch-Giant-Gobl-Wall-Ball-Wiza-Heal-Drag-Pekk-BabyD-Mine-Mini-Hogs-Valk-Gole-Witc-Lava-Bowl"), "-" & $command & "-") > 0
If $debugsetlog = 1 Then Setlog(">> AttackTHGrid($e" & $command & ", Random (" & Int($acommand[2]) & "," & Int($acommand[3]) & ",1), Random(" & Int($acommand[4]) & "," & Int($acommand[5]) & ",1), Random(" & Int($acommand[6]) & "," & Int($acommand[7]) & ",1) )", $COLOR_DEBUG)
Local $iNbOfSpots
If Int($acommand[2]) = Int($acommand[3]) Then
$iNbOfSpots = Int($acommand[2])
Else
$iNbOfSpots = Random(Int($acommand[2]), Int($acommand[3]), 1)
EndIf
Local $iAtEachSpot
If Int($acommand[4]) = Int($acommand[5]) Then
$iAtEachSpot = Int($acommand[4])
Else
$iAtEachSpot = Random(Int($acommand[4]), Int($acommand[5]), 1)
EndIf
Local $Sleep
If Int($acommand[6]) = Int($acommand[7]) Then
$Sleep = Int($acommand[6])
Else
$Sleep = Random(Int($acommand[6]), Int($acommand[7]), 1)
EndIf
AttackTHGrid(Eval("e" & $command), $iNbOfSpots, $iAtEachSpot, $Sleep, 0)
Case $command = "WAIT"
If $debugsetlog = 1 Then Setlog(">> GoldElixirChangeThSnipes(" & Int($acommand[7]) & ") ", $COLOR_DEBUG)
If CheckOneStar(Int($acommand[7]) / 2000) Then ExitLoop
If GoldElixirChangeThSnipes(Int($acommand[7]) / 2000) Then ExitLoop
Case StringInStr(StringUpper("-King-Queen-Castle-"), "-" & $command & "-") > 0
If $debugsetlog = 1 Then Setlog(">> AttackTHGrid($e" & $command & ")", $COLOR_DEBUG)
AttackTHGrid(Eval("e" & $command))
Case StringInStr(StringUpper("-HSpell-RSpell-LSpell-JSpell-FSpell-PSpell-ESpell-HaSpell"), "-" & $command & "-") > 0
If $debugsetlog = 1 Then Setlog(">> SpellTHGrid($e" & $command & ")", $COLOR_DEBUG)
SpellTHGrid(Eval("e" & $command))
Case StringInStr(StringUpper("-LSpell-"), "-" & $command & "-") > 0
If $debugsetlog = 1 Then Setlog(">> CastSpell($e" & $command & ",$THx, $THy)", $COLOR_DEBUG)
CastSpell(Eval("e" & $command), $THx, $THy)
Case Else
Setlog("attack row bad, discard: " & $line, $COLOR_RED)
EndSelect
If $acommand[8] <> "" And $command <> "TEXT" And $command <> "TROOP" Then
If $debugsetlog = 1 Then Setlog(">> SETLOG(""" & $acommand[8] & """)", $COLOR_DEBUG)
SETLOG($acommand[8], $COLOR_BLUE)
EndIf
Else
If StringStripWS($acommand[1], 2) <> "" Then Setlog("attack row error, discard: " & $line, $COLOR_RED)
EndIf
If $debugsetlog = 1 Then Setlog(">> CheckOneStar()", $COLOR_DEBUG)
If CheckOneStar() Then ExitLoop
WEnd
FileClose($f)
Else
SetLog("Cannot found THSnipe attack file " & $dirTHSnipesAttacks & "\" & $attackCSVtoUse & ".csv", $color_red)
EndIf
EndFunc
Global $MAINSIDE = "TOP-RIGHT"
Global $FRONT_LEFT = "TOP-RIGHT-DOWN"
Global $FRONT_RIGHT = "TOP-RIGHT-UP"
Global $RIGHT_FRONT = "TOP-LEFT-UP"
Global $RIGHT_BACK = "TOP-LEFT-DOWN"
Global $LEFT_FRONT = "BOTTOM-RIGHT-UP"
Global $LEFT_BACK = "BOTTOM-RIGHT-DOWN"
Global $BACK_LEFT = "BOTTOM-LEFT-DOWN"
Global $BACK_RIGHT = "BOTTOM-LEFT-UP"
Global $PixelTopLeftDropLine
Global $PixelTopRightDropLine
Global $PixelBottomLeftDropLine
Global $PixelBottomRightDropLine
Global $PixelTopLeftUPDropLine
Global $PixelTopLeftDOWNDropLine
Global $PixelTopRightUPDropLine
Global $PixelTopRightDOWNDropLine
Global $PixelBottomLeftUPDropLine
Global $PixelBottomLeftDOWNDropLine
Global $PixelBottomRightUPDropLine
Global $PixelBottomRightDOWNDropLine
Global Const $TopExt[2] = [444, 22]
Global Const $LeftExt[2] = [2, 344]
Global Const $RightExt[2] = [860, 344]
Global Const $BottomExt[2] = [444, 670]
Global Const $Middle = [444, 344]
Global $ExternalArea[8][3] = [  [$LeftExt[0], $LeftExt[1], "LEFT"],  [$RightExt[0], $RightExt[1], "RIGHT"],  [$TopExt[0], $TopExt[1], "TOP"],  [$BottomExt[0], $BottomExt[1], "BOTTOM"],  [($TopExt[0] + $LeftExt[0]) / 2, ($TopExt[1] + $LeftExt[1]) / 2, "TOP-LEFT"],  [($TopExt[0] + $RightExt[0]) / 2, ($TopExt[1] + $RightExt[1]) / 2, "TOP-RIGHT"],  [($BottomExt[0] + $LeftExt[0]) / 2, ($BottomExt[1] + $LeftExt[1]) / 2, "BOTTOM-LEFT"],  [($BottomExt[0] + $RightExt[0]) / 2, ($BottomExt[1] + $RightExt[1]) / 2, "BOTTOM-RIGHT"]  ]
Global Const $TopInt[2] = [444, 70]
Global Const $LeftInt[2] = [55, 344]
Global Const $RightInt[2] = [825, 344]
Global Const $BottomInt[2] = [444, 640]
Global $InternalArea[8][3] = [  [$LeftInt[0], $LeftInt[1], "LEFT"],  [$RightInt[0], $RightInt[1], "RIGHT"],  [$TopInt[0], $TopInt[1], "TOP"],  [$BottomInt[0], $BottomInt[1], "BOTTOM"],  [($TopInt[0] + $LeftInt[0]) / 2, ($TopInt[1] + $LeftInt[1]) / 2, "TOP-LEFT"],  [($TopInt[0] + $RightInt[0]) / 2, ($TopInt[1] + $RightInt[1]) / 2, "TOP-RIGHT"],  [($BottomInt[0] + $LeftInt[0]) / 2, ($BottomInt[1] + $LeftInt[1]) / 2, "BOTTOM-LEFT"],  [($BottomInt[0] + $RightInt[0]) / 2, ($BottomInt[1] + $RightInt[1]) / 2, "BOTTOM-RIGHT"]  ]
Func Algorithm_AttackCSV($testattack = False, $captureredarea = True)
ParseAttackCSV_Read_SIDE_variables()
If _Sleep($iDelayRespond) Then Return
Local $hTimerTOTAL = TimerInit()
debugAttackCSV("Troops to be used (purged from troops) ")
For $i = 0 To UBound($atkTroops) - 1
debugAttackCSV("SLOT n.: " & $i & " - Troop: " & NameOfTroop($atkTroops[$i][0]) & " (" & $atkTroops[$i][0] & ") - Quantity: " & $atkTroops[$i][1])
Next
Local $hTimer = TimerInit()
If $captureredarea Or $makeIMGCSV = 1 Then
ParseAndMakeDropLines("")
Setlog("> Get all Red Area in  " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
Local $hTimer = TimerInit()
Local $htimerREDAREA = Round(TimerDiff($hTimer) / 1000, 2)
debugAttackCSV("Calculated  (in " & $htimerREDAREA & " seconds) :")
debugAttackCSV("	[" & UBound($PixelTopLeft) & "] pixels TopLeft")
debugAttackCSV("	[" & UBound($PixelTopRight) & "] pixels TopRight")
debugAttackCSV("	[" & UBound($PixelBottomLeft) & "] pixels BottomLeft")
debugAttackCSV("	[" & UBound($PixelBottomRight) & "] pixels BottomRight")
Setlog(">> Total time: " & Round(TimerDiff($hTimerTOTAL) / 1000, 2) & " seconds", $COLOR_BLUE)
If $makeIMGCSV = 1 Then AttackCSVDEBUGIMAGE()
EndIf
If $THSnipeBeforeDBEnable = 1 And $searchTH = "-" Then townHallCheck(True)
If $THSnipeBeforeDBEnable = 1 Then
If $searchTH <> "-" Then
If SearchTownHallLoc() Then
Setlog(_PadStringCenter(" TH snipe Before Scripted Attack ", 54, "="), $color_blue)
$THusedKing = 0
$THusedQueen = 0
AttackTHParseCSV()
Else
If $debugsetlog = 1 Then Setlog("TH snipe before scripted attack skip, th internal village", $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog("TH snipe before scripted attack skip, no th found", $COLOR_DEBUG)
EndIf
EndIf
SetSlotSpecialTroops()
If _Sleep($iDelayRespond) Then Return
ParseAttackCSV($testattack)
EndFunc
Func UpdateResourcesLocations($lineContent)
Local $hTimerTOTAL = TimerInit()
ParseAttackCSV_Read_SIDE_variables($lineContent)
If $searchTH = "-" Then
Local $THString = ""
If $attackcsv_locate_townhall = 1 Then
SuspendAndroid()
$hTimer = TimerInit()
Local $aResult = townHallCheck(True)
$THString = convertToOldTHData($aResult)
Setlog("> Townhall located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
ResumeAndroid()
Else
Setlog("> Townhall search not needed, skip")
EndIf
Else
Setlog("> Townhall has already been located in while searching for an image", $COLOR_BLUE)
EndIf
If _Sleep($iDelayRespond) Then Return
_CaptureRegion2()
Global $PixelMine[0]
Global $PixelElixir[0]
Global $PixelDarkElixir[0]
Local $PixelNearCollectorTopLeftSTR = ""
Local $PixelNearCollectorBottomLeftSTR = ""
Local $PixelNearCollectorTopRightSTR = ""
Local $PixelNearCollectorBottomRightSTR = ""
If $attackcsv_locate_mine = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
$PixelMine = GetLocationMine()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelMine)
Local $htimerMine = Round(TimerDiff($hTimer) / 1000, 2)
If (IsArray($PixelMine)) Then
For $i = 0 To UBound($PixelMine) - 1
$pixel = $PixelMine[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "MINE"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopLeftSTR &= $str & "|"
Else
$PixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopRightSTR &= $str & "|"
Else
$PixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
Setlog("> Mines located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
Else
Setlog("> Mines detection not needed, skip", $COLOR_BLUE)
EndIf
If _Sleep($iDelayRespond) Then Return
If $attackcsv_locate_elixir = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
$PixelElixir = GetLocationElixir()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelElixir)
Local $htimerMine = Round(TimerDiff($hTimer) / 1000, 2)
If (IsArray($PixelElixir)) Then
For $i = 0 To UBound($PixelElixir) - 1
$pixel = $PixelElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "ELIXIR"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopLeftSTR &= $str & "|"
Else
$PixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopRightSTR &= $str & "|"
Else
$PixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
Setlog("> Elixir collectors located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
Else
Setlog("> Elixir collectors detection not needed, skip", $COLOR_BLUE)
EndIf
If _Sleep($iDelayRespond) Then Return
If $attackcsv_locate_drill = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
$PixelDarkElixir = GetLocationDarkElixir()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelDarkElixir)
Local $htimerMine = Round(TimerDiff($hTimer) / 1000, 2)
If (IsArray($PixelDarkElixir)) Then
For $i = 0 To UBound($PixelDarkElixir) - 1
$pixel = $PixelDarkElixir[$i]
Local $str = $pixel[0] & "-" & $pixel[1] & "-" & "DRILL"
If isInsideDiamond($pixel) Then
If $pixel[0] <= $InternalArea[2][0] Then
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopLeftSTR &= $str & "|"
Else
$PixelNearCollectorBottomLeftSTR &= $str & "|"
EndIf
Else
If $pixel[1] <= $InternalArea[0][1] Then
$PixelNearCollectorTopRightSTR &= $str & "|"
Else
$PixelNearCollectorBottomRightSTR &= $str & "|"
EndIf
EndIf
EndIf
Next
EndIf
Setlog("> Drills located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
Else
Setlog("> Drills detection not needed, skip", $COLOR_BLUE)
EndIf
If _Sleep($iDelayRespond) Then Return
If StringLen($PixelNearCollectorTopLeftSTR) > 0 Then $PixelNearCollectorTopLeftSTR = StringLeft($PixelNearCollectorTopLeftSTR, StringLen($PixelNearCollectorTopLeftSTR) - 1)
If StringLen($PixelNearCollectorTopRightSTR) > 0 Then $PixelNearCollectorTopRightSTR = StringLeft($PixelNearCollectorTopRightSTR, StringLen($PixelNearCollectorTopRightSTR) - 1)
If StringLen($PixelNearCollectorBottomLeftSTR) > 0 Then $PixelNearCollectorBottomLeftSTR = StringLeft($PixelNearCollectorBottomLeftSTR, StringLen($PixelNearCollectorBottomLeftSTR) - 1)
If StringLen($PixelNearCollectorBottomRightSTR) > 0 Then $PixelNearCollectorBottomRightSTR = StringLeft($PixelNearCollectorBottomRightSTR, StringLen($PixelNearCollectorBottomRightSTR) - 1)
$PixelNearCollectorTopLeft = GetListPixel3($PixelNearCollectorTopLeftSTR)
$PixelNearCollectorTopRight = GetListPixel3($PixelNearCollectorTopRightSTR)
$PixelNearCollectorBottomLeft = GetListPixel3($PixelNearCollectorBottomLeftSTR)
$PixelNearCollectorBottomRight = GetListPixel3($PixelNearCollectorBottomRightSTR)
If $attackcsv_locate_gold_storage = 1 Then
SuspendAndroid()
$GoldStoragePos = GetLocationGoldStorage()
ResumeAndroid()
EndIf
If $attackcsv_locate_elixir_storage = 1 Then
SuspendAndroid()
$ElixirStoragePos = GetLocationElixirStorage()
ResumeAndroid()
EndIf
If $attackcsv_locate_dark_storage = 1 Then
$hTimer = TimerInit()
SuspendAndroid()
Local $PixelDarkElixirStorage = GetLocationDarkElixirStorageWithLevel()
ResumeAndroid()
If _Sleep($iDelayRespond) Then Return
CleanRedArea($PixelDarkElixirStorage)
Local $pixel = StringSplit($PixelDarkElixirStorage, "#", 2)
If UBound($pixel) >= 2 Then
Local $pixellevel = $pixel[0]
Local $pixelpos = StringSplit($pixel[1], "-", 2)
If UBound($pixelpos) >= 2 Then
Local $temp = [Int($pixelpos[0]), Int($pixelpos[1])]
$darkelixirStoragePos = $temp
EndIf
EndIf
Setlog("> Dark Elixir Storage located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
Else
Setlog("> Dark Elixir Storage detection not need, skip", $COLOR_BLUE)
EndIf
Setlog(">> Total time: " & Round(TimerDiff($hTimerTOTAL) / 1000, 2) & " seconds", $COLOR_BLUE)
If _Sleep($iDelayRespond) Then Return
EndFunc
Func ParseAndMakeDropLines($MAINSIDE)
Local $hTimer = TimerInit()
Local $result
If IsRedLineAvailable() = True Then
$result = GetImgLoc2MBR($CurBaseRedLine)
Setlog("Used last Red Lines!!", $COLOR_RED)
Else
$result = GetImgLoc2MBR()
EndIf
If $debugsetlog Then Setlog("Debug: Redline chosen")
Local $listPixelBySide = StringSplit($result, "#")
If $debugRedArea =  1 then
Local $1 = StringSplit($listPixelBySide[1], "|", 2)
Local $2 = StringSplit($listPixelBySide[2], "|", 2)
Local $3 = StringSplit($listPixelBySide[3], "|", 2)
Local $4 = StringSplit($listPixelBySide[4], "|", 2)
_CaptureRegion()
Local $editedImage = $hBitmap
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $subDirectory = @ScriptDir & "\RedLineDebug"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = String($Date & "_" & $Time & "_.png")
For $i = 0 To UBound($1) - 1
Local $temp = StringSplit($1[$i], "-", 2)
If UBound($temp) > 1 Then
_GDIPlus_GraphicsDrawRect($hGraphic, $temp[0] - 2, $temp[1] - 2, 4, 4, $hPenRED)
EndIf
Next
For $i = 0 To UBound($2) - 1
Local $temp = StringSplit($2[$i], "-", 2)
If UBound($temp) > 1 Then
_GDIPlus_GraphicsDrawRect($hGraphic, $temp[0] - 2, $temp[1] - 2, 4, 4, $hPenRED)
EndIf
Next
For $i = 0 To UBound($3) - 1
Local $temp = StringSplit($3[$i], "-", 2)
If UBound($temp) > 1 Then
_GDIPlus_GraphicsDrawRect($hGraphic, $temp[0] - 2, $temp[1] - 2, 4, 4, $hPenRED)
EndIf
Next
For $i = 0 To UBound($4) - 1
Local $temp = StringSplit($4[$i], "-", 2)
If UBound($temp) > 1 Then
_GDIPlus_GraphicsDrawRect($hGraphic, $temp[0] - 2, $temp[1] - 2, 4, 4, $hPenRED)
EndIf
Next
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $fileName)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
$PixelTopLeft = GetPixelSide($listPixelBySide, 1)
$PixelBottomLeft = GetPixelSide($listPixelBySide, 2)
$PixelBottomRight = GetPixelSide($listPixelBySide, 3)
$PixelTopRight = GetPixelSide($listPixelBySide, 4)
ReDim $PixelRedArea[UBound($PixelTopLeft) + UBound($PixelBottomLeft) + UBound($PixelTopRight) + UBound($PixelBottomRight)]
ReDim $PixelRedAreaFurther[UBound($PixelTopLeft) + UBound($PixelBottomLeft) + UBound($PixelTopRight) + UBound($PixelBottomRight)]
Local $hTimer = TimerInit()
CleanRedArea($PixelBottomRight)
If UBound($PixelBottomRight) < 30 Then
$PixelBottomRight = _GetVectorOutZone($eVectorRightBottom)
EndIf
debugAttackCSV("RedArea cleaned")
debugAttackCSV("	[" & UBound($PixelBottomRight) & "] pixels BottomRight")
$PixelBottomRightDropLine = MakeDropLine($PixelBottomRight, StringSplit($InternalArea[3][0] & "-" & $InternalArea[3][1] + 20, "-", $STR_NOCOUNT), StringSplit($InternalArea[1][0] + 30 & "-" & $InternalArea[1][1], "-", $STR_NOCOUNT))
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($PixelBottomRightDropLine) - 1
$pixel = $PixelBottomRightDropLine[$i]
Switch StringLeft(Slice8($pixel), 1)
Case "1"
$tempvectstr1 &= $pixel[0] & "-" & $pixel[1] & "|"
Case "2"
$tempvectstr2 &= $pixel[0] & "-" & $pixel[1] & "|"
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$PixelBottomRightDOWNDropLine = GetListPixel($tempvectstr1)
$PixelBottomRightUPDropLine = GetListPixel($tempvectstr2)
Setlog("> BOTTOM-RIGHT DROP LINE EDGE in  " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
$hTimer = TimerInit()
CleanRedArea($PixelTopRight)
If UBound($PixelTopRight) < 30 Then
$PixelTopRight = _GetVectorOutZone($eVectorRightTop)
EndIf
debugAttackCSV("RedArea cleaned")
debugAttackCSV("	[" & UBound($PixelTopRight) & "] pixels TopRight")
$PixelTopRightDropLine = MakeDropLine($PixelTopRight, StringSplit($InternalArea[2][0] & "-" & $InternalArea[2][1] - 25, "-", $STR_NOCOUNT), StringSplit($InternalArea[1][0] + 30 & "-" & $InternalArea[1][1], "-", $STR_NOCOUNT))
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($PixelTopRightDropLine) - 1
$pixel = $PixelTopRightDropLine[$i]
Switch StringLeft(Slice8($pixel), 1)
Case "3"
$tempvectstr1 &= $pixel[0] & "-" & $pixel[1] & "|"
Case "4"
$tempvectstr2 &= $pixel[0] & "-" & $pixel[1] & "|"
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$PixelTopRightDOWNDropLine = GetListPixel($tempvectstr1)
$PixelTopRightUPDropLine = GetListPixel($tempvectstr2)
Setlog("> TOP-RIGHT DROP LINE EDGE in  " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
$hTimer = TimerInit()
CleanRedArea($PixelTopLeft)
If UBound($PixelTopLeft) < 30 Then
$PixelTopLeft = _GetVectorOutZone($eVectorLeftTop)
EndIf
debugAttackCSV("RedArea cleaned")
debugAttackCSV("	[" & UBound($PixelTopLeft) & "] pixels TopLeft")
$PixelTopLeftDropLine = MakeDropLine($PixelTopLeft, StringSplit($InternalArea[0][0] - 30 & "-" & $InternalArea[0][1], "-", $STR_NOCOUNT), StringSplit($InternalArea[2][0] & "-" & $InternalArea[2][1] - 25, "-", $STR_NOCOUNT))
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($PixelTopLeftDropLine) - 1
$pixel = $PixelTopLeftDropLine[$i]
Switch StringLeft(Slice8($pixel), 1)
Case "6"
$tempvectstr1 &= $pixel[0] & "-" & $pixel[1] & "|"
Case "5"
$tempvectstr2 &= $pixel[0] & "-" & $pixel[1] & "|"
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$PixelTopLeftDOWNDropLine = GetListPixel($tempvectstr1)
$PixelTopLeftUPDropLine = GetListPixel($tempvectstr2)
Setlog("> TOP-LEFT DROP LINE EDGE in  " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
$hTimer = TimerInit()
CleanRedArea($PixelBottomLeft)
If UBound($PixelBottomLeft) < 30 Then
$PixelBottomLeft = _GetVectorOutZone($eVectorLeftBottom)
EndIf
debugAttackCSV("RedArea cleaned")
debugAttackCSV("	[" & UBound($PixelBottomLeft) & "] pixels BottomLeft")
$PixelBottomLeftDropLine = MakeDropLine($PixelBottomLeft, StringSplit($InternalArea[0][0] - 30 & "-" & $InternalArea[0][1], "-", $STR_NOCOUNT), StringSplit($InternalArea[3][0] & "-" & $InternalArea[3][1] + 20, "-", $STR_NOCOUNT))
Local $tempvectstr1 = ""
Local $tempvectstr2 = ""
For $i = 0 To UBound($PixelBottomLeftDropLine) - 1
$pixel = $PixelBottomLeftDropLine[$i]
Switch StringLeft(Slice8($pixel), 1)
Case "8"
$tempvectstr1 &= $pixel[0] & "-" & $pixel[1] & "|"
Case "7"
$tempvectstr2 &= $pixel[0] & "-" & $pixel[1] & "|"
EndSwitch
Next
If StringLen($tempvectstr1) > 0 Then $tempvectstr1 = StringLeft($tempvectstr1, StringLen($tempvectstr1) - 1)
If StringLen($tempvectstr2) > 0 Then $tempvectstr2 = StringLeft($tempvectstr2, StringLen($tempvectstr2) - 1)
$PixelBottomLeftDOWNDropLine = GetListPixel($tempvectstr1)
$PixelBottomLeftUPDropLine = GetListPixel($tempvectstr2)
Setlog("> BOTTOM-LEFT DROP LINE EDGE in  " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_BLUE)
If _Sleep($iDelayRespond) Then Return
EndFunc
Func AttackCSVDEBUGIMAGE()
DebugImageSave("clean")
_CaptureRegion()
Local $EditedImage = $hBitmap
Local $testx
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($EditedImage)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $hPenLtGreen = _GDIPlus_PenCreate(0xFF00DC00, 2)
Local $hPenDkGreen = _GDIPlus_PenCreate(0xFF006E00, 2)
Local $hPenMdGreen = _GDIPlus_PenCreate(0xFF4CFF00, 2)
Local $hPenRed = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $hPenDkRed = _GDIPlus_PenCreate(0xFF6A0000, 2)
Local $hPenBlue = _GDIPlus_PenCreate(0xFF0026FF, 2)
Local $hPenCyan = _GDIPlus_PenCreate(0xFF00FFFF, 2)
Local $hPenYellow = _GDIPlus_PenCreate(0xFFFFD800, 2)
Local $hPenLtGrey = _GDIPlus_PenCreate(0xFFCCCCCC, 2)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[0][0], $ExternalArea[0][1], $ExternalArea[2][0], $ExternalArea[2][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[0][0], $ExternalArea[0][1], $ExternalArea[3][0], $ExternalArea[3][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[1][0], $ExternalArea[1][1], $ExternalArea[2][0], $ExternalArea[2][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[1][0], $ExternalArea[1][1], $ExternalArea[3][0], $ExternalArea[3][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[0][0], $InternalArea[0][1], $InternalArea[2][0], $InternalArea[2][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[0][0], $InternalArea[0][1], $InternalArea[3][0], $InternalArea[3][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[1][0], $InternalArea[1][1], $InternalArea[2][0], $InternalArea[2][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[1][0], $InternalArea[1][1], $InternalArea[3][0], $InternalArea[3][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $InternalArea[2][0], 0, $InternalArea[2][0], $DEFAULT_HEIGHT, $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, $InternalArea[0][1], $DEFAULT_WIDTH, $InternalArea[0][1], $hPenDkGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[4][0], $ExternalArea[4][1], $ExternalArea[7][0], $ExternalArea[7][1], $hPenLtGreen)
_GDIPlus_GraphicsDrawLine($hGraphic, $ExternalArea[5][0], $ExternalArea[5][1], $ExternalArea[6][0], $ExternalArea[6][1], $hPenLtGreen)
For $i = 0 To UBound($PixelTopLeft) - 1
$pixel = $PixelTopLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($PixelTopRight) - 1
$pixel = $PixelTopRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($PixelBottomLeft) - 1
$pixel = $PixelBottomLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($PixelBottomRight) - 1
$pixel = $PixelBottomRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenRed)
Next
For $i = 0 To UBound($PixelTopLeftDropLine) - 1
$pixel = $PixelTopLeftDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($PixelTopRightDropLine) - 1
$pixel = $PixelTopRightDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($PixelBottomLeftDropLine) - 1
$pixel = $PixelBottomLeftDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($PixelBottomRightDropLine) - 1
$pixel = $PixelBottomRightDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
For $i = 0 To UBound($PixelTopLeftDOWNDropLine) - 1
$pixel = $PixelTopLeftDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($PixelTopLeftUPDropLine) - 1
$pixel = $PixelTopLeftUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($PixelBottomLeftDOWNDropLine) - 1
$pixel = $PixelBottomLeftDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($PixelBottomLeftUPDropLine) - 1
$pixel = $PixelBottomLeftUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
For $i = 0 To UBound($PixelTopRightDOWNDropLine) - 1
$pixel = $PixelTopRightDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenBlue)
Next
For $i = 0 To UBound($PixelTopRightUPDropLine) - 1
$pixel = $PixelTopRightUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenCyan)
Next
For $i = 0 To UBound($PixelBottomRightDOWNDropLine) - 1
$pixel = $PixelBottomRightDOWNDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenYellow)
Next
For $i = 0 To UBound($PixelBottomRightUPDropLine) - 1
$pixel = $PixelBottomRightUPDropLine[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPenLtGrey)
Next
$testx = MakeDropPoints("TOP-LEFT-DOWN", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-LEFT-DOWN", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-UP", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-UP", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-RIGHT-DOWN", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-RIGHT-DOWN", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-UP", 10, 2, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-UP", 10, 4, "EXT-INT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-LEFT-UP", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-LEFT-UP", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-DOWN", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-LEFT-DOWN", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("TOP-RIGHT-UP", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("TOP-RIGHT-UP", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-DOWN", 10, 2, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0], $pixel[1], "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenRed)
Next
$testx = MakeDropPoints("BOTTOM-RIGHT-DOWN", 10, 4, "INT-EXT")
For $i = 0 To UBound($testx) - 1
$pixel = $testx[$i]
_GDIPlus_GraphicsDrawString($hGraphic, $i + 1, $pixel[0] - 10, $pixel[1] - 10, "Arial", 12)
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 6, 6, $hPenMdGreen)
Next
For $i = 0 To UBound($PixelMine) - 1
$pixel = $PixelMine[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenLtGreen)
Next
For $i = 0 To UBound($PixelElixir) - 1
$pixel = $PixelElixir[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenDkGreen)
Next
For $i = 0 To UBound($PixelDarkElixir) - 1
$pixel = $PixelDarkElixir[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $pixel[0] - 10, $pixel[1] - 10, 20, 20, $hPenDkRed)
Next
_GDIPlus_GraphicsDrawRect($hGraphic, $THX - 15, $THY - 15, 30, 30, $hPenRed)
_GDIPlus_GraphicsDrawString($hGraphic, "1", 580, 580, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "2", 750, 450, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "3", 750, 200, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "4", 580, 110, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "5", 260, 110, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "6", 110, 200, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "7", 110, 450, "Arial", 20)
_GDIPlus_GraphicsDrawString($hGraphic, "8", 310, 580, "Arial", 20)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = String("AttackDebug_" & $Date & "_" & $Time)
_GDIPlus_ImageSaveToFile($EditedImage, $dirTempDebug & $filename & ".jpg")
_GDIPlus_PenDispose($hPenLtGreen)
_GDIPlus_PenDispose($hPenDkGreen)
_GDIPlus_PenDispose($hPenMdGreen)
_GDIPlus_PenDispose($hPenRed)
_GDIPlus_PenDispose($hPenDkRed)
_GDIPlus_PenDispose($hPenBlue)
_GDIPlus_PenDispose($hPenCyan)
_GDIPlus_PenDispose($hPenYellow)
_GDIPlus_PenDispose($hPenLtGrey)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
EndFunc
Func CheckCsvValues($instruction, $variablenumber, $variable)
Switch $instruction
Case "MAKE"
Switch $variablenumber
Case 1
If $variable = "RANDOM" Then
Return True
Else
Local $vect1 = StringSplit($variable, "-", 2)
If UBound($vect1) = 0 Then
If StringLen($vect1) = 1 Then
If (Asc($vect1[$i]) >= 65 And Asc($vect1[$i]) <= 90) Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
Else
For $i = 0 To UBound($vect1) - 1
Local $tempstr = $vect1[$i]
If StringLen($tempstr) <> 1 Then
Return False
Else
If Not (Asc($vect1[$i]) >= 65 And Asc($vect1[$i]) <= 90) Then Return False
EndIf
Next
Return True
EndIf
EndIf
Case 2
Switch $variable
Case "FRONT-LEFT"
Return True
Case "FRONT-RIGHT"
Return True
Case "RIGHT-FRONT"
Return True
Case "RIGHT-BACK"
Return True
Case "LEFT-FRONT"
Return True
Case "LEFT-BACK"
Return True
Case "BACK-LEFT"
Return True
Case "BACK-RIGHT"
Return True
Case "RANDOM"
Return True
EndSwitch
Case 5
Switch $variable
Case "EXT-INT"
Return True
Case "INT-EXT"
Return True
Case Else
Return False
EndSwitch
EndSwitch
EndSwitch
Return False
EndFunc
Func debugAttackCSV($string)
If $debugAttackCSV = 1 Then
Local $hfile = FileOpen($dirLogs & "debugAttackCSV.log", $FO_APPEND)
_FileWriteLog($hfile, $string)
FileClose($hfile)
EndIf
EndFunc
Func DropTroopFromINI($vectors, $indexStart, $indexEnd, $indexArray, $qtaMin, $qtaMax, $troopName, $delayPointmin, $delayPointmax, $delayDropMin, $delayDropMax, $sleepafterMin, $sleepAfterMax, $debug = False)
If IsArray($indexArray) = 0 Then
debugAttackCSV("drop using vectors " & $vectors & " index " & $indexStart & "-" & $indexEnd & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
Else
debugAttackCSV("drop using vectors " & $vectors & " index " & _ArrayToString($indexArray, ",") & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
EndIf
debugAttackCSV(" - delay for multiple troops in same point: " & $delayPointmin & "-" & $delayPointmax)
debugAttackCSV(" - delay when  change deploy point : " & $delayDropMin & "-" & $delayDropMax)
debugAttackCSV(" - delay after drop all troops : " & $sleepafterMin & "-" & $sleepAfterMax)
Local $temp = StringSplit($vectors, "-")
Local $numbersOfVectors
If UBound($temp) > 0 Then
$numbersOfVectors = $temp[0]
Else
$numbersOfVectors = 0
EndIf
Local $vector1, $vector2, $vector3, $vector4
If UBound($temp) > 0 Then
If $temp[0] >= 1 Then $vector1 = "ATTACKVECTOR_" & $temp[1]
If $temp[0] >= 2 Then $vector2 = "ATTACKVECTOR_" & $temp[2]
If $temp[0] >= 3 Then $vector3 = "ATTACKVECTOR_" & $temp[3]
If $temp[0] >= 4 Then $vector4 = "ATTACKVECTOR_" & $temp[4]
Else
$vector1 = $vectors
EndIf
If $qtaMin <> $qtaMax Then
Local $qty = Random($qtaMin, $qtaMax, 1)
Else
Local $qty = $qtaMin
EndIf
debugAttackCSV(">> qty to deploy: " & $qty)
Local $qtyxpoint = Int($qty / ($indexEnd - $indexStart + 1))
Local $extraunit = Mod($qty, ($indexEnd - $indexStart + 1))
debugAttackCSV(">> qty x point: " & $qtyxpoint)
debugAttackCSV(">> qty extra: " & $extraunit)
Local $troopPosition = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = Eval("e" & $troopName) Then
$troopPosition = $i
EndIf
Next
Local $usespell = True
Switch Eval("e" & $troopName)
Case $eLSpell
If $ichkLightSpell[$iMatchMode] = 0 Then $usespell = False
Case $eHSpell
If $ichkHealSpell[$iMatchMode] = 0 Then $usespell = False
Case $eRSpell
If $ichkRageSpell[$iMatchMode] = 0 Then $usespell = False
Case $eJSpell
If $ichkJumpSpell[$iMatchMode] = 0 Then $usespell = False
Case $eFSpell
If $ichkFreezeSpell[$iMatchMode] = 0 Then $usespell = False
Case $ePSpell
If $ichkPoisonSpell[$iMatchMode] = 0 Then $usespell = False
Case $eESpell
If $ichkEarthquakeSpell[$iMatchMode] = 0 Then $usespell = False
Case $eHaSpell
If $ichkHasteSpell[$iMatchMode] = 0 Then $usespell = False
EndSwitch
If $troopPosition = -1 Or $usespell = False Then
If $usespell = True Then
Setlog("No troop found in your attack troops list")
debugAttackCSV("No troop found in your attack troops list")
Else
If $DebugSetLog = 1 Then SetLog("discard use spell", $COLOR_DEBUG)
EndIf
Else
SelectDropTroop($troopPosition)
Local $tempquant = 0
For $i = $indexStart To $indexEnd
Local $delayDrop = 0
Local $index = $i
Local $indexMax = $indexEnd
If IsArray($indexArray) = 1 Then
$index = $indexArray[$i]
$indexMax = $indexArray[$indexEnd]
EndIf
If $index <> $indexMax Then
If $delayDropMin <> $delayDropMax Then
$delayDrop = Random($delayDropMin, $delayDropMax, 1)
Else
$delayDrop = $delayDropMin
EndIf
debugAttackCSV(">> delay change drop point: " & $delayDrop)
EndIf
For $j = 1 To $numbersOfVectors
Local $delayDropLast = 0
If $j = $numbersOfVectors Then $delayDropLast = $delayDrop
If $index <= UBound(Execute("$" & Eval("vector" & $j))) Then
$pixel = Execute("$" & Eval("vector" & $j) & "[" & $index - 1 & "]")
Local $qty2 = $qtyxpoint
If $index < $indexStart + $extraunit Then $qty2 += 1
If $delayPointmin <> $delayPointmax Then
Local $delayPoint = Random($delayPointmin, $delayPointmax, 1)
Else
Local $delayPoint = $delayPointmin
EndIf
local $plural = 0
If $qty2 > 1 then $plural = 1
Switch Eval("e" & $troopName)
Case $eBarb To $eBowl
If $debug = True Then
Setlog("AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0666")
$tempquant += $qty2
If $tempquant > 0 and $i = $indexEnd then Setlog(" Â» Try to Deploy " & $tempquant & " of "& NameOfTroop(Eval("e" & $troopName), $plural))
EndIf
Case $eKing
If $debug = True Then
Setlog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ", " & $King & ", -1, -1) ")
Else
dropHeroes($pixel[0], $pixel[1], $King, -1, -1)
EndIf
Case $eQueen
If $debug = True Then
Setlog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ",-1," & $Queen & ", -1) ")
Else
dropHeroes($pixel[0], $pixel[1], -1, $Queen, -1)
EndIf
Case $eWarden
If $debug = True Then
Setlog("dropHeroes(" & $pixel[0] & ", " & $pixel[1] & ", -1, -1," & $Warden & ") ")
Else
dropHeroes($pixel[0], $pixel[1], -1, -1, $Warden)
EndIf
Case $eCastle
If $debug = True Then
Setlog("dropCC(" & $pixel[0] & ", " & $pixel[1] & ", " & $CC & ")")
Else
dropCC($pixel[0], $pixel[1], $CC)
EndIf
Case $eLSpell To $eSkSpell
If $debug = True Then
Setlog("Drop Spell AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0667")
If $qty2 > 0 then Setlog(" Â» Deploying " & $qty2 & " of "& NameOfTroop(Eval("e" & $troopName), $plural))
EndIf
Case Else
Setlog("Error parsing line")
EndSwitch
debugAttackCSV($troopName & " qty " & $qty2 & " in (" & $pixel[0] & "," & $pixel[1] & ") delay " & $delayPoint)
EndIf
Next
Next
ReleaseClicks()
Local $sleepafter = 0
If $sleepafterMin <> $sleepAfterMax Then
$sleepafter = Random($sleepafterMin, $sleepAfterMax, 1)
Else
$sleepafter = Int($sleepafterMin)
EndIf
If $sleepafter > 0 And IsKeepClicksActive() = False Then
debugAttackCSV(">> delay after drop all troops: " & $sleepafter)
If $sleepafter <= 1000 Then
If _Sleep($sleepafter) Then Return
CheckHeroesHealth()
Else
For $z = 1 To Int($sleepafter/1000)
If _Sleep(980) Then Return
CheckHeroesHealth()
Next
If _Sleep(Mod($sleepafter,1000)) Then Return
CheckHeroesHealth()
EndIf
EndIf
EndIf
EndFunc
Global $debugDropSCommand = 0, $LocateMode = 1
Func DropSpellFromINIOnDefense($Defense, $options, $qtaMin, $qtaMax, $troopName, $delayPointmin, $delayPointmax, $delayDropMin, $delayDropMax, $sleepafterMin, $sleepAfterMax, $debug = False)
If $debugDropSCommand = 1 Then SetLog("Func DropSpellFromINIOnDefense(" & $Defense & ", " & $options & ")", $COLOR_DEBUG)
debugAttackCSV("drop using Defense " & $Defense & " and using " & $qtaMin & "-" & $qtaMax & " of " & $troopName)
debugAttackCSV(" - delay for multiple troops in same point: " & $delayPointmin & "-" & $delayPointmax)
debugAttackCSV(" - delay when  change deploy point : " & $delayDropMin & "-" & $delayDropMax)
debugAttackCSV(" - delay after drop all troops : " & $sleepafterMin & "-" & $sleepAfterMax)
$FullDefenseName = GetFullDefenseName($Defense)
If $qtaMin <> $qtaMax Then
Local $qty = Random($qtaMin, $qtaMax, 1)
Else
Local $qty = $qtaMin
EndIf
debugAttackCSV(">> qty to deploy: " & $qty)
Local $qtyxpoint = Int($qty)
debugAttackCSV(">> qty x point: " & $qtyxpoint)
Local $troopPosition = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = Eval("e" & $troopName) Then
$troopPosition = $i
EndIf
Next
Local $usespell = True
Switch Eval("e" & $troopName)
Case $eLSpell
If $ichkLightSpell[$iMatchMode] = 0 Then $usespell = False
Case $eHSpell
If $ichkHealSpell[$iMatchMode] = 0 Then $usespell = False
Case $eRSpell
If $ichkRageSpell[$iMatchMode] = 0 Then $usespell = False
Case $eJSpell
If $ichkJumpSpell[$iMatchMode] = 0 Then $usespell = False
Case $eFSpell
If $ichkFreezeSpell[$iMatchMode] = 0 Then $usespell = False
Case $ePSpell
If $ichkPoisonSpell[$iMatchMode] = 0 Then $usespell = False
Case $eESpell
If $ichkEarthquakeSpell[$iMatchMode] = 0 Then $usespell = False
Case $eHaSpell
If $ichkHasteSpell[$iMatchMode] = 0 Then $usespell = False
EndSwitch
If $troopPosition = -1 Or $usespell = False Then
If $usespell = True Then
Setlog("No troop found in your attack troops list")
debugAttackCSV("No troop found in your attack troops list")
Else
If $DebugSetLog = 1 Then SetLog("discard use spell", $COLOR_DEBUG)
EndIf
Else
SelectDropTroop($troopPosition)
Local $tempquant = 0
If $delayDropMin <> $delayDropMax Then
$delayDrop = Random($delayDropMin, $delayDropMax, 1)
Else
$delayDrop = $delayDropMin
EndIf
Local $delayDropLast = 0
$delayDropLast = $delayDrop
$DefenseResult = AssignPixelOfDefense($Defense, $options)
Local $pixel[2] = [$DefenseResult[4], $DefenseResult[5]]
If $DefenseResult[1] = False Then
CheckHeroesHealth()
ReleaseClicks()
Return
EndIf
If IsArray($pixel) Then
If UBound($pixel) >= 2 Then
If $pixel[1] <= 0 Then
CheckHeroesHealth()
ReleaseClicks()
Return
EndIf
EndIf
EndIf
If $DefenseResult[3] <> "" Then SetLog($DefenseResult[3])
If $debugDropSCommand = 1 And IsArray($pixel) Then SetLog("$pixel[0] = " & $pixel[0] & " $pixel[1] = " & $pixel[1])
Local $qty2 = $qtyxpoint
If $delayPointmin <> $delayPointmax Then
Local $delayPoint = Random($delayPointmin, $delayPointmax, 1)
Else
Local $delayPoint = $delayPointmin
EndIf
Local $plural = 0
If $qty2 > 1 Then $plural = 1
Switch Eval("e" & $troopName)
Case $eLSpell To $eSkSpell
If $debug = True Then
Setlog("Drop Spell AttackClick( " & $pixel[0] & ", " & $pixel[1] & " , " & $qty2 & ", " & $delayPoint & ",#0666)")
Else
AttackClick($pixel[0], $pixel[1], $qty2, $delayPoint, $delayDropLast, "#0667")
If $qty2 > 0 And $DefenseResult[1] = True Then Setlog(" Â» Dropping " & $qty2 & " of " & NameOfTroop(Eval("e" & $troopName), $plural) &  IIf($DefenseResult[2] = True, " Between ", "") & IIf($DefenseResult[2] = True, $FullDefenseName, " On " & $FullDefenseName) & IIf($DefenseResult[2] = True, "(s)", ""))
EndIf
Case Else
Setlog("Error parsing line")
EndSwitch
debugAttackCSV($troopName & " qty " & $qty2 & " in (" & $pixel[0] & "," & $pixel[1] & ") delay " & $delayPoint)
ReleaseClicks()
Local $sleepafter = 0
If $sleepafterMin <> $sleepAfterMax Then
$sleepafter = Random($sleepafterMin, $sleepAfterMax, 1)
Else
$sleepafter = Int($sleepafterMin)
EndIf
If $sleepafter > 0 And IsKeepClicksActive() = False Then
debugAttackCSV(">> delay after drop all troops: " & $sleepafter)
If $sleepafter <= 1000 Then
If _Sleep($sleepafter) Then Return
CheckHeroesHealth()
Else
For $z = 1 To Int($sleepafter / 1000)
If _Sleep(980) Then Return
CheckHeroesHealth()
Next
If _Sleep(Mod($sleepafter, 1000)) Then Return
CheckHeroesHealth()
EndIf
EndIf
EndIf
EndFunc
Func GetFullDefenseName($Defense)
If $debugDropSCommand = 1 Then SetLog("Func GetFullDefenseName(" & $Defense & ")", $COLOR_DEBUG)
Select
Case $Defense = "EAGLE"
Return "Eagle"
Case $Defense = "INFERNO"
Return "Inferno Tower"
Case $Defense = "ADEFENSE"
Return "Air Defense"
Case Else
Return "Unknown Defense"
EndSelect
EndFunc
Func AssignPixelOfDefense($Defense, $options, $forceReLocate = False)
If $debugDropSCommand = 1 Then SetLog("Func AssignPixelOfDefense(" & $Defense & ", " & $options & ", " & $forceReLocate & ")", $COLOR_DEBUG)
Local $LocateResult
Switch $forceReLocate
Case True
ResetDefensesLocation($Defense)
$LocateResult = LocateDefense($Defense, $options)
Case Else
$LocateResult = LocateDefense($Defense, $options)
EndSwitch
Switch $Defense
Case "EAGLE"
_ArrayMerge($LocateResult, $PixelEaglePos)
Return $LocateResult
Case "INFERNO"
_ArrayMerge($LocateResult, $PixelInfernoPos)
Return $LocateResult
Case "ADEFENSE"
_ArrayMerge($LocateResult, $PixelADefensePos)
Return $LocateResult
EndSwitch
EndFunc
Func ResetDefensesLocation($Defense = "")
If $debugDropSCommand = 1 Then SetLog("Func ResetDefensesLocation(" & $Defense & ")", $COLOR_DEBUG)
Select
Case $LocateMode = 1 Or $Defense <> ""
Switch $Defense
Case ""
$PixelEaglePos[0] = -1
$PixelEaglePos[1] = -1
$PixelInfernoPos[0] = -1
$PixelInfernoPos[1] = -1
$PixelADefensePos[0] = -1
$PixelADefensePos[1] = -1
Case "EAGLE"
$PixelEaglePos[0] = -1
$PixelEaglePos[1] = -1
Case "INFERNO"
$PixelInfernoPos[0] = -1
$PixelInfernoPos[1] = -1
Case "ADEFENSE"
$PixelADefensePos[0] = -1
$PixelADefensePos[1] = -1
EndSwitch
Case Else
Switch $Defense
Case ""
ReDim $AllPixelEaglePos[1][3]
ReDim $AllPixelInfernoPos[1][3]
ReDim $AllPixelADefensePos[1][3]
$AllPixelEaglePos[0][0] = -1
$AllPixelEaglePos[0][1] = -1
$AllPixelEaglePos[0][2] = -1
$AllPixelInfernoPos[0][0] = -1
$AllPixelInfernoPos[0][1] = -1
$AllPixelInfernoPos[0][2] = -1
$AllPixelADefensePos[0][0] = -1
$AllPixelADefensePos[0][1] = -1
$AllPixelADefensePos[0][2] = -1
$PixelEaglePos[0] = -1
$PixelEaglePos[1] = -1
$PixelInfernoPos[0] = -1
$PixelInfernoPos[1] = -1
$PixelADefensePos[0] = -1
$PixelADefensePos[1] = -1
Case "EAGLE"
ReDim $AllPixelEaglePos[1][3]
$AllPixelEaglePos[0][0] = -1
$AllPixelEaglePos[0][1] = -1
$AllPixelEaglePos[0][2] = -1
$PixelEaglePos[0] = -1
$PixelEaglePos[1] = -1
Case "INFERNO"
ReDim $AllPixelInfernoPos[1][3]
$AllPixelInfernoPos[0][0] = -1
$AllPixelInfernoPos[0][1] = -1
$AllPixelInfernoPos[0][2] = -1
$PixelInfernoPos[0] = -1
$PixelInfernoPos[1] = -1
Case "ADEFENSE"
ReDim $AllPixelADefensePos[1][3]
$AllPixelADefensePos[0][0] = -1
$AllPixelADefensePos[0][1] = -1
$AllPixelADefensePos[0][2] = -1
$PixelADefensePos[0] = -1
$PixelADefensePos[1] = -1
EndSwitch
EndSelect
EndFunc
Func isLocatedBefore($Defense)
If $debugDropSCommand = 1 Then SetLog("Func isLocatedBefore(" & $Defense & ")", $COLOR_DEBUG)
Select
Case $LocateMode = 1
Switch $Defense
Case "EAGLE"
If $PixelEaglePos[0] > 0 Then
If $PixelEaglePos[1] > 0 Then Return True
Return False
Else
Return False
EndIf
Case "INFERNO"
If $PixelInfernoPos[0] > 0 Then
If $PixelInfernoPos[1] > 0 Then Return True
Return False
Else
Return False
EndIf
Case "ADEFENSE"
If $PixelADefensePos[0] > 0 Then
If $PixelADefensePos[1] > 0 Then Return True
Return False
Else
Return False
EndIf
EndSwitch
Case Else
Switch $Defense
Case "EAGLE"
If $AllPixelEaglePos[0][0] > 0 Then
If $AllPixelEaglePos[0][1] > 0 Then Return True
Return False
Else
Return False
EndIf
Case "INFERNO"
If $AllPixelInfernoPos[0][0] > 0 Then
If $AllPixelInfernoPos[0][1] > 0 Then Return True
Return False
Else
Return False
EndIf
Case "ADEFENSE"
If $AllPixelADefensePos[0][0] > 0 Then
If $AllPixelADefensePos[0][1] > 0 Then Return True
Return False
Else
Return False
EndIf
EndSwitch
EndSelect
EndFunc
Func LocateDefense($Defense, $options)
If $debugDropSCommand = 1 Then SetLog("Func LocateDefense(" & $Defense & ", " & $options & ")", $COLOR_DEBUG)
Local $Result[4] = [False, False, False, ""]
Local $ParsedOptions = ParseCommandOptions($options)
Local $RandomizeDropPoint = $ParsedOptions[0]
Local $SideCondition = $ParsedOptions[1]
Local $DropBetween = $ParsedOptions[2]
Switch $Defense
Case "EAGLE"
$hTimer = TimerInit()
Local $directory = @ScriptDir & "\images\WeakBase\Eagle"
Local $return
Local $reLocated = False
If $LocateMode = 1 Then
$return = returnAllMatchesDefense($directory)
$reLocated = True
ElseIf $LocateMode = 2 Then
If isLocatedBefore($Defense) = True Then
$return = ReturnSavedPositions($Defense)
Else
$return = returnAllMatchesDefense($directory)
$reLocated = True
SavePositions($Defense, $return)
EndIf
EndIf
Local $splitedPositions = StringSplit($return, "|", 2)
If Not (UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2) Then DebugImageSave("EagleDetection_NotDetected_", True)
Local $theEagleSide = ""
Local $NotdetectedEagle = True
$Counter = -1
For $eachPos In $splitedPositions
$splitedEachPos = StringSplit($eachPos, ",", 2)
If IsArray($splitedEachPos) And UBound($splitedEachPos) > 1 Then
$Counter += 1
If $debugDropSCommand = 1 Then SetLog("$SideCondition = " & $SideCondition, $COLOR_DEBUG)
If IsSameColor($Defense, $Counter, $splitedEachPos[0], $splitedEachPos[1], $Counter = 0, False, $reLocated) = True Then
Select
Case $SideCondition = "AnySide"
$PixelEaglePos[0] = $splitedEachPos[0]
$PixelEaglePos[1] = $splitedEachPos[1]
$NotdetectedEagle = False
ExitLoop
Case $SideCondition = "SameSide" Or $SideCondition = "OtherSide"
$sliced = Slice8($splitedEachPos)
If $debugDropSCommand = 1 Then SetLog("$sliced = " & $sliced, $COLOR_BLUE)
Switch StringLeft($sliced, 1)
Case 1, 2
$theEagleSide = "BOTTOM"
Case 3, 4
$theEagleSide = "TOP"
Case 5, 6
$theEagleSide = "TOP"
Case 7, 8
$theEagleSide = "BOTTOM"
EndSwitch
$curMainSide = StringSplit($MAINSIDE, "-", 2)[0]
If $debugDropSCommand = 1 Then SetLog("$curMainSide = " & $curMainSide, $COLOR_ORANGE)
If $debugDropSCommand = 1 Then SetLog("$theEagleSide = " & $theEagleSide, $COLOR_ORANGE)
If $SideCondition = "SameSide" Then
If $theEagleSide = $curMainSide Then
$PixelEaglePos[0] = $splitedEachPos[0]
$PixelEaglePos[1] = $splitedEachPos[1]
$NotdetectedEagle = False
ExitLoop
EndIf
Else
If $theEagleSide <> $curMainSide Then
$PixelEaglePos[0] = $splitedEachPos[0]
$PixelEaglePos[1] = $splitedEachPos[1]
$NotdetectedEagle = False
ExitLoop
EndIf
EndIf
EndSelect
Else
$PixelEaglePos[0] = -1
$PixelEaglePos[1] = -1
EndIf
EndIf
Next
If $NotdetectedEagle = False Then
$rToDecreaseX = 4
$rToIncreaseY = 11
If $RandomizeDropPoint = True Then
$rToDecreaseX = Random(0, 8, 1)
$rToIncreaseY = Random(0, 19, 1)
EndIf
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseX = " & $rToDecreaseX)
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseY = " & $rToIncreaseY)
$PixelEaglePos[0] -= $rToDecreaseX
$PixelEaglePos[1] += $rToIncreaseY
EndIf
If UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2 Then
$Result[0] = True
Setlog(" Â»Â» Eagle located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
Else
FlagAsUnDetected($Result)
EndIf
Switch $SideCondition
Case "SameSide"
If $NotdetectedEagle = False Then
$Result[1] = True
SetLog("Eagle Detected in Same Side")
Else
FlagAsUnDetected($Result)
SetLog("No Eagle Detected in same side", $COLOR_ORANGE)
EndIf
Case "OtherSide"
If $NotdetectedEagle = False Then
$Result[1] = True
SetLog("Eagle Detected in the Other Side")
Else
FlagAsUnDetected($Result)
SetLog("No Eagle Detected in the other side", $COLOR_ORANGE)
EndIf
Case "AnySide"
If $NotdetectedEagle = False Then
$Result[1] = True
SetLog("Eagle Detected")
Else
FlagAsUnDetected($Result)
SetLog("No Eagle Detected at all", $COLOR_ORANGE)
EndIf
EndSwitch
Return $Result
Case "INFERNO"
$hTimer = TimerInit()
Local $directory = @ScriptDir & "\images\WeakBase\Infernos"
Local $return
Local $reLocated = False
If $LocateMode = 1 Then
$return = returnAllMatchesDefense($directory)
$reLocated = True
ElseIf $LocateMode = 2 Then
If isLocatedBefore($Defense) = True Then
$return = ReturnSavedPositions($Defense)
Else
$return = returnAllMatchesDefense($directory)
$reLocated = True
SavePositions($Defense, $return)
EndIf
EndIf
Local $splitedPositions = StringSplit($return, "|", 2)
If Not (UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2) Then DebugImageSave("InfernoDetection_NotDetected_", True)
Local $theInfernoSide = ""
Local $NotdetectedInferno = True
$Counter = -1
For $eachPos In $splitedPositions
$splitedEachPos = StringSplit($eachPos, ",", 2)
If IsArray($splitedEachPos) And UBound($splitedEachPos) > 1 Then
$Counter += 1
If $debugDropSCommand = 1 Then SetLog("$SideCondition = " & $SideCondition, $COLOR_DEBUG)
If IsSameColor($Defense, $Counter, $splitedEachPos[0], $splitedEachPos[1], $Counter = 0, False, $reLocated) = True Then
Select
Case $SideCondition = "AnySide"
$PixelInfernoPos[0] = $splitedEachPos[0]
$PixelInfernoPos[1] = $splitedEachPos[1]
$NotdetectedInferno = False
ExitLoop
Case $SideCondition = "SameSide" Or $SideCondition = "OtherSide"
$sliced = Slice8($splitedEachPos)
If $debugDropSCommand = 1 Then SetLog("$sliced = " & $sliced, $COLOR_BLUE)
Switch StringLeft($sliced, 1)
Case 1, 2
$theInfernoSide = "BOTTOM"
Case 3, 4
$theInfernoSide = "TOP"
Case 5, 6
$theInfernoSide = "TOP"
Case 7, 8
$theInfernoSide = "BOTTOM"
EndSwitch
$curMainSide = StringSplit($MAINSIDE, "-", 2)[0]
If $debugDropSCommand = 1 Then SetLog("$curMainSide = " & $curMainSide, $COLOR_ORANGE)
If $debugDropSCommand = 1 Then SetLog("$theInfernoSide = " & $theInfernoSide, $COLOR_ORANGE)
If $SideCondition = "SameSide" Then
If $theInfernoSide = $curMainSide Then
$PixelInfernoPos[0] = $splitedEachPos[0]
$PixelInfernoPos[1] = $splitedEachPos[1]
$NotdetectedInferno = False
ExitLoop
EndIf
Else
If $theInfernoSide <> $curMainSide Then
$PixelInfernoPos[0] = $splitedEachPos[0]
$PixelInfernoPos[1] = $splitedEachPos[1]
$NotdetectedInferno = False
ExitLoop
EndIf
EndIf
EndSelect
Else
$PixelInfernoPos[0] = -1
$PixelInfernoPos[1] = -1
EndIf
EndIf
Next
Local $isNearToTheOtherOne = IsInfernoTowersNearToTheOtherOne($splitedPositions, $DropBetween)
If $NotdetectedInferno = True And $isNearToTheOtherOne[4] = True Then
If $debugDropSCommand = 1 Then SetLog("Near To The Other One Is True But No Inferno Towers Detected!!!, Disabling Drop Between...")
$isNearToTheOtherOne[4] = False
EndIf
If $isNearToTheOtherOne[4] = True And $NotdetectedInferno = False Then
If $isNearToTheOtherOne[0] = True Then
$PixelInfernoPos[0] += (($isNearToTheOtherOne[2] / 2) + 0 + IIf($RandomizeDropPoint = True, Random(0, 5, 1), 0))
Else
$PixelInfernoPos[0] -= (($isNearToTheOtherOne[2] / 2) - 0 - IIf($RandomizeDropPoint = True, Random(0, 5, 1), 0))
EndIf
If $isNearToTheOtherOne[1] = True Then
$PixelInfernoPos[1] += (($isNearToTheOtherOne[3] / 2) + IIf($RandomizeDropPoint = True, 7, 9) + IIf($RandomizeDropPoint = True, Random(1, 3, 1), 0))
Else
$PixelInfernoPos[1] -= (($isNearToTheOtherOne[3] / 2) - IIf($RandomizeDropPoint = True, 7, 9) - IIf($RandomizeDropPoint = True, Random(1, 3, 1), 0))
EndIf
EndIf
If $debugDropSCommand = 1 Then SetLog("$isNearToTheOtherOne[4] = " & $isNearToTheOtherOne[4], $COLOR_BLUE)
If $NotdetectedInferno = False And $isNearToTheOtherOne[4] = False Then
Local $rToDecreaseX = 4
Local $rToIncreaseY = 11
If $RandomizeDropPoint = True Then
$rToDecreaseX = Random(0, 8, 1)
$rToIncreaseY = Random(0, 19, 1)
EndIf
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseX = " & $rToDecreaseX)
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseY = " & $rToIncreaseY)
$PixelInfernoPos[0] -= $rToDecreaseX
$PixelInfernoPos[1] += $rToIncreaseY
EndIf
If UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2 Then
$Result[0] = True
Setlog(" Â»Â» " & UBound($splitedPositions) & "x Inferno Tower(s) located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
Else
FlagAsUnDetected($Result)
EndIf
Switch $SideCondition
Case "SameSide"
If $NotdetectedInferno = False Then
If $isNearToTheOtherOne[4] = False Then
$Result[1] = True
SetLog("Inferno Tower Detected in Same Side")
EndIf
If $isNearToTheOtherOne[4] = True Then
$Result[1] = True
$Result[2] = True
EndIf
Else
FlagAsUnDetected($Result)
SetLog("No Inferno Tower Detected in same side", $COLOR_ORANGE)
EndIf
Case "OtherSide"
If $NotdetectedInferno = False Then
If $isNearToTheOtherOne[4] = False Then
$Result[1] = True
SetLog("Inferno Tower Detected in the Other Side")
EndIf
If $isNearToTheOtherOne[4] = True Then
$Result[1] = True
$Result[2] = True
EndIf
Else
FlagAsUnDetected($Result)
SetLog("No Inferno Tower Detected in the other side", $COLOR_ORANGE)
EndIf
Case "AnySide"
If $NotdetectedInferno = False Then
If $isNearToTheOtherOne[4] = False Then
$Result[1] = True
SetLog("Inferno Tower Detected")
EndIf
If $isNearToTheOtherOne[4] = True Then
$Result[1] = True
$Result[2] = True
EndIf
Else
FlagAsUnDetected($Result)
SetLog("No Inferno Tower Detected at all", $COLOR_ORANGE)
EndIf
EndSwitch
Return $Result
Case "ADEFENSE"
$hTimer = TimerInit()
Local $directory = @ScriptDir & "\images\WeakBase\ADefense"
Local $return
Local $reLocated = False
If $LocateMode = 1 Then
$return = returnAllMatchesDefense($directory)
$reLocated = True
ElseIf $LocateMode = 2 Then
If isLocatedBefore($Defense) = True Then
$return = ReturnSavedPositions($Defense)
Else
$return = returnAllMatchesDefense($directory)
$reLocated = True
SavePositions($Defense, $return)
EndIf
EndIf
Local $splitedPositions = StringSplit($return, "|", 2)
If Not (UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2) Then DebugImageSave("AirDefenseDetection_NotDetected_", True)
Local $theADefenseSide = ""
Local $NotdetectedADefense = True
$Counter = -1
For $eachPos In $splitedPositions
$splitedEachPos = StringSplit($eachPos, ",", 2)
If IsArray($splitedEachPos) And UBound($splitedEachPos) > 1 Then
$Counter += 1
If $debugDropSCommand = 1 Then SetLog("$SideCondition = " & $SideCondition, $COLOR_DEBUG)
If IsSameColor($Defense, $Counter, $splitedEachPos[0], $splitedEachPos[1], $Counter = 0, False, $reLocated) = True Then
Select
Case $SideCondition = "AnySide"
$PixelADefensePos[0] = $splitedEachPos[0]
$PixelADefensePos[1] = $splitedEachPos[1]
$NotdetectedADefense = False
ExitLoop
Case $SideCondition = "SameSide" Or $SideCondition = "OtherSide"
$sliced = Slice8($splitedEachPos)
If $debugDropSCommand = 1 Then SetLog("$sliced = " & $sliced, $COLOR_BLUE)
Switch StringLeft($sliced, 1)
Case 1, 2
$theADefenseSide = "BOTTOM"
Case 3, 4
$theADefenseSide = "TOP"
Case 5, 6
$theADefenseSide = "TOP"
Case 7, 8
$theADefenseSide = "BOTTOM"
EndSwitch
$curMainSide = StringSplit($MAINSIDE, "-", 2)[0]
If $debugDropSCommand = 1 Then SetLog("$curMainSide = " & $curMainSide, $COLOR_ORANGE)
If $debugDropSCommand = 1 Then SetLog("$theADefenseSide = " & $theADefenseSide, $COLOR_ORANGE)
If $SideCondition = "SameSide" Then
If $theADefenseSide = $curMainSide Then
$PixelADefensePos[0] = $splitedEachPos[0]
$PixelADefensePos[1] = $splitedEachPos[1]
$NotdetectedADefense = False
ExitLoop
EndIf
Else
If $theADefenseSide <> $curMainSide Then
$PixelADefensePos[0] = $splitedEachPos[0]
$PixelADefensePos[1] = $splitedEachPos[1]
$NotdetectedADefense = False
ExitLoop
EndIf
EndIf
EndSelect
Else
$PixelADefensePos[0] = -1
$PixelADefensePos[1] = -1
EndIf
EndIf
Next
If $NotdetectedADefense = False Then
Local $rToDecreaseX = 4
Local $rToIncreaseY = 11
If $RandomizeDropPoint = True Then
$rToDecreaseX = Random(0, 8, 1)
$rToIncreaseY = Random(0, 19, 1)
EndIf
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseX = " & $rToDecreaseX)
If $debugDropSCommand = 1 Then SetLog("$rToDecreaseY = " & $rToIncreaseY)
$PixelADefensePos[0] -= $rToDecreaseX
$PixelADefensePos[1] += $rToIncreaseY
EndIf
If UBound($splitedPositions) >= 1 And StringLen($splitedPositions[0]) > 2 Then
$Result[0] = True
Setlog(" Â»Â» " & UBound($splitedPositions) & "x Air Defense(s) located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
Else
FlagAsUnDetected($Result)
EndIf
Switch $SideCondition
Case "SameSide"
If $NotdetectedADefense = False Then
$Result[1] = True
SetLog("Air Defense Detected in Same Side")
Else
FlagAsUnDetected($Result)
SetLog("No Air Defense Detected in same side", $COLOR_ORANGE)
EndIf
Case "OtherSide"
If $NotdetectedADefense = False Then
$Result[1] = True
SetLog("Air Defense Detected in the Other Side")
Else
FlagAsUnDetected($Result)
SetLog("No Air Defense Detected in the other side", $COLOR_ORANGE)
EndIf
Case "AnySide"
If $NotdetectedADefense = False Then
$Result[1] = True
SetLog("Air Defense Detected")
Else
FlagAsUnDetected($Result)
SetLog("No Air Defense Detected at all", $COLOR_ORANGE)
EndIf
EndSwitch
Return $Result
EndSwitch
Return $Result
EndFunc
Func FlagAsUnDetected(ByRef $Result)
For $i = 0 To (UBound($Result) - 1)
If Not $i = (UBound($Result) - 1) Then
$Result[$i] = False
Else
$Result[$i] = ""
EndIf
Next
EndFunc
Func IsSameColor($Defense, $Counter, $X, $Y, $bNeedCapture = False, $Equal = False, $bSkip = False)
If $debugDropSCommand = 1 Then SetLog("Func IsSameColor(" & $Defense & ", " & $Counter & ", " & $X & ", " & $Y & ", " & $bNeedCapture & ", " & $Equal & ", " & $bSkip & ")", $COLOR_DEBUG)
If $LocateMode = 1 Or $bSkip = True Then Return True
Select
Case $Defense = "EAGLE"
If $Equal = True Then
$CurColor = IIf($AllPixelEaglePos[$Counter][2] = _GetPixelColor($X, $Y, $bNeedCapture), True, False)
Else
$CurColor = _ColorCheck(_GetPixelColor($X, $Y, $bNeedCapture), Hex("0x" & $AllPixelEaglePos[$Counter][2], 6), 20)
EndIf
If $debugDropSCommand = 1 Then SetLog("$CurColor = " & $CurColor & "  $AllPixelEaglePos[" & $Counter & "][2] = " & $AllPixelEaglePos[$Counter][2], $COLOR_BLUE)
If $CurColor = True Then
If $debugDropSCommand = 1 Then SetLog("Pixel Colors are same", $COLOR_BLUE)
Return True
EndIf
If $debugDropSCommand = 1 Then SetLog("Pixel Colors not Same", $COLOR_ORANGE)
Return False
Case $Defense = "INFERNO"
If $Equal = True Then
$CurColor = IIf($AllPixelInfernoPos[$Counter][2] = _GetPixelColor($X, $Y, $bNeedCapture), True, False)
Else
$CurColor = _ColorCheck(_GetPixelColor($X, $Y, $bNeedCapture), Hex("0x" & $AllPixelInfernoPos[$Counter][2], 6), 40)
EndIf
If $debugDropSCommand = 1 Then SetLog("$CurColor = " & $CurColor & "  $AllPixelInfernoPos[" & $Counter & "][2] = " & $AllPixelInfernoPos[$Counter][2], $COLOR_BLUE)
If $CurColor = True Then
If $debugDropSCommand = 1 Then SetLog("Pixel Colors are same", $COLOR_BLUE)
Return True
EndIf
If $debugDropSCommand = 1 Then SetLog("Pixel Colors not Same", $COLOR_ORANGE)
Return False
Case $Defense = "ADEFENSE"
If $Equal = True Then
$CurColor = IIf($AllPixelADefensePos[$Counter][2] = _GetPixelColor($X, $Y, $bNeedCapture), True, False)
Else
$CurColor = _ColorCheck(_GetPixelColor($X, $Y, $bNeedCapture), Hex("0x" & $AllPixelADefensePos[$Counter][2], 6), 90)
EndIf
If $debugDropSCommand = 1 Then SetLog("$CurColor = " & $CurColor & "  $AllPixelADefensePos[" & $Counter & "][2] = " & $AllPixelADefensePos[$Counter][2], $COLOR_BLUE)
If $CurColor = True Then
If $debugDropSCommand = 1 Then SetLog("Pixel Colors are same", $COLOR_BLUE)
Return True
EndIf
If $debugDropSCommand = 1 Then SetLog("Pixel Colors not Same", $COLOR_ORANGE)
Return False
EndSelect
Return False
EndFunc
Func SavePositions($Defense, $return)
If $debugDropSCommand = 1 Then SetLog("Func SavePositions(" & $Defense & ", " & $return & ")", $COLOR_DEBUG)
Local $splitedPositions = StringSplit($return, "|", 2)
Select
Case $Defense = "EAGLE"
If UBound($splitedPositions) < 1 Then DebugImageSave("EagleDetection_NotDetected_", True)
$Counter = -1
For $eachPos In $splitedPositions
$splitedEachPos = StringSplit($eachPos, ",", 2)
If IsArray($splitedEachPos) And UBound($splitedEachPos) > 1 Then
ReDim $AllPixelEaglePos[UBound($AllPixelEaglePos) + 1][3]
$Counter += 1
$AllPixelEaglePos[$Counter][0] = $splitedEachPos[0]
$AllPixelEaglePos[$Counter][1] = $splitedEachPos[1]
$AllPixelEaglePos[$Counter][2] = _GetPixelColor($splitedEachPos[0], $splitedEachPos[1], True)
EndIf
Next
_ArrayDelete($AllPixelEaglePos, UBound($AllPixelEaglePos) - 1)
Case $Defense = "INFERNO"
If UBound($splitedPositions) < 1 Then DebugImageSave("InfernoDetection_NotDetected_", True)
$Counter = -1
For $eachPos In $splitedPositions
$splitedEachPos = StringSplit($eachPos, ",", 2)
If IsArray($splitedEachPos) And UBound($splitedEachPos) > 1 Then
ReDim $AllPixelInfernoPos[UBound($AllPixelInfernoPos) + 1][3]
$Counter += 1
$AllPixelInfernoPos[$Counter][0] = $splitedEachPos[0]
$AllPixelInfernoPos[$Counter][1] = $splitedEachPos[1]
$AllPixelInfernoPos[$Counter][2] = _GetPixelColor($splitedEachPos[0], $splitedEachPos[1], True)
EndIf
Next
_ArrayDelete($AllPixelInfernoPos, UBound($AllPixelInfernoPos) - 1)
Case $Defense = "ADEFENSE"
If UBound($splitedPositions) < 1 Then DebugImageSave("ADefenseDetection_NotDetected_", True)
$Counter = -1
For $eachPos In $splitedPositions
$splitedEachPos = StringSplit($eachPos, ",", 2)
If IsArray($splitedEachPos) And UBound($splitedEachPos) > 1 Then
ReDim $AllPixelADefensePos[UBound($AllPixelADefensePos) + 1][3]
$Counter += 1
$AllPixelADefensePos[$Counter][0] = $splitedEachPos[0]
$AllPixelADefensePos[$Counter][1] = $splitedEachPos[1]
$AllPixelADefensePos[$Counter][2] = _GetPixelColor($splitedEachPos[0], $splitedEachPos[1], True)
EndIf
Next
_ArrayDelete($AllPixelADefensePos, UBound($AllPixelADefensePos) - 1)
EndSelect
EndFunc
Func ReturnSavedPositions($Defense)
If $debugDropSCommand = 1 Then SetLog("Func ReturnSavedPositions(" & $Defense & ")", $COLOR_DEBUG)
Local $Result = ""
Select
Case $Defense = "EAGLE"
For $i = 0 To UBound($AllPixelEaglePos) - 1
$Result &= $AllPixelEaglePos[$i][0] & "," & $AllPixelEaglePos[$i][1] & "|"
Next
Case $Defense = "INFERNO"
For $i = 0 To UBound($AllPixelInfernoPos) - 1
$Result &= $AllPixelInfernoPos[$i][0] & "," & $AllPixelInfernoPos[$i][1] & "|"
Next
Case $Defense = "ADEFENSE"
For $i = 0 To UBound($AllPixelADefensePos) - 1
$Result &= $AllPixelADefensePos[$i][0] & "," & $AllPixelADefensePos[$i][1] & "|"
Next
EndSelect
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result, StringLen($Result) - 1)
Return $Result
EndFunc
Func ParseCommandOptions($options)
If $debugDropSCommand = 1 Then SetLog("Func ParseCommandOptions(" & $options & ")", $COLOR_DEBUG)
Local $Result[3] = [False, "", True]
Local $splitedOptions = StringSplit($options, ",", 2)
For $Opt In $splitedOptions
$optSplited = StringSplit($Opt, ":", 2)
$optArg = $optSplited[0]
$optValue = $optSplited[1]
Switch $optArg
Case "R"
If $optValue = "T" Then
$Result[0] = True
Else
$Result[0] = False
EndIf
Case "B"
If $optValue = "T" Then
$Result[2] = True
Else
$Result[2] = False
EndIf
Case "S"
Switch $optValue
Case "S"
$Result[1] = "SameSide"
Case "O"
$Result[1] = "OtherSide"
Case "A"
$Result[1] = "AnySide"
EndSwitch
EndSwitch
Next
Return $Result
EndFunc
Func IsInfernoTowersNearToTheOtherOne($positions, $DropBetween)
If $debugDropSCommand = 1 Then SetLog("Func IsInfernoTowersNearToTheOtherOne(" & $positions & ", " & $DropBetween & ")", $COLOR_DEBUG)
Local $Result[5] = [False, False, 0, 0, False]
If UBound($positions) < 2 Or $DropBetween = False Then
If $debugDropSCommand = 1 Then SetLog("UBound($positions) < 2 OR $DropBetween = False")
If $debugDropSCommand = 1 Then SetLog("UBound($positions) = " & UBound($positions))
If $debugDropSCommand = 1 Then SetLog("$DropBetween = " & $DropBetween)
Return $Result
EndIf
Local $allowedXDiff = 74, $allowedYDiff = 53
If IsArray(StringSplit($positions[0], ",", 2)) And IsArray(StringSplit($positions[1], ",", 2)) Then Return $Result
Local $firstInfernoPosition[2] = [StringSplit($positions[0], ",", 2)[0], StringSplit($positions[0], ",", 2)[1]]
Local $secondInfernoPosition[2] = [StringSplit($positions[1], ",", 2)[0], StringSplit($positions[1], ",", 2)[1]]
Local $xDiff = $firstInfernoPosition[0] - $secondInfernoPosition[0], $yDiff = $firstInfernoPosition[1] - $secondInfernoPosition[1]
If StringLeft(String($xDiff), 1) = "-" Then
$xDiff = $secondInfernoPosition[0] - $firstInfernoPosition[0]
$Result[0] = True
EndIf
If StringLeft(String($yDiff), 1) = "-" Then
$yDiff = $secondInfernoPosition[1] - $firstInfernoPosition[1]
$Result[1] = True
EndIf
$Result[2] = $xDiff
$Result[3] = $yDiff
If $xDiff <= $allowedXDiff And $yDiff <= $allowedYDiff Then
$Result[4] = True
Return $Result
EndIf
SetLog("Inferno Towers are so far from the other one, Cannot Drop Between", $COLOR_ORANGE)
Return $Result
EndFunc
Func _ArrayMerge(ByRef $a_base, ByRef $a_add, $i_start = 0)
Local $X
For $X = $i_start To UBound($a_add) - 1
_ArrayAdd($a_base, $a_add[$X])
Next
EndFunc
Func GetListPixel3($listPixel)
Local $listPixelSideStr = StringSplit($listPixel, "|")
If ($listPixelSideStr[0] > 1) Then
Local $listPixelSide[UBound($listPixelSideStr) - 1]
For $i = 0 To UBound($listPixelSide) - 1
Local $pixelStr = StringSplit($listPixelSideStr[$i + 1], "-")
If ($pixelStr[0] > 2) Then
Local $pixel[3] = [$pixelStr[1], $pixelStr[2], $pixelStr[3]]
$listPixelSide[$i] = $pixel
EndIf
Next
Return $listPixelSide
Else
If StringInStr($listPixel, "-") > 0 Then
Local $pixelStrHere = StringSplit($listPixel, "-")
Local $pixelHere[3] = [$pixelStrHere[1], $pixelStrHere[2], $pixelStrHere[3]]
Local $listPixelHere[1]
$listPixelHere[0] = $pixelHere
Return $listPixelHere
EndIf
Return -1
EndIf
EndFunc
Func isInsideDiamondRedArea($aCoords)
Local $Left = $InternalArea[0][0] - 30, $Right = $InternalArea[1][0] + 30, $Top = $InternalArea[2][1] - 25, $Bottom = $InternalArea[3][1] + 20
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2, ($aDiamond[0][1] + $aDiamond[1][1]) / 2]
Local $aSize = [$aMiddle[0] - $aDiamond[0][0], $aMiddle[1] - $aDiamond[0][1]]
Local $DX = Abs($aCoords[0] - $aMiddle[0])
Local $DY = Abs($aCoords[1] - $aMiddle[1])
If ($DX / $aSize[0] + $DY / $aSize[1] <= 1) Then
Return True
Else
Return False
EndIf
EndFunc
Func Line2Points($pixel0, $pixel1, $x)
Return Round(($x - $pixel0[0]) / ($pixel1[0] - $pixel0[0]) * ($pixel1[1] - $pixel0[1]) + $pixel0[1])
EndFunc
Func MakeDropLine($searchvect, $startpoint, $endpoint)
Local $point1 = $startpoint
Local $ReturnVect
$ReturnVect = $startpoint[0] & "-" & $startpoint[1]
Local $t, $f
$t = 0
$f = 0
For $i = $startpoint[0] + 1 To $endpoint[0]
For $j = $t To UBound($searchvect) - 1
$pixel = $searchvect[$j]
If $i < $pixel[0] Then
Local $h = Line2Points($point1, $pixel, $i)
If $h > 620 Then $h = 620
$ReturnVect &= "|" & $i & "-" & $h
$f = $i
ExitLoop
Else
If $i = $pixel[0] Then
Local $h = $pixel[1]
If $h > 620 Then $h = 620
$ReturnVect &= "|" & $pixel[0] & "-" & $h
$point1 = $pixel
$t = $j + 1
$f = $i
ExitLoop
EndIf
EndIf
Next
Next
For $i = $f + 1 To $endpoint[0]
Local $h = Line2Points($point1, $endpoint, $i)
If $h > 620 Then $h = 620
$ReturnVect &= "|" & $i & "-" & $h
Next
Return GetListPixel($ReturnVect)
EndFunc
Func MakeDropPoints($side, $pointsQty, $addtiles, $versus, $randomx = 2, $randomy = 2)
debugAttackCSV("make for side " & $side)
Local $Vector, $Output = ""
Local $rndx = Random(0, Abs(Int($randomx)), 1)
Local $rndy = Random(0, Abs(Int($randomy)), 1)
If $side = "RANDOM" Then
EndIf
Switch $side
Case "TOP-LEFT-DOWN"
Local $Vector = $PixelTopLeftDOWNDropLine
Case "TOP-LEFT-UP"
Local $Vector = $PixelTopLeftUPDropLine
Case "TOP-RIGHT-DOWN"
Local $Vector = $PixelTopRightDOWNDropLine
Case "TOP-RIGHT-UP"
Local $Vector = $PixelTopRightUPDropLine
Case "BOTTOM-LEFT-UP"
Local $Vector = $PixelBottomLeftUPDropLine
Case "BOTTOM-LEFT-DOWN"
Local $Vector = $PixelBottomLeftDOWNDropLine
Case "BOTTOM-RIGHT-UP"
Local $Vector = $PixelBottomRightUPDropLine
Case "BOTTOM-RIGHT-DOWN"
Local $Vector = $PixelBottomRightDOWNDropLine
Case Else
EndSwitch
If Int($pointsQty) > 0 Then
Local $pointsQtyCleaned = Abs(Int($pointsQty))
Else
Local $pointsQtyCleaned = 1
EndIf
Local $p = Int(UBound($Vector) / $pointsQtyCleaned)
If $p = 0 Then $p = 1
Local $x = 0
Local $y = 0
Local $str = ""
For $i = 0 To UBound($Vector) - 1
$pixel = $Vector[$i]
$str &= $pixel[0] & "-" & $pixel[1] & "|"
Next
Switch $side & "|" & $versus
Case "TOP-LEFT-DOWN|INT-EXT", "TOP-LEFT-UP|EXT-INT", "TOP-RIGHT-DOWN|EXT-INT", "TOP-RIGHT-UP|INT-EXT", "BOTTOM-LEFT-DOWN|EXT-INT", "BOTTOM-LEFT-UP|INT-EXT", "BOTTOM-RIGHT-DOWN|INT-EXT", "BOTTOM-RIGHT-UP|EXT-INT"
For $i = UBound($Vector) To 1 Step -1
$pixel = $Vector[$i - 1]
$x += $pixel[0]
$y += $pixel[1]
If Mod(UBound($Vector) - $i + 1, $p) = 0 Then
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case Else
EndSwitch
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
$Output &= $pixel[0] & "-" & $pixel[1] & "|"
$x = 0
$y = 0
EndIf
Next
Case "TOP-LEFT-DOWN|EXT-INT", "TOP-LEFT-UP|INT-EXT", "TOP-RIGHT-DOWN|INT-EXT", "TOP-RIGHT-UP|EXT-INT", "BOTTOM-LEFT-DOWN|INT-EXT", "BOTTOM-LEFT-UP|EXT-INT", "BOTTOM-RIGHT-DOWN|EXT-INT", "BOTTOM-RIGHT-UP|INT-EXT"
For $i = 1 To UBound($Vector)
$pixel = $Vector[$i - 1]
$x += $pixel[0]
$y += $pixel[1]
If Mod($i, $p) = 0 Then
For $u = 8 * Abs(Int($addtiles)) To 0 Step -1
If Int($addtiles) > 0 Then
Local $l = $u
Else
Local $l = -$u
EndIf
Switch $side
Case "TOP-LEFT-UP", "TOP-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "TOP-RIGHT-UP", "TOP-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) - $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) - $l - $rndy
Case "BOTTOM-LEFT-UP", "BOTTOM-LEFT-DOWN"
Local $x1 = Round($x / $p) - $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) - $l - $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case "BOTTOM-RIGHT-UP", "BOTTOM-RIGHT-DOWN"
Local $x1 = Round($x / $p) + $l
Local $y1 = Round($y / $p) + $l
Local $x2 = Round($x / $p) + $l + $rndx
Local $y2 = Round($y / $p) + $l + $rndy
Case Else
EndSwitch
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
If isInsideDiamondRedArea($pixel) Then ExitLoop
Next
$pixel = StringSplit($x2 & "-" & $y2, "-", 2)
$Output &= $pixel[0] & "-" & $pixel[1] & "|"
$x = 0
$y = 0
EndIf
Next
Case Else
EndSwitch
If StringLen($Output) > 0 Then $Output = StringLeft($Output, StringLen($Output) - 1)
Return GetListPixel($Output)
EndFunc
Func ParseAttackCSV($debug = False)
Global $ATTACKVECTOR_A, $ATTACKVECTOR_B, $ATTACKVECTOR_C, $ATTACKVECTOR_D, $ATTACKVECTOR_E, $ATTACKVECTOR_F
Global $ATTACKVECTOR_G, $ATTACKVECTOR_H, $ATTACKVECTOR_I, $ATTACKVECTOR_J, $ATTACKVECTOR_K, $ATTACKVECTOR_L
Global $ATTACKVECTOR_M, $ATTACKVECTOR_N, $ATTACKVECTOR_O, $ATTACKVECTOR_P, $ATTACKVECTOR_Q, $ATTACKVECTOR_R
Global $ATTACKVECTOR_S, $ATTACKVECTOR_T, $ATTACKVECTOR_U, $ATTACKVECTOR_V, $ATTACKVECTOR_W, $ATTACKVECTOR_X
Global $ATTACKVECTOR_Y, $ATTACKVECTOR_Z
Local $rownum = 0
If $iMatchMode = $DB Then
Local $filename = $scmbDBScriptName
Else
Local $filename = $scmbABScriptName
EndIf
Setlog("execute " & $filename)
Local $f, $line, $acommand, $command
Local $value1, $value2, $value3, $value4, $value5, $value6, $value7, $value8, $value9
If FileExists($dirAttacksCSV & "\" & $filename & ".csv") Then
$f = FileOpen($dirAttacksCSV & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
$rownum += 1
If @error = -1 Then ExitLoop
If $debug = True Then Setlog("parse line:<<" & $line & ">>")
debugAttackCSV("line content: " & $line)
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
$value1 = StringStripWS(StringUpper($acommand[2]), 2)
$value2 = StringStripWS(StringUpper($acommand[3]), 2)
$value3 = StringStripWS(StringUpper($acommand[4]), 2)
$value4 = StringStripWS(StringUpper($acommand[5]), 2)
$value5 = StringStripWS(StringUpper($acommand[6]), 2)
$value6 = StringStripWS(StringUpper($acommand[7]), 2)
$value7 = StringStripWS(StringUpper($acommand[8]), 2)
$value8 = StringStripWS(StringUpper($acommand[9]), 2)
$value9 = StringStripWS(StringUpper($acommand[10]), 2)
Switch $command
Case ""
debugAttackCSV("comment line")
Case "MAKE"
ReleaseClicks()
If CheckCsvValues("MAKE", 2, $value2) Then
Local $sidex = StringReplace($value2, "-", "_")
If $sidex = "RANDOM" Then
Switch Random(1, 4, 1)
Case 1
$sidex = "FRONT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "LEFT"
Else
$sidex &= "RIGHT"
EndIf
Case 2
$sidex = "BACK_"
If Random(0, 1, 1) = 0 Then
$sidex &= "LEFT"
Else
$sidex &= "RIGHT"
EndIf
Case 3
$sidex = "LEFT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "FRONT"
Else
$sidex &= "BACK"
EndIf
Case 4
$sidex = "RIGHT_"
If Random(0, 1, 1) = 0 Then
$sidex &= "FRONT"
Else
$sidex &= "BACK"
EndIf
EndSwitch
EndIf
If CheckCsvValues("MAKE", 1, $value1) And CheckCsvValues("MAKE", 5, $value5) Then
Assign("ATTACKVECTOR_" & $value1, MakeDropPoints(Eval($sidex), $value3, $value4, $value5, $value6, $value7))
For $i = 0 To UBound(Execute("$ATTACKVECTOR_" & $value1)) - 1
$pixel = Execute("$ATTACKVECTOR_" & $value1 & "[" & $i & "]")
debugAttackCSV($i & " - " & $pixel[0] & "," & $pixel[1])
Next
Else
Setlog("Discard row, bad value1 or value 5 parameter: row " & $rownum)
debugAttackCSV("Discard row, bad value1 or value5 parameter")
EndIf
Else
Setlog("Discard row, bad value2 parameter:row " & $rownum)
debugAttackCSV("Discard row, bad value2 parameter:row " & $rownum)
EndIf
Case "DROP"
KeepClicks()
Local $index1, $index2, $indexArray, $indexvect
$indexvect = StringSplit($value2, "-", 2)
If UBound($indexvect) > 1 Then
$indexArray = 0
If Int($indexvect[0]) > 0 And Int($indexvect[1]) > 0 Then
$index1 = Int($indexvect[0])
$index2 = Int($indexvect[1])
Else
$index1 = 1
$index2 = 1
EndIf
Else
$indexArray = StringSplit($value2, ",", 2)
If UBound($indexArray) > 1 Then
$index1 = 0
$index2 = UBound($indexArray) - 1
Else
$indexArray = 0
If Int($value2) > 0 Then
$index1 = Int($value2)
$index2 = Int($value2)
Else
$index1 = 1
$index2 = 1
EndIf
EndIf
EndIf
Local $qty1, $qty2, $qtyvect
$qtyvect = StringSplit($value3, "-", 2)
If UBound($qtyvect) > 1 Then
If Int($qtyvect[0]) > 0 And Int($qtyvect[1]) > 0 Then
$qty1 = Int($qtyvect[0])
$qty2 = Int($qtyvect[1])
Else
$index1 = 1
$qty2 = 1
EndIf
Else
If Int($value3) > 0 Then
$qty1 = Int($value3)
$qty2 = Int($value3)
Else
$qty1 = 1
$qty2 = 1
EndIf
EndIf
Local $delaypoints1, $delaypoints2, $delaypointsvect
$delaypointsvect = StringSplit($value5, "-", 2)
If UBound($delaypointsvect) > 1 Then
If Int($delaypointsvect[0]) > 0 And Int($delaypointsvect[1]) > 0 Then
$delaypoints1 = Int($delaypointsvect[0])
$delaypoints2 = Int($delaypointsvect[1])
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
Else
If Int($value3) > 0 Then
$delaypoints1 = Int($value5)
$delaypoints2 = Int($value5)
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
EndIf
Local $delaydrop1, $delaydrop2, $delaydropvect
$delaydropvect = StringSplit($value6, "-", 2)
If UBound($delaydropvect) > 1 Then
If Int($delaydropvect[0]) > 0 And Int($delaydropvect[1]) > 0 Then
$delaydrop1 = Int($delaydropvect[0])
$delaydrop2 = Int($delaydropvect[1])
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
Else
If Int($value3) > 0 Then
$delaydrop1 = Int($value6)
$delaydrop2 = Int($value6)
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
EndIf
Local $sleepdrop1, $sleepdrop2, $sleepdroppvect
$sleepdroppvect = StringSplit($value7, "-", 2)
If UBound($sleepdroppvect) > 1 Then
If Int($sleepdroppvect[0]) > 0 And Int($sleepdroppvect[1]) > 0 Then
$sleepdrop1 = Int($sleepdroppvect[0])
$sleepdrop2 = Int($sleepdroppvect[1])
Else
$index1 = 1
$sleepdrop2 = 1
EndIf
Else
If Int($value3) > 0 Then
$sleepdrop1 = Int($value7)
$sleepdrop2 = Int($value7)
Else
$sleepdrop1 = 1
$sleepdrop2 = 1
EndIf
EndIf
If $value4 = "REMAIN" Then
SetLog("dropRemain:  Dropping left over troops", $COLOR_BLUE)
If PrepareAttack($iMatchMode, True) > 0 Then
For $ii = $eLava To $eBarb Step -1
LauchTroop($ii, 1, 0, 1)
Next
EndIf
Else
DropTroopFromINI($value1, $index1, $index2, $indexArray, $qty1, $qty2, $value4, $delaypoints1, $delaypoints2, $delaydrop1, $delaydrop2, $sleepdrop1, $sleepdrop2, $debug)
EndIf
ReleaseClicks($AndroidAdbClicksTroopDeploySize)
If _Sleep($iDelayRespond) Then
FileClose($f)
Return
EndIf
Case "DROPS"
KeepClicks()
Local $qty1, $qty2, $qtyvect
$qtyvect = StringSplit($value3, "-", 2)
If UBound($qtyvect) > 1 Then
If Int($qtyvect[0]) > 0 And Int($qtyvect[1]) > 0 Then
$qty1 = Int($qtyvect[0])
$qty2 = Int($qtyvect[1])
Else
$index1 = 1
$qty2 = 1
EndIf
Else
If Int($value3) > 0 Then
$qty1 = Int($value3)
$qty2 = Int($value3)
Else
$qty1 = 1
$qty2 = 1
EndIf
EndIf
Local $delaypoints1, $delaypoints2, $delaypointsvect
$delaypointsvect = StringSplit($value5, "-", 2)
If UBound($delaypointsvect) > 1 Then
If Int($delaypointsvect[0]) > 0 And Int($delaypointsvect[1]) > 0 Then
$delaypoints1 = Int($delaypointsvect[0])
$delaypoints2 = Int($delaypointsvect[1])
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
Else
If Int($value3) > 0 Then
$delaypoints1 = Int($value5)
$delaypoints2 = Int($value5)
Else
$delaypoints1 = 1
$delaypoints2 = 1
EndIf
EndIf
Local $delaydrop1, $delaydrop2, $delaydropvect
$delaydropvect = StringSplit($value6, "-", 2)
If UBound($delaydropvect) > 1 Then
If Int($delaydropvect[0]) > 0 And Int($delaydropvect[1]) > 0 Then
$delaydrop1 = Int($delaydropvect[0])
$delaydrop2 = Int($delaydropvect[1])
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
Else
If Int($value3) > 0 Then
$delaydrop1 = Int($value6)
$delaydrop2 = Int($value6)
Else
$delaydrop1 = 1
$delaydrop2 = 1
EndIf
EndIf
Local $sleepdrop1, $sleepdrop2, $sleepdroppvect
$sleepdroppvect = StringSplit($value7, "-", 2)
If UBound($sleepdroppvect) > 1 Then
If Int($sleepdroppvect[0]) > 0 And Int($sleepdroppvect[1]) > 0 Then
$sleepdrop1 = Int($sleepdroppvect[0])
$sleepdrop2 = Int($sleepdroppvect[1])
Else
$index1 = 1
$sleepdrop2 = 1
EndIf
Else
If Int($value3) > 0 Then
$sleepdrop1 = Int($value7)
$sleepdrop2 = Int($value7)
Else
$sleepdrop1 = 1
$sleepdrop2 = 1
EndIf
EndIf
DropSpellFromINIOnDefense($value1, $value2, $qty1, $qty2, $value4, $delaypoints1, $delaypoints2, $delaydrop1, $delaydrop2, $sleepdrop1, $sleepdrop2, $debug)
ReleaseClicks($AndroidAdbClicksTroopDeploySize)
If _Sleep($iDelayRespond) Then
FileClose($f)
Return
EndIf
Case "WAIT"
ReleaseClicks()
Local $sleep1, $sleep2, $sleepvect
$sleepvect = StringSplit($value1, "-", 2)
If UBound($sleepvect) > 1 Then
If Int($sleepvect[0]) > 0 And Int($sleepvect[1]) > 0 Then
$sleep1 = Int($sleepvect[0])
$sleep2 = Int($sleepvect[1])
Else
$sleep1 = 1
$sleep2 = 1
EndIf
Else
If Int($value3) > 0 Then
$sleep1 = Int($value1)
$sleep2 = Int($value1)
Else
$sleep1 = 1
$sleep2 = 1
EndIf
EndIf
If $sleep1 <> $sleep2 Then
Local $sleep = Random(Int($sleep1), Int($sleep2), 1)
Else
Local $sleep = Int($sleep1)
EndIf
debugAttackCSV("wait " & $sleep)
Local $Gold = 0
Local $Elixir = 0
Local $DarkElixir = 0
Local $Trophies = 0
Local $exitOneStar = 0
Local $exitTwoStars = 0
Local $exitNoResources = 0
Local $hSleepTimer = TimerInit()
While TimerDiff($hSleepTimer) < $sleep
$Gold = getGoldVillageSearch(48, 69)
$Elixir = getElixirVillageSearch(48, 69 + 29)
If _Sleep($iDelayRespond) Then
FileClose($f)
Return
EndIf
$Trophies = getTrophyVillageSearch(48, 69 + 99)
If $Trophies <> "" Then
$DarkElixir = getDarkElixirVillageSearch(48, 69 + 57)
Else
$DarkElixir = ""
$Trophies = getTrophyVillageSearch(48, 69 + 69)
EndIf
If $DebugSetLog = 1 Then SetLog("detected [G]: " & $Gold & " [E]: " & $Elixir & " [DE]: " & $DarkElixir, $COLOR_DEBUG)
If $ichkEndNoResources[$iMatchMode] = 1 And Number($Gold) = 0 And Number($Elixir) = 0 And Number($DarkElixir) = 0 Then
If $DebugSetLog = 1 Then Setlog("From Attackcsv: Gold & Elixir & DE = 0, end battle ", $COLOR_DEBUG)
$exitNoResources = 1
ExitLoop
EndIf
If $ichkEndTwoStars[$iMatchMode] = 1 And _CheckPixel($aWonTwoStar, True) Then
If $DebugSetLog = 1 Then Setlog("From Attackcsv: Two Star Reach, exit", $COLOR_DEBUG)
$exitTwoStars = 1
ExitLoop
EndIf
If $ichkEndOneStar[$iMatchMode] = 1 And _CheckPixel($aWonOneStar, True) Then
If $DebugSetLog = 1 Then Setlog("From Attackcsv: One Star Reach, exit", $COLOR_DEBUG)
$exitOneStar = 1
ExitLoop
EndIf
If _Sleep($iDelayRespond) Then
FileClose($f)
Return
EndIf
CheckHeroesHealth()
WEnd
If $exitOneStar = 1 Or $exitTwoStars = 1 Or $exitNoResources = 1 Then ExitLoop
Case "RECALC"
ReleaseClicks()
PrepareAttack($iMatchMode, True)
Case "SIDE"
ReleaseClicks()
Setlog("Calculate main side... ")
If StringUpper($value8) = "EAGLE" Then
Setlog("Forced side: " & StringUpper($value8))
$hTimer = TimerInit()
Local $directory = @ScriptDir & "\images\WeakBase\Eagle"
Local $return = returnHighestLevelSingleMatch($directory)
Local $NotdetectedEagle = True
If $DebugSetLog = 1 Then Setlog(" Â»Â» Ubound ROW $return: " & UBound($return, $UBOUND_ROWS), $COLOR_DEBUG)
If $DebugSetLog = 1 Then Setlog(" Â»Â» Ubound COLUMNS $return: " & UBound($return, $UBOUND_COLUMNS), $COLOR_DEBUG)
If $DebugSetLog = 1 Then Setlog(" Â»Â» Ubound DIMENSIONS $return: " & UBound($return, $UBOUND_DIMENSIONS), $COLOR_DEBUG)
If UBound($return) > 1 and $return[1] <> "NONE" Then
If $DebugSetLog = 1 Then Setlog(" Â»Â» Image: " & $return[0], $COLOR_DEBUG)
If $DebugSetLog = 1 Then Setlog(" Â»Â» Build: " & $return[1], $COLOR_DEBUG)
If $DebugSetLog = 1 Then Setlog(" Â»Â» Level: " & $return[2], $COLOR_DEBUG)
Local $EaglePosition = $return[5]
If $DebugSetLog = 1 Then Setlog(" Â»Â» $EaglePosition[0] X: " & $EaglePosition[0][0], $COLOR_DEBUG)
If $DebugSetLog = 1 Then Setlog(" Â»Â» $EaglePosition[1] Y: " & $EaglePosition[0][1], $COLOR_DEBUG)
If $DebugSetLog = 1 Then Setlog(" Â»Â» Ubound ROW $EaglePosition: " & UBound($EaglePosition, $UBOUND_ROWS), $COLOR_DEBUG)
If $DebugSetLog = 1 Then Setlog(" Â»Â» Ubound COLUMNS $EaglePosition: " & UBound($EaglePosition, $UBOUND_COLUMNS), $COLOR_DEBUG)
If $DebugSetLog = 1 Then Setlog(" Â»Â» Ubound DIMENSIONS $EaglePosition: " & UBound($EaglePosition, $UBOUND_DIMENSIONS), $COLOR_DEBUG)
If $EaglePosition[0][0] <> "" Then
$PixelEaglePos[0] = $EaglePosition[0][0]
$PixelEaglePos[1] = $EaglePosition[0][1]
Setlog(" Â»Â» Eagle located in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds")
Switch StringLeft(Slice8($PixelEaglePos), 1)
Case 1, 2
$MAINSIDE = "BOTTOM-RIGHT"
Case 3, 4
$MAINSIDE = "TOP-RIGHT"
Case 5, 6
$MAINSIDE = "TOP-LEFT"
Case 7, 8
$MAINSIDE = "BOTTOM-LEFT"
EndSwitch
Setlog(" Â» Eagle located : " & $MAINSIDE, $COLOR_BLUE)
$NotdetectedEagle = False
Else
Setlog("> Eagle not detected!", $COLOR_BLUE)
DebugImageSave("EagleDetection_NotDetected_", True)
EndIf
Else
Setlog("> Eagle not Present!", $COLOR_BLUE)
DebugImageSave("EagleDetection_NotPresent_", True)
EndIf
If $MAINSIDE = "" Then $MAINSIDE = "TOP-RIGHT"
If $attackcsv_locate_townhall = 1 And $NotdetectedEagle = True Then
$pixel = StringSplit($thx & "-" & $thy, "-", 2)
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$MAINSIDE = "BOTTOM-RIGHT"
Case 3, 4
$MAINSIDE = "TOP-RIGHT"
Case 5, 6
$MAINSIDE = "TOP-LEFT"
Case 7, 8
$MAINSIDE = "BOTTOM-LEFT"
EndSwitch
EndIf
ElseIf StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
$MAINSIDE = StringUpper($value8)
Setlog("Forced side: " & StringUpper($value8))
Else
Local $heightTopLeft = 0, $heightTopRight = 0, $heightBottomLeft = 0, $heightBottomRight = 0
UpdateResourcesLocations($line)
For $i = 0 To UBound($PixelMine) - 1
Local $str = ""
Local $pixel = $PixelMine[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value1)
Case 3, 4
$heightTopRight += Int($value1)
Case 5, 6
$heightTopLeft += Int($value1)
Case 7, 8
$heightBottomLeft += Int($value1)
EndSwitch
EndIf
Next
For $i = 0 To UBound($PixelElixir) - 1
Local $str = ""
Local $pixel = $PixelElixir[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value2)
Case 3, 4
$heightTopRight += Int($value2)
Case 5, 6
$heightTopLeft += Int($value2)
Case 7, 8
$heightBottomLeft += Int($value2)
EndSwitch
EndIf
Next
For $i = 0 To UBound($PixelDarkElixir) - 1
Local $str = ""
Local $pixel = $PixelDarkElixir[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value3)
Case 3, 4
$heightTopRight += Int($value3)
Case 5, 6
$heightTopLeft += Int($value3)
Case 7, 8
$heightBottomLeft += Int($value3)
EndSwitch
EndIf
Next
If IsArray($GoldStoragePos) Then
For $i = 0 To UBound($GoldStoragePos) - 1
Local $pixel = $GoldStoragePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value4)
Case 3, 4
$heightTopRight += Int($value4)
Case 5, 6
$heightTopLeft += Int($value4)
Case 7, 8
$heightBottomLeft += Int($value4)
EndSwitch
EndIf
Next
EndIf
If IsArray($ElixirStoragePos) Then
For $i = 0 To UBound($ElixirStoragePos) - 1
Local $pixel = $ElixirStoragePos[$i]
If UBound($pixel) = 2 Then
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value5)
Case 3, 4
$heightTopRight += Int($value5)
Case 5, 6
$heightTopLeft += Int($value5)
Case 7, 8
$heightBottomLeft += Int($value5)
EndSwitch
EndIf
Next
EndIf
Switch StringLeft(Slice8($darkelixirStoragePos), 1)
Case 1, 2
$heightBottomRight += Int($value6)
Case 3, 4
$heightTopRight += Int($value6)
Case 5, 6
$heightTopLeft += Int($value6)
Case 7, 8
$heightBottomLeft += Int($value6)
EndSwitch
$pixel = StringSplit($thx & "-" & $thy, "-", 2)
Switch StringLeft(Slice8($pixel), 1)
Case 1, 2
$heightBottomRight += Int($value7)
Case 3, 4
$heightTopRight += Int($value7)
Case 5, 6
$heightTopLeft += Int($value7)
Case 7, 8
$heightBottomLeft += Int($value7)
EndSwitch
Local $maxValue = $heightBottomRight
Local $sidename = "BOTTOM-RIGHT"
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
Setlog("Mainside: " & $sidename & " (top-left:" & $heightTopLeft & " top-right:" & $heightTopRight & " bottom-left:" & $heightBottomLeft & " bottom-right:" & $heightBottomRight)
$MAINSIDE = $sidename
EndIf
Switch $MAINSIDE
Case "BOTTOM-RIGHT"
$FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
$FRONT_RIGHT = "BOTTOM-RIGHT-UP"
$RIGHT_FRONT = "TOP-RIGHT-DOWN"
$RIGHT_BACK = "TOP-RIGHT-UP"
$LEFT_FRONT = "BOTTOM-LEFT-DOWN"
$LEFT_BACK = "BOTTOM-LEFT-UP"
$BACK_LEFT = "TOP-LEFT-DOWN"
$BACK_RIGHT = "TOP-LEFT-UP"
Case "BOTTOM-LEFT"
$FRONT_LEFT = "BOTTOM-LEFT-UP"
$FRONT_RIGHT = "BOTTOM-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-RIGHT-DOWN"
$RIGHT_BACK = "BOTTOM-RIGHT-UP"
$LEFT_FRONT = "TOP-LEFT-DOWN"
$LEFT_BACK = "TOP-LEFT-UP"
$BACK_LEFT = "TOP-RIGHT-UP"
$BACK_RIGHT = "TOP-RIGHT-DOWN"
Case "TOP-LEFT"
$FRONT_LEFT = "TOP-LEFT-UP"
$FRONT_RIGHT = "TOP-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-LEFT-UP"
$RIGHT_BACK = "BOTTOM-LEFT-DOWN"
$LEFT_FRONT = "TOP-RIGHT-UP"
$LEFT_BACK = "TOP-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-RIGHT-UP"
$BACK_RIGHT = "BOTTOM-RIGHT-DOWN"
Case "TOP-RIGHT"
$FRONT_LEFT = "TOP-RIGHT-DOWN"
$FRONT_RIGHT = "TOP-RIGHT-UP"
$RIGHT_FRONT = "TOP-LEFT-UP"
$RIGHT_BACK = "TOP-LEFT-DOWN"
$LEFT_FRONT = "BOTTOM-RIGHT-UP"
$LEFT_BACK = "BOTTOM-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-LEFT-DOWN"
$BACK_RIGHT = "BOTTOM-LEFT-UP"
EndSwitch
ParseAndMakeDropLines($MAINSIDE)
Case "SIDEP"
Local $sidep_locate_mine = 0, $sidep_locate_elixir = 0, $sidep_locate_drill = 0
$sidep_locate_mine = IIf(Int($value1) > 0, 1, 0)
$sidep_locate_elixir = IIf(Int($value2) > 0, 1, 0)
$sidep_locate_drill = IIf(Int($value3) > 0, 1, 0)
Local $heightTopLeft = 0, $heightTopRight = 0, $heightBottomLeft = 0, $heightBottomRight = 0
Local $rGetCountEachSide
Local $hLTimer
If $sidep_locate_mine = 1 Then
$hLTimer = TimerInit()
$rGetCountEachSide = GetCountEachSide("Mine")
If Not @error Then
SetLog("Gold Mines Located within " & Round(Number(TimerDiff($hLTimer) / 1000), 2) & " second(s)")
$heightBottomRight += ($rGetCountEachSide[0] * Int($value1))
$heightTopRight += ($rGetCountEachSide[1] * Int($value1))
$heightTopLeft += ($rGetCountEachSide[2] * Int($value1))
$heightBottomLeft += ($rGetCountEachSide[3] * Int($value1))
ElseIf @error = 2 Then
SetLog("Cannot find Gold Mines", $COLOR_ORANGE)
EndIf
EndIf
If $sidep_locate_elixir = 1 Then
$hLTimer = TimerInit()
$rGetCountEachSide = GetCountEachSide("Collector")
If Not @error Then
SetLog("Elixir Collectors Located within " & Round(Number(TimerDiff($hLTimer) / 1000), 2) & " second(s)")
$heightBottomRight += ($rGetCountEachSide[0] * Int($value2))
$heightTopRight += ($rGetCountEachSide[1] * Int($value2))
$heightTopLeft += ($rGetCountEachSide[2] * Int($value2))
$heightBottomLeft += ($rGetCountEachSide[3] * Int($value2))
ElseIf @error = 2 Then
SetLog("Cannot find Elixir Collectors", $COLOR_ORANGE)
EndIf
EndIf
If $sidep_locate_drill = 1 Then
$hLTimer = TimerInit()
$rGetCountEachSide = GetCountEachSide("Drill")
If Not @error Then
SetLog("Dark Drills Located within " & Round(Number(TimerDiff($hLTimer) / 1000), 2) & " second(s)")
$heightBottomRight += ($rGetCountEachSide[0] * Int($value3))
$heightTopRight += ($rGetCountEachSide[1] * Int($value3))
$heightTopLeft += ($rGetCountEachSide[2] * Int($value3))
$heightBottomLeft += ($rGetCountEachSide[3] * Int($value3))
ElseIf @error = 2 Then
SetLog("Cannot find Dark Drills", $COLOR_ORANGE)
EndIf
EndIf
Local $maxValue = $heightBottomRight
Local $sidename = "BOTTOM-RIGHT"
Switch $value8
Case "Highest"
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
Case "Lowest"
If $heightTopLeft < $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight < $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft < $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
Case Else
If $heightTopLeft > $maxValue Then
$maxValue = $heightTopLeft
$sidename = "TOP-LEFT"
EndIf
If $heightTopRight > $maxValue Then
$maxValue = $heightTopRight
$sidename = "TOP-RIGHT"
EndIf
If $heightBottomLeft > $maxValue Then
$maxValue = $heightBottomLeft
$sidename = "BOTTOM-LEFT"
EndIf
EndSwitch
Setlog("SideP-Mainside: " & $sidename & " (top-left:" & $heightTopLeft & " top-right:" & $heightTopRight & " bottom-left:" & $heightBottomLeft & " bottom-right:" & $heightBottomRight)
$MAINSIDE = $sidename
Switch $MAINSIDE
Case "BOTTOM-RIGHT"
$FRONT_LEFT = "BOTTOM-RIGHT-DOWN"
$FRONT_RIGHT = "BOTTOM-RIGHT-UP"
$RIGHT_FRONT = "TOP-RIGHT-DOWN"
$RIGHT_BACK = "TOP-RIGHT-UP"
$LEFT_FRONT = "BOTTOM-LEFT-DOWN"
$LEFT_BACK = "BOTTOM-LEFT-UP"
$BACK_LEFT = "TOP-LEFT-DOWN"
$BACK_RIGHT = "TOP-LEFT-UP"
Case "BOTTOM-LEFT"
$FRONT_LEFT = "BOTTOM-LEFT-UP"
$FRONT_RIGHT = "BOTTOM-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-RIGHT-DOWN"
$RIGHT_BACK = "BOTTOM-RIGHT-UP"
$LEFT_FRONT = "TOP-LEFT-DOWN"
$LEFT_BACK = "TOP-LEFT-UP"
$BACK_LEFT = "TOP-RIGHT-UP"
$BACK_RIGHT = "TOP-RIGHT-DOWN"
Case "TOP-LEFT"
$FRONT_LEFT = "TOP-LEFT-UP"
$FRONT_RIGHT = "TOP-LEFT-DOWN"
$RIGHT_FRONT = "BOTTOM-LEFT-UP"
$RIGHT_BACK = "BOTTOM-LEFT-DOWN"
$LEFT_FRONT = "TOP-RIGHT-UP"
$LEFT_BACK = "TOP-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-RIGHT-UP"
$BACK_RIGHT = "BOTTOM-RIGHT-DOWN"
Case "TOP-RIGHT"
$FRONT_LEFT = "TOP-RIGHT-DOWN"
$FRONT_RIGHT = "TOP-RIGHT-UP"
$RIGHT_FRONT = "TOP-LEFT-UP"
$RIGHT_BACK = "TOP-LEFT-DOWN"
$LEFT_FRONT = "BOTTOM-RIGHT-UP"
$LEFT_BACK = "BOTTOM-RIGHT-DOWN"
$BACK_LEFT = "BOTTOM-LEFT-DOWN"
$BACK_RIGHT = "BOTTOM-LEFT-UP"
EndSwitch
ParseAndMakeDropLines($MAINSIDE)
Case Else
Setlog("attack row bad, discard :row " & $rownum, $COLOR_RED)
EndSwitch
Else
If StringLeft($line, 7) <> "NOTE  |" And StringLeft($line, 7) <> "      |" And StringStripWS(StringUpper($line), 2) <> "" Then Setlog("attack row error, discard.: " & $line, $COLOR_RED)
EndIf
CheckHeroesHealth()
If _Sleep($iDelayRespond) Then
FileClose($f)
Return
EndIf
WEnd
ResetRedLines()
ReleaseClicks()
FileClose($f)
Else
SetLog("Cannot find attack file " & $dirAttacksCSV & "\" & $filename & ".csv", $color_red)
EndIf
EndFunc
Func ParseAttackCSV_Read_SIDE_variables($lineContent = "")
$attackcsv_locate_mine = 0
$attackcsv_locate_elixir = 0
$attackcsv_locate_drill = 0
$attackcsv_locate_gold_storage = 0
$attackcsv_locate_elixir_storage = 0
$attackcsv_locate_dark_storage = 0
$attackcsv_locate_townhall = 0
If $iMatchMode = $DB Then
Local $filename = $scmbDBScriptName
Else
Local $filename = $scmbABScriptName
EndIf
Local $f, $line, $acommand, $command
Local $value1, $value2, $value3, $value4, $value5, $value6, $value7, $value8, $value9
Select
Case $lineContent = ""
If FileExists($dirAttacksCSV & "\" & $filename & ".csv") Then
$f = FileOpen($dirAttacksCSV & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
$value1 = StringStripWS(StringUpper($acommand[2]), 2)
$value2 = StringStripWS(StringUpper($acommand[3]), 2)
$value3 = StringStripWS(StringUpper($acommand[4]), 2)
$value4 = StringStripWS(StringUpper($acommand[5]), 2)
$value5 = StringStripWS(StringUpper($acommand[6]), 2)
$value6 = StringStripWS(StringUpper($acommand[7]), 2)
$value7 = StringStripWS(StringUpper($acommand[8]), 2)
$value8 = StringStripWS(StringUpper($acommand[9]), 2)
$value9 = StringStripWS(StringUpper($acommand[10]), 2)
If $command = "SIDE" Then
If StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
Else
If Int($value1) > 0 Then $attackcsv_locate_mine = 1
If Int($value2) > 0 Then $attackcsv_locate_elixir = 1
If Int($value3) > 0 Then $attackcsv_locate_drill = 1
If Int($value4) > 0 Then $attackcsv_locate_gold_storage = 1
If Int($value5) > 0 Then $attackcsv_locate_elixir_storage = 1
If Int($value6) > 0 Then $attackcsv_locate_dark_storage = 1
If Int($value7) > 0 Then $attackcsv_locate_townhall = 1
EndIf
ExitLoop
EndIf
EndIf
WEnd
FileClose($f)
Else
SetLog("Cannot find attack file " & $dirAttacksCSV & "\" & $filename & ".csv", $color_red)
EndIf
Case Else
$line = $lineContent
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
$value1 = StringStripWS(StringUpper($acommand[2]), 2)
$value2 = StringStripWS(StringUpper($acommand[3]), 2)
$value3 = StringStripWS(StringUpper($acommand[4]), 2)
$value4 = StringStripWS(StringUpper($acommand[5]), 2)
$value5 = StringStripWS(StringUpper($acommand[6]), 2)
$value6 = StringStripWS(StringUpper($acommand[7]), 2)
$value7 = StringStripWS(StringUpper($acommand[8]), 2)
$value8 = StringStripWS(StringUpper($acommand[9]), 2)
$value9 = StringStripWS(StringUpper($acommand[10]), 2)
If $command = "SIDE" Then
If StringUpper($value8) = "TOP-LEFT" Or StringUpper($value8) = "TOP-RIGHT" Or StringUpper($value8) = "BOTTOM-LEFT" Or StringUpper($value8) = "BOTTOM-RIGHT" Then
Else
If Int($value1) > 0 Then $attackcsv_locate_mine = 1
If Int($value2) > 0 Then $attackcsv_locate_elixir = 1
If Int($value3) > 0 Then $attackcsv_locate_drill = 1
If Int($value4) > 0 Then $attackcsv_locate_gold_storage = 1
If Int($value5) > 0 Then $attackcsv_locate_elixir_storage = 1
If Int($value6) > 0 Then $attackcsv_locate_dark_storage = 1
If Int($value7) > 0 Then $attackcsv_locate_townhall = 1
EndIf
EndIf
EndIf
EndSelect
EndFunc
Func Slice8($pixel)
If UBound($pixel) < 2 Then Return "0_NO_ARRAY"
If $pixel[0] < $ExternalArea[0][0] Or $pixel[0] > $ExternalArea[1][0] Or $pixel[1] < $ExternalArea[2][1] Or $pixel[1] > $ExternalArea[3][1] Then
Return "0_O"
Else
If $pixel[0] <= $ExternalArea[2][0] Then
If $pixel[1] <= $ExternalArea[0][1] Then
If $pixel[0] <= $ExternalArea[4][0] Then
If ($ExternalArea[4][0] - $pixel[0]) / ($ExternalArea[4][0] - $ExternalArea[0][0]) + ($ExternalArea[0][1] - $pixel[1]) / ($ExternalArea[0][1] - $ExternalArea[4][1]) <= 1 Then
Return "6E"
Else
Return "0_6E"
EndIf
Else
If ($pixel[0] - $ExternalArea[4][0]) / ($ExternalArea[2][0] - $ExternalArea[4][0]) + ($ExternalArea[0][1] - $pixel[1]) / ($ExternalArea[0][1] - $ExternalArea[4][1]) <= 1 Then
Return "6_I"
Else
If ($ExternalArea[2][0] - $pixel[0]) / ($ExternalArea[2][0] - $ExternalArea[4][0]) + Abs($ExternalArea[4][1] - $pixel[1]) / ($ExternalArea[0][1] - $ExternalArea[4][1]) <= 1 Then
If $pixel[1] <= $ExternalArea[4][1] Then
Return "5_E"
Else
Return "5_I"
EndIf
Else
Return "O_5"
EndIf
EndIf
EndIf
Else
If $pixel[0] <= $ExternalArea[6][0] Then
If ($ExternalArea[6][0] - $pixel[0]) / ($ExternalArea[6][0] - $ExternalArea[0][0]) + ($pixel[1] - $ExternalArea[0][1]) / ($ExternalArea[6][1] - $ExternalArea[0][1]) <= 1 Then
Return "7_E"
Else
Return "0_7"
EndIf
Else
If ($pixel[0] - $ExternalArea[6][0]) / ($ExternalArea[2][0] - $ExternalArea[6][0]) + ($pixel[1] - $ExternalArea[0][1]) / ($ExternalArea[6][1] - $ExternalArea[0][1]) <= 1 Then
Return "7_I"
Else
If ($ExternalArea[2][0] - $pixel[0]) / ($ExternalArea[2][0] - $ExternalArea[6][0]) + Abs($ExternalArea[6][1] - $pixel[1]) / ($ExternalArea[6][1] - $ExternalArea[0][1]) <= 1 Then
If $pixel[1] <= $ExternalArea[6][1] Then
Return "8_I"
Else
Return "8_E"
EndIf
Else
Return "0_8"
EndIf
EndIf
EndIf
EndIf
Else
If $pixel[1] <= $ExternalArea[0][1] Then
If $pixel[0] > $ExternalArea[5][0] Then
If ($pixel[0] - $ExternalArea[5][0]) / ($ExternalArea[1][0] - $ExternalArea[5][0]) + ($ExternalArea[0][1] - $pixel[1]) / ($ExternalArea[0][1] - $ExternalArea[5][1]) <= 1 Then
Return "3_E"
Else
Return "0_3"
EndIf
Else
If ($ExternalArea[5][0] - $pixel[0]) / ($ExternalArea[5][0] - $ExternalArea[2][0]) + ($ExternalArea[0][1] - $pixel[1]) / ($ExternalArea[0][1] - $ExternalArea[5][1]) <= 1 Then
Return "3_I"
Else
If ($pixel[0] - $ExternalArea[2][0]) / ($ExternalArea[5][0] - $ExternalArea[2][0]) + Abs($ExternalArea[5][1] - $pixel[1]) / ($ExternalArea[0][1] - $ExternalArea[5][1]) <= 1 Then
If $pixel[1] <= $ExternalArea[5][1] Then
Return "4_E"
Else
Return "4_I"
EndIf
Else
Return "0_4"
EndIf
EndIf
EndIf
Else
If $pixel[0] > $ExternalArea[7][0] Then
If ($pixel[0] - $ExternalArea[7][0]) / ($ExternalArea[1][0] - $ExternalArea[7][0]) + ($pixel[1] - $ExternalArea[0][1]) / ($ExternalArea[7][1] - $ExternalArea[0][1]) <= 1 Then
Return "2_E"
Else
Return "0_2"
EndIf
Else
If ($ExternalArea[7][0] - $pixel[0]) / ($ExternalArea[7][0] - $ExternalArea[3][0]) + ($pixel[1] - $ExternalArea[0][1]) / ($ExternalArea[7][1] - $ExternalArea[0][1]) <= 1 Then
Return "2_I"
Else
If ($pixel[0] - $ExternalArea[3][0]) / ($ExternalArea[7][0] - $ExternalArea[3][0]) + Abs($ExternalArea[7][1] - $pixel[1]) / ($ExternalArea[7][1] - $ExternalArea[0][1]) <= 1 Then
If $pixel[1] <= $ExternalArea[7][1] Then
Return "1_I"
Else
Return "1_E"
EndIf
Else
Return "0_1"
EndIf
EndIf
EndIf
EndIf
EndIf
EndIf
EndFunc
Func CleanRedArea(ByRef $InputVect, $side = "")
Local $TempVectStr = ""
For $i = 0 To UBound($InputVect) - 1
$pixel = $InputVect[$i]
If isInsideDiamondRedArea($pixel) And Not ($pixel[0] = 261 And $pixel[1] = 191) And Not ($pixel[0] = $ExternalArea[2][0]) Then
$TempVectStr &= $pixel[0] & "-" & $pixel[1] & "|"
Else
debugAttackCSV("CleanRedArea removed (" & $pixel[0] & "," & $pixel[1] & ")")
EndIf
Next
If StringLen($TempVectStr) > 0 Then
$TempVectStr = StringLeft($TempVectStr, StringLen($TempVectStr) - 1)
$InputVect = GetListPixel($TempVectStr)
EndIf
EndFunc
Func ChkAttackCSVConfig()
If Not (FileExists($dirAttacksCSV & "\" & $scmbDBScriptName & ".csv")) Then
Setlog("Dead base scripted attack file do not exists (renamed, deleted?)", $COLOR_RED)
SetLog("Please select a new scripted algorithm from 'scripted attack' tab", $COLOR_RED)
PopulateComboScriptsFilesDB()
btnStop()
EndIf
If Not (FileExists($dirAttacksCSV & "\" & $scmbABScriptName & ".csv")) Then
Setlog("Dead base scripted attack file do not exists (renamed, deleted?)", $COLOR_RED)
SetLog("Please select a new scripted algorithm from 'scripted attack' tab", $COLOR_RED)
PopulateComboScriptsFilesAB()
btnStop()
EndIf
EndFunc
Global $DebugSideP = 0
Global Const $dGoldMines = @ScriptDir & "\images\Resources\SideP\GoldMines", $dDarkDrills = @ScriptDir & "\images\Resources\SideP\Drills", $dElixirCollectors = @ScriptDir & "\images\Resources\SideP\Collectors"
Func TestSideP()
Local $oRunState = $RunState
$RunState = True
GetRedLines()
Local $rGetCountEachSide = GetCountEachSide("Collector")
If Not @error Then
GetPercentageEachSide($rGetCountEachSide)
EndIf
ResetRedLines()
$RunState = $oRunState
EndFunc
Func GetPercentageEachSide($rGetCountEachSide)
Local $ToReturn[4] = [0, 0, 0, 0]
Local $TotalFound = $rGetCountEachSide[0] + $rGetCountEachSide[1] + $rGetCountEachSide[2] + $rGetCountEachSide[3]
If $DebugSideP Then SetLog("Total Objects Found: " & $TotalFound)
If $TotalFound = 0 Then Return SetError(1)
$ToReturn[0] = Round(($rGetCountEachSide[0] / $TotalFound) * 100)
$ToReturn[1] = Round(($rGetCountEachSide[1] / $TotalFound) * 100)
$ToReturn[2] = Round(($rGetCountEachSide[2] / $TotalFound) * 100)
$ToReturn[3] = Round(($rGetCountEachSide[3] / $TotalFound) * 100)
If $DebugSideP Then
SetLog("==============Percentage===============")
SetLog("BOTTOM-RIGHT Percentage: " & $ToReturn[0] & "%", $COLOR_BLUE)
SetLog("TOP-RIGHT Percentage: " & $ToReturn[1] & "%", $COLOR_BLUE)
SetLog("TOP-LEFT Percentage: " & $ToReturn[2] & "%", $COLOR_BLUE)
SetLog("BOTTOM-LEFT Percentage: " & $ToReturn[3] & "%", $COLOR_BLUE)
EndIf
Return $ToReturn
EndFunc
Func GetCountEachSide($sToSearch)
Local $ToReturn[4] = [0, 0, 0, 0]
Local $iSearchResult = ""
Local $bSomethingFound = False
Local $splitedPositions
Switch $sToSearch
Case "Mine"
$iSearchResult = multiMatchesPixelOnly($dGoldMines, 7, $DCD, $CurBaseRedLine)
Case "Drill"
$iSearchResult = multiMatchesPixelOnly($dDarkDrills, 3, $DCD, $CurBaseRedLine)
Case "Collector"
$iSearchResult = multiMatchesPixelOnly($dElixirCollectors, 7, $DCD, $CurBaseRedLine)
Case Else
Return SetError(1)
EndSwitch
If $iSearchResult <> "" And StringLen($iSearchResult) > 3 Then $bSomethingFound = True
If $bSomethingFound Then
If StringInStr($iSearchResult, "|") > 0 Then
$splitedPositions = StringSplit($iSearchResult, "|", 2)
Else
$splitedPositions = _StringEqualSplit($iSearchResult, StringLen($iSearchResult))
EndIf
EndIf
If $bSomethingFound = False Then
If $DebugSideP Then
SetLog("SomethingFound is false and" & @CRLF & "$iSearchResult = " & $iSearchResult, $COLOR_RED)
DebugImageSave("SideP_BuildingNotFound_", False)
EndIf
Return SetError(2)
EndIf
For $Pos In $splitedPositions
Switch StringLeft(Slice8(StringSplit($Pos, ",", 2)), 1)
Case 1, 2
$ToReturn[0] += 1
Case 3, 4
$ToReturn[1] += 1
Case 5, 6
$ToReturn[2] += 1
Case 7, 8
$ToReturn[3] += 1
EndSwitch
Next
If $DebugSideP Then
SetLog("==============Objects Count===============")
SetLog("BOTTOM-RIGHT Objects Count: x" & $ToReturn[0], $COLOR_BLUE)
SetLog("TOP-RIGHT Objects Count: x" & $ToReturn[1], $COLOR_BLUE)
SetLog("TOP-LEFT Objects Count: x" & $ToReturn[2], $COLOR_BLUE)
SetLog("BOTTOM-LEFT Objects Count: x" & $ToReturn[3], $COLOR_BLUE)
EndIf
Return $ToReturn
EndFunc
Func GetRedLines()
If StringLen($CurBaseRedLine[0]) > 30 Then Return $CurBaseRedLine
If $DebugSideP Then $hTimer = TimerInit()
_CaptureRegion2()
Local $SingleCocDiamond = "ECD"
Local $result = DllCall($pImgLib2, "str", "SearchRedLines", "handle", $hHBitmap2, "str", $SingleCocDiamond)
If IsArray($result) Then
If $DebugSideP Then SetLog("Redline grabbed within " & Round(TimerDiff($hTimer) / 1000, 2) & " second(s)", $COLOR_GREEN)
$CurBaseRedLine[0] = $result[0]
EndIf
Return $CurBaseRedLine
EndFunc
Func _StringEqualSplit($sString, $iNumChars)
If Not IsString($sString) Or $sString = "" Then Return SetError(1, 0, 0)
If Not IsInt($iNumChars) Or $iNumChars < 1 Then Return SetError(2, 0, 0)
Return StringRegExp($sString, "(?s).{1," & $iNumChars & "}", 3)
EndFunc
Func Alogrithm_MilkingAttack()
If $THSnipeBeforeDBEnable = 1 and $searchTH = "-" Then townHallCheck(True)
If $THSnipeBeforeDBEnable = 1 Then
If $searchTH <> "-" Then
If 	SearchTownHallLoc()  Then
Setlog(_PadStringCenter(" TH snipe Before Milking ", 54,"="),$color_blue)
$THusedKing = 0
$THusedQueen = 0
AttackTHParseCSV()
Else
Setlog("TH snipe Before Milking skip, TH inside village",$color_blue)
EndIf
Else
Setlog("TH snipe Before Milking skip, no th detected",$color_blue)
EndIf
EndIf
$duringMilkingAttack = 1
Local $hTimerTOTAL = TimerInit()
Setlog(_PadStringCenter(" Milking Attack ", 54,"="),$color_blue)
If StringLen($MilkFarmObjectivesSTR) > 0 Then
Local $vect = StringSplit($MilkFarmObjectivesSTR, "|", 2)
If $debugsetlog = 1 Then Setlog("MilkFarmObjectivesSTR = <" & $MilkFarmObjectivesSTR & ">.. UBOUND=" & UBound($vect), $COLOR_DEBUG)
If UBound($vect) > 0 Then
If StringLen($vect[0]) > 0 Then
If $debugsetlog = 1 Then SetLog(">Structures to attack: (" & UBound($vect) & ")", $COLOR_DEBUG)
For $i = 0 To UBound($vect) - 1
If $debugsetlog = 1 Then Setlog("> " & $i & " " & $vect[$i], $COLOR_DEBUG)
Next
MilkFarmObjectivesDebugImage($MilkFarmObjectivesSTR, 0)
Local $troopPosition = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][1] <> -1 Then
If $atkTroops[$i][0] = $eGobl Then
If $debugsetlog = 1 Then SetLog("-*-" & $atkTroops[$i][0] & " " & NameOfTroop($atkTroops[$i][0]) & " " & $atkTroops[$i][1] & " <<---" & $eGobl, $COLOR_DEBUG)
$troopPosition = $i
Else
If $debugsetlog = 1 Then SetLog("-*-" & $atkTroops[$i][0] & " " & NameOfTroop($atkTroops[$i][0]) & " " & $atkTroops[$i][1] & "", $COLOR_DEBUG)
EndIf
EndIf
Next
If $troopPosition >= 0 Then
SelectDropTroop($troopPosition)
If UBound($vect) > 2 Then
Switch $MilkingAttackStructureOrder
Case 1
Local $rnd = _RandomUnique(UBound($vect) - 1, 0, UBound($vect) - 2, 1)
For $i = 0 To UBound($rnd) - 1
If $debugsetlog = 1 Then Setlog("random vect pos " & $i & " value " & $rnd[$i], $COLOR_DEBUG)
Next
Case 2
Local $rnd = _OrderBySideObjectives($vect)
For $i = 0 To UBound($rnd) - 1
If $debugsetlog = 1 Then Setlog("order by side vect pos " & $i & " value " & $rnd[$i], $COLOR_DEBUG)
Next
Case else
Local $tmpstr = ""
For $k=0 To UBound($vect) -1
$tmpstr &= $k &"-"
Next
$tmpstr=StringLeft($tmpStr,StringLen($tmpstr)-1)
Local $rnd = StringSplit($tmpStr,"-",2)
For $i = 0 To UBound($rnd) - 1
If $debugsetlog = 1 Then Setlog("as found vect pos " & $i & " value " & $rnd[$i], $COLOR_DEBUG)
Next
EndSwitch
For $i = 0 To UBound($rnd) - 1
Local $vect2 = StringSplit($vect[$i], ".", 2)
If UBound($vect2) > 1 Then
If $debugsetlog = 1 Then Setlog($i & "- Attack structure n. " & $rnd[$i] +1 & "/" & UBound($vect) & " - " & $vect2[0], $COLOR_DEBUG)
If UBound($vect) > $rnd[$i] Then
MilkingAttackStructure($vect[$rnd[$i]])
Else
If $debugsetlog = 1 Then Setlog($i & " range exceeded of $vect!", $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog("Error @18", $COLOR_DEBUG)
EndIf
Next
EndIf
If UBound($vect) = 2 Then
For $i = 0 To 1
If $debugsetlog = 1 Then Setlog($i & "- Attack structure n. " & $i & "/1 ", $COLOR_DEBUG)
MilkingAttackStructure($vect[$i])
Next
EndIf
If UBound($vect) = 1 Then
If $debugsetlog = 1 Then Setlog($i & "- Attack structure n. 0/0 ", $COLOR_DEBUG)
MilkingAttackStructure($vect[0])
EndIf
Else
If $debugsetlog = 1 Then Setlog("No Goblins left ", $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog("No structures to attack...", $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog("No structures to attack..", $COLOR_DEBUG)
EndIf
Else
Setlog("No structures to attack, skip attack structures!")
EndIf
If $MilkAttackAfterTHSnipe = 1 Then
townHallCheck(True)
If $searchTH <>"-" Then
If SearchTownHallLoc() Then
$iMatchMode = $TS
Setlog(_PadStringCenter(" Attack TH snipe after Milking Attack ", 54,"="),$color_blue)
If $MilkAttackAfterScriptedAtk = 0 Then
PrepareAttack($iMatchMode, True)
algorithm_AllTroops()
Else
SetSlotSpecialTroops()
$THusedKing = 0
$THusedQueen = 0
AttackTHParseCSV()
EndIf
Else
Setlog("TH it is not outside, skip attack", $color_blue)
EndIf
Else
Setlog("Cannot detect Townhall, skip THsnipe after Milking", $color_blue)
EndIf
EndIf
If $MilkAttackAfterScriptedAtk = 1 Then
Setlog(_PadStringCenter("Scripted Attack after Miliking ", 54,"="),$color_blue)
Algorithm_AttackCSV(False,False)
EndIf
$duringMilkingAttack = 0
EndFunc
Func _OrderBySideObjectives($vect)
Local $slice1 = ""
Local $slice2 = ""
Local $slice3 = ""
Local $slice4 = ""
Local $slice5 = ""
Local $slice6 = ""
Local $slice7 = ""
Local $slice8 = ""
For $j = 0 To Ubound($vect) -1
Local $structure = StringSplit($vect[$j],".",2)
Local $pixel = StringSplit($structure[2],"-",2)
Switch StringLeft(Slice8($pixel),1)
Case 1
$slice1 &= $j & "-"
Case 2
$slice2 &= $j & "-"
Case 3
$slice3 &= $j & "-"
Case 4
$slice4 &= $j & "-"
Case 5
$slice5 &= $j & "-"
Case 6
$slice6 &= $j & "-"
Case 7
$slice7 &= $j & "-"
Case else
$slice8 &= $j & "-"
EndSwitch
Next
Local $result
If $slice7 <>"" Then $result &=$slice7
If $slice8 <>"" Then $result &=$slice8
If $slice1 <>"" Then $result &=$slice1
If $slice2 <>"" Then $result &=$slice2
If $slice3 <>"" Then $result &=$slice3
If $slice4 <>"" Then $result &=$slice4
If $slice5 <>"" Then $result &=$slice5
If $slice6 <>"" Then $result &=$slice6
$result = StringLeft($result,StringLen($result)-1)
Return StringSplit($result,"-",2)
EndFunc
Func AmountOfResourcesInStructure($type, $coordinate, $level)
Switch $type
Case "elixir"
If $level <= 8 And $level >= 0 Then
Local $temp = Int($MilkFarmElixirParam[$level])
If $temp > 0 Then
If $MilkAttackType = 0 Then
Local $capacity = DetectAmountOfResourceInStructure($type, $coordinate, $level, $temp)
If $capacity >= $temp Then
If $debugsetlog=1 Then Setlog("elixir " & $type & " " & $coordinate & " " & $level & " " & $capacity , $COLOR_DEBUG)
Return True
Else
If $debugsetlog = 1 Then Setlog("Discard, capacity of structure under settings:  liv " & $level & " cap " & $temp  & " detected "& $capacity, $COLOR_DEBUG)
EndIf
Else
If $debugsetlog=1 Then Setlog("elixir " & $type & " " & $coordinate & " " & $level & " PASSED LOW CPU SETTINGS" , $COLOR_DEBUG)
Return True
EndIf
Else
If $debugsetlog = 1 Then Setlog("Discard, level settings discard this structure (requested min. " & Int($MilkFarmElixirParam[$level]) & ")", $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog("Discard, out of bounds", $COLOR_DEBUG)
EndIf
Return False
Case "mine"
If $level <= 8 And $level >= 0 Then
If $level >= $MilkFarmMineParam Then
Return True
Else
If $debugsetlog = 1 Then Setlog("Discard, level settings discard this structure (level=" & $level & ",filter=" & $MilkFarmMineParam & ")", $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog("Discard, out of bounds", $COLOR_DEBUG)
EndIf
Return False
Case "drill"
If $level <= 6 And $level >= 1 Then
If $level >= $MilkFarmDrillParam Then
Return True
Else
If $debugsetlog = 1 Then Setlog("Discard, level settings discard this structure (level=" & $level & ",filter=" & $MilkFarmDrillParam & ")", $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog("Discard, out of bounds", $COLOR_DEBUG)
EndIf
Return False
Case Else
Return False
EndSwitch
EndFunc
Func DetectAmountOfResourceInStructure($type, $coordinate, $level, $mincapacity)
If $type = "elixir" Then
Local $tolerance
Local $posx, $posy
Local $levelanalized
Local $filename
Local $endoffilename
_CaptureRegion($coordinate[0] - 10, $coordinate[1] - 10, $coordinate[0] + 10, $coordinate[1] + 20)
Local $found = 0
For $t = UBound(Eval("CapacityStructureElixir" & $level)) - 1 To 1 Step -1
$filename = Execute("$CapacityStructureElixir" & $level & "[" & $t & "]")
$capacityanalized = StringMid($filename, StringInStr($filename, "_", 0, 2) + 1, StringInStr($filename, "_", 0, 3) - StringInStr($filename, "_", 0, 2) - 1)
$tolerance = StringMid($filename, StringInStr($filename, "_", 0, 3) + 1, StringInStr($filename, "_", 0, 4) - StringInStr($filename, "_", 0, 3) - 1)
If $MilkFarmForcetolerance = 1 Then
$endoffilename = StringMid($filename, StringInStr($filename, "_", 0, 4) + 1, 1)
If $endoffilename = "Z" Then
$tolerance = $MilkFarmForcetoleranceboosted
Else
$tolerance = $MilkFarmForcetolerancenormal
EndIf
EndIf
If $capacityanalized < $mincapacity And $continuesearchelixirdebug = 0 Then
If $debugsetlog = 1 Then Setlog("IMAGECKECK STOP, capacity < mincapacity " & $filename, $COLOR_DEBUG)
Return -1
ExitLoop
Else
$found = _ImageSearch(@ScriptDir & "\images\CapacityStructure\" & Execute("$CapacityStructureElixir" & $level & "[" & $t & "]"), 1, $posx, $posy, $tolerance)
If $found = 1 Then
If $debugsetlog = 1 Then Setlog("IMAGECKECK OK (" & $tolerance & ") " & $filename, $COLOR_DEBUG)
If $debugImageSave = 1 Then DebugImageSave("IMAGECKECK OK (" & $tolerance & ") " & $filename, False)
Return $capacityanalized
ExitLoop
EndIf
EndIf
Next
If $found = 0 Then
If $debugImageSave = 1 Then DebugImageSave("elixir_" & $level & "_", False)
If $debugsetlog = 1 Then SETLOG("FAIL STRUCTURE POSITION (" & $coordinate[0] & "," & $coordinate[1] & ") level " & $level & " (" & $level + 4 & ")", $COLOR_DEBUG)
EndIf
Return -1
Else
Return -1
EndIf
EndFunc
Func MilkFarmObjectivesSTR_INSERT($type, $level, $coordinate)
Local $ResourceToInsertQty = 0
Local $ResourceToInsert = ""
$ResourceToInsert = $type
$ResourceToInsert &= "." & $level
$ResourceToInsert &= "." & $coordinate
$pixel = StringSplit($coordinate, "-", 2)
Local $diamondx = $MilkFarmOffsetX + $MilkFarmOffsetXStep * $MilkFarmResMaxTilesFromBorder
Local $diamondy = $MilkFarmOffsetY + $MilkFarmOffsetYStep * $MilkFarmResMaxTilesFromBorder
If UBound($pixel) = 2 Then
Switch $type
Case "gomine"
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
Case "elixir"
Local $px = StringSplit($MilkFarmOffsetElixir[$level], "-", 2)
Case "ddrill"
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
Case Else
Local $px = StringSplit("0-0", "-", 2)
EndSwitch
$pixel[0] += $px[0]
$pixel[1] += $px[1]
Local $vector = $PixelTopLeft
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_DEBUG)
EndIf
Next
Local $vector = $PixelTopRight
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_DEBUG)
EndIf
Next
Local $vector = $PixelBottomLeft
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_DEBUG)
EndIf
Next
Local $vector = $PixelBottomRight
For $i = 0 To UBound($vector) - 1
Local $pixel2 = $vector[$i]
If UBound($pixel2) = 2 Then
If Abs(($pixel[0] - $pixel2[0]) / $diamondx) + Abs(($pixel[1] - $pixel2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixel2[0] & "-" & $pixel2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #3", $COLOR_DEBUG)
EndIf
Next
If $ResourceToInsertQty > 0 Then
If StringLen($MilkFarmObjectivesSTR) > 0 Then $MilkFarmObjectivesSTR &= "|"
$MilkFarmObjectivesSTR &= $ResourceToInsert
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkFarmObjectivesSTR_INSERT Discard error #1 " & $pixel & " " & UBound($pixel), $COLOR_DEBUG)
EndIf
Return $ResourceToInsertQty
EndFunc
Func LoadAmountOfResourcesImages()
Local $x
Local $path = @ScriptDir & "\images\CapacityStructure\"
Local $useImages = "*.bmp"
For $t = 0 To 8
Assign("CapacityStructureElixir" & $t, StringSplit("", ""))
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "elixir_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then Assign("CapacityStructureElixir" & $t, $x)
Next
For $t = 0 To 8
Assign("DestroyedMineIMG" & $t, StringSplit("", ""))
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "destroyed_mine_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then Assign("DestroyedMineIMG" & $t, $x)
Next
For $t = 0 To 8
Assign("DestroyedElixirIMG" & $t, StringSplit("", ""))
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "destroyed_elixir_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then Assign("DestroyedElixirIMG" & $t, $x)
Next
For $t = 0 To 8
Assign("DestroyedDarkIMG" & $t, StringSplit("", ""))
$x = _FileListToArrayRec(@ScriptDir & "\images\CapacityStructure\", "destroyed_dark_" & $t & $useImages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) > 0 Then Assign("DestroyedDarkIMG" & $t, $x)
Next
EndFunc
Func MilkFarmObjectivesDebugImage($vector, $maxtiles = 0)
If $debugMilkingIMGmake = 1 Then
_CaptureRegion()
Local $EditedImage
$EditedImage = $hBitmap
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($EditedImage)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
For $i = 0 To UBound($PixelTopLeft) - 1
$pixel = $PixelTopLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
For $i = 0 To UBound($PixelTopRight) - 1
$pixel = $PixelTopRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
For $i = 0 To UBound($PixelBottomLeft) - 1
$pixel = $PixelBottomLeft[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
For $i = 0 To UBound($PixelBottomRight) - 1
$pixel = $PixelBottomRight[$i]
_GDIPlus_GraphicsDrawEllipse($hGraphic, $pixel[0], $pixel[1], 2, 2, $hPen)
Next
Local $testx = StringSplit($vector, "|", 2)
For $i = 0 To UBound($testx) - 1
Local $pixel1 = StringSplit($testx[$i], ".", 2)
If UBound($pixel1) >= 2 Then
Local $level = $pixel1[1]
Else
Local $level = 0
EndIf
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Switch $pixel1[0]
Case "gomine"
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
Case "elixir"
Local $px = StringSplit($MilkFarmOffsetElixir[$level], "-", 2)
Case "ddrill"
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
Case Else
Local $px = StringSplit("0-0", "-", 2)
EndSwitch
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
If UBound($pixel1) >= 2 Then
$pixel = StringSplit($pixel1[2], "-", 2)
If UBound($pixel) = 2 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 1)
Local $x = 20
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $x, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - 10, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + 10, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $x, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $x, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx - 10, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx + 10, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx + $x, $pixel[1] + $resourceoffsety, $hPen)
If $maxtiles >= 0 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFF0026FF, 1)
Local $multiplier = 0
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
EndIf
If $maxtiles >= 1 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFF00FFFF, 1)
Local $multiplier = 1
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
EndIf
If $maxtiles >= 2 Then
_GDIPlus_PenDispose($hPen)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $multiplier = 2
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx - $MilkFarmOffsetX - $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety - $MilkFarmOffsetY - $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, $pixel[0] + $resourceoffsetx, $pixel[1] + $resourceoffsety + $MilkFarmOffsetY + $MilkFarmOffsetYStep * $multiplier, $pixel[0] + $resourceoffsetx + $MilkFarmOffsetX + $MilkFarmOffsetXStep * $multiplier, $pixel[1] + $resourceoffsety, $hPen)
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkFarmObjectivesDebugImage #1", $COLOR_DEBUG)
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkFarmObjectivesDebugImage #2", $COLOR_DEBUG)
EndIf
Next
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $savefolder = $dirTempDebug & "MilkFarmDebug_" & "\"
DirCreate($savefolder)
Local $filename = String("MilkFarmDebug_" & $Date & "_" & $Time)
_GDIPlus_ImageSaveToFile($EditedImage, $savefolder & $filename & ".jpg")
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
EndFunc
Func MilkingAttackStructure($vectstr)
If $debugsetlog = 1 Then SetLog("###### Attack " & $vectstr & "######", $COLOR_DEBUG)
Local $vect = StringSplit($vectstr, ".", 2)
If UBound($vect) = 4 Then
Local $temp = $vect[3]
Local $aRnd[1] = [$temp]
Else
Local $troopxwave
If $MilkFarmTroopForWaveMin = $MilkFarmTroopForWaveMax Then
$troopxwave = $MilkFarmTroopForWaveMin
Else
$troopxwave = Random($MilkFarmTroopForWaveMin, $MilkFarmTroopForWaveMax, 1)
EndIf
If $debugsetlog = 1 Then Setlog("drop n.: " & $troopxwave & " troops | structure:" & $vect[0], $COLOR_DEBUG)
Local $skipdelay = False
For $i = 1 To $MilkFarmTroopMaxWaves
If $debugsetlog = 1 Then Setlog("Wave attack number " & $i, $COLOR_DEBUG)
$skipdelay = False
If IsAttackPage() Then
If $MilkingAttackCheckStructureDestroyedBeforeAttack = 1 Then
If MilkingAttackStructureDestroyed($vect[0], $vect[1], $vect[2]) Then
$skipdelay = True
ExitLoop
EndIf
EndIf
If $MilkingAttackDropGoblinAlgorithm = 1 Then
For $j = 1 To $troopxwave
If UBound($vect) = 4 Then
Local $rndpos = 3
Else
Local $rndpos = Random(3, UBound($vect) - 1, 1)
EndIf
$pixel = StringSplit($vect[$rndpos], "-", 2)
Local $delaypoint = 0
If UBound($pixel) = 2 Then
Click($pixel[0], $pixel[1], 1, $delaypoint, "#0777")
Else
If $debugsetlog = 1 Then Setlog("MilkingAttackStructure error #1")
EndIf
Next
Else
If UBound($vect) = 4 Then
Local $rndpos = 3
Else
Local $rndpos = Random(3, UBound($vect) - 1, 1)
EndIf
$pixel = StringSplit($vect[$rndpos], "-", 2)
If UBound($pixel) = 2 Then
Click($pixel[0], $pixel[1], $troopxwave, Random(2, 7, 1), "#0778")
Else
If $debugsetlog = 1 Then Setlog("MilkingAttackStructure error #1", $COLOR_DEBUG)
EndIf
EndIf
Else
If $debugsetlog = 1 Then Setlog("You are not in Attack phase", $COLOR_DEBUG)
Return
EndIf
If $skipdelay = False Then
Local $delayfromwaves
If $MilkFarmDelayFromWavesMin = $MilkFarmDelayFromWavesMax Then
$delayfromwaves = $MilkFarmDelayFromWavesMin
Else
$delayfromwaves = Random($MilkFarmDelayFromWavesMin, $MilkFarmDelayFromWavesMax, 1)
EndIf
If $debugsetlog = 1 Then Setlog("wait " & $delayfromwaves, $COLOR_DEBUG)
If _Sleep($delayfromwaves) Then Return
EndIf
Next
If $MilkingAttackCheckStructureDestroyedAfterAttack = 1 Then
If MilkingAttackStructureDestroyed($vect[0], $vect[1], $vect[2]) Then Return
EndIf
EndIf
EndFunc
Func MilkingAttackStructureDestroyed($type, $level, $coordinate)
$pixel = StringSplit($coordinate, "-", 2)
Switch $type
Case "gomine"
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
Local $name = "Mine"
Case "elixir"
Local $px = StringSplit($MilkFarmOffsetElixir[$level], "-", 2)
Local $name = "Elixir"
Case "ddrill"
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
Local $name = "Dark"
Case Else
Local $px = StringSplit("0-0", "-", 2)
Local $name = ""
If $debugsetlog = 1 Then Setlog("MilkingAttackStructureDestroyed error #1", $COLOR_DEBUG)
EndSwitch
$pixel[0] += $px[0]
$pixel[1] += $px[1]
If UBound($pixel) = 2 Then
_CaptureRegion($pixel[0] - 15, $pixel[1] - 15, $pixel[0] + 15, $pixel[1] + 15)
Local $found = 0
Local $posx, $posy
If $debugsetlog = 1 Then Setlog("##start search in vector Destroyed" & $name & "IMG" & $level & ": numbers of files=" & UBound(Eval("Destroyed" & $name & "IMG" & $level)), $COLOR_DEBUG)
For $t = UBound(Eval("Destroyed" & $name & "IMG" & $level)) - 1 To 1 Step -1
$filename = Execute("$Destroyed" & $name & "IMG" & $level & "[" & $t & "]")
$tolerance = Int(StringMid($filename, StringInStr($filename, "_", 0, 3) + 1, StringInStr($filename, "_", 0, 4) - StringInStr($filename, "_", 0, 3) - 1))
If $MilkFarmForcetolerance = 1 Then $tolerance = Int($MilkFarmForcetolerancedestroyed)
$found = _ImageSearch(@ScriptDir & "\images\CapacityStructure\" & Execute("$Destroyed" & $name & "IMG" & $level & "[" & $t & "]"), 1, $posx, $posy, $tolerance)
If $found = 1 Then
If $debugsetlog = 1 Then Setlog("IMAGECKECK OK " & $filename, $COLOR_DEBUG)
If $debugsetlog = 1 Then SetLog(">>Structure Destroyed! (" & $name & "," & $level & "," & $tolerance & ")", $COLOR_DEBUG)
Return True
ExitLoop
Else
EndIf
Next
If $found = 0 Then
DebugImageSave("debugMilkingAttackStructureDestroyed_" & $type & "_" & $level & "_", False)
EndIf
Return False
Else
If $debugsetlog = 1 Then Setlog("error MilkingAttackStructureDestroyed #1", $COLOR_DEBUG)
EndIf
EndFunc
Func _RandomUnique($iCount, $nMin, $nMax, $iInt = 0, $nSeed = Default)
Select
Case ($iCount < 1)
Return SetError(1, 0, 0)
Case ($iCount > 10 ^ 6 - 1)
Return SetError(2, 0, 0)
Case ($nMin = $nMax)
Return SetError(3, 0, 0)
Case ($nMin > $nMax)
Return SetError(4, 0, 0)
Case (($nMin < -2 ^ 31) Or ($nMax > 2 ^ 31 - 1))
Return SetError(5, 0, 0)
EndSelect
If IsNumber($nSeed) Then
If (($nSeed < -2 ^ 31) Or ($nSeed > 2 ^ 31 - 1)) Then Return SetError(6, 0, 0)
SRandom($nSeed)
EndIf
Local $iCountInval = 0
If ($iInt) Then
If ($nMin >= 0) Then
If ($iCount > ($nMax - $nMin) + 1) Then
$iCountInval = 1
ElseIf ($iCount = ($nMax - $nMin) + 1) Then
$iCountInval = 3
EndIf
Else
If ($iCount > ($nMax + Abs($nMin) + 1)) Then
$iCountInval = 2
ElseIf ($iCount = ($nMax + Abs($nMin) + 1)) Then
$iCountInval = 3
EndIf
EndIf
EndIf
If ($iInt And $iCount = 1) Then
Local $aArray[2] = [1, Random($nMin, $nMax, $iInt)]
ElseIf $iCountInval Then
If $iCountInval = 1 Then
$iCount = Int($nMax - $nMin) + 1
ElseIf $iCountInval = 2 Then
$iCount = Int($nMax + Abs($nMin)) + 1
EndIf
If $iCountInval = 3 Then $iCountInval = 0
Local $aTmp, $iA, $iNumber = $nMin, $aArray[$iCount + 1] = [$iCount]
For $i = 1 To $aArray[0]
$aArray[$i] = $iNumber
$iNumber += 1
Next
For $i = 1 To $aArray[0]
$iA = Random($i, $aArray[0], 1)
If $i = $iA Then ContinueLoop
If $iA = 0 Then $iA = $aArray[0]
$aTmp = $aArray[$i]
$aArray[$i] = $aArray[$iA]
$aArray[$iA] = $aTmp
Next
Else
Local $nRnd, $iStep = 0, $aArray[$iCount + 1] = [$iCount]
While ($iStep <= $iCount - 1)
$nRnd = Random($nMin, $nMax, $iInt)
If IsDeclared($nRnd) <> -1 Then
$iStep += 1
$aArray[$iStep] = $nRnd
Assign($nRnd, '', 1)
EndIf
WEnd
EndIf
Return SetError(0, Number($iCountInval > 0), $aArray)
EndFunc
Func MilkingDetectElixirExtractors()
If $MilkFarmAttackElixirExtractors = 1 and $iElixirCurrent >= $MilkFarmLimitElixir Then
If $debugsetlog=1 Then setlog("skip attack of elixir extractors, current elixir (" & $iElixirCurrent & ") >= limit (" & $MilkFarmLimitElixir & ")", $COLOR_DEBUG)
return 0
Else
If $debugsetlog=1 Then setlog("current elixir (" & $iElixirCurrent & ") < limit (" & $MilkFarmLimitElixir & ")", $COLOR_DEBUG)
EndIf
$MilkFarmObjectivesSTR = ""
Local $MilkFarmAtkPixelListSTR = ""
Local $hTimer = TimerInit()
_CaptureRegion2()
Local $ElixirVect = StringSplit(GetLocationElixirWithLevel(), "~", 2)
Local $elixirfounds = UBound($ElixirVect)
Local $elixirmatch = 0
Local $elixirdiscard = 0
Local $redareapointsnearstructure = ""
For $i = 0 To UBound($ElixirVect) - 1
If $debugsetlog = 1 Then Setlog($i & " : " & $ElixirVect[$i], $COLOR_DEBUG)
Local $temp = StringSplit($ElixirVect[$i], "#", 2)
If UBound($temp) = 2 Then
$pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
$redareapointsnearstructure = MilkingRedAreaPointsNearStructure("elixir", $temp[0], $temp[1])
if $redareapointsnearstructure <>"" Then
If AmountOfResourcesInStructure("elixir", $pixel, $temp[0]) Then
If $MilkFarmLocateElixir = 1 Then
if $MilkFarmObjectivesSTR <> "" then 		  $MilkFarmObjectivesSTR &= "|"
$MilkFarmObjectivesSTR &= "elixir"
$MilkFarmObjectivesSTR &= "." & $temp[0]
$MilkFarmObjectivesSTR &= "." & $temp[1]
$MilkFarmObjectivesSTR &= $redareapointsnearstructure
$elixirmatch += 1
Else
If $debugsetlog = 1 Then Setlog(" - discard #6 skip locate elixir", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #5 no match condition % amount of elixir", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #4 no redarea points matching conditions", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
If $debugresourcesoffset = 1 Then
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Local $px = StringSplit($MilkFarmOffsetElixir[$temp[0]], "-", 2)
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
_CaptureRegion($pixel[0] + $resourceoffsetx - 30, $pixel[1] + $resourceoffsety - 30, $pixel[0] + $resourceoffsetx + 30, $pixel[1] + $resourceoffsety + 30)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $multiplier = 2
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmap)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, 30, 60, 30, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, 30, 0, 30, 60, $hPen)
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
DebugImageSave("debugresourcesoffset_" & "elixir" & "_" & $temp[0] & "_",  False)
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #3 out of insidediamond", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #2 no pixel coordinate", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #1 no valid point", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Next
If StringLen($MilkFarmAtkPixelListSTR) > 1 Then
$MilkFarmAtkPixelListSTR = StringLeft($MilkFarmAtkPixelListSTR, StringLen($MilkFarmAtkPixelListSTR) - 1)
EndIf
If $debugsetlog = 1 Then Setlog("> Elixir Extractors to attack list: " & $MilkFarmAtkPixelListSTR, $COLOR_DEBUG)
Local $htimerLocateElixir = Round(TimerDiff($hTimer) / 1000, 2)
If $debugsetlog = 1 Then Setlog("> Elixir Extractors found: " & $elixirfounds & " | match conditions: " & $elixirmatch & " | discard " & $elixirdiscard, $COLOR_DEBUG)
If $debugsetlog = 1 Then SetLog("> Elixir Extractors position and %full detectecd in " & $htimerLocateElixir & " seconds", $COLOR_DEBUG)
Return $elixirmatch
EndFunc
Func MilkingDetectMineExtractors()
If $MilkFarmAttackGoldMines = 1 and $iGoldCurrent >= $MilkFarmLimitGold Then
If $debugsetlog=1 Then setlog("skip attack of gold mines, current gold (" & $iGoldCurrent & ") >= limit (" & $MilkFarmLimitGold & ")", $COLOR_DEBUG)
return 0
Else
If $debugsetlog=1 Then setlog("current gold (" & $iGoldCurrent & ") < limit (" & $MilkFarmLimitGold & ")", $COLOR_DEBUG)
EndIf
Local $MilkFarmAtkPixelListMINESTR = ""
If $MilkFarmLocateMine = 1 Then
Local $hTimer = TimerInit()
_CaptureRegion2()
Local $MineVect = StringSplit(GetLocationMineWithLevel(), "~", 2)
Local $Minefounds = 0
Local $Minematch = 0
Local $Minediscard = 0
For $i = 0 To UBound($MineVect) - 1
Local $temp = StringSplit($MineVect[$i], "#", 2)
If UBound($temp) = 2 Then
Local $pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
Local $tempPixel[2] = [$pixel[0] , $pixel[1] ]
$pixel = $tempPixel
$temp[1] = String($pixel[0] & "-" & $pixel[1])
If isInsideDiamondRedArea($pixel) Then
$Minefounds += 1
If $debugresourcesoffset = 1 Then
Local $level = $temp[0]
Local $type = "mine"
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
_CaptureRegion($pixel[0] + $resourceoffsetx - 30, $pixel[1] + $resourceoffsety - 30, $pixel[0] + $resourceoffsetx + 30, $pixel[1] + $resourceoffsety + 30)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $multiplier = 2
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmap)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, 30, 60, 30, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, 30, 0, 30, 60, $hPen)
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
DebugImageSave("debugresourcesoffset_" & $type & "_" & $level & "_" , False)
EndIf
If AmountOfResourcesInStructure("mine", $pixel, $temp[0]) Then
$MilkFarmAtkPixelListMINESTR &= $temp[1] & "|"
If MilkFarmObjectivesSTR_INSERT("gomine", $temp[0], $temp[1]) Then
$Minematch += 1
Else
$Minediscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #4 no match conditions", $COLOR_DEBUG)
$Minediscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #3 out of insidediamond", $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #2 no pixel coordinate", $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #1 no valid point", $COLOR_DEBUG)
$Minediscard += 1
EndIf
Next
If StringLen($MilkFarmAtkPixelListMINESTR) > 1 Then $MilkFarmAtkPixelListMINESTR = StringLeft($MilkFarmAtkPixelListMINESTR, StringLen($MilkFarmAtkPixelListMINESTR) - 1)
If $debugsetlog = 1 Then Setlog("> Mine Extractors to attack list: " & $MilkFarmAtkPixelListMINESTR, $COLOR_DEBUG)
Local $htimerLocateMine = Round(TimerDiff($hTimer) / 1000, 2)
If $debugsetlog = 1 Then Setlog("> Mine Extractors found: " & $Minefounds & " | match conditions: " & $Minematch & " | discard " & $Minediscard, $COLOR_DEBUG)
If $debugsetlog = 1 Then SetLog("> Mine Extractors position detectecd in " & $htimerLocateMine & " seconds", $COLOR_DEBUG)
Return $Minematch
Else
Return 0
EndIf
EndFunc
Func MilkingDetectDarkExtractors()
If $MilkFarmAttackDarkDrills = 1 and Number($iDarkCurrent) >= number($MilkFarmLimitDark) Then
If $debugsetlog=1  and $MilkFarmAttackDarkDrills = 1 Then setlog("skip attack of dark drills, current dark (" & $iDarkCurrent & ") >= limit (" & $MilkFarmLimitDark & ")", $COLOR_DEBUG)
If $debugsetlog=1  and $MilkFarmAttackDarkDrills = 0 Then setlog("skip attack of dark drills", $COLOR_DEBUG)
return 0
Else
If $debugsetlog=1 Then setlog("current dark (" & $iDarkCurrent & ") < limit (" & $MilkFarmLimitDark & ")", $COLOR_DEBUG)
EndIf
Local $MilkFarmAtkPixelListDRILLSTR = ""
If $MilkFarmLocateDrill = 1 Then
Local $hTimer = TimerInit()
_CaptureRegion2()
Local $DrillVect = StringSplit(GetLocationDarkElixirWithLevel(), "~", 2)
Local $Drillfounds = UBound($DrillVect)
Local $Drillmatch = 0
Local $Drilldiscard = 0
For $i = 0 To UBound($DrillVect) - 1
Local $temp = StringSplit($DrillVect[$i], "#", 2)
If UBound($temp) = 2 Then
$pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
If $debugresourcesoffset = 1 Then
Local $level = $temp[0]
Local $type = "drill"
Local $resourceoffsetx = 0
Local $resourceoffsety = 0
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
$resourceoffsetx = $px[0]
$resourceoffsety = $px[1]
_CaptureRegion($pixel[0] + $resourceoffsetx - 30, $pixel[1] + $resourceoffsety - 30, $pixel[0] + $resourceoffsetx + 30, $pixel[1] + $resourceoffsety + 30)
Local $hPen = _GDIPlus_PenCreate(0xFFFFD800, 1)
Local $multiplier = 2
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmap)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
_GDIPlus_GraphicsDrawLine($hGraphic, 0, 30, 60, 30, $hPen)
_GDIPlus_GraphicsDrawLine($hGraphic, 30, 0, 30, 60, $hPen)
_GDIPlus_PenDispose($hPen)
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
DebugImageSave("debugresourcesoffset_" & $type & "_" & $level & "_" , False)
EndIf
If AmountOfResourcesInStructure("drill", $pixel, $temp[0]) Then
$MilkFarmAtkPixelListDRILLSTR &= $temp[1] & "|"
If MilkFarmObjectivesSTR_INSERT("ddrill", $temp[0], $temp[1]) > 0 Then
$Drillmatch += 1
Else
$Drilldiscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #4 no match conditions", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #3 out of insidediamond", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #2 no pixel coordinate", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #1 no valid point", $COLOR_DEBUG)
$Drilldiscard += 1
EndIf
Next
If StringLen($MilkFarmAtkPixelListDRILLSTR) > 1 Then $MilkFarmAtkPixelListDRILLSTR = StringLeft($MilkFarmAtkPixelListDRILLSTR, StringLen($MilkFarmAtkPixelListDRILLSTR) - 1)
If $debugsetlog = 1 Then Setlog("> Drill Extractors to attack list: " & $MilkFarmAtkPixelListDRILLSTR, $COLOR_DEBUG)
Local $htimerLocateDrill = Round(TimerDiff($hTimer) / 1000, 2)
If $debugsetlog = 1 Then Setlog("> Drill Extractors found: " & $Drillfounds & " | match conditions: " & $Drillmatch & " | discard " & $Drilldiscard, $COLOR_DEBUG)
If $debugsetlog = 1 Then SetLog("> Drill Extractors position detectecd in " & $htimerLocateDrill & " seconds", $COLOR_DEBUG)
Return $Drillmatch
Else
Return 0
EndIf
EndFunc
Func MilkingDetectRedArea()
$MilkFarmObjectivesSTR = ""
Local $hTimer = TimerInit()
_CaptureRegion2()
_GetRedArea()
Local $htimerREDAREA = Round(TimerDiff($hTimer) / 1000, 2)
If $debugsetlog = 1 Then SetLog("> RedArea completed in " & $htimerREDAREA & " seconds", $COLOR_DEBUG)
CleanRedArea($PixelTopLeft)
CleanRedArea($PixelTopRight)
CleanRedArea($PixelBottomLeft)
CleanRedArea($PixelBottomRight)
EndFunc
Func MilkingDebug()
Local $debugselogLocal = $debugsetlog
Local $MilkingExtractorsMatch
$debugsetlog = 1
Setlog("1 - Zoom out")
CheckZoomOut()
Local $TimeCheckMilkingAttack = TimerInit()
Setlog("2 - Detect Elixir Collectors")
Setlog("  2.1 Detect RedArea")
MilkingDetectRedArea()
$MilkFarmObjectivesSTR = ""
Setlog("  2.2bis detect elixir extractors2")
$MilkingExtractorsMatch = MilkingDetectElixirExtractors()
Setlog("  2.3 Detect Mine Extractors")
$MilkingExtractorsMatch += MilkingDetectMineExtractors()
Setlog("  2.4 Detect Dark Elixir Extractors")
Local $TimeCheckMilkingAttackSeconds = Round(TimerDiff($TimeCheckMilkingAttack) / 1000, 2)
Setlog("Computing Time Milking Attack : " & $TimeCheckMilkingAttackSeconds & " seconds", $color_blue)
$debugsetlog = $debugselogLocal
Setlog("Make DebugImage")
MilkFarmObjectivesDebugImage($MilkFarmObjectivesSTR, 0)
EndFunc
Func CheckMilkingBaseTest()
Local $MilkingElixirImages = _FileListToArray(@ScriptDir & "\images\Milking\Elixir", "*.*")
If @error = 1 Then
MsgBox(0, "", "Folder" &  @ScriptDir & "\images\Milking\Elixir" & " not Found.", 30)
EndIf
If @error = 4 Then
MsgBox(0, "", "No Files in folder " &@ScriptDir & "\images\Milking\Elixir" , 30)
EndIf
Setlog("Locate Elixir..." )
$hTimer = TimerInit()
_CaptureRegion2()
_CaptureRegion()
$sendHBitmap = _GDIPlus_BitmapCreateHBITMAPFromBitmap($hBitmap)
Local $MilkFarmAtkPixelListSTR = ""
Local $ElixirVect = StringSplit(GetLocationElixirWithLevel(), "~", 2)
Local $elixirfounds = UBound($ElixirVect)
Local $elixirmatch = 0
Local $elixirdiscard = 0
For $i = 0 To UBound($ElixirVect) - 1
Local $temp = StringSplit($ElixirVect[$i], "#", 2)
If UBound($temp) = 2 Then
Setlog("examine elixir vector #" & $i & " placed in " & $ElixirVect[$i],$COLOR_RED)
Local $pixelTemp = StringSplit($ElixirVect[$i],"-",2)
$pixelTemp[0] += 0
$pixelTemp[1] += 10
Local $arrPixelsCloser = _FindPixelCloser($PixelRedArea, $pixelTemp, 1)
Setlog("pixelcloser=" & $arrPixelsCloser & "ubound = " & Ubound($arrPixelsCloser))
For $t=0 to Ubound($arrPixelsCloser) -1
Local $temp = $arrPixelsCloser[$t]
Setlog("$arrPixelsCloser " & $arrPixelsCloser[$t] & " ubound = " & Ubound($temp) & " " & $temp[0] & "-" & $temp[1])
Next
If UBound($arrPixelsCloser) > 1 Then
EndIf
Else
If $debugsetlog = 1 Then Setlog(" - discard #1 no valid point", $COLOR_DEBUG)
$elixirdiscard += 1
EndIf
Setlog("............ next ..........")
Next
EndFunc
Func MilkingRedAreaPointsNearStructure($type, $level, $coordinate)
Local $ResourceToInsertQty = 0
Local $ResourceToInsert = ""
Local $pixelCoord = StringSplit($coordinate, "-", 2)
Local $diamondx = $MilkFarmOffsetX + $MilkFarmOffsetXStep * $MilkFarmResMaxTilesFromBorder
Local $diamondy = $MilkFarmOffsetY + $MilkFarmOffsetYStep * $MilkFarmResMaxTilesFromBorder
If UBound($pixelCoord) = 2 Then
Switch $type
Case "gomine"
Local $px = StringSplit($MilkFarmOffsetMine[$level], "-", 2)
Case "elixir"
Local $px = StringSplit($MilkFarmOffsetElixir[$level], "-", 2)
Case "ddrill"
Local $px = StringSplit($MilkFarmOffsetDark[$level], "-", 2)
Case Else
Local $px = StringSplit("0-0", "-", 2)
EndSwitch
$pixelCoord[0] += $px[0]
$pixelCoord[1] += $px[1]
Local $vector = $pixelTopLeft
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_DEBUG)
EndIf
Next
Local $vector = $pixelTopRight
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_DEBUG)
EndIf
Next
Local $vector = $pixelBottomLeft
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_DEBUG)
EndIf
Next
Local $vector = $pixelBottomRight
For $i = 0 To UBound($vector) - 1
Local $pixelCoord2 = $vector[$i]
If UBound($pixelCoord2) = 2 Then
If Abs(($pixelCoord[0] - $pixelCoord2[0]) / $diamondx) + Abs(($pixelCoord[1] - $pixelCoord2[1]) / $diamondy) <= 1 Then
$ResourceToInsert &= "." & $pixelCoord2[0] & "-" & $pixelCoord2[1]
$ResourceToInsertQty += 1
EndIf
Else
If $DebugSetLog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #3", $COLOR_DEBUG)
EndIf
Next
If $debugsetlog=1 Then Setlog("$ResourceToInsertQty = " & $ResourceToInsertQty & " value " & $ResourceToInsert, $COLOR_DEBUG)
Return $ResourceToInsert
Else
If $DebugSetLog = 1 Then Setlog("MilkingRedAreaPointsNearStructure Discard error #1 " & $pixelCoord & " " & UBound($pixelCoord), $COLOR_DEBUG)
EndIf
EndFunc
Func CheckMilkingBase($matchDB, $dbBase)
Local $MilkingExtractorsMatch = 0
$MilkFarmObjectivesSTR = ""
$milkingAttackOutside = 0
If $matchDB And $iAtkAlgorithm[$DB] = 2 Then
If ( ( $MilkAttackType=1 and $dbBase )  or ( $MilkAttackType= 0 ) )  then
Local $TimeCheckMilkingAttack = TimerInit()
If $debugsetlog = 1 Then Setlog("Check Milking...", $COLOR_DEBUG)
MilkingDetectRedArea()
$MilkingExtractorsMatch = MilkingDetectElixirExtractors()
If $MilkingExtractorsMatch > 0 Then
$MilkingExtractorsMatch += MilkingDetectMineExtractors() + MilkingDetectDarkExtractors()
EndIf
If StringLen($MilkFarmObjectivesSTR) > 0 Then
If $MilkAttackType = 1 Then
If $debugsetlog = 1 Then Setlog("Milking match LOW CPU SETTINGS", $COLOR_DEBUG)
If $debugsetlog = 1 Then Setlog("objectives: " & $MilkFarmObjectivesSTR , $COLOR_DEBUG)
Else
If $debugsetlog = 1 Then Setlog("Milking match HIGH CPU SETTINGS", $COLOR_DEBUG)
If $debugsetlog = 1 Then Setlog("objectives: " & $MilkFarmObjectivesSTR , $COLOR_DEBUG)
EndIf
Else
If $debugsetlog = 1 Then Setlog("Milking no match", $COLOR_DEBUG)
If $MilkAttackAfterTHSnipe = 1 and $chkSnipeIfNoElixir = 1 Then
If $debugsetlog = 1 Then Setlog("Milking no match but Snipe even if no structures detected... check...", $COLOR_DEBUG)
If $searchTH = "-" Then	townHallCheck(True)
If $searchTH <>"-" Then
$milkingAttackOutside = 1
If SearchTownHallLoc() Then
If $debugsetlog = 1 Then Setlog("Milking Attack TH outside match!", $COLOR_DEBUG)
$milkingAttackOutside = 1
Else
If $debugsetlog = 1 Then Setlog("TH it is not outside, skip attack", $COLOR_DEBUG)
EndIf
$milkingAttackOutside = 0
Else
If $debugsetlog = 1 Then Setlog("Cannot detect Townhall, skip THsnipe", $COLOR_DEBUG)
EndIf
EndIf
EndIf
Local $TimeCheckMilkingAttackSeconds = Round(TimerDiff($TimeCheckMilkingAttack) / 1000, 2)
If $TimeCheckMilkingAttackSeconds >= 23 Then
Setlog("Computing Time Milking Attack too HIGH", $color_red)
Setlog("Your computer it is too slow to use this algorithm :(", $color_red)
Setlog("Please change algorithm", $color_red)
Else
Setlog("Computing Time Milking Attack : " & $TimeCheckMilkingAttackSeconds & " seconds", $color_blue)
EndIf
EndIf
EndIf
EndFunc
Func _FindPixelCloser($arrPixel, $pixel, $nb = 1)
If IsArray($arrPixel) = False Then Return
Local $arrPixelCloser[0]
For $j = 0 To $nb
Local $PixelCloser = $arrPixel[0]
For $i = 0 To UBound($arrPixel) - 1
$alreadyExist = False
Local $arrTemp = $arrPixel[$i]
Local $found = False
If ($pixel[0] = -1) Then
If (Abs($arrTemp[1] - $pixel[1]) < Abs($PixelCloser[1] - $pixel[1])) Then
$found = True
EndIf
ElseIf ($pixel[1] = -1) Then
If (Abs($arrTemp[0] - $pixel[0]) < Abs($PixelCloser[0] - $pixel[0])) Then
$found = True
EndIf
Else
If ((Abs($arrTemp[0] - $pixel[0]) + Abs($arrTemp[1] - $pixel[1])) < (Abs($PixelCloser[0] - $pixel[0]) + Abs($PixelCloser[1] - $pixel[1]))) Then
$found = True
EndIf
EndIf
If ($found) Then
For $k = 0 To UBound($arrPixelCloser) - 1
Local $arrTemp2 = $arrPixelCloser[$k]
If ($arrTemp[0] = $arrTemp2[0] And $arrTemp[1] = $arrTemp2[1]) Then
$alreadyExist = True
ExitLoop
EndIf
Next
If ($alreadyExist = False) Then
$PixelCloser = $arrTemp
EndIf
EndIf
Next
ReDim $arrPixelCloser[UBound($arrPixelCloser) + 1]
$arrPixelCloser[UBound($arrPixelCloser) - 1] = $PixelCloser
Next
Return $arrPixelCloser
EndFunc
Func _GetOffsetTroopFurther($pixel, $eVectorType, $offset)
debugRedArea("_GetOffsetTroopFurther IN")
Local $xMin, $xMax, $yMin, $yMax, $xStep, $yStep, $xOffset, $yOffset
Local $vectorRedArea[0]
Local $pixelOffset = GetOffestPixelRedArea2($pixel, $eVectorType, $offset)
If ($eVectorType = $eVectorLeftTop) Then
$xMin = 12
$xMax = 440
$yMin = 349
$yMax = 40
$xStep = 4
$yStep = -3
$yOffset = -1 * $offset
$xOffset = Floor($yOffset)
ElseIf ($eVectorType = $eVectorRightTop) Then
$xMin = 440
$xMax = 850
$yMin = 40
$yMax = 349
$xStep = 4
$yStep = 3
$yOffset = -1 * $offset
$xOffset = Floor($yOffset) * -1
ElseIf ($eVectorType = $eVectorLeftBottom) Then
$xMin = 12
$xMax = 440
$yMin = 349
$yMax = 629
$xStep = 4
$yStep = 3
$yOffset = $offset
$xOffset = Floor($yOffset) * -1
Else
$xMin = 440
$xMax = 850
$yMin = 629
$yMax = 349
$xStep = 4
$yStep = -3
$yOffset = $offset
$xOffset = Floor($yOffset)
EndIf
Local $y = $yMin
Local $found = False
For $x = $xMin To $xMax Step $xStep
If ($eVectorType = $eVectorRightBottom And $y > $yMax And $pixelOffset[0] > $x And $pixelOffset[1] > $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf ($eVectorType = $eVectorLeftBottom And $y < $yMax And $pixelOffset[0] < $x And $pixelOffset[1] > $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf ($eVectorType = $eVectorLeftTop And $y > $yMax And $pixelOffset[0] < $x And $pixelOffset[1] < $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
ElseIf ($eVectorType = $eVectorRightTop And $y < $yMax And $pixelOffset[0] > $x And $pixelOffset[1] < $y) Then
$pixelOffset[0] = $x + $xOffset
$pixelOffset[1] = $y + $yOffset
$found = True
EndIf
$y += $yStep
If ($found) Then ExitLoop
Next
If $pixelOffset[1] > 565 + $bottomOffsetY Then
$pixelOffset[1] = 565 + $bottomOffsetY
EndIf
debugRedArea("$pixelOffset x : [" & $pixelOffset[0] & "] / y : [" & $pixelOffset[1] & "]")
Return $pixelOffset
EndFunc
Global $CurBaseRedLine[2] = ["", ""]
Func _GetRedArea()
$nameFunc = "[_GetRedArea] "
debugRedArea($nameFunc & " IN")
Local $colorVariation = 60
Local $xSkip = 1
Local $ySkip = 5
_CaptureRegion2()
If $iMatchMode = $LB And $iChkDeploySettings[$LB] = 4 Then
Local $result = DllCall($hFuncLib, "str", "getRedAreaSideBuilding", "ptr", $hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation, "int", $eSideBuildingDES)
If $debugSetlog Then Setlog("Debug: Redline with DES Side chosen")
ElseIf $iMatchMode = $LB And $iChkDeploySettings[$LB] = 5 Then
Local $result = DllCall($hFuncLib, "str", "getRedAreaSideBuilding", "ptr", $hHBitmap2, "int", $xSkip, "int", $ySkip, "int", $colorVariation, "int", $eSideBuildingTH)
If $debugSetlog Then Setlog("Debug: Redline with TH Side chosen")
Else
Local $result = GetImgLoc2MBR()
If $debugSetlog Then Setlog("Debug: Redline chosen")
EndIf
Local $listPixelBySide = StringSplit($result, "#")
If $debugRedArea =  1 then
Local $1 = StringSplit($listPixelBySide[1], "|", 2)
Local $2 = StringSplit($listPixelBySide[2], "|", 2)
Local $3 = StringSplit($listPixelBySide[3], "|", 2)
Local $4 = StringSplit($listPixelBySide[4], "|", 2)
_CaptureRegion()
Local $editedImage = $hBitmap
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $subDirectory = @ScriptDir & "\RedLineDebug"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = String($Date & "_" & $Time & "_variation_" & $colorVariation & "_.png")
For $i = 0 To UBound($1) - 1
Local $temp = StringSplit($1[$i], "-", 2)
If UBound($temp) > 1 Then
_GDIPlus_GraphicsDrawRect($hGraphic, $temp[0] - 2, $temp[1] - 2, 4, 4, $hPenRED)
EndIf
Next
For $i = 0 To UBound($2) - 1
Local $temp = StringSplit($2[$i], "-", 2)
If UBound($temp) > 1 Then
_GDIPlus_GraphicsDrawRect($hGraphic, $temp[0] - 2, $temp[1] - 2, 4, 4, $hPenRED)
EndIf
Next
For $i = 0 To UBound($3) - 1
Local $temp = StringSplit($3[$i], "-", 2)
If UBound($temp) > 1 Then
_GDIPlus_GraphicsDrawRect($hGraphic, $temp[0] - 2, $temp[1] - 2, 4, 4, $hPenRED)
EndIf
Next
For $i = 0 To UBound($4) - 1
Local $temp = StringSplit($4[$i], "-", 2)
If UBound($temp) > 1 Then
_GDIPlus_GraphicsDrawRect($hGraphic, $temp[0] - 2, $temp[1] - 2, 4, 4, $hPenRED)
EndIf
Next
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $fileName)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
$PixelTopLeft = GetPixelSide($listPixelBySide, 1)
$PixelBottomLeft = GetPixelSide($listPixelBySide, 2)
$PixelBottomRight = GetPixelSide($listPixelBySide, 3)
$PixelTopRight = GetPixelSide($listPixelBySide, 4)
Local $offsetTroops = 12
ReDim $PixelRedArea[UBound($PixelTopLeft) + UBound($PixelBottomLeft) + UBound($PixelTopRight) + UBound($PixelBottomRight)]
ReDim $PixelRedAreaFurther[UBound($PixelTopLeft) + UBound($PixelBottomLeft) + UBound($PixelTopRight) + UBound($PixelBottomRight)]
If ($iMatchMode = $DB And $iAtkAlgorithm[$DB] = 2) Or ($iMatchMode = $DB And $ichkUseAttackDBCSV = 1) Or ($iMatchMode = $LB And $ichkUseAttackABCSV = 1) Then
If $debugsetlog = 1 Then setlog("redarea no calc pixel further (quick)", $COLOR_DEBUG)
$count = 0
ReDim $PixelTopLeftFurther[UBound($PixelTopLeft)]
For $i = 0 To UBound($PixelTopLeft) - 1
$PixelTopLeftFurther[$i] = $PixelTopLeft[$i]
$PixelRedArea[$count] = $PixelTopLeft[$i]
$PixelRedAreaFurther[$count] = $PixelTopLeftFurther[$i]
$count += 1
Next
ReDim $PixelBottomLeftFurther[UBound($PixelBottomLeft)]
For $i = 0 To UBound($PixelBottomLeft) - 1
$PixelBottomLeftFurther[$i] = $PixelBottomLeft[$i]
$PixelRedArea[$count] = $PixelBottomLeft[$i]
$PixelRedAreaFurther[$count] = $PixelBottomLeftFurther[$i]
$count += 1
Next
ReDim $PixelTopRightFurther[UBound($PixelTopRight)]
For $i = 0 To UBound($PixelTopRight) - 1
$PixelTopRightFurther[$i] = $PixelTopRight[$i]
$PixelRedArea[$count] = $PixelTopRight[$i]
$PixelRedAreaFurther[$count] = $PixelTopRightFurther[$i]
$count += 1
Next
ReDim $PixelBottomRightFurther[UBound($PixelBottomRight)]
For $i = 0 To UBound($PixelBottomRight) - 1
$PixelBottomRightFurther[$i] = $PixelBottomRight[$i]
$PixelRedArea[$count] = $PixelBottomRight[$i]
$PixelRedAreaFurther[$count] = $PixelBottomRightFurther[$i]
$count += 1
Next
debugRedArea("PixelTopLeftFurther* " & UBound($PixelTopLeftFurther))
Else
If $debugsetlog = 1 Then setlog("redarea calc pixel further", $COLOR_DEBUG)
$count = 0
ReDim $PixelTopLeftFurther[UBound($PixelTopLeft)]
For $i = 0 To UBound($PixelTopLeft) - 1
$PixelTopLeftFurther[$i] = _GetOffsetTroopFurther($PixelTopLeft[$i], $eVectorLeftTop, $offsetTroops)
$PixelRedArea[$count] = $PixelTopLeft[$i]
$PixelRedAreaFurther[$count] = $PixelTopLeftFurther[$i]
$count += 1
Next
ReDim $PixelBottomLeftFurther[UBound($PixelBottomLeft)]
For $i = 0 To UBound($PixelBottomLeft) - 1
$PixelBottomLeftFurther[$i] = _GetOffsetTroopFurther($PixelBottomLeft[$i], $eVectorLeftBottom, $offsetTroops)
$PixelRedArea[$count] = $PixelBottomLeft[$i]
$PixelRedAreaFurther[$count] = $PixelBottomLeftFurther[$i]
$count += 1
Next
ReDim $PixelTopRightFurther[UBound($PixelTopRight)]
For $i = 0 To UBound($PixelTopRight) - 1
$PixelTopRightFurther[$i] = _GetOffsetTroopFurther($PixelTopRight[$i], $eVectorRightTop, $offsetTroops)
$PixelRedArea[$count] = $PixelTopRight[$i]
$PixelRedAreaFurther[$count] = $PixelTopRightFurther[$i]
$count += 1
Next
ReDim $PixelBottomRightFurther[UBound($PixelBottomRight)]
For $i = 0 To UBound($PixelBottomRight) - 1
$PixelBottomRightFurther[$i] = _GetOffsetTroopFurther($PixelBottomRight[$i], $eVectorRightBottom, $offsetTroops)
$PixelRedArea[$count] = $PixelBottomRight[$i]
$PixelRedAreaFurther[$count] = $PixelBottomRightFurther[$i]
$count += 1
Next
debugRedArea("PixelTopLeftFurther " & UBound($PixelTopLeftFurther))
EndIf
If UBound($PixelTopLeft) < 30 Then
$PixelTopLeft = _GetVectorOutZone($eVectorLeftTop)
$PixelTopLeftFurther = $PixelTopLeft
EndIf
If UBound($PixelBottomLeft) < 30 Then
$PixelBottomLeft = _GetVectorOutZone($eVectorLeftBottom)
$PixelBottomLeftFurther = $PixelBottomLeft
EndIf
If UBound($PixelTopRight) < 30 Then
$PixelTopRight = _GetVectorOutZone($eVectorRightTop)
$PixelTopRightFurther = $PixelTopRight
EndIf
If UBound($PixelBottomRight) < 30 Then
$PixelBottomRight = _GetVectorOutZone($eVectorRightBottom)
$PixelBottomRightFurther = $PixelBottomRight
EndIf
debugRedArea($nameFunc & "  Size of arr pixel for TopLeft [" & UBound($PixelTopLeft) & "] /  BottomLeft [" & UBound($PixelBottomLeft) & "] /  TopRight [" & UBound($PixelTopRight) & "] /  BottomRight [" & UBound($PixelBottomRight) & "] ")
debugRedArea($nameFunc & " OUT ")
EndFunc
Func GetImgLoc2MBR($redlines = "")
Local $res
If $redlines = "" And IsArray($redlines) = False Then
_CaptureRegion2()
Local $SingleCocDiamond = "ECD"
$res = DllCall($pImgLib2, "str", "SearchRedLines", "handle", $hHBitmap2, "str", $SingleCocDiamond)
StoreRedLines($res)
If @error Then _logErrorDLLCall($pImgLib2 & ", SearchRedLines: ", @error)
Else
$res = $redlines
EndIf
Local $rConvert = ConvertToOldRedLines($res)
Local $NewRedLineString = $rConvert[0] & "#" & $rConvert[1] & "#" & $rConvert[2] & "#" & $rConvert[3]
Return $NewRedLineString
EndFunc
Func ConvertToOldRedLines($imgLocResult)
Local $_PixelTopLeft, $_PixelBottomLeft, $_PixelBottomRight, $_PixelTopRight , $AllPoints , $EachPoint[1][2]
Local $res = $imgLocResult
If IsArray($res) Then
If $res[0] = "0" Or $res[0] = "" Then
SetLog("Imgloc|SearchRedLines not found!", $COLOR_RED)
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0] & ", SearchRedLines", $COLOR_RED)
Else
$AllPoints = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $EachPoint[UBound($AllPoints)][2]
For $i = 0 To UBound($AllPoints) - 1
Local $temp = StringSplit($AllPoints[$i], ",", $STR_NOCOUNT)
$EachPoint[$i][0] = Number($temp[0])
$EachPoint[$i][1] = Number($temp[1])
Next
_ArraySort($EachPoint, 0, 0, 0, 0)
For $i = 0 To UBound($EachPoint) - 1
If $EachPoint[$i][0] > 20 And $EachPoint[$i][0] < 440 And $EachPoint[$i][1] > 20 And $EachPoint[$i][1] < 349 Then
$_PixelTopLeft &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
ElseIf $EachPoint[$i][0] > 20 And $EachPoint[$i][0] < 440 And $EachPoint[$i][1] > 349 And $EachPoint[$i][1] < 630 Then
$_PixelBottomLeft &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
ElseIf $EachPoint[$i][0] > 440 And $EachPoint[$i][0] < 850 And $EachPoint[$i][1] > 349 And $EachPoint[$i][1] < 630 Then
$_PixelBottomRight &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
ElseIf $EachPoint[$i][0] > 440 And $EachPoint[$i][0] < 850 And $EachPoint[$i][1] > 20 And $EachPoint[$i][1] < 349 Then
$_PixelTopRight &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
EndIf
Next
If Not StringIsSpace($_PixelTopLeft) Then $_PixelTopLeft = StringTrimLeft($_PixelTopLeft, 1)
If Not StringIsSpace($_PixelBottomLeft) Then $_PixelBottomLeft = StringTrimLeft($_PixelBottomLeft, 1)
If Not StringIsSpace($_PixelBottomRight) Then $_PixelBottomRight = StringTrimLeft($_PixelBottomRight, 1)
If Not StringIsSpace($_PixelTopRight) Then $_PixelTopRight = StringTrimLeft($_PixelTopRight, 1)
EndIf
EndIf
Local $__PixelTopLeft = ReturnString($_PixelTopLeft)
Local $__PixelBottomLeft = ReturnString($_PixelBottomLeft)
Local $__PixelBottomRight = ReturnString($_PixelBottomRight)
Local $__PixelTopRight = ReturnString($_PixelTopRight)
If Not StringIsSpace($__PixelTopLeft) Then $__PixelTopLeft = StringTrimLeft($__PixelTopLeft, 1)
If Not StringIsSpace($__PixelBottomLeft) Then $__PixelBottomLeft = StringTrimLeft($__PixelBottomLeft, 1)
If Not StringIsSpace($__PixelBottomRight) Then $__PixelBottomRight = StringTrimLeft($__PixelBottomRight, 1)
If Not StringIsSpace($__PixelTopRight) Then $__PixelTopRight = StringTrimLeft($__PixelTopRight, 1)
Local $ToReturn[4] = [$__PixelTopLeft, $__PixelBottomLeft, $__PixelBottomRight, $__PixelTopRight]
Return $ToReturn
EndFunc
Func StoreRedLines($redLines)
If StringLen($CurBaseRedLine[0]) > 30 Then Return $CurBaseRedLine
Local $result = $redLines
If IsArray($result) Then
$CurBaseRedLine[0] = $result[0]
EndIf
Return $CurBaseRedLine
EndFunc
Func IsRedLineAvailable()
If StringLen($CurBaseRedLine[0]) > 30 Then Return True
Return False
EndFunc
Func ResetRedLines()
_ArrayClear($CurBaseRedLine)
Return True
EndFunc
Func _ArrayClear(ByRef $aArray)
Local $iCols = UBound($aArray, 2)
Local $iDim = UBound($aArray, 0)
Local $iRows = UBound($aArray, 1)
If $iDim = 1 Then
Local $aArray1D[$iRows]
$aArray = $aArray1D
Else
Local $aArray2D[$iRows][$iCols]
$aArray = $aArray2D
EndIf
EndFunc
Func ReturnString($string = "")
Local $OldPixel = StringSplit($string, "|", $STR_NOCOUNT)
Local $EachPointOld[1][2]
Local $__Pixel = ""
Local $z = 0
For $i = 0 To UBound($OldPixel) - 1
Local $temp = StringSplit($OldPixel[$i], "-", $STR_NOCOUNT)
If UBound($temp) > 1 Then
Local $aResult = _ArraySearch($EachPointOld, $temp[0], 0, 0, 0, 0, 1, 0, False)
If not @error And $temp[1] = $EachPointOld[$aResult][1] Then
ContinueLoop
Else
$EachPointOld[$z][0] = Number($temp[0])
$EachPointOld[$z][1] = Number($temp[1])
$z += 1
ReDim $EachPointOld[$z + 1][2]
EndIf
EndIf
Next
_ArraySort($EachPointOld, 0, 0, 0, 0)
For $i = 0 To UBound($EachPointOld) - 1
If $EachPointOld[$i][0] > 1 And $EachPointOld[$i][1] > 1 Then
$__Pixel &= String("|" & $EachPointOld[$i][0] & "-" & $EachPointOld[$i][1])
EndIf
Next
Return $__Pixel
EndFunc
Func _GetVectorOutZone($eVectorType)
debugRedArea("_GetVectorOutZone IN")
Local $vectorOutZone[0]
If ($eVectorType = $eVectorLeftTop) Then
$xMin = 2
$yMin = 349
$xMax = 440
$yMax = 30
$xStep = 4
$yStep = -3
ElseIf ($eVectorType = $eVectorRightTop) Then
$xMin = 440
$yMin = 30
$xMax = 857
$yMax = 349
$xStep = 4
$yStep = 3
ElseIf ($eVectorType = $eVectorLeftBottom) Then
$xMin = 2
$yMin = 349
$xMax = 440
$yMax = 625
$xStep = 4
$yStep = 3
Else
$xMin = 440
$yMin = 625
$xMax = 857
$yMax = 349
$xStep = 4
$yStep = -3
EndIf
Local $pixel[2]
Local $x = $xMin
For $y = $yMin To $yMax Step $yStep
$x += $xStep
$pixel[0] = Floor($x)
$pixel[1] = Ceiling($y)
ReDim $vectorOutZone[UBound($vectorOutZone) + 1]
$vectorOutZone[UBound($vectorOutZone) - 1] = $pixel
Next
Return $vectorOutZone
EndFunc
Func debugRedArea($string)
If $debugRedArea = 1 Then
Local $hFile = FileOpen($dirLogs & "debugRedArea.log", $FO_APPEND)
_FileWriteLog($hFile, $string)
FileClose($hFile)
EndIf
EndFunc
Func DropOnPixel($troop, $listArrPixel, $number, $slotsPerEdge = 0)
If isProblemAffect(True) Then Return
If Not IsAttackPage() Then Return
$nameFunc = "[DropOnPixel]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / size arrPixel [" & UBound($listArrPixel) & "] / number [" & $number & "]/ $slotsPerEdge [" & $slotsPerEdge & "] ")
If ($number = 0 Or UBound($listArrPixel) = 0) Then Return
KeepClicks()
If $number = 1 Or $slotsPerEdge = 1 Then
For $i = 0 To UBound($listArrPixel) - 1
debugRedArea("$listArrPixel $i : [" & $i & "] ")
Local $arrPixel = $listArrPixel[$i]
debugRedArea("$arrPixel $UBound($arrPixel) : [" & UBound($arrPixel) & "] ")
If UBound($arrPixel) > 0 Then
Local $pixel = $arrPixel[0]
If $i = Int(UBound($arrPixel) / 2) And $isHeroesDropped = False Then
$DeployHeroesPosition[0] = $pixel[0]
$DeployHeroesPosition[1] = $pixel[1]
debugRedArea("Heroes : $slotsPerEdge = 1 ")
EndIf
If $i = Int(UBound($arrPixel) / 2) And $isCCDropped = False Then
$DeployCCPosition[0] = $pixel[0]
$DeployCCPosition[1] = $pixel[1]
debugRedArea("CC : $slotsPerEdge = 1 ")
EndIf
AttackClick($pixel[0], $pixel[1], $number, $iDelayDropOnPixel2, $iDelayDropOnPixel1, "#0096")
EndIf
Next
ElseIf $slotsPerEdge = 2 Then
For $i = 0 To UBound($listArrPixel) - 1
Local $arrPixel = $listArrPixel[$i]
If UBound($arrPixel) > 0 Then
Local $pixel = $arrPixel[0]
If $i = Int(UBound($arrPixel) / 2) And $isHeroesDropped = False Then
$DeployHeroesPosition[0] = $pixel[0]
$DeployHeroesPosition[1] = $pixel[1]
debugRedArea("Heroes : $slotsPerEdge = 2 ")
EndIf
If $i = Int(UBound($arrPixel) / 2) And $isCCDropped = False Then
$DeployCCPosition[0] = $pixel[0]
$DeployCCPosition[1] = $pixel[1]
debugRedArea("CC : $slotsPerEdge = 2 ")
EndIf
AttackClick($pixel[0], $pixel[1], $number, SetSleep(0), SetSleep(1), "#0097")
EndIf
Next
Else
For $i = 0 To UBound($listArrPixel) - 1
debugRedArea("$listArrPixel $i : [" & $i & "] ")
Local $nbTroopsLeft = $number
Local $offset = 1
Local $nbTroopByPixel = 1
Local $arrPixel = $listArrPixel[$i]
debugRedArea("UBound($arrPixel) " & UBound($arrPixel) & "$number :" & $number)
While ($nbTroopsLeft > 0)
If (UBound($arrPixel) = 0) Then
ExitLoop
EndIf
If (UBound($arrPixel) > $nbTroopsLeft) Then
$offset = UBound($arrPixel) / $nbTroopsLeft
Else
$nbTroopByPixel = Floor($number / UBound($arrPixel))
EndIf
If ($offset < 1) Then
$offset = 1
EndIf
If ($nbTroopByPixel < 1) Then
$nbTroopByPixel = 1
EndIf
For $j = 0 To UBound($arrPixel) - 1 Step $offset
Local $index = Round($j)
If ($index > UBound($arrPixel) - 1) Then
$index = UBound($arrPixel) - 1
EndIf
Local $currentPixel = $arrPixel[Floor($index)]
If $j >= Round(UBound($arrPixel) / 2) And $j <= Round((UBound($arrPixel) / 2) + $offset) And $isHeroesDropped = False Then
$DeployHeroesPosition[0] = $currentPixel[0]
$DeployHeroesPosition[1] = $currentPixel[1]
debugRedArea("Heroes : $slotsPerEdge = else ")
debugRedArea("$offset: " & $offset)
EndIf
If $j >= Round(UBound($arrPixel) / 2) And $j <= Round((UBound($arrPixel) / 2) + $offset) And $isCCDropped = False Then
$DeployCCPosition[0] = $currentPixel[0]
$DeployCCPosition[1] = $currentPixel[1]
debugRedArea("CC : $slotsPerEdge = else ")
debugRedArea("$offset: " & $offset)
EndIf
AttackClick($currentPixel[0], $currentPixel[1], $nbTroopByPixel, SetSleep(0), 0, "#0098")
$nbTroopsLeft -= $nbTroopByPixel
Next
WEnd
Next
EndIf
ReleaseClicks()
debugRedArea($nameFunc & " OUT ")
EndFunc
Func DropTroop($troop, $nbSides, $number, $slotsPerEdge = 0, $indexToAttack = -1)
If isProblemAffect(True) Then Return
$nameFunc = "[DropTroop]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / nbSides : [" & $nbSides & "] / number : [" & $number & "] / slotsPerEdge [" & $slotsPerEdge & "]")
If ($iChkRedArea[$iMatchMode]) Then
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If _Sleep($iDelayDropTroop1) Then Return
SelectDropTroop($troop)
If _Sleep($iDelayDropTroop2) Then Return
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
If ($iChkSmartAttack[$iMatchMode][0] = 0 And $iChkSmartAttack[$iMatchMode][1] = 0 And $iChkSmartAttack[$iMatchMode][2] = 0) Then
If $nbSides = 4 Then
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $number, $slotsPerEdge)
For $i = 0 To $nbSides - 3
Local $nbTroopsPerEdge = Round($nbTroopsLeft / ($nbSides - $i * 2))
If ($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $listEdgesPixelToDrop[2] = [$edgesPixelToDrop[$i], $edgesPixelToDrop[$i + 2]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
Next
Return
EndIf
For $i = 0 To $nbSides - 1
If $nbSides = 1 Or ($nbSides = 3 And $i = 2) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft / ($nbSides - $i))
If ($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
Local $listEdgesPixelToDrop[1] = [$edgesPixelToDrop[$i]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge
ElseIf ($nbSides = 2 And $i = 0) Or ($nbSides = 3 And $i <> 1) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft / ($nbSides - $i * 2))
If ($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
Local $listEdgesPixelToDrop[2] = [$edgesPixelToDrop[$i + 3], $edgesPixelToDrop[$i + 1]]
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
EndIf
Next
Else
Local $listEdgesPixelToDrop[0]
If ($indexToAttack <> -1) Then
Local $nbTroopsPerEdge = $number
Local $maxElementNearCollector = $indexToAttack
Local $startIndex = $indexToAttack
Else
Local $nbTroopsPerEdge = Round($number / UBound($PixelNearCollector))
Local $maxElementNearCollector = UBound($PixelNearCollector) - 1
Local $startIndex = 0
EndIf
If ($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
For $i = $startIndex To $maxElementNearCollector
$pixel = $PixelNearCollector[$i]
ReDim $listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) + 1]
$listEdgesPixelToDrop[UBound($listEdgesPixelToDrop) - 1] = _FindPixelCloser($PixelRedAreaFurther, $pixel, 5)
Next
DropOnPixel($troop, $listEdgesPixelToDrop, $nbTroopsPerEdge, $slotsPerEdge)
EndIf
Else
DropOnEdges($troop, $nbSides, $number, $slotsPerEdge)
EndIf
debugRedArea($nameFunc & " OUT ")
EndFunc
Func DropTroop2($troop, $nbSides, $number, $slotsPerEdge = 0, $name = "")
$nameFunc = "[DropTroop2]"
debugRedArea($nameFunc & " IN ")
debugRedArea("troop : [" & $troop & "] / nbSides : [" & $nbSides & "] / number : [" & $number & "] / slotsPerEdge [" & $slotsPerEdge & "]")
Local $listInfoPixelDropTroop[0]
If ($iChkRedArea[$iMatchMode]) Then
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
Local $nbTroopsPerEdge = Round($nbTroopsLeft / $nbSides)
If (($iChkSmartAttack[$iMatchMode][0] = 0 And $iChkSmartAttack[$iMatchMode][1] = 0 And $iChkSmartAttack[$iMatchMode][2] = 0) Or UBound($PixelNearCollector) = 0) Then
If ($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
If $nbSides = 4 Then
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 4]
Local $listInfoPixelDropTroop = GetPixelDropTroop($troop, $number, $slotsPerEdge)
Else
For $i = 0 To $nbSides - 1
If $nbSides = 1 Or ($nbSides = 3 And $i = 2) Then
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 1]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = $edgesPixelToDrop[$i]
ElseIf ($nbSides = 2 And $i = 0) Or ($nbSides = 3 And $i <> 1) Then
Local $edgesPixelToDrop = GetPixelDropTroop($troop, $nbTroopsPerEdge, $slotsPerEdge)
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 2]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 2] = $edgesPixelToDrop[$i + 3]
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = $edgesPixelToDrop[$i + 1]
EndIf
Next
EndIf
Else
Local $listEdgesPixelToDrop[0]
Local $nbTroopsPerEdge = Round($number / UBound($PixelNearCollector))
If ($number > 0 And $nbTroopsPerEdge = 0) Then $nbTroopsPerEdge = 1
Local $maxElementNearCollector = UBound($PixelNearCollector) - 1
Local $startIndex = 0
Local $troopFurther = False
$troopFurther = True
Local $centerPixel[2] = [430, 338]
For $i = $startIndex To $maxElementNearCollector
$pixel = $PixelNearCollector[$i]
ReDim $listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) + 1]
Local $arrPixelToSearch
If ($pixel[0] < $centerPixel[0] And $pixel[1] < $centerPixel[1]) Then
If ($troopFurther) Then
$arrPixelToSearch = $PixelTopLeftFurther
Else
$arrPixelToSearch = $PixelTopLeft
EndIf
ElseIf ($pixel[0] < $centerPixel[0] And $pixel[1] > $centerPixel[1]) Then
If ($troopFurther) Then
$arrPixelToSearch = $PixelBottomLeftFurther
Else
$arrPixelToSearch = $PixelBottomLeft
EndIf
ElseIf ($pixel[0] > $centerPixel[0] And $pixel[1] > $centerPixel[1]) Then
If ($troopFurther) Then
$arrPixelToSearch = $PixelBottomRightFurther
Else
$arrPixelToSearch = $PixelBottomRight
EndIf
Else
If ($troopFurther) Then
$arrPixelToSearch = $PixelTopRightFurther
Else
$arrPixelToSearch = $PixelTopRight
EndIf
EndIf
$listInfoPixelDropTroop[UBound($listInfoPixelDropTroop) - 1] = _FindPixelCloser($arrPixelToSearch, $pixel, 1)
Next
EndIf
Else
DropOnEdges($troop, $nbSides, $number, $slotsPerEdge)
EndIf
Local $infoDropTroop[6] = [$troop, $listInfoPixelDropTroop, $nbTroopsPerEdge, $slotsPerEdge, $number, $name]
debugRedArea($nameFunc & " OUT ")
Return $infoDropTroop
EndFunc
Func GetLocationMine()
If $iDetectedImageType = 0 Then
Local $result = DllCall($hFuncLib, "str", "getLocationMineExtractor", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# GetLocationMine: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"Mine")
Else
Local $result = DllCall($hFuncLib, "str", "getLocationSnowMineExtractor", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# GetLocationSnowMine: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"SnowMine")
EndIf
Return GetListPixel($result[0])
EndFunc
Func GetLocationElixir()
If $iDetectedImageType = 0 Then
Local $result = DllCall($hFuncLib, "str", "getLocationElixirExtractor", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# GetLocationElixir: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"Elixir")
Else
Local $result = DllCall($hFuncLib, "str", "getLocationSnowElixirExtractor", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# GetLocationSnowElixir: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"SnowElixir")
EndIf
Return GetListPixel($result[0])
EndFunc
Func GetLocationDarkElixir()
Local $result = DllCall($hFuncLib, "str", "getLocationDarkElixirExtractor", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then
Setlog("#*# GetLocationDarkElixir: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"DarkElixir")
EndIf
Return GetListPixel($result[0])
EndFunc
Func GetLocationTownHall()
Local $result = DllCall($hFuncLib, "str", "getLocationTownHall", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# GetLocationTownHall: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"TownHall")
Return GetListPixel($result[0])
EndFunc
Func GetLocationDarkElixirStorageWithLevel()
Local $result = DllCall($hFuncLib, "str", "getLocationDarkElixirStorageWithLevel", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# GetLocationDarkElixirStorageWithLevel: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"DarkElixirStorageWithLevel")
Return $result[0]
EndFunc
Func GetLocationDarkElixirStorage()
Local $result = DllCall($hFuncLib, "str", "getLocationDarkElixirStorage", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# GetLocationDarkElixirStorage: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"DarkElixirStorage")
Return GetListPixel($result[0])
EndFunc
Func GetLocationElixirWithLevel()
If $iDetectedImageType = 0 Then
Local $result = DllCall($hFuncLib, "str", "getLocationElixirExtractorWithLevel", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# getLocationElixirExtractorWithLevel: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"ElixirExtractorWithLevel")
Else
Local $result = DllCall($hFuncLib, "str", "getLocationSnowElixirExtractorWithLevel", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# getLocationSnowElixirExtractorWithLevel: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"SnowElixirExtractorWithLevel")
EndIf
Return $result[0]
EndFunc
Func GetLocationMineWithLevel()
If $iDetectedImageType = 0 Then
Local $result = DllCall($hFuncLib, "str", "getLocationMineExtractorWithLevel", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# getLocationMineExtractorWithLevel: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"MineExtractorWithLevel")
Else
Local $result = DllCall($hFuncLib, "str", "getLocationSnowMineExtractorWithLevel", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# getLocationSnowMineExtractorWithLevel: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"SnowMineExtractorWithLevel")
EndIf
Return $result[0]
EndFunc
Func GetLocationDarkElixirWithLevel()
Local $result = DllCall($hFuncLib, "str", "getLocationDarkElixirExtractorWithLevel", "ptr", $hHBitmap2)
If $debugBuildingPos = 1 Then Setlog("#*# getLocationDarkElixirExtractorWithLevel: " & $result[0], $COLOR_TEAL)
if $debugGetLocation = 1 Then DebugImageGetLocation($result[0],"DarkElixirExtractorWithLevel")
Return $result[0]
EndFunc
Func GetLocationGoldStorage()
Local $hTimer = TimerInit()
Local $directory = @ScriptDir & "\images\Storages\Gold"
Local $TempVectStr
Local $TotalStorages = 0
Local $TotalObjects = 0
Local $GoldStorageXY
Local $maxReturnPoints = 4
Local $redLines = ""
Local $minLevel = 0
Local $maxLevel = 12
Local $statFile = ""
If $DebugSetLog = 1 Then SetLog("Started the function | GetLocationGoldStorage", $COLOR_DEBUG)
Local $aResult = returnMultipleMatches($directory, $maxReturnPoints , $redLines, $statFile, $minLevel, $maxLevel)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
$Filename = $aResult[$i][1]
$TotalObjects = $aResult[$i][4]
$GoldStorageXY = $aResult[$i][5]
If IsArray($GoldStorageXY) and $TotalObjects > 0 Then
For $t = 0 To UBound($GoldStorageXY) - 1
If $DebugSetLog = 1 Then SetLog($Filename & " found (" & $GoldStorageXY[$t][0] & "," & $GoldStorageXY[$t][1] & ")", $COLOR_DEBUG)
$TempVectStr &= $GoldStorageXY[$t][0] & "-" & $GoldStorageXY[$t][1] & "|"
$TotalStorages += 1
If $TotalStorages >= 4 Then ExitLoop (2)
Next
EndIf
Next
EndIf
If $DebugSetLog = 1 Then SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG)
If StringLen($TempVectStr) > 0 Then
$TempVectStr = StringLeft($TempVectStr, StringLen($TempVectStr) - 1)
if $debugGetLocation = 1 Then DebugImageGetLocation($TempVectStr,"GoldStorage")
Local $InputVect = GetListPixel($TempVectStr)
SetLog("Total Gold Storages :" & $TotalStorages)
Return $InputVect
Else
Return 0
EndIf
EndFunc
Func GetLocationElixirStorage()
Local $hTimer = TimerInit()
Local $directory = @ScriptDir & "\images\Storages\Elixir"
Local $TempVectStr
Local $TotalStorages = 0
Local $TotalObjects = 0
Local $ElixirStorageXY
Local $maxReturnPoints = 4
Local $redLines = ""
Local $minLevel = 0
Local $maxLevel = 12
Local $statFile = ""
If $DebugSetLog = 1 Then SetLog("Started the function | GetLocationElixirStorage", $COLOR_DEBUG)
Local $aResult = returnMultipleMatches($directory, $maxReturnPoints , $redLines, $statFile, $minLevel, $maxLevel)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
$Filename = $aResult[$i][1]
$TotalObjects = $aResult[$i][4]
$ElixirStorageXY = $aResult[$i][5]
If IsArray($ElixirStorageXY) and $TotalObjects > 0 Then
For $t = 0 To UBound($ElixirStorageXY) - 1
If $DebugSetLog = 1 Then SetLog($Filename & " found (" & $ElixirStorageXY[$t][0] & "," & $ElixirStorageXY[$t][1] & ")", $COLOR_DEBUG)
$TempVectStr &= $ElixirStorageXY[$t][0] & "-" & $ElixirStorageXY[$t][1] & "|"
$TotalStorages += 1
If $TotalStorages >= 4 Then ExitLoop (2)
Next
EndIf
Next
EndIf
If $DebugSetLog = 1 Then SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG)
If StringLen($TempVectStr) > 0 Then
$TempVectStr = StringLeft($TempVectStr, StringLen($TempVectStr) - 1)
Local $InputVect = GetListPixel($TempVectStr)
SetLog("Total Elixirr Storages :" & $TotalStorages)
if $debugGetLocation = 1 Then DebugImageGetLocation($TempVectStr,"ElixirStorage")
Return $InputVect
Else
Return 0
EndIf
EndFunc
Func DebugImageGetLocation($vectorstr, $type)
setlog("DebugImage .............................")
setlog("input: " & $vectorstr)
setlog("type: " & $type)
Switch $type
case "DarkElixirStorageWithLevel", "ElixirExtractorWithLevel", "SnowElixirExtractorWithLevel", "MineExtractorWithLevel", "SnowMineExtractorWithLevel", "DarkElixirExtractorWithLevel"
Local $vector = stringSplit($vectorstr,"~",2)
Setlog("-- " & $type)
For $i = 0 To UBound($vector) - 1
Setlog($type & " " & $i & " --> " & $vector[$i])
Local $temp = StringSplit($vector[$i], "#", 2)
If UBound($temp) = 2 Then
$pixel = StringSplit($temp[1], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
if $debugsetlog=1 then Setlog("coordinate inside village (" & $pixel[0] & "," & $pixel[1] & ")" )
_CaptureRegion($pixel[0]  - 30, $pixel[1] - 30, $pixel[0]  + 30, $pixel[1]  + 30)
DebugImageSave("DebugImageGetLocation_" & $type & "_"  ,  False)
Else
if $debugsetlog=1 then Setlog("coordinate out of village (" & $pixel[0] & "," & $pixel[1] & ")" )
EndIf
EndIf
EndIf
Next
case "Mine", "SnowMine", "Elixir", "SnowElixir", "DarkElixir", "TownHall","DarkElixirStorage", "GoldStorage", "ElixirStorage"
Local $vector = stringSplit($vectorstr,"|",2)
Setlog("-- " & $type)
For $i = 0 To UBound($vector) - 1
Local $pixel = StringSplit($vector[$i], "-", 2)
If UBound($pixel) = 2 Then
If isInsideDiamondRedArea($pixel) Then
if $debugsetlog=1 then Setlog("coordinate inside village (" & $pixel[0] & "," & $pixel[1] & ")" )
_CaptureRegion($pixel[0]  - 30, $pixel[1] - 30, $pixel[0]  + 30, $pixel[1]  + 30)
DebugImageSave("DebugImageGetLocation_" & $type & "_"  ,  False)
Else
if $debugsetlog=1 then Setlog("coordinate out of village (" & $pixel[0] & "," & $pixel[1] & ")" )
EndIf
EndIf
Next
case Else
setlog("!!!!!!")
EndSwitch
setlog("-------------------------------------------")
EndFunc
Func GetOffestPixelRedArea2($pixel, $eVectorType, $offset = 3)
Local $pixelOffest = $pixel
If ($eVectorType = $eVectorLeftTop) Then
$pixelOffest[0] = Round($pixel[0] - $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] - $offset
ElseIf ($eVectorType = $eVectorRightBottom) Then
$pixelOffest[0] = Round($pixel[0] + $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] + $offset
ElseIf ($eVectorType = $eVectorLeftBottom) Then
$pixelOffest[0] = Round($pixel[0] - $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] + $offset
ElseIf ($eVectorType = $eVectorRightTop) Then
$pixelOffest[0] = Round($pixel[0] + $offset * 4 / 3)
$pixelOffest[1] = $pixel[1] - $offset
EndIf
If $pixelOffest[1] > 565 Then
$pixelOffest[1] = 565
EndIf
Return $pixelOffest
EndFunc
Func GetPixelDropTroop($troop, $number, $slotsPerEdge)
Local $newPixelTopLeft
Local $newPixelBottomLeft
Local $newPixelTopRight
Local $newPixelBottomRight
if Ubound($PixelTopLeftFurther) >0 then
$newPixelTopLeft = $PixelTopLeftFurther
Else
$newPixelTopLeft = $PixelTopLeft
EndIf
If Ubound($PixelBottomLeftFurther) >0 Then
$newPixelBottomLeft = $PixelBottomLeftFurther
Else
$newPixelBottomLeft = $PixelBottomLeft
EndIf
If Ubound( $PixelTopRightFurther) >0 Then
$newPixelTopRight = $PixelTopRightFurther
Else
$newPixelTopRight = $PixelTopRight
EndIf
If Ubound( $PixelBottomRightFurther) then
$newPixelBottomRight = $PixelBottomRightFurther
Else
$newPixelBottomRight = $PixelBottomRight
EndIf
If ($slotsPerEdge = 1) Then
$newPixelTopLeft = GetVectorPixelAverage($newPixelTopLeft, 0)
$newPixelBottomLeft = GetVectorPixelAverage($newPixelBottomLeft, 1)
$newPixelTopRight = GetVectorPixelAverage($newPixelTopRight, 1)
$newPixelBottomRight = GetVectorPixelAverage($newPixelBottomRight, 0)
ElseIf ($slotsPerEdge = 2) Then
$newPixelTopLeft = GetVectorPixelOnEachSide($newPixelTopLeft, 0)
$newPixelBottomLeft = GetVectorPixelOnEachSide($newPixelBottomLeft, 1)
$newPixelTopRight = GetVectorPixelOnEachSide($newPixelTopRight, 1)
$newPixelBottomRight = GetVectorPixelOnEachSide($newPixelBottomRight, 0)
Else
debugRedArea("GetPixelDropTroop :  $slotsPerEdge [" & $slotsPerEdge & "] ")
$newPixelTopLeft = GetVectorPixelToDeploy($newPixelTopLeft, 0, $slotsPerEdge)
$newPixelBottomLeft = GetVectorPixelToDeploy($newPixelBottomLeft, 1, $slotsPerEdge)
$newPixelTopRight = GetVectorPixelToDeploy($newPixelTopRight, 1, $slotsPerEdge)
$newPixelBottomRight = GetVectorPixelToDeploy($newPixelBottomRight, 0, $slotsPerEdge)
EndIf
Local $edgesPixelToDrop[4] = [$newPixelBottomRight, $newPixelTopLeft, $newPixelBottomLeft, $newPixelTopRight]
Return $edgesPixelToDrop
EndFunc
Func GetPixelSide($listPixel, $index)
Return GetListPixel($listPixel[$index])
EndFunc
Func GetVectorPixelAverage($arrPixel, $vectorDirection)
Local $vectorPixelAverage[1]
debugRedArea("GetVectorPixelAverage IN $vectorDirection [" & $vectorDirection & "]")
If (UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
Local $posAverage = ($max - $min) / 2
debugRedArea("GetVectorPixelAverage IN $min [" & $min & "]")
debugRedArea("GetVectorPixelAverage IN $max [" & $max & "]")
$pixelSearch[$vectorDirection] = $min + $posAverage
debugRedArea("GetVectorPixelAverage $pixelSearch x : [" & $pixelSearch[0] & "] / y [" & $pixelSearch[1] & "] ")
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
Local $arrTemp = $arrPixelCloser[0]
debugRedArea("GetVectorPixelAverage $arrTemp x : [" & $arrTemp[0] & "] / y [" & $arrTemp[1] & "] ")
$vectorPixelAverage[0] = $arrPixelCloser[0]
EndIf
Return $vectorPixelAverage
EndFunc
Func GetVectorPixelOnEachSide($arrPixel, $vectorDirection)
Local $vectorPixelEachSide[2]
If (UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
Local $posSide = ($max - $min) / 4
$pixelSearch[$vectorDirection] = $min + $posSide
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
$vectorPixelEachSide[0] = $arrPixelCloser[0]
$pixelSearch[$vectorDirection] = $min + $posSide * 3
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
$vectorPixelEachSide[1] = $arrPixelCloser[0]
EndIf
Return $vectorPixelEachSide
EndFunc
Func GetVectorPixelToDeploy($arrPixel, $vectorDirection , $sizeVector)
Local $vectorPixel[0]
debugRedArea("GetVectorPixelToDeploy IN")
debugRedArea("size " & UBound($arrPixel))
If (UBound($arrPixel) > 1) Then
Local $pixelSearch[2] = [-1, -1]
Local $minPixel = $arrPixel[0]
Local $maxPixel = $arrPixel[UBound($arrPixel) - 1]
Local $min = $minPixel[$vectorDirection]
Local $max = $maxPixel[$vectorDirection]
Local $offset = ($max - $min) / $sizeVector
debugRedArea("min : [" & $min & "] / max [" & $max & "] / offset [" & $offset & "]")
If ($min <= $max And $offset <= 0) Then
$offset = 1
ElseIf ($min >= $max And $offset >= 0) Then
$offset = -1
EndIf
For $i = $min To $max Step $offset
$pixelSearch[$vectorDirection] = $i
Local $arrPixelCloser = _FindPixelCloser($arrPixel, $pixelSearch, 1)
ReDim $vectorPixel[UBound($vectorPixel) + 1]
$vectorPixel[UBound($vectorPixel) - 1] = $arrPixelCloser[0]
Next
EndIf
Return $vectorPixel
EndFunc
Func CheckHeroesHealth()
If $checkKPower Or $checkQPower or $checkWPower Then
ForceCaptureRegion()
Local $aKingHealthCopy = $aKingHealth
$aKingHealthCopy[0] = GetXPosOfArmySlot($King, 68)
Local $aQueenHealthCopy = $aQueenHealth
$aQueenHealthCopy[0] = GetXPosOfArmySlot($Queen, 68)
Local $aWardenHealthCopy = $aWardenHealth
$aWardenHealthCopy[0] = GetXPosOfArmySlot($Warden, 68)
If _Sleep($iDelayRespond) Then Return
If $debugSetlog = 1 Then
Setlog(" CheckHeroesHealth started ", $COLOR_DEBUG)
Local $KingPixelColor = _GetPixelColor($aKingHealthCopy[0], $aKingHealthCopy[1], $bCapturePixel)
Local $QueenPixelColor = _GetPixelColor($aQueenHealthCopy[0], $aQueenHealthCopy[1], $bCapturePixel)
Local $WardenPixelColor = _GetPixelColor($aWardenHealthCopy[0], $aWardenHealthCopy[1], $bCapturePixel)
EndIf
If $checkKPower Then
If $debugSetlog = 1 Then Setlog(" King _GetPixelColor(" & $aKingHealthCopy[0] & "," & $aKingHealthCopy[1] & "): " & $KingPixelColor, $COLOR_DEBUG)
If _CheckPixel($aKingHealthCopy, $bCapturePixel, "Red") Then
SetLog("King is getting weak, Activating King's power", $COLOR_BLUE)
SelectDropTroop($King)
$checkKPower = False
EndIf
EndIf
If $checkQPower Then
If $debugSetlog = 1 Then Setlog(" Queen _GetPixelColor(" & $aQueenHealthCopy[0] & "," & $aQueenHealthCopy[1] & "): " & $QueenPixelColor, $COLOR_DEBUG)
If _CheckPixel($aQueenHealthCopy, $bCapturePixel, "Red") Then
SetLog("Queen is getting weak, Activating Queen's power", $COLOR_BLUE)
SelectDropTroop($Queen)
$checkQPower = False
EndIf
EndIf
If $checkWPower Then
If $debugSetlog = 1 Then Setlog(" Grand Warden _GetPixelColor(" & $aWardenHealthCopy[0] & "," & $aWardenHealthCopy[1] & "): " & $WardenPixelColor, $COLOR_DEBUG)
If _CheckPixel($aWardenHealthCopy, $bCapturePixel, "Red") Then
SetLog("Grand Warden is getting weak, Activating Warden's power", $COLOR_BLUE)
SelectDropTroop($Warden)
$checkWPower = False
EndIf
EndIf
If _Sleep($iDelayRespond) Then Return
EndIf
EndFunc
Func dropCC($x, $y, $slot)
Local $test1 = false
Local $test2 = false
If $iMatchMode = $MA and $iDropCC[$DB] = 1  then $test1= True
if $iMatchMode <>$MA Then
If ($iMatchMode <> $DB And $iMatchMode <> $LB and $iMatchMode <> $MA) Or $iDropCC[$iMatchMode] = 1 Or $iDropCCCSV[$iMatchMode] = 1  Then $test2 = True
EndIf
If $slot <> -1 and ( $test1 or $test2 )	Then
If $iPlannedDropCCHoursEnable = 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $iPlannedDropCCHours[$hour[0]] = 0 Then
SetLog("Drop CC not Planned, Skipped..", $COLOR_GREEN)
Return
EndIf
EndIf
If $iChkUseCCBalanced = 1 Then
If Number($TroopsReceived) <> 0 Then
If Number(Number($TroopsDonated) / Number($TroopsReceived)) >= (Number($iCmbCCDonated) / Number($iCmbCCReceived)) Then
SetLog(" Â» Deploying Clan Castle, donated (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") >= " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_BLUE)
Click(GetXPosOfArmySlot($slot, 68), 595 + $bottomOffsetY, 1, $iDelaydropCC2, "#0086")
If _Sleep($iDelaydropCC1) Then Return
Click($x, $y, 1, 0, "#0087")
Else
SetLog("No Dropping Clan Castle, donated  (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") < " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_BLUE)
EndIf
Else
If Number(Number($TroopsDonated) / 1) >= (Number($iCmbCCDonated) / Number($iCmbCCReceived)) Then
SetLog(" Â» Deploying Clan Castle, donated (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") >= " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_BLUE)
Click(GetXPosOfArmySlot($slot, 68), 595 + $bottomOffsetY, 1, $iDelaydropCC2, "#0088")
If _Sleep($iDelaydropCC1) Then Return
Click($x, $y, 1, 0, "#0089")
Else
SetLog("No Dropping Clan Castle, donated  (" & $TroopsDonated & ") / received (" & $TroopsReceived & ") < " & $iCmbCCDonated & "/" & $iCmbCCReceived, $COLOR_BLUE)
EndIf
EndIf
Else
SetLog(" Â» Deploying Clan Castle", $COLOR_BLUE)
Click(GetXPosOfArmySlot($slot, 68), 595 + $bottomOffsetY, 1, $iDelaydropCC2, "#0090")
If _Sleep($iDelaydropCC1) Then Return
Click($x, $y, 1, 0, "#0091")
EndIf
EndIf
EndFunc
Func dropHeroes($x, $y, $KingSlot = -1, $QueenSlot = -1, $WardenSlot = -1)
If $debugSetLog = 1 Then SetLog("dropHeroes KingSlot " & $KingSlot & " QueenSlot " & $QueenSlot & " WardenSlot " & $WardenSlot & " matchmode " & $iMatchMode, $COLOR_DEBUG)
If _Sleep($iDelaydropHeroes1) Then Return
$dropKing = False
$dropQueen = False
$dropWarden = False
Local $MatchMode
If $iMatchMode = $TS and $duringMilkingAttack = 1 Then
$MatchMode = $DB
Else
$MatchMode = $iMatchMode
EndIf
If $KingSlot <> -1 And (($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($iHeroAttack[$MatchMode], $HERO_KING) = $HERO_KING) Then $dropKing = True
If $QueenSlot <> -1 And (($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($iHeroAttack[$MatchMode], $HERO_QUEEN) = $HERO_QUEEN) Then $dropQueen = True
If $WardenSlot <> -1 And (($MatchMode <> $DB And $MatchMode <> $LB) Or BitAND($iHeroAttack[$MatchMode], $HERO_WARDEN) = $HERO_WARDEN) Then $dropWarden = True
If $debugSetLog = 1 Then SetLog("drop KING = " & $dropKing, $COLOR_DEBUG)
If $debugSetLog = 1 Then SetLog("drop QUEEN = " & $dropQueen, $COLOR_DEBUG)
If $debugSetLog = 1 Then SetLog("drop WARDEN = " & $dropWarden, $COLOR_DEBUG)
If $dropKing Then
SetLog(" Â» Deploying King", $COLOR_BLUE)
Click(GetXPosOfArmySlot($KingSlot, 68), 595 + $bottomOffsetY, 1, 0, "#0092")
If _Sleep($iDelaydropHeroes2) Then Return
Click($x, $y, 1, 0, "#0093")
$checkKPower = True
EndIf
If _Sleep($iDelaydropHeroes1) Then Return
If $dropQueen Then
SetLog(" Â» Deploying Queen", $COLOR_BLUE)
Click(GetXPosOfArmySlot($QueenSlot, 68), 595 + $bottomOffsetY, 1, 0, "#0094")
If _Sleep($iDelaydropHeroes2) Then Return
Click($x, $y, 1, 0, "#0095")
$checkQPower = True
EndIf
If _Sleep($iDelaydropHeroes1) Then Return
If $dropWarden Then
SetLog(" Â» Deploying Grand Warden", $COLOR_BLUE)
Click(GetXPosOfArmySlot($WardenSlot, 68), 595 + $bottomOffsetY, 1, 0, "#X998")
If _Sleep($iDelaydropHeroes2) Then Return
Click($x, $y, 1, 0, "#x999")
$checkWPower = True
EndIf
EndFunc
Func DropOnEdge($troop, $edge, $number, $slotsPerEdge = 0, $edge2 = -1, $x = -1)
If isProblemAffect(True) Then Return
If $number = 0 Then Return
If _SleepAttack($iDelayDropOnEdge1) Then Return
SelectDropTroop($troop)
If _SleepAttack($iDelayDropOnEdge2) Then Return
If $slotsPerEdge = 0 Or $number < $slotsPerEdge Then $slotsPerEdge = $number
If $number = 1 Or $slotsPerEdge = 1 Then
If $edge2 = -1 Then
AttackClick($edge[2][0], $edge[2][1], $number, $iDelayDropOnEdge1, $iDelayDropOnEdge3, "#0102")
Else
AttackClick($edge[2][0], $edge[2][1], $number, $iDelayDropOnEdge1, 0, "#0102")
AttackClick($edge2[2][0], $edge2[2][1], $number, $iDelayDropOnEdge1, $iDelayDropOnEdge3, "#0103")
EndIf
ElseIf $slotsPerEdge = 2 Then
Local $half = Ceiling($number / 2)
AttackClick($edge[1][0], $edge[1][1], $half, SetSleep(0), 0, "#0104")
If $edge2 <> -1 Then
AttackClick($edge2[1][0], $edge2[1][1], $half, SetSleep(0), 0, "#0105")
EndIf
AttackClick($edge[3][0], $edge[3][1], $number - $half, SetSleep(0), 0, "#0106")
If $edge2 <> -1 Then
AttackClick($edge2[3][0], $edge2[3][1], $number - $half, SetSleep(0), 0, "#0107")
EndIf
Else
Local $minX = $edge[0][0]
Local $maxX = $edge[4][0]
Local $minY = $edge[0][1]
Local $maxY = $edge[4][1]
If $edge2 <> -1 Then
Local $minX2 = $edge2[0][0]
Local $maxX2 = $edge2[4][0]
Local $minY2 = $edge2[0][1]
Local $maxY2 = $edge2[4][1]
EndIf
Local $nbTroopsLeft = $number
For $i = 0 To $slotsPerEdge - 1
Local $nbtroopPerSlot = Round($nbTroopsLeft / ($slotsPerEdge - $i))
Local $posX = Round($minX + (($maxX - $minX) * $i) / ($slotsPerEdge - 1))
Local $posY = Round($minY + (($maxY - $minY) * $i) / ($slotsPerEdge - 1))
AttackClick($posX, $posY, $nbtroopPerSlot, SetSleep(0), 0, "#0108")
If $edge2 <> -1 Then
Local $posX2 = Round($maxX2 - (($maxX2 - $minX2) * $i) / ($slotsPerEdge - 1))
Local $posY2 = Round($maxY2 - (($maxY2 - $minY2) * $i) / ($slotsPerEdge - 1))
AttackClick($posX2, $posY2, $nbtroopPerSlot, SetSleep(0), 0, "#0109")
EndIf
$nbTroopsLeft -= $nbtroopPerSlot
Next
EndIf
EndFunc
Func DropOnEdges($troop, $nbSides, $number, $slotsPerEdge = 0)
If $nbSides = 0 Or $number = 1 Then
OldDropTroop($troop, $Edges[0], $number)
Return
EndIf
If $nbSides < 1 Then Return
Local $nbTroopsLeft = $number
If $nbSides = 4 Then
For $i = 0 To $nbSides - 3
KeepClicks()
Local $nbTroopsPerEdge = Round($nbTroopsLeft / ($nbSides - $i * 2))
DropOnEdge($troop, $Edges[$i], $nbTroopsPerEdge, $slotsPerEdge, $Edges[$i + 2], $i)
$nbTroopsLeft -= $nbTroopsPerEdge * 2
ReleaseClicks()
Next
Return
EndIf
For $i = 0 To $nbSides - 1
KeepClicks()
If $nbSides = 1 Or ($nbSides = 3 And $i = 2) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft / ($nbSides - $i))
If $iMatchMode = $LB And $iChkDeploySettings[$LB] >= 4 Then
DropOnEdge($troop, $Edges[$BuildingEdge], $nbTroopsPerEdge, $slotsPerEdge)
Else
DropOnEdge($troop, $Edges[$i], $nbTroopsPerEdge, $slotsPerEdge)
EndIf
$nbTroopsLeft -= $nbTroopsPerEdge
ElseIf ($nbSides = 2 And $i = 0) Or ($nbSides = 3 And $i <> 1) Then
Local $nbTroopsPerEdge = Round($nbTroopsLeft / ($nbSides - $i * 2))
DropOnEdge($troop, $Edges[$i + 3], $nbTroopsPerEdge, $slotsPerEdge, $Edges[$i + 1])
$nbTroopsLeft -= $nbTroopsPerEdge * 2
EndIf
ReleaseClicks()
Next
EndFunc
Func GetXPosOfArmySlot($slotNumber, $xOffsetFor11Slot)
Local $SlotPixelColor, $SlotPixelColorTemp, $SlotPixelColor1
$xOffsetFor11Slot -= 8
Switch $slotNumber
Case 0 To 4
$SlotComp = 0
Case 5
$SlotComp = 1
Case Else
$SlotComp = 2
EndSwitch
If $slotNumber = $King Or $slotNumber = $Queen Or $slotNumber = $Warden Then $xOffsetFor11Slot += 8
$SlotPixelColor = _ColorCheck(_GetPixelColor(834, 588 + $bottomOffsetY, True), Hex(0x040c0a, 6), 15)
If $debugSetlog = 1 Then
Setlog(" Slot 0  _ColorCheck 0x040c0a at (834," & 588 + $bottomOffsetY & "): " & $SlotPixelColor, $COLOR_DEBUG)
$SlotPixelColorTemp = _GetPixelColor(834, 588 + $bottomOffsetY, $bCapturePixel)
Setlog(" Slot 0  _GetPixelColo(834," & 588 + $bottomOffsetY & "): " & $SlotPixelColorTemp, $COLOR_DEBUG)
EndIf
If $SlotPixelColor = True Then
Return $xOffsetFor11Slot + $SlotComp + ($slotNumber * 72)
Else
Return $xOffsetFor11Slot + $SlotComp + ($slotNumber * 72) - 13
EndIf
EndFunc
Func GetSlotIndexFromXPos($xPos)
For $slot = 0 To 11
If $xPos < 68 + ($slot * 72) Then
Return $slot
EndIf
Next
EndFunc
Func LauchTroop($troopKind, $nbSides, $waveNb, $maxWaveNb, $slotsPerEdge = 0)
Local $troop = -1
Local $troopNb = 0
Local $name = ""
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $troopKind Then
$troop = $i
$troopNb = Ceiling($atkTroops[$i][1] / $maxWaveNb)
Local $plural = 0
If $troopNb > 1 Then $plural = 1
$name = NameOfTroop($troopKind, $plural)
EndIf
Next
If ($troop = -1) Or ($troopNb = 0) Then
Return False
EndIf
Local $waveName = "first"
If $waveNb = 2 Then $waveName = "second"
If $waveNb = 3 Then $waveName = "third"
If $maxWaveNb = 1 Then $waveName = "only"
If $waveNb = 0 Then $waveName = "last"
SetLog("Dropping " & $waveName & " wave of " & $troopNb & " " & $name, $COLOR_GREEN)
DropTroop($troop, $nbSides, $troopNb, $slotsPerEdge)
Return True
EndFunc
Func LaunchTroop2($listInfoDeploy, $CC, $King, $Queen, $Warden)
If $debugSetlog = 1 Then SetLog("LaunchTroop2 with CC " & $CC & ", K " & $King & ", Q " & $Queen & ", W " & $Warden, $COLOR_DEBUG)
Local $listListInfoDeployTroopPixel[0]
Local $pixelRandomDrop[2]
Local $pixelRandomDropcc[2]
If ($iChkRedArea[$iMatchMode] = 1) Then
For $i = 0 To UBound($listInfoDeploy) - 1
Local $troop = -1
Local $troopNb = 0
Local $name = ""
$troopKind = $listInfoDeploy[$i][0]
$nbSides = $listInfoDeploy[$i][1]
$waveNb = $listInfoDeploy[$i][2]
$maxWaveNb = $listInfoDeploy[$i][3]
$slotsPerEdge = $listInfoDeploy[$i][4]
If $debugSetlog = 1 Then SetLog("**ListInfoDeploy row " & $i & ": USE " & $troopKind & " SIDES " & $nbSides & " WAVE " & $waveNb & " XWAVE " & $maxWaveNb & " SLOTXEDGE " & $slotsPerEdge, $COLOR_DEBUG)
If (IsNumber($troopKind)) Then
For $j = 0 To UBound($atkTroops) - 1
If $atkTroops[$j][0] = $troopKind Then
$troop = $j
$troopNb = Ceiling($atkTroops[$j][1] / $maxWaveNb)
Local $plural = 0
If $troopNb > 1 Then $plural = 1
$name = NameOfTroop($troopKind, $plural)
EndIf
Next
EndIf
If ($troop <> -1 And $troopNb > 0) Or IsString($troopKind) Then
Local $listInfoDeployTroopPixel
If (UBound($listListInfoDeployTroopPixel) < $waveNb) Then
ReDim $listListInfoDeployTroopPixel[$waveNb]
Local $newListInfoDeployTroopPixel[0]
$listListInfoDeployTroopPixel[$waveNb - 1] = $newListInfoDeployTroopPixel
EndIf
$listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$waveNb - 1]
ReDim $listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) + 1]
If (IsString($troopKind)) Then
Local $arrCCorHeroes[1] = [$troopKind]
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $arrCCorHeroes
Else
Local $infoDropTroop = DropTroop2($troop, $nbSides, $troopNb, $slotsPerEdge, $name)
$listInfoDeployTroopPixel[UBound($listInfoDeployTroopPixel) - 1] = $infoDropTroop
EndIf
$listListInfoDeployTroopPixel[$waveNb - 1] = $listInfoDeployTroopPixel
EndIf
Next
If (($iChkSmartAttack[$iMatchMode][0] = 1 Or $iChkSmartAttack[$iMatchMode][1] = 1 Or $iChkSmartAttack[$iMatchMode][2] = 1) And UBound($PixelNearCollector) = 0) Then
SetLog("Error, no pixel found near collector => Normal attack near red line")
EndIf
If ($iCmbSmartDeploy[$iMatchMode] = 0) Then
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
Local $infoPixelDropTroop = $listInfoDeployTroopPixel[$i]
If (IsString($infoPixelDropTroop[0]) And ($infoPixelDropTroop[0] = "CC" Or $infoPixelDropTroop[0] = "HEROES")) Then
If $DeployHeroesPosition[0] <> -1 Then
$pixelRandomDrop[0] = $DeployHeroesPosition[0]
$pixelRandomDrop[1] = $DeployHeroesPosition[1]
If $debugSetlog = 1 Then SetLog("Deploy Heroes $DeployHeroesPosition", $COLOR_DEBUG)
Else
$pixelRandomDrop[0] = $BottomRight[2][0]
$pixelRandomDrop[1] = $BottomRight[2][1]
If $debugSetlog = 1 Then SetLog("Deploy Heroes $BottomRight", $COLOR_DEBUG)
EndIf
If $DeployCCPosition[0] <> -1 Then
$pixelRandomDropcc[0] = $DeployCCPosition[0]
$pixelRandomDropcc[1] = $DeployCCPosition[1]
If $debugSetlog = 1 Then SetLog("Deploy CC $DeployHeroesPosition", $COLOR_DEBUG)
Else
$pixelRandomDropcc[0] = $BottomRight[2][0]
$pixelRandomDropcc[1] = $BottomRight[2][1]
If $debugSetlog = 1 Then SetLog("Deploy CC $BottomRight", $COLOR_DEBUG)
EndIf
If ($infoPixelDropTroop[0] = "CC") Then
dropCC($pixelRandomDropcc[0], $pixelRandomDropcc[1], $CC)
$isCCDropped = True
ElseIf ($infoPixelDropTroop[0] = "HEROES") Then
dropHeroes($pixelRandomDrop[0], $pixelRandomDrop[1], $King, $Queen, $Warden)
$isHeroesDropped = True
EndIf
Else
If _Sleep($iDelayLaunchTroop21) Then Return
SelectDropTroop($infoPixelDropTroop[0])
If _Sleep($iDelayLaunchTroop21) Then Return
Local $waveName = "first"
If $numWave + 1 = 2 Then $waveName = "second"
If $numWave + 1 = 3 Then $waveName = "third"
If $numWave + 1 = 0 Then $waveName = "last"
SetLog("Dropping " & $waveName & " wave of " & $infoPixelDropTroop[5] & " " & $infoPixelDropTroop[4], $COLOR_GREEN)
DropOnPixel($infoPixelDropTroop[0], $infoPixelDropTroop[1], $infoPixelDropTroop[2], $infoPixelDropTroop[3])
EndIf
If ($isHeroesDropped) Then
If _Sleep($iDelayLaunchTroop22) Then Return
CheckHeroesHealth()
EndIf
If _Sleep(SetSleep(1)) Then Return
Next
Next
Else
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
If (UBound($listInfoDeployTroopPixel) > 0) Then
Local $infoTroopListArrPixel = $listInfoDeployTroopPixel[0]
Local $numberSidesDropTroop = 1
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$i]
If (UBound($infoTroopListArrPixel) > 1) Then
Local $infoListArrPixel = $infoTroopListArrPixel[1]
$numberSidesDropTroop = UBound($infoListArrPixel)
ExitLoop
EndIf
Next
If ($numberSidesDropTroop > 0) Then
For $i = 0 To $numberSidesDropTroop - 1
For $j = 0 To UBound($listInfoDeployTroopPixel) - 1
$infoTroopListArrPixel = $listInfoDeployTroopPixel[$j]
If (IsString($infoTroopListArrPixel[0]) And ($infoTroopListArrPixel[0] = "CC" Or $infoTroopListArrPixel[0] = "HEROES")) Then
If $DeployHeroesPosition[0] <> -1 Then
$pixelRandomDrop[0] = $DeployHeroesPosition[0]
$pixelRandomDrop[1] = $DeployHeroesPosition[1]
If $debugSetlog = 1 Then SetLog("Deploy Heroes $DeployHeroesPosition", $COLOR_DEBUG)
Else
$pixelRandomDrop[0] = $BottomRight[2][0]
$pixelRandomDrop[1] = $BottomRight[2][1]
If $debugSetlog = 1 Then SetLog("Deploy Heroes $BottomRight", $COLOR_DEBUG)
EndIf
If $DeployCCPosition[0] <> -1 Then
$pixelRandomDropcc[0] = $DeployCCPosition[0]
$pixelRandomDropcc[1] = $DeployCCPosition[1]
If $debugSetlog = 1 Then SetLog("Deploy CC $DeployHeroesPosition", $COLOR_DEBUG)
Else
$pixelRandomDropcc[0] = $BottomRight[2][0]
$pixelRandomDropcc[1] = $BottomRight[2][1]
If $debugSetlog = 1 Then SetLog("Deploy CC $BottomRight", $COLOR_DEBUG)
EndIf
If ($isCCDropped = False And $infoTroopListArrPixel[0] = "CC") Then
dropCC($pixelRandomDropcc[0], $pixelRandomDropcc[1], $CC)
$isCCDropped = True
ElseIf ($isHeroesDropped = False And $infoTroopListArrPixel[0] = "HEROES" And $i = $numberSidesDropTroop - 1) Then
dropHeroes($pixelRandomDrop[0], $pixelRandomDrop[1], $King, $Queen, $Warden)
$isHeroesDropped = True
EndIf
Else
$infoListArrPixel = $infoTroopListArrPixel[1]
$listPixel = $infoListArrPixel[$i]
If _Sleep($iDelayLaunchTroop21) Then Return
SelectDropTroop($infoTroopListArrPixel[0])
If _Sleep($iDelayLaunchTroop23) Then Return
SetLog("Dropping " & $infoTroopListArrPixel[2] & "  of " & $infoTroopListArrPixel[5] & " => on each side (side : " & $i + 1 & ")", $COLOR_GREEN)
Local $pixelDropTroop[1] = [$listPixel]
DropOnPixel($infoTroopListArrPixel[0], $pixelDropTroop, $infoTroopListArrPixel[2], $infoTroopListArrPixel[3])
EndIf
If ($isHeroesDropped) Then
If _sleep(1000) Then Return
CheckHeroesHealth()
EndIf
Next
Next
EndIf
EndIf
If _Sleep(SetSleep(1)) Then Return
Next
EndIf
For $numWave = 0 To UBound($listListInfoDeployTroopPixel) - 1
Local $listInfoDeployTroopPixel = $listListInfoDeployTroopPixel[$numWave]
For $i = 0 To UBound($listInfoDeployTroopPixel) - 1
Local $infoPixelDropTroop = $listInfoDeployTroopPixel[$i]
If Not (IsString($infoPixelDropTroop[0]) And ($infoPixelDropTroop[0] = "CC" Or $infoPixelDropTroop[0] = "HEROES")) Then
Local $numberLeft = ReadTroopQuantity($infoPixelDropTroop[0])
If ($numberLeft > 0) Then
If _Sleep($iDelayLaunchTroop21) Then Return
SelectDropTroop($infoPixelDropTroop[0])
If _Sleep($iDelayLaunchTroop23) Then Return
SetLog("Dropping last " & $numberLeft & "  of " & $infoPixelDropTroop[5], $COLOR_GREEN)
DropOnPixel($infoPixelDropTroop[0], $infoPixelDropTroop[1], Ceiling($numberLeft / UBound($infoPixelDropTroop[1])), $infoPixelDropTroop[3])
EndIf
EndIf
Next
Next
Else
For $i = 0 To UBound($listInfoDeploy) - 1
If (IsString($listInfoDeploy[$i][0]) And ($listInfoDeploy[$i][0] = "CC" Or $listInfoDeploy[$i][0] = "HEROES")) Then
If $iMatchMode = $LB And $iChkDeploySettings[$LB] >= 4 Then
Local $RandomEdge = $Edges[$BuildingEdge]
Local $RandomXY = 2
Else
Local $RandomEdge = $Edges[Round(Random(0, 3))]
Local $RandomXY = Round(Random(1, 3))
EndIf
If ($listInfoDeploy[$i][0] = "CC") Then
dropCC($RandomEdge[$RandomXY][0], $RandomEdge[$RandomXY][1], $CC)
ElseIf ($listInfoDeploy[$i][0] = "HEROES") Then
dropHeroes($RandomEdge[$RandomXY][0], $RandomEdge[$RandomXY][1], $King, $Queen, $Warden)
EndIf
Else
If $duringMilkingAttack = 0 Then
If LauchTroop($listInfoDeploy[$i][0], $listInfoDeploy[$i][1], $listInfoDeploy[$i][2], $listInfoDeploy[$i][3], $listInfoDeploy[$i][4]) Then
If _Sleep(SetSleep(1)) Then Return
EndIf
Else
If $listInfoDeploy[$i][0] <> $eGobl Then
If LauchTroop($listInfoDeploy[$i][0], $listInfoDeploy[$i][1], $listInfoDeploy[$i][2], $listInfoDeploy[$i][3], $listInfoDeploy[$i][4]) Then
If _Sleep(SetSleep(1)) Then Return
EndIf
EndIf
EndIf
EndIf
Next
EndIf
Return True
EndFunc
Func NameOfTroop($iKind, $iPlural = 0)
Local $sTroopname
Switch $iKind
Case $eBarb
$sTroopname = "Barbarian"
Case $eArch
$sTroopname = "Archer"
Case $eGobl
$sTroopname = "Goblin"
Case $eGiant
$sTroopname = "Giant"
Case $eWall
$sTroopname = "Wall Breaker"
Case $eWiza
$sTroopname = "Wizard"
Case $eBall
$sTroopname = "Balloon"
Case $eHeal
$sTroopname = "Healer"
Case $eDrag
$sTroopname = "Dragon"
Case $ePekk
$sTroopname = "Pekka"
Case $eBabyD
$sTroopname = "Baby Dragon"
Case $eMine
$sTroopname = "Miner"
Case $eMini
$sTroopname = "Minion"
Case $eHogs
$sTroopname = "Hog Rider"
Case $eValk
$sTroopname = "Valkyrie"
Case $eWitc
$sTroopname = "Witch"
Case $eGole
$sTroopname = "Golem"
Case $eLava
$sTroopname = "Lava Hound"
Case $eBowl
$sTroopname = "Bowler"
Case $eKing
$sTroopname = "King"
$iPlural = 0
Case $eQueen
$sTroopname = "Queen"
$iPlural = 0
Case $eWarden
$sTroopname = "Grand Warden"
$iPlural = 0
Case $eCastle
$sTroopname = "Clan Castle"
$iPlural = 0
Case $eLSpell
$sTroopname = "Lightning Spell"
Case $eHSpell
$sTroopname = "Heal Spell"
Case $eRSpell
$sTroopname = "Rage Spell"
Case $eJSpell
$sTroopname = "Jump Spell"
Case $eFSpell
$sTroopname = "Freeze Spell"
Case $eCSpell
$sTroopname = "Clone Spell"
Case $ePSpell
$sTroopname = "Poison Spell"
Case $eESpell
$sTroopname = "Earthquake Spell"
Case $eHaSpell
$sTroopname = "Haste Spell"
Case $eSkSpell
$sTroopname = "Skeleton Spell"
Case Else
Return ""
EndSwitch
If $iPlural = 1 And $iKind = $eWitc Then $sTroopname &= "e"
If $iPlural = 1 Then $sTroopname &= "s"
Return $sTroopname
EndFunc
Func OldDropTroop($troop, $position, $nbperspot)
SelectDropTroop($troop)
If _Sleep($iDelayOldDropTroop1) Then Return
For $i = 0 To 4
Click($position[$i][0], $position[$i][1], $nbperspot, 1, "#0110")
If _Sleep($iDelayOldDropTroop2) Then Return
Next
EndFunc
Func ReadTroopQuantity($Troop)
Local $iAmount
$iAmount = getTroopCountSmall(GetXPosOfArmySlot($Troop, 40), 582 + $bottomOffsetY)
If $iAmount = "" Then
$iAmount = getTroopCountBig(GetXPosOfArmySlot($Troop, 40), 577 + $bottomOffsetY)
EndIf
Return Number($iAmount)
EndFunc
Func SelectDropTroop($Troop)
If IsAttackPage() Then Click(GetXPosOfArmySlot($Troop, 68), 595 + $bottomOffsetY, 1, 0, "#0111")
EndFunc
Func SetSleep($type)
If IsKeepClicksActive() = True Then Return 0
Local $factor0 = 10
Local $factor1 = 100
If $AndroidAdbClick = True Then
$factor0 = 10
$factor1 = 100
EndIf
Switch $type
Case 0
If $iChkRandomspeedatk[$iMatchMode] = 1 Then
Return Round(Random(1, 10)) * $factor0
Else
Return ($iCmbUnitDelay[$iMatchMode] + 1) * $factor0
EndIf
Case 1
If $iChkRandomspeedatk[$iMatchMode] = 1 Then
Return Round(Random(1, 10)) * $factor1
Else
Return ($iCmbWaveDelay[$iMatchMode] + 1) * $factor1
EndIf
EndSwitch
EndFunc
Func _SleepAttack($iDelay, $iSleep = True)
If $RunState = False Then
ResumeAndroid()
Return True
EndIf
If IsKeepClicksActive() = True Then Return False
Return _Sleep($iDelay, $iSleep)
EndFunc
Func getArmyCCStatus($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Begin getArmyCCStatus:", $COLOR_DEBUG)
$iCCRemainTime = 0
If $bOpenArmyWindow = False And IsTrainPage() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If openArmyOverview() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
If $debugsetlogTrain = 1 Then SETLOG("Can Request CC: " & $canRequestCC, $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) Then
Local $iRemainTrainCCTimer = 0, $sResultCCMinutes = "", $aResult
Local $sResultCC = getArmyCampCap($aArmyCCRemainTime[0], $aArmyCCRemainTime[1])
If $debugsetlogTrain = 1 Then Setlog("getArmyCampCap returned: " & $sResultCC, $COLOR_DEBUG)
If $sResultCC <> "" Then
If StringInStr($sResultCC, "m") > 1 Then
$aResult = StringSplit($sResultCC, "m", $STR_NOCOUNT)
$aResult[1] = StringStripWS($aResult[1], $STR_STRIPALL)
$sResultCCMinutes = StringTrimRight($aResult[1], 1)
$iRemainTrainCCTimer = Number($aResult[0]) + Number($sResultCCMinutes / 60)
ElseIf StringInStr($sResultCC, "s") > 1 Then
$iRemainTrainCCTimer = Number(StringStripWS($sResultCC, $STR_STRIPALL)) / 60
Else
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("getArmyCCStatus: Bad OCR string: " & $sResultCC, $COLOR_DEBUG)
EndIf
If $bDonationEnabled Or $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("CC request time: " & StringFormat("%.2f", $iRemainTrainCCTimer) & " minutes", $COLOR_BLUE)
$iCCRemainTime = $iRemainTrainCCTimer
Else
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("Can not read remaining Spell train time!", $COLOR_DEBUG)
EndIf
EndIf
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
EndFunc
Func getArmyHeroCount($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SETLOG("Begin getArmyTHeroCount:", $COLOR_DEBUG)
If $bOpenArmyWindow = False And ISArmyWindow() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If OpenArmyWindow() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
If $iTownHallLevel < 7 then return
$iHeroAvailable = $HERO_NOHERO
$bFullArmyHero = False
Local $debugArmyHeroCount = 0
Local $sResult
Local Const $HeroSlots[3][2] = [[464, 446], [526, 446], [588, 446]]
Local $sMessage = ""
For $index = 0 To UBound($HeroSlots) - 1
$sResult = ArmyHeroStatus($index)
If $sResult <> "" Then
Select
Case StringInStr($sResult, "king", $STR_NOCASESENSEBASIC)
Setlog(" - Barbarian King available", $COLOR_GREEN)
$iHeroAvailable = BitOR($iHeroAvailable, $HERO_KING)
Case StringInStr($sResult, "queen", $STR_NOCASESENSEBASIC)
Setlog(" - Archer Queen available", $COLOR_GREEN)
$iHeroAvailable = BitOR($iHeroAvailable, $HERO_QUEEN)
Case StringInStr($sResult, "warden", $STR_NOCASESENSEBASIC)
Setlog(" - Grand Warden available", $COLOR_GREEN)
$iHeroAvailable = BitOR($iHeroAvailable, $HERO_WARDEN)
Case StringInStr($sResult, "heal", $STR_NOCASESENSEBASIC)
If $debugsetlogTrain = 1 Or $debugArmyHeroCount = 1 Then
Switch $index
Case 0
$sMessage = "-Barbarian King"
Case 1
$sMessage = "-Archer Queen"
Case 2
$sMessage = "-Grand Warden"
Case Else
$sMessage = "-Very Bad Monkey Needs"
EndSwitch
SetLog("Hero slot#" & $index + 1 & $sMessage & " Healing", $COLOR_DEBUG)
EndIf
If $index = 0 then Setlog(" - Barbarian King Recovering", $COLOR_ACTION)
If $index = 1 then Setlog(" - Archer Queen Recovering", $COLOR_ACTION)
If $index = 2 then Setlog(" - Grand Warden Recovering", $COLOR_ACTION)
Case StringInStr($sResult, "upgrade", $STR_NOCASESENSEBASIC)
Switch $index
Case 0
$sMessage = "-Barbarian King"
If BitAND($iHeroAttack[$DB], $iHeroWait[$DB], $HERO_KING) = $HERO_KING Or BitAND($iHeroAttack[$LB], $iHeroWait[$LB], $HERO_KING) = $HERO_KING Then
_GUI_Value_STATE("SHOW", $groupKingSleeping)
SetLog("Warning: King Upgrading & Wait enabled, Disable Wait for King or may never attack!", $COLOR_RED)
EndIf
Case 1
$sMessage = "-Archer Queen"
If BitAND($iHeroAttack[$DB], $iHeroWait[$DB], $HERO_QUEEN) = $HERO_QUEEN Or BitAND($iHeroAttack[$LB], $iHeroWait[$LB], $HERO_QUEEN) = $HERO_QUEEN Then
_GUI_Value_STATE("SHOW", $groupQueenSleeping)
SetLog("Warning: Queen Upgrading & Wait enabled, Disable Wait for Queen or may never attack!", $COLOR_RED)
EndIf
Case 2
$sMessage = "-Grand Warden"
If BitAND($iHeroAttack[$DB], $iHeroWait[$DB], $HERO_WARDEN) = $HERO_WARDEN Or BitAND($iHeroAttack[$LB], $iHeroWait[$LB], $HERO_WARDEN) = $HERO_WARDEN Then
_GUI_Value_STATE("SHOW", $groupWardenSleeping)
SetLog("Warning: Warden Upgrading & Wait enabled, Disable Wait for Warden or may never attack!", $COLOR_RED)
EndIf
Case Else
$sMessage = "-Need to Get Monkey"
EndSwitch
If $debugsetlogTrain = 1 Or $debugArmyHeroCount = 1 Then SetLog("Hero slot#" & $index + 1 & $sMessage & " Upgrade in Process", $COLOR_DEBUG)
Case StringInStr($sResult, "none", $STR_NOCASESENSEBASIC)
If $debugsetlogTrain = 1 Or $debugArmyHeroCount = 1 Then SetLog("Hero slot#" & $index + 1 & " Empty, stop count", $COLOR_DEBUG)
ExitLoop
Case Else
SetLog("Hero slot#" & $i + 1 & " bad OCR string returned!", $COLOR_RED)
EndSelect
Else
SetLog("Hero slot#" & $index + 1 & " status read problem!", $COLOR_RED)
EndIf
Next
If $iDBcheck = 0 then $iHeroWait[$DB] = $HERO_NOHERO
If $iABcheck = 0 then $iHeroWait[$LB] = $HERO_NOHERO
If (($iDBcheck = 1 and $iHeroWait[$DB]<= $iHeroAvailable) Or ($iABcheck = 1 and $iHeroWait[$LB]<= $iHeroAvailable)) Or  ($iHeroWait[$DB] = $HERO_NOHERO And $iHeroWait[$LB] = $HERO_NOHERO) Then
$bFullArmyHero = True
If $debugsetlogTrain = 1 Or $debugArmyHeroCount = 1 Then SetLog("$bFullArmyHero= " & $bFullArmyHero, $COLOR_DEBUG)
EndIf
If $debugsetlogTrain = 1 Or $debugArmyHeroCount = 1 Then SetLog("Hero Status K|Q|W : " & BitAND($iHeroAvailable, $HERO_KING) & "|" & BitAND($iHeroAvailable, $HERO_QUEEN) & "|" & BitAND($iHeroAvailable, $HERO_WARDEN), $COLOR_DEBUG)
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
EndFunc
Func getArmyHeroTime($HeroType, $bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Begin getArmyHeroTime:", $COLOR_DEBUG)
If $HeroType <> $eKing And $HeroType <> $eQueen And $HeroType <> $eWarden And StringInStr($HeroType, "all", $STR_NOCASESENSEBASIC) = 0 Then
Setlog("getHeroTime slipped on banana, get doctor, tell him: " & $HeroType, $COLOR_RED)
SetError(1)
Return
EndIf
If $bOpenArmyWindow = False And ISArmyWindow() = False Then
SetError(2)
Return
ElseIf $bOpenArmyWindow = True Then
If OpenArmyWindow() = False Then
SetError(3)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
If $iTownHallLevel < 7 then return
Local $iRemainTrainHeroTimer = 0
Local $sResult
Local $iResultHeroes[3] = ["", "", ""]
Local Const $HeroSlots[3][2] = [[464, 446], [526, 446], [588, 446]]
Local Const $aHeroRemainData[3][4] = [[620, 414, "King", $eKing], [695, 414, "Queen", $eQueen], [775, 414, "Warden", $eWarden]]
For $index = 0 To UBound($HeroSlots) - 1
If StringInStr($HeroType, "all", $STR_NOCASESENSEBASIC) = 0 And $HeroType <> $aHeroRemainData[$index][3] Then ContinueLoop
$sResult = ArmyHeroStatus($index)
If $sResult <> "" Then
If StringInStr($sResult, "heal", $STR_NOCASESENSEBASIC) = 0 or StringInStr($sResult, "none", $STR_NOCASESENSEBASIC) <> 0 Then
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then
SetLog("Hero slot#" & $index + 1 & " status: " & $sResult & " :skip time read", $COLOR_DEBUG)
EndIf
ContinueLoop
Else
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("Hero slot#" & $index + 1 & " status: " & $sResult, $COLOR_DEBUG)
EndIf
Else
SetLog("Hero slot#" & $index + 1 & " Status read problem!", $COLOR_RED)
EndIf
$sResult = getRemainTHero($aHeroRemainData[$index][0], $aHeroRemainData[$index][1])
If $sResult <> "" Then
Select
Case StringInStr($sResult, "m", $STR_NOCASESENSEBASIC) >= 1
$sResultHeroTime = StringTrimRight($sResult, 1)
$iResultHeroes[$index] = Number($sResultHeroTime)
Case StringInStr($sResult, "s", $STR_NOCASESENSEBASIC) >= 1
$sResultHeroTime = StringTrimRight($sResult, 1)
$iResultHeroes[$index] = Number($sResultHeroTime) / 60
Case Else
SetLog("Bad read of remaining " & $aHeroRemainData[$index][2] & " train time: " & $sResult, $COLOR_RED)
EndSelect
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("Remaining " & $aHeroRemainData[$index][2] & " train time: " & StringFormat("%.2f", $iResultHeroes[$index]), $COLOR_DEBUG)
If $HeroType = $aHeroRemainData[$index][3] Then
$iRemainTrainHeroTimer = Number($sResultHeroTime)
ExitLoop
EndIf
Else
If $HeroType = $aHeroRemainData[$index][3] Then
SetLog("Can not read remaining " & $aHeroRemainData[$index][2] & " train time", $COLOR_RED)
Else
For $pMatchMode = $DB To $iMatchMode - 1
If IsSpecialTroopToBeUsed($pMatchMode, $aHeroRemainData[$index][3]) And  BitAND($iHeroAttack[$pMatchMode], $iHeroWait[$pMatchMode]) = $iHeroWait[$pMatchMode] Then
SetLog("Can not read remaining " & $aHeroRemainData[$index][2] & " train time", $COLOR_RED)
ExitLoop
Else
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("Bad read remain " & $aHeroRemainData[$index][2] & " train time, but not enabled", $COLOR_DEBUG)
EndIf
Next
EndIf
EndIf
Next
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
If $HeroType = $eKing Or $HeroType = $eQueen Or $HeroType = $eWarden Then
Return $iRemainTrainHeroTimer
ElseIf StringInStr($HeroType, "all", $STR_NOCASESENSEBASIC) > 0 Then
Return $iResultHeroes
EndIf
EndFunc
Func ReadHeroesRecoverTime($aHeroResult)
Local $aResult, $iActiveHero
$aTimeTrain[2] = 0
If $iTownHallLevel < 7 Then Return
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("ReadHeroesRecoverTime", $COLOR_DEBUG)
Setlog(" Â» Getting Heroes Recover Time: ")
If $aHeroResult[0] > 0 Then
SetLog(" Â»Â» King: " & StringFormat("%.2f", $aHeroResult[0]) & " minute", $COLOR_BLUE)
EndIf
If $aHeroResult[1] > 0 Then
SetLog(" Â»Â» Queen: " & StringFormat("%.2f", $aHeroResult[1]) & " minute", $COLOR_BLUE)
EndIf
If $aHeroResult[2] > 0 Then
SetLog(" Â»Â» Warden: " & StringFormat("%.2f", $aHeroResult[2]) & " minute", $COLOR_BLUE)
EndIf
If $aHeroResult[0] = 0 And $aHeroResult[1] = 0 And $aHeroResult[2] = 0 Then
SetLog(" Â» No Heroes Waiting Time..", $COLOR_GREEN)
EndIf
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("getArmyHeroTime returned: " & $aHeroResult[0] & ":" & $aHeroResult[1] & ":" & $aHeroResult[2], $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return
If $aHeroResult[0] > 0 Or $aHeroResult[1] > 0 Or $aHeroResult[2] > 0 Then
For $pTroopType = $eKing To $eWarden
For $pMatchMode = $DB To $iModeCount - 1
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then
SetLog("$pTroopType: " & NameOfTroop($pTroopType) & ", $pMatchMode: " & $sModeText[$pMatchMode], $COLOR_DEBUG)
Setlog("TroopToBeUsed: " & IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) & ", Hero Wait Status: " & (BitOr($iHeroAttack[$pMatchMode], $iHeroWait[$pMatchMode]) = $iHeroAttack[$pMatchMode]), $COLOR_DEBUG)
EndIf
$iActiveHero = -1
If IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) And  BitOr($iHeroAttack[$pMatchMode], $iHeroWait[$pMatchMode]) = $iHeroAttack[$pMatchMode] Then
$iActiveHero = $pTroopType - $eKing
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $aTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$aTimeTrain[2] = $aHeroResult[$iActiveHero]
EndIf
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then
SetLog("Wait enabled: " & NameOfTroop($pTroopType) & ", Attack Mode:" & $sModeText[$pMatchMode] & ", Hero Time:" & $aHeroResult[$iActiveHero] & ", Wait Time: " & StringFormat("%.2f", $aTimeTrain[2]), $COLOR_DEBUG)
EndIf
EndIf
Next
If _Sleep($iDelayRespond) Then Return
Next
Else
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("getArmyHeroTime return all zero hero wait times", $COLOR_DEBUG)
EndIf
If $aHeroResult[0] > 0 Or $aHeroResult[1] > 0 Or $aHeroResult[2] > 0 Then
Setlog("Heroes Wait Time: " & StringFormat("%.2f", $aTimeTrain[2]) & " minute(s)", $COLOR_BLUE)
EndIf
EndFunc
Func GetReadTimeHeroesAndSpell()
If IsMainPage() = False Then checkMainScreen()
getArmyTroopTime(True, False)
If IsWaitforSpellsActive() Then
getArmySpellTime()
Else
$aTimeTrain[1] = 0
EndIf
ClickP($aAway, 1, 0, "#0000")
EndFunc
Func ArmyHeroStatus($Hero)
Local $directory = @ScriptDir & "\images\Other\HeroStatus"
Local Const $aHeroesRect[3][4] = [[610, 340, 680, 370], [683, 340, 755, 370], [757, 340, 830, 370]]
Local $Result
Select
Case $Hero = "King" Or $Hero = 0 Or $Hero = $eKing
$Result = SearchArmy($directory, $aHeroesRect[0][0], $aHeroesRect[0][1], $aHeroesRect[0][2], $aHeroesRect[0][3], "", True)
$Status = $Result[0][0]
If $Status = "" Then $Status = "king"
Return $Status
Case $Hero = "Queen" Or $Hero = 1 Or $Hero = $eQueen
$Result = SearchArmy($directory, $aHeroesRect[1][0], $aHeroesRect[1][1], $aHeroesRect[1][2], $aHeroesRect[1][3], "", True)
$Status = $Result[0][0]
If $Status = "" Then $Status = "queen"
Return $Status
Case $Hero = "Warden" Or $Hero = 2 Or $Hero = $eWarden
$Result = SearchArmy($directory, $aHeroesRect[2][0], $aHeroesRect[2][1], $aHeroesRect[2][2], $aHeroesRect[2][3], "", True)
$Status = $Result[0][0]
If $Status = "" Then $Status = "warden"
Return $Status
EndSelect
EndFunc
Func CountHeroes()
Local $directory = @ScriptDir & "\images\Other\HeroStatus"
Local Const $aHeroesRect[3][4] = [[610, 340, 680, 370], [683, 340, 755, 370], [757, 340, 830, 370]]
Local $Result
Local $Available = 0, $Healing = 0, $Upgrading = 0, $None = 0, $AvaiAndHealing = 0
Local $ToReturn[5] = [$Available, $Healing, $Upgrading, $None, $AvaiAndHealing]
For $i = 0 To (UBound($aHeroesRect) - 1)
$Result = SearchArmy($directory, $aHeroesRect[$i][0], $aHeroesRect[$i][1], $aHeroesRect[$i][2], $aHeroesRect[$i][3], "", True)
$Status = $Result[0][0]
Switch $Status
Case "heal"
$Healing += 1
Case "upgrade"
$Upgrading += 1
Case "none"
$None += 1
Case Else
$Available += 1
EndSwitch
Next
$AvaiAndHealing = Number($Available + $Healing)
$ToReturn[0] = $Available
$ToReturn[1] = $Healing
$ToReturn[2] = $Upgrading
$ToReturn[3] = $None
$ToReturn[4] = $AvaiAndHealing
Return $ToReturn
EndFunc
Func getArmySpellTime($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Begin getArmySpellTime:", $COLOR_DEBUG)
Local $ResultTroopsHour = 0
Local $ResultTroopsMinutes = 0
Local $ResultTroopsSeconds = 0
$aTimeTrain[1] = 0
Local $iRemainTrainSpellsTimer = 0
If $bOpenArmyWindow = False And ISArmyWindow() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If OpenArmyWindow() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
Local $TimeRemainSpells = getRemainTrainTimer(495, 315)
If $TimeRemainSpells <> "" Then
If StringInStr($TimeRemainSpells, "h") > 1 Then
$ResultTroopsHour = StringSplit($TimeRemainSpells, "h", $STR_NOCOUNT)
$ResultTroopsMinutes = StringTrimRight($ResultTroopsHour[1], 1)
$iRemainTrainSpellsTimer = (Number($ResultTroopsHour[0]) * 60) + Number($ResultTroopsMinutes)
ElseIf StringInStr($TimeRemainSpells, "m") > 1 Then
$ResultTroopsMinutes = StringSplit($TimeRemainSpells, "m", $STR_NOCOUNT)
$iRemainTrainSpellsTimer = $ResultTroopsMinutes[0] + Ceiling($ResultTroopsMinutes[1] / 60)
Else
$ResultTroopsSeconds = StringTrimRight($TimeRemainSpells, 1)
$iRemainTrainSpellsTimer = Ceiling($ResultTroopsSeconds / 60)
EndIf
$aTimeTrain[1] = $iRemainTrainSpellsTimer
Setlog("Remain Spells Time: " & $iRemainTrainSpellsTimer & " min", $COLOR_GREEN)
Else
If Not $bFullArmySpells Then
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("Can not read remaining Spell train time!", $COLOR_DEBUG)
EndIf
EndIf
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
$aTimeTrain[1] = $iRemainTrainSpellsTimer
EndFunc
Func getArmyTroopTime($bOpenArmyWindow = False, $bCloseArmyWindow = False)
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SETLOG("Begin getArmyTroopTime:", $COLOR_DEBUG)
Local $ResultTroopsHour, $ResultTroopsMinutes, $ResultTroopsSeconds
Local $aRemainTrainTroopTimer = 0 , $iRemainTrainTroopTimer = 0
$aTimeTrain[0] = 0
If $bOpenArmyWindow = False And ISArmyWindow() = False Then
SetError(1)
Return
ElseIf $bOpenArmyWindow = True Then
If OpenArmyWindow() = False Then
SetError(2)
Return
EndIf
If _Sleep($iDelaycheckArmyCamp5) Then Return
EndIf
Local $TimeRemainTroops = getRemainTrainTimer(756, 169)
If $TimeRemainTroops <> "" Then
If StringInStr($TimeRemainTroops, "h") > 1 Then
$ResultTroopsHour = StringSplit($TimeRemainTroops, "h", $STR_NOCOUNT)
$ResultTroopsMinutes = StringTrimRight($ResultTroopsHour[1], 1)
$aRemainTrainTroopTimer = (Number($ResultTroopsHour[0]) * 60) + Number($ResultTroopsMinutes)
ElseIf StringInStr($TimeRemainTroops, "m") > 1 Then
$ResultTroopsMinutes = StringSplit($TimeRemainTroops, "m", $STR_NOCOUNT)
$aRemainTrainTroopTimer = $ResultTroopsMinutes[0] + Ceiling($ResultTroopsMinutes[1] / 60)
Else
$ResultTroopsSeconds = StringTrimRight($TimeRemainTroops, 1)
$aRemainTrainTroopTimer = Ceiling($ResultTroopsSeconds / 60)
EndIf
$aTimeTrain[0] = $aRemainTrainTroopTimer
Setlog("Remain Troops Time: " & $aRemainTrainTroopTimer & " min", $COLOR_GREEN)
Else
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("Can not read remaining Troop train time!", $COLOR_DEBUG)
EndIf
If $bCloseArmyWindow = True Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
EndIf
$aTimeTrain[0] = $aRemainTrainTroopTimer
EndFunc
Func openArmyOverview()
If IsMainPage() = False Then
SetLog("Can not open Army Overview window", $COLOR_RED)
SetError(1)
Return False
EndIf
If WaitforPixel(28, 505 + $bottomOffsetY, 30, 507 + $bottomOffsetY, Hex(0xE4A438, 6), 5, 10) Then
If $debugsetlogTrain = 1 Then SetLog("Click $aArmyTrainButton", $COLOR_GREEN)
If $iUseRandomClick = 0 then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0293")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIF
EndIf
If _Sleep($iDelayRunBot6) Then Return
If IsTrainPage() = False Then
SetError(1)
Return False
EndIf
Return True
EndFunc
Func SmartWait4Train()
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Begin SmartWait4Train:", $COLOR_DEBUG1)
If $ichkCloseWaitEnable = 0 Then Return
Local $iExitCount = 0
If _Sleep($iDelaySmartWait) Then Return
While IsMainPage() = False
If _Sleep($iDelayIdle1) Then Return
$iExitCount += 1
If $iExitCount > 25 Then
Setlog("SmartWait4Train not finding Main Page, skip function!", $COLOR_ERROR)
Return
EndIf
WEnd
If BitOR($ichkCloseWaitEnable, $ichkCloseWaitTrain) = 0 Then Return
Local $aResult, $iActiveHero
Local $aHeroResult[3]
Local Const $TRAINWAIT_NOWAIT = 0x00
Local Const $TRAINWAIT_SHIELD = 0x01
Local Const $TRAINWAIT_TROOP = 0x02
Local Const $TRAINWAIT_SPELL = 0x04
Local Const $TRAINWAIT_HERO = 0x08
Local $iTrainWaitCloseFlag = $TRAINWAIT_NOWAIT
Local $sNowTime = "", $sTrainEndTime = ""
Local $iShieldTime = 0, $iDiffDateTime = 0, $iDiffTime = 0
Local $RandomAddPercent = Random(0, $icmbCloseWaitRdmPercent / 100)
Local $MinimumTimeClose = Number($icmbMinimumTimeClose * 60)
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Random add percent = " & StringFormat("%.4f", $RandomAddPercent), $COLOR_DEBUG)
If $debugSetlog = 1 Then Setlog("$MinimumTimeClose = " & $MinimumTimeClose & "s", $COLOR_DEBUG)
Local $StopEmulator = False
If $ibtnCloseWaitStopRandom = 1 Then $StopEmulator = "random"
If $ibtnCloseWaitStop = 1 Then $StopEmulator = True
If IsArray($aShieldStatus) And (StringInStr($aShieldStatus[0], "shield", $STR_NOCASESENSEBASIC) Or StringInStr($aShieldStatus[0], "guard", $STR_NOCASESENSEBASIC)) Then
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("Have shield till " & $aShieldStatus[2] & ", close game while wait for train)", $COLOR_DEBUG)
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD)
EndIf
If _Sleep($iDelayRespond) Then Return
If IsArray($aShieldStatus) = 0 Or $aShieldStatus[0] = "" Or $aShieldStatus[0] = "none" Then
$aResult = getShieldInfo()
If @error Then
Setlog("SmartWait4Train Shield OCR error = " & @error & "Extended = " & @extended, $COLOR_ERROR)
Return False
Else
$aShieldStatus = $aResult
EndIf
If IsArray($aShieldStatus) And (StringInStr($aShieldStatus[0], "shield", $STR_NOCASESENSEBASIC) Or StringInStr($aShieldStatus[0], "guard", $STR_NOCASESENSEBASIC)) Then
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("Have shield till " & $aShieldStatus[2] & ", close game while wait for train)", $COLOR_DEBUG)
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD)
EndIf
EndIf
If $debugsetlogTrain = 1 Or $debugSetlog = 1 And IsArray($aShieldStatus) Then Setlog("Shield Status:" & $aShieldStatus[0] & ", till " & $aShieldStatus[2], $COLOR_DEBUG)
$result = OpenArmyWindow()
If $result = False Then
If $debugimagesave = 1 Or $debugsetlogTrain = 1 Then Debugimagesave("SmartWait4Troop2_")
EndIf
If _Sleep($iDelayRespond) Then Return
If $ichkCloseWaitTrain = 1 Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD Then
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("$ichkCloseWaitTrain enabled", $COLOR_DEBUG)
getArmyTroopTime()
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("getArmyTroopTime returned: " & $aTimeTrain[0], $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return
If $aTimeTrain[0] > 0 Then
If $ibtnCloseWaitRandom = 1 Then
$aTimeTrain[0] += $aTimeTrain[0] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_TROOP)
EndIf
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", troop time = " & StringFormat("%.2f", $aTimeTrain[0]), $COLOR_DEBUG)
EndIf
If ($ichkCloseWaitTrain = 1 Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD) And IsWaitforSpellsActive() Then
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("$ichkCloseWaitSpell enabled", $COLOR_DEBUG)
getArmySpellTime()
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("getArmySpellTime returned: " & $aTimeTrain[1], $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return
If $aTimeTrain[1] > 0 Then
If $ibtnCloseWaitRandom = 1 Then
$aTimeTrain[1] += $aTimeTrain[1] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_SPELL)
EndIf
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", spell time = " & StringFormat("%.2f", $aTimeTrain[1]), $COLOR_DEBUG)
EndIf
If ($ichkCloseWaitTrain = 1 Or BitAND($iTrainWaitCloseFlag, $TRAINWAIT_SHIELD) = $TRAINWAIT_SHIELD) And IsWaitforHeroesActive() Then
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("$ichkCloseWaitHero enabled", $COLOR_DEBUG)
For $j = 0 To UBound($aResult) - 1
$aHeroResult[$j] = 0
Next
If _Sleep($iDelayRespond) Then Return
$aHeroResult = getArmyHeroTime("all")
If @error Then
Setlog("getArmyHeroTime return error, exit SmartWait!", $COLOR_ERROR)
Return
EndIf
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then SetLog("getArmyHeroTime returned: " & $aHeroResult[0] & ":" & $aHeroResult[1] & ":" & $aHeroResult[2], $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return
If $aHeroResult[0] > 0 Or $aHeroResult[1] > 0 Or $aHeroResult[2] > 0 Then
For $pTroopType = $eKing To $eWarden
For $pMatchMode = $DB To $iModeCount - 1
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then
SetLog("$pTroopType: " & NameOfTroop($pTroopType) & ", $pMatchMode: " & $sModeText[$pMatchMode], $COLOR_DEBUG)
Setlog("TroopToBeUsed: " & IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) & ", Hero Wait Status: " & (BitAND($iHeroAttack[$pMatchMode], $iHeroWait[$pMatchMode]) = $iHeroAttack[$pMatchMode]), $COLOR_DEBUG)
EndIf
$iActiveHero = -1
If IsSpecialTroopToBeUsed($pMatchMode, $pTroopType) And  BitAND($iHeroAttack[$pMatchMode], $iHeroWait[$pMatchMode]) = $iHeroAttack[$pMatchMode] Then
$iActiveHero = $pTroopType - $eKing
EndIf
If $iActiveHero <> -1 And $aHeroResult[$iActiveHero] > 0 Then
If $ibtnCloseWaitRandom = 1 And $aTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$aTimeTrain[2] = $aHeroResult[$iActiveHero] + ($aHeroResult[$iActiveHero] * $RandomAddPercent)
ElseIf $ibtnCloseWaitExact = 1 And $aTimeTrain[2] < $aHeroResult[$iActiveHero] Then
$aTimeTrain[2] = $aHeroResult[$iActiveHero]
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_HERO)
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then
SetLog("Wait enabled: " & NameOfTroop($pTroopType) & ":" & $sModeText[$pMatchMode] & ", $iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", Hero Time:" & $aHeroResult[$iActiveHero] & ", Wait Time: " & StringFormat("%.2f", $aTimeTrain[2]), $COLOR_DEBUG)
EndIf
EndIf
Next
If _Sleep($iDelayRespond) Then Return
Next
Else
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("getArmyHeroTime return all zero hero wait times", $COLOR_DEBUG)
EndIf
If $aTimeTrain[2] > 0 Then
If $ibtnCloseWaitRandom = 1 Then
$aTimeTrain[2] += $aTimeTrain[2] * $RandomAddPercent
EndIf
$iTrainWaitCloseFlag = BitOR($iTrainWaitCloseFlag, $TRAINWAIT_HERO)
EndIf
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("$iTrainWaitCloseFlag:" & $iTrainWaitCloseFlag & ", hero time = " & StringFormat("%.2f", $aTimeTrain[2]), $COLOR_DEBUG)
Else
$aTimeTrain[2] = 0
EndIf
If $iCCRemainTime = 0 And _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) Then
getArmyCCStatus()
EndIf
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
If $iTrainWaitCloseFlag = $TRAINWAIT_NOWAIT Then Return
Switch $iTrainWaitCloseFlag
Case 14 To 15
$iTrainWaitTime = _ArrayMax($aTimeTrain, 1, 0, 2, 0)
Case 12 To 13
$iTrainWaitTime = _Max($aTimeTrain[1], $aTimeTrain[2])
Case 10 To 11
$iTrainWaitTime = _Max($aTimeTrain[0], $aTimeTrain[2])
Case 8 To 9
$iTrainWaitTime = $aTimeTrain[2]
Case 6 To 7
$iTrainWaitTime = _Max($aTimeTrain[0], $aTimeTrain[1])
Case 4 To 5
$iTrainWaitTime = $aTimeTrain[1]
Case 2 To 3
$iTrainWaitTime = $aTimeTrain[0]
Case 1
If $aTimeTrain[0] <= 1 Then
ClickP($aAway, 1, 0, "#0000")
If _Sleep($iDelaycheckArmyCamp4) Then Return
Setlog("No smart troop wait needed", $COLOR_SUCCESS)
Return
Else
$iTrainWaitTime = $aTimeTrain[0]
EndIf
Case Else
Setlog("Impossible > Slipped on banana checking train time flag!", $COLOR_ERROR)
Return
EndSwitch
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then
Setlog("Training time values: " & StringFormat("%.2f", $aTimeTrain[0]) & " : " & StringFormat("%.2f", $aTimeTrain[1]) & " : " & StringFormat("%.2f", $aTimeTrain[2]), $COLOR_DEBUG)
SetLog("$iTrainWaitTime = " & StringFormat("%.2f", $iTrainWaitTime) & " minutes", $COLOR_DEBUG)
Setlog("$iTrainWaitCloseFlag: " & $iTrainWaitCloseFlag)
EndIf
If $iPlannedRequestCCHoursEnable = 1 And $iCCRemainTime > 0 And $iCCRemainTime < $iTrainWaitTime Then
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Wait time reduced for CC from: " & StringFormat("%.2f", $iTrainWaitTime) & " To " & StringFormat("%.2f", $iCCRemainTime), $COLOR_DEBUG)
$iTrainWaitTime = $iCCRemainTime
EndIf
$iTrainWaitTime = $iTrainWaitTime * 60
$sNowTime = _NowCalc()
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Train end time: " & _DateAdd("s", Int($iTrainWaitTime), $sNowTime), $COLOR_DEBUG)
If IsArray($aShieldStatus) And _DateIsValid($aShieldStatus[2]) Then
$iShieldTime = _DateDiff("s", $sNowTime, $aShieldStatus[2])
If @error Then _logErrorDateDiff(@error)
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Shield time remain: " & $iShieldTime & " seconds", $COLOR_DEBUG)
$iShieldTime -= 45
EndIf
If $iTrainWaitTime >= $MinimumTimeClose Then
If $iShieldTime > 0 Then
$iDiffTime = $iShieldTime - ($iTrainWaitTime)
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Time Train:Shield:Diff " & ($iTrainWaitTime) & ":" & $iShieldTime & ":" & $iDiffTime, $COLOR_DEBUG)
If $iDiffTime <= 0 And $iShieldTime > 120 Then
Setlog("Smart wait while shield time = " & StringFormat("%.2f", $iShieldTime / 60) & " Minutes", $COLOR_INFO)
UniversalCloseWaitOpenCoC($iShieldTime * 1000, "SmartWait4Train_", $StopEmulator)
$Restart = True
For $i = 0 To UBound($aTimeTrain) - 1
$aTimeTrain[$i] = 0
Next
Else
Setlog("Smart wait train time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
UniversalCloseWaitOpenCoC($iTrainWaitTime * 1000, "SmartWait4Train_", $StopEmulator)
$Restart = True
For $i = 0 To UBound($aTimeTrain) - 1
$aTimeTrain[$i] = 0
Next
EndIf
ElseIf ($ichkCloseWaitTrain = 1 And $aTimeTrain[0] > 0) Or ($ichkCloseWaitSpell = 1 And $aTimeTrain[1] > 0) Or ($ichkCloseWaitHero = 1 And $aTimeTrain[2] > 0) Then
Setlog("Smart Wait time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
UniversalCloseWaitOpenCoC($iTrainWaitTime * 1000, "SmartWait4TrainNoShield_", $StopEmulator)
$Restart = True
For $i = 0 To UBound($aTimeTrain) - 1
$aTimeTrain[$i] = 0
Next
Else
If $debugsetlogTrain = 1 Or $debugSetlog = 1 Then Setlog("Troop training with time remaining not enabled, skip SmartWait game exit", $COLOR_DEBUG)
EndIf
ElseIf $iTrainWaitTime < $MinimumTimeClose Then
Setlog("Smart Wait Time < Minimum Time Required To Close [" & ($MinimumTimeClose / 60) & " Min]", $COLOR_INFO)
Setlog("Wait Train Time = " & StringFormat("%.2f", $iTrainWaitTime / 60) & " Minutes", $COLOR_INFO)
Setlog("Not Close CoC Just Wait In The Main Screen", $COLOR_INFO)
_SleepStatus($iTrainWaitTime * 1000)
EndIf
EndFunc
Global $TypeTroops[4] = [1, 10, 20, 0]
Func TrainClick($x, $y, $iTimes, $iSpeed, $aWatchSpot, $aLootSpot, $sdebugtxt, $TypeTroops)
If IsTrainPage() Then
If $debugClick = 1 Then
Local $txt = _DecodeDebug($sdebugtxt)
SetLog("TrainClick " & $x & "," & $y & "," & $iTimes & "," & $iSpeed & " " & $sdebugtxt & $txt, $COLOR_ORANGE, "Verdana", "7.5", 0)
EndIf
If $iTimes <> 1 Then
If FastCaptureRegion() = True Then
For $i = 0 To ($iTimes - 1)
If isProblemAffect(True) Then checkMainScreen(False)
If $debugsetlogTrain = 1 Then SetLog("Full Check=" & _GetPixelColor($aWatchSpot[0], $aWatchSpot[1], True), $COLOR_DEBUG)
If _CheckPixel($aWatchSpot, True) = True Then ExitLoop
If _CheckPixel($aLootSpot, True) = True Then
SetLog("Elixir Check Fail: Color = " & _GetPixelColor($aLootSpot[0], $aLootSpot[1], False), $COLOR_DEBUG)
$OutOfElixir = 1
If _Sleep($iDelayTrainClick1) Then Return
If IsGemOpen(True) = True Then ClickP($aAway)
ExitLoop
EndIf
If $iUseRandomClick = 0 then
PureClick($x, $y, 1, $iSpeed)
Else
PureClickR($TypeTroops, $x, $y, 1, $iSpeed)
EndIf
If _Sleep($iSpeed, False) Then ExitLoop
Next
Else
If isProblemAffect(True) Then checkMainScreen(False)
If $debugsetlogTrain = 1 Then SetLog("Full Check=" & _GetPixelColor($aWatchSpot[0], $aWatchSpot[1], True), $COLOR_DEBUG)
If _CheckPixel($aWatchSpot, False) = True Then Return
If _CheckPixel($aLootSpot, False) = True Then
SetLog("Elixir Check Fail: Color = " & _GetPixelColor($aLootSpot[0], $aLootSpot[1], False), $COLOR_DEBUG)
$OutOfElixir = 1
If _Sleep($iDelayTrainClick1) Then Return
If IsGemOpen(False) = True Then ClickP($aAway)
Return
EndIf
If $iUseRandomClick = 0 then
PureClick($x, $y, $iTimes, $iSpeed)
Else
PureClickR($TypeTroops, $x, $y, $iTimes, $iSpeed)
EndIf
If _Sleep($iSpeed, False) Then Return
EndIf
Else
If isProblemAffect(True) Then checkMainScreen(False)
If $debugsetlogTrain = 1 Then SetLog("Full Check=" & _GetPixelColor($aWatchSpot[0], $aWatchSpot[1], False), $COLOR_DEBUG)
If _CheckPixel($aWatchSpot, True) = True Then Return
If _CheckPixel($aLootSpot, False) = True Then
SetLog("Elixir Check Fail: Color = " & _GetPixelColor($aLootSpot[0], $aLootSpot[1], False), $COLOR_DEBUG)
$OutOfElixir = 1
If _Sleep($iDelayTrainClick1) Then Return
If IsGemOpen(False) = True Then ClickP($aAway)
Return
EndIf
If $iUseRandomClick = 0 then
PureClick($x, $y, 1, $iSpeed)
Else
PureClickR($TypeTroops, $x, $y, 1, $iSpeed)
EndIF
If _Sleep($iSpeed, False) Then Return
If _CheckPixel($aLootSpot, True) = True Then
SetLog("Elixir Check Fail: Color = " & _GetPixelColor($aLootSpot[0], $aLootSpot[1], True), $COLOR_DEBUG)
$OutOfElixir = 1
If _Sleep($iDelayTrainClick1) Then Return
If IsGemOpen(True) = True Then ClickP($aAway)
Return
EndIf
EndIf
Return True
Else
Return False
EndIf
EndFunc
Func TrainClickP($point, $howMany, $speed, $aWatchSpot, $aLootSpot, $debugtxt, $TypeTroops)
Return TrainClick($point[0], $point[1], $howMany, $speed, $aWatchSpot, $aLootSpot, $debugtxt, $TypeTroops)
EndFunc
Func TrainIt($troopKind, $howMuch = 1, $iSleep = 400)
If $debugsetlogTrain = 1 Then SetLog("Func TrainIt " & $troopKind & " " & $howMuch & " " & $iSleep, $COLOR_DEBUG)
Local $bDark = False
_CaptureRegion()
Local $pos = GetTrainPos($troopKind)
If IsArray($pos) Then
If _CheckPixel($pos, $bNoCapturePixel) Then
Local $GemName = GetGemName($troopKind)
If IsArray($GemName) Then
Local $FullName = GetFullName($troopKind)
If IsArray($FullName) Then
Local $RNDName = GetRNDName($troopKind)
If IsArray($RNDName) Then
TrainClickP($pos, $howMuch, $iSleep, $FullName, $GemName, "#0266", $RNDName)
If _Sleep($iSleep) Then Return False
If $OutOfElixir = 1 Then
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $troopKind Then
$bDark = True
Setlog("Not enough Dark Elixir to train position " & $troopKind & " troops!", $COLOR_RED)
ExitLoop
EndIf
Next
If Not $bDark Then Setlog("Not enough Elixir to train position " & $troopKind & " troops!", $COLOR_RED)
Setlog("Switching to Halt Attack, Stay Online Mode...", $COLOR_RED)
$ichkBotStop = 1
$icmbBotCond = 18
If Not ($fullarmy = True) Then $Restart = True
Return
EndIf
Return True
Else
Setlog("TrainIt position " & $troopKind & " - RNDName did not return array?", $COLOR_RED)
EndIf
Else
Setlog("TrainIt " & NameOfTroop($troopKind) & " - FullName did not return array?", $COLOR_RED)
EndIf
Else
Setlog("TrainIt " & NameOfTroop($troopKind) & " - GemName did not return array?", $COLOR_RED)
EndIf
Else
Local $badPixelColor = _GetPixelColor($pos[0], $pos[1], $bNoCapturePixel)
If StringMid($badPixelColor, 1, 2) = StringMid($badPixelColor, 3, 2) And StringMid($badPixelColor, 1, 2) = StringMid($badPixelColor, 5, 2) Then
If $debugsetlogTrain = 1 Then Setlog("Troop " & NameOfTroop($troopKind) & " is not available due to full queue", $COLOR_DEBUG)
Else
Setlog("Bad pixel check on troop position " & NameOfTroop($troopKind), $COLOR_RED)
Setlog("Train Pixel Color: " & $badPixelColor, $COLOR_DEBUG)
EndIf
EndIf
Else
Setlog("Impossible happened? TrainIt troop position " & NameOfTroop($troopKind) & " did not return array", $COLOR_RED)
EndIf
EndFunc
Func GetTrainPos($troopKind)
If $debugsetlogTrain = 1 Then SetLog("Func GetTrainPos " & $troopKind, $COLOR_DEBUG)
For $i = 0 To UBound($TroopName) - 1
If Eval("e" & $TroopName[$i]) = $troopKind Then
Return Eval("Train" & $TroopName[$i])
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $troopKind Then
Return Eval("Train" & $TroopDarkName[$i])
EndIf
Next
For $i = 0 To UBound($SpellName) - 1
If Eval("e" & $SpellName[$i]) = $troopKind Then
Return Eval("Train" & $SpellName[$i])
EndIf
Next
SetLog("Don't know how to train the troop " & NameOfTroop($troopKind) & " yet")
Return 0
EndFunc
Func GetFullName($troopKind)
If $debugsetlogTrain = 1 Then SetLog("Func GetFullName " & $troopKind, $COLOR_DEBUG)
For $i = 0 To UBound($TroopName) - 1
If Eval("e" & $TroopName[$i]) = $troopKind Then
Return Eval("Full" & $TroopName[$i])
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $troopKind Then
Return Eval("Full" & $TroopDarkName[$i])
EndIf
Next
For $i = 0 To UBound($SpellName) - 1
If Eval("e" & $SpellName[$i]) = $troopKind Then
Return Eval("Full" & $SpellName[$i])
EndIf
Next
SetLog("Don't know how to find the troop " & NameOfTroop($troopKind) & " yet")
Return 0
EndFunc
Func GetGemName($troopKind)
If $debugsetlogTrain = 1 Then SetLog("Func GetGemName " & $troopKind, $COLOR_DEBUG)
For $i = 0 To UBound($TroopName) - 1
If Eval("e" & $TroopName[$i]) = $troopKind Then
Return Eval("Gem" & $TroopName[$i])
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $troopKind Then
Return Eval("Gem" & $TroopDarkName[$i])
EndIf
Next
For $i = 0 To UBound($SpellName) - 1
If Eval("e" & $SpellName[$i]) = $troopKind Then
Return Eval("Gem" & $SpellName[$i])
EndIf
Next
SetLog("Don't know how to find the troop " & NameOfTroop($troopKind) & " yet")
Return 0
EndFunc
Func GetRNDName($troopKind)
If $debugsetlogTrain = 1 Then SetLog("Func GetRNDName " & $troopKind, $COLOR_DEBUG)
For $i = 0 To UBound($TroopName) - 1
If Eval("e" & $TroopName[$i]) = $troopKind Then
Return Eval("Train" & $TroopName[$i] & "RND")
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $troopKind Then
Return Eval("Train" & $TroopDarkName[$i] & "RND")
EndIf
Next
For $i = 0 To UBound($SpellName) - 1
If Eval("e" & $SpellName[$i]) = $troopKind Then
Return Eval("Train" & $SpellName[$i])
EndIf
Next
SetLog("Don't know how to find the troop " & $troopKind & " yet")
Return 0
EndFunc
Global Enum $ArmyTAB, $TrainTroopsTAB, $BrewSpellsTAB, $QuickTrainTAB
Func TestTrainRevamp()
If $ichkUseQTrain = 0 Then
TestTrainRevampOldStyle()
Return
EndIf
If $debugsetlogTrain = 1 Then Setlog(" Â» Initial Quick train Function")
Local $timer
Local $tempElixir = ""
Local $tempDElixir = ""
Local $tempElixirSpent = 0
Local $tempDElixirSpent = 0
VillageReport(True, True)
$tempCounter = 0
While ($iElixirCurrent = "" Or ($iDarkCurrent = "" And $iDarkStart <> "")) And $tempCounter < 5
$tempCounter += 1
If _Sleep(100) Then Return
VillageReport(True, True)
WEnd
$tempElixir = $iElixirCurrent
$tempDElixir = $iDarkCurrent
If $debugsetlogTrain = 1 Then Setlog(" Â»Â» Line Open Army Window")
If OpenArmyWindow() = False Then Return
SetLog(" Â»Â» Army Window Opened!", $COLOR_ACTION1)
If _Sleep(250) Then Return
If $Runstate = False Then Return
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
If $debugsetlogTrain = 1 Then Setlog(" Â»Â» $canRequestCC : " & _GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True))
If $debugsetlogTrain = 1 Then $debugOcr = 1
Local $sArmyCamp = getArmyCampCap(110, 166)
Local $aGetArmySize = StringSplit($sArmyCamp, "#", $STR_NOCOUNT)
If $debugsetlogTrain = 1 Then Setlog(" Â»Â» $sArmyCamp : " & $sArmyCamp)
Local $sSpells = getArmyCampCap(99, 313)
Local $aGetSpellsSize = StringSplit($sSpells, "#", $STR_NOCOUNT)
If $debugsetlogTrain = 1 Then Setlog(" Â»Â» $sSpells : " & $sSpells)
Local $scastle = getArmyCampCap(300, 468)
Local $aGetCastleSize = StringSplit($scastle, "#", $STR_NOCOUNT)
If $debugsetlogTrain = 1 Then Setlog(" Â»Â» $scastle : " & $scastle)
If $debugsetlogTrain = 1 Then $debugOcr = 0
$fullarmy = False
$CurCamp = 0
If UBound($aGetArmySize) = 2 Then
If $ichkTotalCampForced = 0 Then
$CurCamp = $aGetArmySize[0]
$TotalCamp = $aGetArmySize[1]
Else
$CurCamp = $aGetArmySize[0]
$TotalCamp = Number($iValueTotalCampForced)
EndIf
If ($CurCamp >= ($TotalCamp * $fulltroop / 100)) And $CommandStop = -1 Then
$fullarmy = True
EndIf
Else
SetLog("Error reading Camp size")
Return
EndIf
If $debugsetlogTrain = 1 Then Setlog(" Â»Â» $CurCamp : " & $CurCamp)
If $debugsetlogTrain = 1 Then Setlog(" Â»Â» $TotalCamp : " & $TotalCamp)
If $debugsetlogTrain = 1 Then Setlog(" Â»Â» $fullarmy : " & $fullarmy)
$bFullArmySpells = False
$iTotalSpellSpace = 0
If UBound($aGetSpellsSize) = 2 Then
If $aGetSpellsSize[0] = $aGetSpellsSize[1] Or $aGetSpellsSize[0] >= $iTotalCountSpell Then
$iTotalSpellSpace = $aGetSpellsSize[0]
$bFullArmySpells = True
EndIf
Else
SetLog("Error reading Spells size")
Return
EndIf
Local $checkSpells = checkspells()
If $Runstate = False Then Return
Local $fullcastlespells = IsFullCastleSpells()
If $Runstate = False Then Return
Local $fullcastletroops = IsFullCastleTroops()
$bFullCastle = False
If UBound($aGetCastleSize) = 2 Then
If $aGetCastleSize[0] = $aGetCastleSize[1] Then
$bFullCastle = True
EndIf
Else
SetLog("Error reading Castle size")
Return
EndIf
If ($CommandStop = 3 Or $CommandStop = 0) And $fullarmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $FirstStart Then
$FirstStart = False
CheckExistentArmy("Troops")
CheckExistentArmy("Spells")
CountNumberDarkSpells()
EndIf
Return
EndIf
If $Runstate = False Then Return
Setlog("Army Camp: " & $aGetArmySize[0] & "/" & $aGetArmySize[1], $COLOR_GREEN)
If $aGetSpellsSize[0] <> "" And $aGetSpellsSize[1] <> "" Then Setlog("Spells :" & $aGetSpellsSize[0] & "/" & $aGetSpellsSize[1], $COLOR_GREEN)
If $aGetCastleSize[0] <> "" And $aGetCastleSize[1] <> "" Then Setlog("Clan Castle : " & $aGetCastleSize[0] & "/" & $aGetCastleSize[1], $COLOR_GREEN)
If IsWaitforHeroesActive() Or $iChkTrophyRange = 1 Or $ichkEnableSuperXP = 1 Then
getArmyHeroCount()
Else
$bFullArmyHero = True
EndIf
If $fullarmy And $checkSpells And $bFullArmyHero And $fullcastlespells And $fullcastletroops Then
$IsFullArmywithHeroesAndSpells = True
Else
$IsFullArmywithHeroesAndSpells = False
EndIf
Local $text = ""
If $fullarmy = False then
$text &= " Troops,"
EndIf
If $checkSpells = False then
$text &= " Spells,"
EndIf
If $bFullArmyHero = False then
$text &= " Heroes,"
EndIf
If $fullcastlespells = False then
$text &= " CC Spell,"
EndIf
If $fullcastletroops = False then
$text &= " CC Troops,"
EndIf
If $IsFullArmywithHeroesAndSpells = True Then
If (($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertCampFull = 1) Then PushMsg("CampFull")
Setlog("Chief, are your Army ready for battle? Yes, they are!", $COLOR_GREEN)
Else
Setlog("Chief, are your Army ready for battle? No, Not yet!", $COLOR_ACTION)
If $text <> "" then Setlog(" Â»" & $text & " not Ready!", $COLOR_ACTION)
EndIf
If UBound($aGetArmySize) > 1 Then
If $Runstate = False Then Return
If ($IsFullArmywithHeroesAndSpells = True) Or ($aGetArmySize[0] = 0 And $FirstStart) Then
If $IsFullArmywithHeroesAndSpells Then Setlog(" Â» Your Army is Full, let's make troops before Attack!", $COLOR_BLUE)
If ($aGetArmySize[0] = 0 And $FirstStart) Then
Setlog(" Â» Your Army is Empty, let's make troops before Attack!", $COLOR_ACTION1)
Setlog(" Â» Go to TrainRevamp Tab and select your Quick Army position!", $COLOR_ACTION1)
EndIf
DeleteTroopsQueued()
If _Sleep(500) Then Return
DeleteSpellsQueued()
If _Sleep(250) Then Return
OpenTrainTabNumber($QuickTrainTAB)
If _Sleep(1000) Then Return
Local $Num = 0
If GUICtrlRead($hRadio_Army1) = $GUI_CHECKED Then $Num = 1
If GUICtrlRead($hRadio_Army2) = $GUI_CHECKED Then $Num = 2
If GUICtrlRead($hRadio_Army3) = $GUI_CHECKED Then $Num = 3
TrainArmyNumber($Num)
ResetVariables("donated")
If _Sleep(700) Then Return
$FirstStart = False
Else
If $Runstate = False Then Return
If $aGetArmySize[0] > 0 And $FirstStart Then SetLog("Please Start with army camp Empty or Full!", $COLOR_RED)
$timer = TimerInit()
If $debugsetlogTrain = 1 Then $debugOcr = 1
Local $TimeRemainTroops = getRemainTrainTimer(756, 169)
Local $ResultTroopsHour, $ResultTroopsMinutes, $ResultTroopsSeconds
Local $aRemainTrainTroopTimer = 0
$aTimeTrain[0] = 0
If $TimeRemainTroops <> "" Then
If StringInStr($TimeRemainTroops, "h") > 1 Then
$ResultTroopsHour = StringSplit($TimeRemainTroops, "h", $STR_NOCOUNT)
$ResultTroopsMinutes = StringTrimRight($ResultTroopsHour[1], 1)
$aRemainTrainTroopTimer = (Number($ResultTroopsHour[0]) * 60) + Number($ResultTroopsMinutes)
ElseIf StringInStr($TimeRemainTroops, "m") > 1 Then
$ResultTroopsMinutes = StringSplit($TimeRemainTroops, "m", $STR_NOCOUNT)
$aRemainTrainTroopTimer = $ResultTroopsMinutes[0] + Ceiling($ResultTroopsMinutes[1] / 60)
Else
$ResultTroopsSeconds = StringTrimRight($TimeRemainTroops, 1)
$aRemainTrainTroopTimer = Ceiling($ResultTroopsSeconds / 60)
EndIf
$aTimeTrain[0] = $aRemainTrainTroopTimer
Setlog("Remain Troops Time: " & $aRemainTrainTroopTimer & " min", $COLOR_GREEN)
EndIf
CheckExistentArmy("Troops")
CheckExistentArmy("Spells")
CountNumberDarkSpells()
If IsWaitforSpellsActive() Then
Local $TimeRemainSpells = getRemainTrainTimer(495, 315)
$ResultTroopsHour = 0
$ResultTroopsMinutes = 0
$ResultTroopsSeconds = 0
$aTimeTrain[1] = 0
Local $iRemainTrainSpellsTimer = 0
If $TimeRemainSpells <> "" Then
If StringInStr($TimeRemainSpells, "h") > 1 Then
$ResultTroopsHour = StringSplit($TimeRemainSpells, "h", $STR_NOCOUNT)
$ResultTroopsMinutes = StringTrimRight($ResultTroopsHour[1], 1)
$iRemainTrainSpellsTimer = (Number($ResultTroopsHour[0]) * 60) + Number($ResultTroopsMinutes)
ElseIf StringInStr($TimeRemainSpells, "m") > 1 Then
$ResultTroopsMinutes = StringSplit($TimeRemainSpells, "m", $STR_NOCOUNT)
$iRemainTrainSpellsTimer = $ResultTroopsMinutes[0] + Ceiling($ResultTroopsMinutes[1] / 60)
Else
$ResultTroopsSeconds = StringTrimRight($TimeRemainSpells, 1)
$iRemainTrainSpellsTimer = Ceiling($ResultTroopsSeconds / 60)
EndIf
$aTimeTrain[1] = $iRemainTrainSpellsTimer
Setlog("Remain Spells Time: " & $iRemainTrainSpellsTimer & " min", $COLOR_GREEN)
EndIf
EndIf
If _Sleep(100) Then Return
If $debugsetlogTrain = 1 Then $debugOcr = 0
If $bDonationEnabled = True Then MakingDonatedTroops()
CheckIsFullQueuedAndNotFullArmy()
If $Runstate = False Then Return
CheckIsEmptyQueuedAndNotFullArmy()
If $Runstate = False Then Return
$FirstStart = False
EndIf
Else
SetLog("Error! OCR read army trained and total ", $COLOR_RED)
EndIf
ClickP($aAway, 2, 0, "#0346")
If _Sleep(1000) Then Return
SetLog(" Â»Â» Army Window Closed!", $COLOR_ACTION1)
VillageReport(True, True)
$tempCounter = 0
While ($iElixirCurrent = "" Or ($iDarkCurrent = "" And $iDarkStart <> "")) And $tempCounter < 30
$tempCounter += 1
If _Sleep($iDelayTrain1) Then Return
VillageReport(True, True)
WEnd
If $tempElixir <> "" And $iElixirCurrent <> "" Then
$tempElixirSpent = ($tempElixir - $iElixirCurrent)
$iTrainCostElixir += $tempElixirSpent
$iElixirTotal -= $tempElixirSpent
EndIf
If $tempDElixir <> "" And $iDarkCurrent <> "" Then
$tempDElixirSpent = ($tempDElixir - $iDarkCurrent)
$iTrainCostDElixir += $tempDElixirSpent
$iDarkTotal -= $tempDElixirSpent
EndIf
If $Runstate = False Then Return
UpdateStats()
checkAttackDisable($iTaBChkIdle)
EndFunc
Func TestTrainRevampOldStyle()
If $debugsetlogTrain = 1 Then Setlog(" Â» Initial Custom train Function")
Local $tempElixir = ""
Local $tempDElixir = ""
Local $tempElixirSpent = 0
Local $tempDElixirSpent = 0
VillageReport(True, True)
$tempCounter = 0
While ($iElixirCurrent = "" Or ($iDarkCurrent = "" And $iDarkStart <> "")) And $tempCounter < 5
$tempCounter += 1
If _Sleep(100) Then Return
VillageReport(True, True)
WEnd
$tempElixir = $iElixirCurrent
$tempDElixir = $iDarkCurrent
Setlog(" Â»Â» Army Window!", $COLOR_BLUE)
If OpenArmyWindow() = False then return
If $Runstate = False Then Return
$fullarmy = False
$bFullArmySpells = False
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
IsFullArmy(True)
If $Runstate = False Then Return
IsFullSpells(True)
Local $fullcastlespells = IsFullCastleSpells()
If $Runstate = False Then Return
Local $fullcastletroops = IsFullCastleTroops()
Local $checkSpells = checkspells()
If ($CommandStop = 3 Or $CommandStop = 0) And $fullarmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $FirstStart Then $FirstStart = False
Return
EndIf
If IsWaitforHeroesActive() Or $iChkTrophyRange = 1 Or $ichkEnableSuperXP = 1 Then
getArmyHeroCount()
Else
$bFullArmyHero = True
EndIf
If $Runstate = False Then Return
If $fullarmy And $checkSpells And $bFullArmyHero And $fullcastlespells And $fullcastletroops Then
$IsFullArmywithHeroesAndSpells = True
$FirstStart = False
Else
$IsFullArmywithHeroesAndSpells = False
EndIf
Local $text = ""
If $fullarmy = False then
$text &= " Troops,"
EndIf
If $checkSpells = False then
$text &= " Spells,"
EndIf
If $bFullArmyHero = False then
$text &= " Heroes,"
EndIf
If $fullcastlespells = False then
$text &= " CC Spell,"
EndIf
If $fullcastletroops = False then
$text &= " CC Troops,"
EndIf
If $IsFullArmywithHeroesAndSpells = True Then
If (($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertCampFull = 1) Then PushMsg("CampFull")
Setlog("Chief, are your Army ready for battle? Yes, they are!", $COLOR_GREEN)
Else
Setlog("Chief, are your Army ready for battle? No, Not yet!", $COLOR_ACTION)
If $text <> "" then Setlog(" Â»" & $text & " not Ready!", $COLOR_ACTION)
EndIf
Local $rWhatToTrain = WhatToTrain(True)
Local $rRemoveExtraTroops = RemoveExtraTroops($rWhatToTrain)
If $rRemoveExtraTroops = 1 Or $rRemoveExtraTroops = 2 Then
$fullarmy = False
$bFullArmySpells = False
IsFullArmy()
IsFullSpells()
$fullcastlespells = IsFullCastleSpells()
$fullcastletroops = IsFullCastleTroops()
$checkSpells = checkspells()
If ($CommandStop = 3 Or $CommandStop = 0) And $fullarmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $FirstStart Then $FirstStart = False
Return
EndIf
If IsWaitforHeroesActive() Then
getArmyHeroCount()
Else
$bFullArmyHero = True
EndIf
If $fullarmy And $checkSpells And $bFullArmyHero And $fullcastlespells And $fullcastletroops Then
$IsFullArmywithHeroesAndSpells = True
Else
$IsFullArmywithHeroesAndSpells = False
EndIf
EndIf
If $Runstate = False Then Return
If $rRemoveExtraTroops = 2 Then
$rWhatToTrain = WhatToTrain(False, False)
OpenTrainTabNumber($TrainTroopsTAB)
TrainUsingWhatToTrain($rWhatToTrain)
EndIf
If IsQueueEmpty($TrainTroopsTAB) = True Then
If $Runstate = False Then Return
OpenTrainTabNumber($ArmyTAB)
$rWhatToTrain = WhatToTrain(False, False)
OpenTrainTabNumber($TrainTroopsTAB)
TrainUsingWhatToTrain($rWhatToTrain)
Else
If $Runstate = False Then Return
OpenTrainTabNumber($ArmyTAB)
Local $TimeRemainTroops = getRemainTrainTimer(756, 169)
Local $ResultTroopsHour, $ResultTroopsMinutes, $ResultTroopsSeconds
Local $aRemainTrainTroopTimer = 0
$aTimeTrain[0] = 0
If $TimeRemainTroops <> "" Then
If StringInStr($TimeRemainTroops, "h") > 1 Then
$ResultTroopsHour = StringSplit($TimeRemainTroops, "h", $STR_NOCOUNT)
$ResultTroopsMinutes = StringTrimRight($ResultTroopsHour[1], 1)
$aRemainTrainTroopTimer = (Number($ResultTroopsHour[0]) * 60) + Number($ResultTroopsMinutes)
ElseIf StringInStr($TimeRemainTroops, "m") > 1 Then
$ResultTroopsMinutes = StringSplit($TimeRemainTroops, "m", $STR_NOCOUNT)
$aRemainTrainTroopTimer = $ResultTroopsMinutes[0] + Ceiling($ResultTroopsMinutes[1] / 60)
Else
$ResultTroopsSeconds = StringTrimRight($TimeRemainTroops, 1)
$aRemainTrainTroopTimer = Ceiling($ResultTroopsSeconds / 60)
EndIf
$aTimeTrain[0] = $aRemainTrainTroopTimer
Setlog("Remaining Troops Train Time: " & $aRemainTrainTroopTimer & " min", $COLOR_GREEN)
EndIf
EndIf
$rWhatToTrain = WhatToTrain(False, False)
If DoWhatToTrainContainSpell($rWhatToTrain) Then
If IsQueueEmpty($BrewSpellsTAB) = True Then
TrainUsingWhatToTrain($rWhatToTrain, True)
Else
OpenTrainTabNumber($ArmyTAB)
Local $TimeRemainTroops = getRemainTrainTimer(500, 315)
Local $ResultTroopsHour, $ResultTroopsMinutes, $ResultTroopsSeconds
Local $aRemainTrainTroopTimer = 0
$aTimeTrain[0] = 0
If $TimeRemainTroops <> "" Then
If StringInStr($TimeRemainTroops, "h") > 1 Then
$ResultTroopsHour = StringSplit($TimeRemainTroops, "h", $STR_NOCOUNT)
$ResultTroopsMinutes = StringTrimRight($ResultTroopsHour[1], 1)
$aRemainTrainTroopTimer = (Number($ResultTroopsHour[0]) * 60) + Number($ResultTroopsMinutes)
ElseIf StringInStr($TimeRemainTroops, "m") > 1 Then
$ResultTroopsMinutes = StringSplit($TimeRemainTroops, "m", $STR_NOCOUNT)
$aRemainTrainTroopTimer = $ResultTroopsMinutes[0] + Ceiling($ResultTroopsMinutes[1] / 60)
Else
$ResultTroopsSeconds = StringTrimRight($TimeRemainTroops, 1)
$aRemainTrainTroopTimer = Ceiling($ResultTroopsSeconds / 60)
EndIf
$aTimeTrain[0] = $aRemainTrainTroopTimer
Setlog("Remaining Spells Brew Time: " & $aRemainTrainTroopTimer & " min", $COLOR_GREEN)
EndIf
EndIf
EndIf
If _Sleep(250) Then Return
If $Runstate = False Then Return
ClickP($aAway, 2, 0, "#0346")
If _Sleep(250) Then Return
VillageReport(True, True)
$tempCounter = 0
While ($iElixirCurrent = "" Or ($iDarkCurrent = "" And $iDarkStart <> "")) And $tempCounter < 30
$tempCounter += 1
If _Sleep($iDelayTrain1) Then Return
VillageReport(True, True)
WEnd
If $tempElixir <> "" And $iElixirCurrent <> "" Then
$tempElixirSpent = ($tempElixir - $iElixirCurrent)
$iTrainCostElixir += $tempElixirSpent
$iElixirTotal -= $tempElixirSpent
EndIf
If $tempDElixir <> "" And $iDarkCurrent <> "" Then
$tempDElixirSpent = ($tempDElixir - $iDarkCurrent)
$iTrainCostDElixir += $tempDElixirSpent
$iDarkTotal -= $tempDElixirSpent
EndIf
If $Runstate = False Then Return
UpdateStats()
checkAttackDisable($iTaBChkIdle)
EndFunc
Func IsFullArmy($log = False)
If ISArmyWindow(False, $ArmyTAB) = False Then OpenTrainTabNumber($ArmyTAB)
If $Runstate = False Then Return
Local Const $rColorCheck = _ColorCheck(_GetPixelColor(28, 176, True), Hex(0xFFFFFF, 6), 20) And _ColorCheck(_GetPixelColor(24, 168, True), Hex(0x92C232, 6), 20)
If $rColorCheck = True Then $fullarmy = True
Local $sArmyCamp = getArmyCampCap(110, 166)
Local $aGetArmySize = StringSplit($sArmyCamp, "#", $STR_NOCOUNT)
If UBound($aGetArmySize) >= 2 Then
If $log Then SetLog("Troops: " & $aGetArmySize[0] & "/" & $aGetArmySize[1], $COLOR_GREEN)
$fullarmy = False
$CurCamp = 0
If $ichkTotalCampForced = 0 Then
$CurCamp = $aGetArmySize[0]
$TotalCamp = $aGetArmySize[1]
Else
$CurCamp = $aGetArmySize[0]
$TotalCamp = Number($iValueTotalCampForced)
EndIf
Local $thePercent = Number(($CurCamp / $TotalCamp) * 100, 1)
If $thePercent >= $fulltroop Then $fullarmy = True
EndIf
Return $fullarmy
EndFunc
Func IsFullSpells($log = False)
If ISArmyWindow(False, $ArmyTAB) = False Then OpenTrainTabNumber($ArmyTAB)
If $Runstate = False Then Return
Local $sSpells = getArmyCampCap(99, 313)
Local $aGetSpellsSize = StringSplit($sSpells, "#", $STR_NOCOUNT)
$bFullArmySpells = False
If UBound($aGetSpellsSize) = 2 Then
If $log Then SetLog("Spells: " & $aGetSpellsSize[0] & "/" & $aGetSpellsSize[1], $COLOR_GREEN)
If $aGetSpellsSize[0] = $aGetSpellsSize[1] Or $aGetSpellsSize[0] >= $iTotalCountSpell Or $aGetSpellsSize[0] >= TotalSpellsToBrewInGUI() Then
$bFullArmySpells = True
Return True
EndIf
Else
SetLog("Error reading Spells size")
Return
EndIf
If $aGetSpellsSize[0] = $iTotalCountSpell Then
$bFullArmySpells = True
Return True
EndIf
Return $bFullArmySpells
EndFunc
Func checkspells()
Local $ToReturn = False
If $Runstate = False Then Return
If ($iEnableSpellsWait[$DB] = 0 And $iEnableSpellsWait[$LB] = 0) Or ($bFullArmySpells And ($iEnableSpellsWait[$DB] = 1 Or $iEnableSpellsWait[$LB] = 1)) Then
$ToReturn = True
Return $ToReturn
EndIf
$ToReturn = (IIf($iDBcheck = 1, IIf($iEnableSpellsWait[$DB] = 1, $bFullArmySpells, True), 1) And IIf($iABcheck = 1, IIf($iEnableSpellsWait[$LB] = 1, $bFullArmySpells, True), 1))
Return $ToReturn
EndFunc
Func IsFullCastleSpells($returnOnly = False)
Local $ToReturn = False
If $Runstate = False Then Return
If $iChkWaitForCastleSpell[$DB] = 0 And $iChkWaitForCastleSpell[$LB] = 0 Then
$ToReturn = True
If $returnOnly = False Then
Return $ToReturn
Else
Return ""
EndIf
EndIf
Local Const $rColCheck = _ColorCheck(_GetPixelColor(512, 470, True), Hex(0x93C230, 6), 30)
Local $rColCheckFullCCTroops = False
$ToReturn = (IIf($iDBcheck = 1, IIf($iChkWaitForCastleSpell[$DB] = 1, $rColCheck, True), 1) And IIf($iABcheck = 1, IIf($iChkWaitForCastleSpell[$LB] = 1, $rColCheck, True), 1))
If $ToReturn = True Then
$CurCCSpell = GetCurCCSpell()
If $CurCCSpell = "" Then
If $returnOnly = False Then SetLog("Failed to get current available spell in clan castle", $COLOR_RED)
$ToReturn = False
If $returnOnly = False Then
Return $ToReturn
Else
Return ""
EndIf
EndIf
Local $bShouldRemove
$bShouldRemove = Not CompareCCSpellWithGUI($CurCCSpell)
If $bShouldRemove = True Then
SetLog("Removing Useless Spell from Clan Castle", $COLOR_BLUE)
RemoveCastleSpell()
If _Sleep(1000) Then Return
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
If $canRequestCC = True Then
$rColCheckFullCCTroops = _ColorCheck(_GetPixelColor(24, 470, True), Hex(0x93C230, 6), 30)
If $rColCheckFullCCTroops = True Then SetLog("Castle spell is empty, Requesting for...")
If $returnOnly = False Then
RequestCC(False, IIf($rColCheckFullCCTroops = True Or ($iChkWaitForCastleTroops[$DB] = 0 And $iChkWaitForCastleTroops[$LB] = 0), IIf($iChkWaitForCastleSpell[$LB] = 1, IIf(String(GUICtrlRead($cmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($cmbABWaitForCastleSpell) & " Spell")), IIf($iChkWaitForCastleSpell[$DB] = 1, IIf(String(GUICtrlRead($cmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($cmbDBWaitForCastleSpell) & " Spell")), "")), ""))
Else
$ToReturn = IIf($rColCheckFullCCTroops = True Or ($iChkWaitForCastleTroops[$DB] = 0 And $iChkWaitForCastleTroops[$LB] = 0), IIf($iChkWaitForCastleSpell[$LB] = 1, IIf(String(GUICtrlRead($cmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($cmbABWaitForCastleSpell) & " Spell")), IIf($iChkWaitForCastleSpell[$DB] = 1, IIf(String(GUICtrlRead($cmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($cmbDBWaitForCastleSpell) & " Spell")), "")), "")
Return $ToReturn
EndIf
EndIf
$ToReturn = False
EndIf
Else
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
If $canRequestCC = True Then
$rColCheckFullCCTroops = _ColorCheck(_GetPixelColor(24, 470, True), Hex(0x93C230, 6), 30)
If $rColCheckFullCCTroops = True Then SetLog("Castle spell is empty, Requesting for...")
If $returnOnly = False Then
RequestCC(False, IIf($rColCheckFullCCTroops = True Or ($iChkWaitForCastleTroops[$DB] = 0 And $iChkWaitForCastleTroops[$LB] = 0), IIf($iChkWaitForCastleSpell[$LB] = 1, IIf(String(GUICtrlRead($cmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($cmbABWaitForCastleSpell) & " Spell")), IIf($iChkWaitForCastleSpell[$DB] = 1, IIf(String(GUICtrlRead($cmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($cmbDBWaitForCastleSpell) & " Spell")), "")), ""))
Else
$ToReturn = IIf($rColCheckFullCCTroops = True Or ($iChkWaitForCastleTroops[$DB] = 0 And $iChkWaitForCastleTroops[$LB] = 0), IIf($iChkWaitForCastleSpell[$LB] = 1, IIf(String(GUICtrlRead($cmbABWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($cmbABWaitForCastleSpell) & " Spell")), IIf($iChkWaitForCastleSpell[$DB] = 1, IIf(String(GUICtrlRead($cmbDBWaitForCastleSpell)) = "Any", "", String(GUICtrlRead($cmbDBWaitForCastleSpell) & " Spell")), "")), "")
Return $ToReturn
EndIf
EndIf
EndIf
If $returnOnly = False Then
Return $ToReturn
Else
Return ""
EndIf
EndFunc
Func RemoveCastleSpell()
If _ColorCheck(_GetPixelColor(675, 482, True), Hex(0xFFFFFF, 6), 30) = False Then
SetLog("Cannot find/verify 'Edit Army' Button in Army tab", $COLOR_ORANGE)
Return False
EndIf
Click(Random(680, 775, 1), Random(470, 515, 1))
If $Runstate = False Then Return
If _Sleep(500) Then Return
Local $pos[2] = [575, 575]
ClickRemoveTroop($pos, 1, $isldTrainITDelay)
If _Sleep(400) Then Return
If _ColorCheck(_GetPixelColor(815, 520, True), Hex(0x68B020, 6), 30) = False Then
SetLog("Cannot find/verify 'Okay' Button in Army tab", $COLOR_ORANGE)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(400) Then OpenArmyWindow()
Return False
EndIf
If _Sleep(700) Then Return
Click(Random(730, 830, 1), Random(495, 525, 1))
If _Sleep(700) Then Return
If _ColorCheck(_GetPixelColor(508, 428, True), Hex(0xFFFFFF, 6), 30) = False Then
SetLog("Cannot find/verify 'Okay #2' Button in Army tab", $COLOR_ORANGE)
ClickP($aAway, 2, 0, "#0346")
Return False
EndIf
Click(Random(445, 585, 1), Random(400, 455, 1))
SetLog("Castle Sell Removed", $COLOR_GREEN)
If _Sleep(200) Then Return
Return True
EndFunc
Func CompareCCSpellWithGUI($CS)
Local $SpellsInGUI[2] = [GUICtrlRead($cmbDBWaitForCastleSpell), GUICtrlRead($cmbABWaitForCastleSpell)]
$dbCSPellWait = IIf($iDBcheck = 1, IIf($iChkWaitForCastleSpell[$DB] = 1, $SpellsInGUI[0] = "Any", True), True)
$lbCSPellWait = IIf($iABcheck = 1, IIf($iChkWaitForCastleSpell[$LB] = 1, $SpellsInGUI[1] = "Any", True), True)
If $dbCSPellWait = True And $lbCSPellWait = True Then Return True
If $Runstate = False Then Return
Switch $SpellsInGUI[0]
Case "Poison"
$SpellsInGUI[0] = "PSpell"
Case "EarthQuake"
$SpellsInGUI[0] = "ESpell"
Case "Haste"
$SpellsInGUI[0] = "HaSpell"
Case "Skeleton"
$SpellsInGUI[0] = "SkSpell"
EndSwitch
Switch $SpellsInGUI[1]
Case "Poison"
$SpellsInGUI[1] = "PSpell"
Case "EarthQuake"
$SpellsInGUI[1] = "ESpell"
Case "Haste"
$SpellsInGUI[1] = "HaSpell"
Case "Skeleton"
$SpellsInGUI[1] = "SkSpell"
EndSwitch
Return ((IIf($iDBcheck = 1, IIf($iChkWaitForCastleSpell[$DB] = 1, $CS = $SpellsInGUI[0], False), False)) Or (IIf($iABcheck = 1, IIf($iChkWaitForCastleSpell[$LB] = 1, $CS = $SpellsInGUI[1], False), False)))
EndFunc
Func GetCurCCSpell()
If $Runstate = False Then Return
Local $directory = @ScriptDir & "\images\Resources\ArmyDarkSpells"
Local $res = SearchArmy($directory, 508, 493, 587, 592, "", True)
If ValidateSearchArmyResult($res) Then
Return $res[0][0]
EndIf
Return ""
EndFunc
Func IsFullCastleTroops()
Local $ToReturn = False
If $Runstate = False Then Return
If $iChkWaitForCastleTroops[$DB] = 0 And $iChkWaitForCastleTroops[$LB] = 0 Then
$ToReturn = True
Return $ToReturn
EndIf
Local Const $rColCheck = _ColorCheck(_GetPixelColor(24, 470, True), Hex(0x93C230, 6), 30)
$ToReturn = (IIf($iDBcheck = 1, IIf($iChkWaitForCastleTroops[$DB] = 1, $rColCheck, True), 1) And IIf($iABcheck = 1, IIf($iChkWaitForCastleTroops[$LB] = 1, $rColCheck, True), 1))
Return $ToReturn
EndFunc
Func TrainUsingWhatToTrain($rWTT, $SpellsOnly = False)
If $Runstate = False Then Return
If $SpellsOnly = False Then
If ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB)
Else
If ISArmyWindow(False, $BrewSpellsTAB) = False Then OpenTrainTabNumber($BrewSpellsTAB)
EndIf
Select
Case $IsFullArmywithHeroesAndSpells = False
For $i = 0 To (UBound($rWTT) - 1)
If $Runstate = False Then Return
If $rWTT[$i][1] > 0 Then
If IsSpellToBrew($rWTT[$i][0]) Then
BrewUsingWhatToTrain($rWTT[$i][0], $rWTT[$i][1])
ContinueLoop
Else
If $SpellsOnly = True Then ContinueLoop
EndIf
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $rWTT[$i][1])
$LeftSpace = LeftSpace()
If $NeededSpace <= $LeftSpace Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
SetLog("Training " & $rWTT[$i][1] & "x " & NameOfTroop(Eval("e" & $rWTT[$i][0]), IIf($rWTT[$i][1] > 1, 1, 0)), $COLOR_GREEN)
TrainIt(Eval("e" & $rWTT[$i][0]), $rWTT[$i][1], $isldTrainITDelay)
Else
$CountToTrain = 0
$CanAdd = True
Do
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $CountToTrain)
If $NeededSpace <= $LeftSpace Then
$CountToTrain += 1
Else
$CanAdd = False
EndIf
Until $CanAdd = False
If $CountToTrain > 0 Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
EndIf
SetLog("Training " & $CountToTrain & "x " & NameOfTroop(Eval("e" & $rWTT[$i][0]), IIf($CountToTrain > 1, 1, 0)), $COLOR_GREEN)
TrainIt(Eval("e" & $rWTT[$i][0]), $CountToTrain, $isldTrainITDelay)
EndIf
EndIf
Next
Case $IsFullArmywithHeroesAndSpells = True
For $i = 0 To (UBound($rWTT) - 1)
If $Runstate = False Then Return
If $rWTT[$i][1] > 0 Then
If IsSpellToBrew($rWTT[$i][0]) Then
BrewUsingWhatToTrain($rWTT[$i][0], $rWTT[$i][1])
ContinueLoop
Else
If $SpellsOnly = True Then ContinueLoop
EndIf
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $rWTT[$i][1])
$LeftSpace = LeftSpace(True)
$LeftSpace = ($LeftSpace[1] * 2) - $LeftSpace[0]
If $NeededSpace <= $LeftSpace Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
SetLog("Training " & $rWTT[$i][1] & "x " & NameOfTroop(Eval("e" & $rWTT[$i][0]), IIf($rWTT[$i][1] > 1, 1, 0)), $COLOR_GREEN)
TrainIt(Eval("e" & $rWTT[$i][0]), $rWTT[$i][1], $isldTrainITDelay)
Else
$CountToTrain = 0
$CanAdd = True
Do
$NeededSpace = CalcNeededSpace($rWTT[$i][0], $CountToTrain)
If $NeededSpace <= $LeftSpace Then
$CountToTrain += 1
Else
$CanAdd = False
EndIf
Until $CanAdd = False
If $CountToTrain > 0 Then
If DragIfNeeded($rWTT[$i][0]) = False Then
Return False
EndIf
EndIf
SetLog("Training " & $CountToTrain & "x " & NameOfTroop(Eval("e" & $rWTT[$i][0]), IIf($CountToTrain > 1, 1, 0)), $COLOR_GREEN)
TrainIt(Eval("e" & $rWTT[$i][0]), $CountToTrain, $isldTrainITDelay)
EndIf
EndIf
Next
EndSelect
Return True
EndFunc
Func BrewUsingWhatToTrain($Spell, $Quantity)
If $Quantity <= 0 Then Return False
If $Quantity = 9999 Then
SetLog("Brewing " & NameOfTroop(Eval("e" & $Spell)) & " Cancelled, " & @CRLF &  "Because you have enough as you set In GUI And This Spell will not be used in Attack")
Return True
EndIf
If $Runstate = False Then Return
If ISArmyWindow(False, $BrewSpellsTAB) = False Then OpenTrainTabNumber($BrewSpellsTAB)
Select
Case $IsFullArmywithHeroesAndSpells = False
If _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 30) = False Then RemoveExtraTroopsQueue()
$NeededSpace = CalcNeededSpace($Spell, $Quantity)
$LeftSpace = LeftSpace()
If $NeededSpace <= $LeftSpace Then
SetLog("Brewing " & $Quantity & "x " & NameOfTroop(Eval("e" & $Spell), IIf($Quantity > 1, 1, 0)), $COLOR_GREEN)
TrainIt(Eval("e" & $Spell), $Quantity, $isldTrainITDelay)
EndIf
Case $IsFullArmywithHeroesAndSpells = True
$NeededSpace = CalcNeededSpace($Spell, $Quantity)
$LeftSpace = LeftSpace(True)
$LeftSpace = ($LeftSpace[1] * 2) - $LeftSpace[0]
If $NeededSpace <= $LeftSpace Then
SetLog("Brewing " & $Quantity & "x " & NameOfTroop(Eval("e" & $Spell), IIf($Quantity > 1, 1, 0)), $COLOR_GREEN)
TrainIt(Eval("e" & $Spell), $Quantity, $isldTrainITDelay)
EndIf
EndSelect
EndFunc
Func TotalSpellsToBrewInGUI()
Local $ToReturn = 0
If $iTotalCountSpell = 0 Then Return $ToReturn
If $Runstate = False Then Return
For $i = 0 To (UBound($SpellName) - 1)
$ToReturn += Number(Number(Eval($SpellName[$i] & "Comp") * $SpellHeight[$i]))
Next
Return $ToReturn
EndFunc
Func HowManyTimesWillBeUsed($Spell)
Local $ToReturn = -1
If $Runstate = False Then Return
If $ichkForceBrewBeforeAttack = 1 Then
$ToReturn = 2
Return $ToReturn
EndIf
If $iDBcheck = 1 Then
If $iAtkAlgorithm[$DB] = 1 Then
If IsGUICheckedForSpell($Spell, $DB) Then
$ToReturn = CountCommandsForSpell($Spell, $DB)
If $ToReturn = 0 Then $ToReturn = -1
Else
$ToReturn = -1
EndIf
Else
$ToReturn = -1
EndIf
EndIf
If $iABcheck = 1 Then
If $iAtkAlgorithm[$LB] = 1 Then
If IsGUICheckedForSpell($Spell, $LB) Then
$ToReturn = CountCommandsForSpell($Spell, $LB)
If $ToReturn = 0 Then $ToReturn = -1
EndIf
EndIf
EndIf
Return $ToReturn
EndFunc
Func CountCommandsForSpell($Spell, $Mode)
Local $ToReturn = 0
Local $filename = ""
If $Runstate = False Then Return
If $Mode = $DB Then
$filename = $scmbDBScriptName
Else
$filename = $scmbABScriptName
EndIf
Local $rownum = 0
If FileExists($dirAttacksCSV & "\" & $filename & ".csv") Then
Local $f, $line, $acommand, $command
Local $value1, $Troop
$f = FileOpen($dirAttacksCSV & "\" & $filename & ".csv", 0)
While 1
$line = FileReadLine($f)
$rownum += 1
If @error = -1 Then ExitLoop
$acommand = StringSplit($line, "|")
If $acommand[0] >= 8 Then
$command = StringStripWS(StringUpper($acommand[1]), 2)
$Troop = StringStripWS(StringUpper($acommand[5]), 2)
If $Troop = $Spell Then $ToReturn += 1
EndIf
WEnd
Else
$ToReturn = 0
EndIf
Return $ToReturn
EndFunc
Func IsGUICheckedForSpell($Spell, $Mode)
Local $sSpell = ""
If $Runstate = False Then Return
Switch Eval("e" & $Spell)
Case $eLSpell
$sSpell = "Light"
Case $eHSpell
$sSpell = "Heal"
Case $eRSpell
$sSpell = "Rage"
Case $eJSpell
$sSpell = "Jump"
Case $eFSpell
$sSpell = "Freeze"
Case $ePSpell
$sSpell = "Poison"
Case $eESpell
$sSpell = "Earthquake"
Case $eHaSpell
$sSpell = "Haste"
EndSwitch
$iVal = Execute("$ichk" & $sSpell & "Spell")
Return (($iVal[$Mode] = 1) ? True : False)
EndFunc
Func DragIfNeeded($Troop)
Local Const $pos = GetTrainPos(Eval("e" & $Troop))
If $Runstate = False Then Return
If IsDarkTroop($Troop) Then
Local $rCheckPixel = _CheckPixel($pos, $bCapturePixel)
For $i = 1 To 4
If $rCheckPixel = False Then
ClickDrag(616, 445 + $midOffsetY, 400, 445 + $midOffsetY, 2000)
If _Sleep(1500) Then Return
$rCheckPixel = _CheckPixel($pos, $bCapturePixel)
Else
Return True
EndIf
Next
SetLog("Failed to Verify Troop " & NameOfTroop(Eval("e" & $Troop)) & " Position or Failed to Drag Successfully", $COLOR_RED)
Return False
Else
Local $rCheckPixel = _CheckPixel($pos, $bCapturePixel)
For $i = 1 To 4
If $rCheckPixel = False Then
ClickDrag(400, 445 + $midOffsetY, 616, 445 + $midOffsetY, 2000)
If _Sleep(1500) Then Return
$rCheckPixel = _CheckPixel($pos, $bCapturePixel)
Else
Return True
EndIf
Next
SetLog("Failed to Verify Troop " & NameOfTroop(Eval("e" & $Troop)) & " Position or Failed to Drag Successfully", $COLOR_RED)
Return False
EndIf
EndFunc
Func DoWhatToTrainContainSpell($rWTT)
For $i = 0 To (UBound($rWTT) - 1)
If $Runstate = False Then Return
If IsSpellToBrew($rWTT[$i][0]) Then
If $rWTT[$i][1] > 0 Then Return True
EndIf
Next
Return False
EndFunc
Func IsElixirTroop($Troop)
For $i = 0 To (UBound($TroopName) - 1)
If $Runstate = False Then Return
If $Troop = $TroopName[$i] Then Return True
Next
Return False
EndFunc
Func IsDarkTroop($Troop)
For $i = 0 To (UBound($TroopDarkName) - 1)
If $Runstate = False Then Return
If $Troop = $TroopDarkName[$i] Then Return True
Next
Return False
EndFunc
Func IsSpellToBrew($Spell)
For $i = 0 To (UBound($SpellName) - 1)
If $Runstate = False Then Return
If $Spell = $SpellName[$i] Then Return True
Next
Return False
EndFunc
Func CalcNeededSpace($Troop, $Quantity)
For $i = 0 To (UBound($MergedTroopGroup) - 1)
If $Runstate = False Then Return
If $Troop = $MergedTroopGroup[$i][0] Then
$THeight = $MergedTroopGroup[$i][2]
Return Number($THeight * $Quantity)
EndIf
Next
For $i = 0 To (UBound($SpellGroup) - 1)
If $Runstate = False Then Return
If $Troop = $SpellGroup[$i][0] Then
$THeight = $SpellGroup[$i][2]
Return Number($THeight * $Quantity)
EndIf
Next
Return -1
EndFunc
Func RemoveExtraTroops($toRemove)
Local $ToReturn = 0
If $IsFullArmywithHeroesAndSpells = True Or $fullarmy = True Or ($CommandStop = 3 Or $CommandStop = 0) = True Then
$ToReturn = 3
Return $ToReturn
EndIf
If UBound($toRemove) > 0 Then
Local $rGetSlotNumber = GetSlotNumber()
Local $rGetSlotNumberSpells = GetSlotNumber(True)
OpenTrainTabNumber($TrainTroopsTAB)
$CounterToRemove = 0
For $i = 0 To (UBound($toRemove) - 1)
If $Runstate = False Then Return
If IsSpellToBrew($toRemove[$i][0]) Then ExitLoop
$CounterToRemove += 1
If IsAlreadyTraining($toRemove[$i][0]) Then
SetLog(NameOfTroop(Eval("e" & $toRemove[$i][0])) & " Is in Train Tab Queue By Mistake!", $COLOR_BLUE)
DeleteTroopsQueued()
$ToReturn = 2
EndIf
Next
If TotalSpellsToBrewInGUI() > 0 Then
OpenTrainTabNumber($BrewSpellsTAB)
For $i = $CounterToRemove To (UBound($toRemove) - 1)
If $Runstate = False Then Return
If IsAlreadyTraining($toRemove[$i][0], True) Then
SetLog(NameOfTroop(Eval("e" & $toRemove[$i][0])) & " Is in Spells Tab Queue By Mistake!", $COLOR_BLUE)
DeleteSpellsQueued()
$ToReturn = 2
EndIf
Next
EndIf
OpenTrainTabNumber($ArmyTAB)
$toRemove = WhatToTrain(True, False)
$rGetSlotNumber = GetSlotNumber()
$rGetSlotNumberSpells = GetSlotNumber(True)
SetLog("Troops To Remove: ", $COLOR_GREEN)
$CounterToRemove = 0
For $i = 0 To (UBound($toRemove) - 1)
If IsSpellToBrew($toRemove[$i][0]) Then ExitLoop
$CounterToRemove += 1
SetLog("  " & NameOfTroop(Eval("e" & $toRemove[$i][0])) & ": " & $toRemove[$i][1] & "x", $COLOR_GREEN)
Next
If TotalSpellsToBrewInGUI() > 0 Then
If $CounterToRemove <= UBound($toRemove) Then
SetLog("Spells To Remove: ", $COLOR_GREEN)
For $i = $CounterToRemove To (UBound($toRemove) - 1)
SetLog("  " & NameOfTroop(Eval("e" & $toRemove[$i][0])) & ": " & $toRemove[$i][1] & "x", $COLOR_GREEN)
Next
EndIf
EndIf
If _ColorCheck(_GetPixelColor(675, 482, True), Hex(0xFFFFFF, 6), 30) = False Then
SetLog("Cannot find/verify 'Edit Army' Button in Army tab", $COLOR_ORANGE)
Return False
EndIf
Click(Random(680, 775, 1), Random(470, 515, 1))
$CounterToRemove = 0
For $j = 0 To (UBound($toRemove) - 1)
If IsSpellToBrew($toRemove[$j][0]) Then ExitLoop
$CounterToRemove += 1
For $i = 0 To (UBound($rGetSlotNumber) - 1)
If $toRemove[$j][0] = $rGetSlotNumber[$i] Then
$pos = GetSlotRemoveBtnPosition($i + 1)
ClickRemoveTroop($pos, $toRemove[$j][1], $isldTrainITDelay)
EndIf
Next
Next
If TotalSpellsToBrewInGUI() > 0 Then
For $j = $CounterToRemove To (UBound($toRemove) - 1)
For $i = 0 To (UBound($rGetSlotNumberSpells) - 1)
If $toRemove[$j][0] = $rGetSlotNumberSpells[$i] Then
$pos = GetSlotRemoveBtnPosition($i + 1, True)
ClickRemoveTroop($pos, $toRemove[$j][1], $isldTrainITDelay)
EndIf
Next
Next
EndIf
If _ColorCheck(_GetPixelColor(772, 510, True), Hex(0xFFFFFF, 6), 30) = False Then
SetLog("Cannot find/verify 'Okay' Button in Army tab", $COLOR_ORANGE)
ClickP($aAway, 2, 0, "#0346")
If _Sleep(400) Then OpenArmyWindow()
Return False
EndIf
If _Sleep(700) Then Return
If $Runstate = False Then Return
Click(Random(730, 830, 1), Random(495, 525, 1))
If _Sleep(700) Then Return
If _ColorCheck(_GetPixelColor(508, 428, True), Hex(0xFFFFFF, 6), 30) = False Then
SetLog("Cannot find/verify 'Okay #2' Button in Army tab", $COLOR_ORANGE)
ClickP($aAway, 2, 0, "#0346")
Return False
EndIf
Click(Random(445, 585, 1), Random(400, 455, 1))
SetLog("All Extra troops removed", $COLOR_GREEN)
If _Sleep(200) Then Return
If $ToReturn = 0 Then $ToReturn = 1
Else
SetLog("No extra troop to remove, Great", $COLOR_GREEN)
$ToReturn = 3
EndIf
Return $ToReturn
EndFunc
Func RemoveExtraTroopsQueue()
If $IsFullArmywithHeroesAndSpells = True Then Return True
Local Const $y = 187, $yRemoveBtn = 200, $xDecreaseRemoveBtn = 10
Local $rColCheck = ""
Local $Removed = False
For $x = 834 To 58 Step -70
If $Runstate = False Then Return
$rColCheck = _ColorCheck(_GetPixelColor($x, $y, True), Hex(0xD7AFA9, 6), 20)
If $rColCheck = True Then
Do
If _Sleep(20) Then Return
Click($x - $xDecreaseRemoveBtn, $yRemoveBtn, 2, $isldTrainITDelay)
$Removed = True
$rColCheck = _ColorCheck(_GetPixelColor($x, $y, True), Hex(0xD7AFA9, 6), 20)
Until $rColCheck = False
ElseIf $rColCheck = False And $Removed Then
ExitLoop
EndIf
Next
Return True
EndFunc
Func IsAlreadyTraining($Troop, $Spells = False)
If $Runstate = False Then Return
Select
Case $Spells = False
If IsQueueEmpty($TrainTroopsTAB) Then Return False
Local $QueueTroops = CheckQueueTroops(False, False)
For $i = 0 To (UBound($QueueTroops) - 1)
If $QueueTroops[$i] = $Troop Then Return True
Next
Return False
Case $Spells = True
If IsQueueEmpty($BrewSpellsTAB, False, IIf($ichkForceBrewBeforeAttack = 1, False, True)) Then Return False
Local $QueueSpells = CheckQueueSpells(False, False)
For $i = 0 To (UBound($QueueSpells) - 1)
If $QueueSpells[$i] = $Troop Then Return True
Next
Return False
EndSelect
EndFunc
Func IsQueueEmpty($Tab = -1, $bSkipTabCheck = False, $removeExtraTroopsQueue = True)
If $Runstate = False Then Return
If $bSkipTabCheck = False Then
If $Tab = -1 Then $Tab = $TrainTroopsTAB
If ISArmyWindow(False, $Tab) = False Then OpenTrainTabNumber($Tab)
EndIf
If $IsFullArmywithHeroesAndSpells = False Then
If $removeExtraTroopsQueue Then
If _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 30) = False Then RemoveExtraTroopsQueue()
EndIf
EndIf
If _ColorCheck(_GetPixelColor(230, 208, True), Hex(0x677CB5, 6), 30) Then Return True
Return False
EndFunc
Func ClickRemoveTroop($pos, $iTimes, $iSpeed)
$pos[0] = Random($pos[0] - 3, $pos[0] + 10, 1)
$pos[1] = Random($pos[1] - 5, $pos[1] + 5, 1)
If $Runstate = False Then Return
If _Sleep(400) Then Return
If $iTimes <> 1 Then
If FastCaptureRegion() = True Then
For $i = 0 To ($iTimes - 1)
PureClick($pos[0], $pos[1], 1, $iSpeed)
If _Sleep($iSpeed, False) Then ExitLoop
Next
Else
PureClick($pos[0], $pos[1], $iTimes, $iSpeed)
If _Sleep($iSpeed, False) Then Return
EndIf
Else
PureClick($pos[0], $pos[1], 1, $iSpeed)
If _Sleep($iSpeed, False) Then Return
EndIf
EndFunc
Func GetSlotRemoveBtnPosition($iSlot, $Spells = False)
Local Const $aResult[2] = [Number((74 * $iSlot) - 4), IIf($Spells = False, 270, 417)]
Return $aResult
EndFunc
Func GetSlotNumber($Spells = False)
Select
Case $Spells = False
Local Const $Orders[19] = [$eBarb, $eArch, $eGiant, $eGobl, $eWall, $eBall, $eWiza, $eHeal, $eDrag, $ePekk, $eBabyD, $eMine,  $eMini, $eHogs, $eValk, $eGole, $eWitc, $eLava, $eBowl]
Local $allCurTroops[UBound($Orders)]
For $i = 0 To (UBound($TroopName) - 1)
If $Runstate = False Then Return
If Number(Eval("Cur" & $TroopName[$i])) > 0 Then
For $j = 0 To (UBound($Orders) - 1)
If Eval("e" & $TroopName[$i]) = $Orders[$j] Then
$allCurTroops[$j] = $TroopName[$i]
EndIf
Next
EndIf
Next
_ArryRemoveBlanks($allCurTroops)
Return $allCurTroops
Case $Spells = True
Local Const $SpellsOrders[10] = [$eLSpell, $eHSpell, $eRSpell, $eJSpell, $eFSpell, $eCSpell, $ePSpell, $eESpell, $eHaSpell, $eSkSpell]
Local $allCurSpells[UBound($SpellsOrders)]
For $i = 0 To (UBound($SpellName) - 1)
If $Runstate = False Then Return
If Number(Eval("Cur" & $SpellName[$i])) > 0 Then
For $j = 0 To (UBound($SpellsOrders) - 1)
If Eval("e" & $SpellName[$i]) = $SpellsOrders[$j] Then
$allCurSpells[$j] = $SpellName[$i]
EndIf
Next
EndIf
Next
_ArryRemoveBlanks($allCurSpells)
Return $allCurSpells
EndSelect
EndFunc
Func WhatToTrain($ReturnExtraTroopsOnly = False, $showlog = True)
If ISArmyWindow(False, $ArmyTAB) = False Then OpenTrainTabNumber($ArmyTAB)
Local $ToReturn[1][2] = [["Arch", 0]]
If $IsFullArmywithHeroesAndSpells Then
If $CommandStop = 3 Or $CommandStop = 0 Then
If $FirstStart Then $FirstStart = False
Return $ToReturn
EndIf
Setlog(" Â» Your Army is Full, let's make troops before Attack!")
For $i = 0 To (UBound($TroopName) - 1)
If Number(Eval($TroopName[$i] & "Comp")) > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $TroopName[$i]
$ToReturn[UBound($ToReturn) - 1][1] = Number(Eval($TroopName[$i] & "Comp"))
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
For $i = 0 To (UBound($SpellName) - 1)
If $Runstate = False Then Return
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If Number(Eval($SpellName[$i] & "Comp")) > 0 Then
If HowManyTimesWillBeUsed($SpellName[$i]) > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $SpellName[$i]
$ToReturn[UBound($ToReturn) - 1][1] = Number(Eval($SpellName[$i] & "Comp"))
ReDim $ToReturn[UBound($ToReturn) + 1][2]
Else
CheckExistentArmy("Spells", False)
If Number(Number(Eval($SpellName[$i] & "Comp")) - Number(Eval("Cur" & $SpellName[$i]))) > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $SpellName[$i]
$ToReturn[UBound($ToReturn) - 1][1] = Number(Number(Eval($SpellName[$i] & "Comp")) - Number(Eval("Cur" & $SpellName[$i])))
ReDim $ToReturn[UBound($ToReturn) + 1][2]
Else
$ToReturn[UBound($ToReturn) - 1][0] = $SpellName[$i]
$ToReturn[UBound($ToReturn) - 1][1] = 9999
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
EndIf
Next
Return $ToReturn
EndIf
CheckExistentArmy("Troops", $showlog)
CheckExistentArmy("Spells", $showlog)
Switch $ReturnExtraTroopsOnly
Case False
For $i = 0 To (UBound($TroopName) - 1)
If $Runstate = False Then Return
If Number(Eval($TroopName[$i] & "Comp")) > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $TroopName[$i]
$ToReturn[UBound($ToReturn) - 1][1] = Number(Number(Eval($TroopName[$i] & "Comp")) - Number(Eval("Cur" & $TroopName[$i])))
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
For $i = 0 To (UBound($SpellName) - 1)
If $Runstate = False Then Return
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If Number(Eval($SpellName[$i] & "Comp")) > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $SpellName[$i]
$ToReturn[UBound($ToReturn) - 1][1] = Number(Number(Eval($SpellName[$i] & "Comp")) - Number(Eval("Cur" & $SpellName[$i])))
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
Next
Case Else
For $i = 0 To (UBound($TroopName) - 1)
If $Runstate = False Then Return
If Number(Eval("Cur" & $TroopName[$i])) > 0 Then
If StringInStr(Number(Number(Eval($TroopName[$i] & "Comp")) - Number(Eval("Cur" & $TroopName[$i]))), "-") > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $TroopName[$i]
$ToReturn[UBound($ToReturn) - 1][1] = StringReplace(Number(Number(Eval($TroopName[$i] & "Comp")) - Number(Eval("Cur" & $TroopName[$i]))), "-", "")
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
Next
For $i = 0 To (UBound($SpellName) - 1)
If $Runstate = False Then Return
If TotalSpellsToBrewInGUI() = 0 Then ExitLoop
If Number(Eval("Cur" & $SpellName[$i])) > 0 Then
If StringInStr(Number(Number(Eval($SpellName[$i] & "Comp")) - Number(Eval("Cur" & $SpellName[$i]))), "-") > 0 Then
$ToReturn[UBound($ToReturn) - 1][0] = $SpellName[$i]
$ToReturn[UBound($ToReturn) - 1][1] = StringReplace(Number(Number(Eval($SpellName[$i] & "Comp")) - Number(Eval("Cur" & $SpellName[$i]))), "-", "")
ReDim $ToReturn[UBound($ToReturn) + 1][2]
EndIf
EndIf
Next
EndSwitch
_ArrayDelete($ToReturn, UBound($ToReturn) - 1)
Return $ToReturn
EndFunc
Func TestTroopsCoords()
TrainIt($eDrag, 1, 300)
TrainIt($eBarb, 1, 300)
TrainIt($eArch, 1, 300)
TrainIt($eGiant, 1, 300)
TrainIt($eGobl, 1, 300)
TrainIt($eWall, 1, 300)
TrainIt($eBall, 1, 300)
TrainIt($eWiza, 1, 300)
TrainIt($eHeal, 1, 300)
TrainIt($eDrag, 1, 300)
TrainIt($ePekk, 1, 300)
TrainIt($eBabyD, 1, 300)
TrainIt($eMine, 1, 300)
If _Sleep(1000) Then Return
ClickDrag(616, 445 + $midOffsetY, 400, 445 + $midOffsetY, 2000)
If _Sleep(1500) Then Return
TrainIt($eMini, 1, 300)
TrainIt($eHogs, 1, 300)
TrainIt($eValk, 1, 300)
TrainIt($eGole, 1, 300)
TrainIt($eWitc, 1, 300)
TrainIt($eLava, 1, 300)
TrainIt($eBowl, 1, 300)
EndFunc
Func LeftSpace($ReturnAll = False)
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $Runstate = False Then Return
If $ReturnAll = False Then
Return Number($RemainTrainSpace[2])
Else
Return $RemainTrainSpace
EndIf
EndFunc
Func OpenArmyWindow()
ClickP($aAway, 2, 0, "#0346")
If $Runstate = False Then Return
If _Sleep($iDelayRunBot3) Then Return
If IsMainPage() = False Then
SetLog("Can not open Army Overview window", $COLOR_RED)
SetError(1)
Return False
EndIf
If WaitforPixel(31, 515 + $bottomOffsetY, 33, 517 + $bottomOffsetY, Hex(0xF8F0E0, 6), 10, 20) Then
If $debugsetlogTrain = 1 Then SetLog("Click $aArmyTrainButton", $COLOR_GREEN)
If $iUseRandomClick = 0 Then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0293")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIf
EndIf
If _Sleep($iDelayTrain4) Then Return
Local $x = 0
While ISArmyWindow(True, $ArmyTAB) = False
If _sleep($iDelayTrain4) then return
$x += 1
If $x = 50 then
SetError(1)
Return False
EndIf
WEnd
Return True
EndFunc
Func ISArmyWindow($writelogs = False, $TabNumber = 0)
Local $i = 0
Local $_aIsTrainPgChk1[4] = [816, 136, 0xc40608, 15]
Local $_aIsTrainPgChk2[4] = [843, 183, 0xe8e8e0, 15]
Local $_TabNumber[4][4] = [[147, 128, 0Xf8f8f7, 15], [366, 128, 0Xf8f8f7, 15], [555, 128, 0Xf8f8f7, 15], [758, 128, 0Xf8f8f7, 15]]
Local $CheckIT[4] = [$_TabNumber[$TabNumber][0], $_TabNumber[$TabNumber][1], $_TabNumber[$TabNumber][2], $_TabNumber[$TabNumber][3]]
While $i < 30
If $Runstate = False Then Return
If _CheckPixel($_aIsTrainPgChk1, True) And _CheckPixel($_aIsTrainPgChk2, True) And _CheckPixel($CheckIT, True) Then ExitLoop
If _Sleep($iDelayIsTrainPage1) Then ExitLoop
$i += 1
WEnd
If $i <= 28 Then
If ($DebugSetlog = 1 Or $DebugClick = 1) And $writelogs = True Then Setlog("**Train Window OK**", $COLOR_DEBUG)
Return True
Else
If $writelogs = True Then SetLog("Cannot find train Window | TAB " & $TabNumber, $COLOR_RED)
If $debugImageSave = 1 Then DebugImageSave("IsTrainPage_")
Return False
EndIf
EndFunc
Func CheckExistentArmy($txt = "", $showlog = True)
If ISArmyWindow(True, $ArmyTAB) = False Then
OpenArmyWindow()
If _Sleep(1500) Then Return
EndIf
If $txt = "Troops" Then
ResetVariables("Troops")
Local $directory = @ScriptDir & "\images\Resources\ArmyTroops"
Local $x = 23, $y = 215, $x1 = 840, $y1 = 255
EndIf
If $txt = "Spells" Then
ResetVariables("Spells")
Local $directory = @ScriptDir & "\images\Resources\ArmySpells"
Local $x = 23, $y = 366, $x1 = 585, $y1 = 400
EndIf
If $txt = "Heroes" Then
Local $directory = @ScriptDir & "\images\Resources\ArmyHeroes"
Local $x = 610, $y = 366, $x1 = 830, $y1 = 400
EndIf
Local $result = SearchArmy($directory, $x, $y, $x1, $y1, $txt)
If UBound($result) > 0 Then
For $i = 0 To UBound($result) - 1
If $Runstate = False Then Return
Local $Plural = 0
If $result[$i][0] <> "" Then
If $result[$i][3] > 1 Then $Plural = 1
If StringInStr($result[$i][0], "queued") Then
$result[$i][0] = StringTrimRight($result[$i][0], 6)
If $txt = "Troops" Then
If $showlog = True Then Setlog(" - " & $result[$i][3] & " " & NameOfTroop(Eval("e" & $result[$i][0]), $Plural) & " Queued", $COLOR_BLUE)
Assign("Cur" & $result[$i][0], Eval("Cur" & $result[$i][0]) + $result[$i][3])
EndIf
If $txt = "Spells" Then
If $result[$i][3] = 0 Then
If $showlog = True Then SetLog(" - No Spells are Brewed", $COLOR_BLUE)
Else
If $showlog = True Then Setlog(" - " & $result[$i][3] & " " & NameOfTroop(Eval("e" & $result[$i][0]), $Plural) & " Brewed", $COLOR_BLUE)
Assign("Cur" & $result[$i][0], Eval("Cur" & $result[$i][0]) + $result[$i][3])
EndIf
EndIf
If $txt = "Heroes" Then
If ArmyHeroStatus(Eval("e" & $result[$i][0])) = "heal" Then Setlog(" Â» " & NameOfTroop(Eval("e" & $result[$i][0]), $Plural) & " Recovering, Remain of " & $result[$i][3], $COLOR_BLUE)
EndIf
Else
If $txt = "Heroes" Then
If $showlog = True Then Setlog(" - " & NameOfTroop(Eval("e" & $result[$i][0]), $Plural) & " Recovered", $COLOR_GREEN)
ElseIf $txt = "Troops" Then
ResetDropTrophiesVariable()
If $showlog = True Then Setlog(" - " & $result[$i][3] & " " & NameOfTroop(Eval("e" & $result[$i][0]), $Plural) & " Available", $COLOR_GREEN)
Assign("Cur" & $result[$i][0], Eval("Cur" & $result[$i][0]) + $result[$i][3])
CanBeUsedToDropTrophies(Eval("e" & $result[$i][0]), Eval("Cur" & $result[$i][0]))
Else
If $result[$i][3] = 0 Then
If $showlog = True Then SetLog(" - No Spells are Brewed", $COLOR_GREEN)
Else
If $showlog = True Then Setlog(" - " & $result[$i][3] & " " & NameOfTroop(Eval("e" & $result[$i][0]), $Plural) & " Brewed", $COLOR_GREEN)
Assign("Cur" & $result[$i][0], Eval("Cur" & $result[$i][0]) + $result[$i][3])
EndIf
EndIf
EndIf
EndIf
Next
EndIf
If $txt = "Spells" Then
CountNumberDarkSpells()
EndIf
EndFunc
Func CanBeUsedToDropTrophies($eTroop, $Quantity)
If $eTroop = $eBarb Then
$aDTtroopsToBeUsed[0][1] = $Quantity
ElseIf $eTroop = $eArch Then
$aDTtroopsToBeUsed[1][1] = $Quantity
ElseIf $eTroop = $eGiant Then
$aDTtroopsToBeUsed[2][1] = $Quantity
ElseIf $eTroop = $eGobl Then
$aDTtroopsToBeUsed[4][1] = $Quantity
ElseIf $eTroop = $eWall Then
$aDTtroopsToBeUsed[3][1] = $Quantity
ElseIf $eTroop = $eMini Then
$aDTtroopsToBeUsed[5][1] = $Quantity
EndIf
EndFunc
Func ResetDropTrophiesVariable()
For $i = 0 To (UBound($aDTtroopsToBeUsed, 1) - 1)
$aDTtroopsToBeUsed[$i][1] = 0
Next
EndFunc
Func CheckQueueTroops($getQuantity = True, $showlog = True)
Local $res[1] = [""]
If $showlog Then SetLog("Checking Troops Queue...", $COLOR_BLUE)
Local $directory = @ScriptDir & "\images\Resources\TrainTroops"
Local $result = SearchArmy($directory, 18, 182, 839, 261)
ReDim $res[UBound($result)]
For $i = 0 To (UBound($result) - 1)
If $Runstate = False Then Return
$res[$i] = $result[$i][0]
Next
_ArrayReverse($res)
If $getQuantity Then
Local $Quantities = GetQueueQuantity($res)
If $showlog Then
For $i = 0 To (UBound($Quantities) - 1)
SetLog("  - " & NameOfTroop(Eval("e" & $Quantities[$i][0])) & ": " & $Quantities[$i][1] & "x", $COLOR_GREEN)
Next
EndIf
EndIf
Return $res
EndFunc
Func CheckQueueSpells($getQuantity = True, $showlog = True)
Local $res[1] = [""]
If $showlog Then SetLog("Checking Spells Queue...", $COLOR_BLUE)
Local $directory = @ScriptDir & "\images\Resources\SpellsInQueue"
Local $result = SearchArmy($directory, 18, 182, 839, 261)
ReDim $res[UBound($result)]
For $i = 0 To (UBound($result) - 1)
If $Runstate = False Then Return
$res[$i] = $result[$i][0]
Next
_ArrayReverse($res)
If $getQuantity Then
Local $Quantities = GetQueueQuantity($res)
If $showlog Then
For $i = 0 To (UBound($Quantities) - 1)
If $Runstate = False Then Return
SetLog("  - " & NameOfTroop(Eval("e" & $Quantities[$i][0])) & ": " & $Quantities[$i][1] & "x", $COLOR_GREEN)
Next
EndIf
EndIf
Return $res
EndFunc
Func GetQueueQuantity($AvailableTroops)
If IsArray($AvailableTroops) Then
If $AvailableTroops[0] = "" Or StringLen($AvailableTroops[0]) = 0 Then _ArrayDelete($AvailableTroops, 0)
If $AvailableTroops[UBound($AvailableTroops) - 1] = "" Or StringLen($AvailableTroops[UBound($AvailableTroops) - 1]) = 0 Then _ArrayDelete($AvailableTroops, Number(UBound($AvailableTroops) - 1))
Local $result[UBound($AvailableTroops)][2] = [["", 0]]
Local $x = 770, $y = 189
_CaptureRegion2()
For $i = 0 To (UBound($AvailableTroops) - 1)
If $Runstate = False Then Return
$OCRResult = getQueueTroopsQuantity($x, $y)
$result[$i][0] = $AvailableTroops[$i]
$result[$i][1] = $OCRResult
$x -= 70
Next
Return $result
EndIf
Return False
EndFunc
Func SearchArmy($directory = "", $x = 0, $y = 0, $x1 = 0, $y1 = 0, $txt = "", $skipReceivedTroopsCheck = False)
Local $aResult[1][4], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
Local $Redlines = "FV"
For $waiting = 0 To 10
If $Runstate = False Then Return
If getReceivedTroops(162, 200, $skipReceivedTroopsCheck) = False Then
_CaptureRegion2($x, $y, $x1, $y1)
$res = DllCall($hImgLib, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", $Redlines, "Int", 0, "Int", 1000)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)][4]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i][0] = returnPropertyValue($aKeys[$i], "objectname")
$aValue = returnPropertyValue($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
$aCoordsSplit = StringSplit($aCoords[0], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[0][0] = $aCoordsSplit[0] + $x
$aCoordArray[0][1] = $aCoordsSplit[1]
Else
$aCoordArray[0][0] = -1
$aCoordArray[0][1] = -1
EndIf
$aResult[$i][1] = Number($aCoordArray[0][0])
$aResult[$i][2] = Number($aCoordArray[0][1])
Next
EndIf
ExitLoop
Else
If $waiting = 1 Then Setlog("You have received castle troops! Wait 5's...")
If _Sleep($iDelayTrain8) Then Return
EndIf
Next
_ArraySort($aResult, 0, 0, 0, 1)
If $txt = "Troops" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "troop"), 196))
Next
EndIf
If $txt = "Spells" Then
For $i = 0 To UBound($aResult) - 1
$aResult[$i][3] = Number(getBarracksNewTroopQuantity(Slot($aResult[$i][1], "spells"), 341))
Next
EndIf
If $txt = "Heroes" Then
For $i = 0 To UBound($aResult) - 1
If StringInStr($aResult[$i][0], "Kingqueued") Then
$aResult[$i][3] = getRemainTHero(620, 414)
ElseIf StringInStr($aResult[$i][0], "Queenqueued") Then
$aResult[$i][3] = getRemainTHero(695, 414)
ElseIf StringInStr($aResult[$i][0], "Wardenqueued") Then
$aResult[$i][3] = getRemainTHero(775, 414)
Else
$aResult[$i][3] = 0
EndIf
Next
EndIf
Return $aResult
EndFunc
Func ResetVariables($txt = "")
If $txt = "troops" Or $txt = "all" Then
For $i = 0 To UBound($TroopName) - 1
If $Runstate = False Then Return
Assign("Cur" & $TroopName[$i], 0)
If _Sleep($iDelayTrain6) Then Return
Next
For $i = 0 To UBound($TroopDarkName) - 1
If $Runstate = False Then Return
Assign("Cur" & $TroopDarkName[$i], 0)
If _Sleep($iDelayTrain6) Then Return
Next
EndIf
If $txt = "Spells" Or $txt = "all" Then
For $i = 0 To UBound($SpellName) - 1
If $Runstate = False Then Return
Assign("Cur" & $SpellName[$i], 0)
If _Sleep($iDelayTrain6) Then Return
Next
EndIf
If $txt = "donated" Or $txt = "all" Then
For $i = 0 To UBound($TroopName) - 1
If $Runstate = False Then Return
Assign("Don" & $TroopName[$i], 0)
If _Sleep($iDelayTrain6) Then Return
Next
For $i = 0 To UBound($TroopDarkName) - 1
Assign("Don" & $TroopDarkName[$i], 0)
If $Runstate = False Then Return
If _Sleep($iDelayTrain6) Then Return
Next
EndIf
EndFunc
Func OpenTrainTabNumber($Num)
Local $Message[4] = ["Army Camp",  "Train Troops",  "Brew Spells",  "Quick Train"]
Local $TabNumber[4][2] = [[90, 128], [245, 128], [440, 128], [650, 128]]
If $Runstate = False Then Return
If IsTrainPage() Then
Click($TabNumber[$Num][0], $TabNumber[$Num][1], 2, 200)
If _Sleep(1500) Then Return
If ISArmyWindow(False, $Num) Then Setlog(" Â» Opened the " & $Message[$Num], $COLOR_ACTION1)
Else
Setlog(" Â» Error Clicking On " & ($Num >= 0 And $Num < UBound($Message)) ? ($Message[$Num]) : ("Not selectable") & " Tab!!!", $COLOR_RED)
EndIf
EndFunc
Func TrainArmyNumber($Num)
$Num = $Num - 1
Local $a_TrainArmy[3][4] = [[817, 366, 0x6bb720, 10], [817, 484, 0x6bb720, 10], [817, 601, 0x6bb720, 10]]
Setlog(" Â» TrainArmyNumber: " & $Num + 1)
If $Runstate = False Then Return
If ISArmyWindow(True, $QuickTrainTAB) Then
If _ColorCheck(_GetPixelColor($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], True), Hex($a_TrainArmy[$Num][2], 6), $a_TrainArmy[$Num][3]) Then
Click($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1])
SetLog("Making the Army " & $Num + 1)
If _Sleep(1000) Then Return
Else
Setlog(" Â» Error Clicking On Army: " & $Num + 1 & "| Pixel was :" & _GetPixelColor($a_TrainArmy[$Num][0], $a_TrainArmy[$Num][1], True), $COLOR_ORANGE)
Setlog(" Â» Please 'edit' the Army " & $Num + 1 & " before start the BOT!!!", $COLOR_RED)
BotStop()
EndIf
Else
Setlog(" Â» Error Clicking On Army! You are not on Quick Train Window", $COLOR_RED)
EndIf
EndFunc
Func DeleteTroopsQueued()
If ISArmyWindow(True, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB)
If _Sleep(1500) Then Return
If ISArmyWindow(True, $TrainTroopsTAB) = False Then Return
SetLog(" Â»Â» Delete Troops Queued ", $COLOR_ACTION)
If _Sleep(500) Then Return
Local $x = 0
While _ColorCheck(_GetPixelColor(802, 220, True), Hex(0Xbac8a5, 6), 10) = False
If _Sleep(20) Then Return
If $Runstate = False Then Return
Click(826, 202, 2, 50)
$x += 1
If $x = 250 Then ExitLoop
WEnd
EndFunc
Func DeleteSpellsQueued()
OpenTrainTabNumber($BrewSpellsTAB)
If _Sleep(1500) Then Return
If ISArmyWindow(True, $BrewSpellsTAB) = False Then Return
SetLog(" Â»Â» Delete Spells Queued ", $COLOR_ACTION)
If _Sleep(500) Then Return
Local $x = 0
While _ColorCheck(_GetPixelColor(802, 220, True), Hex(0Xbac8a5, 6), 10) = False
If _Sleep(20) Then Return
If $Runstate = False Then Return
Click(826, 202, 2, 100)
$x += 1
If $x = 250 Then ExitLoop
WEnd
EndFunc
Func Slot($x = 0, $txt = "")
If $Runstate = False Then Return
Switch $x
Case $x < 94
If $txt = "troop" Then Return 35
If $txt = "spells" Then Return 40
Case $x > 94 And $x < 171
If $txt = "troop" Then Return 111
If $txt = "spells" Then Return 120
Case $x > 171 And $x < 244
If $txt = "troop" Then Return 184
If $txt = "spells" Then Return 195
Case $x > 244 And $x < 308
If $txt = "troop" Then Return 255
If $txt = "spells" Then Return 272
Case $x > 308 And $x < 393
If $txt = "troop" Then Return 330
If $txt = "spells" Then Return 341
Case $x > 393 And $x < 465
If $txt = "troop" Then Return 403
If $txt = "spells" Then Return 415
Case $x > 465 And $x < 538
If $txt = "troop" Then Return 477
If $txt = "spells" Then Return 485
Case $x > 538 And $x < 611
Return 551
Case $x > 611 And $x < 683
Return 625
Case $x > 683 And $x < 753
Return 694
Case $x > 753 And $x < 825
Return 764
EndSwitch
EndFunc
Func MakingTroops()
If IsTrainPage() And ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB)
If _Sleep(1500) Then Return
If ISArmyWindow(True, $TrainTroopsTAB) = False Then Return
For $i = 0 To UBound($TroopName) - 1
If $Runstate = False Then Return
If Eval($TroopName[$i] & "Comp") > 0 Then
If Eval($TroopName[$i] & "Comp") - Eval("Cur" & $TroopName[$i]) > 0 Then
TrainIt(Eval("e" & $TroopName[$i]), Eval($TroopName[$i] & "Comp") - Eval("Cur" & $TroopName[$i]), $isldTrainITDelay)
$fullarmy = False
ElseIf Eval($TroopName[$i] & "Comp") - Eval("Cur" & $TroopName[$i]) < 0 Then
Setlog("You have " & Abs(Eval($TroopName[$i] & "Comp") - Eval("Cur" & $TroopName[$i])) & " " & NameOfTroop(Eval("e" & $TroopName[$i]), 1) & " more than necessary!", $COLOR_RED)
ElseIf Eval($TroopName[$i] & "Comp") - Eval("Cur" & $TroopName[$i]) = 0 Then
Setlog(" Â» " & NameOfTroop(Eval("e" & $TroopName[$i]), 1) & " are all done!", $COLOR_GREEN)
EndIf
EndIf
Next
Local $z = 0
For $i = 0 To UBound($TroopDarkName) - 1
If $Runstate = False Then Return
If Eval($TroopDarkName[$i] & "Comp") > 0 Then
If $z = 0 Then
ClickDrag(616, 445 + $midOffsetY, 400, 445 + $midOffsetY, 2000)
If _Sleep(1500) Then Return
$z = 1
EndIf
If Eval($TroopDarkName[$i] & "Comp") - Eval("Cur" & $TroopDarkName[$i]) > 0 Then
TrainIt(Eval("e" & $TroopDarkName[$i]), Eval($TroopDarkName[$i] & "Comp") - Eval("Cur" & $TroopDarkName[$i]), $isldTrainITDelay)
$fullarmy = False
ElseIf Eval($TroopDarkName[$i] & "Comp") - Eval("Cur" & $TroopDarkName[$i]) < 0 Then
Setlog("You have " & Abs(Eval($TroopDarkName[$i] & "Comp") - Eval("Cur" & $TroopDarkName[$i])) & " " & NameOfTroop(Eval("e" & $TroopDarkName[$i]), 1) & " more than necessary!", $COLOR_RED)
ElseIf Eval($TroopDarkName[$i] & "Comp") - Eval("Cur" & $TroopDarkName[$i]) = 0 Then
Setlog(" Â» " & NameOfTroop(Eval("e" & $TroopDarkName[$i]), 1) & " are all done!", $COLOR_GREEN)
EndIf
EndIf
Next
EndFunc
Func MakingDonatedTroops()
Local $RemainTrainSpace
Local $Plural = 0
Local $areThereDonTroop = 0
Local $areThereDonSpell = 0
For $j = 0 To UBound($TroopName) - 1
If $Runstate = False Then Return
$areThereDonTroop += Eval("Don" & $TroopName[$j])
Next
For $j = 0 To UBound($TroopDarkName) - 1
If $Runstate = False Then Return
$areThereDonTroop += Eval("Don" & $TroopDarkName[$j])
Next
For $j = 0 To UBound($SpellName) - 1
If $Runstate = False Then Return
$areThereDonSpell += Eval("Don" & $SpellName[$j])
Next
If $areThereDonSpell = 0 And $areThereDonTroop = 0 Then Return
SetLog(" Â» making donated troops", $COLOR_ACTION1)
If $areThereDonTroop > 0 Then
For $i = 0 To UBound($MergedTroopGroup, 1) - 1
For $j = 0 To UBound($TroopName) - 1
If $TroopName[$j] = $MergedTroopGroup[$i][0] Then
$MergedTroopGroup[$i][3] = Eval("Don" & $TroopName[$j])
EndIf
Next
For $j = 0 To UBound($TroopDarkName) - 1
If $TroopDarkName[$j] = $MergedTroopGroup[$i][0] Then
$MergedTroopGroup[$i][3] = Eval("Don" & $TroopDarkName[$j])
EndIf
Next
Next
For $j = 0 To UBound($TroopName) - 1
Assign("Don" & $TroopName[$j], 0)
Next
For $j = 0 To UBound($TroopDarkName) - 1
Assign("Don" & $TroopDarkName[$j], 0)
Next
If IsTrainPage() And ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB)
If _Sleep(1500) Then Return
If ISArmyWindow(True, $TrainTroopsTAB) = False Then Return
For $i = 0 To UBound($MergedTroopGroup, 1) - 1
If $Runstate = False Then Return
$Plural = 0
If $MergedTroopGroup[$i][3] > 0 Then
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] = $RemainTrainSpace[1] Then
For $j = 0 To UBound($MergedTroopGroup, 1) - 1
$MergedTroopGroup[$j][3] = 0
Next
ExitLoop
EndIf
If $MergedTroopGroup[$i][2] * $MergedTroopGroup[$i][3] <= $RemainTrainSpace[2] Then
Local $pos = GetTrainPos(Eval("e" & $MergedTroopGroup[$i][0]))
Local $howMuch = $MergedTroopGroup[$i][3]
If $MergedTroopGroup[$i][4] = "e" Then
PureClick($pos[0], $pos[1], $howMuch, 500)
Else
ClickDrag(616, 445 + $midOffsetY, 400, 445 + $midOffsetY, 2000)
PureClick($pos[0], $pos[1], $howMuch, 500)
ClickDrag(400, 445 + $midOffsetY, 616, 445 + $midOffsetY, 2000)
EndIf
If $MergedTroopGroup[$i][3] > 1 Then $Plural = 1
Setlog(" Â» Trained " & $MergedTroopGroup[$i][3] & " " & NameOfTroop(Eval("e" & $MergedTroopGroup[$i][0]), $Plural), $COLOR_ACTION)
$MergedTroopGroup[$i][3] = 0
If _Sleep(1000) Then Return
Else
For $z = 0 To $RemainTrainSpace[2] - 1
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] = $RemainTrainSpace[1] Then
For $j = 0 To UBound($MergedTroopGroup, 1) - 1
$MergedTroopGroup[$j][3] = 0
Next
ExitLoop (2)
EndIf
If $MergedTroopGroup[$i][2] <= $RemainTrainSpace[2] And $MergedTroopGroup[$i][3] > 0 Then
Local $pos = GetTrainPos(Eval("e" & $MergedTroopGroup[$i][0]))
Local $howMuch = 1
If $MergedTroopGroup[$i][4] = "e" Then
PureClick($pos[0], $pos[1], $howMuch, 500)
Else
ClickDrag(616, 445 + $midOffsetY, 400, 445 + $midOffsetY, 2000)
PureClick($pos[0], $pos[1], $howMuch, 500)
ClickDrag(400, 445 + $midOffsetY, 616, 445 + $midOffsetY, 2000)
EndIf
If $MergedTroopGroup[$i][3] > 1 Then $Plural = 1
Setlog(" Â» Trained " & $MergedTroopGroup[$i][3] & " " & NameOfTroop(Eval("e" & $MergedTroopGroup[$i][0]), $Plural), $COLOR_ACTION)
$MergedTroopGroup[$i][3] -= 1
If _Sleep(1000) Then Return
Else
ExitLoop
EndIf
Next
EndIf
EndIf
Next
$RemainTrainSpace = GetOCRCurrent(48, 160)
If $RemainTrainSpace[0] < $RemainTrainSpace[1] Then
Local $howMuch = $RemainTrainSpace[2]
PureClick($TrainArch[0], $TrainArch[1], $howMuch, 500)
If $RemainTrainSpace[2] > 0 Then $Plural = 1
Setlog("Trained " & $howMuch & " archer(s)!", $COLOR_ACTION)
If _Sleep(1000) Then Return
EndIf
For $j = 0 To UBound($MergedTroopGroup, 1) - 1
$MergedTroopGroup[$j][3] = 0
Next
EndIf
If $areThereDonSpell > 0 Then
If IsTrainPage() And ISArmyWindow(False, 2) = False Then OpenTrainTabNumber(2)
If _Sleep(1500) Then Return
If ISArmyWindow(True, 2) = False Then Return
For $i = 0 To UBound($SpellName) - 1
If $Runstate = False Then Return
If Eval("Don" & $SpellName[$i]) > 0 Then
$Plural = 0
Local $pos = GetTrainPos(Eval("e" & $SpellName[$i]))
Local $howMuch = Eval("Don" & $SpellName[$i])
If $howMuch > 1 Then $Plural = 1
PureClick($pos[0], $pos[1], $howMuch, 500)
Setlog(" Â» Brewed " & $howMuch & " " & NameOfTroop(Eval("e" & $SpellName[$i]), $Plural), $COLOR_ACTION)
Assign("Don" & $SpellName[$i], Eval("Don" & $SpellName[$i]) - $howMuch)
EndIf
Next
EndIf
If _Sleep(1000) Then Return
$RemainTrainSpace = GetOCRCurrent(48, 160)
Setlog(" Â» Current Capacity: " & $RemainTrainSpace[0] & "/" & ($RemainTrainSpace[1]))
EndFunc
Func GetOCRCurrent($x_start, $y_start)
Local $FinalResult[3] = [0, 0, 0]
If $Runstate = False Then Return $FinalResult
Local $result = getArmyCapacityOnTrainTroops($x_start, $y_start)
If StringInStr($result, "#") Then
Local $resultSplit = StringSplit($result, "#", $STR_NOCOUNT)
$FinalResult[0] = Number($resultSplit[0])
$FinalResult[1] = Number($resultSplit[1])
$FinalResult[2] = $FinalResult[1] - $FinalResult[0]
Else
Setlog("DEBUG | ERROR on GetOCRCurrent", $COLOR_RED)
EndIf
Return $FinalResult
EndFunc
Func CheckIsFullQueuedAndNotFullArmy()
SetLog(" Â» Checking: FULL Queue and Not Full Army", $COLOR_ACTION1)
Local $CheckTroop[4] = [824, 243, 0x949522, 20]
If $Runstate = False Then Return
If IsTrainPage() And ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB)
If _Sleep(1500) Then Return
If ISArmyWindow(True, $TrainTroopsTAB) = False Then Return
Local $ArmyCamp = GetOCRCurrent(48, 160)
If UBound($ArmyCamp) = 3 And $ArmyCamp[2] < 0 Then
If _ColorCheck(_GetPixelColor($CheckTroop[0], $CheckTroop[1], True), Hex($CheckTroop[2], 6), $CheckTroop[3]) Then
SetLog(" Â» Conditions met: FULL Queue and Not Full Army")
DeleteTroopsQueued()
If _Sleep(500) Then Return
$ArmyCamp = GetOCRCurrent(48, 160)
Local $ArchToMake = $ArmyCamp[2]
If ISArmyWindow(False, $TrainTroopsTAB) Then PureClick($TrainArch[0], $TrainArch[1], $ArchToMake, 500)
Setlog("Trained " & $ArchToMake & " archer(s)!")
Else
SetLog(" Â» Conditions NOT met: FULL queue and Not Full Army")
EndIf
EndIf
EndFunc
Func CheckIsEmptyQueuedAndNotFullArmy()
SetLog(" Â» Checking: Empty Queue and Not Full Army", $COLOR_ACTION1)
Local $CheckTroop[4] = [820, 220, 0xCFCFC8, 15]
Local $CheckTroop1[4] = [390, 130, 0x78BE2B, 15]
If $Runstate = False Then Return
If IsTrainPage() And ISArmyWindow(False, $TrainTroopsTAB) = False Then OpenTrainTabNumber($TrainTroopsTAB)
If _Sleep(1500) Then Return
If ISArmyWindow(True, $TrainTroopsTAB) = False Then Return
Local $ArmyCamp = GetOCRCurrent(48, 160)
If UBound($ArmyCamp) = 3 And $ArmyCamp[2] > 0 Then
If _ColorCheck(_GetPixelColor($CheckTroop[0], $CheckTroop[1], True), Hex($CheckTroop[2], 6), $CheckTroop[3]) Then
If Not _ColorCheck(_GetPixelColor($CheckTroop1[0], $CheckTroop1[1], True), Hex($CheckTroop1[2], 6), $CheckTroop1[3]) Then
SetLog(" Â» Conditions met: Empty Queue and Not Full Army")
If _Sleep(500) Then Return
$ArmyCamp = GetOCRCurrent(48, 160)
Local $ArchToMake = $ArmyCamp[2]
If ISArmyWindow(False, $TrainTroopsTAB) Then PureClick($TrainArch[0], $TrainArch[1], $ArchToMake, 500)
SetLog(" Â» Trained " & $ArchToMake & " archer(s)!")
Else
SetLog(" Â» Conditions NOT met: Empty queue and Not Full Army")
EndIf
EndIf
EndIf
EndFunc
Func AttackBarCheck()
Local $x = 0, $y = 659, $x1 = 853, $y1 = 698
Local $aResult[1][5], $aCoordArray[1][2], $aCoords, $aCoordsSplit, $aValue
Local $Redlines = "FV"
Local $directory = @ScriptDir & "\images\Resources\AttackBar"
If $Runstate = False Then Return
_CaptureRegion2($x, $y, $x1, $y1)
Local $strinToReturn = ""
$res = DllCall($hImgLib, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", $Redlines, "Int", 0, "Int", 1000)
If IsArray($res) Then
If $res[0] = "0" Or $res[0] = "" Then
SetLog("Imgloc|AttackBarCheck not found!", $COLOR_RED)
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0] & ", AttackBarCheck", $COLOR_RED)
Else
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)][5]
For $i = 0 To UBound($aKeys) - 1
If $Runstate = False Then Return
$aResult[$i][0] = returnPropertyValue($aKeys[$i], "objectname")
$aValue = returnPropertyValue($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
$aCoordsSplit = StringSplit($aCoords[0], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[0][0] = $aCoordsSplit[0]
$aCoordArray[0][1] = $aCoordsSplit[1]
Else
$aCoordArray[0][0] = -1
$aCoordArray[0][1] = -1
EndIf
If $DebugSetlog = 1 Then Setlog($aResult[$i][0] & " | $aCoordArray: " & $aCoordArray[0][0] & "-" & $aCoordArray[0][1])
If UBound($aCoords) > 1 And StringInStr($aResult[$i][0], "Spell") <> 0 Then
If $DebugSetlog = 1 Then Setlog($aResult[$i][0] & " detected twice!")
Local $aCoordsSplit2 = StringSplit($aCoords[1], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit2) = 2 Then
If $aCoordsSplit2[0] < $aCoordsSplit[0] Then
$aCoordArray[0][0] = $aCoordsSplit2[0]
$aCoordArray[0][1] = $aCoordsSplit2[1]
If $DebugSetlog = 1 Then Setlog($aResult[$i][0] & " | $aCoordArray: " & $aCoordArray[0][0] & "-" & $aCoordArray[0][1])
EndIf
Else
$aCoordArray[0][0] = -1
$aCoordArray[0][1] = -1
EndIf
EndIf
$aResult[$i][1] = Number($aCoordArray[0][0])
$aResult[$i][2] = Number($aCoordArray[0][1])
Next
_ArraySort($aResult, 0, 0, 0, 1)
For $i = 0 To UBound($aResult) - 1
Local $Slottemp
If $aResult[$i][1] > 0 Then
If $DebugSetlog = 1 Then SetLog("$aResult : " & $i, $COLOR_DEBUG)
If $DebugSetlog = 1 Then SetLog("UBound($aResult) : " & $aResult[$i][0] & "|" & $aResult[$i][1] & "|" & $aResult[$i][2], $COLOR_DEBUG)
$Slottemp = SlotAttack($aResult[$i][1])
If $DebugSetlog = 1 Then SetLog("$Slottemp : " & $Slottemp[0] & "|" & $Slottemp[1], $COLOR_DEBUG)
If $aResult[$i][0] = "Castle" Or $aResult[$i][0] = "King" Or $aResult[$i][0] = "Queen" Or $aResult[$i][0] = "Warden" Then
$aResult[$i][3] = 1
$aResult[$i][4] = $Slottemp[1]
Else
$aResult[$i][3] = Number(getTroopCountBig($Slottemp[0], 636))
$aResult[$i][4] = $Slottemp[1]
If $aResult[$i][3] = "" Or $aResult[$i][3] = 0 Then
$aResult[$i][3] = Number(getTroopCountSmall($Slottemp[0], 641))
$aResult[$i][4] = $Slottemp[1]
EndIf
EndIf
$strinToReturn &= "|" & Eval("e" & $aResult[$i][0]) & "#" & $aResult[$i][4] & "#" & $aResult[$i][3]
EndIf
Next
EndIf
EndIf
If $debugImageSave = 1 Then
Local $x = 0, $y = 659, $x1 = 853, $y1 = 698
_CaptureRegion($x, $y, $x1, $y1)
Local $subDirectory = $dirTempDebug & "AttackBarDetection"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = String($Date & "_" & $Time & "_.png")
Local $editedImage = $hBitmap
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 2)
For $i = 0 To UBound($aResult) - 1
_GDIPlus_GraphicsDrawRect($hGraphic, $aResult[$i][1] - 5, $aResult[$i][2] - 5, 10, 10, $hPenRED)
Next
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $filename)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
$strinToReturn = StringTrimLeft($strinToReturn, 1)
Return $strinToReturn
EndFunc
Func SlotAttack($x)
Local $CheckSlot11 = _ColorCheck(_GetPixelColor(834, 588 + $bottomOffsetY, True), Hex(0x040c0a, 6), 15)
Local $Slottemp[2] = [0, 0]
If $Runstate = False Then Return
Switch $x
Case $x < 98
$Slottemp[0] = 35
$Slottemp[1] = 0
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 98 And $x < 171
$Slottemp[0] = 111
$Slottemp[1] = 1
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 171 And $x < 244
$Slottemp[0] = 184
$Slottemp[1] = 2
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 244 And $x < 308
$Slottemp[0] = 255
$Slottemp[1] = 3
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 308 And $x < 393
$Slottemp[0] = 330
$Slottemp[1] = 4
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 393 And $x < 465
$Slottemp[0] = 403
$Slottemp[1] = 5
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 465 And $x < 538
$Slottemp[0] = 477
$Slottemp[1] = 6
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 538 And $x < 611
$Slottemp[0] = 551
$Slottemp[1] = 7
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 611 And $x < 683
$Slottemp[0] = 625
$Slottemp[1] = 8
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 683 And $x < 753
$Slottemp[0] = 694
$Slottemp[1] = 9
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 753 And $x < 823
$Slottemp[0] = 764
$Slottemp[1] = 10
If $CheckSlot11 = False Then $Slottemp[0] -= 13
Return $Slottemp
Case $x > 823 And $x < 860
$Slottemp[0] = 830
$Slottemp[1] = 11
Return $Slottemp
Case Else
Return $Slottemp
EndSwitch
EndFunc
Func CountNumberDarkSpells()
$CurTotalDarkSpell = $CurPSpell + $CurESpell + $CurHaSpell + $CurSkSpell
Return $CurTotalDarkSpell
EndFunc
Func getReceivedTroops($x_start, $y_start, $skip = False)
If $skip = True Then Return False
Local $result = ""
If $Runstate = False Then Return
$result = getOcrAndCapture("coc-DonTroops", $x_start, $y_start, 120, 27, True)
If IsString($result) <> "" Or IsString($result) <> " " Then
If StringInStr($result, "you") Then
Return True
Else
Return False
EndIf
Else
Return False
EndIf
EndFunc
Func TestEQDeploy()
$Runstate = True
Setlog(" Â»Â»Â» Initial TestEQDeploy Â«Â«Â« ")
Local $subDirectory = @ScriptDir & "\TestsImages"
DirCreate($subDirectory)
Local $TestEQDeployTimer = TimerInit()
Local $TestEQDeployFinalTimer = TimerInit()
Local $TileX = 128
Local $TileY = 96
_CaptureRegion()
Local $editedImage = $hBitmap
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = String($Date & "_" & $Time & ".png")
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPenRED = _GDIPlus_PenCreate(0xFFFF0000, 2)
Local $hPenWHITE = _GDIPlus_PenCreate(0xFFFFFFFF, 2)
Local $hPenGREEN = _GDIPlus_PenCreate(0xFF00FF00, 2)
Local $hPenBLUE = _GDIPlus_PenCreate(0xFF2D49FF, 2)
Local $hPenYELLOW = _GDIPlus_PenCreate(0xFFffff00, 2)
Local $result, $listPixelByLevel, $pixelWithLevel, $level, $pixelStr, $TH[2]
Local $aTownHallLocal[3] = [-1, -1, -1]
Local $center = [430, 338]
Local $MixX = 76, $MinY = 70, $MaxX = 790, $MaxY = 603
Local $aTownHall
Setlog(" Â»Â»Â» Initial detection TH and Red Lines Â«Â«Â« ")
Local $directory = @ScriptDir & "\images\Resources\TH"
$aTownHall = returnHighestLevelSingleMatch($directory)
Setlog(" Â»Â»Â» Ends detection TH and Red Lines Â«Â«Â« ")
If Number($aTownHall[4]) > 0 Then
Setlog(" Â»Â»Â» $aTownHall Rows: " & UBound($aTownHall))
Setlog("filename: " & $aTownHall[0])
Setlog("objectname: " & $aTownHall[1])
Setlog("objectlevel: " & $aTownHall[2])
Setlog("totalobjects: " & $aTownHall[4])
Setlog(" Â»Â»Â» $aTownHall[5] Rows: " & UBound($aTownHall[5]))
Setlog("$aTownHall[5]: " & $aTownHall[5])
$pixelStr = $aTownHall[5]
Setlog(" Â»Â»Â» X coord: " & $pixelStr[0][0])
Setlog(" Â»Â»Â» Y coord: " & $pixelStr[0][1])
$TH[0] = $pixelStr[0][0]
$TH[1] = $pixelStr[0][1]
$level = $aTownHall[2]
Setlog("RedLine String: " & $aTownHall[6])
Else
SetLog("ImgLoc TownHall Error..!!", $COLOR_RED)
EndIf
Setlog("Time Taken|$aTownHall: " & Round(TimerDiff($TestEQDeployTimer) / 1000, 2) & "'s")
$TestEQDeployTimer = TimerInit()
If isInsideDiamond($TH) Then
Setlog("TownHall level: " & $level & "|" & $TH[0] & "-" & $TH[1])
Else
SetLog("Found TownHall with Invalid Location?", $COLOR_RED)
EndIf
_GDIPlus_GraphicsDrawRect($hGraphic, $TH[0] - 5, $TH[1] - 5, 10, 10, $hPenRED)
_GDIPlus_GraphicsDrawString($hGraphic, "TH" & $level, $TH[0] + 10, $TH[1], "Verdana", 15)
Local $Redlines = Imgloc2MBR($aTownHall[6])
Setlog("Time Taken|$Redlines|Imgloc2MBR: " & Round(TimerDiff($TestEQDeployTimer) / 1000, 2) & "'s")
$TestEQDeployTimer = TimerInit()
Setlog(" Â» RedLine string: " & $Redlines)
Local $listPixelBySide = StringSplit($Redlines, "#")
$PixelTopLeft = GetPixelSide($listPixelBySide, 1)
$PixelBottomLeft = GetPixelSide($listPixelBySide, 2)
$PixelBottomRight = GetPixelSide($listPixelBySide, 3)
$PixelTopRight = GetPixelSide($listPixelBySide, 4)
Setlog(" Â»Â» " & UBound($PixelTopLeft) + UBound($PixelBottomLeft) + UBound($PixelBottomRight) + UBound($PixelTopRight) & " points detected!")
Local $tempFinalPixelTopLef[1][3]
Local $tempFinalPixelBottomLeft[1][3]
Local $tempFinalPixelBottomRight[1][3]
Local $tempFinalPixelTopRight[1][3]
For $i = 0 To UBound($PixelTopLeft) - 1
Local $PixelTemp = $PixelTopLeft[$i]
Local $Pixel = Pixel_Distance($PixelTemp[0], $PixelTemp[1], $TH[0], $TH[1])
ReDim $tempFinalPixelTopLef[$i + 1][3]
$tempFinalPixelTopLef[$i][0] = $PixelTemp[0]
$tempFinalPixelTopLef[$i][1] = $PixelTemp[1]
$tempFinalPixelTopLef[$i][2] = $Pixel
Next
For $i = 0 To UBound($PixelBottomLeft) - 1
Local $PixelTemp = $PixelBottomLeft[$i]
Local $Pixel = Pixel_Distance($PixelTemp[0], $PixelTemp[1], $TH[0], $TH[1])
ReDim $tempFinalPixelBottomLeft[$i + 1][3]
$tempFinalPixelBottomLeft[$i][0] = $PixelTemp[0]
$tempFinalPixelBottomLeft[$i][1] = $PixelTemp[1]
$tempFinalPixelBottomLeft[$i][2] = $Pixel
Next
For $i = 0 To UBound($PixelBottomRight) - 1
Local $PixelTemp = $PixelBottomRight[$i]
Local $Pixel = Pixel_Distance($PixelTemp[0], $PixelTemp[1], $TH[0], $TH[1])
ReDim $tempFinalPixelBottomRight[$i + 1][3]
$tempFinalPixelBottomRight[$i][0] = $PixelTemp[0]
$tempFinalPixelBottomRight[$i][1] = $PixelTemp[1]
$tempFinalPixelBottomRight[$i][2] = $Pixel
Next
For $i = 0 To UBound($PixelTopRight) - 1
Local $PixelTemp = $PixelTopRight[$i]
Local $Pixel = Pixel_Distance($PixelTemp[0], $PixelTemp[1], $TH[0], $TH[1])
ReDim $tempFinalPixelTopRight[$i + 1][3]
$tempFinalPixelTopRight[$i][0] = $PixelTemp[0]
$tempFinalPixelTopRight[$i][1] = $PixelTemp[1]
$tempFinalPixelTopRight[$i][2] = $Pixel
Next
Setlog("Time Taken|$Pixel_Distance Loop: " & Round(TimerDiff($TestEQDeployTimer) / 1000, 2) & "'s")
$TestEQDeployTimer = TimerInit()
_ArraySort($tempFinalPixelTopLef, 0, -1, -1, 2)
_ArraySort($tempFinalPixelBottomLeft, 0, -1, -1, 2)
_ArraySort($tempFinalPixelBottomRight, 0, -1, -1, 2)
_ArraySort($tempFinalPixelTopRight, 0, -1, -1, 2)
Local $MostNearTH[4][3]
$MostNearTH[0][0] = $tempFinalPixelTopLef[0][0]
$MostNearTH[0][1] = $tempFinalPixelTopLef[0][1]
$MostNearTH[0][2] = $tempFinalPixelTopLef[0][2]
$MostNearTH[1][0] = $tempFinalPixelBottomLeft[0][0]
$MostNearTH[1][1] = $tempFinalPixelBottomLeft[0][1]
$MostNearTH[1][2] = $tempFinalPixelBottomLeft[0][2]
$MostNearTH[2][0] = $tempFinalPixelBottomRight[0][0]
$MostNearTH[2][1] = $tempFinalPixelBottomRight[0][1]
$MostNearTH[2][2] = $tempFinalPixelBottomRight[0][2]
$MostNearTH[3][0] = $tempFinalPixelTopRight[0][0]
$MostNearTH[3][1] = $tempFinalPixelTopRight[0][1]
$MostNearTH[3][2] = $tempFinalPixelTopRight[0][2]
_ArraySort($MostNearTH, 0, -1, -1, 2)
Local $MasterPixel[2]
$MasterPixel[0] = $MostNearTH[0][0]
$MasterPixel[1] = $MostNearTH[0][1]
Local $RedLinepixelCloserTH[2]
Switch StringLeft(Slice8($MasterPixel), 1)
Case 1, 2
$MAINSIDE = "BOTTOM-RIGHT"
$MixX = 430
$MaxX = 790
$MinY = 338
$MaxY = 603
Local $PixelRedLine = $PixelBottomRight
$RedLinepixelCloserTH[0] = $tempFinalPixelBottomRight[0][0]
$RedLinepixelCloserTH[1] = $tempFinalPixelBottomRight[0][1]
Case 3, 4
$MAINSIDE = "TOP-RIGHT"
$MixX = 430
$MaxX = 790
$MinY = 70
$MaxY = 338
Local $PixelRedLine = $PixelTopRight
$RedLinepixelCloserTH[0] = $tempFinalPixelTopRight[0][0]
$RedLinepixelCloserTH[1] = $tempFinalPixelTopRight[0][1]
Case 5, 6
$MAINSIDE = "TOP-LEFT"
$MixX = 76
$MaxX = 430
$MinY = 70
$MaxY = 338
Local $PixelRedLine = $PixelTopLeft
$RedLinepixelCloserTH[0] = $tempFinalPixelTopLef[0][0]
$RedLinepixelCloserTH[1] = $tempFinalPixelTopLef[0][1]
Case 7, 8
$MAINSIDE = "BOTTOM-LEFT"
$MixX = 76
$MaxX = 430
$MinY = 338
$MaxY = 603
Local $PixelRedLine = $PixelBottomLeft
$RedLinepixelCloserTH[0] = $tempFinalPixelBottomLeft[0][0]
$RedLinepixelCloserTH[1] = $tempFinalPixelBottomLeft[0][1]
EndSwitch
Setlog("Forced side: " & $MAINSIDE)
_GDIPlus_GraphicsDrawRect($hGraphic, $MixX, $MinY, $MaxX - $MixX, $MaxY - $MinY, $hPenGREEN)
_GDIPlus_GraphicsDrawString($hGraphic, "SIDE: " & $MAINSIDE, $MixX + 50, $MinY, "Verdana", 15)
For $i = 0 To UBound($PixelRedLine) - 1
Local $RedLinepixel = $PixelRedLine[$i]
_GDIPlus_GraphicsDrawRect($hGraphic, $RedLinepixel[0] - 1, $RedLinepixel[1] - 1, 2, 2, $hPenRED)
Next
_GDIPlus_GraphicsDrawLine($hGraphic, $RedLinepixelCloserTH[0], $RedLinepixelCloserTH[1], $TH[0], $TH[1], $hPenWHITE)
Local $MiddleDistance[2] = [Floor(Abs($RedLinepixelCloserTH[0] - $TH[0]) / 2), Floor(Abs($RedLinepixelCloserTH[1] - $TH[1]) / 2)]
If $RedLinepixelCloserTH[0] < $TH[0] And $RedLinepixelCloserTH[1] < $TH[1] Then
$MiddleDistance[0] = Abs($MiddleDistance[0] + $RedLinepixelCloserTH[0])
$MiddleDistance[1] = Abs($MiddleDistance[1] + $RedLinepixelCloserTH[1])
EndIf
If $RedLinepixelCloserTH[0] < $TH[0] And $RedLinepixelCloserTH[1] > $TH[1] Then
$MiddleDistance[0] = Abs($MiddleDistance[0] + $RedLinepixelCloserTH[0])
$MiddleDistance[1] = Abs($MiddleDistance[1] - $RedLinepixelCloserTH[1])
EndIf
If $RedLinepixelCloserTH[0] > $TH[0] And $RedLinepixelCloserTH[1] > $TH[1] Then
$MiddleDistance[0] = Abs($MiddleDistance[0] - $RedLinepixelCloserTH[0])
$MiddleDistance[1] = Abs($MiddleDistance[1] - $RedLinepixelCloserTH[1])
EndIf
If $RedLinepixelCloserTH[0] > $TH[0] And $RedLinepixelCloserTH[1] < $TH[1] Then
$MiddleDistance[0] = Abs($MiddleDistance[0] - $RedLinepixelCloserTH[0])
$MiddleDistance[1] = Abs($MiddleDistance[1] + $RedLinepixelCloserTH[1])
EndIf
Setlog(" Â»Â» Middle Distance is: " & $MiddleDistance[0] & "-" & $MiddleDistance[1])
_GDIPlus_GraphicsDrawRect($hGraphic, $MiddleDistance[0] - 3, $MiddleDistance[1] - 3, 6, 6, $hPenWHITE)
Local $x = $MiddleDistance[0] - ($TileX / 2)
Local $y = $MiddleDistance[1] - ($TileY / 2)
Local $x1 = Floor(Abs($MiddleDistance[0] - $TH[0]) / 2)
Local $y1 = Floor(Abs($MiddleDistance[1] - $TH[1]) / 2)
If $MiddleDistance[0] < $TH[0] And $MiddleDistance[1] < $TH[1] Then
$x1 = Abs($x1 + $MiddleDistance[0])
$y1 = Abs($y1 + $MiddleDistance[1])
EndIf
If $MiddleDistance[0] < $TH[0] And $MiddleDistance[1] > $TH[1] Then
$x1 = Abs($x1 + $MiddleDistance[0])
$y1 = Abs($y1 - $MiddleDistance[1])
EndIf
If $MiddleDistance[0] > $TH[0] And $MiddleDistance[1] > $TH[1] Then
$x1 = Abs($x1 - $MiddleDistance[0])
$y1 = Abs($y1 - $MiddleDistance[1])
EndIf
If $MiddleDistance[0] > $TH[0] And $MiddleDistance[1] < $TH[1] Then
$x1 = Abs($x1 - $MiddleDistance[0])
$y1 = Abs($y1 + $MiddleDistance[1])
EndIf
_GDIPlus_GraphicsDrawRect($hGraphic, $x, $y, $TileX, $TileY, $hPenRED)
_GDIPlus_GraphicsDrawString($hGraphic, "|Walls|", $x + 10, $y + 10, "Verdana", 15)
If Pixel_Distance($x, $y, $x1, $y1) > 60 Then
$TestEQDeployTimer = TimerInit()
Local $THlevel = $level
Local $FinalWallsPixelWithDistance
$FinalWallsPixelWithDistance = GetWalls($x, $y, $x + $TileX, $y + $TileY, $THlevel)
Setlog(" $FinalWallsPixelWithDistance | Rows; " & UBound($FinalWallsPixelWithDistance, $UBOUND_ROWS))
Setlog("Time Taken|Walls detection: " & Round(TimerDiff($TestEQDeployTimer) / 1000, 2) & "'s")
For $i = 0 To UBound($FinalWallsPixelWithDistance) - 1
_GDIPlus_GraphicsDrawRect($hGraphic, $FinalWallsPixelWithDistance[$i][0] - 2, $FinalWallsPixelWithDistance[$i][1] - 2, 4, 4, $hPenWHITE)
Next
Local $PixelNearBuild = PixelNearest($FinalWallsPixelWithDistance, $TH)
_GDIPlus_GraphicsDrawRect($hGraphic, $PixelNearBuild[0] - 3, $PixelNearBuild[1] - 3, 6, 6, $hPenBLUE)
Local $radius = 60
Local $PixelToDeploy = PixelToDeployEQ($FinalWallsPixelWithDistance, $PixelNearBuild, $radius)
Setlog("$PixelToDeploy: " & $PixelToDeploy[0] & "-" & $PixelToDeploy[1])
_GDIPlus_GraphicsDrawRect($hGraphic, $PixelToDeploy[0] - 3, $PixelToDeploy[1] - 3, 6, 6, $hPenYELLOW)
EndIf
Setlog("Time Taken|ALL FUNCTION: " & Round(TimerDiff($TestEQDeployFinalTimer) / 1000, 2) & "'s")
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & "\" & $filename)
_GDIPlus_PenDispose($hPenRED)
_GDIPlus_PenDispose($hPenWHITE)
_GDIPlus_PenDispose($hPenGREEN)
_GDIPlus_PenDispose($hPenBLUE)
_GDIPlus_PenDispose($hPenYELLOW)
_GDIPlus_GraphicsDispose($hGraphic)
Run("Explorer.exe " & $subDirectory)
$Runstate = False
EndFunc
Func Pixel_Distance($x1, $y1, $x2, $y2)
Local $a, $b, $c
If $x2 = $x1 And $y2 = $y1 Then
Return 0
Else
$a = $y2 - $y1
$b = $x2 - $x1
$c = Sqrt($a * $a + $b * $b)
Return $c
EndIf
EndFunc
Func Imgloc2MBR($string)
Local $AllPoints = StringSplit($string, "|", $STR_NOCOUNT)
Local $EachPoint[UBound($AllPoints)][2]
Local $_PixelTopLeft, $_PixelBottomLeft, $_PixelBottomRight, $_PixelTopRight
For $i = 0 To UBound($AllPoints) - 1
Local $temp = StringSplit($AllPoints[$i], ",", $STR_NOCOUNT)
$EachPoint[$i][0] = Number($temp[0])
$EachPoint[$i][1] = Number($temp[1])
Next
_ArraySort($EachPoint, 0, 0, 0, 0)
For $i = 0 To UBound($EachPoint) - 1
If $EachPoint[$i][0] > 60 And $EachPoint[$i][0] < 430 And $EachPoint[$i][1] > 35 And $EachPoint[$i][1] < 336 Then
$_PixelTopLeft &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
ElseIf $EachPoint[$i][0] > 60 And $EachPoint[$i][0] < 430 And $EachPoint[$i][1] > 336 And $EachPoint[$i][1] < 630 Then
$_PixelBottomLeft &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
ElseIf $EachPoint[$i][0] > 430 And $EachPoint[$i][0] < 805 And $EachPoint[$i][1] > 336 And $EachPoint[$i][1] < 630 Then
$_PixelBottomRight &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
ElseIf $EachPoint[$i][0] > 430 And $EachPoint[$i][0] < 805 And $EachPoint[$i][1] > 35 And $EachPoint[$i][1] < 336 Then
$_PixelTopRight &= String("|" & $EachPoint[$i][0] & "-" & $EachPoint[$i][1])
EndIf
Next
If Not StringIsSpace($_PixelTopLeft) Then $_PixelTopLeft = StringTrimLeft($_PixelTopLeft, 1)
If Not StringIsSpace($_PixelBottomLeft) Then $_PixelBottomLeft = StringTrimLeft($_PixelBottomLeft, 1)
If Not StringIsSpace($_PixelBottomRight) Then $_PixelBottomRight = StringTrimLeft($_PixelBottomRight, 1)
If Not StringIsSpace($_PixelTopRight) Then $_PixelTopRight = StringTrimLeft($_PixelTopRight, 1)
Local $NewRedLineString = $_PixelTopLeft & "#" & $_PixelBottomLeft & "#" & $_PixelBottomRight & "#" & $_PixelTopRight
Return $NewRedLineString
EndFunc
Func GetWalls($x, $y, $x1, $y2, $THlevel)
Local $IniX = $x
Local $IniY = $y
Local $aResult[1][6], $aCoordArray[0][0], $aCoords, $aCoordsSplit, $aValue
Local $directory = @ScriptDir & "\images\Resources\Walls"
Local $Redlines = "FV"
Local $minLevel = 0
Local $maxLevel = 0
Switch $THlevel
Case 0 To 6
$minLevel = 3
$maxLevel = 6
Case 7
$minLevel = 4
$maxLevel = 7
Case 8
$minLevel = 5
$maxLevel = 8
Case 9
$minLevel = 6
$maxLevel = 10
Case 10
$minLevel = 6
$maxLevel = 10
Case 11
$minLevel = 7
$maxLevel = 11
Case Else
$minLevel = 0
$maxLevel = 11
EndSwitch
_CaptureRegion2($x, $y, $x1, $y2)
$res = DllCall($hImgLib, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", $Redlines, "Int", $minLevel, "Int", $maxLevel)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys)][6]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i][0] = returnPropertyValue($aKeys[$i], "filename")
$aResult[$i][1] = returnPropertyValue($aKeys[$i], "objectname")
$aResult[$i][2] = returnPropertyValue($aKeys[$i], "objectlevel")
$aResult[$i][3] = returnPropertyValue($aKeys[$i], "filllevel")
$aResult[$i][4] = returnPropertyValue($aKeys[$i], "totalobjects")
$aValue = returnPropertyValue($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
ReDim $aCoordArray[UBound($aCoords)][2]
SetLog("$aResult[$i][0]|filename : " & $aResult[$i][0])
For $j = 0 To UBound($aCoords) - 1
$aCoordsSplit = StringSplit($aCoords[$j], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[$j][0] = $aCoordsSplit[0] + $IniX
$aCoordArray[$j][1] = $aCoordsSplit[1] + $IniY
EndIf
Next
$aResult[$i][5] = $aCoordArray
Next
EndIf
Local $temp
Local $FinalResult[1][2]
Local $z = 0
For $i = 0 To UBound($aResult) - 1
$temp = $aResult[$i][5]
For $x = 0 To UBound($temp) - 1
$FinalResult[$z][0] = $temp[$x][0]
$FinalResult[$z][1] = $temp[$x][1]
$z += 1
If $i = (UBound($aResult) - 1) And $x = (UBound($temp) - 1) Then ExitLoop (2)
ReDim $FinalResult[$z + 1][2]
Next
Next
_ArraySort($FinalResult, 1, 0, 0, 0)
Setlog(" Â»" & UBound($FinalResult) & " Walls Detected!")
Return $FinalResult
EndFunc
Func PixelNearest($aArrayPoints, $center)
Setlog("Initial PixelNearest")
Local $mindist = 860
Local $MinPixel[3]
Local $Distance = 860
For $i = 0 To UBound($aArrayPoints) - 1
If $aArrayPoints[$i][0] = $center[0] And $aArrayPoints[$i][1] = $center[1] Then
$Distance = 0
Else
$Distance = Ceiling(Sqrt(($aArrayPoints[$i][0] - $center[0]) ^ 2 + ($aArrayPoints[$i][1] - $center[1]) ^ 2))
EndIf
If $Distance < $mindist Then
$mindist = $Distance
$MinPixel[0] = $aArrayPoints[$i][0]
$MinPixel[1] = $aArrayPoints[$i][1]
$MinPixel[2] = $mindist
EndIf
Next
Setlog("End PixelNearest")
If $mindist <> 860 Then Return $MinPixel
If $mindist = 860 Then Return -1
EndFunc
Func PixelToDeployEQ($aArrayPoints, $WallNearBuilding, $radius)
Setlog("Initial PixelToDeployEQ")
Local $MinPixel[1][3]
Local $Distance = 860
Local $z = 0
Local $PixelNearest[2] = [0, 0]
Local $Pixelfarest[2] = [0, 0]
Local $Pixelfarest2[2] = [0, 0]
Local $PixelToDeploy[2] = [0, 0]
Setlog("Initial PixelToDeployEQ 2")
If UBound($aArrayPoints) < 2 Then Return $PixelToDeploy
Setlog("Initial PixelToDeployEQ 3")
For $i = 0 To UBound($aArrayPoints) - 1
If $aArrayPoints[$i][0] = $WallNearBuilding[0] And $aArrayPoints[$i][1] = $WallNearBuilding[1] Then
$Distance = 0
Else
$Distance = Ceiling(Sqrt(($aArrayPoints[$i][0] - $WallNearBuilding[0]) ^ 2 + ($aArrayPoints[$i][1] - $WallNearBuilding[1]) ^ 2))
EndIf
If $Distance < $radius Then
$MinPixel[$z][0] = $aArrayPoints[$i][0]
$MinPixel[$z][1] = $aArrayPoints[$i][1]
$MinPixel[$z][2] = $Distance
$z += 1
If $i = UBound($aArrayPoints) - 1 Then ExitLoop
ReDim $MinPixel[$z + 1][3]
EndIf
Next
Setlog("Initial PixelToDeployEQ 4")
Local $MAX = _ArrayMaxIndex($MinPixel, 1, 0, 0, 2)
Local $MIN = _ArrayMinIndex($MinPixel, 1, 0, 0, 2)
Setlog("Initial PixelToDeployEQ 5")
If UBound($MinPixel) > 1 Then
Setlog("Initial PixelToDeployEQ 6")
$PixelNearest[0] = $MinPixel[$MIN][0]
$PixelNearest[1] = $MinPixel[$MIN][1]
Setlog("$PixelNearest: " & $PixelNearest[0] & "-" & $PixelNearest[1])
$Pixelfarest[0] = $MinPixel[$MAX][0]
$Pixelfarest[1] = $MinPixel[$MAX][1]
Setlog("$Pixelfarest: " & $Pixelfarest[0] & "-" & $Pixelfarest[1])
$PixelToDeploy[0] = Ceiling(Abs($PixelNearest[0] - $Pixelfarest[0]) / 2)
$PixelToDeploy[1] = Ceiling(Abs($PixelNearest[1] - $Pixelfarest[1]) / 2)
Setlog("$PixelToDeploy: " & $PixelToDeploy[0] & "-" & $PixelToDeploy[1])
Setlog("Initial PixelToDeployEQ 7")
If $PixelNearest[0] > $Pixelfarest[0] And $PixelNearest[1] < $Pixelfarest[1] Then
$x = $PixelNearest[0] - $PixelToDeploy[0]
$y = $PixelNearest[1] + $PixelToDeploy[1]
ElseIf $PixelNearest[0] < $Pixelfarest[0] And $PixelNearest[1] < $Pixelfarest[1] Then
$x = $PixelNearest[0] + $PixelToDeploy[0]
$y = $PixelNearest[1] + $PixelToDeploy[1]
ElseIf $PixelNearest[0] > $Pixelfarest[0] And $PixelNearest[1] > $Pixelfarest[1] Then
$x = $PixelNearest[0] - $PixelToDeploy[0]
$y = $PixelNearest[1] - $PixelToDeploy[1]
ElseIf $PixelNearest[0] < $Pixelfarest[0] And $PixelNearest[1] > $Pixelfarest[1] Then
$x = $PixelNearest[0] + $PixelToDeploy[0]
$y = $PixelNearest[1] - $PixelToDeploy[1]
Else
$x = $PixelNearest[0]
$y = $PixelNearest[1]
EndIf
$Pixelfarest2[0] = $x
$Pixelfarest2[1] = $y
Setlog("$Pixelfarest2: " & $Pixelfarest2[0] & "-" & $Pixelfarest2[1])
Return $Pixelfarest2
Else
$Pixelfarest2[0] = $MinPixel[0][0]
$Pixelfarest2[1] = $MinPixel[0][1]
Setlog("$Pixelfarest2   : " & $Pixelfarest2[0] & "-" & $Pixelfarest2[1])
Return $Pixelfarest2
EndIf
EndFunc
Func TestTrainRevamp2()
$Runstate = True
$debugOcr = 1
Setlog("Start......OpenArmy Window.....")
Local $timer = TimerInit()
CheckExistentArmy("Troops")
Setlog("Imgloc Troops Time: " & Round(TimerDiff($timer) / 1000, 2) & "'s")
Setlog("End......OpenArmy Window.....")
$debugOcr = 0
$Runstate = False
EndFunc
Func IIf($Condition, $IfTrue, $IfFalse)
If $Condition = True Then
Return $IfTrue
Else
Return $IfFalse
EndIf
EndFunc
Func _ArryRemoveBlanks(ByRef $Array)
$Counter = 0
For $i = 0 To UBound($Array) - 1
If $Array[$i] <> "" Then
$Array[$Counter] = $Array[$i]
$Counter += 1
EndIf
Next
ReDim $Array[$Counter]
EndFunc
Func ValidateSearchArmyResult($result, $index = 0)
If IsArray($result) Then
If UBound($result) > 0 Then
If StringLen($result[$index][0]) > 0 Then Return True
EndIf
EndIf
Return False
EndFunc
Func _ImageSearch($findImage, $resultPosition, ByRef $x, ByRef $y, $Tolerance)
Return _ImageSearchArea($findImage, $resultPosition, 0, 0, 840, 720, $x, $y, $Tolerance)
EndFunc
Func _ImageSearchArea($findImage, $resultPosition, $x1, $y1, $right, $bottom, ByRef $x, ByRef $y, $Tolerance)
Global $HBMP = $hHBitmap
If $ichkBackground = 0 Then
$HBMP = 0
$x1 += $BSPos[0]
$y1 += $BSPos[1]
$right += $BSPos[0]
$bottom += $BSPos[1]
EndIf
Local $result
If IsString($findImage) Then
If $Tolerance > 0 Then $findImage = "*" & $Tolerance & " " & $findImage
If $HBMP = 0 Then
$result = DllCall($pImageLib, "str", "ImageSearch", "int", $x1, "int", $y1, "int", $right, "int", $bottom, "str", $findImage)
Else
$result = DllCall($pImageLib, "str", "ImageSearchEx", "int", $x1, "int", $y1, "int", $right, "int", $bottom, "str", $findImage, "ptr", $HBMP)
EndIf
Else
$result = DllCall($pImageLib, "str", "ImageSearchExt", "int", $x1, "int", $y1, "int", $right, "int", $bottom, "int", $Tolerance, "ptr", $findImage, "ptr", $HBMP)
EndIf
If @error Then _logErrorDLLCall($pImageLib, @error)
If IsArray($result) Then
If $result[0] = "0" Then Return 0
Else
SetLog("Error: Image Search not working...", $COLOR_RED)
Return 1
EndIf
$array = StringSplit($result[0], "|")
If (UBound($array) >= 4) Then
$x = Int(Number($array[2]))
$y = Int(Number($array[3]))
If $resultPosition = 1 Then
$x = $x + Int(Number($array[4]) / 2)
$y = $y + Int(Number($array[5]) / 2)
EndIf
$x -= $x1
$y -= $y1
Return 1
EndIf
EndFunc
Func _ImageSearchAreaImgLoc($findImage, $resultPosition, $x1, $y1, $right, $bottom, ByRef $x, ByRef $y, $Tolerance)
Local $ToleranceImgLoc = Number($Tolerance) / 100
Local $sArea = Int($x1) & "," & Int($y1) & "|" & Int($right) & "," & Int($y1) & "|" & Int($right) & "," & Int($bottom) & "|" & Int($x1) & "," & Int($bottom)
Local $MaxReturnPoints = 1
Local $res = DllCall($hImgLib, "str", "SearchTile", "handle", $hHBitmap, "str", $findImage, "float", $ToleranceImgLoc, "str", $sArea, "Int", $MaxReturnPoints)
If @error Then _logErrorDLLCall($pImgLib, @error)
If IsArray($res) Then
If $res[0] = "0" Or $res[0] = "" Then
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0] & ", " & $findImage, $COLOR_RED)
Else
Local $expRet = StringSplit($res[0], "|", $STR_NOCOUNT)
Local $posPoint = StringSplit($expRet[1], ",", $STR_NOCOUNT)
If UBound($posPoint) >= 2 Then
$x = Int($posPoint[0])
$y = Int($posPoint[1])
If $resultPosition = 1 Then
Local $sImgInfo = _ImageGetInfo($findImage)
Local $iTileWidth = _ImageGetParam($sImgInfo, "Width")
Local $iTileHeight = _ImageGetParam($sImgInfo, "Height")
$x = $x + Int(Number($iTileWidth) / 2)
$y = $y + Int(Number($iTileHeight) / 2)
EndIf
$x -= $x1
$y -= $y1
Return 1
Else
EndIf
EndIf
EndIf
Return 0
EndFunc
Func _ImageSearchAreaImgLocZoom($findImage, $resultPosition, $x1, $y1, $right, $bottom, ByRef $x, ByRef $y)
$pImgLib = $LibDir & "\MyBotRunImgLoc.dll"
$hImgLib = DllOpen($pImgLib)
Local $sArea = Int($x1) & "," & Int($y1) & "|" & Int($right) & "," & Int($y1) & "|" & Int($right) & "," & Int($bottom) & "|" & Int($x1) & "," & Int($bottom)
Local $MaxReturnPoints = 1
Local $res = DllCall($hImgLib, "str", "FindTile", "handle", $hHBitmap, "str", $findImage,  "str", $sArea, "Int", $MaxReturnPoints)
If @error Then _logErrorDLLCall($pImgLib, @error)
If IsArray($res) Then
If $res[0] = "0" Or $res[0] = "" Then
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0] & ", " & $findImage, $COLOR_ERROR)
Else
Local $expRet = StringSplit($res[0], "|", $STR_NOCOUNT)
Local $posPoint = StringSplit($expRet[1], ",", $STR_NOCOUNT)
If UBound($posPoint) >= 2 Then
$x = Int($posPoint[0])
$y = Int($posPoint[1])
If $resultPosition <> 1 Then
Local $sImgInfo = _ImageGetInfo($findImage)
Local $iTileWidth = _ImageGetParam($sImgInfo, "Width")
Local $iTileHeight = _ImageGetParam($sImgInfo, "Height")
$x -= Int(Number($iTileWidth) / 2)
$y -= Int(Number($iTileHeight) / 2)
EndIf
$x -= $x1
$y -= $y1
$pImgLib = $LibDir & "\ImgLoc.dll"
$hImgLib = DllOpen($pImgLib)
Return 1
Else
EndIf
EndIf
EndIf
$pImgLib = $LibDir & "\ImgLoc.dll"
$hImgLib = DllOpen($pImgLib)
Return 0
EndFunc
Func LoadElixirImage()
Local $x
Local $path = @ScriptDir & "\images\ELIXIR\"
Local $useimages
If $iDetectedImageType = 0 Then
$useimages = "*T*.bmp|*SNOW*.bmp"
ElseIf $iDetectedImageType = 1 Then
$useimages = "*T*.bmp|*NORM*.bmp"
Else
$useimages = "*T*.bmp"
EndIf
For $t = 0 To $maxElixirLevel
If Eval("chkLvl" & $t + 6 & "Enabled") <> "1" Or Eval("cmbLvl" & $t + 6 & "Fill") > 2 Then
Assign("ElixirImages" & $t, StringSplit("", ""))
ContinueLoop
EndIf
Assign("ElixirImages" & $t, StringSplit("", ""))
$x = _FileListToArrayRec(@ScriptDir & "\images\ELIXIR\" & $t + 6 & "\", $useimages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) Then Assign("ElixirImages" & $t, $x)
For $i = 0 To UBound(Eval("ElixirImages" & $t)) - 1
ConsoleWrite("$ElixirImages" & $t & "[" & $i & "]:" & Execute("$ElixirImages" & $t & "[" & $i & "]") & @CRLF)
Next
If UBound($x) Then Assign("ElixirImagesStat" & $t, $x)
For $i = 1 To UBound(Eval("ElixirImagesStat" & $t)) - 1
Local $tempvect = Eval("ElixirImagesStat" & $t)
$tempvect[$i] = IniRead($statChkDeadBase, $t, Execute("$ElixirImages" & $t & "[" & $i & "]"), "0")
Assign("ElixirImagesStat" & $t, $tempvect)
Next
Next
EndFunc
Func LoadElixirImage75Percent()
Local $x
Local $path = @ScriptDir & "\images\ELIXIR75PERCENT\"
Local $useimages
If $iDetectedImageType = 0 Then
$useimages = "*T*.bmp|*SNOW*.bmp"
ElseIf $iDetectedImageType = 1 Then
$useimages = "*T*.bmp|*NORM*.bmp"
Else
$useimages = "*T*.bmp"
EndIf
For $t = 0 To $maxElixirLevel
If Eval("chkLvl" & $t + 6 & "Enabled") <> "1" Or Eval("cmbLvl" & $t + 6 & "Fill") > 1 Then
Assign("ElixirImages" & $t & "_75percent", StringSplit("", ""))
ContinueLoop
EndIf
Assign("ElixirImages" & $t & "_75percent", StringSplit("", ""))
$x = _FileListToArrayRec(@ScriptDir & "\images\ELIXIR75PERCENT\" & $t + 6 & "\", $useimages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) Then Assign("ElixirImages" & $t & "_75percent", $x)
For $i = 0 To UBound(Eval("ElixirImages" & $t & "_75percent")) - 1
ConsoleWrite("$ElixirImages" & $t & "_75percent" & "[" & $i & "]:" & Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]") & @CRLF)
Next
If UBound($x) Then Assign("ElixirImagesStat" & $t & "_75percent", $x)
For $i = 1 To UBound(Eval("ElixirImagesStat" & $t & "_75percent")) - 1
Local $tempvect = Eval("ElixirImagesStat" & $t & "_75percent")
$tempvect[$i] = IniRead($statChkDeadBase75percent, $t, Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), "0")
Assign("ElixirImagesStat" & $t & "_75percent", $tempvect)
Next
Next
EndFunc
Func LoadElixirImage50Percent()
Local $x
Local $path = @ScriptDir & "\images\ELIXIR50PERCENT\"
Local $useimages
If $iDetectedImageType = 0 Then
$useimages = "*T*.bmp|*SNOW*.bmp"
ElseIf $iDetectedImageType = 1 Then
$useimages = "*T*.bmp|*NORM*.bmp"
Else
$useimages = "*T*.bmp"
EndIf
For $t = 0 To $maxElixirLevel
If Eval("chkLvl" & $t + 6 & "Enabled") <> "1" Or Eval("cmbLvl" & $t + 6 & "Fill") > 0 Then
Assign("ElixirImages" & $t & "_50percent", StringSplit("", ""))
ContinueLoop
EndIf
Assign("ElixirImages" & $t & "_50percent", StringSplit("", ""))
$x = _FileListToArrayRec(@ScriptDir & "\images\ELIXIR50PERCENT\" & $t + 6 & "\", $useimages, $FLTAR_FILES, $FLTAR_NORECUR, $FLTAR_SORT, $FLTAR_NOPATH)
If UBound($x) Then Assign("ElixirImages" & $t & "_50percent", $x)
For $i = 0 To UBound(Eval("ElixirImages" & $t & "_50percent")) - 1
ConsoleWrite("$ElixirImages" & $t & "_50percent" & "[" & $i & "]:" & Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]") & @CRLF)
Next
If UBound($x) Then Assign("ElixirImagesStat" & $t & "_50percent", $x)
For $i = 1 To UBound(Eval("ElixirImagesStat" & $t & "_50percent")) - 1
Local $tempvect = Eval("ElixirImagesStat" & $t & "_50percent")
$tempvect[$i] = IniRead($statChkDeadBase50percent, $t, Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), "0")
Assign("ElixirImagesStat" & $t & "_50percent", $tempvect)
Next
Next
EndFunc
Func checkDeadBase()
Return ZombieSearch2()
EndFunc
Global $AdjustTolerance = 0
Global $Tolerance[5][11] = [[55, 55, 55, 80, 70, 70, 75, 80, 0, 75, 65], [55, 55, 55, 80, 80, 70, 75, 80, 0, 75, 65], [55, 55, 55, 80, 80, 70, 75, 80, 0, 75, 65], [55, 55, 55, 80, 80, 60, 75, 75, 0, 75, 60], [55, 55, 55, 80, 80, 70, 75, 80, 0, 75, 65]]
Global $ZC = 0, $ZombieCount = 0
Global $ZombieFileSets = 3
Global $ZSExclude = 0
Global $Lx[4] = [0, 400, 0, 400]
Global $Ly[4] = [0, 0, 265, 265]
Global $Rx[4] = [460, 860, 400, 860]
Global $Ry[4] = [325, 325, 590, 590]
Global $Area[5][11][4], $IS_x[11][4], $IS_y[11][4], $E[5][11]
#Region ### Check Dead Base Functions ###
Func ZombieSearch()
_CaptureRegion()
$ZombieCount = 0
$ZC = 0
For $s = 0 To ($ZombieFileSets - 1) Step 1
For $p = 10 To 0 + $ZSExclude Step -1
If FileExists($E[$s][$p]) Then
$Area[$s][$p][0] = _ImageSearch($E[$s][$p], 1, $IS_x[$p][0], $IS_y[$p][0], $Tolerance[$s][$p] + $AdjustTolerance)
If $Area[$s][$p][0] > 0 Then
$ZC = 1
ExitLoop (2)
EndIf
Else
$Area[$s][$p][0] = 0
EndIf
Next
Next
$ZombieCount += $ZC
If $ZombieCount > 0 Then
Return True
Else
Return False
EndIf
EndFunc
#EndRegion ### Check Dead Base Functions ###
Func ZombieSearch2($limit = 0, $tolerancefix = 0)
Local $hTimer = TimerInit()
Local $count = 0
Local $ElixirLocation
Local $ElixirLocationx, $ElixirLocationy
Local $ZombieFound = False
Local $LogCase = $debugBuildingPos
If $LogCase = 0 Then $LogCase = 2
Local $Tolerance
Local $max100 = 0, $max75 = 0, $max50 = 0
For $i = 0 To $maxElixirLevel
If Int(Execute("$ElixirImages" & $i & "[0]")) > $max100 Then $max100 = Int(Execute("$ElixirImages" & $i & "[0]"))
Next
If $limit > 0 And $max100 > 0 And $limit <= $max100 Then $max100 = $limit
For $i = 0 To $maxElixirLevel
If Int(Execute("$ElixirImages" & $i & "_75percent" & "[0]")) > $max75 Then $max75 = Int(Execute("$ElixirImages" & $i & "_75percent" & "[0]"))
Next
If $limit > 0 And $max75 > 0 And $limit <= $max75 Then $max75 = $limit
For $i = 0 To $maxElixirLevel
If Int(Execute("$ElixirImages" & $i & "_50percent" & "[0]")) > $max50 Then $max50 = Int(Execute("$ElixirImages" & $i & "_50percent" & "[0]"))
Next
If $limit > 0 And $max50 > 0 And $limit <= $max50 Then $max50 = $limit
_CaptureRegion()
For $i = 1 To $max50
For $t = 0 To $maxElixirLevel
If Int(Execute("$ElixirImages" & $t & "_50percent" & "[0]")) >= $i Then
$count += 1
If $tolerancefix > 0 Then
$Tolerance = $tolerancefix
Else
$Tolerance = Number(StringMid(Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), StringInStr(Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), "T") + 1, StringInStr(Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), ".bmp") - StringInStr(Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), "T") - 1))
EndIf
LogItInCase("Examine image 50% n." & $i, $LogCase)
LogItInCase(" for ElixirImage " & $t & "_50percent", $LogCase)
LogItInCase(" - image name: " & Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), $LogCase)
LogItInCase(" - tolerance: <" & StringMid(Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), StringInStr(Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), "T") + 1, StringInStr(Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), ".BMP") - StringInStr(Execute("$ElixirImages" & $t & "[" & $i & "]"), "T") - 1) & ">", $LogCase)
LogItInCase(" - tolerancecalc: " & $Tolerance, $LogCase)
LogItInCase(@CRLF, $LogCase)
$ElixirLocation = _ImageSearch(@ScriptDir & "\images\ELIXIR50PERCENT\" & $t + 6 & "\" & Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), 1, $ElixirLocationx, $ElixirLocationy, $Tolerance + ($DevMode = 1 ? Number($toleranceoffset) : 0))
LogItInCase("Imagesearch return: ", $LogCase)
LogItInCase("- ElixirLocation : " & $ElixirLocation, $LogCase)
LogItInCase("- ElixirLocationx : " & $ElixirLocationx, $LogCase)
LogItInCase("- TElixirLocationy : " & $ElixirLocationy, $LogCase)
LogItInCase(@CRLF, $LogCase)
If $ElixirLocation = 1 Then
If $debugBuildingPos = 1 Then
Setlog("#*# ZombieSearch2: ", $COLOR_TEAL)
Setlog("  - Position (" & $ElixirLocationx & "," & $ElixirLocationy & ")", $COLOR_TEAL)
Setlog("  - Elixir Collector 50% level " & $t + 6, $COLOR_TEAL)
Setlog("  - Image Match " & Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), $COLOR_TEAL)
Setlog("  - IsInsidediamond: " & isInsideDiamondXY($ElixirLocationx, $ElixirLocationy), $COLOR_TEAL)
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_TEAL)
SetLog("  - Images checked: " & $count, $COLOR_TEAL)
EndIf
If isInsideDiamondXY($ElixirLocationx, $ElixirLocationy) = True Then
Local $tempvect = Eval("ElixirImagesStat" & $t & "_50percent")
$tempvect[$i] += 1
Assign("ElixirImagesStat" & $t & "_50percent", $tempvect)
$ZombieFound = True
SaveStatChkDeadBase()
ExitLoop (2)
Else
ContinueLoop
EndIf
EndIf
EndIf
Next
Next
If $ZombieFound = False Then
For $i = 1 To $max75
For $t = 0 To $maxElixirLevel
If Int(Execute("$ElixirImages" & $t & "_75percent" & "[0]")) >= $i Then
$count += 1
If $tolerancefix > 0 Then
$Tolerance = $tolerancefix
Else
$Tolerance = Number(StringMid(Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), StringInStr(Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), "T") + 1, StringInStr(Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), ".bmp") - StringInStr(Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), "T") - 1))
EndIf
LogItInCase("Examine image 75% n." & $i, $LogCase)
LogItInCase(" for ElixirImage " & $t & "_75percent", $LogCase)
LogItInCase(" - image name: " & Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), $LogCase)
LogItInCase(" - tolerance: <" & StringMid(Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), StringInStr(Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), "T") + 1, StringInStr(Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), ".BMP") - StringInStr(Execute("$ElixirImages" & $t & "[" & $i & "]"), "T") - 1) & ">", $LogCase)
LogItInCase(" - tolerancecalc: " & $Tolerance, $LogCase)
LogItInCase(@CRLF, $LogCase)
$ElixirLocation = _ImageSearch(@ScriptDir & "\images\ELIXIR75PERCENT\" & $t + 6 & "\" & Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), 1, $ElixirLocationx, $ElixirLocationy, $Tolerance + ($DevMode = 1 ? Number($toleranceoffset) : 0))
LogItInCase("Imagesearch return: ", $LogCase)
LogItInCase("- ElixirLocation : " & $ElixirLocation, $LogCase)
LogItInCase("- ElixirLocationx : " & $ElixirLocationx, $LogCase)
LogItInCase("- TElixirLocationy : " & $ElixirLocationy, $LogCase)
LogItInCase(@CRLF, $LogCase)
If $ElixirLocation = 1 Then
If $debugBuildingPos = 1 Then
Setlog("#*# ZombieSearch2: ", $COLOR_TEAL)
Setlog("  - Position (" & $ElixirLocationx & "," & $ElixirLocationy & ")", $COLOR_TEAL)
Setlog("  - Elixir Collector 75% level " & $t + 6, $COLOR_TEAL)
Setlog("  - Image Match " & Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), $COLOR_TEAL)
Setlog("  - IsInsidediamond: " & isInsideDiamondXY($ElixirLocationx, $ElixirLocationy), $COLOR_TEAL)
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_TEAL)
SetLog("  - Images checked: " & $count, $COLOR_TEAL)
EndIf
If isInsideDiamondXY($ElixirLocationx, $ElixirLocationy) = True Then
Local $tempvect = Eval("ElixirImagesStat" & $t & "_75percent")
$tempvect[$i] += 1
Assign("ElixirImagesStat" & $t & "_75percent", $tempvect)
$ZombieFound = True
SaveStatChkDeadBase()
ExitLoop (2)
Else
ContinueLoop
EndIf
EndIf
EndIf
Next
Next
EndIf
If $ZombieFound = False Then
For $i = 1 To $max100
For $t = 0 To $maxElixirLevel
If Int(Execute("$ElixirImages" & $t & "[0]")) >= $i Then
$count += 1
If $tolerancefix > 0 Then
$Tolerance = $tolerancefix
Else
$Tolerance = Number(StringMid(Execute("$ElixirImages" & $t & "[" & $i & "]"), StringInStr(Execute("$ElixirImages" & $t & "[" & $i & "]"), "T") + 1, StringInStr(Execute("$ElixirImages" & $t & "[" & $i & "]"), ".bmp") - StringInStr(Execute("$ElixirImages" & $t & "[" & $i & "]"), "T") - 1))
EndIf
LogItInCase("Examine image 100% n." & $i, $LogCase)
LogItInCase(" for ElixirImage " & $t, $LogCase)
LogItInCase(" - image name: " & Execute("$ElixirImages" & $t & "[" & $i & "]"), $LogCase)
LogItInCase(" - tolerance: <" & StringMid(Execute("$ElixirImages" & $t & "[" & $i & "]"), StringInStr(Execute("$ElixirImages" & $t & "[" & $i & "]"), "T") + 1, StringInStr(Execute("$ElixirImages" & $t & "[" & $i & "]"), ".BMP") - StringInStr(Execute("$ElixirImages" & $t & "[" & $i & "]"), "T") - 1) & ">", $LogCase)
LogItInCase(" - tolerancecalc: " & $Tolerance, $LogCase)
LogItInCase(@CRLF, $LogCase)
$ElixirLocation = _ImageSearch(@ScriptDir & "\images\ELIXIR\" & $t + 6 & "\" & Execute("$ElixirImages" & $t & "[" & $i & "]"), 1, $ElixirLocationx, $ElixirLocationy, $Tolerance + ($DevMode = 1 ? Number($toleranceoffset) : 0))
LogItInCase("Imagesearch return: ", $LogCase)
LogItInCase("- ElixirLocation : " & $ElixirLocation, $LogCase)
LogItInCase("- ElixirLocationx : " & $ElixirLocationx, $LogCase)
LogItInCase("- TElixirLocationy : " & $ElixirLocationy, $LogCase)
LogItInCase(@CRLF, $LogCase)
If $ElixirLocation = 1 Then
If $debugBuildingPos = 1 Then
Setlog("#*# ZombieSearch2: ", $COLOR_TEAL)
Setlog("  - Position (" & $ElixirLocationx & "," & $ElixirLocationy & ")", $COLOR_TEAL)
Setlog("  - Elixir Collector 100% level " & $t + 6, $COLOR_TEAL)
Setlog("  - Image Match " & Execute("$ElixirImages" & $t & "[" & $i & "]"), $COLOR_TEAL)
Setlog("  - IsInsidediamond: " & isInsideDiamondXY($ElixirLocationx, $ElixirLocationy), $COLOR_TEAL)
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_TEAL)
SetLog("  - Images checked: " & $count, $COLOR_TEAL)
EndIf
If isInsideDiamondXY($ElixirLocationx, $ElixirLocationy) = True Then
Local $tempvect = Eval("ElixirImagesStat" & $t)
$tempvect[$i] += 1
Assign("ElixirImagesStat" & $t, $tempvect)
$ZombieFound = True
SaveStatChkDeadBase()
ExitLoop (2)
Else
ContinueLoop
EndIf
EndIf
EndIf
Next
Next
EndIf
If $ZombieFound = False Then
If $debugBuildingPos = 1 Then
Setlog("#*# ZombieSearch2: NONE ", $COLOR_TEAL)
SetLog("  - Calculated  in: " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_TEAL)
SetLog("  - Images checked: " & $count, $COLOR_TEAL)
Setlog(" FOUND = " & $ZombieFound, $COLOR_TEAL)
EndIf
If $debugBuildingPos = 1 And ($limit <> 0 Or $tolerancefix <> 0) Then Setlog("#*# ZombieSearch2: limit= " & $limit & ", tolerancefix=" & $tolerancefix, $COLOR_TEAL)
If $debugImageSave = 1 Then DebugImageSave("ZombieSearch2_NoDeadBaseFound_", True)
If $debugsetlog = 1 Then Setlog("Collectors NO match, dead base not found", $COLOR_DEBUG)
Return False
Else
If $debugBuildingPos = 1 Then
Setlog(" FOUND = " & $ZombieFound, $COLOR_TEAL)
EndIf
If $debugsetlog = 1 Then Setlog("Collectors match, dead base found", $COLOR_DEBUG)
Return True
EndIf
EndFunc
Func SaveStatChkDeadBase()
Local $hFile
$hFile = FileOpen($statChkDeadBase, $FO_UTF16_LE + $FO_OVERWRITE)
If FileExists($statChkDeadBase) Then
For $t = 0 To $maxElixirLevel
For $i = 1 To UBound(Eval("ElixirImages" & $t)) - 1
IniWrite($statChkDeadBase, $t, Execute("$ElixirImages" & $t & "[" & $i & "]"), Execute("$ElixirImagesStat" & $t & "[" & $i & "]"))
Next
Next
EndIf
FileClose($hFile)
$hFile = FileOpen($statChkDeadBase75percent, $FO_UTF16_LE + $FO_OVERWRITE)
If FileExists($statChkDeadBase75percent) Then
For $t = 0 To $maxElixirLevel
For $i = 1 To UBound(Eval("ElixirImages" & $t & "_75percent")) - 1
IniWrite($statChkDeadBase75percent, $t, Execute("$ElixirImages" & $t & "_75percent" & "[" & $i & "]"), Execute("$ElixirImagesStat" & $t & "_75percent" & "[" & $i & "]"))
Next
Next
EndIf
FileClose($hFile)
$hFile = FileOpen($statChkDeadBase50percent, $FO_UTF16_LE + $FO_OVERWRITE)
If FileExists($statChkDeadBase50percent) Then
For $t = 0 To $maxElixirLevel
For $i = 1 To UBound(Eval("ElixirImages" & $t & "_50percent")) - 1
IniWrite($statChkDeadBase50percent, $t, Execute("$ElixirImages" & $t & "_50percent" & "[" & $i & "]"), Execute("$ElixirImagesStat" & $t & "_50percent" & "[" & $i & "]"))
Next
Next
EndIf
FileClose($hFile)
EndFunc
Func LogItInCase($String, $Case)
Switch $Case
Case 1
If $String = @CRLF Or $String = @CR Or $String = @LF Then
SetLog("=========================")
Return True
EndIf
SetLog($String)
Return True
Case 2
ConsoleWrite($String)
Return True
Case Else
Return False
EndSwitch
Return False
EndFunc
Func CheckWall()
If _Sleep(500) Then Return
Local $levelWall = $icmbWalls + 4
Local $listPixel[0]
Local $DebugIt = 0
$hTimer = TimerInit()
_CaptureRegion2()
SetLog("Searching for Wall(s) level: " & $levelWall, $COLOR_GREEN)
Local $directory = @ScriptDir & "\images\Resources\WallUpgrade\" & $levelWall & "\"
Local $result = SearchWalls($directory, $levelWall, $levelWall)
If $DebugIt = 2 Then SaveDebugImageWall2($result)
SetMostPositionsFound($result)
ClickP($aAway, 1, 0, "#0505")
If Not $result[0][0] = "" And UBound($result) > 0 Then
Local $listPixelTemp = GetListPixel($result[0][0])
_ArrayAdd($listPixel, $listPixelTemp)
EndIf
Setlog("Time Taken: " & Round(TimerDiff($hTimer) / 1000, 2) & "'s")
If (UBound($listPixel) = 0) Then
SetLog("No wall(s) level: " & $levelWall & " found.", $COLOR_RED)
Else
If $DebugIt = 1 Then SaveDebugImageWall($listPixel, $result[0][3])
SetLog("Found: " & UBound($listPixel) & " possible Wall position(s).", $COLOR_GREEN)
SetLog("Checking if found positions are a Wall and of desired level.", $COLOR_GREEN)
PushMsg("FoundWalls")
For $i = 0 To UBound($listPixel) - 1
Local $pixel = $listPixel[$i]
Local $xCompensation = 6
Local $yCompensation = 4
For $j = 0 To 1
GemClick($pixel[0] + $xCompensation, $pixel[1] + $yCompensation)
If _Sleep(500) Then Return
$aResult = BuildingInfo(245, 520 + $bottomOffsetY)
If $aResult[0] = 2 Then
If StringInStr($aResult[1], "wall") = True And Number($aResult[2]) = ($icmbWalls + 4) Then
Setlog("Position No: " & $i + 1 & " is a Wall Level: " & $icmbWalls + 4 & ".")
Return True
Else
If $debugSetlog Then
ClickP($aAway, 1, 0, "#0931")
Setlog("Position No: " & $i + 1 & " is not a Wall Level: " & $icmbWalls + 4 & ". It was: " & $aResult[1] & ", " & $aResult[2] & " at: (" & $pixel[0] + $xCompensation & "," & $pixel[1] + $yCompensation & ").", $COLOR_DEBUG)
Else
ClickP($aAway, 1, 0, "#0932")
Setlog("Position No: " & $i + 1 & " is not a Wall Level: " & $icmbWalls + 4 & ".", $COLOR_RED)
EndIf
EndIf
Else
ClickP($aAway, 1, 0, "#0933")
$xCompensation = 4
$yCompensation = 7
EndIf
Next
Next
EndIf
Return False
EndFunc
Func SetMostPositionsFound(ByRef $Positions)
Local $i_ub = UBound($Positions)
For $i_count = 0 To $i_ub - 2
Local $i_se = $i_count
For $x_count = $i_count To $i_ub - 1
If Number($Positions[$i_se][2]) < Number($Positions[$x_count][2]) Then $i_se = $x_count
Next
Local $i_hld = $Positions[$i_count][2]
$Positions[$i_count][0] = $Positions[$i_se][0]
$Positions[$i_count][1] = $Positions[$i_se][1]
$Positions[$i_count][2] = $Positions[$i_se][2]
$Positions[$i_count][3] = $Positions[$i_se][3]
$Positions[$i_se][0] = $Positions[$i_count][0]
$Positions[$i_se][1] = $Positions[$i_count][1]
$Positions[$i_se][2] = $i_hld
$Positions[$i_se][3] = $Positions[$i_count][3]
Next
For $i = UBound($Positions) - 1 To 1 Step -1
_ArrayDelete($Positions, $i)
Next
EndFunc
Func SaveDebugImageWall($listPixel, $TxtName, $SaveLQImageAlso = False)
_CaptureRegion2()
$hImage = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
$hGraphics = _GDIPlus_ImageGetGraphicsContext($hImage)
Local $hBrush
_GDIPlus_GraphicsFillRect($hGraphics, 0, 0, 250, 110)
_GDIPlus_GraphicsFillRect($hGraphics, 656, 0, 204, 203)
_GDIPlus_GraphicsFillRect($hGraphics, 260, 0, 335, 55)
_GDIPlus_GraphicsFillRect($hGraphics, 0, 485, 120, 247)
$hBrush = _GDIPlus_BrushCreateSolid(0xFF000029)
If $aCCPos[0] = -1 Or $aCCPos[1] = -1 Then
Setlog("Debug Image warning: Locate the Clan Castle to hide the clanname!", $COLOR_RED)
EndIf
If $aCCPos[0] <> -1 Then _GDIPlus_GraphicsFillRect($hGraphics, $aCCPos[0] - $IsCCAutoLocated[2], $aCCPos[1] - $IsCCAutoLocated[3], 66, 20, $hBrush)
Local $hPen = _GDIPlus_PenCreate(0xFFFEDCBA, 2)
Local $i
For $i = 0 To UBound($listPixel) - 1
Local $pixel = $listPixel[$i]
_GDIPlus_GraphicsDrawRect($hGraphics, $pixel[0], $pixel[1], 5, 5, $hPen)
Next
$hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
$hFormat = _GDIPlus_StringFormatCreate()
$hFamily = _GDIPlus_FontFamilyCreate("Arial")
$hFont = _GDIPlus_FontCreate($hFamily, 22, 2)
$tLayout = _GDIPlus_RectFCreate(295, 670, 550, 30)
_GDIPlus_GraphicsDrawStringEx($hGraphics, "Found Positions: " & $i, $hFont, $tLayout, $hFormat, $hBrush)
$i = 0
$Date = @MDAY & "." & @MON & "." & @YEAR
$Time = @HOUR & "." & @MIN & "." & @SEC
$TxtName = "(" & $TxtName & ") "
Local $savefolder = $dirTempDebug
$savefolder = $dirTempDebug & "WallUpgrade" & "\"
DirCreate($savefolder)
Local $extension = "png"
Local $exist = True
Local $i = 1
Local $first = True
Local $filename = "", $filenameLQ = ""
While $exist
If $first Then
$first = False
$filename = $savefolder & $TxtName & $Date & " at " & $Time & "." & $extension
$filenameLQ = $savefolder & "[LQ]" & $TxtName & $Date & " at " & $Time & "." & $extension
If FileExists($filename) = 1 Then
$exist = True
Else
$exist = False
EndIf
Else
$filename = $savefolder & $TxtName & $Date & " at " & $Time & " (" & $i & ")." & $extension
$filenameLQ = $savefolder & "[LQ]" & $TxtName & $Date & " at " & $Time & " (" & $i & ")." & $extension
If FileExists($filename) = 1 Then
$i += 1
Else
$exist = False
EndIf
EndIf
WEnd
_GDIPlus_ImageSaveToFile($hImage, $filename)
If $SaveLQImageAlso = True Then
Local $sImgCLSID = _GDIPlus_EncodersGetCLSID("jpg")
Local $tGUID = _WinAPI_GUIDFromString($sImgCLSID)
Local $tParams = _GDIPlus_ParamInit(1)
Local $tData = DllStructCreate("int Quality")
DllStructSetData($tData, "Quality", 50)
Local $pData = DllStructGetPtr($tData)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGQUALITY, 1, $GDIP_EPTLONG, $pData)
_GDIPlus_ImageSaveToFileEx($hImage, $filenameLQ, $sImgCLSID, $tParams)
EndIf
_GDIPlus_ImageDispose($hImage)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphics)
Setlog($filename, $COLOR_DEBUG)
If _Sleep($iDelayDebugImageSave1) Then Return
EndFunc
Func SaveDebugImageWall2($result, $SaveLQImageAlso = False)
_CaptureRegion2()
Local $subFolderIndex = 0
For $ArrCounter = 0 To (UBound($result) - 1)
If Not $result[$ArrCounter][3] = "" Then
$hImage = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap2)
$hGraphics = _GDIPlus_ImageGetGraphicsContext($hImage)
Local $hBrush
_GDIPlus_GraphicsFillRect($hGraphics, 0, 0, 250, 110)
_GDIPlus_GraphicsFillRect($hGraphics, 656, 0, 204, 203)
_GDIPlus_GraphicsFillRect($hGraphics, 260, 0, 335, 55)
_GDIPlus_GraphicsFillRect($hGraphics, 0, 485, 120, 247)
$hBrush = _GDIPlus_BrushCreateSolid(0xFF000029)
If $aCCPos[0] = -1 Or $aCCPos[1] = -1 Then
Setlog("Debug Image warning: Locate the Clan Castle to hide the clanname!", $COLOR_RED)
EndIf
If $aCCPos[0] <> -1 Then _GDIPlus_GraphicsFillRect($hGraphics, $aCCPos[0] - $IsCCAutoLocated[2], $aCCPos[1] - $IsCCAutoLocated[3], 66, 20, $hBrush)
Local $hPen = _GDIPlus_PenCreate(0xFFFEDCBA, 2)
Local $i
If Not $result[$ArrCounter][0] = "" Then
Local $sPixels = $result[$ArrCounter][0]
Local $splitedsPixels = StringSplit($sPixels, "|", 2)
For $j = 0 To (UBound($splitedsPixels) - 1)
$ThePixel = StringSplit($splitedsPixels[$j], "-", 2)
_GDIPlus_GraphicsDrawRect($hGraphics, $ThePixel[0], $ThePixel[1], 5, 5, $hPen)
Next
EndIf
$hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
$hFormat = _GDIPlus_StringFormatCreate()
$hFamily = _GDIPlus_FontFamilyCreate("Arial")
$hFont = _GDIPlus_FontCreate($hFamily, 22, 2)
$tLayout = _GDIPlus_RectFCreate(295, 670, 550, 30)
_GDIPlus_GraphicsDrawStringEx($hGraphics, "Found Positions: " & $result[$ArrCounter][2], $hFont, $tLayout, $hFormat, $hBrush)
$i = 0
$Date = @MDAY & "." & @MON & "." & @YEAR
$Time = @HOUR & "." & @MIN & "." & @SEC
Local $TxtName = "(" & $result[$ArrCounter][3] & ") "
Local $savefolder = $dirTempDebug
$savefolder = $dirTempDebug & "WallUpgrade" & "\" & $result[$ArrCounter][1] & "\" & IIf($subFolderIndex >= 1, $subFolderIndex & "\", "")
DirCreate($savefolder)
If $subFolderIndex <= 0 Then
For $SubFolderCounter = 1 To 9999
If FileExists($savefolder & $SubFolderCounter & "\") = False Then
$savefolder &= $SubFolderCounter & "\"
DirCreate($savefolder)
$subFolderIndex = $SubFolderCounter
ExitLoop
EndIf
Next
EndIf
Local $extension = "png"
Local $exist = True
Local $i = 1
Local $first = True
Local $filename = "", $filenameLQ = ""
While $exist
If $first Then
$first = False
$filename = $savefolder & $TxtName & $Date & " at " & $Time & "." & $extension
$filenameLQ = $savefolder & "[LQ]" & $TxtName & $Date & " at " & $Time & "." & $extension
If FileExists($filename) = 1 Then
$exist = True
Else
$exist = False
EndIf
Else
$filename = $savefolder & $TxtName & $Date & " at " & $Time & " (" & $i & ")." & $extension
$filenameLQ = $savefolder & "[LQ]" & $TxtName & $Date & " at " & $Time & " (" & $i & ")." & $extension
If FileExists($filename) = 1 Then
$i += 1
Else
$exist = False
EndIf
EndIf
WEnd
_GDIPlus_ImageSaveToFile($hImage, $filename)
If $SaveLQImageAlso = True Then
Local $sImgCLSID = _GDIPlus_EncodersGetCLSID("jpg")
Local $tGUID = _WinAPI_GUIDFromString($sImgCLSID)
Local $tParams = _GDIPlus_ParamInit(1)
Local $tData = DllStructCreate("int Quality")
DllStructSetData($tData, "Quality", 50)
Local $pData = DllStructGetPtr($tData)
_GDIPlus_ParamAdd($tParams, $GDIP_EPGQUALITY, 1, $GDIP_EPTLONG, $pData)
_GDIPlus_ImageSaveToFileEx($hImage, $filenameLQ, $sImgCLSID, $tParams)
EndIf
_GDIPlus_ImageDispose($hImage)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphics)
Setlog($filename, $COLOR_DEBUG)
EndIf
Next
If _Sleep($iDelayDebugImageSave1) Then Return
EndFunc
Func CheckTombs()
If $ichkTombstones <> 1 Then Return False
Local $hTimer = TimerInit()
Local $directory = @ScriptDir & "\images\Resources\Tombs"
Local $return[7] = ["None", "None", 0, 0, 0, "", ""]
Local $TombsXY[2] = [0, 0]
Local $aResult = returnSingleMatchOwnVillage($directory)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
$TombsXY = $return[5]
If $DebugSetLog = 1 Then SetLog("Filename :" & $return[0], $COLOR_DEBUG)
If $DebugSetLog = 1 Then SetLog("Type :" & $return[1], $COLOR_DEBUG)
If $DebugSetLog = 1 Then SetLog("Total Objects :" & $return[4], $COLOR_DEBUG)
If IsArray($TombsXY) Then
For $j = 0 To UBound($TombsXY) - 1
If $DebugSetLog = 1 Then Setlog("Coords :" & $TombsXY[$j][0] & "," & $TombsXY[$j][1], $COLOR_DEBUG)
If IsMainPage() Then Click($TombsXY[$j][0], $TombsXY[$j][1], 1, 0, "#0430")
Next
EndIf
Setlog("Tombs removed!", $COLOR_TEAL)
Else
Setlog("No Tombs Found!", $COLOR_GREEN)
EndIf
checkMainScreen(False)
EndFunc
Func CleanYard()
If $ichkCleanYard = 0 And $ichkGemsBox = 0 Then Return
Local $hObstaclesTimer = TimerInit()
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
Local $directory = @ScriptDir & "\images\Resources\Obstacles"
Local $Filename = ""
Local $Locate = 0
Local $CleanYardXY
Local $maxReturnPoints = $iFreeBuilderCount
If $iFreeBuilderCount > 0 And $ichkCleanYard = 1 Then
Local $aResult = returnMultipleMatchesOwnVillage($directory, $maxReturnPoints)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
$Filename = $aResult[$i][1]
$CleanYardXY = $aResult[$i][5]
If IsArray($CleanYardXY) Then
For $t = 0 To UBound($CleanYardXY) - 1
If isInsideDiamondXY($CleanYardXY[$t][0], $CleanYardXY[$t][1]) Then
If $DebugSetLog = 1 Then SetLog($Filename & " found (" & $CleanYardXY[$t][0] & "," & $CleanYardXY[$t][1] & ")", $COLOR_DEBUG)
If IsMainPage() Then Click($CleanYardXY[$t][0], $CleanYardXY[$t][1], 1, 0, "#0430")
$Locate = 1
If _Sleep($iDelayCollect3) Then Return
If IsMainPage() Then GemClick($aCleanYard[0], $aCleanYard[1], 1, 0, "#0431")
If _Sleep($iDelayCheckTombs2) Then Return
ClickP($aAway, 2, 300, "#0329")
If _Sleep($iDelayCheckTombs1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount = 0 Then
Setlog("No More Builders available")
If _Sleep(2000) Then Return
ExitLoop (2)
EndIf
EndIf
Next
EndIf
Next
EndIf
EndIf
Local $directoryGemBox = @ScriptDir & "\images\Resources\GemBox"
Local $return[7] = ["None", "None", 0, 0, 0, "", ""]
Local $GemBoxXY[2] = [0, 0]
If $iFreeBuilderCount > 0 And $ichkGemsBox = 1 Then
Local $aResult = returnSingleMatchOwnVillage($directoryGemBox)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
$GemBoxXY = $return[5]
If $DebugSetLog = 1 Then SetLog("Filename :" & $return[0], $COLOR_DEBUG)
If $DebugSetLog = 1 Then SetLog("Type :" & $return[1], $COLOR_DEBUG)
If $DebugSetLog = 1 Then SetLog("Total Objects :" & $return[4], $COLOR_DEBUG)
If IsArray($GemBoxXY) Then
For $j = 0 To UBound($GemBoxXY) - 1
If $DebugSetLog = 1 Then Setlog("Coords :" & $GemBoxXY[$j][0] & "," & $GemBoxXY[$j][1], $COLOR_DEBUG)
If Number($GemBoxXY[$j][0]) > 80 Then
If IsMainPage() Then Click($GemBoxXY[$j][0], $GemBoxXY[$j][1], 1, 0, "#0430")
If _Sleep($iDelayCheckTombs2) Then Return
$Locate = 1
If _Sleep($iDelayCollect3) Then Return
If IsMainPage() Then Click($aCleanYard[0], $aCleanYard[1], 1, 0, "#0431")
If _Sleep($iDelayCheckTombs2) Then Return
ClickP($aAway, 2, 300, "#0329")
If _Sleep($iDelayCheckTombs1) Then Return
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount = 0 Then
Setlog("No More Builders available")
If _Sleep(2000) Then Return
ExitLoop
EndIf
EndIf
Next
EndIf
Setlog("GemBox removed!", $COLOR_TEAL)
Else
Setlog("No GemBox Found!", $COLOR_GREEN)
EndIf
EndIf
If $Locate = 0 Then SetLog("No Obstacles found, Yard is clean!", $COLOR_GREEN)
If $DebugSetLog = 1 Then SetLog("Time: " & Round(TimerDiff($hObstaclesTimer) / 1000, 2) & "'s", $COLOR_DEBUG)
UpdateStats()
ClickP($aAway, 1, 300, "#0329")
EndFunc
Func townHallCheck($check = False)
If $check = True Or  IsSearchModeActive($TS) Or  ($isModeActive[$DB] And (Number($iChkMeetTH[$DB]) > 0 Or Number($ichkMeetTHO[$DB]) > 0)) Or  ($isModeActive[$LB] And (Number($iChkMeetTH[$LB]) > 0 Or Number($ichkMeetTHO[$LB]) > 0)) Then
For $i = 0 To 1
$searchTH = "-"
$THx = 0
$THy = 0
Local $aTownHall = Null
If $i = 0 Then $aTownHall = returnHighestLevelSingleMatch(@ScriptDir & "\images\Resources\TH")
If $i = 1 Then $aTownHall = returnHighestLevelSingleMatch(@ScriptDir & "\images\Resources\TH2")
If $debugImageSave = 1 Then
_CaptureRegion()
Local $editedImage = $hBitmap
Local $subDirectory = $dirTempDebug & "THdetection" & "\"
DirCreate($subDirectory)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = "Thdetection_" & $i & "_" & $Date & "_" & $Time & ".png"
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
If Number($aTownHall[4]) > 0 Then
Local $coords = $aTownHall[5]
If IsArray($coords) Then
For $j = 0 To UBound($coords) - 1
addInfoToDebugImage($hGraphic, $hPen, $aTownHall[0], $coords[0][0], $coords[0][1])
Next
EndIf
EndIf
_GDIPlus_ImageSaveToFile($editedImage, $subDirectory & $fileName)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
If $RunState = False Then Return
If $aTownHall[1] <> "NONE" Then
Return convertToOldTHData($aTownHall)
Else
If $i = 1 then return convertToOldTHData($aTownHall)
EndIf
Next
Else
$THLoc = $searchTH
$THx = 0
$THy = 0
Return ""
EndIf
EndFunc
Func convertToOldTHData($aResult)
$searchTH = "-"
$THLoc = "-"
$THx = 0
$THy = 0
If IsArray($aResult) Then
If $aResult[1] = "" Or $aResult[1] = "NONE" Then
$searchTH = "-"
ElseIf Number($aResult[2]) < 7 And Number($aResult[2]) > 0 Then
$searchTH = "4-6"
ElseIf Number($aResult[2]) >= 7 Then
$searchTH = String($aResult[2])
EndIf
If $aResult[1] = "" Or $aResult[1] = "NONE" Then
$THx = 0
$THy = 0
Else
Local $coords = $aResult[5]
If IsArray($coords) Then
$THx = $coords[0][0]
$THy = $coords[0][1]
Else
$THx = 0
$THy = 0
EndIf
EndIf
If SearchTownHallLoc() = False And $searchTH <> "-" Then
$THLoc = "In"
ElseIf $searchTH <> "-" Then
$THLoc = "Out"
Else
$THLoc = $searchTH
$THx = 0
$THy = 0
EndIf
EndIf
Return " [TH]:" & StringFormat("%2s", $searchTH) & ", " & $THLoc
EndFunc
Func checkMainScreen($Check = True, $CheckZoomout = True)
Local $iCount, $Result
If $Check = True Then
SetLog("Trying to locate Main Screen")
Else
EndIf
If CheckAndroidRunning(False) = False Then Return
getBSPos()
WinGetAndroidHandle()
If $ichkBackground = 0 And $HWnD <> 0 Then
BotToFront()
EndIf
If $AndroidAdbScreencap = False And _WinAPI_IsIconic($HWnD) Then WinSetState($HWnD, "", @SW_RESTORE)
$iCount = 0
While _CheckPixel($aIsMain, $bCapturePixel) = False
WinGetAndroidHandle()
If _Sleep($iDelaycheckMainScreen1) Then Return
$Result = checkObstacles()
If $debugsetlog = 1 Then Setlog("CheckObstacles Result = " & $Result, $COLOR_DEBUG)
If ($Result = False And $MinorObstacle = True) Then
$MinorObstacle = False
ElseIf ($Result = False And $MinorObstacle = False) Then
RestartAndroidCoC()
Else
$Restart = True
EndIf
waitMainScreen()
If Not $RunState Then Return
If @extended Then Return SetError(1, 1, -1)
If @error Then $iCount += 1
If $iCount > 2 Then
SetLog("Unable to fix the window error", $COLOR_RED)
CloseCoC(True)
ExitLoop
EndIf
WEnd
If $CheckZoomout Then ZoomOut()
If Not $RunState Then Return
If $Check = True Then
SetLog("Main Screen Located", $COLOR_GREEN)
Else
EndIf
DisposeWindows()
EndFunc
Func IsWaitingForConnection()
If _ColorCheck(_GetPixelColor(430, 365, True), Hex(0xEF7800, 6), 20) Then
If _ColorCheck(_GetPixelColor(427, 362, True), Hex(0xFF8800, 6), 20) Then
If _ColorCheck(_GetPixelColor(432, 369, True), Hex(0xB75C00, 6), 20) Then
If _ColorCheck(_GetPixelColor(429, 365, True), Hex(0xEF7800, 6), 20) Then
If _ColorCheck(_GetPixelColor(426, 362, True), Hex(0x7F4000, 6), 20) Then
If _ColorCheck(_GetPixelColor(433, 369, True), Hex(0x3F2000, 6), 20) Then
SetLog("CoC is Waiting for Connection...", $COLOR_RED)
CloseCoC(True)
Return True
EndIf
EndIf
EndIf
EndIf
EndIf
EndIf
Return False
EndFunc
Func checkObstacles()
Local $DebugIt = False
Local $x, $y, $result
$MinorObstacle = False
If WinGetAndroidHandle() = 0 Then
If $DebugIt Then SetLog("#cOb# Android not available...", $COLOR_BLUE)
Return True
EndIf
$Message = _PixelSearch($aIsReloadError[0], $aIsReloadError[1], $aIsReloadError[0] + 3, $aIsReloadError[1] + 11, Hex($aIsReloadError[2], 6), $aIsReloadError[3])
If IsArray($Message) Then
_CaptureRegion()
If $debugsetlog = 1 OR $DebugIt Then SetLog("(Inactive=" & _GetPixelColor($aIsInactive[0], $aIsInactive[1]) & ")(DC=" & _GetPixelColor($aIsConnectLost[0], $aIsConnectLost[1]) & ")(OoS=" & _GetPixelColor($aIsCheckOOS[0], $aIsCheckOOS[1]) & ")", $COLOR_DEBUG)
If $debugsetlog = 1 OR $DebugIt Then SetLog("(Maintenance=" & _GetPixelColor($aIsMaintenance[0], $aIsMaintenance[1]) & ")(RateCoC=" & ")", $COLOR_DEBUG)
If $debugsetlog = 1 OR $DebugIt Then SetLog("33B5E5=>true, 282828=>false", $COLOR_DEBUG)
$result = getOcrMaintenanceTime(184, 325 + $midOffsetY)
If StringInStr($result, "device", $STR_NOCASESENSEBASIC) Or  _ImageSearchAreaImgLoc($device, 0, 220, 300 + $midOffsetY, 300, 360 + $midOffsetY, $x, $y, 95) Then
If $sTimeWakeUp > 3600 Then
SetLog("Another Device has connected, waiting " & Floor(Floor($sTimeWakeUp / 60) / 60) & " hours " & Floor(Mod(Floor($sTimeWakeUp / 60), 60)) & " minutes " & Floor(Mod($sTimeWakeUp, 60)) & " seconds", $COLOR_RED)
PushMsg("AnotherDevice3600")
ElseIf $sTimeWakeUp > 60 Then
SetLog("Another Device has connected, waiting " & Floor(Mod(Floor($sTimeWakeUp / 60), 60)) & " minutes " & Floor(Mod($sTimeWakeUp, 60)) & " seconds", $COLOR_RED)
PushMsg("AnotherDevice60")
Else
SetLog("Another Device has connected, waiting " & Floor(Mod($sTimeWakeUp, 60)) & " seconds", $COLOR_RED)
PushMsg("AnotherDevice")
EndIf
If _SleepStatus($sTimeWakeUp * 1000) Then Return
checkObstacles_ReloadCoC($aReloadButton, "#0127")
If _Sleep(2000) Then Return
If $ichkSinglePBTForced = 1 Then $bGForcePBTUpdate = True
checkObstacles_ResetSearch()
Return True
EndIf
If _ImageSearchAreaImgLoc($break, 0, 165, 257 + $midOffsetY, 335, 295 + $midOffsetY, $x, $y, 95) Then
SetLog("Village must take a break, wait ...", $COLOR_RED)
PushMsg("TakeBreak")
If _SleepStatus($iDelaycheckObstacles4) Then Return
checkObstacles_ReloadCoC($aReloadButton, "#0128")
If $ichkSinglePBTForced = 1 Then $bGForcePBTUpdate = True
checkObstacles_ResetSearch()
Return True
EndIf
Select
Case _CheckPixel($aIsInactive, $bNoCapturePixel)
SetLog("Village was Inactive, Reloading CoC...", $COLOR_RED)
If $ichkSinglePBTForced = 1 Then $bGForcePBTUpdate = True
Case _CheckPixel($aIsConnectLost, $bNoCapturePixel)
$result = getOcrMaintenanceTime(171, 358 + $midOffsetY, "Check Obstacles OCR 'policy at super'=")
If StringInStr($result, "policy", $STR_NOCASESENSEBASIC) Then
SetLog("Sorry but account has been banned, Bot must stop!!", $COLOR_RED)
BanMsgBox()
Btnstop()
Return True
EndIf
$result = getOcrMaintenanceTime(171, 337 + $midOffsetY, "Check Obstacles OCR 'prohibited 3rd'= ")
If StringInStr($result, "3rd", $STR_NOCASESENSEBASIC) Then
SetLog("Sorry but account has been banned, Bot must stop!!", $COLOR_RED)
BanMsgBox()
Btnstop()
Return True
EndIf
SetLog("Connection lost, Reloading CoC...", $COLOR_RED)
Case _CheckPixel($aIsCheckOOS, $bNoCapturePixel)
SetLog("Out of Sync Error, Reloading CoC...", $COLOR_RED)
PushMsg("OutOfSync")
Case _CheckPixel($aIsMaintenance, $bNoCapturePixel)
$result = getOcrMaintenanceTime(171, 345 + $midOffsetY, "Check Obstacles OCR Maintenance Break=")
Local $iMaintenanceWaitTime = 0
Select
Case $result = ""
$iMaintenanceWaitTime = $iDelaycheckObstacles4
Case StringInStr($result, "few", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles4
Case StringInStr($result, "10", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles6
Case StringInStr($result, "15", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles6
Case StringInStr($result, "20", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles7
Case StringInStr($result, "30", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles8
Case StringInStr($result, "45", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles9
Case StringInStr($result, "hour", $STR_NOCASESENSEBASIC)
$iMaintenanceWaitTime = $iDelaycheckObstacles10
Case Else
$iMaintenanceWaitTime = $iDelaycheckObstacles4
SetLog("Error reading Maintenance Break time?", $COLOR_RED)
EndSelect
SetLog("Maintenance Break, waiting: " & $iMaintenanceWaitTime / 60000 & " minutes....", $COLOR_RED)
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertMaintenance = 1 Then NotifyPushToBoth("Maintenance Break, waiting: " & $iMaintenanceWaitTime / 60000 & " minutes....")
If $ichkSinglePBTForced = 1 Then $bGForcePBTUpdate = True
If _SleepStatus($iMaintenanceWaitTime) Then Return
checkObstacles_ResetSearch()
Case Else
If $debugImageSave = 1 Then DebugImageSave("ChkObstaclesReloadMsg_")
$result = getOcrMaintenanceTime(171, 325 + $midOffsetY, "Check Obstacles OCR 'Good News!'=")
If StringInStr($result, "new", $STR_NOCASESENSEBASIC) Then
SetLog("Game Update is required, Bot must stop!!", $COLOR_RED)
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertMaintenance = 1 Then NotifyPushToBoth("Game Update is required, Bot must stop!!")
Btnstop()
Return True
EndIf
$result = getOcrRateCoc(228, 380 + $midOffsetY)
If $debugsetlog = 1 Then SetLog("Check Obstacles getOCRRateCoC=" & $result, $COLOR_DEBUG)
If StringInStr($result, "never", $STR_NOCASESENSEBASIC) Then
SetLog("Clash feedback window found, permanently closed!", $COLOR_RED)
PureClick(248, 408 + $midOffsetY, 1, 0, "#9999")
$MinorObstacle = True
Return True
EndIf
$result = getOcrMaintenanceTime(171, 358 + $midOffsetY, "Check Obstacles OCR 'policy at super'=")
If StringInStr($result, "policy", $STR_NOCASESENSEBASIC) Then
SetLog("Sorry but account has been banned, Bot must stop!!", $COLOR_RED)
BanMsgBox()
Btnstop()
Return True
EndIf
$result = getOcrMaintenanceTime(171, 337 + $midOffsetY, "Check Obstacles OCR 'prohibited 3rd'= ")
If StringInStr($result, "3rd", $STR_NOCASESENSEBASIC) Then
SetLog("Sorry but account has been banned, Bot must stop!!", $COLOR_RED)
BanMsgBox()
Btnstop()
Return True
EndIf
SetLog("Warning: Can not find type of Reload error message", $COLOR_RED)
SetDebugLog("OCR Text: " & $result)
EndSelect
checkObstacles_ReloadCoC($aReloadButton, "#0131")
If _Sleep($iDelaycheckObstacles3) Then Return
Return True
EndIf
_CaptureRegion()
If $DebugIt Then SetLog("#cOb# Second Checks", $COLOR_BLUE)
If _ColorCheck(_GetPixelColor(235, 209 + $midOffsetY), Hex(0x9E3826, 6), 20) Then
If $DebugIt Then SetLog("#cOb# Village was Attacked, Clicks Okay...", $COLOR_BLUE)
PureClick(429, 493 + $midOffsetY, 1, 0, "#0132")
$iShouldRearm = True
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
If _CheckPixel($aIsMainGrayed, $bNoCapturePixel) Then
If $DebugIt Then SetLog("#cOb# Click away If things are open...", $COLOR_BLUE)
PureClickP($aAway, 1, 0, "#0133")
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
If _ColorCheck(_GetPixelColor(792, 39), Hex(0xDC0408, 6), 20) Then
If $DebugIt Then SetLog("#cOb# Clicks X", $COLOR_BLUE)
PureClick(792, 39, 1, 0, "#0134")
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
If _CheckPixel($aCancelFight, $bNoCapturePixel) Or _CheckPixel($aCancelFight2, $bNoCapturePixel) Then
If $DebugIt Then SetLog("#cOb# Clicks X 2, $aCancelFight", $COLOR_BLUE)
PureClickP($aCancelFight, 1, 0, "#0135")
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
If _CheckPixel($aChatTab, $bNoCapturePixel) Then
If $DebugIt Then SetLog("#cOb# Clicks chat tab, $aChatTab", $COLOR_BLUE)
PureClickP($aChatTab, 1, 0, "#0136")
$MinorObstacle = True
If _Sleep($iDelaycheckObstacles1) Then Return
Return False
EndIf
If _CheckPixel($aEndFightSceneBtn, $bNoCapturePixel) Then
If $DebugIt Then SetLog("#cOb# If in that victory or defeat scene, $aEndFightSceneBtn", $COLOR_BLUE)
PureClickP($aEndFightSceneBtn, 1, 0, "#0137")
Return True
EndIf
If _CheckPixel($aSurrenderButton, $bNoCapturePixel) Then
If $DebugIt Then SetLog("#cOb# If End battle is available, $aSurrenderButton", $COLOR_BLUE)
ReturnHome(False, False)
Return True
EndIf
If _ImageSearchAreaImgLoc($CocStopped, 0, 250, 328 + $midOffsetY, 618, 402 + $midOffsetY, $x, $y, 95) Then
SetLog("CoC Has Stopped Error .....", $COLOR_RED)
PushMsg("CoCError")
If _Sleep($iDelaycheckObstacles1) Then Return
PureClick(250 + $x, 328 + $midOffsetY + $y, 1, 0, "#0129")
If _Sleep($iDelaycheckObstacles2) Then Return
checkObstacles_ReloadCoC("")
Return True
EndIf
If _CheckPixel($aNoCloudsAttack, $bNoCapturePixel) Then
If $DebugIt Then SetLog("#cOb# Prevent drop of troops while searching, $aNoCloudsAttack", $COLOR_BLUE)
$Message = _PixelSearch(23, 566 + $bottomOffsetY, 36, 580 + $bottomOffsetY, Hex(0xF4F7E3, 6), 10)
If IsArray($Message) Then
PureClick(67, 602 + $bottomOffsetY, 1, 0, "#0138")
If _Sleep($iDelaycheckObstacles2) Then Return
Return True
EndIf
EndIf
If IsPostDefenseSummaryPage() Then
If $DebugIt Then SetLog("#cOb# Is Post Defense Summary Page...", $COLOR_BLUE)
$Message = _PixelSearch(23, 566 + $bottomOffsetY, 36, 580 + $bottomOffsetY, Hex(0xE0E1CE, 6), 10)
If IsArray($Message) Then
PureClick(67, 602 + $bottomOffsetY, 1, 0, "#0138")
If _Sleep($iDelaycheckObstacles2) Then Return
Return True
EndIf
EndIf
If $DebugIt Then SetLog("#cOb# Second Checks FINISHED", $COLOR_BLUE)
Return False
EndFunc
Func checkObstacles_ReloadCoC($point, $debugtxt = "")
CloseCoC(True)
EndFunc
Func checkObstacles_ResetSearch()
$Is_ClientSyncError = False
$Is_SearchLimit = False
$Quickattack = False
$Restart = True
EndFunc
Func BanMsgBox()
Local $MsgBox
Local $stext = "Sorry, your account is banned!!" & @CRLF & "Bot will stop now..."
While 1
PushMsg("BAN")
_ExtMsgBoxSet(4, 1, 0x004080, 0xFFFF00, 20, "Comic Sans MS", 600)
$MsgBox = _ExtMsgBox(48, "Ok", "Banned", $stext, 1, $frmBot)
If $MsgBox = 1 Then Return
_ExtMsgBoxSet(4, 1, 0xFFFF00, 0x004080, 20, "Comic Sans MS", 600)
$MsgBox = _ExtMsgBox(48, "Ok", "Banned", $stext, 1, $frmBot)
If $MsgBox = 1 Then Return
WEnd
EndFunc
Global $iDPI_Ratio = 1
Func GetDPI_Ratio()
Local $hWnd = 0
Local $hDC = DllCall("user32.dll", "long", "GetDC", "long", $hWnd)
If @error Then Return SetError(1, @extended, 0)
Local $aRet = DllCall("gdi32.dll", "long", "GetDeviceCaps", "long", $hDC[0], "long", 90)
If @error Then Return SetError(2, @extended, 0)
$hDC = DllCall("user32.dll", "long", "ReleaseDC", "long", $hWnd, "long", $hDC)
If @error Then Return SetError(3, @extended, 0)
If $aRet[0] = 0 Then $aRet[0] = 96
Return $aRet[0] / 96
EndFunc
Func GUISetFont_DPI($isize, $iweight = "", $iattribute = "", $sfontname = "")
GUISetFont($isize / $iDPI_Ratio, $iweight, $iattribute, $sfontname)
EndFunc
Func SetDPI()
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = "My Bot needs to change your DPI settinng to continue!" & @CRLF & @CRLF &  "You will be required to reboot your PC when done" & @CRLF & @CRLF & "Please close other programs and save you work NOW!" & @CRLF & @CRLF &  "Hit OK to change settings and reboot, or cancel to exit bot"
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,2,"Display Settings Error"), $stext, 120, $frmBot)
If $MsgBox = 1 Then
Local $aRet = DllCall("syssetup.dll", "int", "SetupChangeFontSize", "int_ptr", 0, "wstr", "96")
If @error Then Return SetError(2, @extended, 0)
If $aRet = 0 Then
Setlog("Your Display DPI has been changed!!  Must logoff or restart to complete the chamge!", $COLOR_MAROON)
_Sleep(5000)
Shutdown($SD_REBOOT)
Else
Setlog("Your DPI has not been changed due some unknown error, Return= " & $aRet, $COLOR_MAROON)
EndIf
EndIf
EndFunc
Func isGemOpen($bNeedCaptureRegion = False)
_Sleep($iDelayisGemOpen1)
If _CheckPixel($aIsGemWindow1, $bNeedCaptureRegion) Then
If $debugSetlog = 1 Then Setlog("Gemclick Red X detect", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0140")
Return True
ElseIf _CheckPixel($aIsGemWindow2, $bNeedCaptureRegion) And  _CheckPixel($aIsGemWindow3, $bNeedCaptureRegion) And  _CheckPixel($aIsGemWindow4, $bNeedCaptureRegion) Then
If $debugSetlog = 1 Then Setlog("Gemclick Red Line detect", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0141")
Return True
EndIf
Return False
EndFunc
Func isNoUpgradeLoot($bNeedCaptureRegion = False)
If _ColorCheck(_GetPixelColor(459, 490 + $midOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 494 + $midOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $midOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) Then
If $debugSetlog = 1 Then Setlog("isNoUpgradeLoot Red Zero found", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0142")
Return True
ElseIf _ColorCheck(_GetPixelColor(691, 523 + $midOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 527 + $midOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $midOffsetY, $bNeedCaptureRegion), Hex(0xE70A12, 6), 20) Then
If $debugSetlog = 1 Then Setlog("IsNoUpgradeLoot Hero Red Zero Found", $COLOR_DEBUG)
PureClickP($aAway, 1, 0, "#0143")
Return True
EndIf
Return False
EndFunc
Func isProblemAffect($bNeedCaptureRegion = False)
If Not _ColorCheck(_GetPixelColor(253, 395 + $midOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(373, 395 + $midOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(473, 395 + $midOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(283, 395 + $midOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(320, 395 + $midOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf Not _ColorCheck(_GetPixelColor(594, 395 + $midOffsetY, $bNeedCaptureRegion), Hex(0x282828, 6), 10) Then
Return False
ElseIf _ColorCheck(_GetPixelColor(823, 32, $bNeedCaptureRegion), Hex(0xF8FCFF, 6), 10) Then
Return False
Else
Return True
EndIf
EndFunc
Func checkAttackDisable($iSource, $Result = "")
Local $i = 0, $iCount = 0
Local $iModSource
If $bDisableBreakCheck = True Then Return
If $ichkSinglePBTForced And _DateIsValid($sPBStartTime) Then
Local $iTimeTillPBTstartSec = Int(_DateDiff('s', $sPBStartTime, _NowCalc()))
If $debugSetlog = 1 Then Setlog("PB starts in: " & $iTimeTillPBTstartSec & " Seconds", $COLOR_DEBUG)
If $iTimeTillPBTstartSec >= 0 Then
$iModSource = $iTaBChkTime
Else
Return
EndIf
Else
$iModSource = $iSource
EndIf
Switch $iModSource
Case $iTaBChkAttack
While $Result = "" Or (StringLen($Result) < 3)
$i += 1
If _Sleep($iDelayAttackDisable100) Then Return
$Result = getAttackDisable(346, 182)
If $i >= 3 Then ExitLoop
WEnd
If $debugSetlog = 1 Then Setlog("Attack Personal Break OCR result = " & $Result, $COLOR_DEBUG)
If $Result <> "" Then
If StringInStr($Result, "disable") <> 0 Or StringInStr($Result, "for") <> 0 Or StringInStr($Result, "after") <> 0 Or StringInStr($Result, "have") <> 0 Then
Setlog("Attacking disabled, Personal Break detected...", $COLOR_RED)
If _CheckPixel($aSurrenderButton, $bCapturePixel) Then
ReturnHome(False, False)
Else
CloseCoC()
EndIf
Else
If $debugSetlog = 1 Then Setlog("wrong text string", $COLOR_DEBUG)
Return
EndIf
Else
Return
EndIf
Case $iTaBChkIdle
If $Result = "" Then $Result = getAttackDisable(180, 156 + $midOffsetY)
If _Sleep($iDelayAttackDisable500) Then Return
If $Result = "" Or (StringLen($Result) < 3) Then $Result = getAttackDisable(180, 156 + $midOffsetY)
If $debugSetlog = 1 Then Setlog("Personal Break OCR result = " & $Result, $COLOR_DEBUG)
If $Result <> "" Then
If StringInStr($Result, "been") <> 0 Or StringInStr($Result, "after") <> 0 Or StringInStr($Result, "have") <> 0 Then
Setlog("Online too long, Personal Break detected....", $COLOR_RED)
checkMainScreen()
Else
If $debugSetlog = 1 Then Setlog("wrong text string", $COLOR_DEBUG)
Return
EndIf
Else
Return
EndIf
Case $iTaBChkTime
If $iSource = $iTaBChkAttack Then
While _CheckPixel($aIsAttackPage, $bCapturePixel) = False
If _Sleep($iDelayAttackDisable500) Then Return
$iCount += 1
If $debugSetlog = 1 Then setlog("wait end battle button " & $iCount, $COLOR_DEBUG)
If $iCount > 40 Or isProblemAffect(True) Then
checkObstacles()
ExitLoop
EndIf
WEnd
If _CheckPixel($aIsAttackPage, $bCapturePixel) Then ReturnHome(False, False)
EndIf
If $iSource = $iTaBChkIdle Then
While _CheckPixel($aIsMain, $bCapturePixel) = False
If _Sleep($iDelayAttackDisable500) Then Return
ClickP($aAway, 1, 0, "#0000")
$iCount += 1
If $debugSetlog = 1 Then setlog("wait main page" & $iCount, $COLOR_DEBUG)
If $iCount > 5 Or isProblemAffect(True) Then
checkObstacles()
ExitLoop
EndIf
WEnd
If _Sleep($iDelayAttackDisable500) Then Return
EndIf
If $aShieldStatus[0] = "guard" Then
Setlog("Unable to Force PB, Guard shield present", $COLOR_BLUE)
Else
Setlog("Forcing Early Personal Break Now!!", $COLOR_GREEN)
EndIf
Case Else
Setlog("Misformed $sSource parameter, silly programmer made a mistake!", $COLOR_DEBUG)
Return False
EndSwitch
Setlog("Prepare base before Personal Break..", $COLOR_BLUE)
$bDisableBreakCheck = True
CheckBaseQuick()
$bDisableBreakCheck = False
$Is_ClientSyncError = False
$Is_SearchLimit = False
$Restart = True
Setlog("Time for break, exit now..", $COLOR_BLUE)
PoliteCloseCoC("AttackDisable_")
If _Sleep(1000) Then Return
PushMsg("TakeBreak")
If $iModSource = $iTaBChkTime And $aShieldStatus[0] <> "guard" Then
Setlog("Personal Break Reset log off: " & $iValueSinglePBTimeForced & " Minutes", $COLOR_BLUE)
WaitnOpenCoC($iValueSinglePBTimeForced * 60 * 1000, True)
Else
WaitnOpenCoC(20000, True)
EndIf
$sPBStartTime = ""
For $i = 0 To UBound($aShieldStatus) - 1
$aShieldStatus[$i] = ""
Next
EndFunc
Func RemoveGhostTrayIcons($IconTextPart_notUsedAnymore = "")
Local $iGhostCount = 0
Local $i, $handle, $pid
Local $count = _SysTrayIconCount()
For $i = $count - 1 To 0 Step -1
$handle = _SysTrayIconHandle($i)
$pid = WinGetProcess($handle)
If $pid = -1 Then
$iGhostCount += 1
_SysTrayIconRemove($i)
EndIF
Next
If _FindTrayToolbarWindow(2) <> -1 Then
$countwin7 = _SysTrayIconCount(2)
For $i = $countwin7 - 1 To 0 Step -1
$handle = _SysTrayIconHandle($i, 2)
$pid = WinGetProcess($handle)
If $pid = -1 Then
$iGhostCount += 1
_SysTrayIconRemove($i, 2)
EndIf
Next
EndIf
If $iGhostCount > 0 And $debugSetlog = 1 Then SetLog("Removed " & $iGhostCount & " Ghost icon successfully", $COLOR_DEBUG)
EndFunc
Func _SysTrayIconCount($iWin = 1)
Local Const $TB_BUTTONCOUNT = 1048
Local $hWnd = _FindTrayToolbarWindow($iWin)
If $hWnd = -1 Then Return -1
Local $count = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $TB_BUTTONCOUNT, "wparam", 0, "lparam", 0)
If @error Then Return -1
Return $count[0]
EndFunc
Func _SysTrayIconTitles($iWin = 1)
Local $count = _SysTrayIconCount($iWin)
If $count <= 0 Then Return -1
Local $titles[$count]
For $i = 0 To $count - 1
$titles[$i] = WinGetTitle(_SysTrayIconHandle($i, $iWin))
Next
Return $titles
EndFunc
Func _SysTrayIconPids($iWin = 1)
Local $count = _SysTrayIconCount($iWin)
If $count <= 0 Then Return -1
Local $processes[$count]
For $i = 0 To $count - 1
$processes[$i] = WinGetProcess(_SysTrayIconHandle($i, $iWin))
Next
Return $processes
EndFunc
Func _SysTrayIconProcesses($iWin = 1)
Local $pids = _SysTrayIconPids($iWin)
If Not IsArray($pids) Then Return -1
Local $processes[UBound($pids)]
Local $list = ProcessList()
For $i = 0 To UBound($pids) - 1
For $j = 1 To $list[0][0]
If $pids[$i] = $list[$j][1] Then
$processes[$i] = $list[$j][0]
ExitLoop
EndIf
Next
Next
Return $processes
EndFunc
Func _SysTrayIconIndex($test, $mode = 0, $iWin = 1)
Local $ret = -1, $compare = -1
If $mode < 0 Or $mode > 2 Or Not IsInt($mode) Then Return -1
Switch $mode
Case 0
$compare = _SysTrayIconProcesses($iWin)
Case 1
$compare = _SysTrayIconTitles($iWin)
Case 2
$compare = _SysTrayIconPids($iWin)
EndSwitch
If Not IsArray($compare) Then Return -1
For $i = 0 To UBound($compare) - 1
If $compare[$i] = $test Then
$ret = $i
ExitLoop
EndIf
Next
Return $ret
EndFunc
Func _SysTrayGetButtonInfo($iIndex, $iWin = 1, $iInfo = 1)
Local Const $TB_GETBUTTON = 1047
Local Const $TB_GETITEMRECT = 1053
Local Const $ACCESS = BitOR(0x0008, 0x0010, 0x0400)
Local $TBBUTTON
If @OSArch = "X86" Then
$TBBUTTON = DllStructCreate("int iBitmap;int idCommand;byte fsState;byte fsStyle;byte bReserved[2];dword dwData;int iString")
Else
$TBBUTTON = DllStructCreate("int iBitmap;int idCommand;byte fsState;byte fsStyle;byte bReserved[6];uint64 dwData;int64 iString")
EndIf
Local $TRAYDATA
If @OSArch = "X86" Then
$TRAYDATA = DllStructCreate("hwnd hwnd;uint uID;uint uCallbackMessage;dword Reserved[2];handle hIcon")
Else
$TRAYDATA = DllStructCreate("uint64 hwnd;uint uID;uint uCallbackMessage;dword Reserved[2];uint64 hIcon")
EndIf
Local $trayHwnd = _FindTrayToolbarWindow($iWin)
If $trayHwnd = -1 Then Return SetError(1, 0, -1)
Local $return, $err = 0
Local $ret = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $trayHwnd, "dword*", 0)
If @error Or Not $ret[2] Then SetError(2, 0, -1)
Local $pId = $ret[2]
Local $procHandle = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $ACCESS, "bool", False, "dword", $pId)
If @error Or Not $procHandle[0] Then Return SetError(3, 0, -1)
Local $lpData = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $procHandle[0], "ptr", 0, "ulong", DllStructGetSize($TBBUTTON), "dword", 0x1000, "dword", 0x04)
If Not @error And $lpData[0] Then
$ret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $trayHwnd, "uint", $TB_GETBUTTON, "wparam", $iIndex, "lparam", $lpData[0])
If Not @error And $ret[0] Then
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", $lpData[0], "struct*", $TBBUTTON, "ulong", DllStructGetSize($TBBUTTON), "ulong*", 0)
Switch $iInfo
Case 2
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", DllStructGetData($TBBUTTON, 6), "struct*", $TRAYDATA, "ulong", DllStructGetSize($TRAYDATA), "ulong*", 0)
$return = $TRAYDATA
Case 3
$return = ""
If BitShift(DllStructGetData($TBBUTTON, 7), 16) <> 0 Then
Local $intTip = DllStructCreate("wchar[1024]")
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", DllStructGetData($TBBUTTON, 7), "struct*", $intTip, "ulong", DllStructGetSize($intTip), "ulong*", 0)
$return = DllStructGetData($intTip, 1)
EndIf
Case 4
If Not BitAND(DllStructGetData($TBBUTTON, 3), 8) Then
Local $pos[2], $RECT = DllStructCreate("int;int;int;int")
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $trayHwnd, "uint", $TB_GETITEMRECT, "wparam", $iIndex, "lparam", $lpData[0])
DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $procHandle[0], "ptr", $lpData[0], "struct*", $RECT, "ulong", DllStructGetSize($RECT), "ulong*", 0)
$ret = DllCall("user32.dll", "int", "MapWindowPoints", "hwnd", $trayHwnd, "ptr", 0, "struct*", $RECT, "uint", 2)
$pos[0] = DllStructGetData($RECT, 1)
$pos[1] = DllStructGetData($RECT, 2)
$return = $pos
Else
$return = -1
EndIf
Case Else
$return = $TBBUTTON
EndSwitch
Else
$err = 5
EndIf
DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $procHandle[0], "ptr", $lpData[0], "ulong", 0, "dword", 0x8000)
Else
$err = 4
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $procHandle[0])
If $err Then
Return SetError($err, 0, -1)
Else
Return $return
EndIf
EndFunc
Func _SysTrayIconHandle($iIndex, $iWin = 1)
Local $TRAYDATA = _SysTrayGetButtonInfo($iIndex, $iWin, 2)
If @error Then
Return SetError(@error, 0, -1)
Else
Return Ptr(DllStructGetData($TRAYDATA, 1))
EndIf
EndFunc
Func _SysTrayIconTooltip($iIndex, $iWin = 1)
Local $ret = _SysTrayGetButtonInfo($iIndex, $iWin, 3)
If @error Then
Return SetError(@error, 0, -1)
Else
Return $ret
EndIf
EndFunc
Func _SysTrayIconPos($iIndex, $iWin = 1)
Local $ret = _SysTrayGetButtonInfo($iIndex, $iWin, 4)
If @error Then
Return SetError(@error, 0, -1)
Else
If $ret = -1 Then
Return SetError(-1, 0, -1)
Else
Return $ret
EndIf
EndIf
EndFunc
Func _SysTrayIconVisible($iIndex, $iWin = 1)
Local $TBBUTTON = _SysTrayGetButtonInfo($iIndex, $iWin, 1)
If @error Then
Return SetError(@error, 0, -1)
Else
Return Not BitAND(DllStructGetData($TBBUTTON, 3), 8)
EndIf
EndFunc
Func _SysTrayIconHide($index, $iFlag, $iWin = 1)
Local $TBBUTTON = _SysTrayGetButtonInfo($index, $iWin, 1)
If @error Then Return SetError(@error, 0, -1)
Local $visible = Not BitAND(DllStructGetData($TBBUTTON, 3), 8)
If ($iFlag And Not $visible) Or (Not $iFlag And $visible) Then
Return 0
Else
Local $TRAYDATA = _SysTrayGetButtonInfo($index, $iWin, 2)
If @error Then Return SetError(@error, 0, -1)
Local $NOTIFYICONDATA = DllStructCreate("dword cbSize;hwnd hWnd;uint uID;uint uFlags;uint uCallbackMessage;handle hIcon;wchar szTip[128];"  & "dword dwState;dword dwStateMask;wchar szInfo[256];uint uVersion;wchar szInfoTitle[64];dword dwInfoFlags;"  & "STRUCT;ulong;ushort;ushort;byte[8];ENDSTRUCT;handle hBalloonIcon")
DllStructSetData($NOTIFYICONDATA, 1, DllStructGetSize($NOTIFYICONDATA))
DllStructSetData($NOTIFYICONDATA, 2, Ptr(DllStructGetData($TRAYDATA, 1)))
DllStructSetData($NOTIFYICONDATA, 3, DllStructGetData($TRAYDATA, 2))
DllStructSetData($NOTIFYICONDATA, 4, 8)
DllStructSetData($NOTIFYICONDATA, 8, $iFlag)
DllStructSetData($NOTIFYICONDATA, 9, 1)
Local $ret = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", 0x1, "struct*", $NOTIFYICONDATA)
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", WinGetHandle("[CLASS:Shell_TrayWnd]"), "uint", 0x001A, "wparam", 0, "lparam", 0)
If IsArray($ret) And $ret[0] Then
Return 1
Else
Return 0
EndIf
EndIf
EndFunc
Func _SysTrayIconMove($curPos, $newPos, $iWin = 1)
Local Const $TB_MOVEBUTTON = 0x0452
Local $iconCount = _SysTrayIconCount($iWin)
If $curPos < 0 Or $newPos < 0 Or $curPos > $iconCount - 1 Or $newPos > $iconCount - 1 Or Not IsInt($curPos) Or Not IsInt($newPos) Then Return SetError(1, 0, -1)
Local $hWnd = _FindTrayToolbarWindow($iWin)
If $hWnd = -1 Then Return SetError(2, 0, -1)
Local $ret = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", $TB_MOVEBUTTON, "wparam", $curPos, "lparam", $newPos)
If @error Or Not $ret[0] Then
Return 0
Else
Return 1
EndIf
EndFunc
Func _SysTrayIconRemove($index, $iWin = 1)
Local Const $TB_DELETEBUTTON = 1046
Local $TRAYDATA = _SysTrayGetButtonInfo($index, $iWin, 2)
If @error Then Return SetError(@error, 0, -1)
Local $NOTIFYICONDATA = DllStructCreate("dword cbSize;hwnd hWnd;uint uID;uint uFlags;uint uCallbackMessage;handle hIcon;wchar szTip[128];"  & "dword dwState;dword dwStateMask;wchar szInfo[256];uint uVersion;wchar szInfoTitle[64];dword dwInfoFlags;"  & "STRUCT;ulong;ushort;ushort;byte[8];ENDSTRUCT;handle hBalloonIcon")
DllStructSetData($NOTIFYICONDATA, 1, DllStructGetSize($NOTIFYICONDATA))
DllStructSetData($NOTIFYICONDATA, 2, Ptr(DllStructGetData($TRAYDATA, 1)))
DllStructSetData($NOTIFYICONDATA, 3, DllStructGetData($TRAYDATA, 2))
Local $ret = DllCall("shell32.dll", "bool", "Shell_NotifyIconW", "dword", 0x2, "struct*", $NOTIFYICONDATA)
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", WinGetHandle("[CLASS:Shell_TrayWnd]"), "uint", 0x001A, "wparam", 0, "lparam", 0)
If IsArray($ret) And $ret[0] Then
Return 1
Else
Return 0
EndIf
EndFunc
Func _FindTrayToolbarWindow($iWin = 1)
Local $hwnd, $ret = -1
If $iWin = 1 Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindow", "str", "Shell_TrayWnd", "ptr", 0)
If @error Then Return -1
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "TrayNotifyWnd", "ptr", 0)
If @error Then Return -1
If @OSVersion <> "WIN_2000" Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "SysPager", "ptr", 0)
If @error Then Return -1
EndIf
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "ToolbarWindow32", "ptr", 0)
If @error Then Return -1
$ret = $hwnd[0]
ElseIf $iWin = 2 Then
$hWnd = DllCall("user32.dll", "hwnd", "FindWindow", "str", "NotifyIconOverflowWindow", "ptr", 0)
If @error Then Return -1
$hWnd = DllCall("user32.dll", "hwnd", "FindWindowEx", "hwnd", $hWnd[0], "hwnd", 0, "str", "ToolbarWindow32", "ptr", 0)
If @error Then Return -1
$ret = $hwnd[0]
EndIf
Return $ret
EndFunc
Func waitMainScreen()
If Not $RunState Then Return
Local $iCount
SetLog("Waiting for Main Screen")
$iCount = 0
For $i = 0 To 105
If Not $RunState Then Return
If $debugsetlog = 1 Then Setlog("ChkObstl Loop = " & $i & "ExitLoop = " & $iCount, $COLOR_DEBUG)
$iCount += 1
Local $hWin = $HWnD
If WinGetAndroidHandle() = 0 Then
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
Return
EndIf
getBSPos()
_CaptureRegion()
If _CheckPixel($aIsMain, $bNoCapturepixel) = True Then
If $debugsetlog = 1 Then Setlog("Screen cleared, WaitMainScreen exit", $COLOR_DEBUG)
Return
ElseIf _CheckPixel($aIsDPI125, $bNoCapturepixel) = True Then
ShowDPIHelp(125)
ElseIf _CheckPixel($aIsDPI150, $bNoCapturepixel) = True Then
ShowDPIHelp(150)
Else
If _Sleep($iDelaywaitMainScreen1) Then Return
If checkObstacles() Then $i = 0
EndIf
If Mod($i, 5) = 0 Then
If $debugImageSave = 1 Then DebugImageSave("WaitMainScreen_", False)
EndIf
If ($i > 105) Or ($iCount > 120) Then ExitLoop
If TestCapture() Then
Return "Main screen not available"
EndIf
Next
CloseCoC(True)
If _CheckPixel($aIsMain, True) Then Return
$iCount = 0
While 1
If Not $RunState Then Return
SetLog("Unable to load CoC, attempt to fix it...", $COLOR_RED)
If $debugsetlog = 1 Then Setlog("Restart Loop = " & $iCount, $COLOR_DEBUG)
CloseAndroid()
If _Sleep(1000) Then Return
OpenAndroid(True)
If @extended Then
SetError(1, 1, -1)
Return
EndIf
If _CheckPixel($aIsMain, $bCapturepixel) = True Then ExitLoop
CheckObstacles()
$iCount += 1
If $iCount > 2 Then
SetLog("Stuck trying to Restart " & $Android & "...", $COLOR_RED)
SetError(1, 0, 0)
Return
EndIf
If _CheckPixel($aIsMain, $bCapturepixel) = True Then ExitLoop
WEnd
EndFunc
Func waitMainScreenMini()
If Not $RunState Then Return
Local $iCount = 0
Local $hTimer = TimerInit()
SetDebugLog("waitMainScreenMini")
getBSPos()
SetLog("Waiting for Main Screen after " & $Android & " restart", $COLOR_BLUE)
For $i = 0 To 60
If Not $RunState Then Return
If WinGetAndroidHandle() = 0 Then ExitLoop
If $debugsetlog = 1 Then Setlog("ChkObstl Loop = " & $i & "ExitLoop = " & $iCount, $COLOR_DEBUG)
$iCount += 1
_CaptureRegion()
If _CheckPixel($aIsMain, $bNoCapturepixel) = False Then
If _Sleep(1000) Then Return
If CheckObstacles() Then $i = 0
Else
SetLog("CoC main window took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_GREEN)
Return
EndIf
_StatusUpdateTime($hTimer, "Main Screen")
If ($i > 60) Or ($iCount > 80) Then ExitLoop
If TestCapture() Then
Return "Main screen not available"
EndIf
Next
Return SetError( 1, 0, -1)
EndFunc
Func AndroidBackButton($bCheckRunState = True)
If $bCheckRunState And Not $RunState Then Return False
AndroidAdbSendShellCommand("input keyevent 4", Default, Default, False)
If $DebugSetLog = 1 Then Setlog("Used Adb to press back button", $COLOR_DEBUG)
Return True
EndFunc
Func AndroidHomeButton()
If Not $RunState Then Return False
AndroidAdbSendShellCommand("input keyevent 3", Default, Default, False)
If $DebugSetLog = 1 Then Setlog("Used Adb to press home button", $COLOR_DEBUG)
Return True
EndFunc
Func CloseCoC($ReOpenCoC = False)
$SkipFirstZoomout = False
ResumeAndroid()
If Not $RunState Then Return
Local $Adb = ""
If $ReOpenCoC Then
SetLog("Please wait for CoC restart......", $COLOR_ERROR)
Else
SetLog("Closing CoC......", $COLOR_ERROR)
EndIf
WinGetAndroidHandle()
AndroidHomeButton()
If Not $RunState Then Return
SendAdbCommand("shell am force-stop " & $AndroidGamePackage)
If Not $RunState Then Return
If $ReOpenCoC Then
OpenCoC()
$Restart = True
EndIf
EndFunc
Func OpenCoC()
ResumeAndroid()
If Not $RunState Then Return
Local $RunApp = "", $iCount = 0
WinGetAndroidHandle()
AndroidHomeButton()
If _Sleep(250) Then Return
SendAdbCommand("shell am start -n " & $AndroidGamePackage & "/" & $AndroidGameClass)
If Not $RunState Then Return
While _CheckPixel($aIsMain, True) = False
$iCount += 1
If _Sleep(100) Then Return
If checkObstacles() Then $iCount += 1
If $iCount > 250 Then ExitLoop
WEnd
EndFunc
Func WaitnOpenCoC($iWaitTime, $bFullRestart = False)
ResumeAndroid()
If Not $RunState Then Return
Local $RunApp = ""
Local $sWaitTime = ""
Local $iMin, $iSec, $iHour, $iWaitSec
WinGetAndroidHandle()
AndroidHomeButton()
$iWaitSec = Round($iWaitTime / 1000)
$iHour = Floor(Floor($iWaitSec / 60) / 60)
$iMin = Floor(Mod(Floor($iWaitSec / 60), 60))
$iSec = Floor(Mod($iWaitSec, 60))
If $iHour > 0 Then $sWaitTime &= $iHour & " hours "
If $iMin > 0 Then $sWaitTime &= $iMin & " minutes "
If $iSec > 0 Then $sWaitTime &= $iSec & " seconds "
SetLog("Waiting " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
If _SleepStatus($iWaitTime) Then Return False
SendAdbCommand("shell am start -n " & $AndroidGamePackage & "/" & $AndroidGameClass)
If Not $RunState Then Return
If $debugSetlog = 1 Then setlog("CoC Restarted, Waiting for completion", $COLOR_DEBUG)
If $bFullRestart = True Then
checkMainScreen()
$Restart = True
Else
waitMainScreen()
EndIf
EndFunc
Func PoliteCloseCoC($sSource = "Unknown_")
$SkipFirstZoomout = False
Local $i = 0
While 1
checkObstacles()
AndroidBackButton()
If _Sleep($iDelayAttackDisable1000) Then Return
If ClickOkay("ExitOkay_" & $sSource, True) = True Then ExitLoop
If $i > 10 Then
Setlog("Can not find Okay button to exit CoC, Forcefully Closing CoC", $COLOR_ERROR)
If $debugImageSave = 1 Then DebugImageSave($sSource)
CloseCoC()
ExitLoop
EndIf
$i += 1
WEnd
EndFunc
Func ZoomOut()
$SearchZoomOutCounter[0] = 0
$SearchZoomOutCounter[1] = 1
ResumeAndroid()
WinGetAndroidHandle()
getBSPos()
If Not $RunState Then Return
Local $Result
If $AndroidEmbedded = False Or $AndroidEmbedMode = 1 Then
$Result = Execute("ZoomOut" & $Android & "()")
If $Result = "" And @error <> 0 Then
$Result = AndroidOnlyZoomOut()
EndIf
$SkipFirstZoomout = True
Return $Result
EndIf
AndroidOnlyZoomOut()
$SkipFirstZoomout = True
EndFunc
Func ZoomOutBlueStacks()
Return ZoomOutCtrlClick(False, False, False, False)
EndFunc
Func ZoomOutBlueStacks2()
If $__BlueStacks2Version_2_5_or_later = False Then
Return ZoomOutCtrlClick(False, False, False, False)
Else
Return DefaultZoomOut("{DOWN}", 0)
EndIf
EndFunc
Func ZoomOutMEmu()
Return DefaultZoomOut("{F3}", 0)
EndFunc
Func ZoomOutDroid4X()
Return ZoomOutCtrlWheelScroll(True, True, True)
EndFunc
Func ZoomOutNox()
Return ZoomOutCtrlWheelScroll(True, True, True)
EndFunc
Func DefaultZoomOut($ZoomOutKey = "{DOWN}", $tryCtrlWheelScrollAfterCycles = 40, $AndroidZoomOut = True)
Local $result0, $result1, $i = 0
Local $exitCount = 80
Local $delayCount = 20
ForceCaptureRegion()
Local $aPicture = SearchZoomOut()
If StringInStr($aPicture[0], "zoomou") = 0 Then
SetLog("Zooming Out", $COLOR_BLUE)
If _Sleep($iDelayZoomOut1) Then Return
If $AndroidZoomOut = True Then
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut()
EndIf
Local $tryCtrlWheelScroll = False
While StringInStr($aPicture[0], "zoomou") = 0 and Not $tryCtrlWheelScroll
AndroidShield("DefaultZoomOut")
If $AndroidZoomOut = True Then
AndroidZoomOut(False, $i)
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If $AndroidZoomOut = False Then
If $debugsetlog = 1 Then Setlog("Index = "&$i, $COLOR_DEBUG)
If _Sleep($iDelayZoomOut2) Then Return
If $ichkBackground = 0 And $NoFocusTampering = False Then
$Result0 = ControlFocus($HWnD, "", "")
Else
$Result0 = 1
EndIf
$Result1 = ControlSend($HWnD, "", "", $ZoomOutKey)
If $debugsetlog = 1 Then Setlog("ControlFocus Result = "&$Result0 & ", ControlSend Result = "&$Result1& "|" & "@error= " & @error, $COLOR_DEBUG)
If $Result1 = 1 Then
$i += 1
Else
Setlog("Warning ControlSend $Result = "&$Result1, $COLOR_DEBUG)
EndIf
EndIF
If $i > $delayCount Then
If _Sleep($iDelayZoomOut3) Then Return
EndIf
If $tryCtrlWheelScrollAfterCycles > 0 And $i > $tryCtrlWheelScrollAfterCycles Then $tryCtrlWheelScroll = True
If $i > $exitCount Then Return
If $RunState = False Then ExitLoop
If IsProblemAffect(True) Then
Setlog($Android & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then Setlog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut()
WEnd
If $tryCtrlWheelScroll Then
Setlog($Android & " zoom-out with key " & $ZoomOutKey & " didn't work, try now Ctrl+MouseWheel...", $COLOR_INFO)
Return ZoomOutCtrlWheelScroll(False, False, False, False)
EndIf
Return True
EndIf
Return False
EndFunc
Func ZoomOutCtrlWheelScroll($CenterMouseWhileZooming = True, $GlobalMouseWheel = True, $AlwaysControlFocus = False, $AndroidZoomOut = True, $hWin = Default, $ScrollSteps = -5, $ClickDelay = 250)
Local $exitCount = 80
Local $delayCount = 20
Local $result[4], $i = 0, $j
Local $ZoomActions[4] = ["ControlFocus", "Ctrl Down", "Mouse Wheel Scroll Down", "Ctrl Up"]
If $hWin = Default Then $hWin = ($AndroidEmbedded = False ? $HWnD : $AndroidEmbeddedCtrlTarget[1])
ForceCaptureRegion()
Local $aPicture = SearchZoomOut()
If StringInStr($aPicture[0], "zoomou") = 0 Then
SetLog("Zooming Out", $COLOR_BLUE)
AndroidShield("ZoomOutCtrlWheelScroll")
If _Sleep($iDelayZoomOut1) Then Return
If $AndroidZoomOut = True Then
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut()
EndIf
Local $aMousePos = MouseGetPos()
While StringInStr($aPicture[0], "zoomou") = 0
If $AndroidZoomOut = True Then
AndroidZoomOut(False, $i)
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If $AndroidZoomOut = False Then
If $debugsetlog = 1 Then Setlog("Index = " & $i, $COLOR_DEBUG)
If _Sleep($iDelayZoomOut2) Then ExitLoop
If ($ichkBackground = 0 And $NoFocusTampering = False) Or $AlwaysControlFocus Then
$Result[0] = ControlFocus($hWin, "", "")
Else
$Result[0] = 1
EndIf
$Result[1] = ControlSend($hWin, "", "", "{CTRLDOWN}")
If $CenterMouseWhileZooming Then MouseMove($BSpos[0] + Int($DEFAULT_WIDTH / 2), $BSpos[1] + Int($DEFAULT_HEIGHT / 2), 0)
If $GlobalMouseWheel Then
$Result[2] = MouseWheel(($ScrollSteps < 0 ? "down" : "up"), Abs($ScrollSteps))
Else
Local $WM_WHEELMOUSE = 0x020A, $MK_CONTROL = 0x0008
Local $wParam = BitOR($ScrollSteps * 0x10000, BitAND($MK_CONTROL, 0xFFFF))
Local $lParam =  BitOR(($BSpos[1] + Int($DEFAULT_HEIGHT / 2)) * 0x10000, BitAND(($BSpos[0] + Int($DEFAULT_WIDTH / 2)), 0xFFFF))
_WinAPI_PostMessage($hWin, $WM_WHEELMOUSE, $wParam, $lParam)
$Result[2] = (@error = 0 ? 1 : 0)
EndIf
If _Sleep($ClickDelay) Then ExitLoop
$Result[3] = ControlSend($hWin, "", "", "{CTRLUP}{SPACE}")
If $debugsetlog = 1 Then Setlog("ControlFocus Result = " & $Result[0] &  ", " & $ZoomActions[1] & " = " & $Result[1] &  ", " & $ZoomActions[2] & " = " & $Result[2] &  ", " & $ZoomActions[3] & " = " & $Result[3] &  " | " & "@error= " & @error, $COLOR_DEBUG)
For $j = 1 To 3
If $Result[$j] = 1 Then
$i += 1
ExitLoop
EndIf
Next
For $j = 1 To 3
If $Result[$j] = 0 Then
Setlog("Warning " & $ZoomActions[$j] & " = " & $Result[1], $COLOR_DEBUG)
EndIf
Next
EndIf
If $i > $delayCount Then
If _Sleep($iDelayZoomOut3) Then ExitLoop
EndIf
If $i > $exitCount Then ExitLoop
If $RunState = False Then ExitLoop
If IsProblemAffect(True) Then
Setlog($Android & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then Setlog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut()
WEnd
If $CenterMouseWhileZooming And $AndroidZoomOut = False Then MouseMove($aMousePos[0], $aMousePos[1], 0)
Return True
EndIf
Return False
EndFunc
Func ZoomOutCtrlClick($ZoomOutOverWaters = False, $CenterMouseWhileZooming = False, $AlwaysControlFocus = False, $AndroidZoomOut = True, $ClickDelay = 250)
Local $exitCount = 80
Local $delayCount = 20
Local $result[4], $i, $j
Local $SendCtrlUp = False
Local $ZoomActions[4] = ["ControlFocus", "Ctrl Down", "Click", "Ctrl Up"]
ForceCaptureRegion()
Local $aPicture = SearchZoomOut()
If StringInStr($aPicture[0], "zoomou") = 0 Then
SetLog("Zooming Out", $COLOR_INFO)
AndroidShield("ZoomOutCtrlClick")
If $ZoomOutOverWaters = True Then
If $AndroidZoomOut = True Then
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut()
Else
For $i = 1 To 3
_PostMessage_ClickDrag(100, 600, 600, 100, "left")
Next
EndIf
EndIf
If _Sleep($iDelayZoomOut1) Then Return
Local $aMousePos = MouseGetPos()
$i = 0
While StringInStr($aPicture[0], "zoomou") = 0
If $AndroidZoomOut = True Then
AndroidZoomOut(False, $i)
If @error <> 0 Then $AndroidZoomOut = False
EndIf
If $AndroidZoomOut = False Then
If $debugsetlog = 1 Then Setlog("Index = " & $i, $COLOR_DEBUG)
If _Sleep($iDelayZoomOut2) Then ExitLoop
If ($ichkBackground = 0 And $NoFocusTampering = False) Or $AlwaysControlFocus Then
$Result[0] = ControlFocus($HWnD, "", "")
Else
$Result[0] = 1
EndIf
$Result[1] = ControlSend($HWnD, "", "", "{CTRLDOWN}")
$SendCtrlUp = True
If $CenterMouseWhileZooming Then MouseMove($BSpos[0] + Int($DEFAULT_WIDTH / 2), $BSpos[1] + Int($DEFAULT_HEIGHT / 2), 0)
$Result[2] = ControlClick($HWnD, "", "", "left", "1", $BSrpos[0] + Int($DEFAULT_WIDTH / 2), $BSrpos[1] + 600)
If _Sleep($ClickDelay) Then ExitLoop
$Result[3] = ControlSend($HWnD, "", "", "{CTRLUP}{SPACE}")
$SendCtrlUp = False
If $debugsetlog = 1 Then Setlog("ControlFocus Result = " & $Result[0] &  ", " & $ZoomActions[1] & " = " & $Result[1] &  ", " & $ZoomActions[2] & " = " & $Result[2] &  ", " & $ZoomActions[3] & " = " & $Result[3] &  " | " & "@error= " & @error, $COLOR_DEBUG)
For $j = 1 To 3
If $Result[$j] = 1 Then
ExitLoop
EndIf
Next
For $j = 1 To 3
If $Result[$j] = 0 Then
Setlog("Warning " & $ZoomActions[$j] & " = " & $Result[1], $COLOR_DEBUG)
EndIf
Next
EndIf
If $i > $delayCount Then
If _Sleep($iDelayZoomOut3) Then ExitLoop
EndIf
If $i > $exitCount Then ExitLoop
If $RunState = False Then ExitLoop
If IsProblemAffect(True) Then
Setlog($Android & " Error window detected", $COLOR_RED)
If checkObstacles() = True Then Setlog("Error window cleared, continue Zoom out", $COLOR_BLUE)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut()
WEnd
If $SendCtrlUp Then ControlSend($HWnD, "", "", "{CTRLUP}{SPACE}")
If $CenterMouseWhileZooming Then MouseMove($aMousePos[0], $aMousePos[1], 0)
Return True
EndIf
Return False
EndFunc
Func AndroidOnlyZoomOut()
Local $i = 0
Local $exitCount = 80
ForceCaptureRegion()
Local $aPicture = SearchZoomOut()
If StringInStr($aPicture[0], "zoomou") = 0 Then
SetLog("Zooming Out", $COLOR_BLUE)
AndroidZoomOut(False)
ForceCaptureRegion()
$aPicture = SearchZoomOut()
While StringInStr($aPicture[0], "zoomou") = 0
AndroidShield("AndroidOnlyZoomOut")
AndroidZoomOut(False, $i)
If $i > $exitCount Then Return
If $RunState = False Then ExitLoop
If IsProblemAffect(True) Then
Setlog($Android & " Error window detected", $COLOR_ERROR)
If checkObstacles() = True Then Setlog("Error window cleared, continue Zoom out", $COLOR_INFO)
EndIf
$i += 1
ForceCaptureRegion()
$aPicture = SearchZoomOut()
WEnd
Return True
EndIf
Return False
EndFunc
Func SearchZoomOut($directory = @ScriptDir & "\imgxml\zoomout", $bCenterVillage = $CenterVillage[0])
Local $x, $y, $x1, $y1, $right, $bottom
Local $aZoomoutImgPos[2] = [191, 498]
Local $iAdditional = 50
$x1 = $aZoomoutImgPos[0] - $iAdditional
$y1 = $aZoomoutImgPos[1] - $iAdditional
$right = $x1 + 37 + $iAdditional * 2
$bottom = $y1 + 25 + $iAdditional * 2
_CaptureRegion()
Local $aResult[1]
$aResult[0] = "zoomout"
Local $aFiles = _FileListToArray($directory, "zoomout*.*", $FLTA_FILES)
If @error Then
SetLog("Error: Missing zoom-out files", $COLOR_ERROR)
Return $aResult
EndIf
local $i, $findImage
If $SearchZoomOutCounter[0] > 0 Then
If _Sleep(1000) Then Return $aResult
EndIf
$aResult[0] = ""
For $i = 1 To $aFiles[0]
$findImage = $aFiles[$i]
If StringRegExp($findImage, "[.](xml|png|bmp)$") Then
If _ImageSearchAreaImgLocZoom($directory & "\" & $findImage, 1, $x1, $y1, $right, $bottom, $x, $y) Then
$aResult[0] = $findImage
$x -= 54
$y -= 89
If $bCenterVillage = True And ($x <> 0 Or $y <> 0) And ($x <> $CenterVillage[1] Or $y <> $CenterVillage[2]) Then
SetDebugLog("Center Village by: " & $x & ", " & $y)
ClickDrag($aZoomoutImgPos[0], $aZoomoutImgPos[1], $aZoomoutImgPos[0] - $x, $aZoomoutImgPos[1] - $y)
If _Sleep(250) Then Return $aResult
$aResult = SearchZoomOut($directory, False)
$CenterVillage[1] = $VILLAGE_OFFSET_X
$CenterVillage[2] = $VILLAGE_OFFSET_Y
SetDebugLog("Centered Village Offset: " & $CenterVillage[1] & ", " & $CenterVillage[2])
Return $aResult
EndIf
If $x <> $VILLAGE_OFFSET_X Or $y <> $VILLAGE_OFFSET_Y Then
SetDebugLog("Village Offset updated to " & $x & ", " & $y)
EndIf
$VILLAGE_OFFSET_X = $x
$VILLAGE_OFFSET_Y = $y
ExitLoop
EndIf
EndIf
Next
If $aResult[0] = "" Then
If $SearchZoomOutCounter[0] > 20 Then
$SearchZoomOutCounter[0] = 0
SetLog("Restart CoC to reset zoom...", $COLOR_INFO)
PoliteCloseCoC("Zoomout")
If _Sleep(1000) Then Return
CloseCoC()
OpenCoC()
Return SearchZoomOut()
Else
$SearchZoomOutCounter[0] += 1
EndIf
Else
If $SkipFirstZoomout = False Then
$aResult[0] = ""
ElseIf $SearchZoomOutCounter[1] > 0 And $SearchZoomOutCounter[0] > 0  Then
$SearchZoomOutCounter[1] -= 1
$aResult[0] = ""
EndIf
EndIf
$SkipFirstZoomout = True
Return $aResult
EndFunc
Func checkAndroidTimeLag($bRebootAndroid = True)
SetError(0, 0)
If $AndroidCheckTimeLagEnabled = False Then Return SetError(1, 0, False)
Local $androidUTC = $AndroidTimeLag[1]
Local $hostTimer = $AndroidTimeLag[2]
If $hostTimer <> 0 And TimerDiff($hostTimer) / 1000 < 60 Then
Return SetError(3, 0, False)
EndIf
Local $s = AndroidAdbSendShellCommand("date +%s")
If @error <> 0 Then Return SetError(4, 0, False)
Local $curr_androidUTC = Number($s)
Local $curr_hostTimer = TimerInit()
If $curr_androidUTC < 1 Then
InitAndroidTimeLag()
Return SetError(5, 0, False)
EndIf
If $androidUTC = 0 Or $hostTimer = 0 Then
$AndroidTimeLag[1] = $curr_androidUTC
$AndroidTimeLag[2] = $curr_hostTimer
$AndroidTimeLag[3] = 0
Return SetError(2, 0, False)
EndIf
Local $hostSeconds = Int(TimerDiff($hostTimer) / 1000)
Local $hostMinutes = $hostSeconds / 60
Local $androidSeconds = $curr_androidUTC - $androidUTC
Local $lagTotal = $hostSeconds - $androidSeconds
Local $lagPerMin = Int($lagTotal / $hostMinutes)
SetDebugLog($Android & " time lag is " & ($lagPerMin > 0 ? "> " : "") & $lagPerMin & " sec/min (avg for " & $hostSeconds & " sec)")
If $androidSeconds <= 0 Then
InitAndroidTimeLag()
Return SetError(6, 0, False)
EndIf
If $lagPerMin < 0 Then $lagPerMin = 0
$AndroidTimeLag[0] = $lagPerMin
$AndroidTimeLag[1] = $curr_androidUTC
$AndroidTimeLag[2] = $curr_hostTimer
$AndroidTimeLag[3] = 0
Local $bRebooted = False
If $lagPerMin > $AndroidTimeLagThreshold Then
If $bRebootAndroid = True Then
SetLog("Rebooting " & $Android & " due to time lag problem of " & $lagPerMin & " sec/min", $COLOR_ERROR)
$bRebooted = True
EndIf
EndIf
Return SetError(0, $lagPerMin, $bRebooted)
EndFunc
Func OpenBS($bRestart = False)
Return OpenAndroid($bRestart)
EndFunc
Func OpenBlueStacks($bRestart = False)
Local $hTimer, $iCount = 0
Local $PID, $ErrorResult, $connected_to
SetLog("Starting BlueStacks and Clash Of Clans", $COLOR_SUCCESS)
$PID = ShellExecute($__BlueStacks_Path & "HD-Frontend.exe", "Android")
If _Sleep(1000) Then Return False
$ErrorResult = ControlGetHandle("BlueStacks Error", "", "")
If $debugsetlog = 1 Then Setlog("$PID= "&$PID & ", $ErrorResult = " &$ErrorResult, $COLOR_DEBUG)
If $PID = 0 Or $ErrorResult <> 0  Then
SetLog("Unable to load Clash of Clans, install/reinstall the game.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnstop()
SetError(1, 1, -1)
Return False
EndIf
SetLog("Please wait while " & $Android & "/CoC start....", $COLOR_SUCCESS)
WinGetAndroidHandle()
$hTimer = TimerInit()
While IsArray(ControlGetPos($Title, $AppPaneName, $AppClassInstance)) = False
If _Sleep(3000) Then ExitLoop
_StatusUpdateTime($hTimer, $Android & "/CoC Start")
If TimerDiff($hTimer) > $AndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog("BlueStacks refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_ERROR)
DebugSaveDesktopImage("BSOpenError_")
SetLog("Unable to continue........", $COLOR_WARNING)
btnstop()
SetError(1, 1, -1)
Return False
EndIf
WinGetAndroidHandle()
WEnd
If IsArray(ControlGetPos($Title, $AppPaneName, $AppClassInstance)) Then
$connected_to = ConnectAndroidAdb(False, 3000)
SetLog("BlueStacks Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndIf
Return False
EndFunc
Func OpenBlueStacks2($bRestart = False)
Local $hTimer, $iCount = 0, $cmdOutput, $process_killed, $i, $connected_to
SetLog("Starting " & $Android & " and Clash Of Clans", $COLOR_SUCCESS)
If Not InitAndroid() Then Return False
SetLog("Please wait while " & $Android & " and CoC start...", $COLOR_SUCCESS)
CloseUnsupportedBlueStacks2()
$hTimer = TimerInit()
WinGetAndroidHandle()
While IsArray(ControlGetPos($Title, $AppPaneName, $AppClassInstance)) = False
If Not $RunState Then Return False
Local $pid = ProcessExists2($AndroidProgramPath)
If $pid <= 0 Then
$pid = ShellExecute($AndroidProgramPath, GetBlueStacks2ProgramParameter())
If _Sleep(1000) Then Return False
EndIf
If $pid > 0 Then $pid = ProcessExists2($AndroidProgramPath)
If $pid <= 0 Then
CloseAndroid()
If _Sleep(1000) Then Return False
EndIf
_StatusUpdateTime($hTimer)
If TimerDiff($hTimer) > $AndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($Android & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
If _Sleep(3000) Then Return False
_StatusUpdateTime($hTimer, $Android & "/CoC Start")
WinGetAndroidHandle()
WEnd
WinGetAndroidHandle()
Local $lCurStyle = _WinAPI_GetWindowLong($HWnD, $GWL_STYLE)
$lCurStyle = BitOr($lCurStyle, $WS_CAPTION, $WS_SYSMENU)
_WinAPI_SetWindowLong($HWnd, $GWL_STYLE, $lCurStyle)
If IsArray(ControlGetPos($Title, $AppPaneName, $AppClassInstance)) Then
$connected_to = ConnectAndroidAdb(False, 3000)
If WaitForAndroidBootCompleted($AndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return
If Not $RunState Then Return False
SetLog($Android & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
AndroidAdbLaunchShellInstance()
If Not $RunState Then Return False
ConfigBlueStacks2WindowManager()
Return True
EndIf
Return False
EndFunc
Func InitBlueStacksX($bCheckOnly = False, $bAdjustResolution = False, $bLegacyMode = False)
Local $plusMode = RegRead($HKLM & "\SOFTWARE\BlueStacks\", "Engine") = "plus" And $bLegacyMode = False
Local $frontend_exe = "HD-Frontend.exe"
If $plusMode = True Then $frontend_exe = "HD-Plus-Frontend.exe"
Local $i, $aFiles[3] = [$frontend_exe, "HD-Adb.exe", "HD-Quit.exe"]
Local $Values[4][3] = [  ["Screen Width", $AndroidClientWidth  , $AndroidClientWidth],  ["Screen Height", $AndroidClientHeight, $AndroidClientHeight],  ["Window Width", $AndroidWindowWidth  , $AndroidWindowWidth],  ["Window Height", $AndroidWindowHeight , $AndroidWindowHeight]  ]
Local $bChanged = False
$__BlueStacks_Version = RegRead($HKLM & "\SOFTWARE\BlueStacks\", "Version")
$__BlueStacks_Path = RegRead($HKLM & "\SOFTWARE\BlueStacks\", "InstallDir")
If @error <> 0 Then
$__BlueStacks_Path = @ProgramFilesDir & "\BlueStacks\"
SetError(0, 0, 0)
EndIf
For $i = 0 To UBound($aFiles) - 1
Local $File = $__BlueStacks_Path & $aFiles[$i]
If Not FileExists($File) Then
If $plusMode And $aFiles[$i] = $frontend_exe Then
SetDebugLog("Cannot find " & $Android & " file:" & $File, $COLOR_ACTION)
SetDebugLog("Try legacy mode", $COLOR_ACTION)
Return InitBlueStacksX($bCheckOnly, $bAdjustResolution, True)
EndIf
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_ERROR)
SetLog($File, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Next
If Not $bCheckOnly Then
$__BlueStacks2Version_2_5_or_later = GetVersionNormalized($__BlueStacks_Version) >= GetVersionNormalized("2.5.00.0000")
If $AndroidAutoAdjustConfig = True And $__BlueStacks2Version_2_5_or_later Then
SetDebugLog($Android & " Version is 2.5 or later found, enable ADB Mouse Click")
$AndroidAdbClickEnabled = True
$AndroidAppConfig[$AndroidConfig][11] = BitOR($AndroidAppConfig[$AndroidConfig][11], 4)
InitAndroidConfig(True)
EndIF
Local $BootParameter = RegRead($HKLM & "\SOFTWARE\BlueStacks\Guests\Android\", "BootParameters")
Local $OEMFeatures
Local $aRegExResult = StringRegExp($BootParameter, "OEMFEATURES=(\d+)", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$OEMFeatures = $aRegExResult[UBound($aRegExResult) - 1]
$AndroidHasSystemBar = BitAND($OEMFeatures, 0x000001) = 0
EndIf
$AndroidProgramPath = $__BlueStacks_Path & $frontend_exe
$AndroidAdbPath = FindPreferredAdbPath()
If $AndroidAdbPath = "" Then $AndroidAdbPath = $__BlueStacks_Path & "HD-Adb.exe"
$AndroidVersion = $__BlueStacks_Version
For $i = 0 To 5
If RegRead($HKLM & "\SOFTWARE\BlueStacks\Guests\Android\SharedFolder\" & $i & "\", "Name") = "BstSharedFolder" Then
$AndroidPicturesPath = "/storage/sdcard/windows/BstSharedFolder/"
$AndroidPicturesHostPath = RegRead($HKLM & "\SOFTWARE\BlueStacks\Guests\Android\SharedFolder\" & $i & "\", "Path")
ExitLoop
EndIf
Next
SetDebugLog($Android & " Engine 'Plus'-Mode: " & $plusMode)
SetDebugLog($Android & " OEM Features: " & $OEMFeatures)
SetDebugLog($Android & " System Bar is " & ($AndroidHasSystemBar ? "" : "not ") & "available")
For $i = 0 To UBound($Values) -1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($Android & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
WinGetAndroidHandle()
EndIf
Return True
EndFunc
Func InitBlueStacks($bCheckOnly = False)
Local $bInstalled = InitBlueStacksX($bCheckOnly)
If $bInstalled And StringInStr($__BlueStacks_Version, "0.8.") <> 1  And StringInStr($__BlueStacks_Version, "0.9.") <> 1  And StringInStr($__BlueStacks_Version, "0.10.") <> 1  And StringInStr($__BlueStacks_Version, "0.11.") <> 1  Then
If Not $bCheckOnly Then
SetLog("BlueStacks supported version 0.8.x - 0.11.x not found", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIF
If Not $bCheckOnly Then
$AndroidHasSystemBar = True
EndIF
Return $bInstalled
EndFunc
Func InitBlueStacks2($bCheckOnly = False)
Local $bInstalled = InitBlueStacksX($bCheckOnly, True)
If $bInstalled And StringInStr($__BlueStacks_Version, "2.") <> 1 Then
If Not $bCheckOnly Then
SetLog("BlueStacks supported version 2 not found", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIF
If Not $bCheckOnly Then
EndIF
Return $bInstalled
EndFunc
Func RestartBlueStacksXCoC()
If Not $RunState Then Return False
Local $cmdOutput, $process_killed
If Not InitAndroid() Then Return False
If WinGetAndroidHandle() = 0 Then Return False
$cmdOutput = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " shell am start -W -S -n " & $AndroidGamePackage & "/" & $AndroidGameClass, $process_killed)
SetLog("Please wait for CoC restart......", $COLOR_INFO)
Return True
EndFunc
Func RestartBlueStacksCoC()
Return RestartBlueStacksXCoC()
EndFunc
Func RestartBlueStacks2CoC()
Return RestartBlueStacksXCoC()
EndFunc
Func CheckScreenBlueStacksX($bSetLog = True)
Local $REGISTRY_KEY_DIRECTORY = $HKLM & "\SOFTWARE\BlueStacks\Guests\Android\FrameBuffer\0"
Local $aValues[5][2] = [  ["FullScreen", 0],  ["GuestHeight", $AndroidClientHeight],  ["GuestWidth", $AndroidClientWidth],  ["WindowHeight", $AndroidClientHeight],  ["WindowWidth", $AndroidClientWidth]  ]
Local $i, $Value, $iErrCnt = 0
For $i = 0 To UBound($aValues) -1
$Value = RegRead($REGISTRY_KEY_DIRECTORY, $aValues[$i][0])
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func CheckScreenBlueStacks($bSetLog = True)
Return CheckScreenBlueStacksX($bSetLog)
EndFunc
Func CheckScreenBlueStacks2($bSetLog = True)
Return CheckScreenBlueStacksX($bSetLog)
EndFunc
Func SetScreenBlueStacks()
Local $REGISTRY_KEY_DIRECTORY = $HKLM & "\SOFTWARE\BlueStacks\Guests\Android\FrameBuffer\0"
RegWrite($REGISTRY_KEY_DIRECTORY, "FullScreen", "REG_DWORD", "0")
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestHeight", "REG_DWORD", $AndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestWidth", "REG_DWORD", $AndroidClientWidth)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowHeight", "REG_DWORD", $AndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowWidth", "REG_DWORD", $AndroidClientWidth)
EndFunc
Func SetScreenBlueStacks2()
Local $REGISTRY_KEY_DIRECTORY = $HKLM & "\SOFTWARE\BlueStacks\Guests\Android\FrameBuffer\0"
RegWrite($REGISTRY_KEY_DIRECTORY, "FullScreen", "REG_DWORD", "0")
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestHeight", "REG_DWORD", $AndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "GuestWidth", "REG_DWORD", $AndroidClientWidth)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowHeight", "REG_DWORD", $AndroidClientHeight)
RegWrite($REGISTRY_KEY_DIRECTORY, "WindowWidth", "REG_DWORD", $AndroidClientWidth)
$REGISTRY_KEY_DIRECTORY = $HKLM & "\SOFTWARE\BlueStacks\Guests\Android\Config"
RegWrite($REGISTRY_KEY_DIRECTORY, "FEControlBar", "REG_DWORD", "0")
EndFunc
Func RebootBlueStacksSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func ConfigBlueStacks2WindowManager()
If Not $RunState Then Return
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " shell wm size reset", $process_killed)
$cmdOutput = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " shell wm density 160", $process_killed)
AndroidSetFontSizeNormal()
EndFunc
Func RebootBlueStacks2SetScreen($bOpenAndroid = True)
If Not InitAndroid() Then Return False
ConfigBlueStacks2WindowManager()
CloseAndroid()
If _Sleep(1000) Then Return False
SetScreenAndroid()
If Not $RunState Then Return False
If $bOpenAndroid Then
OpenAndroid(True)
EndIf
Return True
EndFunc
Func GetBlueStacksRunningInstance($bStrictCheck = True)
WinGetAndroidHandle()
Local $a[2] = [$HWnD, ""]
Return $a
EndFunc
Func GetBlueStacks2RunningInstance($bStrictCheck = True)
WinGetAndroidHandle()
Local $a[2] = [$HWnD, ""]
If $HWnD <> 0 Then Return $a
If $bStrictCheck Then Return False
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $h = WinGetHandle("Bluestacks App Player", "")
If @error = 0 Then
$a[0] = $h
EndIf
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Return $a
EndFunc
Func GetBlueStacksProgramParameter($bAlternative = False)
Return "Android"
EndFunc
Func GetBlueStacks2ProgramParameter($bAlternative = False)
Return "Android"
EndFunc
Func BlueStacksBotStartEvent()
If $AndroidEmbedded = False Then
SetDebugLog("Disable " & $Android & " minimize/maximize Window Buttons")
DisableBS($HWnD, $SC_MINIMIZE)
DisableBS($HWnD, $SC_MAXIMIZE)
EndIf
Return AndroidCloseSystemBar()
EndFunc
Func BlueStacksBotStopEvent()
If $AndroidEmbedded = False Then
SetDebugLog("Enable " & $Android & " minimize/maximize Window Buttons")
EnableBS($HWnD, $SC_MINIMIZE)
EnableBS($HWnD, $SC_MAXIMIZE)
EndIf
Return AndroidOpenSystemBar()
EndFunc
Func BlueStacks2BotStartEvent()
If $AndroidEmbedded = False Then
SetDebugLog("Disable " & $Android & " minimize/maximize Window Buttons")
DisableBS($HWnD, $SC_MINIMIZE)
DisableBS($HWnD, $SC_MAXIMIZE)
EndIf
If $AndroidHasSystemBar Then Return AndroidCloseSystemBar()
Return False
EndFunc
Func BlueStacks2BotStopEvent()
If $AndroidEmbedded = False Then
SetDebugLog("Enable " & $Android & " minimize/maximize Window Buttons")
EnableBS($HWnD, $SC_MINIMIZE)
EnableBS($HWnD, $SC_MAXIMIZE)
EndIf
If $AndroidHasSystemBar Then Return AndroidOpenSystemBar()
Return False
EndFunc
Func BlueStacksAdjustClickCoordinates(ByRef $x, ByRef $y)
$x = Round(32767.0 / $AndroidClientWidth * $x)
$y = Round(32767.0 / $AndroidClientHeight * $y)
EndFunc
Func BlueStacks2AdjustClickCoordinates(ByRef $x, ByRef $y)
$x = Round(32767.0 / $AndroidClientWidth * $x)
$y = Round(32767.0 / $AndroidClientHeight * $y)
EndFunc
Func DisableBS($HWnD, $iButton)
$hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, 0)
_GUICtrlMenu_RemoveMenu($hSysMenu, $iButton, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
EndFunc
Func EnableBS($HWnD, $iButton)
$hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, 1)
_GUICtrlMenu_RemoveMenu($hSysMenu, $iButton, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
EndFunc
Func GetBlueStacksSvcPid()
Local $pid = ProcessExists2("HD-Service.exe")
Return $pid
EndFunc
Func CloseBS()
CloseAndroid()
EndFunc
Func CloseBlueStacks()
Local $iIndex, $bOops = False
Local $aServiceList[4] = ["BstHdAndroidSv", "BstHdLogRotatorSvc", "BstHdUpdaterSvc", "bthserv"]
If Not InitAndroid() Then Return
RunWait($__BlueStacks_Path & "HD-Quit.exe")
If @error <> 0 Then
SetLog($Android & " failed to quit", $COLOR_ERROR)
EndIf
If _Sleep(2000) Then Return
$bOops = ProcessExists("HD-Frontend.exe") <> 0
If $bOops Then
$bOops = False
SetDebugLog("Failed to terminate HD-Frontend.exe with HD-Quit.exe, fallback to taskkill", $COLOR_ERROR)
KillBSProcess()
If _Sleep(1000) Then Return
SetLog("Please wait for full BS shutdown....", $COLOR_SUCCESS)
For $iIndex = 0 To UBound($aServiceList) - 1
ServiceStop($aServiceList[$iIndex])
If @error Then
$bOops = True
If $debugsetlog = 1 Then Setlog($aServiceList[$iIndex] & "errored trying to stop", $COLOR_DEBUG)
EndIf
Next
If $bOops Then
If $debugsetlog = 1 Then Setlog("Service Stop issues, Stopping BS 2nd time", $COLOR_DEBUG)
KillBSProcess()
If _SleepStatus(5000) Then Return
EndIf
EndIf
If $debugsetlog = 1 And $bOops Then
SetLog("BS Kill Failed to stop service", $COLOR_DEBUG)
EndIf
If $bOops Then
SetError(1, @extended, -1)
EndIf
EndFunc
Func CloseBlueStacks2()
Local $bOops = False
If Not InitAndroid() Then Return
RunWait($__BlueStacks_Path & "HD-Quit.exe")
If @error <> 0 Then
SetLog($Android & " failed to quit", $COLOR_ERROR)
EndIf
If _Sleep(2000) Then Return
If $bOops Then
SetError(1, @extended, -1)
EndIf
EndFunc
Func KillBSProcess()
Local $iIndex
Local $aBS_FileNames[8][2] = [['HD-Agent.exe', 0], ['HD-BlockDevice.exe', 0], ['HD-Frontend.exe', 0],  ['HD-Network.exe', 0], ['HD-Service.exe', 0], ['HD-SharedFolder.exe', 0], ['HD-UpdaterService.exe', 0], ['HD-Adb.exe', 0]]
For $iIndex = 0 To UBound($aBS_FileNames) - 1
$aBS_FileNames[$iIndex][1] = ProcessExists($aBS_FileNames[$iIndex][0])
If $debugsetlog = 1 Then Setlog($aBS_FileNames[$iIndex][0] & " PID = " & $aBS_FileNames[$iIndex][1], $COLOR_DEBUG)
If $aBS_FileNames[$iIndex][1] > 0 Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -t -pid " & $aBS_FileNames[$iIndex][1], "", Default, @SW_HIDE)
If _Sleep(1000) Then Return
EndIf
If ProcessExists($aBS_FileNames[$iIndex][1]) Then
If $debugsetlog = 1 Then Setlog($aBS_FileNames[$iIndex][0] & " 1st Kill failed, trying again", $COLOR_DEBUG)
ShellExecute(@WindowsDir & "\System32\taskkill.exe", "-f -t -pid " & $aBS_FileNames[$iIndex][1], "", Default, @SW_HIDE)
If _Sleep(500) Then Return
EndIf
Next
EndFunc
Func ServiceStop($sServiceName)
Local $ServiceRunning, $svcWaitIterations, $data, $pid, $hTimer, $bFailed, $Result
$hTimer = TimerInit()
$Result = RunWait(@ComSpec & " /c " & 'net stop ' & $sServiceName, "", @SW_HIDE)
If @error Then
Setlog("net stop service failed on " & $sServiceName & ", Result= " & $Result, $COLOR_ERROR)
SetError(1, @extended, -1)
Return
EndIf
$ServiceRunning = True
$svcWaitIterations = 0
While $ServiceRunning
_StatusUpdateTime($hTimer, "BS Service Stop")
$data = ""
$pid = Run(@WindowsDir & '\System32\sc.exe query ' & $sServiceName, '', @SW_HIDE, 2)
Do
$data &= StdoutRead($pid)
Until @error
$Result = StringInStr($data, "stopped")
$bFailed = StringInStr($data, "failed")
If $Result Then
$ServiceRunning = False
EndIf
$svcWaitIterations = $svcWaitIterations + 1
If $svcWaitIterations > 15 Or $bFailed Then
SetError(1, @extended, -1)
$ServiceRunning = False
EndIf
If _Sleep(1000) Then Return
WEnd
If $debugsetlog = 1 And $svcWaitIterations > 15 Then
SetLog("Failed to stop service " & $sServiceName, $COLOR_DEBUG)
Else
If $debugsetlog = 1 Then SetLog($sServiceName & "Service stopped successfully", $COLOR_DEBUG)
EndIf
EndFunc
Func CloseUnsupportedBlueStacks2()
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
If IsArray(ControlGetPos("Bluestacks App Player", "", "")) Then
Opt("WinTitleMatchMode", $WinTitleMatchMode)
SetLog("MyBot doesn't work with " & $Android & " App Player", $COLOR_ERROR)
SetLog("Please let MyBot start " & $Android & " automatically", $COLOR_INFO)
RebootBlueStacks2SetScreen(False)
Return True
EndIf
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Return False
EndFunc
Func OpenDroid4X($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $launchAndroid, $cmdPar
SetLog("Starting " & $Android & " and Clash Of Clans", $COLOR_SUCCESS)
$launchAndroid = WinGetAndroidHandle() = 0
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
SetDebugLog("ShellExecute: " & $AndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($AndroidProgramPath, $cmdPar)
If _Sleep(1000) Then Return False
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= "&$PID)
If $PID = 0 Then
SetLog("Unable to load " & $Android & ($AndroidInstance = "" ? "" : "(" & $AndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
EndIf
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $RunState Then Return False
SetLog("Please wait while " & $Android & " and CoC start...", $COLOR_SUCCESS)
$hTimer = TimerInit()
If WaitForAndroidBootCompleted($AndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If Not $RunState Then Return False
If TimerDiff($hTimer) >= $AndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($Android & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($Android & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func GetDroid4XProgramParameter($bAlternative = False)
If Not $bAlternative Or $AndroidInstance <> $AndroidAppConfig[$AndroidConfig][1] Then
Return "-o " & ($AndroidInstance = "" ? $AndroidAppConfig[$AndroidConfig][1] : $AndroidInstance)
EndIf
Return ""
EndFunc
Func GetDroid4XPath()
Local $droid4xPath = RegRead($HKLM & "\SOFTWARE\Droid4X\", "InstallDir")
If @error <> 0 Then
Local $DisplayIcon = RegRead($HKLM & "\SOFTWARE" & $Wow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Droid4X\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1)
$droid4xPath = StringLeft($DisplayIcon, $iLastBS)
EndIf
EndIf
If @error <> 0 Then
$droid4xPath = @ProgramFilesDir & "\Droid4X\"
SetError(0, 0, 0)
EndIf
Return $droid4xPath
EndFunc
Func GetDroid4XAdbPath()
Local $adbPath = GetDroid4XPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitDroid4X($bCheckOnly = False)
Local $process_killed, $aRegExResult, $VirtualBox_Path, $AndroidAdbDeviceHost, $AndroidAdbDevicePort, $oops = 0
$__Droid4X_Version = RegRead($HKLM & "\SOFTWARE" & $Wow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Droid4X\", "DisplayVersion")
$__Droid4X_Path = GetDroid4XPath()
$VirtualBox_Path = RegRead($HKLM & "\SOFTWARE\Oracle\VirtualBox\", "InstallDir")
If @error <> 0 Then
$VirtualBox_Path = @ProgramFilesDir & "\Oracle\VirtualBox\"
SetError(0, 0, 0)
EndIf
If FileExists($__Droid4X_Path & "Droid4X.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_ERROR)
SetLog($__Droid4X_Path & "Droid4X.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($__Droid4X_Path & "adb.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_ERROR)
SetLog($__Droid4X_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($VirtualBox_Path & "VBoxManage.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find VirtualBox:", $COLOR_ERROR)
SetLog($VirtualBox_Path & "VBoxManage.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxManage_Path = $VirtualBox_Path & "VBoxManage.exe"
$__VBoxVMinfo = LaunchConsole($__VBoxManage_Path, "showvminfo " & $AndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $Android & " instance " & $AndroidInstance, $COLOR_ERROR)
Return False
EndIf
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidAdbDeviceHost = $aRegExResult[0]
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: Read $AndroidAdbDeviceHost = " & $AndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $Android & "(" & $AndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIF
$aRegExResult = StringRegExp($__VBoxVMinfo, "ADB_PORT.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidAdbDevicePort = $aRegExResult[0]
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: Read $AndroidAdbDevicePort = " & $AndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $Android & "(" & $AndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIF
If $oops = 0 Then
$AndroidAdbDevice = $AndroidAdbDeviceHost & ":" & $AndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $AndroidAdbDevice & " for " & $Android, $COLOR_ERROR)
EndIf
$AndroidProgramPath = $__Droid4X_Path & "Droid4X.exe"
$AndroidAdbPath = FindPreferredAdbPath()
If $AndroidAdbPath = "" Then $AndroidAdbPath = $__Droid4X_Path & "adb.exe"
$AndroidVersion = $__Droid4X_Version
If $AndroidInstance = "" Or StringCompare($AndroidInstance, $AndroidAppConfig[$AndroidConfig][1]) = 0 Then
Else
If $Title = $AndroidAppConfig[$AndroidConfig][2] Then
$Title = StringReplace($AndroidAppConfig[$AndroidConfig][2], "Droid4X", $AndroidInstance)
EndIf
EndIf
$AndroidPicturesPath = "/mnt/shared/picture/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'picture', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
SetLog($Android & " Background Mode is not available", $COLOR_ERROR)
$AndroidPicturesHostPath = ""
$AndroidAdbScreencap = False
EndIf
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $AndroidInstance, $process_killed)
WinGetAndroidHandle()
UpdateDroid4XConfig()
EndIf
Return True
EndFunc
Func SetScreenDroid4X()
If Not $RunState Then Return False
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $AndroidInstance & " vbox_graph_mode " & $AndroidClientWidth & "x" & $AndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $AndroidInstance & " vbox_dpi 160", $process_killed)
If $ichkBackground = 1 And $AndroidAdbScreencap = False And $AndroidPicturesPathAutoConfig = True And BitAND($AndroidSupportFeature, 2) = 2 and FileExists($AndroidPicturesHostPath) = 1 Then
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder add " & $AndroidInstance & " --name picture --hostpath """ & $AndroidPicturesHostPath & """  --automount", $process_killed)
EndIf
Return True
EndFunc
Func RebootDroid4XSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CheckScreenDroid4X($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [  ["vbox_dpi", "160"],  ["vbox_graph_mode", $AndroidClientWidth & "x" & $AndroidClientHeight & "-16"]  ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult, $properties
For $i = 0 To UBound($aValues) -1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
If $ichkBackground = 1 And $AndroidAdbScreencap = False And $AndroidPicturesPathAutoConfig = True And BitAND($AndroidSupportFeature, 2) = 2 Then
Local $myPictures = RegRead("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\", "My Pictures")
If @error = 0 And FileExists($myPictures) = 1 Then
$AndroidPicturesHostPath = $myPictures & "\" & $Android & " Photo"
If DirCreate($AndroidPicturesHostPath) = 1 Then
SetLog("Configure " & $Android & " to support Background Mode", $COLOR_SUCCESS)
SetLog("Folder created: " & $AndroidPicturesHostPath, $COLOR_SUCCESS)
SetLog("This shared folder will be added to " & $Android, $COLOR_SUCCESS)
Return False
Else
SetLog("Cannot configure " & $Android & " Background Mode", $COLOR_SUCCESS)
SetLog("Cannot create folder: " & $AndroidPicturesHostPath, $COLOR_ERROR)
$AndroidPicturesPathAutoConfig = False
EndIf
Else
SetLog("Cannot configure " & $Android & " Background Mode", $COLOR_SUCCESS)
SetLog("Cannot find current user 'My Pictures' folder", $COLOR_ERROR)
$AndroidPicturesPathAutoConfig = False
EndIf
EndIf
Return True
EndFunc
Func UpdateDroid4XConfig()
Return UpdateDroid4XWindowState()
EndFunc
Func UpdateDroid4XWindowState()
WinGetAndroidHandle()
ControlGetPos($hWnD, $AppPaneName, $AppClassInstance)
If @error = 1 Then
SetError(0, 0, 0)
Return False
EndIf
Local $acw = $AndroidAppConfig[$AndroidConfig][5]
Local $ach = $AndroidAppConfig[$AndroidConfig][6]
Local $aww = $AndroidAppConfig[$AndroidConfig][7]
Local $awh = $AndroidAppConfig[$AndroidConfig][8]
Local $v = GetVersionNormalized($AndroidVersion)
For $i = 0 To UBound($__Droid4X_Window) - 1
Local $v2 = GetVersionNormalized($__Droid4X_Window[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Window sizes of " & $Android & " " & $__Droid4X_Window[$i][0])
$aww = $__Droid4X_Window[$i][1]
$awh = $__Droid4X_Window[$i][2]
ExitLoop
EndIf
Next
Local $i
Local $Values[4][3] = [  ["Screen Width", $AndroidClientWidth  , $AndroidClientWidth],  ["Screen Height", $AndroidClientHeight, $AndroidClientHeight],  ["Window Width", $AndroidWindowWidth  , $AndroidWindowWidth],  ["Window Height", $AndroidWindowHeight , $AndroidWindowHeight]  ]
Local $bChanged = False, $ok = False
$Values[0][2] = $acw
$Values[1][2] = $ach
$Values[2][2] = $aww
$Values[3][2] = $awh
$AndroidClientWidth = $Values[0][2]
$AndroidClientHeight = $Values[1][2]
$AndroidWindowWidth =  $Values[2][2]
$AndroidWindowHeight = $Values[3][2]
For $i = 0 To UBound($Values) -1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($Android & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
Return $bChanged
EndFunc
Func CloseDroid4X()
Return CloseVboxAndroidSvc()
EndFunc
Func OpenMEmu($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $Android & " and Clash Of Clans", $COLOR_SUCCESS)
$launchAndroid = WinGetAndroidHandle() = 0
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
SetDebugLog("ShellExecute: " & $AndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($AndroidProgramPath, $cmdPar, $__MEmu_Path)
If _Sleep(1000) Then Return False
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= "&$PID)
If $PID = 0 Then
SetLog("Unable to load " & $Android & ($AndroidInstance = "" ? "" : "(" & $AndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $Android & " and CoC start...", $COLOR_SUCCESS)
$hTimer = TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $RunState Then Return False
If WaitForAndroidBootCompleted($AndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If TimerDiff($hTimer) >= $AndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($Android & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($Android & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func GetMEmuProgramParameter($bAlternative = False)
If Not $bAlternative Or $AndroidInstance <> $AndroidAppConfig[$AndroidConfig][1] Then
Return ($AndroidInstance = "" ? $AndroidAppConfig[$AndroidConfig][1] : $AndroidInstance)
EndIf
Return ""
EndFunc
Func GetMEmuPath()
Local $MEmu_Path = EnvGet("MEmu_Path") & "\MEmu\"
If FileExists($MEmu_Path & "MEmu.exe") = 0 Then
Local $InstallLocation = RegRead($HKLM & "\SOFTWARE" & $Wow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "InstallLocation")
If @error = 0 And FileExists($InstallLocation & "\MEmu\MEmu.exe") = 1 Then
$MEmu_Path = $InstallLocation & "\MEmu\"
Else
Local $DisplayIcon = RegRead($HKLM & "\SOFTWARE" & $Wow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "DisplayIcon")
If @error = 0 Then
Local $iLastBS = StringInStr($DisplayIcon, "\", 0, -1)
$MEmu_Path = StringLeft($DisplayIcon, $iLastBS)
If StringLeft($MEmu_Path, 1) = """" Then $MEmu_Path = StringMid($MEmu_Path, 2)
Else
$MEmu_Path = @ProgramFilesDir & "\Microvirt\MEmu\"
SetError(0, 0, 0)
EndIf
EndIf
EndIf
$MEmu_Path = StringReplace($MEmu_Path, "\\", "\")
Return $MEmu_Path
EndFunc
Func GetMEmuAdbPath()
Local $adbPath = GetMEmuPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitMEmu($bCheckOnly = False)
Local $process_killed, $aRegExResult, $AndroidAdbDeviceHost, $AndroidAdbDevicePort, $oops = 0
Local $MEmuVersion = RegRead($HKLM & "\SOFTWARE" & $Wow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\MEmu\", "DisplayVersion")
SetError(0, 0, 0)
Local $MEmu_Path = GetMEmuPath()
Local $MEmu_Manage_Path = EnvGet("MEmuHyperv_Path") & "\MEmuManage.exe"
If FileExists($MEmu_Manage_Path) = 0 Then
$MEmu_Manage_Path = $MEmu_Path & "..\MEmuHyperv\MEmuManage.exe"
EndIf
If FileExists($MEmu_Path & "MEmu.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_ERROR)
SetLog($MEmu_Path & "MEmu.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($MEmu_Path & "adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_ERROR)
SetLog($MEmu_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($MEmu_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find MEmu-Hyperv:", $COLOR_ERROR)
SetLog($MEmu_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxVMinfo = LaunchConsole($MEmu_Manage_Path, "showvminfo " & $AndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $Android & " instance " & $AndroidInstance, $COLOR_ERROR)
Return False
EndIf
$AndroidProgramPath = $MEmu_Path & "MEmu.exe"
$AndroidAdbPath = FindPreferredAdbPath()
If $AndroidAdbPath = "" Then $AndroidAdbPath = $MEmu_Path & "adb.exe"
$AndroidVersion = $MEmuVersion
$__MEmu_Path = $MEmu_Path
$__VBoxManage_Path = $MEmu_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = ADB.*host ip = ([^,]+),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidAdbDeviceHost = $aRegExResult[0]
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: Read $AndroidAdbDeviceHost = " & $AndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $Android & "(" & $AndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIF
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = ADB.*host port = (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidAdbDevicePort = $aRegExResult[0]
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: Read $AndroidAdbDevicePort = " & $AndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $Android & "(" & $AndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIF
If $oops = 0 Then
$AndroidAdbDevice = $AndroidAdbDeviceHost & ":" & $AndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $AndroidAdbDevice & " for " & $Android, $COLOR_ERROR)
EndIf
$AndroidPicturesPath = "/mnt/shell/emulated/0/Pictures/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'picture', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$oops = 1
$AndroidAdbScreencap = False
$AndroidPicturesHostPath = ""
SetLog($Android & " Background Mode is not available", $COLOR_ERROR)
EndIf
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $AndroidInstance, $process_killed)
UpdateMEmuConfig()
EndIf
Return SetError($oops, 0, True)
EndFunc
Func WaitForAmMEmu($WaitInSec, $hTimer = 0)
Local $cmdOutput, $connected_to, $am_ready, $process_killed, $hMyTimer
$hMyTimer = ($hTimer = 0 ? TimerInit() : $hTimer)
While True
If Not $RunState Then Return True
$cmdOutput = LaunchConsole($AndroidAdbPath, "connect " & $AndroidAdbDevice, $process_killed)
$connected_to = StringInStr($cmdOutput, "connected to")
$cmdOutput = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " shell am display-size reset", $process_killed)
If $hTimer <> 0 Then _StatusUpdateTime($hTimer)
$am_ready = StringLen($cmdOutput) < 4
If $am_ready Then ExitLoop
If TimerDiff($hMyTimer) > $WaitInSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($Android & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for activity manager", $COLOR_ERROR)
SetError(1, @extended, False)
Return True
EndIf
If _Sleep(1000) Then Return True
WEnd
Return False
EndFunc
Func SetScreenMEmu()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $AndroidInstance & " resolution_width " & $AndroidClientWidth, $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $AndroidInstance & " resolution_height " & $AndroidClientHeight, $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $AndroidInstance & " is_full_screen 0", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $AndroidInstance & " is_customed_resolution 1", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $AndroidInstance & " vbox_dpi 160", $process_killed)
Return True
EndFunc
Func RebootMEmuSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseMEmu()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenMEmu($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[4][2] = [  ["is_full_screen", "0"],  ["vbox_dpi", "160"],  ["resolution_height", $AndroidClientHeight],  ["resolution_width", $AndroidClientWidth]  ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) -1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func UpdateMEmuConfig()
Local $Value, $process_killed, $aRegExResult
$Value = LaunchConsole($__VBoxManage_Path, "guestproperty get " & $AndroidInstance & " phone_layout", $process_killed)
$aRegExResult = StringRegExp($Value, "Value: (.+)", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$__MEmu_PhoneLayout = $aRegExResult[0]
SetDebugLog($Android & " phone_layout is " & $__MEmu_PhoneLayout, $COLOR_ERROR)
Else
SetDebugLog("Cannot read " & $Android & " guestproperty phone_layout!", $COLOR_ERROR)
EndIF
SetError(0, 0, 0)
Return UpdateMEmuWindowState()
EndFunc
Func UpdateMEmuWindowState()
WinGetAndroidHandle()
ControlGetPos($hWnD, $AppPaneName, $AppClassInstance)
If @error = 1 Then
SetError(0, 0, 0)
EndIf
Local $acw = $AndroidAppConfig[$AndroidConfig][5]
Local $ach = $AndroidAppConfig[$AndroidConfig][6]
Local $aww = $AndroidAppConfig[$AndroidConfig][7]
Local $awh = $AndroidAppConfig[$AndroidConfig][8]
Local $tbw = $__MEmu_ToolBar_Width
Local $v = GetVersionNormalized($AndroidVersion)
For $i = 0 To UBound($__MEmu_Window) - 1
Local $v2 = GetVersionNormalized($__MEmu_Window[$i][0])
If $v >= $v2 Then
SetDebugLog("Using Window sizes of " & $Android & " " & $__MEmu_Window[$i][0])
$aww = $__MEmu_Window[$i][1]
$awh = $__MEmu_Window[$i][2]
$tbw = $__MEmu_Window[$i][3]
ExitLoop
EndIf
Next
Local $bToolBarVisible = True
Local $i
Local $Values[4][3] = [  ["Screen Width", $AndroidClientWidth  , $AndroidClientWidth],  ["Screen Height", $AndroidClientHeight, $AndroidClientHeight],  ["Window Width", $AndroidWindowWidth  , $AndroidWindowWidth],  ["Window Height", $AndroidWindowHeight , $AndroidWindowHeight]  ]
Local $bChanged = False, $ok = False
Local $toolBarPos = ControlGetPos($Title, "", "Qt5QWindowIcon3")
If UBound($toolBarPos) = 4 Then
If $toolBarPos[2] = $tbw Then
$bToolBarVisible = ControlCommand($Title, "", "Qt5QWindowIcon3", "IsVisible", "") = 1
SetDebugLog($Android & " Tool Bar is " & ($bToolBarVisible ? "visible" : "hidden"))
$ok = True
EndIf
EndIf
If Not $ok Then
SetDebugLog($Android & " Tool Bar state is undetermined as treated as " & ($bToolBarVisible ? "visible" : "hidden"), $COLOR_ERROR)
EndIF
Local $w = ($bToolBarVisible ? 0 : $tbw)
Switch $__MEmu_PhoneLayout
Case "0"
$Values[0][2] = $acw
$Values[1][2] = $ach
$Values[2][2] = $aww - $w
$Values[3][2] = $awh
Case "1"
$Values[0][2] = $acw + $__MEmu_SystemBar
$Values[1][2] = $ach - $__MEmu_SystemBar
$Values[2][2] = $aww + $__MEmu_SystemBar - $w
$Values[3][2] = $awh - $__MEmu_SystemBar
Case "2"
$Values[0][2] = $acw
$Values[1][2] = $ach - $__MEmu_SystemBar
$Values[2][2] = $aww - $w
$Values[3][2] = $awh - $__MEmu_SystemBar
Case Else
SetDebugLog("Unsupported " & $Android & " guestproperty phone_layout = " & $__MEmu_PhoneLayout, $COLOR_ERROR)
EndSwitch
$AndroidClientWidth = $Values[0][2]
$AndroidClientHeight = $Values[1][2]
$AndroidWindowWidth =  $Values[2][2]
$AndroidWindowHeight = $Values[3][2]
For $i = 0 To UBound($Values) -1
If $Values[$i][1] <> $Values[$i][2] Then
$bChanged = True
SetDebugLog($Android & " " & $Values[$i][0] & " updated from " & $Values[$i][1] & " to " & $Values[$i][2])
EndIf
Next
Return $bChanged
EndFunc
Func OpenLeapDroid($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $Android & " and Clash Of Clans", $COLOR_SUCCESS)
$launchAndroid = WinGetAndroidHandle() = 0
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
SetDebugLog("ShellExecute: " & $AndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($AndroidProgramPath, $cmdPar, $__LeapDroid_Path)
If _Sleep(1000) Then Return False
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= " & $PID)
If $PID = 0 Then
SetLog("Unable to load " & $Android & ($AndroidInstance = "" ? "" : "(" & $AndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $Android & " and CoC start...", $COLOR_SUCCESS)
$hTimer = TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $RunState Then Return False
If WaitForAndroidBootCompleted($AndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If TimerDiff($hTimer) >= $AndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($Android & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($Android & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsLeapDroidCommandLine($CommandLine)
SetDebugLog("Check LeapDroid command line instance: " & $CommandLine)
Local $sInstance = ($AndroidInstance = "" ? $AndroidAppConfig[$AndroidConfig][1] : $AndroidInstance)
$CommandLine = StringReplace($CommandLine, GetLeapDroidPath(), "")
If StringRegExp($CommandLine, "-s " & $sInstance & "\b") = 1 Then Return True
Return False
EndFunc
Func GetLeapDroidProgramParameter($bAlternative = False)
Local $sInstance = ($AndroidInstance = "" ? $AndroidAppConfig[$AndroidConfig][1] : $AndroidInstance)
If Not $bAlternative Or $AndroidInstance <> $AndroidAppConfig[$AndroidConfig][1] Then
Return "-vfiber -novtcheck -w " & $AndroidClientWidth & " -h " & $AndroidClientHeight & " -s " & $sInstance
EndIf
Return "-s " & $sInstance
EndFunc
Func GetLeapDroidPath()
Local $LeapDroid_Path = RegRead($HKLM & "\SOFTWARE\Leapdroid\Leapdroid VM\", "InstallDir")
If $LeapDroid_Path <> "" And FileExists($LeapDroid_Path & "\LeapdroidVM.exe") = 0 Then
$LeapDroid_Path = ""
EndIf
Local $InstallLocation = RegRead($HKLM & "\SOFTWARE" & $Wow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\LeapdroidVM\", "InstallLocation")
If $LeapDroid_Path = "" And FileExists($InstallLocation & "\leapdroidvm.ini") = 1 Then
$LeapDroid_Path = IniRead($InstallLocation & "\leapdroidvm.ini", "main", "install_path", "")
If FileExists($LeapDroid_Path & "\LeapdroidVM.exe") = 0 Then
$LeapDroid_Path = ""
EndIf
EndIf
If $LeapDroid_Path = "" And FileExists($InstallLocation & "\LeapdroidVM.exe") = 1 Then
$LeapDroid_Path = $InstallLocation
EndIf
If $LeapDroid_Path = "" And FileExists(@ProgramFilesDir & "\Leapdroid\VM\LeapdroidVM.exe") = 1 Then
$LeapDroid_Path = @ProgramFilesDir & "\Leapdroid\VM"
EndIf
SetError(0, 0, 0)
If $LeapDroid_Path <> "" And StringRight($LeapDroid_Path, 1) <> "\" Then $LeapDroid_Path &= "\"
Return $LeapDroid_Path
EndFunc
Func GetLeapDroidAdbPath()
Local $adbPath = GetLeapDroidPath() & "adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitLeapDroid($bCheckOnly = False)
Local $process_killed, $aRegExResult, $AndroidAdbDeviceHost, $AndroidAdbDevicePort, $oops = 0
Local $LeapDroidVersion = RegRead($HKLM & "\SOFTWARE" & $Wow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\LeapDroid\", "DisplayVersion")
SetError(0, 0, 0)
Local $LeapDroid_Path = GetLeapDroidPath()
Local $LeapDroid_Manage_Path = GetLeapDroidPath() & "VBoxManage.exe"
If FileExists($LeapDroid_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android, $COLOR_ERROR)
SetLog("installation directory", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($Android & ": Cannot find installation directory")
EndIf
Return False
EndIf
If FileExists($LeapDroid_Path & "LeapdroidVM.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_ERROR)
SetLog($LeapDroid_Path & "LeapdroidVM.exe", $COLOR_ERROR)
Else
SetDebugLog($Android & ": Cannot find " & $LeapDroid_Path & "LeapdroidVM.exe")
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($LeapDroid_Path & "adb.exe") = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_ERROR)
SetLog($LeapDroid_Path & "adb.exe", $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($Android & ": Cannot find " & $LeapDroid_Path & "adb.exe")
EndIf
Return False
EndIf
If FileExists($LeapDroid_Manage_Path) = 0 Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_ERROR)
SetLog($LeapDroid_Manage_Path, $COLOR_ERROR)
SetError(1, @extended, False)
Else
SetDebugLog($Android & ": Cannot find " & $LeapDroid_Manage_Path)
EndIf
Return False
EndIf
Local $ops = 0
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxVMinfo = LaunchConsole($LeapDroid_Manage_Path, "showvminfo " & $AndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $Android & " instance " & $AndroidInstance, $COLOR_ERROR)
Return False
EndIf
$__VBoxGuestProperties = LaunchConsole($LeapDroid_Manage_Path, "guestproperty enumerate " & $AndroidInstance, $process_killed)
$AndroidProgramPath = $LeapDroid_Path & "LeapdroidVM.exe"
$AndroidAdbPath = FindPreferredAdbPath()
If $AndroidAdbPath = "" Then $AndroidAdbPath = $LeapDroid_Path & "adb.exe"
$AndroidVersion = $LeapDroidVersion
$__LeapDroid_Path = $LeapDroid_Path
$__VBoxManage_Path = $LeapDroid_Manage_Path
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: adb_port, value: (\d{3,5}),", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidAdbDeviceHost = "127.0.0.1"
$AndroidAdbDevicePort = $aRegExResult[0]
If $debugSetlog = 1 Then Setlog("InitLeapDroid: Read $AndroidAdbDevicePort = " & $AndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $Android & "(" & $AndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIf
If $oops = 0 Then
$AndroidAdbDevice = "emulator-" & ($AndroidAdbDevicePort - 1)
Else
SetLog("Using ADB default device " & $AndroidAdbDevice & " for " & $Android, $COLOR_ERROR)
EndIf
$AndroidPicturesPath = "/mnt/shared/yw_shared/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'yw_shared', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$AndroidPicturesPath = "/mnt/shared/LeapDroidShared/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'LeapDroidShared', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidPicturesHostPath = $aRegExResult[0] & "\"
Else
$oops = 1
$AndroidAdbScreencap = False
$AndroidPicturesHostPath = ""
SetLog($Android & " Background Mode is not available", $COLOR_ERROR)
EndIf
EndIf
$UpdateAndroidWindowTitle = True
EndIf
Return SetError($oops, 0, True)
EndFunc
Func UpdateLeapdroidSettings(ByRef $fileContent, $param, $value)
$fileContent = StringRegExpReplace($fileContent, "^(" & $param & "=.*)", $param & "=" & $value)
Return @extended
EndFunc
Func SetScreenLeapDroid()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
Local $files[2] = [@MyDocumentsDir & "\Leapdroid\Leapdroid Emulator\leapdroid.settings", GetLeapDroidPath() & "Leapdroid Emulator\leapdroid.settings"]
Local $f, $p, $h
For $f in $files
$p = StringMid($f, 1, StringInStr($f, "\", 0, -1))
If FileExists($p) Then
If FileExists($f) = 0 Then
$h = FileOpen($f, $FO_OVERWRITE)
If $h = -1 Then
SetLog("Cannot write " & $Android & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
FileWrite($h, "RESOLUTION=" & $GAME_WIDTH & "x" & $GAME_HEIGHT & @CRLF & "DPI=160")
FileClose($h)
Else
Local $i
$h = FileOpen($f, $FO_READ)
If $h = -1 Then
SetLog("Cannot read " & $Android & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
Local $s = FileRead($h)
FileClose($h)
$i = UpdateLeapdroidSettings($s, "RESOLUTION", $GAME_WIDTH & "x" & $GAME_HEIGHT)
If $i < 1 Then SetDebugLog("Cannot update " & $Android & " screen resolution in file:" & @CRLF & $f, $COLOR_ERROR)
$i = UpdateLeapdroidSettings($s, "DPI", "160")
If $i < 1 Then SetDebugLog("Cannot update " & $Android & " screen DPI in file:" & @CRLF & $f, $COLOR_ERROR)
$h = FileOpen($f, $FO_OVERWRITE)
If $h = -1 Then
SetLog("Cannot write " & $Android & " config file:" & @CRLF & $f, $COLOR_ERROR)
ContinueLoop
EndIf
FileWrite($h, $s)
FileClose($h)
EndIf
EndIf
Next
Return True
EndFunc
Func RebootLeapDroidSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseLeapDroid()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenLeapDroid($bSetLog = True)
If Not InitAndroid() Then Return False
Return True
EndFunc
Func EmbedLeapDroid($bEmbed = Default)
If $bEmbed = Default Then $bEmbed = $AndroidEmbedded
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hQTool = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "QTool" Then
$hQTool = $h
ExitLoop
EndIf
Next
If $hQTool = 0 Then
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): QTool Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedLeapDroid(" & $bEmbed & "): $hQTool=" & $hQTool, Default, True)
WinMove2($hQTool, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hQTool, ($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
EndIf
EndFunc
Func LeapDroidBotStartEvent()
Return AndroidCloseSystemBar()
EndFunc
Func LeapDroidBotStopEvent()
Return AndroidOpenSystemBar()
EndFunc
Func OpenNox($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $Android & " and Clash Of Clans", $COLOR_SUCCESS)
$launchAndroid = WinGetAndroidHandle() = 0
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter()
SetDebugLog("ShellExecute: " & $AndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($AndroidProgramPath, $cmdPar, $__Nox_Path)
If _Sleep(1000) Then Return False
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= "&$PID)
If $PID = 0 Then
SetLog("Unable to load " & $Android & ($AndroidInstance = "" ? "" : "(" & $AndroidInstance & ")") & ", please check emulator/installation.", $COLOR_ERROR)
SetLog("Unable to continue........", $COLOR_WARNING)
btnStop()
SetError(1, 1, -1)
Return False
EndIf
EndIf
SetLog("Please wait while " & $Android & " and CoC start...", $COLOR_SUCCESS)
$hTimer = TimerInit()
If WaitForRunningVMS($AndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
$InitAndroid = True
InitAndroid()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $RunState Then Return False
If WaitForAndroidBootCompleted($AndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return False
If TimerDiff($hTimer) >= $AndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_ERROR)
SetLog($Android & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_ERROR)
SetError(1, @extended, False)
Return False
EndIf
SetLog($Android & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_SUCCESS)
Return True
EndFunc
Func IsNoxCommandLine($CommandLine)
SetDebugLog($CommandLine)
$CommandLine = StringReplace($CommandLine, GetNoxRtPath(), "")
$CommandLine = StringReplace($CommandLine, "Nox.exe", "")
Local $param1 = StringReplace(GetNoxProgramParameter(), """", "")
Local $param2 = StringReplace(GetNoxProgramParameter(True), """", "")
If StringInStr($CommandLine, $param1 & " ") > 0 Or StringRight($CommandLine, StringLen($param1)) = $param1 Then Return True
If StringInStr($CommandLine, $param2 & " ") > 0 Or StringRight($CommandLine, StringLen($param2)) = $param2 Then Return True
If StringInStr($CommandLine, "-clone:") = 0 And $param2 = "" Then Return True
Return False
EndFunc
Func GetNoxProgramParameter($bAlternative = False)
Local $customScreen = "-resolution:" & $AndroidClientWidth & "x" & $AndroidClientHeight & " -dpi:160"
Local $clone = """-clone:" & ($AndroidInstance = "" ? $AndroidAppConfig[$AndroidConfig][1] : $AndroidInstance) & """"
If $bAlternative = False Then
Return $customScreen & " " & $clone
EndIf
If $AndroidInstance = "" Or $AndroidInstance = $AndroidAppConfig[$AndroidConfig][1] Then Return ""
Return $clone
EndFunc
Func GetNoxRtPath()
Local $path = RegRead($HKLM & "\SOFTWARE\BigNox\VirtualBox\", "InstallDir")
If @error = 0 Then
If StringRight($path, 1) <> "\" Then $path &= "\"
Else
$path = @ProgramFilesDir & "\Bignox\BigNoxVM\RT\"
SetError(0, 0, 0)
EndIf
Return $path
EndFunc
Func GetNoxPath()
Local $path = RegRead($HKLM & "\SOFTWARE" & $Wow6432Node & "\DuoDianOnline\SetupInfo\", "InstallPath")
If @error = 0 Then
If StringRight($path, 1) <> "\" Then $path &= "\"
$path &= "bin\"
Else
$path = ""
SetError(0, 0, 0)
EndIf
Return $path
EndFunc
Func GetNoxAdbPath()
Local $adbPath = GetNoxPath() & "nox_adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitNox($bCheckOnly = False)
Local $process_killed, $aRegExResult, $AndroidAdbDeviceHost, $AndroidAdbDevicePort, $oops = 0
Local $Version = RegRead($HKLM & "\SOFTWARE" & $Wow6432Node & "\Microsoft\Windows\CurrentVersion\Uninstall\Nox\", "DisplayVersion")
SetError(0, 0, 0)
Local $Path = GetNoxPath()
Local $RtPath = GetNoxRtPath()
Local $NoxFile = $Path & "Nox.exe"
Local $AdbFile = $Path & "nox_adb.exe"
Local $VBoxFile = $RtPath & "BigNoxVMMgr.exe"
Local $Files[3] = [$NoxFile, $AdbFile, $VBoxFile]
Local $File
For $File in $Files
If FileExists($File) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & " file:", $COLOR_ERROR)
SetLog($File, $COLOR_ERROR)
SetError(1, @extended, False)
EndIf
Return False
EndIf
Next
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxVMinfo = LaunchConsole($VBoxFile, "showvminfo " & $AndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $Android & " instance " & $AndroidInstance, $COLOR_ERROR)
Return False
EndIf
$AndroidProgramPath = $NoxFile
$AndroidAdbPath = FindPreferredAdbPath()
If $AndroidAdbPath = "" Then $AndroidAdbPath = GetNoxAdbPath()
$AndroidVersion = $Version
$__Nox_Path = $Path
$__VBoxManage_Path = $VBoxFile
$aRegExResult = StringRegExp($__VBoxVMinfo, ".*host ip = ([^,]+), .* guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidAdbDeviceHost = $aRegExResult[0]
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: Read $AndroidAdbDeviceHost = " & $AndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $Android & "(" & $AndroidInstance & ") ADB Device Host", $COLOR_ERROR)
EndIF
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host port = (\d{3,5}), .* guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidAdbDevicePort = $aRegExResult[0]
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: Read $AndroidAdbDevicePort = " & $AndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $Android & "(" & $AndroidInstance & ") ADB Device Port", $COLOR_ERROR)
EndIF
If $oops = 0 Then
$AndroidAdbDevice = $AndroidAdbDeviceHost & ":" & $AndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $AndroidAdbDevice & " for " & $Android, $COLOR_ERROR)
EndIf
$AndroidPicturesPath = "/mnt/shared/Other/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'Other', Host path: '(.*)'.*", $STR_REGEXPARRAYGLOBALMATCH)
If Not @error Then
$AndroidPicturesHostPath = $aRegExResult[UBound($aRegExResult) - 1] & "\"
Else
$AndroidAdbScreencap = False
$AndroidPicturesHostPath = ""
SetLog($Android & " Background Mode is not available", $COLOR_ERROR)
EndIf
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $AndroidInstance, $process_killed)
EndIf
Return True
EndFunc
Func SetScreenNox()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
If $AndroidPicturesPathAutoConfig = True and FileExists($AndroidPicturesHostPath) = 1 Then
$cmdOutput = LaunchConsole($__VBoxManage_Path, "sharedfolder add " & $AndroidInstance & " --name Other --hostpath """ & $AndroidPicturesHostPath & """  --automount", $process_killed)
EndIf
Return True
EndFunc
Func RebootNoxSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseNox()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenNox($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [  ["vbox_dpi", "160"],  ["vbox_graph_mode", $AndroidClientWidth & "x" & $AndroidClientHeight & "-16"]  ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) -1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_ERROR)
Else
SetDebugLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_ERROR)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_ERROR)
EndIf
$iErrCnt += 1
EndIf
Next
If $AndroidPicturesPathAutoConfig = True Then
If $AndroidPicturesHostPath = "" Then
Local $path = @MyDocumentsDir
If FileExists($path) = 1 Then
$AndroidPicturesHostPath = $path & "\Nox_share\Other"
If FileExists($AndroidPicturesHostPath) = 1 Then
SetLog("Configure " & $Android & " to support Background Mode", $COLOR_SUCCESS)
SetLog("Folder exists: " & $AndroidPicturesHostPath, $COLOR_SUCCESS)
SetLog("This shared folder will be added to " & $Android, $COLOR_SUCCESS)
Return False
EndIf
If DirCreate($AndroidPicturesHostPath) = 1 Then
SetLog("Configure " & $Android & " to support Background Mode", $COLOR_SUCCESS)
SetLog("Folder created: " & $AndroidPicturesHostPath, $COLOR_SUCCESS)
SetLog("This shared folder will be added to " & $Android, $COLOR_SUCCESS)
Return False
Else
SetLog("Cannot configure " & $Android & " Background Mode", $COLOR_SUCCESS)
SetLog("Cannot create folder: " & $AndroidPicturesHostPath, $COLOR_ERROR)
$AndroidPicturesPathAutoConfig = False
EndIf
Else
SetLog("Cannot configure " & $Android & " Background Mode", $COLOR_SUCCESS)
SetLog("Cannot find current user 'Documents' folder", $COLOR_ERROR)
$AndroidPicturesPathAutoConfig = False
EndIf
ElseIf FileExists($AndroidPicturesHostPath) = 0 Then
If DirCreate($AndroidPicturesHostPath) = 1 Then
SetLog("Configure " & $Android & " to support ADB", $COLOR_SUCCESS)
SetLog("Folder created: " & $AndroidPicturesHostPath, $COLOR_SUCCESS)
SetLog("This shared folder will be added to " & $Android, $COLOR_SUCCESS)
Return False
Else
SetLog("Cannot configure " & $Android & " Background Mode", $COLOR_SUCCESS)
SetLog("Cannot create folder: " & $AndroidPicturesHostPath, $COLOR_ERROR)
$AndroidPicturesPathAutoConfig = False
EndIf
EndIf
EndIf
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func GetNoxRunningInstance($bStrictCheck = True)
Local $a[2] = [0, ""]
SetDebugLog("GetAndroidRunningInstance: Try to find """ & $AndroidProgramPath & """")
For $pid In ProcessesExist($AndroidProgramPath, "", 1)
Local $currentInstance = $AndroidInstance
Local $commandLine = ProcessGetCommandLine($pid)
SetDebugLog("GetNoxRunningInstance: Found """ & $commandLine & """ by PID=" & $pid)
Local $aRegExResult = StringRegExp($commandLine, ".*""-clone:([^""]+)"".*|.*-clone:([\S]+).*", $STR_REGEXPARRAYMATCH)
If @error = 0 Then
$AndroidInstance = $aRegExResult[0]
If $AndroidInstance = "" Then $AndroidInstance = $aRegExResult[1]
SetDebugLog("Running " & $Android & " instance is """ & $AndroidInstance & """")
EndIf
If WinGetAndroidHandle() <> 0 Then
$a[0] = $HWnD
$a[1] = $AndroidInstance
Return $a
Else
$AndroidInstance = $currentInstance
EndIf
Next
Return $a
EndFunc
Func RedrawNoxWindow()
Local $aPos = WinGetPos($HWnD)
Local $aMousePos = MouseGetPos()
MouseClickDrag("left", $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 3, $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 53, 0)
MouseClickDrag("left", $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 53, $aPos[0] + Int($aPos[2] / 2), $aPos[1] + 3, 0)
MouseMove($aMousePos[0], $aMousePos[1], 0)
$aPos = WinGetPos($HWnD)
ControlClick($HWnD, "", "", "left", 1, $aPos[2] - 46, 18)
If _Sleep(500) Then Return False
$aPos = WinGetPos($HWnD)
ControlClick($HWnD, "", "", "left", 1, $aPos[2] - 46, 18)
EndFunc
Func OpenKOPLAYER($bRestart = False)
Local $PID, $hTimer, $iCount = 0, $process_killed, $cmdOutput, $connected_to, $cmdPar
SetLog("Starting " & $Android & " and Clash Of Clans", $COLOR_GREEN)
If Not InitAndroid() Then Return
$launchAndroid = WinGetAndroidHandle() = 0
If $launchAndroid Then
$cmdPar = GetAndroidProgramParameter() & " -t " & $AndroidInstance
SetDebugLog("ShellExecute: " & $AndroidProgramPath & " " & $cmdPar)
$PID = ShellExecute($AndroidProgramPath, $cmdPar, $__KOPLAYER_Path)
If _Sleep(1000) Then Return
If $PID <> 0 Then $PID = ProcessExists($PID)
SetDebugLog("$PID= "&$PID)
If $PID = 0 Then
SetLog("Unable to load " & $Android & ($AndroidInstance = "" ? "" : "(" & $AndroidInstance & ")") & ", please check emulator/installation.", $COLOR_RED)
SetLog("Unable to continue........", $COLOR_MAROON)
btnStop()
SetError(1, 1, -1)
Return
EndIf
EndIf
SetLog("Please wait while " & $Android & " and CoC start...", $COLOR_GREEN)
$hTimer = TimerInit()
$connected_to = ConnectAndroidAdb(False, 60 * 1000)
If Not $RunState Then Return
If WaitForAndroidBootCompleted($AndroidLaunchWaitSec - TimerDiff($hTimer) / 1000, $hTimer) Then Return
If TimerDiff($hTimer) >= $AndroidLaunchWaitSec * 1000 Then
SetLog("Serious error has occurred, please restart PC and try again", $COLOR_RED)
SetLog($Android & " refuses to load, waited " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds for window", $COLOR_RED)
SetError(1, @extended, False)
Return
EndIf
SetLog($Android & " Loaded, took " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds to begin.", $COLOR_GREEN)
EndFunc
Func GetKOPLAYERProgramParameter($bAlternative = False)
If Not $bAlternative Or $AndroidInstance <> $AndroidAppConfig[$AndroidConfig][1] Then
Return "-n " & ($AndroidInstance = "" ? $AndroidAppConfig[$AndroidConfig][1] : $AndroidInstance)
EndIf
Return "-n default"
EndFunc
Func IsKOPLAYERCommandLine($CommandLine)
SetDebugLog($CommandLine)
Local $param1 = GetKOPLAYERProgramParameter()
Local $param2 = GetKOPLAYERProgramParameter(True)
If StringInStr($CommandLine, $param1 & " ") > 0 Or StringRight($CommandLine, StringLen($param1)) = $param1 Then Return True
If StringInStr($CommandLine, $param2 & " ") > 0 Or StringRight($CommandLine, StringLen($param2)) = $param2 Then Return True
Return False
EndFunc
Func GetKOPLAYERPath()
Local $KOPLAYER_Path = RegRead($HKLM & "\SOFTWARE\KOPLAYER\SETUP\", "InstallPath")
If $KOPLAYER_Path = "" Then
$KOPLAYER_Path = @ProgramFilesDir & "\KOPLAYER\"
Else
If StringRight($KOPLAYER_Path, 1) <> "\" Then $KOPLAYER_Path &= "\"
EndIf
Return $KOPLAYER_Path
EndFunc
Func GetKOPLAYERAdbPath()
Local $adbPath = GetKOPLAYERPath() & "Tools\adb.exe"
If FileExists($adbPath) Then Return $adbPath
Return ""
EndFunc
Func InitKOPLAYER($bCheckOnly = False)
Local $process_killed, $aRegExResult, $AndroidAdbDeviceHost, $AndroidAdbDevicePort, $oops = 0
Local $KOPLAYERVersion = RegRead($HKLM & "\SOFTWARE\KOPLAYER\SETUP\", "Version")
SetError(0, 0, 0)
Local $KOPLAYER_Path = GetKOPLAYERPath()
Local $KOPLAYER_Manage_Path = $KOPLAYER_Path & "vbox\VBoxManage.exe"
If FileExists($KOPLAYER_Path & "KOPLAYER.exe") = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_RED)
SetLog($KOPLAYER_Path & "KOPLAYER.exe", $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists(GetKOPLAYERAdbPath()) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find " & $Android & ":", $COLOR_RED)
SetLog($KOPLAYER_Path & "adb.exe", $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If FileExists($KOPLAYER_Manage_Path) = False Then
If Not $bCheckOnly Then
SetLog("Serious error has occurred: Cannot find KOPLAYER-VBoxManage:", $COLOR_RED)
SetLog($KOPLAYER_Manage_Path, $COLOR_RED)
SetError(1, @extended, False)
EndIf
Return False
EndIf
If Not $bCheckOnly Then
InitAndroidConfig(True)
$__VBoxVMinfo = LaunchConsole($KOPLAYER_Manage_Path, "showvminfo " & $AndroidInstance, $process_killed)
If StringInStr($__VBoxVMinfo, "Could not find a registered machine named") > 0 Then
SetLog("Cannot find " & $Android & " instance " & $AndroidInstance, $COLOR_RED)
Return False
EndIf
$AndroidProgramPath = $KOPLAYER_Path & "KOPLAYER.exe"
$AndroidAdbPath = FindPreferredAdbPath()
If $AndroidAdbPath = "" Then $AndroidAdbPath = GetKOPLAYERAdbPath()
$AndroidVersion = $KOPLAYERVersion
$__KOPLAYER_Path = $KOPLAYER_Path
$__VBoxManage_Path = $KOPLAYER_Manage_Path
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host ip = ([^,]*),.*guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidAdbDeviceHost = $aRegExResult[0]
If $AndroidAdbDeviceHost = "" Then $AndroidAdbDeviceHost = "127.0.0.1"
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: Read $AndroidAdbDeviceHost = " & $AndroidAdbDeviceHost, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $Android & "(" & $AndroidInstance & ") ADB Device Host", $COLOR_RED)
EndIF
$aRegExResult = StringRegExp($__VBoxVMinfo, "name = .*host port = (\d{3,5}),.*guest port = 5555", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidAdbDevicePort = $aRegExResult[0]
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: Read $AndroidAdbDevicePort = " & $AndroidAdbDevicePort, $COLOR_DEBUG)
Else
$oops = 1
SetLog("Cannot read " & $Android & "(" & $AndroidInstance & ") ADB Device Port", $COLOR_RED)
EndIF
If $oops = 0 Then
$AndroidAdbDevice = $AndroidAdbDeviceHost & ":" & $AndroidAdbDevicePort
Else
SetLog("Using ADB default device " & $AndroidAdbDevice & " for " & $Android, $COLOR_RED)
EndIf
$AndroidPicturesPath = "/mnt/shared/UserData/"
$aRegExResult = StringRegExp($__VBoxVMinfo, "Name: 'UserData', Host path: '(.*)'.*", $STR_REGEXPARRAYMATCH)
If Not @error Then
$AndroidPicturesHostPath = StringReplace($aRegExResult[0], "/", "\") & "\"
Else
$AndroidAdbScreencap = False
$AndroidPicturesHostPath = ""
SetLog($Android & " Background Mode is not available", $COLOR_RED)
EndIf
$__VBoxGuestProperties = LaunchConsole($__VBoxManage_Path, "guestproperty enumerate " & $AndroidInstance, $process_killed)
EndIf
Return True
EndFunc
Func SetScreenKOPLAYER()
If Not InitAndroid() Then Return False
Local $cmdOutput, $process_killed
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $AndroidInstance & " vbox_graph_mode " & $AndroidClientWidth & "x" & $AndroidClientHeight & "-16", $process_killed)
$cmdOutput = LaunchConsole($__VBoxManage_Path, "guestproperty set " & $AndroidInstance & " vbox_dpi 160", $process_killed)
Return True
EndFunc
Func RebootKOPLAYERSetScreen()
Return RebootAndroidSetScreenDefault()
EndFunc
Func CloseKOPLAYER()
Return CloseVboxAndroidSvc()
EndFunc
Func CheckScreenKOPLAYER($bSetLog = True)
If Not InitAndroid() Then Return False
Local $aValues[2][2] = [  ["vbox_dpi", "160"],  ["vbox_graph_mode", $AndroidClientWidth & "x" & $AndroidClientHeight & "-16"]  ]
Local $i, $Value, $iErrCnt = 0, $process_killed, $aRegExResult
For $i = 0 To UBound($aValues) -1
$aRegExResult = StringRegExp($__VBoxGuestProperties, "Name: " & $aValues[$i][0] & ", value: (.+), timestamp:", $STR_REGEXPARRAYMATCH)
If @error = 0 Then $Value = $aRegExResult[0]
If $Value <> $aValues[$i][1] Then
If $iErrCnt = 0 Then
If $bSetLog Then
SetLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_RED)
Else
SetDebugLog("MyBot doesn't work with " & $Android & " screen configuration!", $COLOR_RED)
EndIf
EndIf
If $bSetLog Then
SetLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_RED)
Else
SetDebugLog("Setting of " & $aValues[$i][0] & " is " & $Value & " and will be changed to " & $aValues[$i][1], $COLOR_RED)
EndIf
$iErrCnt += 1
EndIf
Next
If $iErrCnt > 0 Then Return False
Return True
EndFunc
Func EmbedKOPLAYER($bEmbed = Default)
If $bEmbed = Default Then $bEmbed = $AndroidEmbedded
Local $aWin = _WinAPI_EnumProcessWindows(GetAndroidPid(), False)
Local $i
Local $hTool = 0
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
If $c = "Qt5QWindowToolSaveBits" Then
$hTool = $h
ExitLoop
EndIf
Next
If $hTool = 0 Then
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): Qt5QWindowToolSaveBits Window not found, list of windows:" & $c, Default, True)
For $i = 1 To UBound($aWin) - 1
Local $h = $aWin[$i][0]
Local $c = $aWin[$i][1]
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): Handle = " & $h & ", Class = " & $c, Default, True)
Next
Else
SetDebugLog("EmbedKOPLAYER(" & $bEmbed & "): $hTool=" & $hTool, Default, True)
WinMove2($hTool, "", -1, -1, -1, -1, $HWND_NOTOPMOST, 0, False)
_WinAPI_ShowWindow($hTool, ($bEmbed ? @SW_HIDE : @SW_SHOWNOACTIVATE))
EndIf
EndFunc
Func getBSPos()
Local $SuspendMode = ResumeAndroid()
Local $Changed = False, $aOldValues[4]
Local $hWin = $HWnD
WinGetAndroidHandle()
If $AndroidBackgroundLaunched = False Then
getAndroidPos(True)
Else
SetError($HWnd = 0 ? 1 : 0)
EndIf
If @error = 1 Then
If Not $RunState Then Return
SetError (0,0,0)
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
If $AndroidBackgroundLaunched = False Then
getAndroidPos(True)
Else
SetError($HWnd = 0 ? 1 : 0)
EndIf
If Not $RunState Then Return
If @error = 1 Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = @CRLF & GetTranslated(640,17,"MyBot has experienced a serious error") & @CRLF & @CRLF &  GetTranslated(640,18,"Unable to find or start up ") & $Android & @CRLF & @CRLF & GetTranslated(640,22,"Reboot PC and try again,") &  GetTranslated(640,19,"and search www.mybot.run forums for more help") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,20,"Close MyBot!"), GetTranslated(640,21,"Okay - Must Exit Program"), $stext, 15, $frmBot)
If $MsgBox = 1 Then
BotClose()
EndIf
EndIf
EndIf
If @error = 1 Then
If Not $RunState Then Return
SetError (0,0,0)
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
Return
EndIf
If $AndroidBackgroundLaunched = True Then
SuspendAndroid($SuspendMode, False)
Return
EndIf
$aOldValues[0] = $BSpos[0]
$aOldValues[1] = $BSpos[1]
$aOldValues[2] = $BSrpos[0]
$aOldValues[3] = $BSrpos[1]
Local $aPos = getAndroidPos()
If Not IsArray($aPos) Then
If Not $RunState Then Return
If $hWin = 0 Then
OpenAndroid(True)
Else
RebootAndroid()
EndIf
$aPos = getAndroidPos(True)
If Not $RunState Then Return
If @error = 1 Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = @CRLF & GetTranslated(640,17,"MyBot has experienced a serious error") & @CRLF & @CRLF &  GetTranslated(640,18,"Unable to find or start up") & " " & $Android & @CRLF & @CRLF & GetTranslated(640,22,"Reboot PC and try again,") &  GetTranslated(640,19,"and search www.mybot.run forums for more help") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,20,"Close MyBot!"), GetTranslated(640,21,"Okay - Must Exit Program"), $stext, 15, $frmBot)
If $MsgBox = 1 Then
BotClose()
Return
EndIf
EndIf
EndIf
If IsArray($aPos) Then
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", $aPos[0])
If @error <> 0 Then Return SetError (0,0,0)
DllStructSetData($tPoint, "Y", $aPos[1])
If @error <> 0 Then Return SetError (0,0,0)
_WinAPI_ClientToScreen(GetCurrentAndroidHWnD(), $tPoint)
If @error <> 0 Then Return SetError (0,0,0)
$BSpos[0] = DllStructGetData($tPoint, "X")
If @error <> 0 Then Return SetError (0,0,0)
$BSpos[1] = DllStructGetData($tPoint, "Y") + $ClientOffsetY
If @error <> 0 Then Return SetError (0,0,0)
$BSrpos[0] = $aPos[0]
$BSrpos[1] = $aPos[1] + $ClientOffsetY
$Changed = Not ($aOldValues[0] = $BSpos[0] And $aOldValues[1] = $BSpos[1] And $aOldValues[2] = $BSrpos[0] And $aOldValues[3] = $BSrpos[1])
If $debugClick = 1 Or $debugSetlog = 1 And $Changed Then Setlog("$BSpos X,Y = " & $BSpos[0] & "," & $BSpos[1] & "; BSrpos X,Y = " & $BSrpos[0] & "," & $BSrpos[1], $COLOR_DEBUG, "Verdana", "7.5", 0)
EndIf
SuspendAndroid($SuspendMode, False)
EndFunc
Func getAndroidPos($FastCheck = False, $RetryCount = 0)
Local $BSsize = ControlGetPos(GetCurrentAndroidHWnD(), $AppPaneName, $AppClassInstance)
If $FastCheck Then Return $BSsize
If IsArray($BSsize) Then
Local $BSx = $BSsize[2]
Local $BSy = $BSsize[3]
If $BSx <> $AndroidClientWidth Or $BSy <> $AndroidClientHeight Then
UpdateAndroidWindowState()
EndIf
If $BSx <> $AndroidClientWidth Or $BSy <> $AndroidClientHeight Then
SetDebugLog("Unsupported " & $Android & " screen size of " & $BSx & " x " & $BSy & " !", $COLOR_ACTION)
Local $AndroidWinPos = WinGetPos($HWnD)
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
Local $aWindowClientDiff[2] = [0,0]
Local $aAndroidWindow[2] = [$AndroidWindowWidth, $AndroidWindowHeight]
Local $tRECT = _WinAPI_GetClientRect($HWnD)
If @error = 0 Then
$aWindowClientDiff[0] = $WinWidth - (DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left"))
$aWindowClientDiff[1] = $WinHeight - (DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top"))
If $debugSetlog = 1 Then SetLog($title & " Window-Client-Diff: " & $aWindowClientDiff[0] & "," & $aWindowClientDiff[1], $COLOR_DEBUG)
$aAndroidWindow[0] = $AndroidWindowWidth + $aWindowClientDiff[0]
$aAndroidWindow[1] = $AndroidWindowHeight + $aWindowClientDiff[1]
If $debugSetlog = 1 Then SetLog($title & " Adjusted Window Size: " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_DEBUG)
Else
SetDebugLog("WARNING: Cannot determine " & $Android & " Window Client Area!", $COLOR_ERROR)
EndIf
WinMove($HWnD, "", $AndroidWinPos[0], $AndroidWinPos[1], $aAndroidWindow[0] - 4, $aAndroidWindow[1] - 4)
$AndroidWinPos = WinGetPos($HWnD)
Local $WinWidth = $AndroidWinPos[2]
Local $WinHeight = $AndroidWinPos[3]
If $AndroidWindowWidth > 0 And $AndroidWindowHeight > 0 And ($WinWidth <> $aAndroidWindow[0] Or $WinHeight <> $aAndroidWindow[1]) Then
WinMove2($HWnD, "", $AndroidWinPos[0], $AndroidWinPos[1], $aAndroidWindow[0], $aAndroidWindow[1])
If @error = 0 Then
SetDebugLog($Android & " window resized to " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_SUCCESS)
RedrawAndroidWindow()
Local $hTimer = TimerInit()
Do
Sleep($iDelaySleep)
Local $new_BSsize = getAndroidPos(True)
Until TimerDiff($hTimer) > 5000 Or ($BSsize[2] <> $new_BSsize[2] And $BSsize[3] <> $new_BSsize[3])
$BSsize[2] = $new_BSsize[2]
$BSsize[3] = $new_BSsize[3]
$BSx = $BSsize[2]
$BSy = $BSsize[3]
If $BSx <> $AndroidClientWidth Or $BSy <> $AndroidClientHeight Then
SetLog($Android & " window resize didn't work, screen is " & $BSx & " x " & $BSy, $COLOR_ERROR)
Else
SetLog($Android & " window resized to work with MyBot", $COLOR_SUCCESS)
EndIf
Else
SetDebugLog("WARNING: Cannot resize " & $Android & " window to " & $aAndroidWindow[0] & " x " & $aAndroidWindow[1], $COLOR_ERROR)
EndIf
Else
If $RetryCount < 5 Then
Sleep(250)
Return getAndroidPos($FastCheck, $RetryCount + 1)
EndIf
EndIf
EndIf
EndIf
Return $BSsize
EndFunc
Func UniversalCloseWaitOpenCoC($iWaitTime = 0, $sSource = "RudeUnknownProgrammer_", $StopEmulator = False, $bFullRestart = False)
If $debugsetlog = 1 Then Setlog("Begin UniversalCloseWaitOpenCoC:", $COLOR_DEBUG1)
Local $sWaitTime = ""
Local $iMin, $iSec, $iHour, $iWaitSec, $StopAndroidFlag
If $iWaitTime > 0 Then
$iWaitSec = Round($iWaitTime / 1000)
$iHour = Floor(Floor($iWaitSec / 60) / 60)
$iMin = Floor(Mod(Floor($iWaitSec / 60), 60))
$iSec = Floor(Mod($iWaitSec, 60))
If $iHour > 0 Then $sWaitTime &= $iHour & " hours "
If $iMin > 0 Then $sWaitTime &= $iMin & " minutes "
If $iSec > 0 Then $sWaitTime &= $iSec & " seconds "
EndIf
Local $msg = ""
Select
Case StringInStr($StopEmulator, "rand", $STR_NOCASESENSEBASIC)
$StopAndroidFlag = Random(0, 2, 1)
Switch $StopAndroidFlag
Case 0
$msg = " =Time out"
Case 1
$msg = " =Close CoC"
Case 2
$msg = " =Close Android"
Case Else
$msg = "One Bad Monkey Error!"
EndSwitch
Setlog("Random close option= " & $StopAndroidFlag & $msg, $COLOR_SUCCESS)
Case StringInStr($StopEmulator, "idle", $STR_NOCASESENSEBASIC)
$StopAndroidFlag = 0
Case $StopEmulator = False
$StopAndroidFlag = 1
Case $StopEmulator = True
$StopAndroidFlag = 2
Case Else
$StopAndroidFlag = 1
SetLog("Code Monkey provided bad stop emulator flag value", $COLOR_ERROR)
EndSelect
If $debugsetlog = 1 Then Setlog("Stop Android flag : Input flag " & $StopAndroidFlag & " : " & $StopEmulator, $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return False
Switch $StopAndroidFlag
Case 0
If $iWaitTime > 0 Then
SetLog("Going idle for " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
If _SleepStatus($iWaitTime) Then Return False
Else
If _SleepStatus($iDelayWaitnOpenCoC10000) Then Return False
EndIf
If _Sleep($iDelayRespond) Then Return False
OpenCoC()
Case 1
PoliteCloseCoC($sSource)
If _Sleep(3000) Then Return False
If $iWaitTime > 0 Then
If $iWaitTime > 30000 Then
AndroidShieldForceDown(True)
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
EndIf
WaitnOpenCoC($iWaitTime, $bFullRestart)
AndroidShieldForceDown(False)
If $RunState = False Then Return False
Else
WaitnOpenCoC($iDelayWaitnOpenCoC10000, $bFullRestart)
EndIf
If _Sleep($iDelayRespond) Then Return False
If $iWaitTime > 30000 Then
SaveConfig()
readConfig()
applyConfig()
DisableGuiControls()
EndIf
Case 2
PoliteCloseCoC($sSource)
If _Sleep(3000) Then Return False
CloseAndroid()
If $iWaitTime > 0 Then
SetLog("Waiting " & $sWaitTime & "before starting CoC", $COLOR_SUCCESS)
If $iWaitTime > 30000 Then
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
EndIf
If _SleepStatus($iWaitTime) Then Return False
If $iWaitTime > 30000 Then
SaveConfig()
readConfig()
applyConfig()
DisableGuiControls()
EndIf
Else
If _SleepStatus($iDelayWaitnOpenCoC10000) Then Return False
EndIf
StartAndroidCoC()
Case Else
SetLog("Code Monkey is drinking banana liqueur again!", $COLOR_ERROR)
EndSwitch
EndFunc
Global $g_hProcShieldInput[5] = [0, 0, False, False, 0]
Global $aAndroidEmbeddedGraphics[0][2]
Func GetCurrentAndroidHWnD()
Local $h = (($AndroidEmbedded = False Or $AndroidEmbedMode = 1) ? $HWnD : $frmBot)
Return $h
EndFunc
Func GetAndroidDisplayHWnD()
Local $h = (($AndroidEmbedded = False) ? $HWnD : $frmBot)
Return $h
EndFunc
Func AndroidEmbed($Embed = True, $CallWinGetAndroidHandle = True, $bForceEmbed = False)
If $AndroidEmbed = False Then Return False
Local $hMutex = AcquireMutex("AndroidEmbed", Default, 1000)
If $hMutex <> 0 Then
Return ReleaseMutex($hMutex, _AndroidEmbed($Embed, $CallWinGetAndroidHandle, $bForceEmbed))
EndIf
Return False
EndFunc
Func _AndroidEmbed($Embed = True, $CallWinGetAndroidHandle = True, $bForceEmbed = False)
If ($CallWinGetAndroidHandle = False And $HWnD = 0) Or ($CallWinGetAndroidHandle = True And WinGetAndroidHandle() = 0) Then
SetDebugLog("Android Emulator not launched", $COLOR_ERROR)
If $AndroidEmbedded = False Then
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Docked Android Window not available, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
If $AndroidBackgroundLaunched = True Then
If $AndroidEmbedded = False Then
SetDebugLog("Android Emulator launched in background mode", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Emulator launched in background mode, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $aPos = WinGetPos($HWnD)
If IsArray($aPos) = 0 Or @error <> 0 Then
If $AndroidEmbedded = False Then
SetDebugLog("Android Window not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
Else
If $Embed = True Then
SetDebugLog("Android Window not accessible, force undock", $COLOR_ERROR)
$Embed = False
EndIf
EndIf
EndIf
Local $hCtrl = ControlGetHandle(GetCurrentAndroidHWnD(), $AppPaneName, $AppClassInstance)
Local $aPosFrmBotEx, $aPosLog
Local $hCtrlTarget = $AndroidEmbeddedCtrlTarget[0]
Local $hCtrlTargetParent = $AndroidEmbeddedCtrlTarget[1]
Local $HWnDParent = $AndroidEmbeddedCtrlTarget[2]
Local $HWnD2 = $AndroidEmbeddedCtrlTarget[3]
Local $lCurStyle = $AndroidEmbeddedCtrlTarget[4]
Local $lCurExStyle = $AndroidEmbeddedCtrlTarget[5]
Local $aPosCtl = $AndroidEmbeddedCtrlTarget[6]
Local $lCurStyleTarget = $AndroidEmbeddedCtrlTarget[8]
Local $hThumbnail = $AndroidEmbeddedCtrlTarget[9]
Local $targetIsHWnD = $hCtrlTarget = $HWnD
Local $activeHWnD = WinGetHandle("")
Local $HWnD_available = WinGetHandle($HWnD) = $HWnD
If $Embed = False Then
If $AndroidEmbedded = True Then
SetDebugLog("Undocking Android Control...")
If _WinAPI_IsIconic($frmBot) Then BotMinimize("_AndroidEmbed (1)", True)
If $AndroidShieldEnabled = True Then
AndroidShield("AndroidEmbed undock", False, $CallWinGetAndroidHandle, 100)
GUIDelete($frmBotEmbeddedShield)
$frmBotEmbeddedShield = 0
If $frmBotEmbeddedMouse Then
GUIDelete($frmBotEmbeddedMouse)
$frmBotEmbeddedMouse = 0
EndIf
$AndroidShieldStatus[0] = Default
EndIf
SetRedrawBotWindow(False)
If $hThumbnail <> 0 Then
_WinAPI_DwmUnregisterThumbnail($hThumbnail)
$AndroidEmbeddedCtrlTarget[9] = 0
EndIf
$aPos = $AndroidEmbeddedCtrlTarget[7]
$g_hProcShieldInput[3] = True
If $HWnD_available Then
Switch $AndroidEmbedMode
Case 0
If $targetIsHWnD = False Then
_WinAPI_SetParent($hCtrlTarget, $hCtrlTargetParent)
EndIf
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_SetParent($HWnD, $HWnDParent)
_WinAPI_SetWindowLong($HWnD, $GWL_HWNDPARENT, $HWnDParent)
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $lCurStyle)
WinMove($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3] - 1)
WinMove2($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
Case 1
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $lCurStyle)
WinMove($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3] - 1)
WinMove($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3])
EndSwitch
EndIf
WinMove(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3])
WinMove2(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
If $debugAndroidEmbedded Then SetDebugLog("Placed Android Control at " & $aPosCtl[0] & "," & $aPosCtl[1])
ControlHide($hGUI_LOG, "", $divider)
$aPosFrmBotEx = ControlGetPos($frmBot, "", $frmBotEx)
ControlMove($frmBot, "", $frmBotEx, 0, 0, $aPosFrmBotEx[2], $aPosFrmBotEx[3] - $frmBotAddH)
ControlMove($frmBot, "", $frmBotBottom, 0, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP)
WinSetTrans($frmBotBottom, "", 255)
$aPosLog = ControlGetPos($frmBotEx, "", $hGUI_LOG)
ControlMove($frmBotEx, "", $hGUI_LOG, Default, Default, $aPosLog[2], $aPosLog[3] - $frmBotAddH)
$AndroidEmbedded = False
WinMove2($frmBot, "", $frmBotPosX, $frmBotPosY, $frmBotPosInit[2], $frmBotPosInit[3], 0, 0, False)
updateBtnEmbed()
$iDividerY -= $frmBotAddH
$frmBotAddH = 0
cmbLog()
SetRedrawBotWindow(True)
If $HWnD_available Then
_SendMessage($HWnD, $WM_SETREDRAW, False, 0)
_WinAPI_ShowWindow($HWnD, @SW_HIDE)
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, BitOR($lCurExStyle, $WS_EX_APPWINDOW))
_WinAPI_ShowWindow($HWnD, @SW_SHOWNOACTIVATE)
_SendMessage($HWnD, $WM_SETREDRAW, True, 0)
_WinAPI_UpdateWindow($HWnD)
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, $lCurExStyle)
_WinAPI_EnableWindow($HWnD, True)
_WinAPI_EnableWindow($hCtrlTarget, True)
WinMove2(($targetIsHWnD ? $hCtrl : $hCtrlTarget), "", $aPosCtl[0], $aPosCtl[1], $aPosCtl[2], $aPosCtl[3], 0, 0, False)
getAndroidPos()
getBSPos()
Execute("Embed" & $Android & "(False)")
If $AndroidEmbedMode = 1 Then
WinMove2($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3], $HWND_TOPMOST)
WinMove2($HWnD, "", $aPos[0], $aPos[1], $aPos[2], $aPos[3], $HWND_NOTOPMOST, 0, False)
EndIf
EndIf
SetDebugLog("Undocked Android Window")
$g_hProcShieldInput[3] = False
Return True
EndIf
updateBtnEmbed()
Return False
EndIf
If $AndroidEmbedded = True And $bForceEmbed = False Then
If $HWnD = $HWnD2 Then
If $targetIsHWnD = False Then
WinMove2($HWnD, "", $aPosCtl[2] + 2, $frmBotPosInit[5], -1, -1, $HWND_BOTTOM)
EndIf
Return False
EndIf
SetDebugLog("Docked Android Window gone", $COLOR_ERROR)
AndroidEmbed(False)
Return AndroidEmbed(True)
EndIf
Local $bAlreadyEmbedded = $AndroidEmbedded = True
SetDebugLog("Docking Android Control...")
If _WinAPI_DwmEnableComposition(True) = 1 Then
SetDebugLog("Desktop Window Manager available", $COLOR_SUCCESS)
Else
SetDebugLog("Desktop Window Manager not available!", $COLOR_ERROR)
SetDebugLog("Android Shield will be invisible!", $COLOR_ERROR)
EndIf
If _WinAPI_IsIconic($frmBot) Then BotMinimize("_AndroidEmbed (2)", True)
If _WinAPI_IsIconic($HWnD) Then WinSetState($HWnD, "", @SW_RESTORE)
getAndroidPos()
$aPos = WinGetPos($HWnD)
If IsArray($aPos) = 0 Then
updateBtnEmbed()
Return False
EndIf
If $debugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPos[] = " & $aPos[0] & ", " & $aPos[1] & ", " & $aPos[2] & ", " & $aPos[3], Default, True)
$lCurStyle = _WinAPI_GetWindowLong($HWnD, $GWL_STYLE)
$lCurExStyle = _WinAPI_GetWindowLong($HWnD, $GWL_EXSTYLE)
$HWnDParent = _WinAPI_GetParent($HWnD)
$hCtrlTarget = _WinAPI_GetParent($hCtrl)
If $hCtrlTarget = 0 Then
updateBtnEmbed()
Return False
EndIf
$lCurStyleTarget = _WinAPI_GetWindowLong($hCtrlTarget, $GWL_STYLE)
$hCtrlTargetParent = _WinAPI_GetParent($hCtrlTarget)
If $debugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $hCtrl=" & $hCtrl & ", $hCtrlTarget=" & $hCtrlTarget & ", $hCtrlTargetParent=" & $hCtrlTargetParent & ", $HWnD=" & $HWnD, Default, True)
$targetIsHWnD = $hCtrlTarget = $HWnD
If $bAlreadyEmbedded = True Then
$g_hProcShieldInput[3] = True
Else
$aPosCtl = ControlGetPos($HWnD, "", ($targetIsHWnD ? $hCtrl : $hCtrlTarget))
If IsArray($aPosCtl) = 0 Or @error <> 0 Then
updateBtnEmbed()
Return False
EndIf
If $debugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosCtl[] = " & $aPosCtl[0] & ", " & $aPosCtl[1] & ", " & $aPosCtl[2] & ", " & $aPosCtl[3], Default, True)
If $targetIsHWnD Then
Local $aPosParentCtl = $aPosCtl
$hCtrlTargetParent = $hCtrlTarget
ElseIf $hCtrlTargetParent = $HWnD Then
Local $aPosParentCtl = $aPosCtl
Else
Local $aPosParentCtl = ControlGetPos($HWnD, "", $hCtrlTargetParent)
If $hCtrlTargetParent = 0 Or IsArray($aPosParentCtl) = 0 Or @error <> 0 Then
SetDebugLog("Android Parent Control not available", $COLOR_ERROR)
updateBtnEmbed()
Return False
EndIf
EndIf
If $debugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosParentCtl[] = " & $aPosParentCtl[0] & ", " & $aPosParentCtl[1] & ", " & $aPosParentCtl[2] & ", " & $aPosParentCtl[3], Default, True)
Local $botClientWidth = $frmBotPosInit[4]
Local $botClientHeight = $frmBotPosInit[5]
$frmBotAddH = $aPosCtl[3] - $botClientHeight
If $debugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $frmBotAddH = " & $frmBotAddH, Default, True)
If $frmBotAddH < 0 Then $frmBotAddH = 0
Local $frmBotWidth = $frmBotPosInit[2] + $aPosCtl[2] + 2
Local $frmBotHeight = $frmBotPosInit[3] + $frmBotAddH
$g_hProcShieldInput[3] = True
$AndroidEmbedded = True
If $frmBotDockedPosX = -1 And $frmBotDockedPosY = -1 Then
If $frmBotPosX < $AndroidPosX Then
$frmBotDockedPosX = $frmBotPosX
$frmBotDockedPosY = $frmBotPosY
Else
$frmBotDockedPosX = $AndroidPosX
$frmBotDockedPosY = $AndroidPosY
EndIf
EndIf
WinMove2($frmBot, "", $frmBotDockedPosX, $frmBotDockedPosY, -1, -1, 0, 0, False)
_SendMessage($frmBot, $WM_SETREDRAW, False, 0)
If $AndroidEmbedMode = 0 Then
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM)
EndIf
$aPosFrmBotEx = ControlGetPos($frmBot, "", $frmBotEx)
$aPosFrmBotEx[3] = $frmBotPosInit[6]
If $debugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosFrmBotEx[] = " & $aPosFrmBotEx[0] & ", " & $aPosFrmBotEx[1] & ", " & $aPosFrmBotEx[2] & ", " & $aPosFrmBotEx[3], Default, True)
WinMove($frmBotEx, "", $aPosCtl[2] + 2, 0, $aPosFrmBotEx[2], $aPosFrmBotEx[3] + $frmBotAddH)
WinMove($frmBotBottom, "", $aPosCtl[2] + 2, $_GUI_MAIN_HEIGHT - $_GUI_BOTTOM_HEIGHT + $_GUI_MAIN_TOP + $frmBotAddH)
WinSetTrans($frmBotBottom, "", 254)
$aPosLog = ControlGetPos($frmBotEx, "", $hGUI_LOG)
If $debugAndroidEmbedded Then SetDebugLog("AndroidEmbed: $aPosLog[] = " & $aPosLog[0] & ", " & $aPosLog[1] & ", " & $aPosLog[2] & ", " & $aPosLog[3], Default, True)
WinMove($hGUI_LOG, "", $_GUI_CHILD_LEFT, $_GUI_CHILD_TOP, $aPosLog[2], $aPosLog[3] + $frmBotAddH)
WinMove2($frmBot, "", $frmBotDockedPosX, $frmBotDockedPosY, $frmBotWidth, $frmBotHeight, 0, 0, False)
$AndroidEmbeddedCtrlTarget[0] = $hCtrlTarget
$AndroidEmbeddedCtrlTarget[1] = $hCtrlTargetParent
$AndroidEmbeddedCtrlTarget[2] = $HWnDParent
$AndroidEmbeddedCtrlTarget[3] = $HWnD
$AndroidEmbeddedCtrlTarget[4] = $lCurStyle
$AndroidEmbeddedCtrlTarget[5] = $lCurExStyle
$aPosCtl[0] = $aPosParentCtl[0] - $aPosCtl[0]
$aPosCtl[1] = $aPosParentCtl[1] - $aPosCtl[1]
$AndroidEmbeddedCtrlTarget[6] = $aPosCtl
$AndroidEmbeddedCtrlTarget[7] = $aPos
$AndroidEmbeddedCtrlTarget[8] = $lCurStyleTarget
EndIf
Local $newStyle = AndroidEmbed_GWL_STYLE()
SetDebugLog("AndroidEmbed_GWL_STYLE=" & Get_GWL_STYLE_Text($newStyle))
Local $a = AndroidEmbed_HWnD_Position()
Switch $AndroidEmbedMode
Case 0
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, $WS_EX_MDICHILD)
_WinAPI_SetWindowLong($HWnD, $GWL_HWNDPARENT, $frmBot)
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $newStyle)
_WinAPI_SetParent($HWnD, $frmBot)
If $targetIsHWnD = False Then
_WinAPI_SetParent($hCtrlTarget, $frmBot)
EndIf
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $newStyle)
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3] - 1, $HWND_BOTTOM, 0, False)
WinMove2($hCtrlTarget, "", 0, 0, $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM, 0, False)
If $targetIsHWnD = False Then
WinMove2($HWnD, "", $a[0], $a[1], -1, -1, $HWND_BOTTOM, 0, False)
EndIf
Case 1
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $newStyle)
WinMove2($HWnD, "", -1, -1, -1, -1, 0, $SWP_HIDEWINDOW, False)
_WinAPI_ShowWindow($HWnD, @SW_HIDE)
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($HWnD, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
_WinAPI_ShowWindow($HWnD, @SW_SHOWNOACTIVATE)
_SendMessage($HWnD, $WM_SETREDRAW, True, 0)
_WinAPI_UpdateWindow($HWnD)
_WinAPI_SetWindowLong($HWnD, $GWL_EXSTYLE, BitOR(_WinAPI_GetWindowLong($HWnD, $GWL_EXSTYLE), $WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE))
WinMove($HWnD, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3] - 1)
WinMove($HWnD, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3])
If _WinAPI_DwmIsCompositionEnabled() And $hThumbnail = 0 Then
$hThumbnail = _WinAPI_DwmRegisterThumbnail($frmBot, $HWnD)
Local $tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $iWidth = DllStructGetData($tSIZE, 1)
Local $iHeight = DllStructGetData($tSIZE, 2)
Local $tDestRect = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
Local $tSrcRect = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
_WinAPI_DwmUpdateThumbnailProperties($hThumbnail, 1, 0, 255, $tDestRect, $tSrcRect)
$AndroidEmbeddedCtrlTarget[9] = $hThumbnail
EndIf
WinMove2($HWnD, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3], $HWND_BOTTOM, $SWP_SHOWWINDOW, False)
EndSwitch
Execute("Embed" & $Android & "(True)")
updateBtnEmbed()
$iDividerY += $frmBotAddH
cmbLog()
_WinAPI_EnableWindow($hCtrlTarget, False)
_WinAPI_EnableWindow($HWnD, False)
Local $aCheck = WinGetPos($HWnD)
If IsArray($aCheck) Then
If $debugAndroidEmbedded Then SetDebugLog("AndroidEmbed: Android Window Pos: " & $aCheck[0] & ", " & $aCheck[1] & ", " & $aCheck[2] & ", " & $aCheck[3], Default, True)
Else
SetDebugLog("AndroidEmbed: Android Window not found", $COLOR_ERROR)
EndIf
Local $aCheck = ControlGetPos(GetCurrentAndroidHWnD(), $AppPaneName, $AppClassInstance)
If IsArray($aCheck) Then
If $debugAndroidEmbedded Then SetDebugLog("AndroidEmbed: Android Control Pos: " & $aCheck[0] & ", " & $aCheck[1] & ", " & $aCheck[2] & ", " & $aCheck[3], Default, True)
Else
SetDebugLog("AndroidEmbed: Android Control not found", $COLOR_ERROR)
EndIf
getBSPos()
_SendMessage($frmBot, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($frmBot, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN + $RDW_ERASE)
_WinAPI_RedrawWindow($frmBotBottom, 0, 0, $RDW_INVALIDATE + $RDW_ALLCHILDREN + $RDW_ERASE)
_WinAPI_UpdateWindow($frmBot)
_WinAPI_UpdateWindow($frmBotBottom)
SetDebugLog("Android Window docked")
$g_hProcShieldInput[3] = False
$g_hProcShieldInput[4] = 0
AndroidShield("AndroidEmbed dock", Default, $CallWinGetAndroidHandle, 100)
Return True
EndFunc
Func Get_GWL_STYLE_Text($iGWL_STYLE)
Local $s = ""
Local $a[20][2] = [[$WS_MAXIMIZEBOX, "$WS_MAXIMIZEBOX"]  , [$WS_MINIMIZEBOX, "$WS_MINIMIZEBOX"]  , [$WS_TABSTOP, "$WS_TABSTOP"]  , [$WS_GROUP, "$WS_GROUP"]  , [$WS_SIZEBOX, "$WS_SIZEBOX"]  , [$WS_SYSMENU, "$WS_SYSMENU"]  , [$WS_HSCROLL, "$WS_HSCROLL"]  , [$WS_VSCROLL, "$WS_VSCROLL"]  , [$WS_DLGFRAME, "$WS_DLGFRAME"]  , [$WS_BORDER, "$WS_BORDER"]  , [$WS_CAPTION, "$WS_CAPTION"]  , [$WS_MAXIMIZE, "$WS_MAXIMIZE"]  , [$WS_CLIPCHILDREN, "$WS_CLIPCHILDREN"]  , [$WS_CLIPSIBLINGS, "$WS_CLIPSIBLINGS"]  , [$WS_DISABLED, "$WS_DISABLED"]  , [$WS_VISIBLE, "$WS_VISIBLE"]  , [$WS_MINIMIZE, "$WS_MINIMIZE"]  , [$WS_CHILD, "$WS_CHILD"]  , [$WS_POPUP, "$WS_POPUP"]  , [$WS_POPUPWINDOW, "$WS_POPUPWINDOW"]  ]
Local $i
For $i = 0 To UBound($a) - 1
If BitAND($iGWL_STYLE, $a[$i][0]) > 0 Then
If $s <> "" Then $s &= ", "
$s &= $a[$i][1]
$iGWL_STYLE -= $a[$i][0]
EndIf
Next
If $iGWL_STYLE > 0 Then
If $s <> "" Then $s &= ","
$s &= Hex($iGWL_STYLE, 8)
EndIf
Return $s
EndFunc
Func AndroidEmbed_GWL_STYLE()
If $AndroidEmbedded = True Then
Local $lCurStyle = $AndroidEmbeddedCtrlTarget[4]
Local $newStyle = BitOR($WS_CHILD, BitAND($lCurStyle, BitNOT(BitOR($WS_POPUP, $WS_CAPTION, $WS_SYSMENU, $WS_MINIMIZEBOX, $WS_MAXIMIZEBOX, $WS_SIZEBOX, $WS_BORDER, $WS_THICKFRAME))))
If $AndroidEmbedMode = 1 Then
$newStyle = BitOR($WS_POPUP, BitAND($newStyle, BitNOT($WS_CHILD)))
EndIf
Return $newStyle
EndIf
Return ""
EndFunc
Func AndroidEmbed_HWnD_Position($bForShield = False, $bDetachedShield = Default, $hCtrlTarget = Default, $aPosCtl = Default)
Local $aPos[2]
If $bDetachedShield = Default Then
$bDetachedShield = $AndroidShieldStatus[4]
EndIf
If $AndroidEmbedMode = 1 Or ($bForShield = True And $bDetachedShield = True) Then
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", 0)
DllStructSetData($tPoint, "Y", 0)
_WinAPI_ClientToScreen($frmBot, $tPoint)
$aPos[0] = DllStructGetData($tPoint, "X")
$aPos[1] = DllStructGetData($tPoint, "Y")
ElseIf $AndroidEmbedMode = 0 And $bForShield = False Then
If $hCtrlTarget = Default Then
$hCtrlTarget = $AndroidEmbeddedCtrlTarget[0]
EndIf
If $aPosCtl = Default Then
$aPosCtl = $AndroidEmbeddedCtrlTarget[6]
EndIf
Local $targetIsHWnD = $hCtrlTarget = $HWnD
If $targetIsHWnD = False Then
$aPos[0] = $aPosCtl[2] + 2
$aPos[1] = $frmBotPosInit[5]
Else
$aPos[0] = 0
$aPos[1] = 0
EndIf
ElseIf $bForShield = True And $bDetachedShield = False Then
$aPos[0] = 0
$aPos[1] = 0
Else
SetDebugLog("AndroidEmbed_HWnD_Position: Wrong window state:" & @CRLF &  "$bForShield=" & $bForShield & @CRLF &  "$AndroidEmbedMode=" & $AndroidEmbedMode & @CRLF &  "$bDetachedShield=" & $bDetachedShield)
EndIf
Return $aPos
EndFunc
Func AndroidEmbedCheck($bTestIfRequired = Default, $bHasFocus = Default, $iAction = 6)
If $bHasFocus = Default Then $bHasFocus = WinActive($frmBot) <> 0
If $bTestIfRequired = Default Then
$iAction = AndroidEmbedCheck(True, $bHasFocus)
If $iAction > 0 Then
Return AndroidEmbedCheck(False, $bHasFocus, $iAction)
EndIf
EndIf
If $AndroidEmbedded = True And AndroidEmbedArrangeActive() = False Then
Local $hCtrlTarget = $AndroidEmbeddedCtrlTarget[0]
Local $aPosCtl = $AndroidEmbeddedCtrlTarget[6]
Local $targetIsHWnD = $hCtrlTarget = $HWnD
Local $aPos = AndroidEmbed_HWnD_Position()
Local $aPosShield = AndroidEmbed_HWnD_Position(True)
Local $newStyle = AndroidEmbed_GWL_STYLE()
Local $bDetachedShield = $AndroidShieldStatus[4]
If $bTestIfRequired = False Then
SetDebugLog("AndroidEmbedCheck: $iAction=" & $iAction, Default, True)
If BitAND($iAction, 2) > 0 Then
AndroidEmbedArrangeActive(True)
_WinAPI_SetWindowLong($HWnD, $GWL_STYLE, $newStyle)
AndroidEmbed(True, False, True)
EndIf
If BitAND($iAction, 1) Or BitAND($iAction, 4) > 0 Then
WinMove2($HWnD, "", $aPos[0], $aPos[1], -1, -1, $HWND_BOTTOM, 0, True)
EndIf
If $AndroidShieldEnabled = True And $bDetachedShield = True Then
If BitAND($iAction, 1) > 0 Or BitAND($iAction, 4) > 0 Then
If BitAND($iAction, 4) > 0 Then
WinMove2($frmBotEmbeddedShield, "", $aPosShield[0], $aPosShield[1], $aPosCtl[2], $aPosCtl[3], ($bHasFocus ? $HWND_TOPMOST : $HWND_NOTOPMOST), 0, False)
If $frmBotEmbeddedGarphics Then
WinMove2($frmBotEmbeddedGarphics, "", $aPosShield[0], $aPosShield[1], $aPosCtl[2], $aPosCtl[3], ($bHasFocus ? $HWND_TOPMOST : $HWND_NOTOPMOST), 0, False)
EndIf
EndIf
If $bHasFocus = False Then
WinMove2($frmBotEmbeddedShield, "", -1, -1, -1, -1, $frmBot, 0, False)
WinMove2($frmBot, "", -1, -1, -1, -1, $frmBotEmbeddedShield, 0, False)
EndIf
EndIf
EndIf
Return True
EndIf
Local $iZorder = 0
If $AndroidShieldEnabled = True And $bDetachedShield = True And $bHasFocus = False Then
If $AndroidShieldEnabled = True Then
Local $h = _WinAPI_GetWindow($frmBotEmbeddedShield, $GW_HWNDNEXT)
If $h <> $frmBot Then $iZorder = 1
EndIf
EndIf
Local $style = _WinAPI_GetWindowLong($HWnD, $GWL_STYLE)
If BitAND($style, $WS_DISABLED) > 0 Then $newStyle = BitOR($newStyle, $WS_DISABLED)
If BitAND($style, $WS_MAXIMIZEBOX) > 0 Then $newStyle = BitOR($newStyle, $WS_MAXIMIZEBOX)
Local $iStyle = (($style <> $newStyle) ? 2 : 0)
If $iStyle > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Window GWL_STYLE changed: " & Get_GWL_STYLE_Text($newStyle) & " to " & Get_GWL_STYLE_Text($style), Default, True)
EndIf
Local $a1[2] = [$aPos[0], $aPos[1]]
Local $a2 = $aPos
Switch $AndroidEmbedMode
Case 0
Local $a1 = ControlGetPos($frmBot, "", $HWnD)
Case 1
Local $a1 = WinGetPos($HWnD)
EndSwitch
Local $iPos = ((IsArray($a1) And ($a1[0] <> $a2[0] Or $a1[1] <> $a2[1])) ? 4 : 0)
If $iPos > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Window Position changed: X: " & $a1[0] & " <> " & $a2[0] & ", Y: " & $a1[1] & " <> " & $a2[1], Default, True)
EndIf
If $iPos = 0 And $bDetachedShield = True Then
$a1 = WinGetPos($frmBotEmbeddedShield)
$a2 = $aPosShield
$iPos = ((IsArray($a1) And ($a1[0] <> $a2[0] Or $a1[1] <> $a2[1])) ? 4 : 0)
If $iPos > 0 Then
SetDebugLog("AndroidEmbedCheck: Android Shield Position changed: X: " & $a1[0] & " <> " & $a2[0] & ", Y: " & $a1[1] & " <> " & $a2[1], Default, True)
EndIf
EndIf
Return BitOR($iZorder, $iStyle, $iPos)
EndIf
Return 0
EndFunc
Func AndroidEmbedded()
Return $AndroidEmbedded
EndFunc
Func AndroidEmbedArrangeActive($bActive = Default)
If $bActive = Default Then Return $g_hProcShieldInput[3]
Local $bWasActive = $g_hProcShieldInput[3]
$g_hProcShieldInput[3] = $bActive
Return $bWasActive
EndFunc
Func AndroidShieldStartup()
_OnAutoItErrorRegister()
EndFunc
Func AndroidShieldDestroy()
_OnAutoItErrorUnRegister()
EndFunc
Func AndroidShieldForceDown($bForceDown = True, $AndroidHasFocus = False)
Local $wasDown = $AndroidShieldForceDown
$AndroidShieldForceDown = $bForceDown
AndroidShield("AndroidShieldForceDown", Default, True, 0, $AndroidHasFocus)
Return $wasDown
EndFunc
Func AndroidShieldForcedDown()
Return $AndroidShieldForceDown
EndFunc
Func AndroidShieldHasFocus()
Return $g_hProcShieldInput[2] = True
EndFunc
Func AndroidShielded()
Return $AndroidShieldStatus[0] = True
EndFunc
Func AndroidShieldActiveDelay($bIsStillWaiting = False)
Return $AndroidShieldDelay[0] <> 0 And $AndroidShieldDelay[1] > 0 And ($bIsStillWaiting = False Or TimerDiff($AndroidShieldDelay[0]) < $AndroidShieldDelay[1])
EndFunc
Func AndroidShieldCheck()
If AndroidShieldActiveDelay(True) = True Then Return False
Return AndroidShield("AndroidShieldCheck")
EndFunc
Func AndroidShield($sCaller, $Enable = Default, $CallWinGetAndroidHandle = True, $iDelay = 0, $AndroidHasFocus = Default, $AndroidUpdateFocus = True)
If $AndroidShieldEnabled = False Or $g_hProcShieldInput[3] = True Then Return False
If $iDelay > 0 Then
Return _AndroidShield($sCaller, $Enable, $CallWinGetAndroidHandle, $iDelay, $AndroidHasFocus, $AndroidUpdateFocus)
EndIf
Local $hMutex = AcquireMutex("AndroidShield", Default, 1000)
If $hMutex <> 0 Then
Local $Result = _AndroidShield($sCaller, $Enable, $CallWinGetAndroidHandle, $iDelay, $AndroidHasFocus, $AndroidUpdateFocus)
ReleaseMutex($hMutex)
Return $Result
Else
SetDebugLog("AndroidShield, failed acquire mutex, caller: " & $sCaller, Default, True)
EndIf
Return False
EndFunc
Func _AndroidShield($sCaller, $Enable = Default, $CallWinGetAndroidHandle = True, $iDelay = 0, $AndroidHasFocus = Default, $AndroidUpdateFocus = True)
Local $bForceUpdate = False
If AndroidShieldActiveDelay() Then
If AndroidShieldActiveDelay(True) = False Then
If $Enable = Default Then $Enable = $AndroidShieldDelay[2]
If $AndroidHasFocus = Default Then $AndroidHasFocus = $AndroidShieldDelay[3]
Else
If $iDelay = 0 Then
If $Enable <> Default Then $AndroidShieldDelay[2] = $Enable
If $AndroidHasFocus <> Default Then $AndroidShieldDelay[3] = $AndroidHasFocus
Return False
EndIf
EndIf
EndIf
If $iDelay > 0 Then
$AndroidShieldDelay[0] = TimerInit()
$AndroidShieldDelay[1] = $iDelay
$AndroidShieldDelay[2] = $Enable
$AndroidShieldDelay[3] = $AndroidHasFocus
SetDebugLog("ShieldAndroid: Delayed update $iDelay=" & $iDelay & ", $Enable=" & $Enable & ", $AndroidHasFocus=" & $AndroidHasFocus & ", caller: " & $sCaller, Default, True)
Return False
EndIf
$AndroidShieldDelay[0] = 0
$AndroidShieldDelay[1] = 0
$AndroidShieldDelay[2] = Default
$AndroidShieldDelay[3] = Default
If $Enable = Default Then
$Enable = $RunState And $TPaused = False
If $AndroidShieldForceDown Then $Enable = False
EndIf
If $AndroidHasFocus = Default Then
$AndroidHasFocus = AndroidShieldHasFocus()
Else
If $AndroidUpdateFocus Then $g_hProcShieldInput[2] = $AndroidHasFocus
EndIf
Local $shieldState = "active"
Local $color = $AndroidShieldColor
Local $trans = $AndroidShieldTransparency
If $Enable = False Or $TPaused = True Then
If _WinAPI_GetActiveWindow() = $frmBot And $AndroidHasFocus Then
$shieldState = "disabled-focus"
$color = $AndroidActiveColor
$trans = $AndroidActiveTransparency
SetAccelerators(True)
Else
$shieldState = "disabled-nofocus"
$color = $AndroidInactiveColor
$trans = $AndroidInactiveTransparency
SetAccelerators(False)
EndIf
Else
SetAccelerators(False)
EndIf
Local $bNoVisibleShield = $ichkBackground = 0
Local $bDetachedShield = $bNoVisibleShield = False And ($AndroidShieldPreWin8 = True Or $AndroidEmbedMode = 1)
If $AndroidEmbedded = False Then
Return False
EndIf
If $AndroidBackgroundLaunched = True Then
Return False
EndIf
If $bForceUpdate = False And $AndroidShieldStatus[0] = $Enable And $AndroidShieldStatus[1] = $color And $AndroidShieldStatus[2] = $trans And $AndroidShieldStatus[3] = $bNoVisibleShield And $AndroidShieldStatus[4] = $bDetachedShield Then
Return False
EndIf
If ($CallWinGetAndroidHandle = False And $HWnD = 0) Or ($CallWinGetAndroidHandle = True And WinGetAndroidHandle() = 0) Then
Return False
EndIf
Local $aPos = WinGetPos($HWnD)
If IsArray($aPos) = 0 Or @error <> 0 Then
Return False
EndIf
Local $hCtrlTarget = $AndroidEmbeddedCtrlTarget[0]
Local $aPosCtl = $AndroidEmbeddedCtrlTarget[6]
Local $targetIsHWnD = $hCtrlTarget = $HWnD
If $frmBotEmbeddedShield <> 0 And ($AndroidShieldStatus[3] <> $bNoVisibleShield Or $AndroidShieldStatus[4] <> $bDetachedShield) Then
GUIDelete($frmBotEmbeddedShield)
$frmBotEmbeddedShield = 0
EndIf
$g_hProcShieldInput[3] = True
Local $show_shield = @SW_SHOWNOACTIVATE
If $Enable <> $AndroidShieldStatus[0] Or $frmBotEmbeddedShield = 0 Then
If $Enable = True Then
SetDebugLog("Shield Android Control (" & $aPosCtl[2] & "x" & $aPosCtl[3] & ")", Default, True)
Else
SetDebugLog("Unshield Android Control", Default, True)
EndIf
If $bDetachedShield = False Then
If $frmBotEmbeddedShield = 0 Then
$frmBotEmbeddedShield = GUICreate("", $aPosCtl[2], $aPosCtl[3], 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), BitOR($WS_EX_TOPMOST, ($bNoVisibleShield ? $WS_EX_TRANSPARENT : 0)), $frmBot)
Else
WinMove($frmBotEmbeddedShield, "", 0, 0, $aPosCtl[2], $aPosCtl[3])
EndIf
WinMove2($hCtrlTarget, "", -1, -1, -1, -1, $HWND_BOTTOM)
Else
Local $bHasFocus = WinActive($frmBot) <> 0
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
If $frmBotEmbeddedShield = 0 Then
$frmBotEmbeddedShield = GUICreate("", $aPosCtl[2], $aPosCtl[3], $a[0], $a[1], BitOR($WS_POPUP, $WS_TABSTOP), BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_TOPMOST, $WS_EX_TRANSPARENT), $frmBot)
_WinAPI_EnableWindow($frmBotEmbeddedShield, False)
$frmBotEmbeddedMouse = GUICreate("", $aPosCtl[2], $aPosCtl[3], 0, 0, BitOR($WS_CHILD, $WS_TABSTOP), BitOR($WS_EX_TOPMOST, $WS_EX_TRANSPARENT), $frmBot)
EndIf
WinMove2($frmBotEmbeddedShield, "", $a[0], $a[1], $aPosCtl[2], $aPosCtl[3], ($bHasFocus ? $HWND_TOPMOST : $HWND_BOTTOM), 0, False)
WinMove2($frmBotEmbeddedMouse, "", 0, 0, $aPosCtl[2], $aPosCtl[3], ($bHasFocus ? $HWND_TOPMOST : $HWND_BOTTOM), 0, False)
WinMove2($hCtrlTarget, "", -1, -1, -1, -1, $HWND_BOTTOM)
SetDebugLog("$frmBotEmbeddedShield Position: " & $a[0] & ", " & $a[1] & ", " & $aPosCtl[2] & ", " & $aPosCtl[3], Default, True)
EndIf
EndIf
If $bNoVisibleShield = False Then
WinSetTrans($frmBotEmbeddedShield, "", $trans)
GUISetBkColor($color, $frmBotEmbeddedShield)
EndIf
GUISetState($show_shield, $frmBotEmbeddedShield)
GUISetState($show_shield, $frmBotEmbeddedMouse)
$g_hProcShieldInput[3] = False
$AndroidShieldStatus[0] = $Enable
$AndroidShieldStatus[1] = $color
$AndroidShieldStatus[2] = $trans
$AndroidShieldStatus[3] = $bNoVisibleShield
$AndroidShieldStatus[4] = $bDetachedShield
AndroidShieldStartup()
SetDebugLog("AndroidShield updated to " & $shieldState & "(handle=" & $frmBotEmbeddedShield & ", color=" & Hex($color, 6) & "), caller: " & $sCaller, Default, True)
Return True
EndFunc
Func AndroidGraphicsGdiBegin()
If $AndroidEmbedded = False Then Return 0
AndroidGraphicsGdiEnd()
Local $iW = $AndroidClientWidth
Local $iH = $AndroidClientHeight
Local $iOpacity = 255
Local $aPosCtl = $AndroidEmbeddedCtrlTarget[6]
If IsArray($aPosCtl) = 1 Then
$iW = $aPosCtl[2]
$iH = $aPosCtl[3]
EndIf
Local $a[2] = [0, 0]
If $frmBotEmbeddedGarphics = 0 Then
Local $bDetachedShield = $AndroidShieldStatus[4]
If $bDetachedShield = False Then
$frmBotEmbeddedGarphics = GUICreate("", $iW, $iH, 0, 0, $WS_CHILD, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_LAYERED, $WS_EX_TOPMOST), $frmBot)
Else
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
$frmBotEmbeddedGarphics = GUICreate("", $iW, $iH, $a[0], $a[1], $WS_POPUP, BitOR($WS_EX_TOOLWINDOW, $WS_EX_NOACTIVATE, $WS_EX_LAYERED, $WS_EX_TOPMOST), $frmBot)
EndIf
EndIf
GUISetState(@SW_SHOWNOACTIVATE, $frmBotEmbeddedGarphics)
Local $hDC = _WinAPI_GetDC($frmBotEmbeddedGarphics)
Local $hMDC = AndroidGraphicsGdiAddObject("hMDC", _WinAPI_CreateCompatibleDC($hDC))
Local $hBitmap = AndroidGraphicsGdiAddObject("hBitmap", _WinAPI_CreateCompatibleBitmap($hDC, $iW, $iH))
_WinAPI_SelectObject($hMDC, $hBitmap)
AndroidGraphicsGdiAddObject("hDC", $hDC)
Local $hGraphics = AndroidGraphicsGdiAddObject("Graphics", _GDIPlus_GraphicsCreateFromHDC($hMDC))
_GDIPlus_GraphicsSetSmoothingMode($hGraphics, $GDIP_SMOOTHINGMODE_HIGHQUALITY)
_GDIPlus_GraphicsClear($hGraphics)
Local $tSIZE = DllStructCreate($tagSIZE)
AndroidGraphicsGdiAddObject("DllStruct", $tSIZE)
Local $pSize = DllStructGetPtr($tSIZE)
DllStructSetData($tSIZE, "X", $iW)
DllStructSetData($tSIZE, "Y", $iH)
Local $tSource = DllStructCreate($tagPOINT)
AndroidGraphicsGdiAddObject("DllStruct", $tSource)
Local $pSource = DllStructGetPtr($tSource)
Local $tBlend = DllStructCreate($tagBLENDFUNCTION)
AndroidGraphicsGdiAddObject("DllStruct", $tBlend)
Local $pBlend = DllStructGetPtr($tBlend)
DllStructSetData($tBlend, "Alpha", $iOpacity)
DllStructSetData($tBlend, "Format", 1)
Local $tPoint = DllStructCreate($tagPOINT)
AndroidGraphicsGdiAddObject("DllStruct", $tPoint)
Local $pPoint = DllStructGetPtr($tPoint)
DllStructSetData($tPoint, "X", $a[0])
DllStructSetData($tPoint, "Y", $a[1])
AndroidGraphicsGdiUpdate()
SetDebugLog("AndroidGraphicsGdiBegin: Graphics " & $hGraphics)
Return $hGraphics
EndFunc
Func AndroidGraphicsGdiUpdate()
If $AndroidEmbedded = False Then Return 0
Local $hMDC = $aAndroidEmbeddedGraphics[0][1]
Local $hDC = $aAndroidEmbeddedGraphics[2][1]
Local $pSize = DllStructGetPtr($aAndroidEmbeddedGraphics[4][1])
Local $pSource = DllStructGetPtr($aAndroidEmbeddedGraphics[5][1])
Local $pBlend = DllStructGetPtr($aAndroidEmbeddedGraphics[6][1])
Local $pPoint = DllStructGetPtr($aAndroidEmbeddedGraphics[7][1])
Local $tPoint = DllStructCreate($tagPOINT, $pPoint)
Local $bDetachedShield = $AndroidShieldStatus[4]
Local $a = AndroidEmbed_HWnD_Position(True, $bDetachedShield)
DllStructSetData($tPoint, "X", $a[0])
DllStructSetData($tPoint, "Y", $a[1])
_WinAPI_UpdateLayeredWindow($frmBotEmbeddedGarphics, $hDC, $pPoint, $pSize, $hMDC, $pSource, 0, $pBlend, $ULW_ALPHA)
EndFunc
Func AndroidGraphicsGdiAddObject($sType, $hHandle)
If $AndroidEmbedded = False Then Return 0
Local $i = UBound($aAndroidEmbeddedGraphics)
ReDim $aAndroidEmbeddedGraphics[$i + 1][2]
$aAndroidEmbeddedGraphics[$i][0] = $sType
$aAndroidEmbeddedGraphics[$i][1] = $hHandle
SetDebugLog("AndroidGraphicsGdiAddObject: " & $sType & " " & $hHandle)
Return $hHandle
EndFunc
Func AndroidGraphicsGdiEnd($Result = Default, $bClear = True)
If UBound($aAndroidEmbeddedGraphics) > 0 Then
Local $i
For $i = UBound($aAndroidEmbeddedGraphics) - 1 To 0 Step -1
Local $sType = $aAndroidEmbeddedGraphics[$i][0]
Local $hHandle = $aAndroidEmbeddedGraphics[$i][1]
If $hHandle <> 0 Then
SetDebugLog("AndroidGraphicsGdiEnd: Dispose/release/delete " & $sType & " " & $hHandle)
Switch $sType
Case "Pen"
_GDIPlus_PenDispose($hHandle)
Case "DllStruct"
Case "Graphics"
_GDIPlus_GraphicsClear($hHandle)
AndroidGraphicsGdiUpdate()
_GDIPlus_GraphicsDispose($hHandle)
Case "hDC"
_WinAPI_ReleaseDC($frmBotEmbeddedGarphics, $hHandle)
Case "hBitmap"
_WinAPI_DeleteObject($hHandle)
Case "hMDC"
_WinAPI_DeleteDC($hHandle)
Case Else
SetDebugLog("Unknown GDI Type: " & $sType)
EndSwitch
EndIf
Next
ReDim $aAndroidEmbeddedGraphics[0][2]
If $frmBotEmbeddedGarphics <> 0 Then
GUIDelete($frmBotEmbeddedGarphics)
$frmBotEmbeddedGarphics = 0
EndIf
EndIf
Return $Result
EndFunc
Func checkAndroidPageError($bRebootAndroid = True)
If $AndroidPageError[1] = 0 Then Return False
Local $bResetTimer = TimerDiff($AndroidPageError[1]) > $iAndroidRebootPageErrorPerMinutes * 60 * 1000
If $AndroidPageError[0] >= $iAndroidRebootPageErrorCount And $bResetTimer = False Then
Local $sMin = Round(TimerDiff($AndroidPageError[1]) / (60 * 1000), 1) & " Minutes"
If $bRebootAndroid = True Then
SetLog("Reboot " & $Android & " due to " & $AndroidPageError[0] & " page errors in " & $sMin, $COLOR_ERROR)
Else
SetLog($Android & " had " & $AndroidPageError[0] & " page errors in " & $sMin, $COLOR_ERROR)
EndIf
InitAndroidPageError()
If $bRebootAndroid = True Then
Return True
EndIf
Return False
EndIf
If $bResetTimer = True Then
If $AndroidPageError[0] > 0 Then
SetDebugLog("Cleared " & $AndroidPageError[0] & " " & $Android & " page errors")
EndIf
InitAndroidPageError()
EndIf
Return False
EndFunc
Func AndroidPageError($sSource)
$AndroidPageError[0] += 1
SetDebugLog("Page error count increased to " & $AndroidPageError[0] & ", source: " & $sSource)
If $AndroidPageError[1] = 0 Then $AndroidPageError[1] = TimerInit()
Return $AndroidPageError[0]
EndFunc
Func WerFaultClose($programFile, $tryCount = 0)
Local $WinTitleMatchMode = Opt("WinTitleMatchMode", -3)
Local $title = $programFile
Local $iLastBS = StringInStr($title, "\", 0, -1)
If $iLastBS > 0 Then $title = StringMid($title, $iLastBS + 1)
Local $aList = WinList($title)
Opt("WinTitleMatchMode", $WinTitleMatchMode)
Local $closed = 0
Local $i
SetDebugLog("Found " & $aList[0][0] & " WerFault Windows with title '" & $title & "'")
If $aList[0][0] > 0 Then
For $i = 1 To $aList[0][0]
Local $HWnD = $aList[$i][1]
Local $pid = WinGetProcess($HWnD)
Local $process = ProcessGetWmiProcess($pid)
If IsObj($process) Then
Local $werfault = $process.ExecutablePath
$iLastBS = StringInStr($werfault, "\", 0, -1)
$werfault = StringMid($werfault, $iLastBS + 1)
If $werfault = "WerFault.exe" Then
SetDebugLog("Found WerFault Process " & $pid)
If WinClose($HWnD) Then
SetDebugLog("Closed " & $werfault & " Window " & $HWnD)
$closed += 1
Else
If WinKill($HWnD) Then
SetDebugLog("Killed " & $werfault & " Window " & $HWnD)
$closed += 1
Else
SetDebugLog("Cannot close " & $werfault & " Window " & $HWnD, $COLOR_RED)
EndIf
EndIf
Else
SetDebugLog("Process " & $pid & " is not WerFault, " & $process.CommandLine, $COLOR_RED)
EndIf
ELse
SetDebugLog("Wmi Object for process " & $pid & " not found")
EndIF
Next
ElseIf FileExists($programFile) = 1 Then
Local $pFileVersionInfo
If _WinAPI_GetFileVersionInfo($programFile, $pFileVersionInfo) Then
Local $FileDescription = _WinAPI_VerQueryValue($pFileVersionInfo, $FV_FILEDESCRIPTION)
If $FileDescription <> "" Then Return WerFaultClose($FileDescription, $tryCount)
EndIf
EndIf
If $closed > 0 And $tryCount < 10 Then
If _Sleep(1000) = False Then
$closed += WerFaultClose($programFile, $tryCount + 1)
EndIF
EndIf
Return $closed
EndFunc
Func _NumberFormat($Number, $NullToZero = False)
If $Number = "" Then
If $NullToZero = False Then
Return ""
Else
Return "0"
EndIf
EndIf
If StringLeft($Number, 1) = "-" Then
Return "- " & StringRegExpReplace(StringTrimLeft($Number, 1), "(\A\d{1,3}(?=(\d{3})+\z)|\d{3}(?=\d))", "\1 ")
Else
Return StringRegExpReplace($Number, "(\A\d{1,3}(?=(\d{3})+\z)|\d{3}(?=\d))", "\1 ")
EndIf
EndFunc
Func _PadStringCenter($String = "", $Width = 50, $PadChar = "=")
If $String = "" Then Return ""
Local $Odd = Mod(($Width - StringLen($String)), 2)
Local $Count = ($Width - StringLen($String)) / 2
Local $Pad = ""
For $i = 0 To $Count - 1
$Pad &= $PadChar
Next
If $Odd Then
$Out = $Pad & $String & $Pad & $PadChar
Else
$Out = $Pad & $String & $Pad
EndIf
Return $Out
EndFunc
Func _ProcessSuspendResume($iPIDorName, $iSuspend = True)
If IsString($iPIDorName) Then $iPIDorName = ProcessExists($iPIDorName)
If Not $iPIDorName Then Return SetError(2, 0, 0)
Local $ai_Handle = _WinAPI_OpenProcess( $PROCESS_ALL_ACCESS, False, $iPIDorName )
Local $i_sucess = DllCall("ntdll.dll","int","Nt" & ($iSuspend ? "Suspend" : "Resume") & "Process","int",$ai_Handle)
_WinAPI_CloseHandle($ai_Handle)
If IsArray($i_sucess) Then Return 1
Return SetError(1, 0, 0)
EndFunc
Func _ProcessSuspendResume2($iPIDorName, $iSuspend = True)
If IsString($iPIDorName) Then $iPIDorName = ProcessExists($iPIDorName)
If Not $iPIDorName Then Return SetError(2, 0, 0)
If $iSuspend Then
DllCall('kernel32.dll', 'ptr', 'DebugActiveProcess', 'int', $iPIDorName)
DllCall('kernel32.dll', 'ptr', 'DebugSetProcessKillOnExit', 'int', False)
Else
DllCall('kernel32.dll', 'ptr', 'DebugActiveProcessStop', 'int', $iPIDorName)
EndIf
EndFunc
Func _Sleep($iDelay, $iSleep = True, $CheckRunState = True, $SleepWhenPaused = True)
Local $iBegin = TimerInit()
If $iDelay > 0 Then
If $RunState And Not $bSearchMode And Not $TPaused And ($hTimer_SetTime = 0 Or TimerDiff($hTimer_SetTime) >= 1000) Then
SetTime()
$hTimer_SetTime = TimerInit()
EndIf
If $hTimer_PBRemoteControlInterval = 0 Or TimerDiff($hTimer_PBRemoteControlInterval) >= $PBRemoteControlInterval Then
PushBulletRemoteControl()
$hTimer_PBRemoteControlInterval = TimerInit()
EndIf
If $hTimer_PBDeleteOldPushesInterval = 0 Or TimerDiff($hTimer_PBDeleteOldPushesInterval) >= $PBDeleteOldPushesInterval Then
PushBulletDeleteOldPushes()
$hTimer_PBDeleteOldPushesInterval = TimerInit()
EndIf
If $hTimer_EmptyWorkingSetAndroid = 0 Or TimerDiff($hTimer_EmptyWorkingSetAndroid) >= $iEmptyWorkingSetAndroid Then
_WinAPI_EmptyWorkingSet(GetAndroidPid())
$hTimer_EmptyWorkingSetAndroid = TimerInit()
EndIf
If $hTimer_EmptyWorkingSetBot = 0 Or TimerDiff($hTimer_EmptyWorkingSetBot) >= $iEmptyWorkingSetBot Then
_WinAPI_EmptyWorkingSet(@AutoItPID)
$hTimer_EmptyWorkingSetBot = TimerInit()
EndIF
If $TogglePauseUpdateState Then TogglePauseUpdateState("_Sleep")
If $TPaused And $SleepWhenPaused And $TogglePauseAllowed Then TogglePauseSleep()
If $bMoveDivider Then
MoveDivider()
$bMoveDivider = False
EndIf
If $NotifyDeleteAllPushesNow = True Then PushMsg("DeleteAllPBMessages")
If $iMakeScreenshotNow = True Then
If $iScreenshotType = 0 Then
MakeScreenshot($dirTemp, "jpg")
Else
MakeScreenshot($dirTemp, "png")
EndIf
EndIf
EndIf
If $CheckRunState = True And $RunState = False Then
ResumeAndroid()
Return True
EndIf
Local $iRemaining = $iDelay - TimerDiff($iBegin)
While $iRemaining > 0
If $CheckRunState = True And $RunState = False Then
ResumeAndroid()
Return True
EndIf
If $iRemaining >= $iDelaySleep Then
Sleep($iDelaySleep)
ElseIf $iRemaining >= 10 Then
Sleep($iRemaining)
EndIf
$iRemaining = $iDelay - TimerDiff($iBegin)
AndroidEmbedCheck()
AndroidShieldCheck()
WEnd
Return False
EndFunc
Func _SleepStatus($iDelay, $iSleep = True, $bDirection = True, $CheckRunState = True)
Local $iCurTime, $iMinCalc, $iSecCalc, $iTime, $iBegin, $sString, $hLastUpdate
Local $iDelayMinCalc, $iDelaySecCalc, $iDelaySecCalc
Local Const $Font = "Verdana"
Local Const $FontSize = 7.5
Local $bUpdate = True
$iBegin = TimerInit()
$iDelayMinCalc = Int($iDelay / (60 * 1000))
$iDelaySecCalc = $iDelay - ($iDelayMinCalc * 60 * 1000)
$iDelaySecCalc = Int($iDelaySecCalc / 1000)
While TimerDiff($iBegin) < $iDelay
If $RunState = False And $CheckRunState = True Then Return True
If $bUpdate Then
$iCurTime = TimerDiff($iBegin)
$iTime = $iCurTime
If $bDirection = True Then $iTime = $iDelay - $iCurTime
$iMinCalc = Int($iTime / (60 * 1000))
$iSecCalc = $iTime - ($iMinCalc * 60 * 1000)
$iSecCalc = Int($iSecCalc / 1000)
$sString = "Waiting Time= " & StringFormat("%02u" & ":" & "%02u", $iDelayMinCalc, $iDelaySecCalc) & ",  Time Left= " & StringFormat("%02u" & ":" & "%02u", $iMinCalc, $iSecCalc)
$hLastUpdate = TimerInit()
_GUICtrlStatusBar_SetText($statLog, " Status: " & $sString)
EndIf
If $iSleep = True Then _Sleep($iDelaySleep)
$bUpdate = TimerDiff($hLastUpdate) > 500
WEnd
If $RunState = False And $CheckRunState = True Then Return True
Return False
EndFunc
Func _StatusUpdateTime($hTimer, $sWhyWait = "")
$iCurTime = TimerDiff($hTimer)
$iMinCalc = Int($iCurTime / (60 * 1000))
$iSecCalc = Int(($iCurTime - ($iMinCalc * 60 * 1000)) / 1000)
$sString = $sWhyWait & " Wait Time = " & StringFormat("%02u" & ":" & "%02u", $iMinCalc, $iSecCalc)
_GUICtrlStatusBar_SetText($statLog, " Status: " & $sString)
EndFunc
Global Const $KLF_ACTIVATE = 0x00000001
Global Const $KLF_NOTELLSHELL = 0x00000080
Global Const $KLF_REORDER = 0x00000008
Global Const $KLF_REPLACELANG = 0x00000010
Global Const $KLF_RESET = 0x40000000
Global Const $KLF_SETFORPROCESS = 0x00000100
Global Const $KLF_SHIFTLOCK = 0x00010000
Global Const $KLF_SUBSTITUTE_OK = 0x00000002
Global Const $HKL_NEXT = 1
Global Const $HKL_PREV = 0
Global Const $AW_ACTIVATE = 0x00020000
Global Const $AW_BLEND = 0x00080000
Global Const $AW_CENTER = 0x00000010
Global Const $AW_HIDE = 0x00010000
Global Const $AW_HOR_NEGATIVE = 0x00000002
Global Const $AW_HOR_POSITIVE = 0x00000001
Global Const $AW_SLIDE = 0x00040000
Global Const $AW_VER_NEGATIVE = 0x00000008
Global Const $AW_VER_POSITIVE = 0x00000004
Global Const $BSF_ALLOWSFW = 0x0080
Global Const $BSF_FLUSHDISK = 0x0004
Global Const $BSF_FORCEIFHUNG = 0x0020
Global Const $BSF_IGNORECURRENTTASK = 0x0002
Global Const $BSF_NOHANG = 0x0008
Global Const $BSF_NOTIMEOUTIFNOTHUNG = 0x0040
Global Const $BSF_POSTMESSAGE = 0x0010
Global Const $BSF_QUERY = 0x0001
Global Const $BSF_SENDNOTIFYMESSAGE = 0x0100
Global Const $BSM_ALLCOMPONENTS = 0x00
Global Const $BSM_ALLDESKTOPS = 0x08
Global Const $BSM_APPLICATIONS = 0x10
Global Const $BSM_INSTALLABLEDRIVERS = 0x04
Global Const $BSM_NETDRIVER = 0x02
Global Const $BSM_VXDS = 0x01
Global Const $MDITILE_HORIZONTAL = 0x01
Global Const $MDITILE_SKIPDISABLED = 0x02
Global Const $MDITILE_VERTICAL = 0x00
Global Const $MDITILE_ZORDER = 0x04
Global Const $MSGFLT_ALLOW = 1
Global Const $MSGFLT_DISALLOW = 2
Global Const $MSGFLT_RESET = 0
Global Const $MSGFLTINFO_ALLOWED_HIGHER = 3
Global Const $MSGFLTINFO_ALREADYALLOWED_FORWND = 1
Global Const $MSGFLTINFO_ALREADYDISALLOWED_FORWND = 2
Global Const $MSGFLTINFO_NONE = 0
Global Const $CWP_ALL = 0x00
Global Const $CWP_SKIPINVISIBLE = 0x01
Global Const $CWP_SKIPDISABLED = 0x02
Global Const $CWP_SKIPTRANSPARENT = 0x04
Global Const $COMPRESSION_FORMAT_NONE = 0x0000
Global Const $COMPRESSION_FORMAT_DEFAULT = 0x0001
Global Const $COMPRESSION_FORMAT_LZNT1 = 0x0002
Global Const $COMPRESSION_FORMAT_XPRESS = 0x0003
Global Const $COMPRESSION_FORMAT_XPRESS_HUFF = 0x0004
Global Const $COMPRESSION_ENGINE_STANDARD = 0x0000
Global Const $COMPRESSION_ENGINE_MAXIMUM = 0x0100
Global Const $COMPRESSION_ENGINE_HIBER = 0x0200
Global Const $WINSTA_ACCESSCLIPBOARD = 0x0004
Global Const $WINSTA_ACCESSGLOBALATOMS = 0x0020
Global Const $WINSTA_CREATEDESKTOP = 0x0008
Global Const $WINSTA_ENUMDESKTOPS = 0x0001
Global Const $WINSTA_ENUMERATE = 0x0100
Global Const $WINSTA_EXITWINDOWS = 0x0040
Global Const $WINSTA_READATTRIBUTES = 0x0002
Global Const $WINSTA_READSCREEN = 0x0200
Global Const $WINSTA_WRITEATTRIBUTES = 0x0010
Global Const $WINSTA_ALL_ACCESS = BitOR($WINSTA_ACCESSCLIPBOARD, $WINSTA_ACCESSGLOBALATOMS, $WINSTA_CREATEDESKTOP, $WINSTA_ENUMDESKTOPS, $WINSTA_ENUMERATE, $WINSTA_EXITWINDOWS, $WINSTA_READATTRIBUTES, $WINSTA_READSCREEN, $WINSTA_WRITEATTRIBUTES)
Global Const $CWF_CREATE_ONLY = 0x01
Global Const $GCL_CBCLSEXTRA = -20
Global Const $GCL_CBWNDEXTRA = -18
Global Const $GCL_HBRBACKGROUND = -10
Global Const $GCL_HCURSOR = -12
Global Const $GCL_HICON = -14
Global Const $GCL_HICONSM = -34
Global Const $GCL_HMODULE = -16
Global Const $GCL_MENUNAME = -8
Global Const $GCL_STYLE = -26
Global Const $GCL_WNDPROC = -24
Global Const $DOCKINFO_DOCKED = 0x02
Global Const $DOCKINFO_UNDOCKED = 0x01
Global Const $DOCKINFO_USER_SUPPLIED = 0x04
Global Const $DOCKINFO_USER_DOCKED = 0x05
Global Const $DOCKINFO_USER_UNDOCKED = 0x06
Global Const $GUI_CARETBLINKING = 0x0001
Global Const $GUI_INMENUMODE = 0x0004
Global Const $GUI_INMOVESIZE = 0x0002
Global Const $GUI_POPUPMENUMODE = 0x0010
Global Const $GUI_SYSTEMMENUMODE = 0x0008
Global Const $HANDLE_FLAG_INHERIT = 0x00000001
Global Const $HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002
Global Const $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 0x0004
Global Const $GET_MODULE_HANDLE_EX_FLAG_PIN = 0x0001
Global Const $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 0x0002
Global Const $GET_MODULE_HANDLE_EX_FLAG_DEFAULT = 0x0000
Global Const $PROCESSOR_ARCHITECTURE_AMD64 = 9
Global Const $PROCESSOR_ARCHITECTURE_IA64 = 6
Global Const $PROCESSOR_ARCHITECTURE_INTEL = 0
Global Const $PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF
Global Const $PROCESSOR_INTEL_386 = 386
Global Const $PROCESSOR_INTEL_486 = 486
Global Const $PROCESSOR_INTEL_PENTIUM = 586
Global Const $PROCESSOR_INTEL_IA64 = 2200
Global Const $PROCESSOR_AMD_X8664 = 8664
Global Const $UOI_FLAGS = 1
Global Const $UOI_HEAPSIZE = 5
Global Const $UOI_IO = 6
Global Const $UOI_NAME = 2
Global Const $UOI_TYPE = 3
Global Const $UOI_USER_SID = 4
Global Const $DF_ALLOWOTHERACCOUNTHOOK = 0x01
Global Const $WSF_VISIBLE = 0x01
Global Const $VER_SUITE_BACKOFFICE = 0x00000004
Global Const $VER_SUITE_BLADE = 0x00000400
Global Const $VER_SUITE_COMPUTE_SERVER = 0x00004000
Global Const $VER_SUITE_DATACENTER = 0x00000080
Global Const $VER_SUITE_ENTERPRISE = 0x00000002
Global Const $VER_SUITE_EMBEDDEDNT = 0x00000040
Global Const $VER_SUITE_PERSONAL = 0x00000200
Global Const $VER_SUITE_SINGLEUSERTS = 0x00000100
Global Const $VER_SUITE_SMALLBUSINESS = 0x00000001
Global Const $VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020
Global Const $VER_SUITE_STORAGE_SERVER = 0x00002000
Global Const $VER_SUITE_TERMINAL = 0x00000010
Global Const $VER_SUITE_WH_SERVER = 0x00008000
Global Const $VER_NT_DOMAIN_CONTROLLER = 0x0000002
Global Const $VER_NT_SERVER = 0x0000003
Global Const $VER_NT_WORKSTATION = 0x0000001
Global Const $WDA_MONITOR = 0x01
Global Const $WDA_NONE = 0x00
Global Const $PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7
Global Const $PF_CHANNELS_ENABLED = 16
Global Const $PF_COMPARE_EXCHANGE_DOUBLE = 2
Global Const $PF_COMPARE_EXCHANGE128 = 14
Global Const $PF_COMPARE64_EXCHANGE128 = 15
Global Const $PF_FLOATING_POINT_EMULATED = 1
Global Const $PF_FLOATING_POINT_PRECISION_ERRATA = 0
Global Const $PF_MMX_INSTRUCTIONS_AVAILABLE = 3
Global Const $PF_NX_ENABLED = 12
Global Const $PF_PAE_ENABLED = 9
Global Const $PF_RDTSC_INSTRUCTION_AVAILABLE = 8
Global Const $PF_SSE3_INSTRUCTIONS_AVAILABLE = 13
Global Const $PF_XMMI_INSTRUCTIONS_AVAILABLE = 6
Global Const $PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10
Global Const $PF_XSAVE_ENABLED = 17
Global Const $KEYEVENTF_EXTENDEDKEY = 0x01
Global Const $KEYEVENTF_KEYUP = 0x02
Global Const $LIM_SMALL = 0
Global Const $LIM_LARGE = 1
Global Const $MAPVK_VK_TO_CHAR = 2
Global Const $MAPVK_VK_TO_VSC = 0
Global Const $MAPVK_VK_TO_VSC_EX = 4
Global Const $MAPVK_VSC_TO_VK = 1
Global Const $MAPVK_VSC_TO_VK_EX = 3
Global Const $MOD_ALT = 0x0001
Global Const $MOD_CONTROL = 0x0002
Global Const $MOD_NOREPEAT = 0x4000
Global Const $MOD_SHIFT = 0x0004
Global Const $MOD_WIN = 0x0008
Global Const $GUID_ACDC_POWER_SOURCE = '{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}'
Global Const $GUID_BATTERY_PERCENTAGE_REMAINING = '{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}'
Global Const $GUID_IDLE_BACKGROUND_TASK = '{515C31D8-F734-163D-A0FD-11A08C91E8F1}'
Global Const $GUID_MONITOR_POWER_ON = '{02731015-4510-4526-99E6-E5A17EBD1AEA}'
Global Const $GUID_POWERSCHEME_PERSONALITY = '{245D8541-3943-4422-B025-13A784F679B7}'
Global Const $GUID_SYSTEM_AWAYMODE = '{98A7F580-01F7-48AA-9C0F-44352C29E5C0}'
Global Const $GUID_MIN_POWER_SAVINGS = '{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}'
Global Const $GUID_MAX_POWER_SAVINGS = '{A1841308-3541-4FAB-BC81-F71556F20B4A}'
Global Const $GUID_TYPICAL_POWER_SAVINGS = '{381B4222-F694-41F0-9685-FF5BB260DF2E}'
Global Const $HSHELL_WINDOWCREATED = 1
Global Const $HSHELL_WINDOWDESTROYED = 2
Global Const $HSHELL_ACTIVATESHELLWINDOW = 3
Global Const $HSHELL_WINDOWACTIVATED = 4
Global Const $HSHELL_GETMINRECT = 5
Global Const $HSHELL_REDRAW = 6
Global Const $HSHELL_TASKMAN = 7
Global Const $HSHELL_LANGUAGE = 8
Global Const $HSHELL_SYSMENU = 9
Global Const $HSHELL_ENDTASK = 10
Global Const $HSHELL_ACCESSIBILITYSTATE = 11
Global Const $HSHELL_APPCOMMAND = 12
Global Const $HSHELL_WINDOWREPLACED = 13
Global Const $HSHELL_WINDOWREPLACING = 14
Global Const $HSHELL_RUDEAPPACTIVATED = 32772
Global Const $HSHELL_FLASH = 32774
Global Const $HWND_BROADCAST = 0xFFFF
Global Const $SMTO_BLOCK = 0x0001
Global Const $SMTO_NORMAL = 0x0000
Global Const $SMTO_ABORTIFHUNG = 0x0002
Global Const $SMTO_NOTIMEOUTIFNOTHUNG = 0x0008
Global Const $SMTO_ERRORONEXIT = 0x0020
Global Const $INPUTLANGCHANGE_BACKWARD = 0x0004
Global Const $INPUTLANGCHANGE_FORWARD = 0x0002
Global Const $INPUTLANGCHANGE_SYSCHARSET = 0x0001
Global Const $EVENT_MIN = 0x00000001
Global Const $EVENT_SYSTEM_SOUND = 0x00000001
Global Const $EVENT_SYSTEM_ALERT = 0x00000002
Global Const $EVENT_SYSTEM_FOREGROUND = 0x00000003
Global Const $EVENT_SYSTEM_MENUSTART = 0x00000004
Global Const $EVENT_SYSTEM_MENUEND = 0x00000005
Global Const $EVENT_SYSTEM_MENUPOPUPSTART = 0x00000006
Global Const $EVENT_SYSTEM_MENUPOPUPEND = 0x00000007
Global Const $EVENT_SYSTEM_CAPTURESTART = 0x00000008
Global Const $EVENT_SYSTEM_CAPTUREEND = 0x00000009
Global Const $EVENT_SYSTEM_MOVESIZESTART = 0x0000000A
Global Const $EVENT_SYSTEM_MOVESIZEEND = 0x0000000B
Global Const $EVENT_SYSTEM_CONTEXTHELPSTART = 0x0000000C
Global Const $EVENT_SYSTEM_CONTEXTHELPEND = 0x0000000D
Global Const $EVENT_SYSTEM_DRAGDROPSTART = 0x0000000E
Global Const $EVENT_SYSTEM_DRAGDROPEND = 0x0000000F
Global Const $EVENT_SYSTEM_DIALOGSTART = 0x00000010
Global Const $EVENT_SYSTEM_DIALOGEND = 0x00000011
Global Const $EVENT_SYSTEM_SCROLLINGSTART = 0x00000012
Global Const $EVENT_SYSTEM_SCROLLINGEND = 0x00000013
Global Const $EVENT_SYSTEM_SWITCHSTART = 0x00000014
Global Const $EVENT_SYSTEM_SWITCHEND = 0x00000015
Global Const $EVENT_SYSTEM_MINIMIZESTART = 0x00000016
Global Const $EVENT_SYSTEM_MINIMIZEEND = 0x00000017
Global Const $EVENT_SYSTEM_DESKTOPSWITCH = 0x00000020
Global Const $EVENT_OBJECT_CREATE = 0x00008000
Global Const $EVENT_OBJECT_DESTROY = 0x00008001
Global Const $EVENT_OBJECT_SHOW = 0x00008002
Global Const $EVENT_OBJECT_HIDE = 0x00008003
Global Const $EVENT_OBJECT_REORDER = 0x00008004
Global Const $EVENT_OBJECT_FOCUS = 0x00008005
Global Const $EVENT_OBJECT_SELECTION = 0x00008006
Global Const $EVENT_OBJECT_SELECTIONADD = 0x00008007
Global Const $EVENT_OBJECT_SELECTIONREMOVE = 0x00008008
Global Const $EVENT_OBJECT_SELECTIONWITHIN = 0x00008009
Global Const $EVENT_OBJECT_STATECHANGE = 0x0000800A
Global Const $EVENT_OBJECT_LOCATIONCHANGE = 0x0000800B
Global Const $EVENT_OBJECT_NAMECHANGE = 0x0000800C
Global Const $EVENT_OBJECT_DESCRIPTIONCHANGE = 0x0000800D
Global Const $EVENT_OBJECT_VALUECHANGE = 0x0000800E
Global Const $EVENT_OBJECT_PARENTCHANGE = 0x0000800F
Global Const $EVENT_OBJECT_HELPCHANGE = 0x00008010
Global Const $EVENT_OBJECT_DEFACTIONCHANGE = 0x00008011
Global Const $EVENT_OBJECT_ACCELERATORCHANGE = 0x00008012
Global Const $EVENT_OBJECT_INVOKED = 0x00008013
Global Const $EVENT_OBJECT_TEXTSELECTIONCHANGED = 0x00008014
Global Const $EVENT_OBJECT_CONTENTSCROLLED = 0x00008015
Global Const $EVENT_MAX = 0x7FFFFFFF
Global Const $WINEVENT_INCONTEXT = 0x04
Global Const $WINEVENT_OUTOFCONTEXT = 0x00
Global Const $WINEVENT_SKIPOWNPROCESS = 0x02
Global Const $WINEVENT_SKIPOWNTHREAD = 0x01
Global Const $TME_CANCEL = 0x80000000
Global Const $TME_HOVER = 0x00000001
Global Const $TME_LEAVE = 0x00000002
Global Const $TME_NONCLIENT = 0x00000010
Global Const $TME_QUERY = 0x40000000
Global Const $DESKTOP_CREATEMENU = 0x0004
Global Const $DESKTOP_CREATEWINDOW = 0x0002
Global Const $DESKTOP_ENUMERATE = 0x0040
Global Const $DESKTOP_HOOKCONTROL = 0x0008
Global Const $DESKTOP_JOURNALPLAYBACK = 0x0020
Global Const $DESKTOP_JOURNALRECORD = 0x0010
Global Const $DESKTOP_READOBJECTS = 0x0001
Global Const $DESKTOP_SWITCHDESKTOP = 0x0100
Global Const $DESKTOP_WRITEOBJECTS = 0x0080
Global Const $DESKTOP_ALL_ACCESS = BitOR($DESKTOP_CREATEMENU, $DESKTOP_CREATEWINDOW, $DESKTOP_ENUMERATE, $DESKTOP_HOOKCONTROL, $DESKTOP_JOURNALPLAYBACK, $DESKTOP_JOURNALRECORD, $DESKTOP_READOBJECTS, $DESKTOP_SWITCHDESKTOP, $DESKTOP_WRITEOBJECTS)
Global Const $RIDEV_APPKEYS = 0x00000400
Global Const $RIDEV_CAPTUREMOUSE = 0x00000200
Global Const $RIDEV_DEVNOTIFY = 0x00002000
Global Const $RIDEV_EXCLUDE = 0x00000010
Global Const $RIDEV_EXINPUTSINK = 0x00001000
Global Const $RIDEV_INPUTSINK = 0x00000100
Global Const $RIDEV_NOHOTKEYS = 0x00000200
Global Const $RIDEV_NOLEGACY = 0x00000030
Global Const $RIDEV_PAGEONLY = 0x00000020
Global Const $RIDEV_REMOVE = 0x00000001
Global Const $RID_HEADER = 0x10000005
Global Const $RID_INPUT = 0x10000003
Global Const $RIM_TYPEHID = 2
Global Const $RIM_TYPEKEYBOARD = 1
Global Const $RIM_TYPEMOUSE = 0
Global Const $RIDI_DEVICENAME = 0x20000007
Global Const $RIDI_DEVICEINFO = 0x2000000B
Global Const $RIDI_PREPARSEDDATA = 0x20000005
Global Const $MOUSE_ATTRIBUTES_CHANGED = 0x04
Global Const $MOUSE_MOVE_ABSOLUTE = 0x01
Global Const $MOUSE_MOVE_RELATIVE = 0x00
Global Const $MOUSE_VIRTUAL_DESKTOP = 0x02
Global Const $RI_MOUSE_LEFT_BUTTON_DOWN = 0x0001
Global Const $RI_MOUSE_LEFT_BUTTON_UP = 0x0002
Global Const $RI_MOUSE_MIDDLE_BUTTON_DOWN = 0x0010
Global Const $RI_MOUSE_MIDDLE_BUTTON_UP = 0x0020
Global Const $RI_MOUSE_RIGHT_BUTTON_DOWN = 0x0004
Global Const $RI_MOUSE_RIGHT_BUTTON_UP = 0x0008
Global Const $RI_MOUSE_BUTTON_1_DOWN = $RI_MOUSE_LEFT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_1_UP = $RI_MOUSE_LEFT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_2_DOWN = $RI_MOUSE_RIGHT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_2_UP = $RI_MOUSE_RIGHT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_3_DOWN = $RI_MOUSE_MIDDLE_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_3_UP = $RI_MOUSE_MIDDLE_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_4_DOWN = 0x0040
Global Const $RI_MOUSE_BUTTON_4_UP = 0x0080
Global Const $RI_MOUSE_BUTTON_5_DOWN = 0x0100
Global Const $RI_MOUSE_BUTTON_5_UP = 0x0200
Global Const $RI_MOUSE_WHEEL = 0x0400
Global Const $RI_KEY_BREAK = 1
Global Const $RI_KEY_E0 = 2
Global Const $RI_KEY_E1 = 4
Global Const $RI_KEY_MAKE = 0
#Region Global Variables and Constants
Global Const $tagOSVERSIONINFOEX = $tagOSVERSIONINFO & ';ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved'
Global Const $tagRAWINPUTDEVICE = 'struct;ushort UsagePage;ushort Usage;dword Flags;hwnd hTarget;endstruct'
Global Const $tagRAWINPUTHEADER = 'struct;dword Type;dword Size;handle hDevice;wparam wParam;endstruct'
Global Const $tagRAWMOUSE = 'ushort Flags;ushort Alignment;ushort ButtonFlags;ushort ButtonData;ulong RawButtons;long LastX;long LastY;ulong ExtraInformation;'
Global Const $tagRAWKEYBOARD = 'ushort MakeCode;ushort Flags;ushort Reserved;ushort VKey;uint Message;ulong ExtraInformation;'
Global Const $tagRAWHID = 'dword SizeHid;dword Count;'
Global Const $tagRAWINPUTMOUSE = $tagRAWINPUTHEADER & ';' & $tagRAWMOUSE
Global Const $tagRAWINPUTKEYBOARD = $tagRAWINPUTHEADER & ';' & $tagRAWKEYBOARD
Global Const $tagRAWINPUTHID = $tagRAWINPUTHEADER & ';' & $tagRAWHID
Global Const $tagRID_DEVICE_INFO_MOUSE = 'struct;dword Id;dword NumberOfButtons;dword SampleRate;int HasHorizontalWheel;endstruc'
Global Const $tagRID_DEVICE_INFO_KEYBOARD = 'struct;dword KbType;dword KbSubType;dword KeyboardMode;dword NumberOfFunctionKeys;dword NumberOfIndicators;dword NumberOfKeysTotal;endstruc'
Global Const $tagRID_DEVICE_INFO_HID = 'struct;dword VendorId;dword ProductId;dword VersionNumber;ushort UsagePage;ushort Usage;endstruc'
Global Const $tagRID_INFO_MOUSE = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_MOUSE & ';dword Unused[2];'
Global Const $tagRID_INFO_KEYBOARD = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_KEYBOARD
Global Const $tagRID_INFO_HID = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_HID & ';dword Unused[2]'
Global Const $tagSHELLHOOKINFO = 'hwnd hWnd;' & $tagRECT
Global Const $tagUPDATELAYEREDWINDOWINFO = 'dword Size;hwnd hDstDC;long DstX;long DstY;long cX;long cY;hwnd hSrcDC;long SrcX;long SrcY;dword crKey;byte BlendOp;byte BlendFlags;byte Alpha;byte AlphaFormat;dword Flags;long DirtyLeft;long DirtyTop;long DirtyRight;long DirtyBottom'
Global Const $tagUSEROBJECTFLAGS = 'int Inherit;int Reserved;dword Flags'
Global Const $tagWINDOWINFO = 'dword Size;struct;long rWindow[4];endstruct;struct;long rClient[4];endstruct;dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;word atomWindowType;word CreatorVersion'
Global Const $tagWNDCLASS = 'uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName'
Global Const $tagWNDCLASSEX = 'uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_ActivateKeyboardLayout($hLocale, $iFlag = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'ActivateKeyboardLayout', 'handle', $hLocale, 'uint', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_AddClipboardFormatListener($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'AddClipboardFormatListener', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AdjustWindowRectEx(ByRef $tRECT, $iStyle, $iExStyle = 0, $bMenu = False)
Local $aRet = DllCall('user32.dll', 'bool', 'AdjustWindowRectEx', 'struct*', $tRECT, 'dword', $iStyle, 'bool', $bMenu,  'dword', $iExStyle)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AnimateWindow($hWnd, $iFlags, $iDuration = 1000)
Local $aRet = DllCall('user32.dll', 'bool', 'AnimateWindow', 'hwnd', $hWnd, 'dword', $iDuration, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_BeginDeferWindowPos($iAmount = 1)
Local $aRet = DllCall('user32.dll', 'handle', 'BeginDeferWindowPos', 'int', $iAmount)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_BringWindowToTop($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'BringWindowToTop', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_BroadcastSystemMessage($iMsg, $wParam = 0, $lParam = 0, $iFlags = 0, $iRecipients = 0)
Local $aRet = DllCall('user32.dll', 'long', 'BroadcastSystemMessageW', 'dword', $iFlags, 'dword*', $iRecipients,  'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, -1)
Return SetExtended($aRet[2], $aRet[0])
EndFunc
Func _WinAPI_CallWindowProcW($pPrevWndProc, $hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('user32.dll', 'lresult', 'CallWindowProcW', 'ptr', $pPrevWndProc, 'hwnd', $hWnd, 'uint', $iMsg,  'wparam', $wParam, 'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CascadeWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aWnds, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tWnds = DllStructCreate('hwnd[' & $iCount & ']')
$iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tWnds, 1, $aWnds[$i], $iCount)
$iCount += 1
Next
Local $aRet = DllCall('user32.dll', 'word', 'CascadeWindows', 'hwnd', $hParent, 'uint', $iFlags, 'struct*', $tRECT,  'uint', $iCount - 1, 'struct*', $tWnds)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ChangeWindowMessageFilterEx($hWnd, $iMsg, $iAction)
Local $tCFS, $aRet
If $hWnd And ($__WINVER > 0x0600) Then
Local Const $tagCHANGEFILTERSTRUCT = 'dword cbSize; dword ExtStatus'
$tCFS = DllStructCreate($tagCHANGEFILTERSTRUCT)
DllStructSetData($tCFS, 1, DllStructGetSize($tCFS))
$aRet = DllCall('user32.dll', 'bool', 'ChangeWindowMessageFilterEx', 'hwnd', $hWnd, 'uint', $iMsg, 'dword', $iAction,  'struct*', $tCFS)
Else
$tCFS = 0
$aRet = DllCall('user32.dll', 'bool', 'ChangeWindowMessageFilter', 'uint', $iMsg, 'dword', $iAction)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended(DllStructGetData($tCFS, 2), 1)
EndFunc
Func _WinAPI_ChildWindowFromPointEx($hWnd, $tPOINT, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'hwnd', 'ChildWindowFromPointEx', 'hwnd', $hWnd, 'struct', $tPOINT, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseDesktop($hDesktop)
Local $aRet = DllCall('user32.dll', 'bool', 'CloseDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'CloseWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseWindowStation($hStation)
Local $aRet = DllCall('user32.dll', 'bool', 'CloseWindowStation', 'handle', $hStation)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormatAndEngine = 0x0002)
Local $aRet, $pWorkSpace = 0, $iError = 0
Do
$aRet = DllCall('ntdll.dll', 'uint', 'RtlGetCompressionWorkSpaceSize', 'ushort', $iFormatAndEngine, 'ulong*', 0, 'ulong*', 0)
If @error Or $aRet[0] Then
$iError = @error + 20
ExitLoop
EndIf
$pWorkSpace = __HeapAlloc($aRet[2])
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$aRet = DllCall('ntdll.dll', 'uint', 'RtlCompressBuffer', 'ushort', $iFormatAndEngine, 'struct*', $pUncompressedBuffer,  'ulong', $iUncompressedSize, 'struct*', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong', 4096,  'ulong*', 0, 'ptr', $pWorkSpace)
If @error Or $aRet[0] Or Not $aRet[7] Then
$iError = @error + 30
ExitLoop
EndIf
Until 1
__HeapFree($pWorkSpace)
If $iError Then
If IsArray($aRet) Then
Return SetError(10, $aRet[0], 0)
Else
Return SetError($iError, 0, 0)
EndIf
EndIf
Return $aRet[7]
EndFunc
Func _WinAPI_ComputeCrc32($pMemory, $iLength)
If _WinAPI_IsBadReadPtr($pMemory, $iLength) Then Return SetError(1, @extended, 0)
Local $aRet = DllCall('ntdll.dll', 'dword', 'RtlComputeCrc32', 'dword', 0, 'struct*', $pMemory, 'int', $iLength)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateBuffer($iLength, $pBuffer = 0, $bAbort = True)
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 0, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
Return $pBuffer
EndFunc
Func _WinAPI_CreateBufferFromStruct($tStruct, $pBuffer = 0, $bAbort = True)
If Not IsDllStruct($tStruct) Then Return SetError(1, 0, 0)
$pBuffer = __HeapReAlloc($pBuffer, DllStructGetSize($tStruct), 0, $bAbort)
If @error Then Return SetError(@error + 100, @extended, 0)
_WinAPI_MoveMemory($pBuffer, $tStruct, DllStructGetSize($tStruct))
Return $pBuffer
EndFunc
Func _WinAPI_CreateDesktop($sName, $iAccess = 0x0002, $iFlags = 0, $iHeap = 0, $tSecurity = 0)
Local $aRet
If $iHeap Then
$aRet = DllCall('user32.dll', 'handle', 'CreateDesktopExW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags,  'dword', $iAccess, 'struct*', $tSecurity, 'ulong', $iHeap, 'ptr', 0)
Else
$aRet = DllCall('user32.dll', 'handle', 'CreateDesktopW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags,  'dword', $iAccess, 'struct*', $tSecurity)
EndIf
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateString($sString, $pString = 0, $iLength = -1, $bUnicode = True, $bAbort = True)
$iLength = Number($iLength)
If $iLength >= 0 Then
$sString = StringLeft($sString, $iLength)
Else
$iLength = StringLen($sString)
EndIf
Local $iSize = $iLength + 1
If $bUnicode Then
$iSize *= 2
EndIf
$pString = __HeapReAlloc($pString, $iSize, 0, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
DllStructSetData(DllStructCreate(__Iif($bUnicode, 'wchar', 'char') & '[' & ($iLength + 1) & ']', $pString), 1, $sString)
Return SetExtended($iLength, $pString)
EndFunc
Func _WinAPI_CreateWindowStation($sName = '', $iAccess = 0, $iFlags = 0, $tSecurity = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateWindowStationW', 'wstr', $sName, 'dword', $iFlags, 'dword', $iAccess,  'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DecompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormat = 0x0002)
Local $aRet = DllCall('ntdll.dll', 'long', 'RtlDecompressBuffer', 'ushort', $iFormat, 'struct*', $pUncompressedBuffer,  'ulong', $iUncompressedSize, 'struct*', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[6]
EndFunc
Func _WinAPI_DeferWindowPos($hInfo, $hWnd, $hAfter, $iX, $iY, $iWidth, $iHeight, $iFlags)
Local $aRet = DllCall('user32.dll', 'handle', 'DeferWindowPos', 'handle', $hInfo, 'hwnd', $hWnd, 'hwnd', $hAfter,  'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DefRawInputProc($paRawInput, $iInput)
Local $aRet = DllCall('user32.dll', 'lresult', 'DefRawInputProc', 'ptr', $paRawInput, 'int', $iInput,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DefWindowProcW($hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('user32.dll', 'lresult', 'DefWindowProcW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DeregisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'DeregisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DragAcceptFiles($hWnd, $bAccept = True)
DllCall('shell32.dll', 'none', 'DragAcceptFiles', 'hwnd', $hWnd, 'bool', $bAccept)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DragFinish($hDrop)
DllCall('shell32.dll', 'none', 'DragFinish', 'handle', $hDrop)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DragQueryFileEx($hDrop, $iFlag = 0)
Local $aRet = DllCall('shell32.dll', 'uint', 'DragQueryFileW', 'handle', $hDrop, 'uint', -1, 'ptr', 0, 'uint', 0)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
Local $iCount = $aRet[0]
Local $aResult[$iCount + 1]
For $i = 0 To $iCount - 1
$aRet = DllCall('shell32.dll', 'uint', 'DragQueryFileW', 'handle', $hDrop, 'uint', $i, 'wstr', '', 'uint', 4096)
If Not $aRet[0] Then Return SetError(11, 0, 0)
If $iFlag Then
Local $bDir = _WinAPI_PathIsDirectory($aRet[3])
If (($iFlag = 1) And $bDir) Or (($iFlag = 2) And Not $bDir) Then
ContinueLoop
EndIf
EndIf
$aResult[$i + 1] = $aRet[3]
$aResult[0] += 1
Next
If Not $aResult[0] Then Return SetError(12, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_DragQueryPoint($hDrop)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('shell32.dll', 'bool', 'DragQueryPoint', 'handle', $hDrop, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_EndDeferWindowPos($hInfo)
Local $aRet = DllCall('user32.dll', 'bool', 'EndDeferWindowPos', 'handle', $hInfo)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumChildWindows($hWnd, $bVisible = True)
If Not _WinAPI_GetWindow($hWnd, 5) Then Return SetError(2, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
DllCall('user32.dll', 'bool', 'EnumChildWindows', 'hwnd', $hWnd, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $bVisible)
If @error Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumDesktops($hStation)
If StringCompare(_WinAPI_GetUserObjectInformation($hStation, 3), 'WindowStation') Then Return SetError(1, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'bool', 'ptr;lparam')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDesktopsW', 'handle', $hStation, 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumDesktopWindows($hDesktop, $bVisible = True)
If StringCompare(_WinAPI_GetUserObjectInformation($hDesktop, 3), 'Desktop') Then Return SetError(1, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDesktopWindows', 'handle', $hDesktop, 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', $bVisible)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumPageFiles()
Local $aInfo = _WinAPI_GetSystemInfo()
Local $hEnumProc = DllCallbackRegister('__EnumPageFilesProc', 'bool', 'lparam;ptr;ptr')
Dim $__g_vEnum[101][4] = [[0]]
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumPageFilesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $aInfo[1])
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumRawInputDevices()
Local Const $tagRAWINPUTDEVICELIST = 'struct;handle hDevice;dword Type;endstruct'
Local $tRIDL, $iLength = DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICELIST))
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputDeviceList', 'ptr', 0, 'uint*', 0, 'uint', $iLength)
If @error Then Return SetError(@error + 10, @extended, 0)
If ($aRet[0] = 4294967295) Or (Not $aRet[2]) Then Return SetError(10, -1, 0)
Local $tData = DllStructCreate('byte[' & ($aRet[2] * $iLength) & ']')
Local $pData = DllStructGetPtr($tData)
If @error Then Return SetError(@error + 20, 0, 0)
$aRet = DllCall('user32.dll', 'uint', 'GetRawInputDeviceList', 'ptr', $pData, 'uint*', $aRet[2], 'uint', $iLength)
If ($aRet[0] = 4294967295) Or (Not $aRet[0]) Then Return SetError(1, -1, 0)
Local $aResult[$aRet[2] + 1][2] = [[$aRet[2]]]
For $i = 1 To $aRet[2]
$tRIDL = DllStructCreate('ptr;dword', $pData + $iLength * ($i - 1))
For $j = 0 To 1
$aResult[$i][$j] = DllStructGetData($tRIDL, $j + 1)
Next
Next
Return $aResult
EndFunc
Func _WinAPI_EnumWindowStations()
Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'bool', 'ptr;lparam')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumWindowStationsW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EqualMemory($pSource1, $pSource2, $iLength)
If _WinAPI_IsBadReadPtr($pSource1, $iLength) Then Return SetError(11, @extended, 0)
If _WinAPI_IsBadReadPtr($pSource2, $iLength) Then Return SetError(12, @extended, 0)
Local $aRet = DllCall('ntdll.dll', 'ulong_ptr', 'RtlCompareMemory', 'struct*', $pSource1, 'struct*', $pSource2, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return Number($aRet[0] = $iLength)
EndFunc
Func _WinAPI_FillMemory($pMemory, $iLength, $iValue = 0)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlFillMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength, 'byte', $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_FreeMemory($pMemory)
If Not __HeapFree($pMemory, 1) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_GetActiveWindow()
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetActiveWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetClassInfoEx($sClass, $hInstance = 0)
Local $sTypeOfClass = 'ptr'
If IsString($sClass) Then
$sTypeOfClass = 'wstr'
EndIf
Local $tWNDCLASSEX = DllStructCreate($tagWNDCLASSEX)
Local $aRet = DllCall('user32.dll', 'bool', 'GetClassInfoExW', 'handle', $hInstance, $sTypeOfClass, $sClass,  'struct*', $tWNDCLASSEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWNDCLASSEX
EndFunc
Func _WinAPI_GetClassLongEx($hWnd, $iIndex)
Local $aRet
If @AutoItX64 Then
$aRet = DllCall('user32.dll', 'ulong_ptr', 'GetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex)
Else
$aRet = DllCall('user32.dll', 'dword', 'GetClassLongW', 'hwnd', $hWnd, 'int', $iIndex)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetClipboardSequenceNumber()
Local $aRet = DllCall('user32.dll', 'dword', 'GetClipboardSequenceNumber')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCurrentHwProfile()
Local $tagHW_PROFILE_INFO = 'dword DockInfo;wchar szHwProfileGuid[39];wchar szHwProfileName[80]'
Local $tHWPI = DllStructCreate($tagHW_PROFILE_INFO)
Local $aRet = DllCall('advapi32.dll', 'bool', 'GetCurrentHwProfileW', 'struct*', $tHWPI)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[3]
For $i = 0 To 2
$aResult[$i] = DllStructGetData($tHWPI, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetDefaultPrinter()
Local $aRet = DllCall('winspool.drv', 'bool', 'GetDefaultPrinterW', 'wstr', '', 'dword*', 2048)
If @error Then Return SetError(@error, @extended, '')
If Not $aRet[0] Then Return SetError(10, _WinAPI_GetLastError(), '')
Return $aRet[1]
EndFunc
Func _WinAPI_GetDllDirectory()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetDllDirectoryW', 'dword', 4096, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetEffectiveClientRect($hWnd, $aCtrl, $iStart = 0, $iEnd = -1)
If Not IsArray($aCtrl) Then
Local $iCtrl = $aCtrl
Dim $aCtrl[1] = [$iCtrl]
$iStart = 0
$iEnd = 0
EndIf
If __CheckErrorArrayBounds($aCtrl, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tCtrl = DllStructCreate('uint64[' & ($iCount + 2) & ']')
$iCount = 2
For $i = $iStart To $iEnd
If IsHWnd($aCtrl[$i]) Then
$aCtrl[$i] = _WinAPI_GetDlgCtrlID($aCtrl[$i])
EndIf
DllStructSetData($tCtrl, 1, _WinAPI_MakeQWord(1, $aCtrl[$i]), $iCount)
$iCount += 1
Next
Local $tRECT = DllStructCreate($tagRECT)
DllCall('comctl32.dll', 'none', 'GetEffectiveClientRect', 'hwnd', $hWnd, 'struct*', $tRECT, 'struct*', $tCtrl)
If @error Then Return SetError(@error, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetGUIThreadInfo($iThreadId)
Local Const $tagGUITHREADINFO = 'dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;long rcCaret[4]'
Local $tGTI = DllStructCreate($tagGUITHREADINFO)
DllStructSetData($tGTI, 1, DllStructGetSize($tGTI))
Local $aRet = DllCall('user32.dll', 'bool', 'GetGUIThreadInfo', 'dword', $iThreadId, 'struct*', $tGTI)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[11]
For $i = 0 To 6
$aResult[$i] = DllStructGetData($tGTI, $i + 2)
Next
For $i = 1 To 4
$aResult[6 + $i] = DllStructGetData($tGTI, 6 + 2, $i)
Next
For $i = 9 To 10
$aResult[$i] -= $aResult[$i - 2]
Next
Return $aResult
EndFunc
Func _WinAPI_GetHandleInformation($hObject)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetHandleInformation', 'handle', $hObject, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetIdleTime()
Local $tLASTINPUTINFO = DllStructCreate('uint;dword')
DllStructSetData($tLASTINPUTINFO, 1, DllStructGetSize($tLASTINPUTINFO))
Local $aRet = DllCall('user32.dll', 'bool', 'GetLastInputInfo', 'struct*', $tLASTINPUTINFO)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return _WinAPI_GetTickCount() - DllStructGetData($tLASTINPUTINFO, 2)
EndFunc
Func _WinAPI_GetKeyboardLayout($hWnd)
Local $aRet = DllCall('user32.dll', 'dword', 'GetWindowThreadProcessId', 'hwnd', $hWnd, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
$aRet = DllCall('user32.dll', 'handle', 'GetKeyboardLayout', 'dword', $aRet[0])
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetKeyboardLayoutList()
Local $aRet = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
Local $tData = DllStructCreate('handle[' & $aRet[0] & ']')
$aRet = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', $aRet[0], 'struct*', $tData)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aList[$aRet[0] + 1] = [$aRet[0]]
For $i = 1 To $aList[0]
$aList[$i] = DllStructGetData($tData, 1, $i)
Next
Return $aList
EndFunc
Func _WinAPI_GetKeyboardState()
Local $tData = DllStructCreate('byte[256]')
Local $aRet = DllCall('user32.dll', 'bool', 'GetKeyboardState', 'struct*', $tData)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tData
EndFunc
Func _WinAPI_GetKeyboardType($iType)
Local $aRet = DllCall('user32.dll', 'int', 'GetKeyboardType', 'int', $iType)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetKeyNameText($lParam)
Local $aRet = DllCall('user32.dll', 'int', 'GetKeyNameTextW', 'long', $lParam, 'wstr', '', 'int', 128)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetKeyState($vKey)
Local $aRet = DllCall('user32.dll', 'short', 'GetKeyState', 'int', $vKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetLastActivePopup($hWnd)
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetLastActivePopup', 'hwnd', $hWnd)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
If $aRet[0] = $hWnd Then Return SetError(1, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetMemorySize($pMemory)
Local $iResult = __HeapSize($pMemory, 1)
If @error Then Return SetError(@error, @extended, 0)
Return $iResult
EndFunc
Func _WinAPI_GetMessageExtraInfo()
Local $aRet = DllCall('user32.dll', 'lparam', 'GetMessageExtraInfo')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetModuleHandleEx($sModule, $iFlags = 0)
Local $sTypeOfModule = 'ptr'
If IsString($sModule) Then
If StringStripWS($sModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfModule = 'wstr'
Else
$sModule = 0
EndIf
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetModuleHandleExW', 'dword', $iFlags, $sTypeOfModule, $sModule, 'ptr*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_GetMonitorInfo($hMonitor)
Local $tMIEX = DllStructCreate('dword;long[4];long[4];dword;wchar[32]')
DllStructSetData($tMIEX, 1, DllStructGetSize($tMIEX))
Local $aRet = DllCall('user32.dll', 'bool', 'GetMonitorInfoW', 'handle', $hMonitor, 'struct*', $tMIEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[4]
For $i = 0 To 1
$aResult[$i] = DllStructCreate($tagRECT)
_WinAPI_MoveMemory($aResult[$i], DllStructGetPtr($tMIEX, $i + 2), 16)
Next
$aResult[3] = DllStructGetData($tMIEX, 5)
Switch DllStructGetData($tMIEX, 4)
Case 1
$aResult[2] = 1
Case Else
$aResult[2] = 0
EndSwitch
Return $aResult
EndFunc
Func _WinAPI_GetMUILanguage()
Local $aRet = DllCall('comctl32.dll', 'word', 'GetMUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetObjectInfoByHandle($hObject)
Local $tagPUBLIC_OBJECT_BASIC_INFORMATION = 'ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]'
Local $tPOBI = DllStructCreate($tagPUBLIC_OBJECT_BASIC_INFORMATION)
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryObject', 'handle', $hObject, 'uint', 0, 'struct*', $tPOBI,  'ulong', DllStructGetSize($tPOBI), 'ptr', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $aResult[4]
For $i = 0 To 3
$aResult[$i] = DllStructGetData($tPOBI, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetObjectNameByHandle($hObject)
Local $tagUNICODE_STRING = 'struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct'
Local $tagPUBLIC_OBJECT_TYPE_INFORMATION = 'struct;' & $tagUNICODE_STRING & ';ulong Reserved[22];endstruct'
Local $tPOTI = DllStructCreate($tagPUBLIC_OBJECT_TYPE_INFORMATION & ';byte[32]')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryObject', 'handle', $hObject, 'uint', 2, 'struct*', $tPOTI,  'ulong', DllStructGetSize($tPOTI), 'ulong*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $pData = DllStructGetData($tPOTI, 3)
If Not $pData Then Return SetError(11, 0, '')
Return _WinAPI_GetString($pData)
EndFunc
Func _WinAPI_GetPerformanceInfo()
Local $tPI = DllStructCreate('dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword')
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetPerformanceInfo', 'struct*', $tPI, 'dword', DllStructGetSize($tPI))
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[13]
For $i = 0 To 12
$aResult[$i] = DllStructGetData($tPI, $i + 2)
Next
For $i = 0 To 8
$aResult[$i] *= $aResult[9]
Next
Return $aResult
EndFunc
Func _WinAPI_GetPhysicallyInstalledSystemMemory()
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetPhysicallyInstalledSystemMemory', 'uint64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_GetProcessShutdownParameters()
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessShutdownParameters', 'dword*', 0, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended(Number(Not $aRet[2]), $aRet[1])
EndFunc
Func _WinAPI_GetProcessWindowStation()
Local $aRet = DllCall('user32.dll', 'handle', 'GetProcessWindowStation')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetPwrCapabilities()
If Not __DLL('powrprof.dll') Then Return SetError(103, 0, 0)
Local $tSPC = DllStructCreate('byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]')
Local $aRet = DllCall('powrprof.dll', 'boolean', 'GetPwrCapabilities', 'struct*', $tSPC)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[25]
For $i = 0 To 17
$aResult[$i] = DllStructGetData($tSPC, 1, $i + 1)
Next
$aResult[18] = DllStructGetData($tSPC, 3)
For $i = 19 To 20
$aResult[$i] = DllStructGetData($tSPC, 5, $i - 18)
Next
For $i = 21 To 24
$aResult[$i] = DllStructGetData($tSPC, 7, $i - 20)
Next
Return $aResult
EndFunc
Func _WinAPI_GetRawInputBuffer($pBuffer, $iLength)
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputBuffer', 'struct*', $pBuffer, 'uint*', $iLength,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If ($aRet[0] = 4294967295) Or (Not $aRet[1]) Then Return SetError(10, -1, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetRawInputBufferLength()
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputBuffer', 'ptr', 0, 'uint*', 0,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return $aRet[2] * 8
EndFunc
Func _WinAPI_GetRawInputData($hRawInput, $pBuffer, $iLength, $iFlag)
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputData', 'handle', $hRawInput, 'uint', $iFlag, 'struct*', $pBuffer,  'uint*', $iLength, 'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return __Iif($aRet[3], $aRet[0], $aRet[4])
EndFunc
Func _WinAPI_GetRawInputDeviceInfo($hDevice, $pBuffer, $iLength, $iFlag)
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputDeviceInfoW', 'handle', $hDevice, 'uint', $iFlag, 'struct*', $pBuffer,  'uint*', $iLength)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return __Iif($aRet[3], $aRet[0], $aRet[4])
EndFunc
Func _WinAPI_GetRegisteredRawInputDevices($pBuffer, $iLength)
Local $iLengthRAW = DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICE))
Local $aRet = DllCall('user32.dll', 'uint', 'GetRegisteredRawInputDevices', 'struct*', $pBuffer,  'uint*', Floor($iLength / $iLengthRAW), 'uint', $iLengthRAW)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then
Local $iLastError = _WinAPI_GetLastError()
If $iLastError = 122 Then Return SetExtended($iLastError, $aRet[2] * $iLengthRAW)
Return SetError(10, $iLastError, 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_GetShellWindow()
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetShellWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetStartupInfo()
Local $tSI = DllStructCreate($tagSTARTUPINFO)
DllCall('kernel32.dll', 'none', 'GetStartupInfoW', 'struct*', $tSI)
If @error Then Return SetError(@error, @extended, 0)
Return $tSI
EndFunc
Func _WinAPI_GetSystemDEPPolicy()
Local $aRet = DllCall('kernel32.dll', 'uint', 'GetSystemDEPPolicy')
If @error Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetSystemInfo()
Local $sProc
If _WinAPI_IsWow64Process() Then
$sProc = 'GetNativeSystemInfo'
Else
$sProc = 'GetSystemInfo'
EndIf
Local Const $tagSYSTEMINFO = 'struct;word ProcessorArchitecture;word Reserved; endstruct;dword PageSize;' &  'ptr MinimumApplicationAddress;ptr MaximumApplicationAddress;dword_ptr ActiveProcessorMask;dword NumberOfProcessors;' &  'dword ProcessorType;dword AllocationGranularity;word ProcessorLevel;word ProcessorRevision'
Local $tSystemInfo = DllStructCreate($tagSYSTEMINFO)
DllCall('kernel32.dll', 'none', $sProc, 'struct*', $tSystemInfo)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult[10]
$aResult[0] = DllStructGetData($tSystemInfo, 1)
For $i = 1 To 9
$aResult[$i] = DllStructGetData($tSystemInfo, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_GetSystemPowerStatus()
Local $tagSYSTEM_POWER_STATUS = 'byte ACLineStatus;byte BatteryFlag;byte BatteryLifePercent;byte Reserved1;' &  'int BatteryLifeTime;int BatteryFullLifeTime'
Local $tSYSTEM_POWER_STATUS = DllStructCreate($tagSYSTEM_POWER_STATUS)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetSystemPowerStatus', 'struct*', $tSYSTEM_POWER_STATUS)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[5]
$aResult[0] = DllStructGetData($tSYSTEM_POWER_STATUS, 1)
$aResult[1] = DllStructGetData($tSYSTEM_POWER_STATUS, 2)
$aResult[2] = DllStructGetData($tSYSTEM_POWER_STATUS, 3)
$aResult[3] = DllStructGetData($tSYSTEM_POWER_STATUS, 5)
$aResult[4] = DllStructGetData($tSYSTEM_POWER_STATUS, 6)
Return $aResult
EndFunc
Func _WinAPI_GetSystemTimes()
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetSystemTimes', 'uint64*', 0, 'uint64*', 0, 'uint64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[3]
For $i = 0 To 2
$aResult[$i] = $aRet[$i + 1]
Next
Return $aResult
EndFunc
Func _WinAPI_GetSystemWow64Directory()
Local $aRet = DllCall('kernel32.dll', 'uint', 'GetSystemWow64DirectoryW', 'wstr', '', 'uint', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, _WinAPI_GetLastError(), '')
Return $aRet[1]
EndFunc
Func _WinAPI_GetTickCount()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetTickCount')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTickCount64()
Local $aRet = DllCall('kernel32.dll', 'uint64', 'GetTickCount64')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTopWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetTopWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetUserObjectInformation($hObject, $iIndex)
Local $aRet = DllCall('user32.dll', 'bool', 'GetUserObjectInformationW', 'handle', $hObject, 'int', $iIndex, 'ptr', 0,  'dword', 0, 'dword*', 0)
If @error Or Not $aRet[5] Then Return SetError(@error + 10, @extended, 0)
Local $tData
Switch $iIndex
Case 1
$tData = DllStructCreate($tagUSEROBJECTFLAGS)
Case 5, 6
$tData = DllStructCreate('uint')
Case 2, 3
$tData = DllStructCreate('wchar[' & $aRet[5] & ']')
Case 4
$tData = DllStructCreate('byte[' & $aRet[5] & ']')
Case Else
Return SetError(20, 0, 0)
EndSwitch
$aRet = DllCall('user32.dll', 'bool', 'GetUserObjectInformationW', 'handle', $hObject, 'int', $iIndex, 'struct*', $tData,  'dword', DllStructGetSize($tData), 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 30, @extended, 0)
Switch $iIndex
Case 1, 4
Return $tData
Case Else
Return DllStructGetData($tData, 1)
EndSwitch
EndFunc
Func _WinAPI_GetVersion()
Return BitAND(BitShift($__WINVER, 8), 0xFF) & '.' & BitAND($__WINVER, 0xFF)
EndFunc
Func _WinAPI_GetVersionEx()
Local $tOSVERSIONINFOEX = DllStructCreate($tagOSVERSIONINFOEX)
DllStructSetData($tOSVERSIONINFOEX, 'OSVersionInfoSize', DllStructGetSize($tOSVERSIONINFOEX))
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVERSIONINFOEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tOSVERSIONINFOEX
EndFunc
Func _WinAPI_GetWindowDisplayAffinity($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'GetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetWindowInfo($hWnd)
Local $tWINDOWINFO = DllStructCreate($tagWINDOWINFO)
DllStructSetData($tWINDOWINFO, 'Size', DllStructGetSize($tWINDOWINFO))
Local $aRet = DllCall('user32.dll', 'bool', 'GetWindowInfo', 'hwnd', $hWnd, 'struct*', $tWINDOWINFO)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWINDOWINFO
EndFunc
Func _WinAPI_GetWorkArea()
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'int', 'SystemParametersInfo', 'uint', 48, 'uint', 0, 'struct*', $tRECT, 'uint', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_InitMUILanguage($iLanguage)
DllCall('comctl32.dll', 'none', 'InitMUILanguage', 'word', $iLanguage)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_IsBadCodePtr($pAddress)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadCodePtr', 'struct*', $pAddress)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadStringPtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadStringPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsChild($hWnd, $hWndParent)
Local $aRet = DllCall('user32.dll', 'bool', 'IsChild', 'hwnd', $hWndParent, 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsHungAppWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsHungAppWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsIconic($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsIconic', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsLoadKBLayout($iLanguage)
Local $aLayout = _WinAPI_GetKeyboardLayoutList()
If @error Then Return SetError(@error, @extended, False)
For $i = 1 To $aLayout[0]
If $aLayout[$i] = $iLanguage Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsMemory($pMemory)
Local $bResult = __HeapValidate($pMemory)
Return SetError(@error, @extended, $bResult)
EndFunc
Func _WinAPI_IsProcessorFeaturePresent($iFeature)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsProcessorFeaturePresent', 'dword', $iFeature)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsWindowEnabled($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsWindowEnabled', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsWindowUnicode($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsWindowUnicode', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsZoomed($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsZoomed', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Keybd_Event($vKey, $iFlags, $iScanCode = 0, $iExtraInfo = 0)
DllCall('user32.dll', 'none', 'keybd_event', 'byte', $vKey, 'byte', $iScanCode, 'dword', $iFlags, 'ulong_ptr', $iExtraInfo)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_KillTimer($hWnd, $iTimerID)
Local $aRet = DllCall('user32.dll', 'bool', 'KillTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadIconMetric($hInstance, $sName, $iMetric)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('comctl32.dll', 'long', 'LoadIconMetric', 'handle', $hInstance, $sTypeOfName, $sName, 'int', $iMetric, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[4]
EndFunc
Func _WinAPI_LoadIconWithScaleDown($hInstance, $sName, $iWidth, $iHeight)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('comctl32.dll', 'long', 'LoadIconWithScaleDown', 'handle', $hInstance, $sTypeOfName, $sName,  'int', $iWidth, 'int', $iHeight, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[5]
EndFunc
Func _WinAPI_LoadKeyboardLayout($iLanguage, $iFlag = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'LoadKeyboardLayoutW', 'wstr', Hex($iLanguage, 8), 'uint', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LockWorkStation()
Local $aRet = DllCall('user32.dll', 'bool', 'LockWorkStation')
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MapVirtualKey($iCode, $iType, $hLocale = 0)
Local $aRet = DllCall('user32.dll', 'INT', 'MapVirtualKeyExW', 'uint', $iCode, 'uint', $iType, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MirrorIcon($hIcon, $bDelete = False)
If Not $bDelete Then
$hIcon = _WinAPI_CopyIcon($hIcon)
EndIf
Local $aRet = DllCall('comctl32.dll', 'int', 414, 'ptr', 0, 'ptr*', $hIcon)
If @error Or Not $aRet[0] Then
Local $iError = @error + 10
If $hIcon And Not $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return SetError($iError, 0, 0)
EndIf
Return $aRet[2]
EndFunc
Func _WinAPI_OpenDesktop($sName, $iAccess = 0, $iFlags = 0, $bInherit = False)
Local $aRet = DllCall('user32.dll', 'handle', 'OpenDesktopW', 'wstr', $sName, 'dword', $iFlags, 'bool', $bInherit,  'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenIcon($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'OpenIcon', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenInputDesktop($iAccess = 0, $iFlags = 0, $bInherit = False)
Local $aRet = DllCall('user32.dll', 'handle', 'OpenInputDesktop', 'dword', $iFlags, 'bool', $bInherit, 'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenWindowStation($sName, $iAccess = 0, $bInherit = False)
Local $aRet = DllCall('user32.dll', 'handle', 'OpenWindowStationW', 'wstr', $sName, 'bool', $bInherit, 'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_QueryPerformanceCounter()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceCounter', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_QueryPerformanceFrequency()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceFrequency', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_RegisterClass($tWNDCLASS)
Local $aRet = DllCall('user32.dll', 'word', 'RegisterClassW', 'struct*', $tWNDCLASS)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterClassEx($tWNDCLASSEX)
Local $aRet = DllCall('user32.dll', 'word', 'RegisterClassExW', 'struct*', $tWNDCLASSEX)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterHotKey($hWnd, $iID, $iModifiers, $vKey)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterHotKey', 'hwnd', $hWnd, 'int', $iID, 'uint', $iModifiers, 'uint', $vKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterPowerSettingNotification($hWnd, $sGUID)
Local $tGUID = DllStructCreate($tagGUID)
Local $aRet = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aRet[0] Then Return SetError(@error + 20, @extended, 0)
$aRet = DllCall('user32.dll', 'handle', 'RegisterPowerSettingNotification', 'handle', $hWnd, 'struct*', $tGUID, 'dword', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterRawInputDevices($paDevice, $iCount = 1)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterRawInputDevices', 'struct*', $paDevice, 'uint', $iCount,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICE)) * $iCount)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RemoveClipboardFormatListener($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'RemoveClipboardFormatListener', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SendMessageTimeout($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iTimeout = 1000, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'lresult', 'SendMessageTimeoutW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam, 'uint', $iFlags, 'uint', $iTimeout, 'dword_ptr*', 0)
If @error Then Return SetError(@error, @extended, -1)
If Not $aRet[0] Then Return SetError(10, _WinAPI_GetLastError(), -1)
Return $aRet[7]
EndFunc
Func _WinAPI_SetActiveWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'int', 'SetActiveWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetClassLongEx($hWnd, $iIndex, $iNewLong)
Local $aRet
If @AutoItX64 Then
$aRet = DllCall('user32.dll', 'ulong_ptr', 'SetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex, 'long_ptr', $iNewLong)
Else
$aRet = DllCall('user32.dll', 'dword', 'SetClassLongW', 'hwnd', $hWnd, 'int', $iIndex, 'long', $iNewLong)
EndIf
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDllDirectory($sDirPath = Default)
Local $sTypeOfPath = 'wstr'
If $sDirPath = Default Then
$sTypeOfPath = 'ptr'
$sDirPath = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetDllDirectoryW', $sTypeOfPath, $sDirPath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetForegroundWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'SetForegroundWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetKeyboardLayout($hWnd, $iLanguage, $iFlags = 0)
If Not _WinAPI_IsWindow($hWnd) Then Return SetError(@error + 10, @extended, 0)
Local $hLocale = 0
If $iLanguage Then
$hLocale = _WinAPI_LoadKeyboardLayout($iLanguage)
If Not $hLocale Then Return SetError(10, 0, 0)
EndIf
Local Const $WM_INPUTLANGCHANGEREQUEST = 0x0050
DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $hWnd, 'uint', $WM_INPUTLANGCHANGEREQUEST, 'uint', $iFlags, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_SetKeyboardState(ByRef $tState)
Local $aRet = DllCall('user32.dll', 'int', 'SetKeyboardState', 'struct*', $tState)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetMessageExtraInfo($lParam)
Local $aRet = DllCall('user32.dll', 'lparam', 'SetMessageExtraInfo', 'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetProcessShutdownParameters($iLevel, $bDialog = False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetProcessShutdownParameters', 'dword', $iLevel, 'dword', Not $bDialog)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetProcessWindowStation($hStation)
Local $aRet = DllCall('user32.dll', 'bool', 'SetProcessWindowStation', 'handle', $hStation)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTimer($hWnd, $iTimerID, $iElapse, $pTimerFunc)
Local $aRet = DllCall('user32.dll', 'uint_ptr', 'SetTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID, 'uint', $iElapse,  'ptr', $pTimerFunc)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetUserObjectInformation($hObject, $iIndex, ByRef $tData)
If $iIndex <> 1 Then Return SetError(10, 0, False)
Local $aRet = DllCall('user32.dll', 'bool', 'SetUserObjectInformationW', 'handle', $hObject, 'int', 1, 'struct*', $tData,  'dword', DllStructGetSize($tData))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowDisplayAffinity($hWnd, $iAffinity)
Local $aRet = DllCall('user32.dll', 'bool', 'SetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword', $iAffinity)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWinEventHook($iEventMin, $iEventMax, $pEventProc, $iPID = 0, $iThreadId = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'SetWinEventHook', 'uint', $iEventMin, 'uint', $iEventMax, 'ptr', 0,  'ptr', $pEventProc, 'dword', $iPID, 'dword', $iThreadId, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ShowOwnedPopups($hWnd, $bShow)
Local $aRet = DllCall('user32.dll', 'bool', 'ShowOwnedPopups', 'hwnd', $hWnd, 'bool', $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonCreate($hWnd, $sText)
Local $aRet = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonCreate', 'hwnd', $hWnd, 'wstr', $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonDestroy($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonDestroy', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonQuery($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonQuery', 'hwnd', $hWnd, 'wstr', '', 'dword*', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_SwitchDesktop($hDesktop)
Local $aRet = DllCall('user32.dll', 'bool', 'SwitchDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SwitchToThisWindow($hWnd, $bAltTab = False)
DllCall('user32.dll', 'none', 'SwitchToThisWindow', 'hwnd', $hWnd, 'bool', $bAltTab)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_TileWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aWnds, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tWnds = DllStructCreate('hwnd[' & $iCount & ']')
$iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tWnds, 1, $aWnds[$i], $iCount)
$iCount += 1
Next
Local $aRet = DllCall('user32.dll', 'word', 'TileWindows', 'hwnd', $hParent, 'uint', $iFlags, 'struct*', $tRECT,  'uint', $iCount - 1, 'struct*', $tWnds)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TrackMouseEvent($hWnd, $iFlags, $iTime = -1)
Local $tTME = DllStructCreate('dword;dword;hwnd;dword')
DllStructSetData($tTME, 1, DllStructGetSize($tTME))
DllStructSetData($tTME, 2, $iFlags)
DllStructSetData($tTME, 3, $hWnd)
DllStructSetData($tTME, 4, $iTime)
Local $aRet = DllCall('user32.dll', 'bool', 'TrackMouseEvent', 'struct*', $tTME)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnhookWinEvent($hEventHook)
Local $aRet = DllCall('user32.dll', 'bool', 'UnhookWinEvent', 'handle', $hEventHook)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UnloadKeyboardLayout($hLocale)
Local $aRet = DllCall('user32.dll', 'bool', 'UnloadKeyboardLayout', 'handle', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnregisterClass($sClass, $hInstance = 0)
Local $sTypeOfClass = 'ptr'
If IsString($sClass) Then
$sTypeOfClass = 'wstr'
EndIf
Local $aRet = DllCall('user32.dll', 'bool', 'UnregisterClassW', $sTypeOfClass, $sClass, 'handle', $hInstance)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UnregisterHotKey($hWnd, $iID)
Local $aRet = DllCall('user32.dll', 'bool', 'UnregisterHotKey', 'hwnd', $hWnd, 'int', $iID)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnregisterPowerSettingNotification($hNotify)
Local $aRet = DllCall('user32.dll', 'bool', 'UnregisterPowerSettingNotification', 'handle', $hNotify)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UpdateLayeredWindowEx($hWnd, $iX, $iY, $hBitmap, $iOpacity = 255, $bDelete = False)
Local $aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', $hWnd)
Local $hDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBitmap)
Local $hDestSv = $aRet[0]
Local $tPOINT
If ($iX = -1) And ($iY = -1) Then
$tPOINT = DllStructCreate('int;int')
Else
$tPOINT = DllStructCreate('int;int;int;int')
DllStructSetData($tPOINT, 3, $iX)
DllStructSetData($tPOINT, 4, $iY)
EndIf
DllStructSetData($tPOINT, 1, 0)
DllStructSetData($tPOINT, 2, 0)
Local $tBLENDFUNCTION = DllStructCreate($tagBLENDFUNCTION)
DllStructSetData($tBLENDFUNCTION, 1, 0)
DllStructSetData($tBLENDFUNCTION, 2, 0)
DllStructSetData($tBLENDFUNCTION, 3, $iOpacity)
DllStructSetData($tBLENDFUNCTION, 4, 1)
Local $tSIZE = _WinAPI_GetBitmapDimension($hBitmap)
$aRet = DllCall('user32.dll', 'bool', 'UpdateLayeredWindow', 'hwnd', $hWnd, 'handle', $hDC, 'ptr', DllStructGetPtr($tPOINT, 3),  'struct*', $tSIZE, 'handle', $hDestDC, 'struct*', $tPOINT, 'dword', 0, 'struct*', $tBLENDFUNCTION, 'dword', 0x02)
Local $iError = @error
DllCall('user32.dll', 'bool', 'ReleaseDC', 'hwnd', $hWnd, 'handle', $hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
If $iError Then Return SetError($iError, 0, False)
If $bDelete Then
_WinAPI_DeleteObject($hBitmap)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_UpdateLayeredWindowIndirect($hWnd, $tULWINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'UpdateLayeredWindowIndirect', 'hwnd', $hWnd, 'struct*', $tULWINFO)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Embedded DLL Functions
#EndRegion Embedded DLL Functions
#Region Internal Functions
Func __EnumDefaultProc($pData, $lParam)
#forceref $lParam
Local $iLength = _WinAPI_StrLen($pData)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $pData), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = ''
EndIf
Return 1
EndFunc
Func __EnumPageFilesProc($iSize, $pInfo, $pFile)
Local $tEPFI = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr', $pInfo)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pFile) + 1) & ']', $pFile), 1)
For $i = 1 To 3
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData($tEPFI, $i + 2) * $iSize
Next
Return 1
EndFunc
#EndRegion Internal Functions
Func FClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $debugClick = 1 Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ORANGE, "Verdana", "7.5", 0)
EndIf
If $AndroidAdbClick = True Then
AndroidClick($x, $y, $times, $speed)
EndIf
If $AndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
$x = $x  + $BSrpos[0]
$y = $y  + $BSrpos[1]
If $times <> 1 Then
For $i = 0 To ($times - 1)
If isProblemAffectBeforeClick($i) Then
If $debugClick = 1 Then Setlog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_RED, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isProblemAffectBeforeClick() Then
If $debugClick = 1 Then Setlog("VOIDED Click " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_RED, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func _ControlClick($x, $y)
Local $hWin = ($AndroidEmbedded = False ? $HWnD : $AndroidEmbeddedCtrlTarget[1])
Local $WM_LBUTTONDOWN = 0x0201, $WM_LBUTTONUP = 0x0202
Local $lParam =  BitOR(Int($y) * 0x10000, BitAND(Int($x), 0xFFFF))
_WinAPI_PostMessage($hWin, $WM_LBUTTONDOWN, 0x0001, $lParam)
_WinAPI_PostMessage($hWin, $WM_LBUTTONUP, 0x0000, $lParam)
_Sleep(10)
EndFunc
Func isProblemAffectBeforeClick($iCount = 0)
If NeedCaptureRegion($iCount) = True Then Return isProblemAffect(True)
Return False
EndFunc
Func ClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
Click($point[0], $point[1], $howMuch, $speed, $debugtxt)
EndFunc
Func FPureClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $debugClick = 1 Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("PureClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ORANGE, "Verdana", "7.5", 0)
EndIf
If $AndroidAdbClick = True Then
AndroidClick($x, $y, $times, $speed, False)
EndIf
If $AndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
$x = $x  + $BSrpos[0]
$y = $y  + $BSrpos[1]
If $times <> 1 Then
For $i = 0 To ($times - 1)
MoveMouseOutBS()
_ControlClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
MoveMouseOutBS()
_ControlClick($x, $y)
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func PureClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
PureClick($point[0], $point[1], $howMuch, $speed, $debugtxt)
EndFunc
Func FGemClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $debugClick = 1 Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ORANGE, "Verdana", "7.5", 0)
EndIf
If $AndroidAdbClick = True Then
If isGemOpen(True) Then
Return False
EndIf
AndroidClick($x, $y, $times, $speed)
EndIf
If $AndroidAdbClick = True Then
Return
EndIf
Local $SuspendMode = ResumeAndroid()
$x = $x  + $BSrpos[0]
$y = $y  + $BSrpos[1]
Local $i
If $times <> 1 Then
For $i = 0 To ($times - 1)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick($i) Then
If $debugClick = 1 Then Setlog("VOIDED GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_RED, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If _Sleep($speed, False) Then ExitLoop
Next
Else
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
If isProblemAffectBeforeClick() Then
If $debugClick = 1 Then Setlog("VOIDED GemClick " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_RED, "Verdana", "7.5", 0)
checkMainScreen(False)
SuspendAndroid($SuspendMode)
Return
EndIf
MoveMouseOutBS()
_ControlClick($x, $y)
If isGemOpen(True) Then
SuspendAndroid($SuspendMode)
Return False
EndIf
EndIf
SuspendAndroid($SuspendMode)
EndFunc
Func GemClickP($point, $howMuch = 1, $speed = 0, $debugtxt = "")
Return GemClick($point[0], $point[1], $howMuch, $speed, $debugtxt = "")
EndFunc
Func AttackClick($x, $y, $times = 1, $speed = 0, $afterDelay = 0, $debugtxt = "")
Local $timer = TimerInit()
Local $result = PureClick($x, $y, $times, $speed, $debugtxt)
Local $delay = $times * $speed + $afterDelay - TimerDiff($timer)
If IsKeepClicksActive() = False And $delay > 0 Then _Sleep($delay, False)
Return $result
EndFunc
Func _DecodeDebug($message)
Local $separator = " | "
Switch $message
Case "#0112", "#0115", "#0140", "#0141", "#0142", "#0143", "#0199", "#0328", "#0201", "#0204", "#0205", "#0206", "#0327", "#0207", "#0208", "#0209", "#0210", "#0211"
Return $separator & "Away"
Case "#0214", "#0215", "#0216", "#0217", "#0218", "#0219", "#0220", "#0221", "#0235", "#0242", "#0268", "#0291", "#0292", "#0295", "#0298", "#0300", "#0301", "#0302"
Return $separator & "Away"
Case "#0303", "#0306", "#0308", "#0309", "#0310", "#0311", "#0312", "#0319", "#0333", "#0257", "#0139", "#0125", "#0251", "#0335", "#0313", "#0314", "#0332", "#0329"
Return $separator & "Away"
Case "#0121", "#0124", "#0133", "#0157", "#0161", "#0165", "#0166", "#0167", "#0170", "#0171", "#0176", "#0224", "#0234", "#0265", "#0346", "#0348", "#0350", "#0351"
Return $separator & "Away"
Case "#0352", "#0353", "#0354", "#0355", "#0356", "#0357", "#0358", "#0359", "#0360", "#0361", "#0362", "#0363", "#0364", "#0365", "#0366", "#0367", "#0368", "#0369"
Return $separator & "Away"
Case "#0370", "#0371", "#0373", "#0374", "#0375", "#0376", "#0377", "#0378", "#0379", "#0380", "#0381", "#0382", "#0383", "#0384", "#0385", "#0386", "#0387", "#0388"
Return $separator & "Away"
Case "#0389", "#0390", "#0391", "#0392", "#0393", "#0394", "#0395", "#0501", "#0502", "#0503", "#0504", "#0467", "#0505", "#0931", "#0932", "#0933"
Return $separator & "Away"
Case "#0001"
Return $separator & "AtkTH - Select Barbarian"
Case "#0002", "#0006"
Return $separator & "AtkTH - Barbarian Bottom Left"
Case "#0003", "#0007"
Return $separator & "AtkTH - Barbarian Bottom Right"
Case "#0004", "#0008"
Return $separator & "AtkTH - Barbarian Top Right"
Case "#0005", "#0009"
Return $separator & "AtkTH - Barbarian Top Left"
Case "#0010"
Return $separator & "AtkTH - Select Archer"
Case "#0011", "#0015"
Return $separator & "AtkTH - Arcer Bottom Left"
Case "#0012", "#0016"
Return $separator & "AtkTH - Arcer Bottom Right"
Case "#0013", "#0017"
Return $separator & "AtkTH - Arcer Top Right"
Case "#0014", "#0018"
Return $separator & "AtkTH - Arcer Top Left"
Case "#0155"
Return $separator & "Attack - Next Button"
Case "#0331"
Return $separator & "Collect resources"
Case "#0330"
Return $separator & "Collect resources*"
Case "#0432"
Return $separator & "Clean tombs*"
Case "#0431"
Return $separator & "Clean yard"
Case "#0430"
Return $separator & "Clean yard*"
Case "#0266"
Return $separator & "Train - TrainIT Selected Troop"
Case "#0269"
Return $separator & "Train - Open Barrack"
Case "#0270"
Return $separator & "Train - Train Troops button"
Case "#0271"
Return $separator & "Train - Next Button "
Case "#0272", "#0286", "#0289", "#0325"
Return $separator & "Train - Prev Button "
Case "#0273", "#0284", "#0285", "#0287", "#0288"
Return $separator & "Train - Remove Troops"
Case "#0274"
Return $separator & "Train - Train Barbarian"
Case "#0275"
Return $separator & "Train - Train Archer"
Case "#0276"
Return $separator & "Train - Train Giant"
Case "#0277"
Return $separator & "Train - Train Goblin"
Case "#0278"
Return $separator & "Train - Train Wall Breaker"
Case "#0279"
Return $separator & "Train - Train Balloon"
Case "#0280"
Return $separator & "Train - Train Wizard"
Case "#0281"
Return $separator & "Train - Train Healer"
Case "#0282"
Return $separator & "Train - Train Dragon"
Case "#0283"
Return $separator & "Train - Train P.E.K.K.A."
Case "#0290"
Return $separator & "Train - GemClick Spell"
Case "#0293"
Return $separator & "Train - Click Army Camp"
Case "#0294"
Return $separator & "Train - Open Info Army Camp"
Case "#0336"
Return $separator & "Train - Go to first barrack"
Case "#0337"
Return $separator & "Train - Click Prev Button*"
Case "#0338"
Return $separator & "Train - Click Next Button*"
Case "#0339"
Return $separator & "Train - Select Prev Barrack/SP"
Case "#0340"
Return $separator & "Train - Click Next Barrack/SP"
Case "#0341"
Return $separator & "Train - Train Bowler"
Case "#0342"
Return $separator & "Train - Train Baby Dragon"
Case "#0343"
Return $separator & "Train - Train Miner"
Case "#0168"
Return $separator & "Donate - Open Chat"
Case "#0169"
Return $separator & "Donate - Select Clan Tab"
Case "#0172"
Return $separator & "Donate - Scroll"
Case "#0173"
Return $separator & "Donate - Click Chat"
Case "#0174"
Return $separator & "Donate - Click Donate Button"
Case "#0175"
Return $separator & "Donate - Donate Selected Troop first row"
Case "#0600"
Return $separator & "Donate - Donate Selected Troop second row"
Case "#0601"
Return $separator & "Donate - Donate Selected Troop spell"
Case "#0144"
Return $separator & "ChkLang - Config Button"
Case "#0145", "#0146", "#0147", "#0148"
Return $separator & "ChkLang - Close Page"
Case "#0222"
Return $separator & "Profile - Profile Button"
Case "#0223"
Return $separator & "Profile - Close Page"
Case "#0225"
Return $separator & "Rearm - Click Town Hall"
Case "#0326", "#0228"
Return $separator & "Rearm - Click Rearm Button"
Case "#0226", "#0229"
Return $separator & "Rearm - Click Rearm"
Case "#0227", "#0230", "#0233"
Return $separator & "Rearm - Close Gem Spend Window"
Case "#0231"
Return $separator & "Rearm - Click Inferno Button"
Case "#0232"
Return $separator & "Rearm - Inferno Button"
Case "#0250"
Return $separator & "Request - Click Castle Clan"
Case "#0253"
Return $separator & "Request - Click Request Button"
Case "#0254", "#0255"
Return $separator & "Request - Click Select Text For Request"
Case "#0256"
Return $separator & "Request - Click Send Request"
Case "#0334"
Return $separator & "Request - Click Train Button"
Case "#0099"
Return $separator & "Return Home - End Battle"
Case "#0100"
Return $separator & "Return Home - Surrender, Confirm"
Case "#0101"
Return $separator & "Return Home - Return Home Button"
Case "#0396"
Return $separator & "Reach Limit - Return home, Press End Battle "
Case "#0468"
Return $separator & "Clan Level - Open Chat"
Case "#0469"
Return $separator & "Clan Level - Open Chat Clan Tab "
Case "#0470"
Return $separator & "Clan Level - Click Info Clan Button"
Case "#071", "#0472"
Return $separator & "Clan Level - Close Chat"
Case "#0473"
Return $separator & "Clan Level - Close Clan Info Page"
Case "#0149"
Return $separator & "Prepare Search - Press Attack Button"
Case "#0150"
Return $separator & "Prepare Search - Press Find a Match Button"
Case "#0030"
Return $separator & "Attack - press surrender"
Case "#0031"
Return $separator & "Attack - press confirm surrender"
Case "#0000"
Return $separator & " "
Case Else
Return ""
EndSwitch
EndFunc
Func SendText($sText)
Local $Result = 1
Local $error = 0
If $AndroidAdbInput = True Then
AndroidSendText($sText)
$error = @error
EndIf
If $AndroidAdbInput = False Or $error <> 0 Then
Local $SuspendMode = ResumeAndroid()
Local $ascText = ""
Local $r, $i, $vk, $shiftBits, $char
Local $c = 0
For $i = 1 To StringLen($sText)
$char = StringMid($sText, $i, 1)
$vk = _VkKeyScan($char)
$shiftBits = @extended
If $vk = -1 And $shiftBits = -1 Then
SetDebugLog("SendText cannot send character: " & $char)
$c += 1
Else
If BitAND($shiftBits, 1) > 0 Then $ascText &= "{LSHIFT down}"
If BitAND($shiftBits, 2) > 0 Then $ascText &= "{LCTRL down}"
If BitAND($shiftBits, 4) > 0 Then $ascText &= "{LALT down}"
$ascText &= "{ASC " & _WinAPI_MapVirtualKey($vk, $MAPVK_VK_TO_CHAR) & "}"
If BitAND($shiftBits, 4) > 0 Then $ascText &= "{LALT up}"
If BitAND($shiftBits, 2) > 0 Then $ascText &= "{LCTRL up}"
If BitAND($shiftBits, 1) > 0 Then $ascText &= "{LSHIFT up}"
$r = ControlSend($HWnD, "", "", $ascText, 0)
$ascText = ""
If $r = 1 Then
$c += 1
EndIf
EndIf
Next
$Result = 0
If $c = StringLen($sText) Then $Result = 1
SuspendAndroid($SuspendMode)
EndIf
Return $Result
EndFunc
Func _VkKeyScan($s_Char)
Local $a_Ret = DllCall("user32.dll", "short", "VkKeyScanW", "ushort", AscW($s_Char))
If @error Then Return SetError(@error, @extended, -1)
Return SetExtended(BitShift($a_Ret[0], 8), BitAnd($a_Ret[0], 0xFF))
EndFunc
Func ClickOkay($FeatureName = "Okay", $bCheckOneTime = False)
Local $i = 0
If _Sleep($iSpecialClick1) Then Return False
While 1
Local $offColors[3][3] = [[0x000000, 144, 0], [0xFFFFFF, 54, 17], [0xCBE870, 54, 10]]
Global $ButtonPixel = _MultiPixelSearch(438, 372 + $midOffsetY, 590, 404 + $midOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $debugSetlog = 1 Then Setlog($FeatureName & " btn chk-#1: " & _GetPixelColor(441, 374 + $midOffsetY, True) & ", #2: " & _GetPixelColor(441 + 144, 374 + $midOffsetY, True) & ", #3: " & _GetPixelColor(441 + 54, 374 + 17 + $midOffsetY, True) & ", #4: " & _GetPixelColor(441 + 54, 374 + 10 + $midOffsetY, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Then
Setlog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 10, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 2, 50, "#0117")
ExitLoop
EndIf
If $bCheckOneTime = True Then Return False
If $i > 5 Then
Setlog("Can not find button for " & $FeatureName & ", giving up", $COLOR_RED)
If $debugImageSave = 1 Then DebugImageSave($FeatureName & "_ButtonCheck_")
SetError(1, @extended, False)
Return
EndIf
$i += 1
If _Sleep($iSpecialClick2) Then Return False
WEnd
Return True
EndFunc
Func ClickRemove($FeatureName = "Remove")
If _CheckPixel($aIsShieldInfo, $bCapturePixel) Then
Local $i = 0
While 1
Local $offColors[3][3] = [[0x111111, 109, 0], [0xFFFFFF, 65, 10], [0xC00000, 55, 20]]
Global $ButtonPixel = _MultiPixelSearch(472, 251, 588, 278, 1, 1, Hex(0x090908, 6), $offColors, 20)
If $debugSetlog = 1 Then Setlog($FeatureName & " btn chk-#1: " & _GetPixelColor(475, 255, True) & ", #2: " & _GetPixelColor(475 + 109, 255, True) & ", #3: " & _GetPixelColor(475 + 65, 255 + 10, True) & ", #4: " & _GetPixelColor(475 + 55, 255 + 20, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Then
Setlog("ButtonPixelLocation = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 109, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 65, $ButtonPixel[1] + 10, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 55, $ButtonPixel[1] + 20, True), $COLOR_DEBUG)
EndIf
PureClick($ButtonPixel[0] + 55, $ButtonPixel[1] + 10, 1, 0)
ExitLoop
EndIf
If $i > 15 Then
Setlog("Can not find button for " & $FeatureName & ", giving up", $COLOR_RED)
If $debugImageSave = 1 Then DebugImageSave($FeatureName & "_ButtonCheck_")
SetError(1, @extended, False)
Return
EndIf
$i += 1
If _Sleep($iSpecialClick1) Then Return False
WEnd
Return True
Else
If $debugSetlog = 1 Then Setlog($FeatureName & " remove button found", $COLOR_DEBUG)
Return False
EndIf
EndFunc
Func CreateLogFile()
If $hLogFileHandle <> "" Then
FileClose($hLogFileHandle)
$hLogFileHandle = ""
EndIf
$sLogFName = @YEAR & "-" & @MON & "-" & @MDAY & "_" & @HOUR & "." & @MIN & "." & @SEC & ".log"
$sLogPath = $dirLogs & $sLogFName
$hLogFileHandle = FileOpen($sLogPath, $FO_APPEND)
EndFunc
Func CreateAttackLogFile()
If $hAttackLogFileHandle <> "" Then
FileClose($hAttackLogFileHandle)
$hAttackLogFileHandle = ""
EndIf
$sAttackLogFName = "AttackLog" & "-" & @YEAR & "-" & @MON & ".log"
$sAttackLogPath = $dirLogs & $sAttackLogFName
$hAttackLogFileHandle = FileOpen($sAttackLogPath, $FO_APPEND)
EndFunc
Func DebugImageSave($TxtName = "Unknown", $capturenew = True, $extensionpng = "png", $makesubfolder = True, $sDrawText = "", $iDrawX = 0, $iDrawY = 0, $iDrawSize = 10, $iDrawRX = 0, $iDrawRY = 0, $iDrawRW = 0, $iDrawRH = 0)
$Date = @MDAY & "." & @MON & "." & @YEAR
$Time = @HOUR & "." & @MIN & "." & @SEC
Local $savefolder = $dirTempDebug
If $makesubfolder = True Then
$savefolder = $dirTempDebug & $TxtName & "\"
DirCreate($savefolder)
EndIf
Local $extension
If $extensionpng = "png" Then
$extension = "png"
Else
$extension = "jpg"
EndIf
Local $exist = True
Local $i = 1
Local $first = True
Local $filename = ""
While $exist
If $first Then
$first = False
$filename = $savefolder & $TxtName & $Date & " at " & $Time & "." & $extension
If FileExists($filename) = 1 Then
$exist = True
Else
$exist = False
EndIf
Else
$filename = $savefolder & $TxtName & $Date & " at " & $Time & " (" & $i & ")." & $extension
If FileExists($filename) = 1 Then
$i += 1
Else
$exist = False
EndIf
EndIf
WEnd
If $capturenew Then _CaptureRegion()
If $sDrawText <> "" Or ($iDrawRX <> 0 Or $iDrawRW <> 0 Or $iDrawRH <> 0) Then
Local $hBmpTemp = $hBitmap
Local $hGraphics = _GDIPlus_ImageGetGraphicsContext($hBmpTemp)
If $sDrawText <> "" Then
_GDIPlus_GraphicsDrawString($hGraphics, $sDrawText, $iDrawX, $iDrawY, "Arial", $iDrawSize)
EndIf
If $iDrawRX <> 0 Or $iDrawRW <> 0 Or $iDrawRH <> 0 Then
_GDIPlus_GraphicsDrawRect($hGraphics, $iDrawRX, $iDrawRY, $iDrawRW, $iDrawRH)
EndIf
_GDIPlus_ImageSaveToFile($hBmpTemp, $filename)
_GDIPlus_BitmapDispose($hBmpTemp)
Else
_GDIPlus_ImageSaveToFile($hBitmap, $filename)
EndIf
If $debugsetlog = 1 Then Setlog($filename, $COLOR_DEBUG)
If _Sleep($iDelayDebugImageSave1) Then Return
EndFunc
Func DebugSaveDesktopImage($sName = "Unknown_")
Local $iDesktopLeft = 0, $iDesktopTop = 0
Local $iDesktopWidth = @DesktopWidth, $iDesktopHeight = @DesktopHeight
Local $hDesktopBitmap = _ScreenCapture_Capture("", $iDesktopLeft, $iDesktopTop, $iDesktopWidth, $iDesktopHeight, False)
SetLog("Saving desktop snapshot in TEMP folder for developer review", $COLOR_BLUE)
$Date = @MDAY & "." & @MON & "." & @YEAR
$Time = @HOUR & "." & @MIN & "." & @SEC
$SaveFileName = $sName & $Date & "_at_" & $Time & ".png"
_ScreenCapture_SaveImage($dirTempDebug & $SaveFileName, $hDesktopBitmap)
_WinAPI_DeleteObject($hDesktopBitmap)
EndFunc
Func _logErrorDLLCall($sDllName, $ErrorCode)
Local $sEmsg
If $ErrorCode > 0 Then
Switch $ErrorCode
Case 1
$sEmsg = "unable to use DLL file"
Case 2
$sEmsg = "unknown return type"
Case 3
$sEmsg = "function not found in the DLL file"
Case 4
$sEmsg = "bad number of parameters"
Case 5
$sEmsg = "bad parameter"
Case Else
$sEmsg = "Unknown Error Code?"
EndSwitch
SetLog($sDllName & " DLLCall Error, @error code: " & $sEmsg, $COLOR_RED)
EndIf
EndFunc
Func _logErrorDateDiff($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Invalid $sType"
Case 2
$sEmsg = "2| Invalid $iNumber"
Case 3
$sEmsg = "3| Invalid $sEndDate"
EndSwitch
Setlog("_DateDiff error code = " & $sEmsg, $COLOR_RED)
EndFunc
Func _logErrorDateAdd($ErrorCode)
Local $sEmsg
Switch $ErrorCode
Case 1
$sEmsg = "1| Invalid $sType"
Case 2
$sEmsg = "2| Invalid $sStartDate"
Case 3
$sEmsg = "3| Invalid $sEndDate"
EndSwitch
Setlog("_DateAdd error code = " & $sEmsg, $COLOR_RED)
EndFunc
Func FindPos()
getBSPos()
WinActivate(((AndroidEmbedded = False) ? $HWnD : $frmBot))
Local $wasDown = AndroidShieldForceDown(True, True)
While 1
If _IsPressed("01") Or _IsPressed("02") Then
Local $Pos = MouseGetPos()
$Pos[0] -= $BSpos[0]
$Pos[1] -= $BSpos[1]
While _IsPressed("01") Or _IsPressed("02")
Sleep(10)
WEnd
AndroidShieldForceDown($wasDown, True)
Return $Pos
EndIf
Sleep(10)
WEnd
EndFunc
Func SetLog($String, $Color = $COLOR_BLACK, $Font = "Verdana", $FontSize = 7.5, $statusbar = 1, $time = Time(), $bConsoleWrite = True, $LogPrefix = "L ", $LogType = "bot")
Local $log = $LogPrefix & TimeDebug() & $String
If $hLogFileHandle = "" Then CreateLogFile()
If $SilentSetLog = True Then
__FileWriteLog($hLogFileHandle, $log)
Return
EndIf
If IsDeclared("txtLog") Then
Local $activeBot = _WinAPI_GetActiveWindow() = $frmBot
Local $hCtrl = _WinAPI_GetFocus()
_SendMessage($txtLog, $WM_SETREDRAW, False, 0)
_WinAPI_EnableWindow($txtLog, False)
_GUICtrlRichEdit_SetSel($txtLog, -1, -1)
_GUICtrlRichEdit_SetFont($txtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($txtLog, $time, 0x000000, False)
_GUICtrlRichEdit_SetFont($txtLog, $FontSize, $Font)
_GUICtrlRichEdit_AppendTextColor($txtLog, $String & @CRLF, _ColorConvert($Color), False)
If $statusbar = 1 And IsDeclared("statLog") Then _GUICtrlStatusBar_SetText($statLog, "Status : " & $String)
_WinAPI_EnableWindow($txtLog, True)
_GUICtrlRichEdit_SetSel($txtLog, -1, -1)
_SendMessage($txtLog, $WM_SETREDRAW, True, 0)
_WinAPI_RedrawWindow($txtLog, 0, 0, $RDW_INVALIDATE)
If $activeBot And $hCtrl <> $txtLog Then _WinAPI_SetFocus($hCtrl)
__FileWriteLog($hLogFileHandle, $log)
Else
Local $iIndex = UBound($aTxtLogInitText)
ReDim $aTxtLogInitText[$iIndex + 1][6]
$aTxtLogInitText[$iIndex][0] = $String
$aTxtLogInitText[$iIndex][1] = $Color
$aTxtLogInitText[$iIndex][2] = $Font
$aTxtLogInitText[$iIndex][3] = $FontSize
$aTxtLogInitText[$iIndex][4] = $statusbar
$aTxtLogInitText[$iIndex][5] = $time
EndIf
EndFunc
Func SetDebugLog($String, $Color = Default, $bSilentSetLog = False, $Font = "Verdana", $FontSize = 7.5, $statusbar = 0, $LogType = "debug")
If $Color = Default Then $Color = $COLOR_PURPLE
Local $LogPrefix = "D "
Local $log = $LogPrefix & TimeDebug() & $String
If $debugSetlog = 1 And $bSilentSetLog = False Then
SetLog($String, $Color, $Font, $FontSize, $statusbar, Time(), False, $LogPrefix, $LogType)
Else
If $hLogFileHandle = "" Then CreateLogFile()
__FileWriteLog($hLogFileHandle, $log)
EndIf
EndFunc
Func _GUICtrlRichEdit_AppendTextColor($hWnd, $sText, $iColor, $bGotoEnd = True)
If $bGotoEnd Then _GUICtrlRichEdit_SetSel($hWnd, -1, -1)
_GUICtrlRichEdit_SetCharColor($hWnd, $iColor)
_GUICtrlRichEdit_AppendText($hWnd, $sText)
EndFunc
Func _ColorConvert($nColor)
Return  BitOR(BitShift(BitAND($nColor, 0x000000FF), -16),  BitAND($nColor, 0x0000FF00),  BitShift(BitAND($nColor, 0x00FF0000), 16))
EndFunc
Func SetAtkLog($String1, $String2 = "", $Color = $COLOR_BLACK, $Font = "Lucida Console", $FontSize = 7.5)
If $hAttackLogFileHandle = "" Then CreateAttackLogFile()
_GUICtrlRichEdit_SetFont($txtAtkLog, $FontSize, $Font)
_GUICtrlRichEdit_AppendTextColor($txtAtkLog, $String1 & @CRLF, _ColorConvert($Color))
_FileWriteLog($hAttackLogFileHandle, $String1 & $String2)
EndFunc
Func AtkLogHead()
SetAtkLog(_PadStringCenter(" " & GetTranslated(601, 15, "ATTACK LOG") & " ", 71, "="), "", $COLOR_BLACK, "MS Shell Dlg", 8.5)
SetAtkLog(GetTranslated(601, 16, "                   --------  LOOT --------       ----- BONUS ------"), "")
SetAtkLog(GetTranslated(601, 17, " TIME|TROP.|SEARCH|   GOLD| ELIXIR|DARK EL|TR.|S|  GOLD|ELIXIR|  DE|L."), "")
EndFunc
Func __FileWriteLog($handle, $text)
FileWriteLine($handle, $text)
EndFunc
Func Tab($a, $b)
$Tab = ""
For $i = StringLen($a) To $b Step 1
$Tab &= " "
Next
Return $Tab
EndFunc
Func Time()
Return "[" & _NowTime(3) & "] "
EndFunc
Func TimeDebug()
Return "[" & @YEAR & "-" & @MON & "-" & @MDAY & " " & _NowTime(5) & "." & @MSEC & "] "
EndFunc
Func TogglePause()
TogglePauseImpl("Button")
EndFunc
Func TogglePauseImpl($Source)
If Not $RunState Then Return
ResumeAndroid()
$TPaused = Not $TPaused
If $TogglePauseAllowed = False Then
$TogglePauseUpdateState = True
Return
EndIf
TogglePauseUpdateState($Source)
TogglePauseSleep()
EndFunc
Func TogglePauseUpdateState($Source)
$TogglePauseUpdateState = False
If $TPaused Then
AndroidShield("TogglePauseImpl paused", False)
TrayTip($sBotTitle, "", 1)
TrayTip($sBotTitle, "was Paused!", 1, $TIP_ICONEXCLAMATION)
Setlog("Bot was Paused!", $COLOR_ERROR)
If Not $bSearchMode Then
$iTimePassed += Int(TimerDiff($sTimer))
EndIf
PushMsg("Pause", $Source)
GUICtrlSetState($btnPause, $GUI_HIDE)
GUICtrlSetState($btnResume, $GUI_SHOW)
Else
AndroidShield("TogglePauseImpl resumed")
TrayTip($sBotTitle, "", 1)
TrayTip($sBotTitle, "was Resumed.", 1, $TIP_ICONASTERISK)
Setlog("Bot was Resumed.", $COLOR_SUCCESS)
If Not $bSearchMode Then
$sTimer = TimerInit()
EndIf
PushMsg("Resume", $Source)
GUICtrlSetState($btnPause, $GUI_SHOW)
GUICtrlSetState($btnResume, $GUI_HIDE)
EndIf
SetRedrawBotWindow(True)
EndFunc
Func TogglePauseSleep()
Local $counter = 0
While $TPaused
If _Sleep($iDelayTogglePause1, True, True, False) Then ExitLoop
$counter = $counter + 1
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyRemoteEnable = 1 And $counter = 200 Then
_RemoteControl()
$counter = 0
EndIf
WEnd
$SkipFirstZoomout = False
If _Sleep($iDelayTogglePause2, True, True, False) Then Return
EndFUnc
Func CheckPrerequisites()
Local $isAllOK = True
Local $isNetFramework4dot5Installed = isNetFramework4dot5Installed()
Local $isVC2010Installed = isVC2010Installed()
If ($isNetFramework4dot5Installed = False Or $isVC2010Installed = False) Then
If ($isNetFramework4dot5Installed = False) Then
SetLog("The .Net Framework 4.5 is not installed", $COLOR_RED)
SetLog("Please download here : https://www.microsoft.com/en-US/download/details.aspx?id=30653", $COLOR_RED)
EndIf
If ($isVC2010Installed = False) Then
SetLog("The VC 2010 x86 is not installed", $COLOR_RED)
SetLog("Please download here : https://www.microsoft.com/en-US/download/details.aspx?id=5555", $COLOR_RED)
EndIf
$isAllOK = False
EndIf
If isEveryFileInstalled() = False Then $isAllOK = False
If Not checkAutoitVersion() Then $isAllOK = False
checkIsAdmin()
If $isAllOK = False Then
GUICtrlSetState($btnStart, $GUI_DISABLE)
EndIf
Return $isAllOK
EndFunc
Func isNetFramework4Installed()
Local $z = 0, $sKeyName, $success = False
Do
$z += 1
$sKeyName = RegEnumKey("HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP", $z)
If StringRegExp($sKeyName, "v4|v4.\d+") Then
$success = True
EndIf
Until $sKeyName = '' Or $success
Return $success
EndFunc
Func isNetFramework4dot5Installed()
Local $z = 0, $sKeyValue, $success = False
$sKeyValue = RegRead("HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\", "Release")
If Number($sKeyValue) >= 378389 Then $success = True
Return $success
EndFunc
Func isVC2010Installed()
Local $listRegistry[4] = ["HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\10.0\VC\VCRedist\x86",  "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\10.0\VC\VCRedist\x86",  "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\12.0\VC\Runtimes\x86",  "HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\12.0\VC\Runtimes\x86"  ]
Local $success = False
For $reg In $listRegistry
$sKeyName = RegRead($reg, "Version")
If $sKeyName <> "" Then
$success = True
ExitLoop
EndIf
Next
Return $success
EndFunc
Func isEveryFileInstalled()
Local $bResult = False, $iCount = 0
Local $aCheckFiles[9] = [@ScriptDir & "\COCBot",  $LibDir,  @ScriptDir & "\Images",  $pFuncLib,  $pImageLib,  $pImgLib,  $pIconLib,  $LibDir & "\opencv_core220.dll",  $LibDir & "\opencv_imgproc220.dll"]
For $vElement In $aCheckFiles
$iCount += FileExists($vElement)
Next
If $iCount = UBound($aCheckFiles) Then
$bResult = True
Else
GUICtrlSetState($btnStart, $GUI_DISABLE)
Local $sText1, $sText2, $MsgBox
$sText1 = GetTranslated(640,11,"Hey Chief, we are missing some files!")
$sText2 = GetTranslated(640,12,"Please extract all files and folders and start this program again!")
$sText3 = GetTranslated(640,13,"Sorry, Start button disabled until fixed!")
Setlog($sText1, $COLOR_RED)
Setlog($sText2, $COLOR_RED)
Setlog($sText3, $COLOR_RED)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(48, GetTranslated(640,14,"Ok"), $sText1, $sText2, 0, $frmBot)
GUICtrlSetState($btnStart, $GUI_DISABLE)
EndIf
If @Compiled Then
If Not StringInStr(@ScriptFullPath, "MyBot.run.exe", 1) Then
Local $sText1, $sText2, $MsgBox
$sText1 = GetTranslated(640,15,"Hey Chief, file name incorrect!")
$sText2 = GetTranslated(640,16,'You have renamed the file "MyBot.run.exe"! Please change it back to MyBot.run.exe and restart the bot!')
$sText3 = GetTranslated(640,13,"Sorry, Start button disabled until fixed!")
Setlog($sText1, $COLOR_RED)
Setlog($sText2, $COLOR_RED)
Setlog($sText3, $COLOR_RED)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(48, GetTranslated(640,14,"Ok"), $sText1, $sText2, 0, $frmBot)
GUICtrlSetState($btnStart, $GUI_DISABLE)
$bResult = False
EndIf
EndIf
Return $bResult
EndFunc
Func checkAutoitVersion()
If @Compiled = True Then Return 1
Local $requiredAutoit = "3.3.14.2"
Local $result = _VersionCompare(@AutoItVersion, $requiredAutoit)
If $result = 0 Or $result = 1 Then Return 1
Local $sText1, $sText2, $MsgBox
$sText1 = "Hey Chief, your AutoIt version is out of date!"
$sText3 = "Click OK to download the latest version of AutoIt."
$sText2 = "The bot requires AutoIt version "&$requiredAutoit&" or above. Your version of AutoIt is "&@AutoItVersion&"." & @CRLF & $sText3 & @CRLF &"After installing the new version, open the bot again."
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(48, "OK|Cancel", $sText1, $sText2, 0, $frmBot)
If $MsgBox = 1 Then ShellExecute("https://www.autoitscript.com/site/autoit/downloads/")
Return 0
EndFunc
Func checkIsAdmin()
If IsAdmin() Then Return True
SetLog("My Bot running without admin privileges", $COLOR_RED)
Return False
EndFunc
Func CheckDisplay()
Local $aPos, $sBSDisplaySize
Local $bDisplayDPI = False, $bDisplayFound = False
Local Const $iDisplaySizeMin = 780
Local $iDPIRatio = GetDPI_Ratio()
If $iDPIRatio <> 1 Then
ShowDPIHelp($iDPIRatio * 100)
Else
If $Debugsetlog = 1 Then SetLog(_PadStringCenter("  Display DPI setting = " & $iDPIRatio & "  ", 53, "+"), $COLOR_DEBUG)
ConsoleWrite('DPI= ' & $iDPIRatio & @CRLF)
$bDisplayDPI = True
EndIf
Local $hMonitor = _WinAPI_MonitorFromWindow($HWnD)
ConsoleWrite('Handle: ' & $hMonitor & @CRLF)
Local $aMonitorData = _WinAPI_EnumDisplayMonitors()
If IsArray($aMonitorData) Then
ReDim $aMonitorData[$aMonitorData[0][0] + 1][5]
For $i = 1 To $aMonitorData[0][0]
$aPos = _WinAPI_GetPosFromRect($aMonitorData[$i][1])
For $j = 0 To 3
$aMonitorData[$i][$j + 1] = $aPos[$j]
Next
Next
ConsoleWrite('NumberDisplays: ' & $aMonitorData[0][0] & @CRLF)
For $i = 1 To $aMonitorData[0][0]
ConsoleWrite('DisplayHandle: ' & $aMonitorData[$i][0] & ', DisplayX: ' & $aMonitorData[$i][3] & ', DisplayY: ' & $aMonitorData[$i][4] & @CRLF)
If $aMonitorData[$i][0] = $hMonitor Then
$bDisplayFound = True
$bMonitorHeight800orBelow = ($aMonitorData[$i][4] <= 800)
$sBSDisplaySize = $aMonitorData[$i][3] & "x" & $aMonitorData[$i][4]
ConsoleWrite("DisplaySizeFound: " & $sBSDisplaySize & @CRLF)
If ($aMonitorData[$i][3] < $iDisplaySizeMin) Or ($aMonitorData[$i][4] < $iDisplaySizeMin) Then
SetLog(_PadStringCenter(" Warning!! Display size smaller than recommended = " & $sBSDisplaySize & " ", 53, "+"), $COLOR_RED)
SetLog(_PadStringCenter(" MBR will attempt to auto adjust Emulator size ", 53, "+"), $COLOR_RED)
SetLog(_PadStringCenter(" Make sure task bar isn't covering Emulator ", 53, "+"), $COLOR_RED)
SetLog(_PadStringCenter(" Search MyBot.run forums if any problems ", 53, "+"), $COLOR_RED)
SetLog(_PadStringCenter(" Click ""Start Bot"" to proceed ", 53, "+"), $COLOR_RED)
Setlog(" ")
Else
ConsoleWrite("Display Check Pass!" & @CRLF)
If $Debugsetlog = 1 Then SetLog(_PadStringCenter(" Display size= " & $sBSDisplaySize & " ", 50, "+"), $COLOR_DEBUG)
ExitLoop
EndIf
EndIf
Next
If $bDisplayFound = False Then
SetLog(" Error finding Android Emulator display device size, proceed with caution!", $COLOR_RED)
EndIf
Else
SetLog(" Error finding Android Emulator display device, proceed with caution!", $COLOR_RED)
EndIf
Return $bDisplayDPI And $bDisplayFound
EndFunc
Func ShowDPIHelp($currentDPI)
$text = GetTranslated(640,4,"Your DPI is incorrect. It is set to") & " " & $currentDPI & GetTranslated(640,5,"%. You must set it to 100% for this bot to work.") & @CRLF &  GetTranslated(640,6,"When you have changed the DPI to the correct value, reboot your computer and run the bot again.") & @CRLF &  GetTranslated(640,7,"You won't be able to use the bot until you make this change.") & @CRLF & @CRLF &  GetTranslated(640,8,"Click OK to view instructions on how to change DPI")
Local $button = MsgBox($MB_OKCANCEL + $MB_ICONWARNING, GetTranslated(640,3,"DPI incorrect"), $text)
If $button = $IDOK Then
Switch @OSVersion
Case "WIN_10"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141136")
Case "WIN_8", "WIN_81"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141160")
Case "WIN_7"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141159")
Case "WIN_VISTA"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141161")
Case "WIN_2012"
ShellExecute("https://mybot.run/forums/index.php?/topic/15137-change-dpi-to-100/#comment-141160")
Case Else
MsgBox($MB_OK, GetTranslated(640,9,"Unsupported"), GetTranslated(640,10,"Sorry, your operating system isn't supported by the bot."))
EndSwitch
EndIf
btnStop()
GUICtrlSetState($btnStart, $GUI_DISABLE)
EndFunc
Func AutoStart()
If $ichkAutoStart = 1 Or $restarted = 1 Then
SetLog("Bot Auto Starting in " & $ichkAutoStartDelay & " seconds", $COLOR_RED)
Sleep($ichkAutoStartDelay * 1000)
btnStart()
EndIf
EndFunc
Func WindowsArrange($position, $offsetX = 0, $offsetY = 0)
WinGetAndroidHandle()
Local $AndroidPos = WinGetPos($HWnD)
Local $BotPos = WinGetPos($frmBot)
If IsArray($AndroidPos) And IsArray($BotPos) Then
Local $hTimer = TimerInit()
WinSetState($HWnD, "", @SW_RESTORE)
While IsArray($AndroidPos) And TimerDiff($hTimer) < 3000 And $AndroidPos[0] < -30000 And $AndroidPos[1] < -30000
$AndroidPos = WinGetPos($HWnD)
If _Sleep($iDelaySleep) Then Return False
WEnd
Local $AndroidX = $AndroidPos[0]
Local $AndroidY = $AndroidPos[1]
Local $AndroidW = $AndroidPos[2]
Local $AndroidH = $AndroidPos[3]
Local $BotX = $BotPos[0]
Local $BotY = $BotPos[1]
Local $BotW = $BotPos[2]
Local $BotH = $BotPos[3]
If Number($AndroidX) > -30000 And Number($AndroidY) > -30000 Then
Local $bAdjusted = False
If $position = "EMBED" Then
AndroidEmbed(True)
If Not ($offsetX == "" Or $offsetY == "") Then
$bAdjusted = $BotX <> $offsetX Or $BotY <> $offsetY
If $bAdjusted = True Then WinMove2($frmBot, "", $offsetX, $offsetY)
EndIf
Else
If $AndroidEmbedded = True Then
Return
EndIf
Local $x = $offsetX
Local $y = $offsetY
Switch $position
Case "BS-BOT"
If $offsetX == "" Then
$x = $AndroidX
$offsetX = 0
EndIf
If $offsetY == "" Then
$y = $AndroidY
$offsetY = 0
EndIf
$bAdjusted = $AndroidX <> $x Or $AndroidY <> $y
If $bAdjusted Then
WinMove2($HWnD, "", $x, $y)
_Sleep($iDelayWindowsArrange1, True, False)
EndIf
$bAdjusted = $bAdjusted = True Or $BotX <> $AndroidW + $offsetX * 2 Or $BotY <> $y
If $bAdjusted Then WinMove2($frmBot, "", $x + $AndroidW + $offsetX, $y)
Case "BOT-BS"
If $offsetX == "" Then
$x = $BotX
$offsetX = 0
EndIf
If $offsetY == "" Then
$y = $BotY
$offsetY = 0
EndIf
$bAdjusted = $BotX <> $x Or $BotY <> $y
If $bAdjusted Then
WinMove2($frmBot, "", $x, $y)
_Sleep($iDelayWindowsArrange1, True, False)
EndIf
$bAdjusted = $bAdjusted Or $AndroidX <> $x + $BotW + $offsetX Or $AndroidY <> $y
If $bAdjusted Then WinMove2($HWnD, "", $x + $BotW + $offsetX, $y)
Case "SNAP-TR"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX + $AndroidW + $offsetX Or $BotY <> $AndroidY + $offsetY
If $bAdjusted Then WinMove2($frmBot, "", $AndroidX + $AndroidW + $offsetX, $AndroidY + $offsetY)
Case "SNAP-BR"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $AndroidX <> $AndroidX + $AndroidW + $offsetX Or $AndroidY <> $AndroidY + ($AndroidH - $BotH) + $offsetY
If $bAdjusted Then WinMove2($frmBot, "", $AndroidX + $AndroidW + $offsetX, $AndroidY + ($AndroidH - $BotH) + $offsetY)
Case "SNAP-TL"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX - $BotW - $offsetX Or $BotY <> $AndroidY + $offsetY
If $bAdjusted Then WinMove2($frmBot, "", $AndroidX - $BotW - $offsetX, $AndroidY + $offsetY)
Case "SNAP-BL"
If $offsetX == "" Then $offsetX = 0
If $offsetY == "" Then $offsetY = 0
$bAdjusted = $BotX <> $AndroidX - $BotW - $offsetX Or $BotY <> $AndroidY + ($AndroidH - $BotH) + $offsetY
If $bAdjusted Then WinMove2($frmBot, "", $AndroidX - $BotW - $offsetX, $AndroidY + ($AndroidH - $BotH) + $offsetY)
EndSwitch
EndIf
If $bAdjusted = True Then
SetDebugLog("WindowsArrange: " & $position & ", offsetX=" & $offsetX & ", offsetY=" & $offsetY & ", X=" & $x & ", Y=" & $y)
_Sleep($iDelayWindowsArrange1, True, False)
EndIf
EndIf
EndIf
EndFunc
Func DisposeWindows()
updateBtnEmbed()
If $iDisposeWindows = 1 Then
Switch $icmbDisposeWindowsPos
Case 0
WindowsArrange("BS-BOT", $iWAOffsetX, $iWAOffsetY)
Case 1
WindowsArrange("BOT-BS", $iWAOffsetX, $iWAOffsetY)
Case 2
WindowsArrange("SNAP-TR", $iWAOffsetX, $iWAOffsetY)
Case 3
WindowsArrange("SNAP-TL", $iWAOffsetX, $iWAOffsetY)
Case 4
WindowsArrange("SNAP-BR", $iWAOffsetX, $iWAOffsetY)
Case 5
WindowsArrange("SNAP-BL", $iWAOffsetX, $iWAOffsetY)
Case 6
WindowsArrange("EMBED", $iWAOffsetX, $iWAOffsetY)
EndSwitch
EndIf
EndFunc
Func WinMove2($WinTitle, $WinText, $x = -1, $y = -1, $w = -1, $h = -1, $hAfter = 0, $iFlags = 0, $bCheckAfterPos = True)
Local $hWin = WinGetHandle($WinTitle, $WinText)
If _WinAPI_IsIconic($hWin) Then
SetDebugLog("Window " & $WinTitle & (($WinTitle <> $hWin) ? "(" & $hWin & ")" : "") & " restored", $COLOR_ORANGE)
WinSetState($hWin, "", @SW_RESTORE)
EndIf
Local $aPos = WinGetPos($hWin)
If @error <> 0 Or Not IsArray($aPos) Then
SetError(1, @extended, -1)
Return 0
EndIf
Local $aPPos = WinGetClientPos(_WinAPI_GetParent($hWin))
If IsArray($aPPos) Then
$aPos[0] -= $aPPos[0]
$aPos[1] -= $aPPos[1]
EndIf
Local $NoMove = $x = -1 And $y = -1
Local $NoResize = $w = -1 And $h = -1
Local $NOZORDER = ($hAfter = 0 ? $SWP_NOZORDER : 0)
If $x = -1 Or $y = -1 Or $w = -1 Or $h = -1 Then
If $x = -1 Then $x = $aPos[0]
If $y = -1 Then $y = $aPos[1]
If $w = -1 Then $w = $aPos[2]
If $h = -1 Then $h = $aPos[3]
EndIf
$NoMove = $NoMove Or ($x = $aPos[0] And $y = $aPos[1])
$NoResize = $NoResize Or ($w = $aPos[2] And $h = $aPos[3])
_WinAPI_SetWindowPos($hWin, $hAfter, $x, $y, $w, $h, BitOR(($NoMove ? BitOR($SWP_NOMOVE, $SWP_NOREPOSITION) : 0), $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
If $bCheckAfterPos Then
$aPos = WinGetPos($hWin)
If @error <> 0 Or Not IsArray($aPos) Then
SetError(1, @extended, -1)
Return 0
EndIf
Local $aPPos = WinGetClientPos(_WinAPI_GetParent($hWin))
If IsArray($aPPos) Then
$aPos[0] -= $aPPos[0]
$aPos[1] -= $aPPos[1]
EndIf
If $x <> $aPos[0] Or $y <> $aPos[1] Or $w <> $aPos[2] Or $h <> $aPos[3] Then
SetDebugLog("Window " & $WinTitle & (($WinTitle <> $hWin) ? "(" & $hWin & ")" : "") & " got resized/moved again to " & $aPos[0] & "/" & $aPos[1] & " " & $aPos[2] & "x" & $aPos[3] & ", restore now " & $x & "/" & $y & " " & $w & "x" & $h, $COLOR_ORANGE)
WinMove($hWin, "", $x, $y, $w, $h - 1)
_WinAPI_SetWindowPos($hWin, $hAfter, $x, $y, $w, $h, BitOR($SWP_NOMOVE, $SWP_NOREPOSITION, $SWP_NOACTIVATE, $SWP_NOSENDCHANGING, $NOZORDER, $iFlags))
EndIf
EndIf
Return $hWin
EndFunc
Func WinGetClientPos($hWin, $x = 0, $y = 0)
Local $tPoint = DllStructCreate("int x;int y")
DllStructSetData($tPoint, "x", $x)
DllStructSetData($tPoint, "y", $y)
_WinAPI_ClientToScreen($hWin, $tPoint)
If @error Then Return SetError(1, 0, 0)
Local $a[2] = [DllStructGetData($tPoint, "x"), DllStructGetData($tPoint, "y")]
Return $a
EndFunc
Func WinGetPos2($title, $text = "")
Local $aPos = 0
If IsHWnd($title) = 0 Then $title = WinGetHandle($title, $text)
While IsHWnd($title) And (IsArray($aPos) = 0 Or $aPos[2] < 200)
If _WinAPI_IsIconic($title) Then WinSetState($title, "", @SW_RESTORE)
If _WinAPI_IsIconic($title) = False Then $aPos = WinGetPos($title)
WEnd
Return $aPos
EndFunc
Func ControlGetPos2($title, $text, $controlID)
Local $aPos = 0
If IsHWnd($title) = 0 Then $title = WinGetHandle($title, $text)
While IsHWnd($title) And (IsArray($aPos) = 0 Or $aPos[2] < 200)
If _WinAPI_IsIconic($title) Then WinSetState($title, "", @SW_RESTORE)
If _WinAPI_IsIconic($title) = False Then $aPos = ControlGetPos($title, $text, $controlID)
WEnd
Return $aPos
EndFunc
Func MakeScreenshot($TargetDir, $type = "jpg")
If WinGetAndroidHandle() <> 0 Then
Local $SuspendMode
Local $iLeft = 0, $iTop = 0, $iRight = $AndroidClientWidth, $iBottom = $AndroidClientHeight
Local $iW = Number($iRight) - Number($iLeft)
Local $iH = Number($iBottom) - Number($iTop)
Local $hBitmapScreenshot
Local $hGraphic, $hBrush
$hHBitmapScreenshot = _CaptureRegion($iLeft, $iTop, $iRight, $iBottom, False, True)
$hBitmapScreenshot = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmapScreenshot)
$hGraphic = _GDIPlus_ImageGetGraphicsContext($hBitmapScreenshot)
$hBrush = _GDIPlus_BrushCreateSolid(0xFF000029)
If $ichkScreenshotHideName = 1 Then
If $aCCPos[0] = -1 Or $aCCPos[1] = -1 Then
Setlog("Screenshot warning: Locate the Clan Castle to hide the clanname!", $COLOR_RED)
EndIf
_GDIPlus_GraphicsFillRect($hGraphic, 0, 0, 250, 50, $hBrush)
If $aCCPos[0] <> -1 Then _GDIPlus_GraphicsFillRect($hGraphic, $aCCPos[0] - $IsCCAutoLocated[2], $aCCPos[1] - $IsCCAutoLocated[3], 66, 18, $hBrush)
EndIf
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $filename = $Date & "_" & $Time & "." & $type
_GDIPlus_ImageSaveToFile($hBitmapScreenshot, $TargetDir & $filename)
If FileExists($TargetDir & $filename) = 1 Then
If $dirTemp = $TargetDir Then
SetLog("Screenshot saved: .\Profiles\" & $sCurrProfile & "\Temp\" & $filename)
Else
SetLog("Screenshot saved: " & $TargetDir & $filename)
EndIf
Else
SetLog("Screenshot file not created!", $COLOR_RED)
EndIf
$iMakeScreenshotNow = False
_GDIPlus_BrushDispose($hBrush)
_GDIPlus_GraphicsDispose($hGraphic)
_GDIPlus_BitmapDispose($hBitmapScreenshot)
_WinAPI_DeleteObject($hHBitmapScreenshot)
Else
SetLog("Not in game", $COLOR_RED)
EndIf
EndFunc
Func _PostMessage_ClickDrag($X1, $Y1, $X2, $Y2, $Button = "left", $Delay = 50)
$X1 = Int($X1) + $BSrpos[0]
$Y1 = Int($Y1) + $BSrpos[1]
$X2 = Int($X2) + $BSrpos[0]
$Y2 = Int($Y2) + $BSrpos[1]
WinGetAndroidHandle()
If Not IsHWnd($HWnD) Then
Return SetError(1, "", False)
EndIf
If StringLower($Button) == "left" Then
$Button = $WM_LBUTTONDOWN
$Pressed = 1
ElseIf StringLower($Button) == "right" Then
$Button = $WM_RBUTTONDOWN
$Pressed = 2
ElseIf StringLower($Button) == "middle" Then
$Button = $WM_MBUTTONDOWN
$Pressed = 10
If $Delay == 10 Then $Delay = 100
EndIf
$User32 = DllOpen("User32.dll")
If @error Then Return SetError(4, "", False)
MoveMouseOutBS()
DllCall($User32, "bool", "PostMessage", "hwnd", $HWnD, "int", $Button, "int", "0", "long", _MakeLong($X1, $Y1))
If @error Then
DllClose($User32)
Return SetError(5, "", False)
EndIf
If _Sleep($Delay / 2) Then Return SetError(-1, "", False)
DllCall($User32, "bool", "PostMessage", "hwnd", $HWnD, "int", $WM_MOUSEMOVE, "int", $Pressed, "long", _MakeLong($X2, $Y2))
If @error Then
DllClose($User32)
Return SetError(6, "", False)
EndIf
If _Sleep($Delay / 2) Then Return SetError(-1, "", False)
DllCall($User32, "bool", "PostMessage", "hwnd", $HWnD, "int", $Button + 1, "int", "0", "long", _MakeLong($X2, $Y2))
If @error Then
DllClose($User32)
Return SetError(7, "", False)
EndIf
DllClose($User32)
Return SetError(0, 0, True)
EndFunc
Func _MakeLong($LowWORD, $HiWORD)
Return BitOR($HiWORD * 0x10000, BitAND($LowWORD, 0xFFFF))
EndFunc
Func ClickDrag($X1, $Y1, $X2, $Y2, $Delay = 50)
Local $error = 0
If $AndroidAdbClickDrag = True Then
AndroidClickDrag($X1, $Y1, $X2, $Y2, $RunState)
$error = @error
If _Sleep($Delay / 5) Then Return SetError(-1, "", False)
EndIf
If $AndroidAdbClickDrag = False Or $error <> 0 Then
Return _PostMessage_ClickDrag($X1, $Y1, $X2, $Y2, "left", $Delay)
EndIf
Return SetError(0, 0, ($error = 0 ? True : False))
EndFunc
Func TestLanguage()
If $Runstate Then
If getOcrLanguage(324, 6) = "english" Then
Setlog("Language setting is English: Correct.", $COLOR_BLUE)
Else
SetLog("Language setting is Wrong: Change CoC language to English!", $COLOR_RED)
btnStop()
EndIf
EndIf
EndFunc
Func Deletefiles($Folder, $Filter, $daydiff = 120, $type = 0)
Local $FileListName = _FileListToArray($Folder, $Filter, 1)
Local $x, $t, $tmin = 0
If Not ((Not IsArray($FileListName)) Or (@error = 1)) Then
For $x = $FileListName[0] To 1 Step -1
Local $FileDate = FileGetTime($Folder & $FileListName[$x])
If IsArray($FileDate) Then
Local $Date = $FileDate[0] & '/' & $FileDate[1] & '/' & $FileDate[2] & ' ' & $FileDate[3] & ':' & $FileDate[4] & ':' & $FileDate[5]
If _DateDiff('D', $Date, _NowCalc()) < $daydiff Then ContinueLoop
If $type = 0 Then
FileDelete($Folder & $FileListName[$x])
Else
FileRecycle($Folder & $FileListName[$x])
EndIf
Else
Return False
EndIf
Next
Else
Return False
EndIf
Return True
EndFunc
Global $ResetStats = 0
Global $iOldFreeBuilderCount, $iOldTotalBuilderCount, $iOldGemAmount
Global $iOldGoldCurrent, $iOldElixirCurrent, $iOldDarkCurrent, $iOldTrophyCurrent
Global $iOldGoldTotal, $iOldElixirTotal, $iOldDarkTotal, $iOldTrophyTotal
Global $iOldGoldLast, $iOldElixirLast, $iOldDarkLast, $iOldTrophyLast
Global $iOldGoldLastBonus, $iOldElixirLastBonus, $iOldDarkLastBonus
Global $iOldSkippedVillageCount, $iOldDroppedTrophyCount
Global $iOldCostGoldWall, $iOldCostElixirWall, $iOldCostGoldBuilding, $iOldCostElixirBuilding, $iOldCostDElixirHero
Global $iOldNbrOfWallsUppedGold, $iOldNbrOfWallsUppedElixir, $iOldNbrOfBuildingsUppedGold, $iOldNbrOfBuildingsUppedElixir, $iOldNbrOfHeroesUpped
Global $iOldSearchCost, $iOldTrainCostElixir, $iOldTrainCostDElixir
Global $iOldNbrOfOoS
Global $iOldNbrOfTHSnipeFails, $iOldNbrOfTHSnipeSuccess
Global $iOldGoldFromMines, $iOldElixirFromCollectors, $iOldDElixirFromDrills
Global $iOldAttackedCount, $iOldAttackedVillageCount[$iModeCount + 1]
Global $iOldTotalGoldGain[$iModeCount + 1], $iOldTotalElixirGain[$iModeCount + 1], $iOldTotalDarkGain[$iModeCount + 1], $iOldTotalTrophyGain[$iModeCount + 1]
Global $iOldNbrOfDetectedMines[$iModeCount + 1], $iOldNbrOfDetectedCollectors[$iModeCount + 1], $iOldNbrOfDetectedDrills[$iModeCount + 1]
Global $iOldGainedXPHour
Func UpdateStats()
If $FirstRun = 1 Then
GUICtrlSetState($lblResultStatsTemp, $GUI_HIDE)
GUICtrlSetState($lblVillageReportTemp, $GUI_HIDE)
GUICtrlSetState($picResultGoldTemp, $GUI_HIDE)
GUICtrlSetState($picResultElixirTemp, $GUI_HIDE)
GUICtrlSetState($picResultDETemp, $GUI_HIDE)
GUICtrlSetState($lblResultGoldNow, $GUI_SHOW)
GUICtrlSetState($picResultGoldNow, $GUI_SHOW)
GUICtrlSetState($lblResultElixirNow, $GUI_SHOW)
GUICtrlSetState($picResultElixirNow, $GUI_SHOW)
If $iDarkCurrent <> "" Then
GUICtrlSetState($lblResultDeNow, $GUI_SHOW)
GUICtrlSetState($picResultDeNow, $GUI_SHOW)
Else
GUICtrlSetState($picResultDEStart, $GUI_HIDE)
GUICtrlSetState($picDarkLoot, $GUI_HIDE)
GUICtrlSetState($picDarkLastAttack, $GUI_HIDE)
GUICtrlSetState($picHourlyStatsDark, $GUI_HIDE)
EndIf
GUICtrlSetState($lblResultTrophyNow, $GUI_SHOW)
GUICtrlSetState($lblResultBuilderNow, $GUI_SHOW)
GUICtrlSetState($lblResultGemNow, $GUI_SHOW)
$iGoldStart = $iGoldCurrent
$iElixirStart = $iElixirCurrent
$iDarkStart = $iDarkCurrent
$iTrophyStart = $iTrophyCurrent
GUICtrlSetData($lblResultGoldStart, _NumberFormat($iGoldCurrent, True))
GUICtrlSetData($lblResultGoldNow, _NumberFormat($iGoldCurrent, True))
$iOldGoldCurrent = $iGoldCurrent
GUICtrlSetData($lblResultElixirStart, _NumberFormat($iElixirCurrent, True))
GUICtrlSetData($lblResultElixirNow, _NumberFormat($iElixirCurrent, True))
$iOldElixirCurrent = $iElixirCurrent
If $iDarkStart <> "" Then
GUICtrlSetData($lblResultDEStart, _NumberFormat($iDarkCurrent, True))
GUICtrlSetData($lblResultDeNow, _NumberFormat($iDarkCurrent, True))
$iOldDarkCurrent = $iDarkCurrent
EndIf
GUICtrlSetData($lblResultTrophyStart, _NumberFormat($iTrophyCurrent, True))
GUICtrlSetData($lblResultTrophyNow, _NumberFormat($iTrophyCurrent, True))
$iOldTrophyCurrent = $iTrophyCurrent
GUICtrlSetData($lblResultGemNow, _NumberFormat($iGemAmount, True))
$iOldGemAmount = $iGemAmount
GUICtrlSetData($lblResultBuilderNow, $iFreeBuilderCount & "/" & $iTotalBuilderCount)
$iOldFreeBuilderCount = $iFreeBuilderCount
$iOldTotalBuilderCount = $iTotalBuilderCount
$FirstRun = 0
GUICtrlSetState($btnResetStats, $GUI_ENABLE)
Return
EndIf
If $FirstAttack = 1 Then
GUICtrlSetState($lblLastAttackTemp, $GUI_HIDE)
GUICtrlSetState($lblLastAttackBonusTemp, $GUI_HIDE)
GUICtrlSetState($lblTotalLootTemp, $GUI_HIDE)
GUICtrlSetState($lblHourlyStatsTemp, $GUI_HIDE)
$FirstAttack = 2
EndIf
If $ResetStats = 1 Then
GUICtrlSetData($lblResultGoldStart, _NumberFormat($iGoldCurrent, True))
GUICtrlSetData($lblResultElixirStart, _NumberFormat($iElixirCurrent, True))
If $iDarkStart <> "" Then
GUICtrlSetData($lblResultDEStart, _NumberFormat($iDarkCurrent, True))
EndIf
GUICtrlSetData($lblResultTrophyStart, _NumberFormat($iTrophyCurrent, True))
GUICtrlSetData($lblHourlyStatsGold, "")
GUICtrlSetData($lblHourlyStatsElixir, "")
GUICtrlSetData($lblHourlyStatsDark, "")
GUICtrlSetData($lblHourlyStatsTrophy, "")
GUICtrlSetData($lblResultGoldHourNow, "")
GUICtrlSetData($lblResultElixirHourNow, "")
GUICtrlSetData($lblResultDEHourNow, "")
EndIf
If $iOldFreeBuilderCount <> $iFreeBuilderCount Or $iOldTotalBuilderCount <> $iTotalBuilderCount Then
GUICtrlSetData($lblResultBuilderNow, $iFreeBuilderCount & "/" & $iTotalBuilderCount)
$iOldFreeBuilderCount = $iFreeBuilderCount
$iOldTotalBuilderCount = $iTotalBuilderCount
EndIf
If $iOldGemAmount <> $iGemAmount Then
GUICtrlSetData($lblResultGemNow, _NumberFormat($iGemAmount, True))
$iOldGemAmount = $iGemAmount
EndIf
If $iOldGoldCurrent <> $iGoldCurrent Then
GUICtrlSetData($lblResultGoldNow, _NumberFormat($iGoldCurrent, True))
$iOldGoldCurrent = $iGoldCurrent
EndIf
If $iOldElixirCurrent <> $iElixirCurrent Then
GUICtrlSetData($lblResultElixirNow, _NumberFormat($iElixirCurrent, True))
$iOldElixirCurrent = $iElixirCurrent
EndIf
If $iOldDarkCurrent <> $iDarkCurrent And $iDarkStart <> "" Then
GUICtrlSetData($lblResultDeNow, _NumberFormat($iDarkCurrent, True))
$iOldDarkCurrent = $iDarkCurrent
EndIf
If $iOldTrophyCurrent <> $iTrophyCurrent Then
GUICtrlSetData($lblResultTrophyNow, _NumberFormat($iTrophyCurrent, True))
$iOldTrophyCurrent = $iTrophyCurrent
EndIf
If $iOldGoldTotal <> $iGoldTotal And ($FirstAttack = 2 Or $ResetStats = 1) Then
GUICtrlSetData($lblGoldLoot, _NumberFormat($iGoldTotal))
$iOldGoldTotal = $iGoldTotal
EndIf
If $iOldElixirTotal <> $iElixirTotal And ($FirstAttack = 2 Or $ResetStats = 1) Then
GUICtrlSetData($lblElixirLoot, _NumberFormat($iElixirTotal))
$iOldElixirTotal = $iElixirTotal
EndIf
If $iOldDarkTotal <> $iDarkTotal And (($FirstAttack = 2 And $iDarkStart <> "") Or $ResetStats = 1) Then
GUICtrlSetData($lblDarkLoot, _NumberFormat($iDarkTotal))
$iOldDarkTotal = $iDarkTotal
EndIf
If $iOldTrophyTotal <> $iTrophyTotal And ($FirstAttack = 2 Or $ResetStats = 1) Then
GUICtrlSetData($lblTrophyLoot, _NumberFormat($iTrophyTotal))
$iOldTrophyTotal = $iTrophyTotal
EndIf
If $iOldGoldLast <> $iGoldLast Then
GUICtrlSetData($lblGoldLastAttack, _NumberFormat($iGoldLast))
$iOldGoldLast = $iGoldLast
EndIf
If $iOldElixirLast <> $iElixirLast Then
GUICtrlSetData($lblElixirLastAttack, _NumberFormat($iElixirLast))
$iOldElixirLast = $iElixirLast
EndIf
If $iOldDarkLast <> $iDarkLast Then
GUICtrlSetData($lblDarkLastAttack, _NumberFormat($iDarkLast))
$iOldDarkLast = $iDarkLast
EndIf
If $iOldTrophyLast <> $iTrophyLast Then
GUICtrlSetData($lblTrophyLastAttack, _NumberFormat($iTrophyLast))
$iOldTrophyLast = $iTrophyLast
EndIf
If $iOldGoldLastBonus <> $iGoldLastBonus Then
GUICtrlSetData($lblGoldBonusLastAttack, _NumberFormat($iGoldLastBonus))
$iOldGoldLastBonus = $iGoldLastBonus
EndIf
If $iOldElixirLastBonus <> $iElixirLastBonus Then
GUICtrlSetData($lblElixirBonusLastAttack, _NumberFormat($iElixirLastBonus))
$iOldElixirLastBonus = $iElixirLastBonus
EndIf
If $iOldDarkLastBonus <> $iDarkLastBonus Then
GUICtrlSetData($lblDarkBonusLastAttack, _NumberFormat($iDarkLastBonus))
$iOldDarkLastBonus = $iDarkLastBonus
EndIf
If $iOldCostGoldWall <> $iCostGoldWall Then
GUICtrlSetData($lblWallUpgCostGold, _NumberFormat($iCostGoldWall, True))
$iOldCostGoldWall = $iCostGoldWall
EndIf
If $iOldCostElixirWall <> $iCostElixirWall Then
GUICtrlSetData($lblWallUpgCostElixir, _NumberFormat($iCostElixirWall, True))
$iOldCostElixirWall = $iCostElixirWall
EndIf
If $iOldCostGoldBuilding <> $iCostGoldBuilding Then
GUICtrlSetData($lblBuildingUpgCostGold, _NumberFormat($iCostGoldBuilding, True))
$iOldCostGoldBuilding = $iCostGoldBuilding
EndIf
If $iOldCostElixirBuilding <> $iCostElixirBuilding Then
GUICtrlSetData($lblBuildingUpgCostElixir, _NumberFormat($iCostElixirBuilding, True))
$iOldCostElixirBuilding = $iCostElixirBuilding
EndIf
If $iOldCostDElixirHero <> $iCostDElixirHero Then
GUICtrlSetData($lblHeroUpgCost, _NumberFormat($iCostDElixirHero, True))
$iOldCostDElixirHero = $iCostDElixirHero
EndIf
If $iOldSkippedVillageCount <> $iSkippedVillageCount Then
GUICtrlSetData($lblresultvillagesskipped, _NumberFormat($iSkippedVillageCount, True))
GUICtrlSetData($lblResultSkippedHourNow, _NumberFormat($iSkippedVillageCount, True))
$iOldSkippedVillageCount = $iSkippedVillageCount
EndIf
If $iOldDroppedTrophyCount <> $iDroppedTrophyCount Then
GUICtrlSetData($lblresulttrophiesdropped, _NumberFormat($iDroppedTrophyCount, True))
$iOldDroppedTrophyCount = $iDroppedTrophyCount
EndIf
If $iOldNbrOfWallsUppedGold <> $iNbrOfWallsUppedGold Then
GUICtrlSetData($lblWallgoldmake, $iNbrOfWallsUppedGold)
$iOldNbrOfWallsUppedGold = $iNbrOfWallsUppedGold
WallsStatsMAJ()
EndIf
If $iOldNbrOfWallsUppedElixir <> $iNbrOfWallsUppedElixir Then
GUICtrlSetData($lblWallelixirmake, $iNbrOfWallsUppedElixir)
$iOldNbrOfWallsUppedElixir = $iNbrOfWallsUppedElixir
WallsStatsMAJ()
EndIf
If $iOldNbrOfBuildingsUppedGold <> $iNbrOfBuildingsUppedGold Then
GUICtrlSetData($lblNbrOfBuildingUpgGold, $iNbrOfBuildingsUppedGold)
$iOldNbrOfBuildingsUppedGold = $iNbrOfBuildingsUppedGold
EndIf
If $iOldNbrOfBuildingsUppedElixir <> $iNbrOfBuildingsUppedElixir Then
GUICtrlSetData($lblNbrOfBuildingUpgElixir, $iNbrOfBuildingsUppedElixir)
$iOldNbrOfBuildingsUppedElixir = $iNbrOfBuildingsUppedElixir
EndIf
If $iOldNbrOfHeroesUpped <> $iNbrOfHeroesUpped Then
GUICtrlSetData($lblNbrOfHeroUpg, $iNbrOfHeroesUpped)
$iOldNbrOfHeroesUpped = $iNbrOfHeroesUpped
EndIf
If $iOldSearchCost <> $iSearchCost Then
GUICtrlSetData($lblSearchCost, _NumberFormat($iSearchCost, True))
$iOldSearchCost = $iSearchCost
EndIf
If $iOldTrainCostElixir <> $iTrainCostElixir Then
GUICtrlSetData($lblTrainCostElixir, _NumberFormat($iTrainCostElixir, True))
$iOldTrainCostElixir = $iTrainCostElixir
EndIf
If $iOldTrainCostDElixir <> $iTrainCostDElixir Then
GUICtrlSetData($lblTrainCostDElixir, _NumberFormat($iTrainCostDElixir, True))
$iOldTrainCostDElixir = $iTrainCostDElixir
EndIf
If $iOldNbrOfOoS <> $iNbrOfOoS Then
GUICtrlSetData($lblNbrOfOoS, $iNbrOfOoS)
$iOldNbrOfOoS = $iNbrOfOoS
EndIf
If $iOldNbrOfTHSnipeFails <> $iNbrOfTHSnipeFails Then
GUICtrlSetData($lblNbrOfTSFailed, $iNbrOfTHSnipeFails)
$iOldNbrOfTHSnipeFails = $iNbrOfTHSnipeFails
EndIf
If $iOldNbrOfTHSnipeSuccess <> $iNbrOfTHSnipeSuccess Then
GUICtrlSetData($lblNbrOfTSSuccess, $iNbrOfTHSnipeSuccess)
$iOldNbrOfTHSnipeSuccess = $iNbrOfTHSnipeSuccess
EndIf
If $iOldGoldFromMines <> $iGoldFromMines Then
GUICtrlSetData($lblGoldFromMines, _NumberFormat($iGoldFromMines, True))
$iOldGoldFromMines = $iGoldFromMines
EndIf
If $iOldElixirFromCollectors <> $iElixirFromCollectors Then
GUICtrlSetData($lblElixirFromCollectors, _NumberFormat($iElixirFromCollectors, True))
$iOldElixirFromCollectors = $iElixirFromCollectors
EndIf
If $iOldDElixirFromDrills <> $iDElixirFromDrills Then
GUICtrlSetData($lblDElixirFromDrills, _NumberFormat($iDElixirFromDrills, True))
$iOldDElixirFromDrills = $iDElixirFromDrills
EndIf
If $iOldSmartZapGain <> $smartZapGain Then
GUICtrlSetData($lblSmartZap, _NumberFormat($smartZapGain, True))
$iOldSmartZapGain = $smartZapGain
EndIf
If $iOldNumLTSpellsUsed <> $numLSpellsUsed Then
GUICtrlSetData($lblLightningUsed, _NumberFormat($numLSpellsUsed, True))
$iOldNumLTSpellsUsed = $numLSpellsUsed
EndIf
If $iOldGainedXPHour <> $iGainedXPHour Then
GUICtrlSetData($lblXPSXWonHour, _NumberFormat($iGainedXPHour))
$iOldGainedXPHour = $iGainedXPHour
EndIf
$iAttackedCount = 0
For $i = 0 To $iModeCount
If $iOldAttackedVillageCount[$i] <> $iAttackedVillageCount[$i] Then
GUICtrlSetData($lblAttacked[$i], _NumberFormat($iAttackedVillageCount[$i], True))
$iOldAttackedVillageCount[$i] = $iAttackedVillageCount[$i]
EndIf
$iAttackedCount += $iAttackedVillageCount[$i]
If $iOldTotalGoldGain[$i] <> $iTotalGoldGain[$i] Then
GUICtrlSetData($lblTotalGoldGain[$i], _NumberFormat($iTotalGoldGain[$i], True))
$iOldTotalGoldGain[$i] = $iTotalGoldGain[$i]
EndIf
If $iOldTotalElixirGain[$i] <> $iTotalElixirGain[$i] Then
GUICtrlSetData($lblTotalElixirGain[$i], _NumberFormat($iTotalElixirGain[$i], True))
$iOldTotalElixirGain[$i] = $iTotalElixirGain[$i]
EndIf
If $iOldTotalDarkGain[$i] <> $iTotalDarkGain[$i] Then
GUICtrlSetData($lblTotalDElixirGain[$i], _NumberFormat($iTotalDarkGain[$i], True))
$iOldTotalDarkGain[$i] = $iTotalDarkGain[$i]
EndIf
If $iOldTotalTrophyGain[$i] <> $iTotalTrophyGain[$i] Then
GUICtrlSetData($lblTotalTrophyGain[$i], _NumberFormat($iTotalTrophyGain[$i], True))
$iOldTotalTrophyGain[$i] = $iTotalTrophyGain[$i]
EndIf
Next
If $iOldAttackedCount <> $iAttackedCount Then
GUICtrlSetData($lblresultvillagesattacked, _NumberFormat($iAttackedCount, True))
GUICtrlSetData($lblResultAttackedHourNow, _NumberFormat($iAttackedCount, True))
$iOldAttackedCount = $iAttackedCount
EndIf
For $i = 0 To $iModeCount
If $i = $TS Then ContinueLoop
If $iOldNbrOfDetectedMines[$i] <> $iNbrOfDetectedMines[$i] Then
GUICtrlSetData($lblNbrOfDetectedMines[$i], $iNbrOfDetectedMines[$i])
$iOldNbrOfDetectedMines[$i] = $iNbrOfDetectedMines[$i]
EndIf
If $iOldNbrOfDetectedCollectors[$i] <> $iNbrOfDetectedCollectors[$i] Then
GUICtrlSetData($lblNbrOfDetectedCollectors[$i], $iNbrOfDetectedCollectors[$i])
$iOldNbrOfDetectedCollectors[$i] = $iNbrOfDetectedCollectors[$i]
EndIf
If $iOldNbrOfDetectedDrills[$i] <> $iNbrOfDetectedDrills[$i] Then
GUICtrlSetData($lblNbrOfDetectedDrills[$i], $iNbrOfDetectedDrills[$i])
$iOldNbrOfDetectedDrills[$i] = $iNbrOfDetectedDrills[$i]
EndIf
Next
If $FirstAttack = 2 Then
GUICtrlSetData($lblHourlyStatsGold, _NumberFormat(Round($iGoldTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600)) & "K / h")
GUICtrlSetData($lblHourlyStatsElixir, _NumberFormat(Round($iElixirTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600)) & "K / h")
If $iDarkStart <> "" Then
GUICtrlSetData($lblHourlyStatsDark, _NumberFormat(Round($iDarkTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600 * 1000)) & " / h")
EndIf
GUICtrlSetData($lblHourlyStatsTrophy, _NumberFormat(Round($iTrophyTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600 * 1000)) & " / h")
GUICtrlSetData($lblResultGoldHourNow, _NumberFormat(Round($iGoldTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600)) & "K / h")
GUICtrlSetData($lblResultElixirHourNow, _NumberFormat(Round($iElixirTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600)) & "K / h")
If $iDarkStart <> "" Then
GUICtrlSetData($lblResultDEHourNow, _NumberFormat(Round($iDarkTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600 * 1000)) & " / h")
EndIf
EndIf
If $ResetStats = 1 Then
$ResetStats = 0
EndIf
EndFunc
Func ResetStats()
$ResetStats = 1
$FirstAttack = 0
$iTimePassed = 0
$sTimer = TimerInit()
GUICtrlSetData($lblresultruntime, "00:00:00")
GUICtrlSetData($lblResultRuntimeNow, "00:00:00")
GUICtrlSetState($lblLastAttackTemp, $GUI_SHOW)
GUICtrlSetState($lblLastAttackBonusTemp, $GUI_SHOW)
GUICtrlSetState($lblTotalLootTemp, $GUI_SHOW)
GUICtrlSetState($lblHourlyStatsTemp, $GUI_SHOW)
$iGoldStart = $iGoldCurrent
$iElixirStart = $iElixirCurrent
$iDarkStart = $iDarkCurrent
$iTrophyStart = $iTrophyCurrent
$iGoldTotal = 0
$iElixirTotal = 0
$iDarkTotal = 0
$iTrophyTotal = 0
$iGoldLast = 0
$iElixirLast = 0
$iDarkLast = 0
$iTrophyLast = 0
$iGoldLastBonus = 0
$iElixirLastBonus = 0
$iDarkLastBonus = 0
$iSkippedVillageCount = 0
$iDroppedTrophyCount = 0
$iCostGoldWall = 0
$iCostElixirWall = 0
$iCostGoldBuilding = 0
$iCostElixirBuilding = 0
$iCostDElixirHero = 0
$iNbrOfWallsUppedGold = 0
$iNbrOfWallsUppedElixir = 0
$iNbrOfBuildingsUppedGold = 0
$iNbrOfBuildingsUppedElixir = 0
$iNbrOfHeroesUpped = 0
$iSearchCost = 0
$iTrainCostElixir = 0
$iTrainCostDElixir = 0
$iNbrOfOoS = 0
$iNbrOfTHSnipeFails = 0
$iNbrOfTHSnipeSuccess = 0
$iGoldFromMines = 0
$iElixirFromCollectors = 0
$iDElixirFromDrills = 0
$smartZapGain = 0
$numLSpellsUsed = 0
For $i = 0 To $iModeCount
$iAttackedVillageCount[$i] = 0
$iTotalGoldGain[$i] = 0
$iTotalElixirGain[$i] = 0
$iTotalDarkGain[$i] = 0
$iTotalTrophyGain[$i] = 0
$iNbrOfDetectedMines[$i] = 0
$iNbrOfDetectedCollectors[$i] = 0
$iNbrOfDetectedDrills[$i] = 0
Next
UpdateStats()
EndFunc
Func CheckVersion()
If $ichkVersion = 1 Then
CheckVersionHTML()
If $lastModversion = "" Then
SetLog("WE CANNOT OBTAIN MOD VERSION AT THIS TIME", $COLOR_ORANGE)
CheckModVersion()
ElseIf VersionNumFromVersionTXT($sModversion) < VersionNumFromVersionTXT($lastModversion) Then
SetLog("WARNING, YOUR MOD VERSION (" & $sModversion & ") IS OUT OF DATE.", $COLOR_RED)
SetLog("CHIEF, PLEASE DOWNLOAD THE LATEST (" & $lastModversion & ")", $COLOR_RED)
SetLog("FROM https://MyBot.run               ", $COLOR_RED)
SetLog(" ")
_PrintLogVersion($oldModversmessage)
CheckModVersion()
ElseIf VersionNumFromVersionTXT($sModversion) > VersionNumFromVersionTXT($lastModversion) Then
SetLog("YOU ARE USING A FUTURE MOD BY DOC.OC VERSION CHIEF!", $COLOR_GREEN)
SetLog("YOUR MOD VERSION: " & $sModversion, $COLOR_GREEN)
SetLog("OFFICIAL MOD VERSION: " & $lastModversion, $COLOR_GREEN)
SetLog(" ")
Else
SetLog("WELCOME CHIEF, YOU HAVE THE LATEST MOD VERSION", $COLOR_GREEN)
SetLog(" ")
SetLog("BY DOC.OC TEAM", $COLOR_BLUE)
SetLog("CHEEERS..")
SetLog(" ")
_PrintLogVersion($lastmessage)
EndIf
EndIf
EndFunc
Func CheckVersionHTML()
Local $versionfile = @ScriptDir & "\LastVersion.txt"
If FileExists(@ScriptDir & "\TestVersion.txt") Then
FileCopy(@ScriptDir & "\TestVersion.txt", $versionfile, 1)
Else
$hDownload = InetGet("https://raw.githubusercontent.com/TheRevenor/MyBotRun_DocOC_Server/master/Version/LastVersions.txt", $versionfile, 0, 1)
Local $i = 0
Do
Sleep($iDelayCheckVersionHTML1)
$i += 1
Until InetGetInfo($hDownload, $INET_DOWNLOADCOMPLETE) Or $i > 25
InetClose($hDownload)
EndIf
Local $f, $f2, $line, $line2, $Casesense = 0, $chkvers = False, $chkmsg = False, $chkmsg2 = False, $i = 0
$lastModversion = ""
If FileExists($versionfile) Then
$f = FileOpen($versionfile, 0)
$lastModversion = IniRead($versionfile,"mod","version","")
Local $versionfilelocalized = @ScriptDir & "\LastVersion_" & $sLanguage & ".txt"
If FileExists(@ScriptDir & "\TestVersion_" & $sLanguage & ".txt") Then
FileCopy(@ScriptDir & "\TestVersion_" & $sLanguage & ".txt", $versionfilelocalized, 1)
Else
$hDownload = InetGet("https://raw.githubusercontent.com/TheRevenor/MyBotRun_DocOC_Server/master/Version/LastVersions_" & $sLanguage & ".txt", $versionfilelocalized, 0, 1)
Local $i = 0
Do
Sleep($iDelayCheckVersionHTML1)
$i += 1
Until InetGetInfo($hDownload, $INET_DOWNLOADCOMPLETE) Or $i > 25
InetClose($hDownload)
EndIf
If FileExists($versionfilelocalized) Then
$f2 = FileOpen($versionfilelocalized, 0)
$lastModmessage = IniRead($versionfilelocalized,"mod","messagenew","")
$oldModversmessage = IniRead($versionfilelocalized,"mod","messageold","")
FileClose($f2)
FileDelete($versionfilelocalized)
Else
$lastModmessage = IniRead($versionfilelocalized,"mod","messagenew","")
$oldModversmessage = IniRead($versionfilelocalized,"mod","messageold","")
EndIf
FileClose($f)
FileDelete($versionfile)
EndIf
EndFunc
Func VersionNumFromVersionTXT($versionTXT)
Local $versionTXT_clean
If StringInStr($versionTXT, " ") Then
$versionTXT_clean = StringLeft($versionTXT, StringInStr($versionTXT, " ") - 1)
Else
$versionTXT_clean = $versionTXT
EndIf
Local $resultnumber = 0
If StringLeft($versionTXT_clean, 1) = "v" Then
Local $versionTXT_Vector = StringSplit(StringMid($versionTXT_clean, 2, -1), ".")
Local $multiplier = 1000000
If UBound($versionTXT_Vector) > 0 Then
For $i = 1 To UBound($versionTXT_Vector) - 1
$resultnumber = $resultnumber + Number($versionTXT_Vector[$i]) * $multiplier
$multiplier = $multiplier / 1000
Next
Else
$resultnumber = Number($versionTXT_Vector) * $multiplier
EndIf
EndIf
Return $resultnumber
EndFunc
Func _PrintLogVersion($message)
Local $messagevet = StringSplit($message, "\n", 1)
If Not (IsArray($messagevet)) Then
Setlog($message)
Else
For $i = 1 To $messagevet[0]
If StringLen($messagevet[$i]) <= 53 Then
SetLog($messagevet[$i], $COLOR_BLACK, "Lucida Console", 8.5)
Else
While StringLen($messagevet[$i]) > 53
Local $sp = StringInStr(StringLeft($messagevet[$i], 53), " ", 0, -1)
If $sp = 0 Then
Local $sp = StringInStr($messagevet[$i], " ", 0)
If $sp = 0 Then
SetLog($messagevet[$i], $COLOR_BLACK, "Lucida Console", 8.5)
Else
SetLog(StringLeft($messagevet[$i], $sp), $COLOR_BLACK, "Lucida Console", 8.5)
$messagevet[$i] = StringMid($messagevet[$i], $sp + 1, -1)
EndIf
Else
SetLog(StringLeft($messagevet[$i], $sp), $COLOR_BLACK, "Lucida Console", 8.5)
$messagevet[$i] = StringMid($messagevet[$i], $sp + 1, -1)
EndIf
WEnd
If StringLen($messagevet[$i]) > 0 Then SetLog($messagevet[$i], $COLOR_BLACK, "Lucida Console", 8.5)
EndIf
Next
EndIf
EndFunc
Func GetVersionNormalized($VersionString, $Chars = 5)
If StringLeft($VersionString, 1) = "v" Then $VersionString = StringMid($VersionString, 2)
Local $a = StringSplit($VersionString, ".", 2)
Local $i
For $i = 0 To UBound($a) - 1
If StringLen($a[$i]) < $Chars Then $a[$i] = _StringRepeat("0", $Chars - StringLen($a[$i])) & $a[$i]
Next
Return _ArrayToString($a, ".")
EndFunc
Func CheckModVersion()
If $lastModversion = "" Then
MsgBox($MB_ICONWARNING, "", "WE CANNOT OBTAIN MOD VERSION AT THIS TIME" &  @CRLF &  "BAD CONNECTION", 10)
ElseIf VersionNumFromVersionTXT($sModversion) < VersionNumFromVersionTXT($lastModversion) Then
PushMsg("Update")
If MsgBox(BitOr($MB_ICONWARNING, $MB_YESNO), "BOT Update Detected", "Chief, there is a new version of the bot available (" & $lastModversion & ")" & @CRLF &  @CRLF &  "Do you want to download the latest version ?", 30) = $IDYES Then
ShellExecute($sModSupportUrl)
Return False
EndIf
Else
MsgBox($MB_ICONINFORMATION, "Notify", "You Are Using The Latest Version Of Mod By DocOc Team" &  @CRLF &  "Thanks..", 15)
EndIf
EndFunc
Func CloseRunningBot($sBotWindowTitle)
Local $otherHWnD = WinGetHandle($sBotTitle)
If @error = 0 Then
Local $otherPID = WinGetProcess($otherHWnD)
SetDebugLog("Found existing " & $sBotTitle & " instance to close, PID " & $otherPID & ", HWnD " & $otherHWnD)
If WinClose($otherHWnD) = 1 Then
SetDebugLog("Existing bot window closed")
EndIf
If WinWaitClose($otherHWnD, "", 10) = 0 Then
SetDebugLog("Existing bot window still there...")
WinKill($otherHWnD)
SetDebugLog("Existing bot window killed")
EndIf
If ProcessExists($otherPID) = $otherPID Then
SetDebugLog("Existing bot process still there...")
If ProcessClose($otherPID) = 1 Then
SetDebugLog("Existing bot process now closed")
Return True
Else
Switch @error
Case 1
SetDebugLog("Existing bot process close error: OpenProcess failed")
Case 2
SetDebugLog("Existing bot process close error: AdjustTokenPrivileges Failed")
Case 3
SetDebugLog("Existing bot process close error: TerminateProcess Failed")
Case 4
SetDebugLog("Existing bot process close error: Cannot verify if process exists")
EndSwitch
Return False
EndIf
EndIf
Return True
EndIf
Return False
EndFunc
Func WindowSystemMenu($HWnD, $iButton, $Action = Default, $DebugInfo = "")
Local $hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, False)
If $Action = Default Then
Return _GUICtrlMenu_GetItemID($hSysMenu, $iButton, False) <> 0
EndIf
Local $enabled = WindowSystemMenu($HWnD, $iButton)
If $Action <> $enabled Then
Local $i, $c = _GUICtrlMenu_GetItemCount($hSysMenu)
Local $aVisible[$c]
For $i = 0 To $c - 1
$aVisible[$i] = _GUICtrlMenu_GetItemID($hSysMenu, $i)
Next
_GUICtrlMenu_GetSystemMenu($HWnD, True)
$hSysMenu = _GUICtrlMenu_GetSystemMenu($HWnD, False)
_GUICtrlMenu_DrawMenuBar($HWnD)
$c = _GUICtrlMenu_GetItemCount($hSysMenu)
If $DebugInfo = "" Then $DebugInfo = $iButton
For $i = 0 To $c - 1
Local $id = _GUICtrlMenu_GetItemID($hSysMenu, $i)
If $id = $iButton Then
If $Action = False Then
SetDebugLog("Hide SystemMenu Item: " & $DebugInfo)
_GUICtrlMenu_RemoveMenu($hSysMenu, $i)
Else
SetDebugLog("Show SystemMenu Item: " & $DebugInfo)
EndIf
ElseIf  _ArraySearch($aVisible, $id) = -1 Then
_GUICtrlMenu_RemoveMenu($hSysMenu, $i)
EndIf
Next
EndIf
EndFunc
Global Const $__FILE_BEGIN   = 0
Global Const $__FILE_CURRENT = 1
Func _ImageGetInfo($sFile)
Local $sInfo = "", $hFile, $nClr, $error
Local $nFileSize = FileGetSize($sFile)
Local $ret = DllCall("kernel32.dll","int","CreateFile",  "str",$sFile,  "int",0x80000000,  "int",0,  "ptr",0,  "int",3,  "int",0x80,  "ptr",0)
If @error OR ($ret[0] = 0) Then Return SetError(1, 0, "")
$hFile = $ret[0]
Local $asIdent[7] = ["0xFFD8", "0x424D", "0x89504E470D0A1A0A", "0x4749463839", "0x4749463837", "0x4949", "0x4D4D"]
Local $p = _FileReadToStructAtOffset("ubyte[54]", $hFile, 0)
For $i = 0 To UBound($asIdent) - 1
If BinaryMid(DllStructGetData($p, 1), 1, BinaryLen($asIdent[$i])) = $asIdent[$i] Then
Switch $i
Case 0
$sInfo = _ParseJPEG($hFile, $nFileSize)
$error = @error
Case 1
Local $t = DllStructCreate("int;int;short;short;dword;dword;dword;dword", DllStructGetPtr($p) + 18)
_Add($sInfo, "Width",  DllStructGetData($t, 1))
_Add($sInfo, "Height", DllStructGetData($t, 2))
_Add($sInfo, "ColorDepth", DllStructGetData($t, 4))
_Add($sInfo, "XResolution", Round(DllStructGetData($t, 7)/39.37))
_Add($sInfo, "YResolution", Round(DllStructGetData($t, 8)/39.37))
_Add($sInfo, "ResolutionUnit", "Inch")
Case 2
$sInfo = _ParsePNG($hFile, $nFileSize)
$error = @error
Case 3, 4
$t = DllStructCreate("short;short;ubyte", DllStructGetPtr($p) + 6)
_Add($sInfo, "Width",  DllStructGetData($t, 1))
_Add($sInfo, "Height", DllStructGetData($t, 2))
$nClr = DllStructGetData($t, 3)
_Add($sInfo, "ColorDepth", _IsBitSet($nClr, 0) + _IsBitSet($nClr, 1)*2 + _IsBitSet($nClr, 2)*4 + 1)
Case 5, 6
$sInfo = _ParseTIFF($hFile, 0)
EndSwitch
Exitloop
Endif
Next
DllCall("kernel32.dll","int","CloseHandle","int", $hFile)
Return SetError($error, 0, $sInfo)
EndFunc
Func _ImageGetParam($sInfo, $sParam)
Local $aParam = StringRegExp($sInfo, "(?m)^" & $sParam & "=(.*)$", 1)
If IsArray($aParam) Then
Return $aParam[0]
Else
SetError(1, 0, "")
EndIf
EndFunc
Func _ParsePNG($hFile, $nFileSize)
Local $sInfo = "", $nBlockSize, $nID = 0, $t
Local $nBPP, $nCol, $sAlpha = ""
Local $nXRes, $nYRes
Local $sKeyword, $nKWLen
Local $pBlockID = DllStructCreate("ulong;ulong")
_FileSetPointer($hFile, 8, $__FILE_BEGIN)
While $nID <> 0x49454E44
$pBlockID = _FileReadToStruct($pBlockID, $hFile)
$nBlockSize = _IntR32(DllStructGetData($pBlockID, 1))
If $nBlockSize > $nFileSize Then Return SetError(2, 0, $sInfo)
$nID = _IntR32(DllStructGetData($pBlockID, 2))
Switch $nID
Case 0x49484452
$t = _FileReadToStruct("align 1;ulong;ulong;byte;byte;byte;byte;byte", $hFile)
_Add($sInfo, "Width",  _IntR32(DllStructGetData($t, 1)))
_Add($sInfo, "Height", _IntR32(DllStructGetData($t, 2)))
$nBPP = DllStructGetData($t, 3)
$nCol = DllStructGetData($t, 4)
If $nCol > 3 Then
$nCol = $nCol - 4
$sAlpha = " + alpha"
Endif
If $nCol < 3 Then $nBPP = ($nCol + 1) * $nBPP
_Add($sInfo, "ColorDepth", $nBPP & $sAlpha)
_Add($sInfo, "Interlace", DllStructGetData($t, 7))
Case 0x70485973
$t = _FileReadToStruct("align 1;ulong;ulong;ubyte", $hFile)
$nXRes = _IntR32(DllStructGetData($t, 1))
$nYRes = _IntR32(DllStructGetData($t, 2))
If DllStructGetData($t, 3) = 1 Then
$nXRes = Round($nXRes/39.37)
$nYRes = Round($nYRes/39.37)
Endif
_Add($sInfo, "XResolution", $nXRes)
_Add($sInfo, "YResolution", $nYRes)
_Add($sInfo, "ResolutionUnit", "Inch")
Case 0x74455874
$t = _FileReadToStruct("char[80]", $hFile)
$sKeyword = DllStructGetData($t, 1)
$nKWLen = StringLen($sKeyword) + 1
_FileSetPointer($hFile, -80 + $nKWLen, $__FILE_CURRENT)
$t = _FileReadToStruct("char[" & $nBlockSize - $nKWLen & "]", $hFile)
_Add($sInfo, $sKeyword, DllStructGetData($t, 1))
Case 0x74494D45
$t = _FileReadToStruct("align 1;ushort;ubyte;ubyte;ubyte;ubyte;ubyte", $hFile)
_Add($sInfo, "DateTime", StringFormat("%4d-%02d-%02d %02d:%02d:%02d",  DllStructGetData($t, 1), DllStructGetData($t, 2),  DllStructGetData($t, 3), DllStructGetData($t, 4),  DllStructGetData($t, 5), DllStructGetData($t, 6)))
Case Else
_FileSetPointer($hFile, $nBlockSize + 4, $__FILE_CURRENT)
ContinueLoop
EndSwitch
_FileSetPointer($hFile, 4, $__FILE_CURRENT)
Wend
Return $sInfo
EndFunc
Func _ParseJPEG($hFile, $nFileSize)
Local $nPos = 2, $nMarker = 0, $sInfo = ""
Local $nSegSize, $pSegment, $t
_FileSetPointer($hFile, 2, $__FILE_BEGIN)
Local $p = DllStructCreate("align 1;ubyte;ubyte;ushort")
While ($nMarker <> 0xDA) and ($nPos < $nFileSize)
$p = _FileReadToStruct($p, $hFile)
If DllStructGetData($p, 1) = 0xFF Then
$nMarker = DllStructGetData($p, 2)
$nSegSize = _IntR16(DllStructGetData($p, 3))
$pSegment = _FileReadToStruct("byte[" & $nSegSize - 2 & "]", $hFile)
Switch $nMarker
Case 0xC0 To 0xC3, 0xC5 To 0xC7, 0xCB, 0xCD To 0xCF
Switch $nMarker
Case 0xC2, 0xC6, 0xCA, 0xCE
_Add($sInfo, "Progressive", "True")
Case 0xC3, 0xC7, 0xCB, 0xCF
_Add($sInfo, "Lossless", "True")
EndSwitch
Switch $nMarker
Case 0xC0 To 0xC3, 0xC5 To 0xC7
_Add($sInfo, "Compression", "Huffman")
Case 0xC9 To 0xCB, 0xCD To 0xCF
_Add($sInfo, "Compression", "Arithmetic")
EndSwitch
$t = DllStructCreate("align 1;byte;ushort;ushort", DllStructGetPtr($pSegment))
_Add($sInfo, "Width",  _IntR16(DllStructGetData($t, 3)))
_Add($sInfo, "Height", _IntR16(DllStructGetData($t, 2)))
Case 0xE0
$t = DllStructCreate("byte[5];byte;byte;ubyte;ushort;ushort", DllStructGetPtr($pSegment))
_Add($sInfo, "XResolution", _IntR16(DllStructGetData($t, 5)))
_Add($sInfo, "YResolution", _IntR16(DllStructGetData($t, 6)))
_AddArray($sInfo, "ResolutionUnit", _IntR16(DllStructGetData($t, 4)), "Pixel;Inch;Cm")
Case 0xE1
$sInfo = $sInfo & _ParseTIFF($hFile, $nPos + 10)
_FileSetPointer($hFile, $nPos + $nSegSize + 2, $__FILE_BEGIN)
Case 0xFE
$t = DllStructCreate("char[" & $nSegSize - 2 & "]", DllStructGetPtr($pSegment))
_Add($sInfo, "Comment", StringStripWS(DllStructGetData($t, 1), 3))
EndSwitch
$nPos= $nPos + $nSegSize + 2
Else
Return SetError(2, 0, $sInfo)
Endif
Wend
Return($sInfo)
EndFunc
Func _ParseTIFF($hFile, $nTiffHdrOffset = 0)
Local $pHdr, $nIFDOffset, $pCnt, $nIFDCount, $pTag, $nCnt, $nID, $nEIFDCount
Local $ByteOrder = 0, $sInfo = ""
Local $nEIFDOffset, $nSubID
$pHdr = _FileReadToStructAtOffset("short;short;dword", $hFile, $nTiffHdrOffset)
If DllStructGetData($pHdr, 1) = 0x4D4D then $ByteOrder = 1
$nIFDOffset = _IntR32(DllStructGetData($pHdr, 3), $ByteOrder)
$pCnt = _FileReadToStructAtOffset("ushort", $hFile, $nTiffHdrOffset + $nIFDOffset)
$nIFDCount = _IntR16(DllStructGetData($pCnt, 1), $ByteOrder)
$pTag = DllStructCreate("ushort;ushort;ulong;ulong")
For $nCnt = 0 To $nIFDCount - 1
$pTag = _FileReadToStructAtOffset($pTag, $hFile, $nTiffHdrOffset + $nIFDOffset + 2 + $nCnt * 12)
$nID = _IntR16(DllStructGetData($pTag, 1), $ByteOrder)
Switch $nID
Case 0x8769, 0x8825
$nEIFDOffset = _ReadTag($hFile, $pTag, $nTiffHdrOffset, $ByteOrder)
$pCnt = _FileReadToStructAtOffset($pCnt, $hFile, $nTiffHdrOffset + $nEIFDOffset)
$nEIFDCount = _IntR16(DllStructGetData($pCnt, 1), $ByteOrder)
For $i = 0 To $nEIFDCount - 1
$pTag = _FileReadToStructAtOffset($pTag, $hFile, $nTiffHdrOffset + $nEIFDOffset + 2 + $i * 12)
$nSubID = _IntR16(DllStructGetData($pTag, 1), $ByteOrder)
Switch $nID
Case 0x8769
_AddExifTag($sInfo, $nSubID, _ReadTag($hFile, $pTag, $nTiffHdrOffset, $ByteOrder))
Case 0x8825
_AddGpsTag($sInfo, $nSubID, _ReadTag($hFile, $pTag, $nTiffHdrOffset, $ByteOrder))
EndSwitch
Next
Case 0xA005
Case 0x014A
Case 0x0190
Case Else
_AddTiffTag($sInfo, $nID, _ReadTag($hFile, $pTag, $nTiffHdrOffset, $ByteOrder))
EndSwitch
Next
Return($sInfo)
EndFunc
Func _ReadTag($hFile, $pTag, $nHdrOffset, $ByteOrder)
Local $nType   = _IntR16(DllStructGetData($pTag, 2), $ByteOrder)
Local $nCount  = _IntR32(DllStructGetData($pTag, 3), $ByteOrder)
Local $nOffset = _IntR32(DllStructGetData($pTag, 4), $ByteOrder) + $nHdrOffset
Local $p
Switch $nType
Case 2
$p = _FileReadToStructAtOffset("char[" & $nCount & "]", $hFile, $nOffset)
Return DllStructGetData($p, 1)
Case 1
Return BitAND(DllStructGetData($pTag, 4), 0xFF)
Case 3
If $nCount > 1 Then
If $nCount > 2 Then
$p = _FileReadToStructAtOffset("short[" & $nCount & "]", $hFile, $nOffset)
Else
$p = DllStructCreate("short[2]", DllStructGetPtr($pTag, 4))
EndIf
Local $aRet[$nCount]
For $i = 1 To $nCount
$aRet[$i-1] = _IntR16(DllStructGetData($p, 1, $i), $ByteOrder)
Next
Return $aRet
Else
Return _IntR16(BitAND(DllStructGetData($pTag, 4), 0xFFFF), $ByteOrder)
EndIf
Case 4
If $nCount > 1 Then
$p = _FileReadToStructAtOffset("short[" & $nCount & "]", $hFile, $nOffset)
Local $aRet[$nCount]
For $i = 1 To $nCount
$aRet[$i-1] = _IntR32(DllStructGetData($p, 1, $i), $ByteOrder)
Next
Return $aRet
Else
Return _IntR32(DllStructGetData($pTag, 4), $ByteOrder)
EndIf
Case 5
$p = _FileReadToStructAtOffset("ulong;ulong", $hFile, $nOffset)
Return _IntR32(DllStructGetData($p, 1), $ByteOrder) / _IntR32(DllStructGetData($p, 2), $ByteOrder)
Case 7
$p = _FileReadToStructAtOffset("byte[" & $nCount & "]", $hFile, $nOffset)
Return DllStructGetData($p, 1)
Case 9
$p = DllStructCreate("long", DllStructGetPtr($pTag, 4))
Return _IntR32(DllStructGetData($p, 1), $ByteOrder)
Case 10
$p = _FileReadToStructAtOffset("dword;dword", $hFile, $nOffset)
Return _IntR32(DllStructGetData($p, 1), $ByteOrder) / _IntR32(DllStructGetData($p, 2), $ByteOrder)
Case Else
Return SetError(1, 0, "")
EndSwitch
EndFunc
Func _AddTiffTag(ByRef $sInfo, $nID, $vTag)
Local $p, $vTemp = ""
Switch $nID
Case 0x00FE
Select
Case _IsBitSet($vTag, 0)
$vTemp = "Reduced image"
Case _IsBitSet($vTag, 1)
$vTemp = "Page"
Case _IsBitSet($vTag, 2)
$vTemp = "Mask"
EndSelect
_Add($sInfo, "NewSubfileType", $vTemp)
Case 0x0100
_Add($sInfo, "Width", $vTag)
Case 0x0101
_Add($sInfo, "Height", $vTag)
Case 0x0102
If IsArray($vTag) Then
$vTemp = 0
For $i = 0 To UBound($vTag) - 1
$vTemp += $vTag[$i]
Next
_Add($sInfo, "Colordepth", $vTemp)
Else
_Add($sInfo, "Colordepth", $vTag)
EndIf
Case 0x0103
Switch $vTag
Case 32773
_Add($sInfo, "Compression", "Packbits")
Case Else
_AddArray($sInfo, "Compression", $vTag, ";No compression;CCITT modified Huffman RLE;CCITT Group 3 fax encoding;" &  "CCITT Group 4 fax encoding;LZW;JPEG (old);JPEG;Deflate;JBIG on B/W;JBIG on color","Unknown")
EndSwitch
Case 0x0106
Switch $vTag
Case 32803
_Add($sInfo, "PhotometricInterpretation", "LOGL")
$vTemp = "LOGL"
Case 34892
_Add($sInfo, "PhotometricInterpretation", "LOGLUV")
Case Else
_AddArray($sInfo, "PhotometricInterpretation", $vTag, "MINISWHITE;MINISBLACK;RGB;PALETTE;MASK;SEPARATED;YCBCR;CIELAB;ICCLAB;ITULAB")
EndSwitch
Case 0x0107
_AddArray($sInfo, "Threshholding", $vTag, ";BiLevel;Halftone;Error Diffusion")
Case 0x0108
_Add($sInfo, "CellWidth", $vTemp)
Case 0x0109
_Add($sInfo, "CellLength", $vTemp)
Case 0x010E
_Add($sInfo, "ImageDescription", $vTag)
Case 0x010F
_Add($sInfo, "Make", $vTag)
Case 0x0110
_Add($sInfo, "Model", $vTag)
Case 0x0112
_AddArray($sInfo, "Orientation", $vTag, ";Normal;Mirrored;180°;180° and mirrored;90° left and mirrored;90° right;90° right and mirrored;90° left")
Case 0x0115
_Add($sInfo, "SamplesPerPixel", $vTag)
Case 0x011A
_Add($sInfo, "XResolution", $vTag)
Case 0x011B
_Add($sInfo, "YResolution", $vTag)
Case 0x0128
_AddArray($sInfo, "ResolutionUnit", $vTag, ";;Inch;Centimeter")
Case 0x0131
_Add($sInfo, "Software", $vTag)
Case 0x0132
_Add($sInfo, "DateTime", $vTag)
Case 0x013B
_Add($sInfo, "Artist", $vTag)
Case 0x013C
_Add($sInfo, "HostComputer", $vTag)
Case 0x0152
_AddArray($sInfo, "ExtraSamples", $vTag, ";Associated alpha;Unassociated alpha","Unspecified")
Case 0x8298
_Add($sInfo, "Copyright", $vTag)
Case 0x010D
_Add($sInfo, "DocumentName", $vTag)
Case 0x011D
_Add($sInfo, "PageName", $vTag)
Case 0x011E
_Add($sInfo, "XPosition", $vTag)
Case 0x011F
_Add($sInfo, "YPosition", $vTag)
Case 0x0129
If IsArray($vTag) Then
_Add($sInfo, "PageNumber", $vTag[0] & "/" & $vTag[1])
EndIf
Case 0x013E
_Add($sInfo, "WhitePoint", $vTag)
Case 0x0146
_Add($sInfo, "BadFaxLines", $vTag)
Case 0x0147
_AddArray($sInfo, "CleanFaxData", $vTag, "Clean;Regenerated;Unclean")
Case 0x0148
_Add($sInfo, "ConsecutiveBadFaxLines", $vTag)
Case 0x014C
_AddArray($sInfo, "InkSet", $vTag, ";CMYK", "No CMYK")
Case 0x014E
_Add($sInfo, "NumberOfInks", $vTag)
Case 0x0151
_Add($sInfo, "TargetPrinter", $vTag)
Case 0x015A
_AddArray($sInfo, "Indexed", $vTag, "Not indexed;Indexed")
Case 0x0191
_AddArray($sInfo, "ProfileType", $vTag, ";Group 3 fax","Unspecified")
Case 0x02BC
_Add($sInfo, "XMP", $vTag)
EndSwitch
EndFunc
Func _AddExifTag(ByRef $sInfo, $nID, $vTag)
Local $vTemp = ""
Switch $nID
Case 0x829A
_Add($sInfo, "ExposureTime", $vTag)
Case 0x829D
_Add($sInfo, "FNumber", $vTag)
Case 0x8822
_AddArray($sInfo, "ExposureProgram", $vTag, "Undefined;Manual;Normal;Aperture priority;Shutter priority;Creative;Action;Portrait mode;Landscape mode")
Case 0x8824
_Add($sInfo, "SpectralSensitivity", $vTag)
Case 0x8827
_Add($sInfo, "ISO", $vTag)
Case 0x9000
_Add($sInfo, "ExifVersion", $vTag)
Case 0x9003
_Add($sInfo, "DateTimeOriginal", $vTag)
Case 0x9004
_Add($sInfo, "DateTimeDigitized", $vTag)
Case 0x9101
Switch BinaryMid($vTag, 1, 1)
Case 0x34
$vTemp = "RGB"
Case 0x31
$vTemp = "YCbCr"
Case Else
$vTemp = "Undefined"
EndSwitch
_Add($sInfo, "ComponentsConfiguration", $vTemp)
Case 0x9102
_Add($sInfo, "CompressedBitsPerPixel", $vTag)
Case 0x9201
_Add($sInfo, "ShutterSpeedValue", $vTag)
Case 0x9202
_Add($sInfo, "ApertureValue", $vTag)
Case 0x9203
_Add($sInfo, "BrightnessValue", $vTag)
Case 0x9204
_Add($sInfo, "ExposureBiasValue", $vTag)
Case 0x9205
_Add($sInfo, "MaxApertureValue", $vTag)
Case 0x9206
_Add($sInfo, "SubjectDistance", $vTag)
Case 0x9207
_AddArray($sInfo, "MeteringMode", $vTag, "Unknown;Average;Center Weighted Average;Spot;MultiSpot;MultiSegment;Partial;Other")
Case 0x9208
If $vTag = 255 Then
_Add($sInfo, "LightSource", "Other")
Else
_AddArray($sInfo, "LightSource", $vTag, "Unknown;Daylight;Fluorescent;Tungsten;Flash;;;;;Fine weather;Cloudy weather;Shade;" &  "Daylight fluorescent;Day white fluorescent;Cool white fluorescent;White fluorescent;;" &  "Standard light A;Standard light B;Standard light C;D55;D65;D75;D50;ISO studio tungsten")
EndIf
Case 0x9209
If _IsBitSet($vTag, 0) Then
$vTemp = "Fired, "
Else
$vTemp = "Not fired, "
EndIf
Switch _IsBitSet($vTag, 4) * 2 + _IsBitSet($vTag, 3)
Case 1
$vTemp &= "Forced ON, "
Case 2
$vTemp &= "Forced OFF, "
Case 3
$vTemp &= "Auto, "
EndSwitch
If _IsBitSet($vTag, 6) Then $vTemp &= "Red-eye reduction, "
_Add($sInfo, "Flash", StringTrimRight($vTemp, 2))
Case 0x920A
_Add($sInfo, "FocalLength", $vTag)
Case 0x9214
If IsArray($vTag) Then
Switch UBound($vTag)
Case 2
$vTemp = StringFormat("Point, %d:%d", $vTag[0], $vTag[1])
Case 3
$vTemp = StringFormat("Circle, Center %d:%d, Diameter %d", $vTag[0], $vTag[1], $vTag[2])
Case 4
$vTemp = StringFormat("Square, Center %d:%d, Width %d, Height %d", $vTag[0], $vTag[1], $vTag[2], $vTag[3])
EndSwitch
EndIf
_Add($sInfo, "SubjectArea", $vTemp)
Case 0x9286
Switch BinaryMid($vTag, 1, 8)
Case "0x4153434949000000"
$vTemp = BinaryToString(BinaryMid($vTag, 9))
Case "0x554E49434F444500"
$vTemp = BinaryMid($vTag, 9)
Case Else
$vTemp = BinaryMid($vTag, 9)
EndSwitch
_Add($sInfo, "UserComment", $vTemp)
Case 0x9290
_Add($sInfo, "SubsecTime", $vTag)
Case 0x9291
_Add($sInfo, "SubsecTimeOriginal", $vTag)
Case 0x9292
_Add($sInfo, "SubsecTimeDigitized", $vTag)
Case 0xA001
_AddArray($sInfo, "ColorSpace", $vTag, ";RGB", "Uncalibrated")
Case 0xA002
_Add($sInfo, "PixelXDimension", $vTag)
Case 0xA003
_Add($sInfo, "PixelYDimension", $vTag)
Case 0xA004
_Add($sInfo, "RelatedSoundFile", $vTag)
Case 0xA20B
_Add($sInfo, "FlashEnergy", $vTag)
Case 0xA20E
_Add($sInfo, "FocalPlaneXResolution", $vTag)
Case 0xA20F
_Add($sInfo, "FocalPlaneYResolution", $vTag)
Case 0xA210
_AddArray($sInfo, "FocalPlaneResolutionUnit", $vTag, ";;Inch;Centimeter")
Case 0xA214
If IsArray($vTag) Then
_Add($sInfo, "SubjectLocation", $vTag[0] & ":" & $vTag[1])
EndIf
Case 0xA215
_Add($sInfo, "ExposureIndex", $vTag)
Case 0xA217
_AddArray($sInfo, "SensingMethod", $vTag, "Undefined;Undefined;OneChipColorArea;TwoChipColorArea;ThreeChipColorArea;ColorSequentialArea;Undefined;Trilinear;ColorSequentialLinear")
Case 0xA300
If $vTag = 0x3 Then _Add($sInfo, "FileSource", "DSC")
Case 0xA301
If $vTag = 0x1 Then _Add($sInfo, "SceneType", "Directly recorded")
Case 0xA401
_AddArray($sInfo, "CustomRendered", "No;Yes","No")
Case 0xA402
_AddArray($sInfo, "ExposureMode", $vTag, "Auto;Manual;Auto bracket")
Case 0xA403
_AddArray($sInfo, "WhiteBalance", $vTag, "Auto;Manual")
Case 0xA404
_Add($sInfo, "DigitalZoomRatio", $vTag)
Case 0xA405
_AddArray($sInfo, "FocalLengthIn35mmFilm", $vTag, "Unknown", $vTag)
Case 0xA406
_AddArray($sInfo, "SceneCaptureType", $vTag, "Standard;Landscape;Portrait;Night scene")
Case 0xA407
_AddArray($sInfo, "GainControl", $vTag, "None;Low gain up;High gain up;Low gain down;High gain down")
Case 0xA408
_AddArray($sInfo, "Contrast", $vTag, "Normal;Soft;Hard")
Case 0xA409
_AddArray($sInfo, "Saturation", $vTag, "Normal;Low;High")
Case 0xA40A
_AddArray($sInfo, "Sharpness", $vTag, "Normal;Soft;Hard")
Case 0xA40B
_Add($sInfo, "DeviceSettingDescription", $vTag)
Case 0xA40C
_AddArray($sInfo, "SubjectDistanceRange", $vTag, "Unknown;Macro;Close view;Distant view")
Case 0xA420
_Add($sInfo, "ImageUniqueID", $vTag)
EndSwitch
EndFunc
Func _AddGpsTag(ByRef $sInfo, $nID, $vTag)
Switch $nID
Case 0x0000
_Add($sInfo, "GPSVersionID", $vTag)
Case 0x0001
_Add($sInfo, "GPSLatitudeRef", $vTag)
Case 0x0002
If IsArray($vTag) And (UBound($vTag) = 3) Then
_Add($sInfo, "GPSLatitude", StringFormat("%f/%f/%f", $vTag[0], $vTag[1], $vTag[2]))
EndIf
Case 0x0003
_Add($sInfo, "GPSLongitudeRef", $vTag)
Case 0x0004
If IsArray($vTag) And (UBound($vTag) = 3) Then
_Add($sInfo, "GPSLongitude", StringFormat("%f/%f/%f", $vTag[0], $vTag[1], $vTag[2]))
EndIf
Case 0x0005
_AddArray($sInfo, "GPSAltitudeRef", $vTag, "Above sea level,Below sea level")
Case 0x0006
_Add($sInfo, "GPSAltitude", $vTag)
Case 0x0007
If IsArray($vTag) And (UBound($vTag) = 3) Then
_Add($sInfo, "GPSTimeStamp", StringFormat("UTC %f:%f:%f", $vTag[0], $vTag[1], $vTag[2]))
EndIf
Case 0x0008
_Add($sInfo, "GPSSatellites", $vTag)
Case 0x0009
_Add($sInfo, "GPSStatus", $vTag)
Case 0x000A
_Add($sInfo, "GPSMeasureMode", $vTag)
Case 0x000B
_Add($sInfo, "GPSDOP", $vTag)
Case 0x000C
_Add($sInfo, "GPSSpeedRef", $vTag)
Case 0x000D
_Add($sInfo, "GPSSpeed", $vTag)
Case 0x000E
_Add($sInfo, "GPSTrackRef", $vTag)
Case 0x000F
_Add($sInfo, "GPSTrack", $vTag)
Case 0x0010
_Add($sInfo, "GPSImgDirectionRef", $vTag)
Case 0x0011
_Add($sInfo, "GPSImgDirection", $vTag)
Case 0x0012
_Add($sInfo, "GPSMapDatum", $vTag)
Case 0x0013
_Add($sInfo, "GPSDestLatitudeRef", $vTag)
Case 0x0014
If IsArray($vTag) And (UBound($vTag) = 3) Then
_Add($sInfo, "GPSDestLatitude", StringFormat("%f/%f/%f", $vTag[0], $vTag[1], $vTag[2]))
EndIf
Case 0x0015
_Add($sInfo, "GPSDestLongitudeRef", $vTag)
Case 0x0016
If IsArray($vTag) And (UBound($vTag) = 3) Then
_Add($sInfo, "GPSDestLongitude", StringFormat("%f/%f/%f", $vTag[0], $vTag[1], $vTag[2]))
EndIf
Case 0x0017
_Add($sInfo, "GPSDestBearingRef", $vTag)
Case 0x0018
_Add($sInfo, "GPSDestBearing", $vTag)
Case 0x0019
_Add($sInfo, "GPSDestDistanceRef", $vTag)
Case 0x001A
_Add($sInfo, "GPSDestDistance", $vTag)
Case 0x001D
_Add($sInfo, "GPSDateStamp", $vTag)
Case 0x001E
_AddArray($sInfo, "GPSDifferential", $vTag, "No correction;Correction applied")
EndSwitch
EndFunc
Func _AddArray(ByRef $sInfo, $sField, $vTag, $sValues, $sDefault = "Undefined")
Local $aArray = StringSplit($sValues, ";", 2)
Switch $vTag
Case 0 To UBound($aArray) - 1
If $aArray[$vTag] = "" Then $aArray[$vTag] = $sDefault
_Add($sInfo, $sField, $aArray[$vTag])
Case Else
_Add($sInfo, $sField, $sDefault)
EndSwitch
EndFunc
Func _IsBitSet($nNum, $nBit)
Return BitAND(BitShift($nNum, $nBit), 1)
EndFunc
Func _Add(ByRef $sInfo, $sField, $nValue)
$sInfo = $sInfo & $sField & "=" & $nValue & @LF
EndFunc
Func _IntR32($nInt, $nOrder = 1)
If not $nOrder Then Return $nInt
Return BitOR(BitAND(BitShift($nInt,24), 0x000000FF),  BitAND(BitShift($nInt, 8), 0x0000FF00),  BitAND(BitShift($nInt,-8), 0x00FF0000),  BitAND(BitShift($nInt,-24),0xFF000000))
EndFunc
Func _IntR16($nInt, $nOrder = 1)
If not $nOrder Then Return $nInt
Return BitOR(BitAND(BitShift($nInt, 8), 0xFF), BitAND(BitShift($nInt, -8), 0xFF00))
EndFunc
Func _FileSetPointer($hFile, $nOffset, $nStartPosition)
Local $ret = DllCall("kernel32.dll","int","SetFilePointer",  "int",$hFile,  "int",$nOffset,  "ptr",0,  "int",$nStartPosition)
EndFunc
Func _FileReadToStruct($vStruct, $hFile)
If not DllStructGetSize($vStruct) Then $vStruct = DllStructCreate($vStruct)
Local $nLen	= DllStructGetSize($vStruct)
Local $pRead = DllStructCreate("dword")
Local $ret = DllCall("kernel32.dll","int","ReadFile",  "int",$hFile,  "ptr",DllStructGetPtr($vStruct),  "int", $nLen,  "ptr",DllStructGetPtr($pRead),  "ptr",0)
Local $nRead = DllStructGetData($pRead, 1)
SetExtended($nRead)
If not ($nRead = $nLen) Then SetError(2)
Return $vStruct
EndFunc
Func _FileReadToStructAtOffset($vStruct, $hFile, $nOffset)
_FileSetPointer($hFile, $nOffset, $__FILE_BEGIN)
Return SetError(@error, @extended, _FileReadToStruct($vStruct, $hFile))
EndFunc
Global $oMyError = ObjEvent("AutoIt.Error", "BotComError")
Func BotComError()
SetError(0, 0, 0)
If $debugsetlog = 1 Then
Setlog("We intercepted a COM Error !", $COLOR_DEBUG)
Setlog("err.description is: " & $oMyError.description, $COLOR_DEBUG)
Setlog("err.windescription:" & $oMyError.windescription, $COLOR_DEBUG)
Setlog("err.number is: " & Hex($oMyError.number, 8), $COLOR_DEBUG)
Setlog("err.lastdllerror is: " & $oMyError.lastdllerror, $COLOR_DEBUG)
Setlog("err.scriptline is: " & $oMyError.scriptline, $COLOR_DEBUG)
Setlog("err.source is: " & $oMyError.source, $COLOR_DEBUG)
Setlog("err.helpfile is: " & $oMyError.helpfile, $COLOR_DEBUG)
Setlog("err.helpcontext is: " & $oMyError.helpcontext, $COLOR_DEBUG)
EndIf
SetError(0, 0, 0)
EndFunc
Func IsTrainPage($writelogs = True)
Local $i = 0
Local $_aIsTrainPgChk1 = [816, 136, 0xc40608, 15]
Local $_aIsTrainPgChk2 = [843, 183, 0xe8e8e0, 15]
While $i < 30
If _CheckPixel($_aIsTrainPgChk1, $bCapturePixel) And _CheckPixel($_aIsTrainPgChk2, $bCapturePixel) Then ExitLoop
If _Sleep($iDelayIsTrainPage1) Then ExitLoop
$i += 1
WEnd
If $i <= 28 Then
If ($DebugSetlog = 1 Or $DebugClick = 1) And $writelogs = True Then Setlog("**Train Window OK**", $COLOR_DEBUG)
Return True
Else
If $writelogs = True Then SetLog("Cannot find train Window.", $COLOR_RED)
If $debugImageSave = 1 Then DebugImageSave("IsTrainPage_")
Return False
EndIf
EndFunc
Func IsAttackPage()
Local $result
Local $colorRead = _GetPixelColor($aIsAttackPage[0], $aIsAttackPage[1], True)
$result = _ColorCheck($colorRead, Hex($aIsAttackPage[2], 6), $aIsAttackPage[3])
If $result Then
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Attack Window OK**", $COLOR_DEBUG)
Return True
Else
If $DebugSetlog = 1 Or $DebugClick = 1 Then
SetLog("**Attack Window FAIL**", $COLOR_DEBUG)
SetLog("expected in (" & $aIsAttackPage[0] & "," & $aIsAttackPage[1] & ")  = " & Hex($aIsAttackPage[2], 6) & " - Found " & $colorRead, $COLOR_DEBUG)
EndIf
If $debugImageSave = 1 Then DebugImageSave("IsAttackPage_")
Return False
EndIf
EndFunc
Func IsAttackWhileShieldPage($makeDebugImageSave = True)
Local $result
$result = _CheckPixel($aIsAttackShield, $bCapturePixel)
If $result Then
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Attack Shield Window Open**", $COLOR_DEBUG)
Return True
Else
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Attack Shield Window not open**", $COLOR_DEBUG)
If $debugImageSave = 1 And $makeDebugImageSave = True Then DebugImageSave("IsAttackWhileShieldPage_")
Return False
EndIf
EndFunc
Func IsMainPage()
Local $result
$result = _CheckPixel($aIsMain, $bCapturePixel)
If $result Then
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Main Window OK**", $COLOR_DEBUG)
Return True
Else
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Main Window FAIL**", $COLOR_DEBUG)
If $debugImageSave = 1 Then DebugImageSave("IsMainPage_")
Return False
EndIf
EndFunc
Func IsMainChatOpenPage()
Local $result
$result = _ColorCheck(_GetPixelColor($aChatTab[0], $aChatTab[1], True), Hex($aChatTab[2], 6), $aChatTab[3])
If $result Then
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Chat Open Window OK**", $COLOR_DEBUG)
Return True
Else
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Chat Open Window FAIL** " & $aChatTab[0] & "," & $aChatTab[1] & " " & _GetPixelColor($aChatTab[0], $aChatTab[1], True), $COLOR_DEBUG)
If $debugImageSave = 1 Then DebugImageSave("IsMainChatOpenPage_")
Return False
EndIf
EndFunc
Func IsClanInfoPage()
Local $result
$result = _ColorCheck(_GetPixelColor($aPerkBtn[0], $aPerkBtn[1], True), Hex($aPerkBtn[2], 6), $aPerkBtn[3])
If $result Then
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Clan Info Window OK**", $COLOR_DEBUG)
Return True
Else
$result = _ColorCheck(_GetPixelColor(214, 106, True), Hex(0xFFFFFF, 6), 1) And _ColorCheck(_GetPixelColor(815, 58, True), Hex(0xD80402, 6), 5)
If $result Then
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Clan Info Window OK**", $COLOR_DEBUG)
SetLog("Join a Clan to donate and receive troops!", $COLOR_ORANGE)
Return True
Else
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Clan Info Window FAIL**", $COLOR_DEBUG)
If $debugImageSave = 1 Then DebugImageSave("IsClanInfoPage_")
Return False
EndIf
EndIf
EndFunc
Func IsLaunchAttackPage()
Local $result
Local $colorReadnoshield = _GetPixelColor($aFindMatchButton[0], $aFindMatchButton[1], True)
Local $colorReadwithshield = _GetPixelColor($aFindMatchButton2[0], $aFindMatchButton2[1], True)
$resultnoshield = _ColorCheck($colorReadnoshield, Hex($aFindMatchButton[2], 6), $aFindMatchButton[3])
$resultwithshield = _ColorCheck($colorReadwithshield, Hex($aFindMatchButton2[2], 6), $aFindMatchButton2[3])
If $resultnoshield Or $resultwithshield Then
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Launch Attack Window OK**", $COLOR_DEBUG)
Return True
Else
If $DebugSetlog = 1 Or $DebugClick = 1 Then
SetLog("**Launch Attack Window FAIL**", $COLOR_DEBUG)
SetLog("expected in (" & $aFindMatchButton[0] & "," & $aFindMatchButton[1] & ")  = " & Hex($aFindMatchButton[2], 6) & " or " & Hex($aFindMatchButton2[2], 6) & " - Found " & $colorReadnoshield & " or " & $colorReadwithshield, $COLOR_DEBUG)
EndIf
If $debugImageSave = 1 Then DebugImageSave("IsLaunchAttackPage_")
Return False
EndIf
EndFunc
Func IsEndBattlePage($writelog = True)
Local $result
Local $colorRead = _GetPixelColor($aConfirmSurrender[0], $aConfirmSurrender[1], True)
$result = _ColorCheck($colorRead, Hex($aConfirmSurrender[2], 6), $aConfirmSurrender[3])
If $result Then
If ($DebugSetlog = 1 Or $DebugClick = 1) And $writelog = True Then SetLog("**End Battle Window OK**", $COLOR_ORANGE)
Return True
Else
If ($DebugSetlog = 1 Or $DebugClick = 1) And $writelog = True Then
SetLog("**End Battle Window FAIL**", $COLOR_ORANGE)
SetLog("expected in (" & $aConfirmSurrender[0] & "," & $aConfirmSurrender[1] & ")  = " & Hex($aConfirmSurrender[2], 6) & " - Found " & $colorRead, $COLOR_ORANGE)
EndIf
If $debugImageSave = 1 And $writelog = True Then DebugImageSave("IsEndBattlePage_")
Return False
EndIf
EndFunc
Func IsReturnHomeBattlePage($useReturnValue = False, $makeDebugImageScreenshot = True)
Local $result
$result = _ColorCheck(_GetPixelColor($aReturnHomeButton[0], $aReturnHomeButton[1], True), Hex($aReturnHomeButton[2], 6), $aReturnHomeButton[3])
If $result Then
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Return Home Battle Window OK**", $COLOR_ORANGE)
Return True
Else
If ($DebugSetlog = 1 Or $DebugClick = 1) And ($makeDebugImageScreenshot = True) Then SetLog("**Return Home Battle Window FAIL**", $COLOR_ORANGE)
If $debugImageSave = 1 And $makeDebugImageScreenshot = True Then DebugImageSave("IsReturnHomeBattlePage_")
If $useReturnValue = True Then
Return False
Else
Return True
EndIf
EndIf
EndFunc
Func IsPostDefenseSummaryPage()
Local $result
Local $GoldSpot = _GetPixelColor(334, 209 + $midOffsetY, $bCapturePixel)
Local $ElixirSpot = _GetPixelColor(334, 233 + $midOffsetY, $bCapturePixel)
$result = _ColorCheck($GoldSpot, Hex(0xE8C138, 6), 20) And _ColorCheck($ElixirSpot, Hex(0xE83CE8, 6), 20)
If $result Then
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Post Defense Page visible**", $COLOR_DEBUG)
Return True
Else
If $DebugSetlog = 1 Or $DebugClick = 1 Then SetLog("**Post Defense Page not visible**", $COLOR_DEBUG)
If $debugImageSave = 1 Then
DebugImageSave("IsPostDefenseSummaryPage_")
EndIf
Return False
EndIf
EndFunc
Func MoveMouseOutBS()
If $iMoveMouseOutBS = 0 Then Return
Local $hWindow, $txtTitleW, $hControl, $aMousePos
$aMousePos = MouseGetPos()
If IsArray($aMousePos) Then
$hControl = _WindowFromPoint($aMousePos[0], $aMousePos[1])
If $hControl <> 0 Then
$hWindow = _WinAPI_GetAncestor($hControl, 2)
$txtTitleW = WinGetTitle($hWindow)
If $hWindow = $HWnD And $txtTitleW == $Title Then
MouseMove(@DesktopWidth + 100, Round(@DesktopHeight / 2), 0)
SetLog("Keep Your Mouse Out of BlueStacks Window while bot is running", $COLOR_RED)
EndIf
EndIf
EndIf
EndFunc
Func _WindowFromPoint($iX, $iY)
Local $stInt64, $aRet, $stPoint = DllStructCreate("long;long")
DllStructSetData($stPoint, 1, $iX)
DllStructSetData($stPoint, 2, $iY)
$stInt64 = DllStructCreate("int64", DllStructGetPtr($stPoint))
$aRet = DllCall("user32.dll", "hwnd", "WindowFromPoint", "int64", DllStructGetData($stInt64, 1))
If @error Then Return SetError(0, 0, 0)
If $aRet[0] = 0 Then Return SetError(0, 0, 0)
Return $aRet[0]
EndFunc
Func KillProcess($pid, $process_info = "", $attempts = 3)
Local $iCount = 0
If $process_info <> "" Then $process_info = ", " & $process_info
While ProcessExists($pid) And $iCount < $attempts
If ProcessClose($pid) = 1 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " closed" & $process_info)
EndIf
If ProcessExists($pid) Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", " -pid " & $pid, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return False
If ProcessExists($pid) = 0 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " killed (using taskkill)" & $process_info)
EndIf
EndIf
If ProcessExists($pid) Then
ShellExecute(@WindowsDir & "\System32\taskkill.exe", "-f -t -pid " & $pid, "", Default, @SW_HIDE)
If _Sleep(1000) Then Return False
If ProcessExists($pid) = 0 Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " killed (using taskkill -f -t)" & $process_info)
EndIf
EndIf
$iCount += 1
WEnd
If ProcessExists($pid) Then
SetDebugLog("KillProcess(" & $iCount & "): PID = " & $pid & " failed to kill" & $process_info, $COLOR_RED)
Return False
EndIf
Return True
EndFunc
Func LaunchConsole($cmd, $param, ByRef $process_killed, $timeout = 10000, $bUseSemaphore = False)
If $bUseSemaphore = True Then
WaitForSemaphore(StringReplace($cmd, "\", "/"))
EndIf
Local $data, $pid, $hTimer
If StringLen($param) > 0 Then $cmd &= " " & $param
$hTimer = TimerInit()
$process_killed = False
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: " & $cmd, $COLOR_DEBUG)
$pid = Run($cmd, "", @SW_HIDE, $STDERR_MERGED)
If $debugSetlog = 1 Then Setlog("Func LaunchConsole: command launched", $COLOR_DEBUG)
If $pid = 0 Then
SetLog("Launch faild: " & $cmd, $COLOR_RED)
Return
EndIf
Local $hProcess
If _WinAPI_GetVersion() >= 6.0 Then
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_LIMITED_INFORMATION, 0, $pid)
Else
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_INFORMATION, 0, $pid)
EndIf
$data = ""
Local $timeout_sec = Round($timeout / 1000)
While True
If $hProcess Then
_WinAPI_WaitForSingleObject($hProcess, $iDelaySleep)
Else
Sleep($iDelaySleep)
EndIf
$data &= StdoutRead($pid)
If @error Then ExitLoop
If ($timeout > 0 And TimerDiff($hTimer) > $timeout) Then ExitLoop
WEnd
If $hProcess Then
_WinAPI_CloseHandle($hProcess)
$hProcess = 0
EndIF
CleanLaunchOutput($data)
If ProcessExists($pid) Then
If ProcessClose($pid) = 1 Then
If $debugSetlog = 1 Then SetLog("Process killed: " & $cmd, $COLOR_DEBUG)
$process_killed = True
EndIf
EndIf
StdioClose($pid)
If $debugSetlog = 1 Then Setlog("Func LaunchConsole Output: " & $data, $COLOR_DEBUG)
Return $data
EndFunc
Func ProcessExists2($ProgramPath, $ProgramParameter = Default, $CompareMode = Default, $SearchMode = 0, $CompareCommandLineFunc = "", $strComputer = ".")
If IsNumber($ProgramPath) Then
Local $hProcess, $pid = $ProgramPath
If _WinAPI_GetVersion() >= 6.0 Then
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_LIMITED_INFORMATION, 0, $pid)
Else
$hProcess = _WinAPI_OpenProcess($PROCESS_QUERY_INFORMATION, 0, $pid)
EndIf
If $hProcess Then
_WinAPI_CloseHandle($hProcess)
EndIf
Return (($hProcess) ? $pid : 0)
EndIf
If $ProgramParameter = Default Then
$ProgramParameter = ""
If $CompareMode = Default Then $CompareMode = 1
EndIf
If $CompareMode = Default Then
$CompareMode = 0
EndIf
Local $oWMI=ObjGet("winmgmts:{impersonationLevel=impersonate}!\\" & $strComputer & "\root\cimv2")
SetDebugLog("ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2"")")
If @error <> 0 Then
SetDebugLog("Cannot create ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2")
Return 0
EndIf
Local $exe = $ProgramPath
Local $iLastBS = StringInStr($exe, "\", 0, -1)
If $iLastBS > 0 Then $exe = StringMid($exe, $iLastBS + 1)
Local $commandLine = ($ProgramPath <> "" ? ('"' & $ProgramPath & '"' & ($ProgramParameter = "" ? "" : " " & $ProgramParameter)) : $ProgramParameter)
Local $commandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($commandLine, ".exe", "" , 1), " ", ""), '"', ""), "'", "")
Local $query = "Select * from Win32_Process"
If StringLen($commandLine) > 0 Then
$query &= " where "
If StringLen($ProgramPath) > 0 Then
$query &= "ExecutablePath like ""%" & StringReplace($ProgramPath,"\","\\") & "%"""
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= " And "
EndIf
If $SearchMode = 1 And StringLen($ProgramParameter) > 0 Then $query &= "CommandLine like ""%" & StringReplace($ProgramParameter,"\","\\") & "%"""
EndIf
SetDebugLog("WMI Query: " & $query)
Local $oProcessColl = $oWMI.ExecQuery($query)
Local $Process, $PID = 0, $i = 0
For $Process In $oProcessColl
SetDebugLog($Process.Handle & " = " & $Process.ExecutablePath & " (" & $Process.CommandLine & ")")
If $PID = 0 Then
Local $processCommandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($Process.CommandLine, ".exe", "" , 1), " ", ""), '"', ""), "'", "")
If ($CompareMode = 0 And $commandLineCompare = $processCommandLineCompare) Or  ($CompareMode = 0 And StringRight($commandLineCompare, StringLen($processCommandLineCompare)) = $processCommandLineCompare) Or  ($CompareMode = 0 And $CompareCommandLineFunc <> "" and Execute($CompareCommandLineFunc & "(""" & StringReplace($Process.CommandLine,"""","") & """)") = True) Or  $CompareMode = 1 Then
$PID = Number($Process.Handle)
EndIf
EndIf
$i += 1
Next
If $PID = 0 Then
SetDebugLog("Process by CommandLine not found: " & $ProgramPath & ($ProgramParameter = "" ? "" : ($ProgramPath <> "" ? " " : "") & $ProgramParameter))
Else
SetDebugLog("Found Process " & $PID & " by CommandLine: " & $ProgramPath & ($ProgramParameter = "" ? "" : ($ProgramPath <> "" ? " " : "") & $ProgramParameter))
EndIf
Return $PID
EndFunc
Func ProcessesExist($ProgramPath, $ProgramParameter = "", $CompareMode = 0, $strComputer=".")
If IsNumber($ProgramPath) Then
Local $a[1] = [ProcessExists($ProgramPath)]
Return $a
EndIf
Local $oWMI=ObjGet("winmgmts:{impersonationLevel=impersonate}!\\" & $strComputer & "\root\cimv2")
SetDebugLog("ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2"")")
If @error <> 0 Then
SetDebugLog("Cannot create ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2")
Local $a[0]
Return $a
EndIf
Local $exe = $ProgramPath
Local $iLastBS = StringInStr($exe, "\", 0, -1)
If $iLastBS > 0 Then $exe = StringMid($exe, $iLastBS + 1)
Local $commandLine = ($ProgramPath <> "" ? ('"' & $ProgramPath & '"' & ($ProgramParameter = "" ? "" : " " & $ProgramParameter)) : $ProgramParameter)
Local $commandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($commandLine, ".exe", "" , 1), " ", ""), '"', ""), "'", "")
Local $query = "Select * from Win32_Process where ExecutablePath like ""%" & StringReplace($ProgramPath,"\","\\") & "%"""
SetDebugLog("WMI Query: " & $query)
Local $oProcessColl = $oWMI.ExecQuery($query)
Local $Process, $PID = 0, $i = 0
Local $PIDs[0]
For $Process In $oProcessColl
SetDebugLog($Process.Handle & " = " & $Process.ExecutablePath)
Local $processCommandLineCompare = StringReplace(StringReplace(StringReplace(StringReplace($Process.CommandLine, ".exe", "" , 1), " ", ""), '"', ""), "'", "")
If ($CompareMode = 0 And $commandLineCompare = $processCommandLineCompare) Or  ($CompareMode = 0 And StringRight($commandLineCompare, StringLen($processCommandLineCompare)) = $processCommandLineCompare) Or  $CompareMode = 1 Then
ReDim $PIDs[$i + 1]
$PIDs[$i] = Number($Process.Handle)
$i += 1
EndIf
Next
If $i = 0 Then
SetDebugLog("No process found by CommandLine: " & $ProgramPath & ($ProgramParameter = "" ? "" : " " & $ProgramParameter))
Else
SetDebugLog("Found " & $i & " process(es) with " & $ProgramPath & ($ProgramParameter = "" ? "" : " " & $ProgramParameter))
EndIf
Return $PIDs
EndFunc
Func ProcessGetCommandLine($PID, $strComputer = ".")
If Not IsNumber($PID) Then Return SetError(2, 0, -1)
Local $oWMI=ObjGet("winmgmts:{impersonationLevel=impersonate}!\\" & $strComputer & "\root\cimv2")
SetDebugLog("ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2"")")
If @error <> 0 Then
SetDebugLog("Cannot create ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2")
Return SetError(3, 0, -1)
EndIf
Local $commandLine
Local $query = "Select * from Win32_Process where Handle = " & $PID
SetDebugLog("WMI Query: " & $query)
Local $oProcessColl = $oWMI.ExecQuery($query)
Local $Process, $i = 0
For $Process In $oProcessColl
SetDebugLog($Process.Handle & " = " & $Process.CommandLine)
SetError(0, 0, 0)
Return $Process.CommandLine
Next
SetDebugLog("Process not found with PID " & $PID)
Return SetError(1, 0, -1)
EndFunc
Func ProcessGetWmiProcess($PID, $strComputer = ".")
If Not IsNumber($PID) Then Return SetError(2, 0, -1)
Local $oWMI=ObjGet("winmgmts:{impersonationLevel=impersonate}!\\" & $strComputer & "\root\cimv2")
SetDebugLog("ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2"")")
If @error <> 0 Then
SetDebugLog("Cannot create ObjGet(""winmgmts:\\" & $strComputer & "\root\cimv2")
Return SetError(3, 0, -1)
EndIf
Local $commandLine
Local $query = "Select * from Win32_Process where Handle = " & $PID
SetDebugLog("WMI Query: " & $query)
Local $oProcessColl = $oWMI.ExecQuery($query)
Local $Process, $i = 0
For $Process In $oProcessColl
SetDebugLog($Process.Handle & " = " & $Process.CommandLine)
SetError(0, 0, 0)
Return $Process
Next
SetDebugLog("Process not found with PID " & $PID)
Return SetError(1, 0, -1)
EndFunc
Func CleanLaunchOutput(ByRef $output)
$output = StringReplace($output,  @CR & @CR, "")
$output = StringReplace($output,  @CRLF & @CRLF, "")
If StringRight($output, 1) = @LF Then $output = StringLeft($output, StringLen($output) - 1)
If StringRight($output, 1) = @CR Then $output = StringLeft($output, StringLen($output) - 1)
EndFunc
Func SendAdbCommand($cmd, $EnsureConnected = True)
Local $process_killed, $connected_to, $pid, $i
Local $data = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " " & $cmd, $process_killed)
Local $error_device_not_found = (StringInStr($data, "device not found") > 0) Or $process_killed
If $error_device_not_found Then
SetDebugLog("ADB connection error, device " & $AndroidAdbDevice & " not available")
If Not $EnsureConnected Then
SetDebugLog("Connect will not be initiated")
SetLog("ADB command not executed or interrupted: " & $cmd, $COLOR_RED)
Return False
EndIf
If ConnectAndroidAdb() Then
$data = LaunchConsole($AndroidAdbPath, "-s " & $AndroidAdbDevice & " " & $cmd, $process_killed)
$error_device_not_found = (StringInStr($data, "device not found") > 0) Or $process_killed
EndIf
If $error_device_not_found Then
SetLog("ADB command not executed: " & $cmd, $COLOR_RED)
Return False
EndIf
EndIf
Return True
EndFunc
Global $TempBot[4] = [1, 10, 20, 0]
Func ClickZone ($x, $y, $Offset = 7, $debugtxt = "", $times = 1, $speed = 0, $OutScreen = (680 + $bottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $BasY
If $y-$Offset > $OutScreen Then
$BasY = $y
Else
$BasY = $y-$Offset
EndIf
Dim $TempBot[4] = [$x-$Offset, $BasY, $x+$Offset, $y+$Offset]
If $debugClick = 1 Then
Local $txt = _DecodeDebug($debugtxt)
SetLog("ClickZone " & $x & "," & $y & "," & $times & "," & $speed & " " & $debugtxt & $txt, $COLOR_ORANGE, "Verdana", "7.5", 0)
EndIf
ClickR($TempBot,$x, $y, $times, $speed, $OutScreen, $scale, $density, $centerX, $centerY)
EndFunc
Func ClickR($boundingBox, $x, $y, $times = 1, $speed = 0, $OutScreen = (680 + $bottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $AncVal = " ValIn: X=" & $x & " Y=" & $y
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale * (($xR ^ (-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And  $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $times <> 1 Then
For $i = 0 To ($times - 1)
If $debugClick = 1 Then SetLog("_ControlClick " & "X=" & $x & " Y=" & $y & " ,t" & $times & ",s" & $speed & $AncVal, $COLOR_ORANGE, "Verdana", "7.5", 0)
Click($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If $debugClick = 1 Then SetLog("_ControlClick " & "X=" & $x & " Y=" & $y & $AncVal, $COLOR_ORANGE, "Verdana", "7.5", 0)
Click($x, $y)
EndIf
EndFunc
Func PureClickR($boundingBox, $x, $y, $times = 1, $speed = 0, $OutScreen = (680 + $bottomOffsetY), $scale = 3, $density = 1, $centerX = 0, $centerY = 0)
Local $AncVal = " ValIn: X=" & $x & " Y=" & $y
Local Const $PI = 3.141592653589793
Local $boxWidth = $boundingBox[2] - $boundingBox[0]
Local $boxHeight = $boundingBox[3] - $boundingBox[1]
Local $boxCenterX = $boundingBox[0] + $boxWidth/2 + $centerX
Local $boxCenterY = $boundingBox[1] + $boxHeight/2 + $centerY
Local $loopStartTime = TimerInit()
Do
Local $angle = Random() * 2 *$PI
Local $xR = Random()
If $xR = 0 Then $xR = 0.000001
Local $distance = $scale * (($xR ^ (-1.0/$density)) - 1)
Local $offsetX = $distance * Sin($angle)
Local $offsetY = $distance * Cos($angle)
$x = $boxCenterX + $boxWidth * $offsetX/4
$y = $boxCenterY + $boxHeight * $offsetY/4
If TimerDiff($loopStartTime)>5000 Then
$x = $boxCenterX
$y = $boxCenterY
ExitLoop
EndIf
Until $x >= $boundingBox[0] And $x <= $boundingBox[2] And  $y >= $boundingBox[1] And $y <= $boundingBox[3]
If $y > $OutScreen Then
$y = $OutScreen
Else
$y = $y
EndIf
$x = Round($x, 3)
$y = Round($y, 3)
If $times <> 1 Then
For $i = 0 To ($times - 1)
If $debugClick = 1 Then SetLog("PureClick " & "X=" & $x & " Y=" & $y & " ,t" & $times & ",s" & $speed & $AncVal, $COLOR_ORANGE, "Verdana", "7.5", 0)
PureClick($x, $y)
If _Sleep($speed, False) Then ExitLoop
Next
Else
If $debugClick = 1 Then SetLog("PureClick " & "X=" & $x & " Y=" & $y & $AncVal, $COLOR_ORANGE, "Verdana", "7.5", 0)
PureClick($x, $y)
EndIf
EndFunc
Func _CaptureRegion($iLeft = 0, $iTop = 0, $iRight = $GAME_WIDTH, $iBottom = $GAME_HEIGHT, $ReturnBMP = False, $ReturnLocal_hHBitmap = False)
Local $SuspendMode
If $ReturnLocal_hHBitmap = False And $hHBitmap <> $hHBitmapTest Then
_GDIPlus_BitmapDispose($hBitmap)
_WinAPI_DeleteObject($hHBitmap)
EndIf
If $RunState Then CheckAndroidRunning()
Local $_hHBitmap = $hHBitmapTest
If $hHBitmapTest = 0 Then
If $ichkBackground = 1 Then
Local $iW = Number($iRight) - Number($iLeft), $iH = Number($iBottom) - Number($iTop)
If $AndroidAdbScreencap = True Then
$_hHBitmap = AndroidScreencap($iLeft, $iTop, $iW, $iH)
Else
$SuspendMode = ResumeAndroid(False)
Local $hCtrl = ControlGetHandle($HWnD, $AppPaneName, $AppClassInstance)
Local $hDC_Capture = _WinAPI_GetDC($hCtrl)
Local $hMemDC = _WinAPI_CreateCompatibleDC($hDC_Capture)
$_hHBitmap = _WinAPI_CreateCompatibleBitmap($hDC_Capture, $iW, $iH)
Local $hObjectOld = _WinAPI_SelectObject($hMemDC, $_hHBitmap)
DllCall("user32.dll", "int", "PrintWindow", "hwnd", $hCtrl, "handle", $hMemDC, "int", 0)
_WinAPI_SelectObject($hMemDC, $_hHBitmap)
_WinAPI_BitBlt($hMemDC, 0, 0, $iW, $iH, $hDC_Capture, $iLeft, $iTop, 0x00CC0020)
_WinAPI_DeleteDC($hMemDC)
_WinAPI_SelectObject($hMemDC, $hObjectOld)
_WinAPI_ReleaseDC($hCtrl, $hDC_Capture)
SuspendAndroid($SuspendMode, False)
EndIf
Else
getBSPos()
$SuspendMode = ResumeAndroid(False)
$_hHBitmap = _ScreenCapture_Capture("", $iLeft + $BSpos[0], $iTop + $BSpos[1], $iRight + $BSpos[0] - 1, $iBottom + $BSpos[1] - 1, False)
SuspendAndroid($SuspendMode, False)
EndIf
EndIf
$ForceCapture = False
If $ReturnLocal_hHBitmap = False Then
$hHBitmap = $_hHBitmap
$hBitmap = _GDIPlus_BitmapCreateFromHBITMAP($hHBitmap)
If $ReturnBMP = True Then Return $hBitmap
Else
Return $_hHBitmap
EndIf
EndFunc
Func _CaptureRegion2($iLeft = 0, $iTop = 0, $iRight = $GAME_WIDTH, $iBottom = $GAME_HEIGHT)
If $hHBitmap2 <> $hHBitmapTest Then
_WinAPI_DeleteObject($hHBitmap2)
EndIf
If $hHBitmapTest = 0 Then
$hHBitmap2 = _CaptureRegion($iLeft, $iTop, $iRight, $iBottom, False, True)
Else
$hHBitmap2 = $hHBitmapTest
EndIf
EndFunc
Func FastCaptureRegion()
Return $ichkBackground = 1 And $AndroidAdbScreencap = False
EndFunc
Func NeedCaptureRegion($iCount)
Local $bNeedCaptureRegion = FastCaptureRegion() Or Mod($iCount, 10) = 0
Return $bNeedCaptureRegion
EndFunc
Func ForceCaptureRegion($bForceCapture = True)
$ForceCapture = $bForceCapture
EndFunc
Func TestCapture($hHBitmap = Default)
If $hHBitmap = Default Then Return $hHBitmapTest <> 0
$hHBitmapTest = $hHBitmap
Return $hHBitmap
EndFunc
Func _ColorCheck($nColor1, $nColor2, $sVari = 5, $Ignore = "")
Local $Red1, $Red2, $Blue1, $Blue2, $Green1, $Green2
$Red1 = Dec(StringMid(String($nColor1), 1, 2))
$Blue1 = Dec(StringMid(String($nColor1), 3, 2))
$Green1 = Dec(StringMid(String($nColor1), 5, 2))
$Red2 = Dec(StringMid(String($nColor2), 1, 2))
$Blue2 = Dec(StringMid(String($nColor2), 3, 2))
$Green2 = Dec(StringMid(String($nColor2), 5, 2))
Switch $Ignore
Case "Red"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
Case "Heroes"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
Case Else
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
EndSwitch
Return True
EndFunc
Func _ColorCheck2($nColor1, $nColor2, $sVari = 5, $Ignore = Default)
Local $Red1, $Red2, $Blue1, $Blue2, $Green1, $Green2
$Red1 = Dec(StringMid(String($nColor1), 1, 2))
$Blue1 = Dec(StringMid(String($nColor1), 3, 2))
$Green1 = Dec(StringMid(String($nColor1), 5, 2))
$Red2 = Dec(StringMid(String($nColor2), 1, 2))
$Blue2 = Dec(StringMid(String($nColor2), 3, 2))
$Green2 = Dec(StringMid(String($nColor2), 5, 2))
Switch $Ignore
Case "Red"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
Case "Heroes"
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
Case Else
If Abs($Blue1 - $Blue2) > $sVari Then Return False
If Abs($Green1 - $Green2) > $sVari Then Return False
If Abs($Red1 - $Red2) > $sVari Then Return False
EndSwitch
Return True
EndFunc
Func _CheckPixel($aScreenCode, $bNeedCapture = False, $Ignore = "")
If _ColorCheck(_GetPixelColor($aScreenCode[0], $aScreenCode[1], $bNeedCapture), Hex($aScreenCode[2], 6), $aScreenCode[3], $Ignore) Then Return True
Return False
EndFunc
Func _CheckPixel2($aScreenCode, $bNeedCapture = Default, $Ignore = Default, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
If $bNeedCapture = Default Then $bNeedCapture = False
If $debugSetlog = 1 And $sLogText <> Default And IsString($sLogText) Then
$sLogText &= ", Expected: " & Hex($aScreenCode[2], 6)
Else
$sLogText = Default
EndIf
If _ColorCheck2(  _GetPixelColor2($aScreenCode[0], $aScreenCode[1], $bNeedCapture, $sLogText, $LogTextColor, $bSilentSetLog),  Hex($aScreenCode[2], 6),  $aScreenCode[3], $Ignore) Then
Return True
EndIf
Return False
EndFunc
Func GetListPixel($listPixel)
Local $listPixelSideStr = StringSplit($listPixel, "|")
If ($listPixelSideStr[0] > 1) Then
Local $listPixelSide[UBound($listPixelSideStr) - 1]
For $i = 0 To UBound($listPixelSide) - 1
Local $Delimiter = StringRegExp($listPixelSideStr[$i + 1], "(?iU)\b[,-]\b", 1)
If UBound($Delimiter) >= 1 Then $Delimiter = $Delimiter[0]
Local $pixelStr = StringSplit($listPixelSideStr[$i + 1], $Delimiter)
If ($pixelStr[0] > 1) Then
Local $pixel[2] = [$pixelStr[1], $pixelStr[2]]
$listPixelSide[$i] = $pixel
EndIf
Next
Return $listPixelSide
Else
Local $Delimiter = StringRegExp($listPixel, "(?iU)\b[,-]\b", 1)
If UBound($Delimiter) >= 1 Then $Delimiter = $Delimiter[0]
If StringInStr($listPixel, $Delimiter) > 0 Then
Local $pixelStrHere = StringSplit($listPixel, $Delimiter)
Local $pixelHere[2] = [$pixelStrHere[1], $pixelStrHere[2]]
Local $listPixelHere[1]
$listPixelHere[0] = $pixelHere
Return $listPixelHere
EndIf
Return -1
EndIf
EndFunc
Func GetLocationItem($functionName, $useImgLoc = False)
If $debugSetLog = 1 Or $debugBuildingPos = 1 Then
Local $hTimer = TimerInit()
Setlog("GetLocationItem(" & $functionName & ")", $COLOR_DEBUG)
EndIf
Local $resultHere
If $useImgLoc = False Then
$resultHere = DllCall($hFuncLib, "str", $functionName, "ptr", $hHBitmap2)
Else
$resultHere = GetLocationItemImgLoc($functionName)
EndIf
If UBound($resultHere) > 0 Then
If $debugBuildingPos = 1 Then Setlog("#*# " & $functionName & ": " & $resultHere[0] & "calc in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG)
Return GetListPixel($resultHere[0])
Else
If $debugBuildingPos = 1 Then Setlog("#*# " & $functionName & ": NONE calc in " & Round(TimerDiff($hTimer) / 1000, 2) & " seconds ", $COLOR_DEBUG)
EndIf
EndFunc
Func GetLocationItemImgLoc($functionName)
Local $DebugIt = False
If $debugSetLog = 1 Or $debugBuildingPos = 1 Then
Local $hTimer = TimerInit()
Setlog("GetLocationItemImgLoc(" & $functionName & ")", $COLOR_DEBUG)
EndIf
Switch $functionName
Case "getLocationTownHall"
Local $directory = @ScriptDir & "\images\Resources\TH"
Local $resultHere = multiMatchesPixelOnly($directory, 0, "ECD", "ECD")
If $DebugIt Then SetLog("$resultHere = " & $resultHere, $COLOR_BLUE)
If Not $resultHere = "" Then
If $debugSetLog = 1 Or $debugBuildingPos = 1 Then Setlog("Found TH Within " & Round(TimerDiff($hTimer) / 1000, 2) & " second(s)", $COLOR_DEBUG)
Return StringSplit($resultHere, "|", 2)
EndIf
EndSwitch
EndFunc
Func GetLocationCC()
If $debugSetLog = 1 Or $debugBuildingPos = 1 Then
Local $hTimer = TimerInit()
Setlog("GetLocationCC()", $COLOR_DEBUG)
EndIf
Local $directory = @ScriptDir & "\images\ClanCastle"
Local $Result = multiMatchesPixelOnly($directory, 0, "ECD", "ECD")
If $debugSetLog = 1 Or $debugBuildingPos = 1 Then SetLog("GetLocationCC() Time Taken: " & Round(Number(TimerDiff($hTimer) / 1000), 2) & " Second(s)!", $COLOR_DEBUG)
Return GetListPixel($Result)
EndFunc
Func _GetPixelColor($iX, $iY, $bNeedCapture = False)
If $bNeedCapture = False Or $RunState = False Then
$aPixelColor = _GDIPlus_BitmapGetPixel($hBitmap, $iX, $iY)
Else
_CaptureRegion($iX - 1, $iY - 1, $iX + 1, $iY + 1)
$aPixelColor = _GDIPlus_BitmapGetPixel($hBitmap, 1, 1)
EndIf
Return Hex($aPixelColor, 6)
EndFunc
Func _GetPixelColor2($iX, $iY, $bNeedCapture = False, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
If $bNeedCapture = False Or $RunState = False Then
$aPixelColor = _GDIPlus_BitmapGetPixel($hBitmap, $iX, $iY)
Else
_CaptureRegion($iX - 1, $iY - 1, $iX + 1, $iY + 1)
$aPixelColor = _GDIPlus_BitmapGetPixel($hBitmap, 1, 1)
EndIf
If $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & ", Found: " & Hex($aPixelColor, 6)
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return Hex($aPixelColor, 6)
EndFunc
Func _PixelSearch($iLeft, $iTop, $iRight, $iBottom, $iColor, $iColorVariation)
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
For $x = $iRight - $iLeft To 0 Step -1
For $y = 0 To $iBottom - $iTop
If _ColorCheck(_GetPixelColor($x, $y), $iColor, $iColorVariation) Then
Local $Pos[2] = [$iLeft + $x, $iTop + $y]
Return $Pos
EndIf
Next
Next
Return 0
EndFunc
Func _MultiPixelSearch($iLeft, $iTop, $iRight, $iBottom, $xSkip, $ySkip, $firstColor, $offColor, $iColorVariation)
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
Local $offColorVariation = UBound($offColor, 2) > 3
For $x = 0 To $iRight - $iLeft Step $xSkip
For $y = 0 To $iBottom - $iTop Step $ySkip
If _ColorCheck(_GetPixelColor($x, $y), $firstColor, $iColorVariation) Then
Local $allchecked = True
Local $iCV = $iColorVariation
For $i = 0 To UBound($offColor) - 1
If $offColorVariation = True Then $iCV = $offColor[$i][3]
If _ColorCheck(_GetPixelColor($x + $offColor[$i][1], $y + $offColor[$i][2]), Hex($offColor[$i][0], 6), $iCV) = False Then
$allchecked = False
ExitLoop
EndIf
Next
If $allchecked Then
Local $Pos[2] = [$iLeft + $x, $iTop + $y]
Return $Pos
EndIf
EndIf
Next
Next
Return 0
EndFunc
Func _MultiPixelSearch2($iLeft, $iTop, $iRight, $iBottom, $xSkip, $ySkip, $firstColor, $offColor, $iColorVariation)
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
Local $offColorVariation = UBound($offColor, 2) > 3
For $y = 0 To $iBottom - $iTop Step $ySkip
For $x = 0 To $iRight - $iLeft Step $xSkip
If _ColorCheck(_GetPixelColor($x, $y), $firstColor, $iColorVariation) Then
Local $allchecked = True
Local $iCV = $iColorVariation
For $i = 0 To UBound($offColor) - 1
If $offColorVariation = True Then $iCV = $offColor[$i][3]
If _ColorCheck(_GetPixelColor($x + $offColor[$i][1], $y + $offColor[$i][2]), Hex($offColor[$i][0], 6), $iCV) = False Then
$allchecked = False
ExitLoop
EndIf
Next
If $allchecked Then
Local $Pos[2] = [$iLeft + $x, $iTop + $y]
Return $Pos
EndIf
EndIf
Next
Next
Return 0
EndFunc
Func WaitforPixel($iLeft, $iTop, $iRight, $iBottom, $firstColor, $iColorVariation, $maxDelay = 10)
For $i = 1 To $maxDelay * 10
$result = _PixelSearch($iLeft, $iTop, $iRight, $iBottom, $firstColor, $iColorVariation)
If IsArray($result) Then Return True
If _Sleep(50) Then Return
Next
Return False
EndFunc
Func boolPixelSearch($pixel1, $pixel2, $pixel3, $variation = 10)
If _ColorCheck(_GetPixelColor($pixel1[0], $pixel1[1]), $pixel1[2], $variation) And _ColorCheck(_GetPixelColor($pixel2[0], $pixel2[1]), $pixel2[2], $variation) And _ColorCheck(_GetPixelColor($pixel3[0], $pixel3[1]), $pixel3[2], $variation) Then Return True
Return False
EndFunc
Func isInsideDiamondXY($Coordx, $Coordy)
Local $aCoords = [$Coordx, $Coordy]
Return isInsideDiamond($aCoords)
EndFunc
Func isInsideDiamond($aCoords)
Local $Left = 10, $Right = 847, $Top = 30, $Bottom = 660
Local $aDiamond[2][2] = [[$Left, $Top], [$Right, $Bottom]]
Local $aMiddle = [($aDiamond[0][0] + $aDiamond[1][0]) / 2, ($aDiamond[0][1] + $aDiamond[1][1]) / 2]
Local $aSize = [$aMiddle[0] - $aDiamond[0][0], $aMiddle[1] - $aDiamond[0][1]]
Local $DX = Abs($aCoords[0] - $aMiddle[0])
Local $DY = Abs($aCoords[1] - $aMiddle[1])
If ($DX / $aSize[0] + $DY / $aSize[1] <= 1) Then
If $aCoords[0] < 68 Then
Return False
ElseIf $aCoords[0] < 412 And $aCoords[1] < 59 Then
Return False
ElseIf $aCoords[0] > 692 And $aCoords[1] < 210 Then
Return False
EndIf
Return True
Else
If $debugSetlog = 1 Then SetDebuglog("Coordinate Outside Village", $COLOR_DEBUG)
Return False
EndIf
EndFunc
Func getBuilderCount($bSuppressLog = False)
Local $sBuilderInfo, $aGetBuilders
If IsMainPage() = True Then
$sBuilderInfo = getBuilders($aBuildersDigits[0], $aBuildersDigits[1])
If StringInStr($sBuilderInfo, "#") > 0 Then
$aGetBuilders = StringSplit($sBuilderInfo, "#", $STR_NOCOUNT)
$iFreeBuilderCount = Int($aGetBuilders[0])
$iTotalBuilderCount = Int($aGetBuilders[1])
If $debugSetlog = 1 And $bSuppressLog = False Then Setlog("No. of Free/Total Builders: " & $iFreeBuilderCount & "/" & $iTotalBuilderCount, $COLOR_DEBUG)
Return True
Else
SetLog("Bad OCR read Free/Total Builders", $COLOR_RED)
EndIf
Else
SetLog("Unable to read Builders info at this time", $COLOR_RED)
EndIf
If $debugSetlog = 1 Or $debugimagesave = 1 Then Debugimagesave("getBuilderCount_")
If checkObstacles() Then checkMainScreen()
Return False
EndFunc
Func BuildingInfo($iXstart, $iYstart)
Local $sBldgText, $sBldgLevel, $aString
Local $aResult[3] = ["", "", ""]
$sBldgText = getNameBuilding($iXstart, $iYstart)
If $sBldgText = "" Then
If _Sleep($iDelayBuildingInfo1) Then Return
$sBldgText = getNameBuilding($iXstart, $iYstart)
EndIf
If $debugSetlog = 1 Then Setlog("Read building Name String = " & $sBldgText, $COLOR_DEBUG)
If StringInStr($sBldgText, "Cart") Then $sBldgText &= " (FakeLevel 100)"
If StringInStr($sBldgText, "Tree") Then $sBldgText &= " (FakeLevel 99)"
If StringInStr($sBldgText, "Mush") Then $sBldgText &= " (FakeLevel 98)"
If StringInStr($sBldgText, "Trunk") Then $sBldgText &= " (FakeLevel 97)"
If StringInStr($sBldgText, "Bush") Then $sBldgText &= " (FakeLevel 96)"
If StringInStr($sBldgText, "Bark") Then $sBldgText &= " (FakeLevel 95)"
If StringInStr($sBldgText, "Gem") Then $sBldgText &= " (FakeLevel 94)"
$aString = StringSplit($sBldgText, "(")
If $aString[0] = 2 Then
If $debugSetlog = 1 Then Setlog("1st $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[1] <> "" Then $aResult[1] = $aString[1]
If $aString[2] <> "" Then
$sBldgLevel = $aString[2]
$aString = StringSplit($sBldgLevel, ")")
If $aString[0] = 2 Then
If StringInStr($aString[1], "Broken") Then $aString[1] &= " 200"
If $debugSetlog = 1 Then Setlog("2nd $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[1] <> "" Then $sBldgLevel = $aString[1]
EndIf
$aString = StringSplit($sBldgLevel, " ")
If $aString[0] = 2 Then
If $debugSetlog = 1 Then Setlog("3rd $aString = " & $aString[0] & ", " & $aString[1] & ", " & $aString[2], $COLOR_DEBUG)
If $aString[2] <> "" Then $aResult[2] = Number($aString[2])
EndIf
EndIf
EndIf
If $aResult[1] <> "" Then $aResult[0] = 1
If $aResult[2] <> "" Then $aResult[0] += 1
If $aResult[2] > 90 Then
If $aResult[2] = 200 Then
$aResult[2] = "Broken"
Else
$aResult[2] = ""
EndIf
EndIf
Return $aResult
EndFunc
Func getNameBuilding($x_start, $y_start)
Return getOcrAndCapture("coc-build", $x_start, $y_start, 377, 27)
EndFunc
Func getGoldVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-g", $x_start, $y_start, 90, 16, True)
EndFunc
Func getRemainTrainTimer($x_start, $y_start)
Return getOcrAndCapture("coc-RemainTrain", $x_start, $y_start, 90, 18, True)
EndFunc
Func getElixirVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-e", $x_start, $y_start, 90, 16, True)
EndFunc
Func getDarkElixirVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-de", $x_start, $y_start, 75, 18, True)
EndFunc
Func getTrophyVillageSearch($x_start, $y_start)
Return getOcrAndCapture("coc-v-t", $x_start, $y_start, 75, 18, True)
EndFunc
Func getTrophyMainScreen($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 50, 16, True)
EndFunc
Func getTrophyLossAttackScreen($x_start, $y_start)
Return getOcrAndCapture("coc-t-p", $x_start, $y_start, 50, 16, True)
EndFunc
Func getUpgradeResource($x_start, $y_start)
Return getOcrAndCapture("coc-u-r", $x_start, $y_start, 98, 16, True)
EndFunc
Func getResourcesMainScreen($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 110, 16, True)
EndFunc
Func getResourcesLoot($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 107, 22, True)
EndFunc
Func getResourcesLootDE($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 75, 22, True)
EndFunc
Func getResourcesLootT($x_start, $y_start)
Return getOcrAndCapture("coc-loot", $x_start, $y_start, 37, 22, True)
EndFunc
Func getResourcesBonus($x_start, $y_start)
Return getOcrAndCapture("coc-bonus", $x_start, $y_start, 98, 16, True)
EndFunc
Func getResourcesBonusPerc($x_start, $y_start)
Return getOcrAndCapture("coc-bonus", $x_start, $y_start, 48, 16, True)
EndFunc
Func getLabUpgrdResourceWht($x_start, $y_start)
Return getOcrAndCapture("coc-lab-w", $x_start, $y_start, 60, 14, True)
EndFunc
Func getLabUpgrdResourceRed($x_start, $y_start)
Return getOcrAndCapture("coc-lab-r", $x_start, $y_start, 60, 14, True)
EndFunc
Func getBldgUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime", $x_start, $y_start, 42, 18)
EndFunc
Func getLabUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime2", $x_start, $y_start, 40, 20)
EndFunc
Func getHeroUpgradeTime($x_start, $y_start)
Return getOcrAndCapture("coc-uptime2", $x_start, $y_start, 68, 20)
EndFunc
Func getChatString($x_start, $y_start, $language)
Return getOcrAndCapture($language, $x_start, $y_start, 280, 16)
EndFunc
Func getBuilders($x_start, $y_start)
Return getOcrAndCapture("coc-Builders", $x_start, $y_start, 40, 18, True)
EndFunc
Func getProfile($x_start, $y_start)
Return getOcrAndCapture("coc-profile", $x_start, $y_start, 46, 11, True)
EndFunc
Func getTroopCountSmall($x_start, $y_start)
Return getOcrAndCapture("coc-t-s", $x_start, $y_start, 53, 15, True)
EndFunc
Func getTroopCountBig($x_start, $y_start)
Return getOcrAndCapture("coc-t-b", $x_start, $y_start, 53, 16, True)
EndFunc
Func getArmyTroopQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-train-quant", $x_start, $y_start, 40, 20, True)
EndFunc
Func getArmyTroopKind($x_start, $y_start)
Return getOcrAndCapture("coc-train-t-kind", $x_start, $y_start, 59, 11, True)
EndFunc
Func getArmyCampCap($x_start, $y_start)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 82, 16, True)
EndFunc
Func getCastleDonateCap($x_start, $y_start)
Return getOcrAndCapture("coc-army", $x_start, $y_start, 30, 14, True)
EndFunc
Func getBarracksTroopQuantity($x_start, $y_start)
Local $result = getOcrAndCapture("coc-train", $x_start, $y_start, 45, 18, True)
If $result <> "" Or $result <> " " Then
Local $StringSlipt = StringSplit($result, "x", $STR_NOCOUNT)
If UBound($StringSlipt) > 0 And Number($StringSlipt[0]) < 100 Then
Return $StringSlipt[0]
Else
Setlog("Error on OCR 'coc-train'!", $COLOR_RED)
Return ""
EndIf
Else
Return 0
EndIf
EndFunc
Func getAttackDisable($x_start, $y_start)
Return getOcrAndCapture("coc-dis", $x_start, $y_start, 118, 24, True)
EndFunc
Func getOcrLanguage($x_start, $y_start)
Return getOcrAndCapture("coc-ms-testl", $x_start, $y_start, 43, 11, True)
EndFunc
Func getOcrSpellDetection($x_start, $y_start)
Local $result = getOcrAndCapture("coc-t-spells2", $x_start, $y_start, 50, 30, True)
Local $PositionSpecialCaracter = 0
$PositionSpecialCaracter = StringInStr($result, "Â§")
If $PositionSpecialCaracter > 0 Then
Return StringLeft($result, $PositionSpecialCaracter - 1)
Else
Return $result
EndIf
EndFunc
Func getOcrSpellQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-t-t", $x_start, $y_start, 25, 12, True)
EndFunc
Func getOcrClanLevel($x_start, $y_start)
Return getOcrAndCapture("coc-clanlevel", $x_start, $y_start, 20, 19, True)
EndFunc
Func getOcrSpaceCastleDonate($x_start, $y_start)
Return getOcrAndCapture("coc-totalreq", $x_start, $y_start, 45, 12, True)
EndFunc
Func getOcrDonationTroopsDetection($x_start, $y_start)
Local $result = getOcrAndCapture("coc-donationtroop", $x_start, $y_start, 45, 30, True)
Local $PositionSpecialCaracter = 0
$PositionSpecialCaracter = StringInStr($result, "Â§")
If $PositionSpecialCaracter > 0 Then
Return StringLeft($result, $PositionSpecialCaracter - 1)
Else
Return $result
EndIf
EndFunc
Func getOcrOverAllDamage($x_start, $y_start)
Return getOcrAndCapture("coc-overalldamage", $x_start, $y_start, 50, 20, True)
EndFunc
Func getOcrGuardShield($x_start, $y_start)
Return getOcrAndCapture("coc-guardshield", $x_start, $y_start, 68, 15)
EndFunc
Func getOcrPBTtime($x_start, $y_start)
Return getOcrAndCapture("coc-pbttime", $x_start, $y_start, 59, 15)
EndFunc
Func getOcrMaintenanceTime($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-reloadmsg", $x_start, $y_start, 116, 19, True)
Local $String = $sLogText & " " & $result
If $debugSetlog = 1 And $sLogText <> Default And IsString($sLogText) Then
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
ElseIf $result <> "" Then
SetDebugLog($String, $LogTextColor, True)
EndIf
Return $result
EndFunc
Func getOcrRateCoc($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-ratecoc", $x_start, $y_start, 42, 18, True)
Local $String = $sLogText & " " & $result
If $debugSetlog = 1 And $sLogText <> Default And IsString($sLogText) Then
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
ElseIf $result <> "" Then
SetDebugLog($String, $LogTextColor, True)
EndIf
Return $result
EndFunc
Func getRemainTLaboratory($x_start, $y_start)
Return getOcrAndCapture("coc-RemainLaboratory", $x_start, $y_start, 192, 24)
EndFunc
Func getRemainTHero($x_start, $y_start)
Return getOcrAndCapture("coc-remainhero", $x_start, $y_start, 38, 12, True)
EndFunc
Func getHeroStatus($x_start, $y_start)
Return getOcrAndCapture("coc-herostatus", $x_start, $y_start, 20, 20)
EndFunc
Func getCloudTextShort($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-cloudsearch", $x_start, $y_start, 51, 27)
If $debugSetlog = 1 And $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & $result
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return $result
EndFunc
Func getCloudFailShort($x_start, $y_start, $sLogText = Default, $LogTextColor = Default, $bSilentSetLog = Default)
Local $result = getOcrAndCapture("coc-cloudfail", $x_start, $y_start, 72, 24)
If $debugSetlog = 1 And $sLogText <> Default And IsString($sLogText) Then
Local $String = $sLogText & $result
SetDebugLog($String, $LogTextColor, $bSilentSetLog)
EndIf
Return $result
EndFunc
Func getBarracksNewTroopQuantity($x_start, $y_start)
Return getOcrAndCapture("coc-newarmy", $x_start, $y_start, 45, 18, True)
EndFunc
Func getArmyCapacityOnTrainTroops($x_start, $y_start)
Return getOcrAndCapture("coc-NewCapacity", $x_start, $y_start, 67, 14, True)
EndFunc
Func getQueueTroopsQuantity($x_start, $y_start)
Return StringReplace(getOcrAndCapture("coc-qqtroop", $x_start, $y_start, 71, 22, True), "b", "")
EndFunc
Func getVillageExp($x_start, $y_start, $removeSpace = False)
Return getOcrAndCapture("coc-ms", $x_start, $y_start, 70, 22, $removeSpace)
EndFunc
Func getOcrAndCapture($language, $x_start, $y_start, $width, $height, $removeSpace = False)
_CaptureRegion2($x_start, $y_start, $x_start + $width, $y_start + $height)
Local $result = getOcr($hHBitmap2, $language)
If ($removeSpace) Then
$result = StringReplace($result, " ", "")
EndIf
Return $result
EndFunc
Func getOcr($hBitmap, $language)
Local $result = DllCall($hFuncLib, "str", "ocr", "ptr", $hBitmap, "str", $language, "int", $debugOcr)
If IsArray($result) Then
Return $result[0]
Else
Return ""
EndIf
EndFunc
Func getPBTime()
Local $sTimeResult = ""
Local $aString[3]
Local $bPBTStart = False
Local $iPBTSeconds, $Result
Local $iHour = 0, $iMin = 0, $iSec = 0
Local $sPBTReturnResult = ""
If IsMainPage() = False Then
Setlog("Not on Main page to read PB information", $COLOR_RED)
Return
EndIf
ClickP($aShieldInfoButton)
If _Sleep($iPersonalShield3) Then Return
Local $iCount = 0
While _CheckPixel($aIsShieldInfo, $bCapturePixel) = False
If _Sleep($iPersonalShield2) Then Return
$Result = getAttackDisable(180, 156 + $midOffsetY)
If $debugSetlog = 1 Then Setlog("OCR PBT early warning= " & $Result, $COLOR_DEBUG)
If (StringLen($Result) > 3) And StringRegExp($Result, "[a-w]", $STR_REGEXPMATCH) Then
Setlog("Personal Break Warning found!", $COLOR_BLUE)
$bPBTStart = True
ExitLoop
EndIf
$iCount += 1
If $iCount > 20 Then
Setlog("PBT information window failed to open", $COLOR_DEBUG)
If $debugImageSave = 1 Then DebugImageSave("PBTInfo_", $bCapturePixel, "png", False)
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
EndIf
WEnd
If _CheckPixel($aIsShieldInfo, $bCapturePixel) Or $bPBTStart Then
$sTimeResult = getOcrPBTtime(555, 499 + $midOffsetY)
If $debugSetlog = 1 Then Setlog("OCR PBT Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
If _Sleep($iPersonalShield2) Then Return
$sTimeResult = getOcrPBTtime(555, 499 + $midOffsetY)
If $debugSetlog = 1 Then Setlog("OCR2 PBT Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" And $bPBTStart = False Then
Setlog("strange error, no PBT value found?", $COLOR_RED)
SetError(1, "Bad OCR of PB time value ")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
EndIf
EndIf
If _Sleep($iDelayRespond) Then Return
$aString = StringSplit($sTimeResult, " ")
Switch $aString[0]
Case 1
Select
Case StringInStr($aString[1], "s", $STR_NOCASESENSEBASIC)
$iSec = Number($aString[1])
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[2])
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
Case Else
Setlog("strange error, unexpected PBT value? |" & $aString[1], $COLOR_RED)
SetError(2, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
EndSelect
Case 2
Select
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
If StringInStr($aString[2], "m", $STR_NOCASESENSEBASIC) Then
$iMin = Number($aString[2])
EndIf
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[1])
If StringInStr($aString[2], "s", $STR_NOCASESENSEBASIC) Then
$iSec = Number($aString[2])
EndIf
Case Else
Setlog("strange error, unexpected PBT value? |" & $aString[1] & "|" & $aString[2], $COLOR_RED)
SetError(3, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
EndSelect
Case Else
If $bPBTStart = False Then
Setlog("Error processing PBT time string: " & $sTimeResult, $COLOR_RED)
SetError(4, "Error processing time string")
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return
Else
Setlog("Error processing PBT time string: " & $sTimeResult, $COLOR_BLUE)
Setlog("Continue due PB starting now", $COLOR_GREEN)
EndIf
EndSwitch
$iPBTSeconds = ($iHour * 3600) + ($iMin * 60) + $iSec
If $debugSetlog = 1 Then Setlog("Computed PBT Seconds = " & $iPBTSeconds, $COLOR_DEBUG)
If $bPBTStart Then
$sPBTReturnResult = _DateAdd('s', -10, _NowCalc())
Else
$sPBTReturnResult = _DateAdd('s', $iPBTSeconds, _NowCalc())
EndIf
If @error Then Setlog("_DateAdd error= " & @error, $COLOR_RED)
If $debugSetlog = 1 Then Setlog("PBT starts: " & $sPBTReturnResult, $COLOR_DEBUG)
If _Sleep($iPersonalShield1) Then Return
ClickP($aAway, 1, 0, "#9999")
If _Sleep($iPersonalShield2) Then Return
Return $sPBTReturnResult
Else
If $debugSetlog = 1 Then SetLog("PB Info window failed to open for PB Time OCR", $COLOR_DEBUG)
EndIf
EndFunc
Func getShieldInfo()
Local $sTimeResult = ""
Local $aString[3]
Local $iShieldSeconds
Local $iDay = 0, $iHour = 0, $iMin = 0, $iSec = 0
Local $aPBReturnResult[3] = ["", "", ""]
$aPBReturnResult[1] = StringFormat("%02s", ($iDay * 24) + $iHour) & ":" & StringFormat("%02s", $iMin) & ":" & StringFormat("%02s", $iSec)
If IsMainPage() = False Then
Setlog("unable to read shield information", $COLOR_RED)
Return
EndIf
Select
Case _CheckPixel($aNoShield, $bCapturePixel)
$aPBReturnResult[0] = "none"
If $debugSetlog = 1 Then Setlog("No shield active", $COLOR_DEBUG)
Return $aPBReturnResult
Case _CheckPixel($aHaveShield, $bCapturePixel)
$aPBReturnResult[0] = "shield"
If $debugSetlog = 1 Then Setlog("Shield Active", $COLOR_DEBUG)
Case _CheckPixel($aHavePerGuard, $bCapturePixel)
$aPBReturnResult[0] = "guard"
If $debugSetlog = 1 Then Setlog("Guard Active", $COLOR_DEBUG)
Case Else
Setlog("Sorry, Monkey needs more bananas to read shield type", $COLOR_RED)
SetError(1, "Bad shield pixel read")
Return
EndSelect
$sTimeResult = getOcrGuardShield(484, 21)
If $debugSetlog = 1 Then Setlog("OCR Shield Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
If _Sleep($iPersonalShield2) Then Return
$sTimeResult = getOcrGuardShield(484, 21)
If $debugSetlog = 1 Then Setlog("OCR2 Shield Time= " & $sTimeResult, $COLOR_DEBUG)
If $sTimeResult = "" Then
$aPBReturnResult[1] = '00:00:00'
Setlog("strange error, no shield value found?", $COLOR_RED)
SetError(2, "Bad time value OCR")
Return $aPBReturnResult
EndIf
EndIf
If _Sleep($iPersonalShield3) Then Return
$aString = StringSplit($sTimeResult, " ")
Switch $aString[0]
Case 1
If StringInStr($aString[1], "s", $STR_NOCASESENSEBASIC) Then $iSec = Number($aString[1])
Case 2
Select
Case StringInStr($aString[1], "d", $STR_NOCASESENSEBASIC)
$iDay = Number($aString[1])
If StringInStr($aString[2], "h", $STR_NOCASESENSEBASIC) Then
$iHour = Number($aString[2])
EndIf
Case StringInStr($aString[1], "h", $STR_NOCASESENSEBASIC)
$iHour = Number($aString[1])
If StringInStr($aString[2], "m", $STR_NOCASESENSEBASIC) Then
$iMin = Number($aString[2])
EndIf
Case StringInStr($aString[1], "m", $STR_NOCASESENSEBASIC)
$iMin = Number($aString[1])
If StringInStr($aString[2], "s", $STR_NOCASESENSEBASIC) Then
$iSec = Number($aString[2])
EndIf
Case Else
Setlog("strange error, unexpected shield value?", $COLOR_RED)
SetError(3, "Error processing time string")
Return $aPBReturnResult
EndSelect
Case Else
Setlog("Error processing time string: " & $sTimeResult, $COLOR_RED)
SetError(4, "Error processing time string")
Return $aPBReturnResult
EndSwitch
$aPBReturnResult[1] = StringFormat("%02s", ($iDay * 24) + $iHour) & ":" & StringFormat("%02s", $iMin) & ":" & StringFormat("%02s", $iSec)
If $debugSetlog = 1 Then Setlog("Shield Time String = " & $aPBReturnResult[1], $COLOR_DEBUG)
$iShieldSeconds = ($iDay * 86400) + ($iHour * 3600) + ($iMin * 60) + $iSec
If $debugSetlog = 1 Then Setlog("Computed Shield Seconds = " & $iShieldSeconds, $COLOR_DEBUG)
$aPBReturnResult[2] = _DateAdd('s', $iShieldSeconds, _NowCalc())
If @error Then Setlog("_DateAdd error= " & @error, $COLOR_RED)
If $debugSetlog = 1 Then Setlog("Shield expires at: " & $aPBReturnResult[2], $COLOR_DEBUG)
Return $aPBReturnResult
EndFunc
Func updateMultiSearchStats($aResult, $statFile = "")
Switch $statFile
Case $statChkWeakBase
updateWeakBaseStats($aResult)
Case Else
EndSwitch
EndFunc
Func addInfoToDebugImage($hGraphic, $hPen, $fileName, $x, $y)
_GDIPlus_GraphicsDrawRect($hGraphic, $x - 5, $y - 5, 10, 10, $hPen)
Local $hBrush = _GDIPlus_BrushCreateSolid(0xFFFFFFFF)
Local $hFormat = _GDIPlus_StringFormatCreate()
Local $hFamily = _GDIPlus_FontFamilyCreate("Tahoma")
Local $hFont = _GDIPlus_FontCreate($hFamily, 12, 2)
Local $tLayout = _GDIPlus_RectFCreate($x + 10, $y, 0, 0)
Local $sString = String($fileName)
Local $aInfo = _GDIPlus_GraphicsMeasureString($hGraphic, $sString, $hFont, $tLayout, $hFormat)
_GDIPlus_GraphicsDrawStringEx($hGraphic, $sString, $hFont, $aInfo[0], $hFormat, $hBrush)
_GDIPlus_FontDispose($hFont)
_GDIPlus_FontFamilyDispose($hFamily)
_GDIPlus_StringFormatDispose($hFormat)
_GDIPlus_BrushDispose($hBrush)
EndFunc
Func captureDebugImage($aResult, $subDirectory)
Local $coords
If IsArray($aResult) Then
DirCreate($dirTempDebug & $subDirectory)
_CaptureRegion()
Local $editedImage = $hBitmap
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
Local $fileName = String($Date & "_" & $Time & ".png")
Local $hGraphic = _GDIPlus_ImageGetGraphicsContext($editedImage)
Local $hPen = _GDIPlus_PenCreate(0xFFFF0000, 2)
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][4]) > 0 Then
$coords = $aResult[$i][5]
If IsArray($coords) Then
For $j = 0 To UBound($coords) - 1
addInfoToDebugImage($hGraphic, $hPen, $aResult[$i][0], $coords[$j][0], $coords[$j][1])
Next
EndIf
EndIf
Next
_GDIPlus_GraphicsDrawString($hGraphic, "Time Taken:" & $aResult[0][2] & " " & $aResult[0][3], 350, 50, "Verdana", 20)
_GDIPlus_ImageSaveToFile($editedImage, $dirTempDebug & $subDirectory & "\" & $fileName)
_GDIPlus_PenDispose($hPen)
_GDIPlus_GraphicsDispose($hGraphic)
EndIf
EndFunc
Func returnPropertyValue($key, $property)
Local $aValue = DllCall($hImgLib, "str", "GetProperty", "str", $key, "str", $property)
Return $aValue[0]
EndFunc
Func updateResultsRow(ByRef $aResult, $redLines = "")
Local $numberFound = 0
If IsArray($aResult) Then
If UBound($aResult) > 1 Then
For $j = 1 To UBound($aResult) - 1
$numberFound += Number($aResult[$j][4])
Next
EndIf
$aResult[0][0] = $redLines
$aResult[0][1] = $numberFound
Else
EndIf
EndFunc
Func multiMatches($directory, $maxReturnPoints = 0, $fullCocAreas = $DCD, $redLines = "", $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $aResult[1][6] = [["", 0, 0, "Seconds", "", ""]], $aCoordArray[0][0], $aCoords, $aCoordsSplit, $aValue
_CaptureRegion2()
Local $hTimer = TimerInit()
$res = DllCall($hImgLib, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
$aValue = DllCall($hImgLib, "str", "GetProperty", "str", "redline", "str", "")
$redLines = $aValue[0]
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys) + 1][6]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i + 1][0] = returnPropertyValue($aKeys[$i], "filename")
$aResult[$i + 1][1] = returnPropertyValue($aKeys[$i], "objectname")
$aResult[$i + 1][2] = returnPropertyValue($aKeys[$i], "objectlevel")
$aResult[$i + 1][3] = returnPropertyValue($aKeys[$i], "filllevel")
$aResult[$i + 1][4] = returnPropertyValue($aKeys[$i], "totalobjects")
$aValue = returnPropertyValue($aKeys[$i], "objectpoints")
$aCoords = StringSplit($aValue, "|", $STR_NOCOUNT)
ReDim $aCoordArray[UBound($aCoords)][2]
For $j = 0 To UBound($aCoords) - 1
$aCoordsSplit = StringSplit($aCoords[$j], ",", $STR_NOCOUNT)
If UBound($aCoordsSplit) = 2 Then
$aCoordArray[$j][0] = $aCoordsSplit[0]
$aCoordArray[$j][1] = $aCoordsSplit[1]
EndIf
Next
$aResult[$i + 1][5] = $aCoordArray
Next
EndIf
Local $timertemp = Round(TimerDiff($hTimer)/1000,2)
$aResult[0][2] = $timertemp
updateResultsRow($aResult, $redLines)
updateMultiSearchStats($aResult, $statFile)
Return $aResult
EndFunc
Func multiMatches2($directory, $maxReturnPoints = 0, $fullCocAreas = $DCD, $redLines = "", $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $aResult[1][6] = [["", 0, 0, "Seconds", "", ""]], $aCoordArray[0][0], $aCoords, $aCoordsSplit, $aValue
_CaptureRegion2()
$res = DllCall($hImgLib, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
Local $strPositions = ""
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($aKeys) - 1
$aValue = returnPropertyValue($aKeys[$i], "objectpoints")
$strPositions &= $aValue & "|"
Next
EndIf
If StringRight($strPositions, 1) = "|" Then $strPositions = StringLeft($strPositions, StringLen($strPositions) - 1)
Return $strPositions
EndFunc
Func multiMatchesPixelOnly($directory, $maxReturnPoints = 0, $fullCocAreas = $ECD, $redLines = "", $statFile = "", $minLevel = 0, $maxLevel = 1000, $x1 = 0, $y1 = 0, $x2 = $GAME_WIDTH, $y2 = $GAME_HEIGHT)
Local $Result = ""
_CaptureRegion2($x1, $y1, $x2, $y2)
$res = DllCall($hImgLib, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($aKeys) - 1
$Result &= returnPropertyValue($aKeys[$i], "objectpoints") & "|"
Next
EndIf
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result, (StringLen($Result) - 1))
Return $Result
EndFunc
Func SearchWalls($directory, $minLevel = 0, $maxLevel = 11, $maxReturnPoints = 0, $fullCocAreas = $ECD, $redLines = $ECD, $statFile = "")
Local $DebugIt = False
Local $aResult[1][4]
Local $i
_CaptureRegion2()
$res = DllCall($hImgLib, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", $fullCocAreas, "Int", $maxReturnPoints, "str", $redLines, "Int", $minLevel, "Int", $maxLevel)
If $res[0] <> "" Then
Local $aKeys = StringSplit($res[0], "|", $STR_NOCOUNT)
ReDim $aResult[UBound($aKeys) + 1][6]
For $i = 0 To UBound($aKeys) - 1
$aResult[$i][1] = returnPropertyValue($aKeys[$i], "objectlevel")
$aResult[$i][2] = returnPropertyValue($aKeys[$i], "totalobjects")
$aResult[$i][3] = returnPropertyValue($aKeys[$i], "filename")
If $DebugIt = True Then
SetLog("Found x" & $aResult[$i][2] & " Level #" & $aResult[$i][1] & " Walls By '" & $aResult[$i][3] & "' Image")
EndIf
$aValue = returnPropertyValue($aKeys[$i], "objectpoints")
$aValue = StringReplace($aValue, ",", "-")
$aResult[$i][0] = $aValue
Next
EndIf
updateMultiSearchStats($aResult, $statFile)
If $i = 1 Then _ArrayDelete($aResult, 1)
Return $aResult
EndFunc
Func returnMultipleMatchesOwnVillage($directory, $maxReturnPoints = 0, $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $aResult = multiMatches($directory, $maxReturnPoints, $ECD, $ECD, $statFile, $minLevel, $maxLevel)
Return $aResult
EndFunc
Func returnSingleMatchOwnVillage($directory, $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $aResult = multiMatches($directory, 1, $ECD, $ECD, $statFile, $minLevel, $maxLevel)
Return $aResult
EndFunc
Func returnAllMatches($directory, $redLines = "", $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $aResult = multiMatches($directory, 0, $DCD, $redLines, $statFile, $minLevel, $maxLevel)
Return $aResult
EndFunc
Func returnAllMatchesDefense($directory, $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $aResult = multiMatches2($directory, 0, $DCD, $CurBaseRedLine, $statFile, $minLevel, $maxLevel)
Return $aResult
EndFunc
Func returnHighestLevelSingleMatch($directory, $redLines = "", $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $defaultCoords[1][2] = [[0, 0]]
Local $return[7] = ["None", "None", 0, 0, 0, $defaultCoords, ""]
Local $aResult = multiMatches($directory, 1, $ECD, $redLines, $statFile, $minLevel, $maxLevel)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) > Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[2] = $aResult[$i][2]
$return[3] = $aResult[$i][3]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
EndIf
$return[6] = $aResult[0][0]
Return $return
EndFunc
Func returnLowestLevelSingleMatch($directory, $returnMax = 100, $redLines = "", $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $defaultCoords[1][2] = [[0, 0]]
Local $return[7] = ["None", "None", $returnMax + 1, 0, 0, $defaultCoords, ""]
Local $aResult = multiMatches($directory, 1, $DCD, $redLines, $statFile, $minLevel, $maxLevel)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
If Number($aResult[$i][2]) < Number($return[2]) Then
$return[0] = $aResult[$i][0]
$return[1] = $aResult[$i][1]
$return[2] = $aResult[$i][2]
$return[3] = $aResult[$i][3]
$return[4] = $aResult[$i][4]
$return[5] = $aResult[$i][5]
EndIf
Next
EndIf
$return[6] = $aResult[0][0]
Return $return
EndFunc
Func returnMultipleMatches($directory, $maxReturnPoints = 0, $redLines = "", $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $aResult = multiMatches($directory, $maxReturnPoints, $DCD, $redLines, $statFile, $minLevel, $maxLevel)
Return $aResult
EndFunc
Func returnSingleMatch($directory, $redLines = "", $statFile = "", $minLevel = 0, $maxLevel = 1000)
Local $aResult = multiMatches($directory, 1, $DCD, $redLines, $statFile, $minLevel, $maxLevel)
Return $aResult
EndFunc
Global Enum $eWeakEagle = 1, $eWeakInferno, $eWeakXBow, $eWeakWizard, $eWeakMortar, $eWeakAirDefense = 6
Global $weakDefenseNames[7] = ["None", "Eagle Artillery", "Inferno Tower", "XBow", "Wizard Tower", "Mortar", "Air Defense"]
Global $weakDefenseMaxLevels[7] = [0, 2, 4, 4, 9, 9, 8]
Func createWeakBaseStats()
Local $aKeys = _FileListToArrayRec(@ScriptDir & "\images\WeakBase", "*.png", $FLTAR_FILES, $FLTAR_RECUR, $FLTAR_SORT, $FLTAR_NOPATH)
Local $return[UBound($aKeys) - 1][2]
If Not FileExists($statChkWeakBase) Then _FileCreate($statChkWeakBase)
For $i = 1 To UBound($aKeys) - 1
$return[$i - 1][0] = $aKeys[$i]
$return[$i - 1][1] = 0
IniWrite($statChkWeakBase, "WeakBase", $aKeys[$i], "0")
Next
Return $return
EndFunc
Func readWeakBaseStats()
Local $aKeys = _FileListToArrayRec(@ScriptDir & "\images\WeakBase", "*.png", $FLTAR_FILES, $FLTAR_RECUR, $FLTAR_SORT, $FLTAR_NOPATH)
Local $return[UBound($aKeys) - 1][2]
If FileExists($statChkWeakBase) Then
For $i = 1 To UBound($aKeys) - 1
$return[$i - 1][0] = $aKeys[$i]
$return[$i - 1][1] = IniRead($statChkWeakBase, "WeakBase", $aKeys[$i], "0")
Next
Else
$return = createWeakBaseStats()
EndIf
Return $return
EndFunc
Func saveWeakBaseStats()
Local $hFile = FileOpen($statChkWeakBase, $FO_OVERWRITE)
For $j = 0 To UBound($aWeakBaseStats) - 1
IniWrite($statChkWeakBase, "WeakBase", $aWeakBaseStats[$j][0], $aWeakBaseStats[$j][1])
Next
FileClose($hFile)
EndFunc
Func updateWeakBaseStats($aResult)
If IsArray($aResult) Then
For $i = 1 To UBound($aResult) - 1
For $j = 0 To UBound($aWeakBaseStats) - 1
If $aWeakBaseStats[$j][0] = $aResult[$i][0] Then
$aWeakBaseStats[$j][1] = Number($aWeakBaseStats[$j][1]) + 1
EndIf
Next
Next
EndIf
EndFunc
Func displayWeakBaseLog($aResult, $showLog = False)
If $showLog And IsArray($aResult) Then
SetLog("================ Weak Base Detection Start ================", $COLOR_BLUE)
SetLog("Highest Eagle Artillery: " & $aResult[1][0] & " - Level: " & $aResult[1][2], $COLOR_BLUE)
SetLog("Highest Inferno Tower: " & $aResult[2][0] & " - Level: " & $aResult[2][2], $COLOR_BLUE)
SetLog("Highest X-Bow: " & $aResult[3][0] & " - Level: " & $aResult[3][2], $COLOR_BLUE)
SetLog("Highest Wizard Tower: " & $aResult[4][0] & " - Level: " & $aResult[4][2], $COLOR_BLUE)
SetLog("Highest Mortar: " & $aResult[5][0] & " - Level: " & $aResult[5][2], $COLOR_BLUE)
SetLog("Highest Air Defense: " & $aResult[6][0] & " - Level: " & $aResult[6][2], $COLOR_BLUE)
SetLog("Time taken: " & $aResult[0][2] & " " & $aResult[0][3], $COLOR_BLUE)
SetLog("================ Weak Base Detection Stop =================", $COLOR_BLUE)
EndIf
EndFunc
Func getTHDefenseMax($levelTownHall, $defenseType)
Local $maxTH = 11
Local $eagleLevels[$maxTH] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2]
Local $infernoLevels[$maxTH] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4]
Local $mortarLevels[$maxTH] = [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Local $wizardLevels[$maxTH] = [0, 0, 0, 0, 2, 3, 4, 6, 7, 8, 9]
Local $xbowLevels[$maxTH] = [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 4]
Local $adefenseLevels[$maxTH] = [0, 0, 0, 2, 3, 4, 5, 6, 7, 8, 8]
If $levelTownHall = 0 Then $levelTownHall = $maxTH
Local $result = 100
If $levelTownHall <= $maxTH Then
Switch $defenseType
Case $eWeakEagle
$result = $eagleLevels[$levelTownHall - 1]
Case $eWeakInferno
$result = $infernoLevels[$levelTownHall - 1]
Case $eWeakXBow
$result = $xbowLevels[$levelTownHall - 1]
Case $eWeakWizard
$result = $wizardLevels[$levelTownHall - 1]
Case $eWeakMortar
$result = $mortarLevels[$levelTownHall - 1]
Case $eWeakAirDefense
$result = $adefenseLevels[$levelTownHall - 1]
Case Else
EndSwitch
EndIf
Return $result
EndFunc
Func getMaxUISetting($settingArray, $defenseType)
Local $result = 0, $maxDB = 0, $maxLB = 0
If IsArray($settingArray) Then
$maxDB = ($iDBcheck = 1 And IsWeakBaseActive($DB)) ? $settingArray[$DB] : 0
$maxLB = ($iABcheck = 1 And IsWeakBaseActive($LB)) ? $settingArray[$LB] : 0
$result = _Max(Number($maxDB), Number($maxLB))
EndIf
If $debugSetLog = 1 Then SetLog("Max " & $weakDefenseNames[$defenseType] & " Level: " & $result, $COLOR_DEBUG)
Return $result
EndFunc
Func getMinUISetting($settingArray, $defenseType)
Local $result = 0, $minDB = 0, $minLB = 0
If IsArray($settingArray) Then
$minDB = ($iDBcheck = 1 And IsWeakBaseActive($DB)) ? $settingArray[$DB] : 0
$minLB = ($iABcheck = 1 And IsWeakBaseActive($LB)) ? $settingArray[$LB] : 0
$result = _Min(Number($minDB), Number($minLB))
EndIf
If $debugSetLog = 1 Then SetLog("Min " & $weakDefenseNames[$defenseType] & " Level: " & $result, $COLOR_DEBUG)
Return $result
EndFunc
Func getIsWeak($aResults, $searchType)
Return $aResults[$eWeakEagle][2] <= Number($iCmbWeakEagle[$searchType])  And $aResults[$eWeakInferno][2] <= Number($iCmbWeakInferno[$searchType])  And $aResults[$eWeakXBow][2] <= Number($iCmbWeakXBow[$searchType])  And $aResults[$eWeakWizard][2] <= Number($iCmbWeakWizTower[$searchType])  And $aResults[$eWeakMortar][2] <= Number($iCmbWeakMortar[$searchType])  And $aResults[$eWeakAirDefense][2] <= Number($iCmbWeakAirDefense[$searchType])
EndFunc
Func IsWeakBaseActive($type)
Return BitOr($iChkMaxEagle[$type],$iChkMaxInferno[$type],$iChkMaxXBow[$type],$iChkMaxWizTower[$type],$iChkMaxMortar[$type],$iChkMaxAirDefense[$type])
EndFunc
Func defenseSearch(ByRef $aResult, $directory, $townHallLevel, $settingArray, $defenseType, ByRef $performSearch, $guiEnabledArray)
Local $defaultCoords[1][2] = [[0, 0]]
Local $aDefenseResult[7] = ["Skipped", "Skipped", $weakDefenseMaxLevels[$defenseType], 0, 0, $defaultCoords, ""]
Local $aNotNecessary[7] = ["None", "None", 0, 0, 0, $defaultCoords, ""]
Local $minSearchLevel = getMinUISetting($settingArray, $defenseType) + 1
Local $maxSearchLevel = getTHDefenseMax($townHallLevel, $defenseType)
Local $guiCheckDefense = IsArray($guiEnabledArray) And (Number($guiEnabledArray[$DB]) = 1 Or Number($guiEnabledArray[$LB] = 1))
If $performSearch Then
Local $defenseTimer = TimerInit()
If $guiCheckDefense And $maxSearchLevel >= $minSearchLevel Then
$aDefenseResult = returnHighestLevelSingleMatch($directory, $aResult[0][0], $statChkWeakBase, $minSearchLevel, $maxSearchLevel)
If $aResult[0][0] = "" Then $aResult[0][0] = $aDefenseResult[6]
If Number($aDefenseResult[2]) > getMaxUISetting($settingArray, $defenseType) Then $performSearch = False
If $debugSetLog = 1 Then SetLog("checkDefense: " & $weakDefenseNames[$defenseType] & " - " & Round(TimerDiff($defenseTimer) / 1000, 2) & " seconds", $COLOR_DEBUG)
Else
$aDefenseResult = $aNotNecessary
If $debugSetLog = 1 Then SetLog("checkDefense: " & $weakDefenseNames[$defenseType] & " not necessary!", $COLOR_DEBUG)
EndIf
EndIf
Return $aDefenseResult
EndFunc
Func weakBaseCheck($townHallLevel = 11, $redlines = "")
Local $defaultCoords[1][2] = [[0, 0]]
Local $aResult[7][6] = [[$redlines, 0, 0, "Seconds", "", ""],  ["Skipped", "Skipped", 2, 0, 0, $defaultCoords],  ["Skipped", "Skipped", 4, 0, 0, $defaultCoords],  ["Skipped", "Skipped", 4, 0, 0, $defaultCoords],  ["Skipped", "Skipped", 9, 0, 0, $defaultCoords],  ["Skipped", "Skipped", 9, 0, 0, $defaultCoords],  ["Skipped", "Skipped", 8, 0, 0, $defaultCoords]]
Local $aEagleResults, $aInfernoResults, $aMortarResults, $aWizardTowerResults, $aXBowResults, $aAirDefenseResults
Local $performSearch = True
Local $hWeakTimer = TimerInit()
$aEagleResults = defenseSearch($aResult, @ScriptDir & "\images\WeakBase\Eagle", $townHallLevel, $iCmbWeakEagle, $eWeakEagle, $performSearch, $iChkMaxEagle)
$aInfernoResults = defenseSearch($aResult, @ScriptDir & "\images\WeakBase\Infernos", $townHallLevel, $iCmbWeakInferno, $eWeakInferno, $performSearch, $iChkMaxInferno)
$aXBowResults = defenseSearch($aResult, @ScriptDir & "\images\WeakBase\Xbow", $townHallLevel, $iCmbWeakXBow, $eWeakXBow, $performSearch, $iChkMaxXBow)
$aWizardTowerResults = defenseSearch($aResult, @ScriptDir & "\images\WeakBase\WTower", $townHallLevel, $iCmbWeakWizTower, $eWeakWizard, $performSearch, $iChkMaxWizTower)
$aMortarResults = defenseSearch($aResult, @ScriptDir & "\images\WeakBase\Mortars", $townHallLevel, $iCmbWeakMortar, $eWeakMortar, $performSearch, $iChkMaxMortar)
$aAirDefenseResults = defenseSearch($aResult, @ScriptDir & "\images\WeakBase\ADefense", $townHallLevel, $iCmbWeakAirDefense, $eWeakAirDefense, $performSearch, $iChkMaxAirDefense)
For $i = 1 To UBound($aResult) - 1
For $j = 0 To UBound($aResult, 2) - 1
Switch $i
Case $eWeakEagle
If IsArray($aEagleResults) and $aEagleResults[1] <> "NONE" Then $aResult[$i][$j] = $aEagleResults[$j]
Case $eWeakInferno
If IsArray($aInfernoResults) and $aInfernoResults[1] <> "NONE" Then $aResult[$i][$j] = $aInfernoResults[$j]
Case $eWeakXBow
If IsArray($aXBowResults) and $aXBowResults[1] <> "NONE" Then $aResult[$i][$j] = $aXBowResults[$j]
Case $eWeakWizard
If IsArray($aWizardTowerResults) and $aWizardTowerResults[1] <> "NONE" Then $aResult[$i][$j] = $aWizardTowerResults[$j]
Case $eWeakMortar
If IsArray($aMortarResults) and $aMortarResults[1] <> "NONE" Then $aResult[$i][$j] = $aMortarResults[$j]
Case $eWeakAirDefense
If IsArray($aAirDefenseResults) and $aAirDefenseResults[1] <> "NONE" Then $aResult[$i][$j] = $aAirDefenseResults[$j]
Case Else
EndSwitch
Next
Next
$aResult[0][2] = Round(TimerDiff($hWeakTimer) / 1000, 2)
$aResult[0][3] = "Seconds"
Return $aResult
EndFunc
Func IsWeakBase($townHallLevel = 11, $redlines = "")
Local $aResult = weakBaseCheck($townHallLevel, $redlines)
displayWeakBaseLog($aResult, $debugSetLog = 1)
If Number($aResult[0][2]) > 10 Then
captureDebugImage($aResult, "WeakBase_Detection_TooSlow")
ElseIf $debugImageSave = 1 And Number($aResult[1][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Eagle_NotDetected")
ElseIf $debugImageSave = 1 And Number($aResult[2][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Inferno_NotDetected")
ElseIf $debugImageSave = 1 And Number($aResult[3][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Xbow_NotDetected")
ElseIf $debugImageSave = 1 And Number($aResult[4][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_WTower_NotDetected")
ElseIf $debugImageSave = 1 And Number($aResult[5][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_Mortar_NotDetected")
ElseIf $debugImageSave = 1 And Number($aResult[6][4]) = 0 Then
captureDebugImage($aResult, "WeakBase_Detection_ADefense_NotDetected")
ElseIf $debugImageSave = 1 Then
captureDebugImage($aResult, "WeakBase_Detection")
EndIf
Return $aResult
EndFunc
Func CompareResources($pMode)
If $iChkSearchReduction = 1 Then
If ($iChkEnableAfter[$pMode] = 0 And $SearchCount <> 0 And Mod($SearchCount, $ReduceCount) = 0) Or ($iChkEnableAfter[$pMode] = 1 And $SearchCount - $iEnableAfterCount[$pMode] > 0 And Mod($SearchCount - $iEnableAfterCount[$pMode], $ReduceCount) = 0) Then
If $iAimGold[$pMode] - $ReduceGold >= 0 Then $iAimGold[$pMode] -= $ReduceGold
If $iAimElixir[$pMode] - $ReduceElixir >= 0 Then $iAimElixir[$pMode] -= $ReduceElixir
If $iAimDark[$pMode] - $ReduceDark >= 0 Then $iAimDark[$pMode] -= $ReduceDark
If $iAimTrophy[$pMode] - $ReduceTrophy >= 0 Then $iAimTrophy[$pMode] -= $ReduceTrophy
If $iAimGoldPlusElixir[$pMode] - $ReduceGoldPlusElixir >= 0 Then $iAimGoldPlusElixir[$pMode] -= $ReduceGoldPlusElixir
If $iCmbMeetGE[$pMode] = 2 Then
SetLog("Aim:           [G+E]:" & StringFormat("%7s", $iAimGoldPlusElixir[$pMode]) & " [D]:" & StringFormat("%5s", $iAimDark[$pMode]) & " [T]:" & StringFormat("%2s", $iAimTrophy[$pMode]) & $iAimTHtext[$pMode] & " for: " & $sModeText[$pMode], $COLOR_GREEN, "Lucida Console", 7.5)
Else
SetLog("Aim: [G]:" & StringFormat("%7s", $iAimGold[$pMode]) & " [E]:" & StringFormat("%7s", $iAimElixir[$pMode]) & " [D]:" & StringFormat("%5s", $iAimDark[$pMode]) & " [T]:" & StringFormat("%2s", $iAimTrophy[$pMode]) & $iAimTHtext[$pMode] & " for: " & $sModeText[$pMode], $COLOR_GREEN, "Lucida Console", 7.5)
EndIf
EndIf
EndIf
Local $G = (Number($searchGold) >= Number($iAimGold[$pMode])), $E = (Number($searchElixir) >= Number($iAimElixir[$pMode])), $D = (Number($searchDark) >= Number($iAimDark[$pMode])), $T = (Number($searchTrophy) >= Number($iAimTrophy[$pMode])), $GPE = ((Number($searchGold) + Number($searchElixir)) >= Number($iAimGoldPlusElixir[$pMode]))
If $iChkMeetOne[$pMode] = 1 Then
If $iCmbMeetGE[$pMode] = 0 Then
If $G = True And $E = True Then Return True
EndIf
If $iChkMeetDE[$pMode] = 1 Then
If $D = True Then Return True
EndIf
If $iChkMeetTrophy[$pMode] = 1 Then
If $T = True Then Return True
EndIf
If $iCmbMeetGE[$pMode] = 1 Then
If $G = True Or $E = True Then Return True
EndIf
If $iCmbMeetGE[$pMode] = 2 Then
If $GPE = True Then Return True
EndIf
Return False
Else
If $iCmbMeetGE[$pMode] = 0 Then
If $G = False Or $E = False Then Return False
EndIf
If $iChkMeetDE[$pMode] = 1 Then
If $D = False Then Return False
EndIf
If $iChkMeetTrophy[$pMode] = 1 Then
If $T = False Then Return False
EndIf
If $iCmbMeetGE[$pMode] = 1 Then
If $G = False And $E = False Then Return False
EndIf
If $iCmbMeetGE[$pMode] = 2 Then
If $GPE = False Then Return False
EndIf
EndIf
Return True
EndFunc
Func CompareTH($pMode)
Local $THL = -1, $THLO = -1
For $i = 0 To 5
If $searchTH = $THText[$i] Then $THL = $i
Next
Switch $THLoc
Case "In"
$THLO = 0
Case "Out"
$THLO = 1
EndSwitch
$SearchTHLResult = 0
If $THL > -1 And $THL <= $YourTH And $searchTH <> "-" Then $SearchTHLResult = 1
If $iChkMeetOne[$pMode] = 1 Then
If $iChkMeetTH[$pMode] = 1 Then
If $THL <> -1 And $THL <= $iCmbTH[$pMode] Then Return True
EndIf
If $iChkMeetTHO[$pMode] = 1 Then
If $THLO = 1 Then Return True
EndIf
Return False
Else
If $iChkMeetTH[$pMode] = 1 Then
If $THL = -1 Or $THL > $iCmbTH[$pMode] Then Return False
EndIf
If $iChkMeetTHO[$pMode] = 1 Then
If $THLO <> 1 Then Return False
EndIf
EndIf
Return True
EndFunc
Global $GetResourcesTXT
Func GetResources($bLog = True, $pMatchMode = -1)
If _Sleep($iDelayGetResources1) Then Return
$searchGold = ""
$searchElixir = ""
$searchDark = ""
$searchTrophy = ""
Local $iResult = 0
Local $i = 0
ForceCaptureRegion()
While _CheckPixel($aNoCloudsAttack, $bCapturePixel) = True
If _Sleep($iDelayGetResources1) Then Return
$i += 1
If $i >= 720 Or isProblemAffect(True) Then
$Is_ClientSyncError = True
checkMainScreen()
If $Restart Then
$iNbrOfOoS += 1
UpdateStats()
SetLog("Disconnected At Search Clouds", $COLOR_RED)
PushMsg("OoSResources")
Else
SetLog("Stuck At Search Clouds, Restarting CoC and Bot...", $COLOR_RED)
$Is_ClientSyncError = False
CloseCoC(True)
EndIf
Return
EndIf
If $debugSetlog = 1 Then SetLog("Loop to clean screen without Clouds, # " & $i, $COLOR_DEBUG)
ForceCaptureRegion()
WEnd
SuspendAndroid()
$i = 0
While (getGoldVillageSearch(48, 69) = "") Or (getElixirVillageSearch(48, 69 + 29) = "")
$i += 1
If _Sleep($iDelayGetResources3) Then Return
If $i >= 50 Or isProblemAffect(True) Then ExitLoop
WEnd
If _Sleep($iDelayRespond) Then Return
$searchGold = getGoldVillageSearch(48, 69)
If _Sleep($iDelayRespond) Then Return
$searchElixir = getElixirVillageSearch(48, 69 + 29)
If _Sleep($iDelayRespond) Then Return
If $debugSetlog then SetLog("_GetPixelColor: 31/144: " & _GetPixelColor(31, 144, True))
If _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0a050a, 6), 10) or _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
$searchDark = getDarkElixirVillageSearch(45, 125)
$searchTrophy = getTrophyVillageSearch(45, 167)
Else
$searchDark = "N/A"
$searchTrophy = getTrophyVillageSearch(45, 69 + 69)
EndIf
If $searchGold = $searchGold2 And $searchElixir = $searchElixir2 Then $iStuck += 1
If $searchGold <> $searchGold2 Or $searchElixir <> $searchElixir2 Then $iStuck = 0
$searchGold2 = $searchGold
$searchElixir2 = $searchElixir
If $iStuck >= 5 Or isProblemAffect(True) Then
$iStuck = 0
$Is_ClientSyncError = True
checkMainScreen()
If $Restart Then
$iNbrOfOoS += 1
UpdateStats()
SetLog("Connection Lost While Searching", $COLOR_RED)
PushMsg("OoSResources")
Else
SetLog("Attack Is Disabled Or Slow connection issues, Restarting CoC and Bot...", $COLOR_RED)
$Is_ClientSyncError = False
CloseCoC(True)
EndIf
Return
EndIf
$SearchCount += 1
ResumeAndroid()
EndFunc
Func resetAttackSearch($bStuck = False)
$Is_ClientSyncError = True
checkMainScreen()
If $Restart Then
$iNbrOfOoS += 1
UpdateStats()
If $bStuck Then
SetLog("Connection Lost While Searching", $COLOR_ERROR)
Else
SetLog("Disconnected At Search Clouds", $COLOR_ERROR)
EndIf
PushMsg("OoSResources")
Else
If $bStuck Then
SetLog("Attack Is Disabled Or Slow connection issues, Restarting CoC and Bot...", $COLOR_ERROR)
Else
SetLog("Stuck At Search Clouds, Restarting CoC and Bot...", $COLOR_ERROR)
EndIf
$Is_ClientSyncError = False
CloseCoC(True)
EndIf
Return
EndFunc
Func PrepareSearch()
IsWaitingForConnection()
SetLog("Going to Attack...", $COLOR_BLUE)
ChkAttackCSVConfig()
If IsMainPage() Then
If $iUseRandomClick = 0 then
ClickP($aAttackButton, 1, 0, "#0149")
Else
ClickR($aAttackButtonRND, $aAttackButton[0], $aAttackButton[1], 1, 0)
EndIF
EndIF
If _Sleep($iDelayPrepareSearch1) Then Return
Local $j = 0
While Not ( IsLaunchAttackPage())
If _Sleep($iDelayPrepareSearch1) Then Return
$j += 1
If $j > 15 Then ExitLoop
WEnd
If $j > 15 Then
SetLog("Launch attack Page Fail", $COLOR_RED)
checkMainScreen()
Return
Else
If $iUseRandomClick = 0 then
ClickP($aFindMatchButton, 1, 0, "#0150")
Else
ClickR($aFindMatchButtonRND, $aFindMatchButton[0], $aFindMatchButton[1], 1, 0)
EndIF
EndIf
If _Sleep($iDelayPrepareSearch2) Then Return
Local $Result = getAttackDisable(346, 182)
If isGemOpen(True) = True Then
Setlog(" Not enough gold to start searching.....", $COLOR_RED)
Click(585, 252, 1, 0, "#0151")
If _Sleep($iDelayPrepareSearch1) Then Return
Click(822, 32, 1, 0, "#0152")
If _Sleep($iDelayPrepareSearch1) Then Return
$OutOfGold = 1
EndIf
checkAttackDisable($iTaBChkAttack, $Result)
If $debugSetlog = 1 Then Setlog("PrepareSearch exit check $Restart= " & $Restart & ", $OutOfGold= " & $OutOfGold, $COLOR_DEBUG)
If $Restart = True Or $OutOfGold = 1 Then
$Is_ClientSyncError = False
Return
EndIf
If IsAttackWhileShieldPage(False) Then
Local $offColors[3][3] = [[0x000000, 144, 1], [0xFFFFFF, 54, 17], [0xFFFFFF, 54, 28]]
Global $ButtonPixel = _MultiPixelSearch(359, 404 + $midOffsetY, 510, 445 + $midOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $debugSetlog = 1 Then Setlog("Shield btn clr chk-#1: " & _GetPixelColor(441, 344 + $midOffsetY, True) & ", #2: " & _GetPixelColor(441 + 144, 344 + $midOffsetY, True) & ", #3: " & _GetPixelColor(441 + 54, 344 + 17 + $midOffsetY, True) & ", #4: " & _GetPixelColor(441 + 54, 344 + 10 + $midOffsetY, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Shld Btn Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 1, 0, "#0153")
EndIf
EndIf
EndFunc
Func VillageSearch()
Local $Result
Local $weakBaseValues
Local $logwrited = False
$iSkipped = 0
If $debugDeadBaseImage = 1 Then
If DirGetSize(@ScriptDir & "\SkippedZombies\") = -1 Then DirCreate(@ScriptDir & "\SkippedZombies\")
If DirGetSize(@ScriptDir & "\Zombies\") = -1 Then DirCreate(@ScriptDir & "\Zombies\")
EndIf
If $Is_ClientSyncError = False Then
For $i = 0 To $iModeCount - 1
$iAimGold[$i] = $iMinGold[$i]
$iAimElixir[$i] = $iMinElixir[$i]
$iAimGoldPlusElixir[$i] = $iMinGoldPlusElixir[$i]
$iAimDark[$i] = ($iChkMeetDE[$i] = 1 ? ($iMinDark[$i]) : (0))
$iAimTrophy[$i] = ($iChkMeetTrophy[$i] = 1 ? ($iMinTrophy[$i]) : (0))
Next
EndIf
If _Sleep($iDelayVillageSearch1) Then Return
$Result = getAttackDisable(346, 182)
checkAttackDisable($iTaBChkAttack, $Result)
If $Restart = True Then Return
If Not ($Is_SearchLimit) Then
SetLog(_StringRepeat("=", 50), $COLOR_BLUE)
EndIf
For $x = 0 To $iModeCount - 1
If IsSearchModeActive($x) Then WriteLogVillageSearch($x)
Next
If Not ($Is_SearchLimit) Then
SetLog(_StringRepeat("=", 50), $COLOR_BLUE)
Else
SetLog(_PadStringCenter(" Restart To Search ", 54, "="), $COLOR_BLUE)
EndIf
If $iChkAttackNow = 1 Then
GUICtrlSetState($btnAttackNowDB, $GUI_SHOW)
GUICtrlSetState($btnAttackNowLB, $GUI_SHOW)
GUICtrlSetState($btnAttackNowTS, $GUI_SHOW)
GUICtrlSetState($pic2arrow, $GUI_HIDE)
GUICtrlSetState($lblVersion, $GUI_HIDE)
EndIf
If $Is_ClientSyncError = False And $Is_SearchLimit = False Then
$SearchCount = 0
EndIf
If $Is_SearchLimit = True Then $Is_SearchLimit = False
While 1
If $debugVillageSearchImages = 1 Then DebugImageSave("villagesearch")
$logwrited = False
$bBtnAttackNowPressed = False
$hAttackCountDown = TimerInit()
If $iVSDelay > 0 And $iMaxVSDelay > 0 Then
If $iVSDelay <> $iMaxVSDelay Then
If _Sleep(Round(1000 * Random($iVSDelay, $iMaxVSDelay))) Then Return
Else
If _Sleep(1000 * $iVSDelay) Then Return
EndIf
EndIf
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN & "." & @SEC
If $Restart = True Then Return
WaitForClouds()
If $Restart = True Then Return
GetResources(False)
If $Restart = True Then Return
If Mod(($iSkipped + 1), 100) = 0 Then
If _Sleep($iDelayRespond) Then Return
If CheckZoomOut() = False Then Return
EndIf
SuspendAndroid()
Local $noMatchTxt = ""
Local $dbBase = False
Local $match[$iModeCount]
ReDim $isModeActive[$iModeCount]
For $i = 0 To $iModeCount - 1
$match[$i] = False
$isModeActive[$i] = False
Next
If _Sleep($iDelayRespond) Then Return
For $i = 0 To $iModeCount - 1
$isModeActive[$i] = IsSearchModeActive($i)
If $isModeActive[$i] Then
$match[$i] = CompareResources($i)
EndIf
Next
Local $THString = ""
$searchTH = "-"
$THx = 0
$THy = 0
If $match[$DB] Or $match[$LB] Or $match[$TS] Then
$THString = townHallCheck(False)
ElseIf ($iChkMeetOne[$DB] = 1 Or $iChkMeetOne[$LB] = 1) Then
$THString = townHallCheck(True)
EndIf
For $i = 0 To $iModeCount - 2
If $isModeActive[$i] Then
If $iChkMeetOne[$i] = 1 Then
If $iChkMeetTH[$i] <> 1 And $iChkMeetTHO[$i] <> 1 Then
Else
If CompareTH($i) Then $match[$i] = True
EndIf
Else
If Not CompareTH($i) Then $match[$i] = False
EndIf
EndIf
Next
$GetResourcesTXT = StringFormat("%3s", $SearchCount) & "> [G]:" & StringFormat("%7s", $searchGold) & " [E]:" & StringFormat("%7s", $searchElixir) & " [D]:" & StringFormat("%5s", $searchDark) & " [T]:" & StringFormat("%2s", $searchTrophy) & $THString
If ($match[$DB] And $iAtkAlgorithm[$DB] <> 2) Or $match[$LB] Or ($match[$DB] And $iAtkAlgorithm[$DB] = 2 And $MilkAttackType = 1) Then
$dbBase = checkDeadBase()
EndIf
If ($isModeActive[$DB] And IsWeakBaseActive($DB) > 0 And $dbBase And ($match[$DB] Or $iChkMeetOne[$DB] = 1)) Or  ($isModeActive[$LB] And IsWeakBaseActive($LB) > 0 And ($match[$LB] Or $iChkMeetOne[$LB] = 1)) Then
$weakBaseValues = IsWeakBase()
For $i = 0 To $iModeCount - 2
If IsWeakBaseActive($i) > 0 And (($i = $DB And $dbBase) Or $i <> $DB) And ($match[$i] Or $iChkMeetOne[$i] = 1) Then
If getIsWeak($weakBaseValues, $i) Then
$match[$i] = True
Else
$match[$i] = False
$noMatchTxt &= ", Not a Weak Base for " & $sModeText[$i]
EndIf
EndIf
Next
EndIf
CheckMilkingBase($match[$DB], $dbBase)
ResumeAndroid()
If $match[$DB] And $iAtkAlgorithm[$DB] = 2 And $milkingAttackOutside = 1 Then
SetLog($GetResourcesTXT, $COLOR_GREEN, "Lucida Console", 7.5)
SetLog("      " & "Milking Attack th outside Found!", $COLOR_GREEN, "Lucida Console", 7.5)
$logwrited = True
$iMatchMode = $DB
ExitLoop
ElseIf $match[$DB] And $iAtkAlgorithm[$DB] = 2 And $MilkAttackType = 0 And StringLen($MilkFarmObjectivesSTR) > 0 Then
SetLog($GetResourcesTXT, $COLOR_GREEN, "Lucida Console", 7.5)
SetLog("      " & "Milking Attack HIGH CPU SETTINGS Found!", $COLOR_GREEN, "Lucida Console", 7.5)
$logwrited = True
$iMatchMode = $DB
ExitLoop
ElseIf $match[$DB] And $iAtkAlgorithm[$DB] = 2 And $MilkAttackType = 1 And StringLen($MilkFarmObjectivesSTR) > 0 And $dbBase Then
SetLog($GetResourcesTXT, $COLOR_GREEN, "Lucida Console", 7.5)
SetLog("      " & "Milking Attack LOW CPU SETTINGS Found!", $COLOR_GREEN, "Lucida Console", 7.5)
$logwrited = True
$iMatchMode = $DB
ExitLoop
ElseIf $match[$DB] And $dbBase Then
SetLog($GetResourcesTXT, $COLOR_GREEN, "Lucida Console", 7.5)
SetLog("      " & "Dead Base Found!", $COLOR_GREEN, "Lucida Console", 7.5)
$logwrited = True
$iMatchMode = $DB
If $debugDeadBaseImage = 1 Then
_CaptureRegion()
_GDIPlus_ImageSaveToFile($hBitmap, @ScriptDir & "\Zombies\" & $Date & " at " & $Time & ".png")
_WinAPI_DeleteObject($hBitmap)
EndIf
ExitLoop
ElseIf $match[$LB] And Not $dbBase Then
SetLog($GetResourcesTXT, $COLOR_GREEN, "Lucida Console", 7.5)
SetLog("      " & "Live Base Found!", $COLOR_GREEN, "Lucida Console", 7.5)
$logwrited = True
$iMatchMode = $LB
ExitLoop
ElseIf $match[$LB] Or $match[$DB] Then
If $OptBullyMode = 1 And ($SearchCount >= $ATBullyMode) Then
If $SearchTHLResult = 1 Then
SetLog($GetResourcesTXT, $COLOR_GREEN, "Lucida Console", 7.5)
SetLog("      " & "Not a match, but TH Bully Level Found! ", $COLOR_GREEN, "Lucida Console", 7.5)
$logwrited = True
$iMatchMode = $iTHBullyAttackMode
ExitLoop
EndIf
EndIf
EndIf
If SearchTownHallLoc() And $match[$TS] Then
If CompareResources($TS) Then
SetLog($GetResourcesTXT, $COLOR_GREEN, "Lucida Console", 7.5)
SetLog("      " & "TH Outside Found! ", $COLOR_GREEN, "Lucida Console", 7.5)
$logwrited = True
$iMatchMode = $TS
ExitLoop
Else
$noMatchTxt &= ", Not a " & $sModeText[$TS] & ", fails resource min"
EndIf
EndIf
If $match[$DB] And Not $dbBase Then
$noMatchTxt &= ", Not a " & $sModeText[$DB]
If $debugDeadBaseImage = 1 Then
_CaptureRegion()
_GDIPlus_ImageSaveToFile($hBitmap, @ScriptDir & "\SkippedZombies\" & $Date & " at " & $Time & ".png")
_WinAPI_DeleteObject($hBitmap)
EndIf
ElseIf $match[$LB] And $dbBase Then
$noMatchTxt &= ", Not a " & $sModeText[$LB]
EndIf
If $noMatchTxt <> "" Then
SetLog($GetResourcesTXT, $COLOR_BLACK, "Lucida Console", 7.5)
SetLog("      " & StringMid($noMatchTxt, 3), $COLOR_BLACK, "Lucida Console", 7.5)
$logwrited = True
EndIf
If $iChkAttackNow = 1 And $iAttackNowDelay > 0 Then
If _Sleep(1000 * $iAttackNowDelay) Then Return
EndIf
If Not ($logwrited) Then
SetLog($GetResourcesTXT, $COLOR_BLACK, "Lucida Console", 7.5)
EndIf
If $bBtnAttackNowPressed = True Then ExitLoop
If SearchLimit($iSkipped + 1) Then Return True
If checkAndroidTimeLag() = True Then
$Restart = True
$Is_ClientSyncError = True
Return
EndIf
Local $i = 0
While $i < 100
If _Sleep($iDelayVillageSearch2) Then Return
$i += 1
If ( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) And IsAttackPage() Then
If $iUseRandomClick = 0 Then
ClickP($NextBtn, 1, 0, "#0155")
Else
ClickR($NextBtnRND, $NextBtn[0], $NextBtn[1], 1, 0)
EndIf
ExitLoop
Else
If $debugsetlog = 1 Then SetLog("Wait to see Next Button... " & $i, $COLOR_DEBUG)
EndIf
If $i >= 99 Or isProblemAffect(True) Then
$Is_ClientSyncError = True
checkMainScreen()
If $Restart Then
$iNbrOfOoS += 1
UpdateStats()
SetLog("Couldn't locate Next button", $COLOR_RED)
PushMsg("OoSResources")
Else
SetLog("Have strange problem Couldn't locate Next button, Restarting CoC and Bot...", $COLOR_RED)
$Is_ClientSyncError = False
CloseCoC(True)
EndIf
Return
EndIf
WEnd
If _Sleep($iDelayRespond) Then Return
$Result = getAttackDisable(346, 182)
checkAttackDisable($iTaBChkAttack, $Result)
If $Restart = True Then Return
If isGemOpen(True) = True Then
Setlog(" Not enough gold to keep searching.....", $COLOR_RED)
Click(585, 252, 1, 0, "#0156")
If _Sleep($iDelayVillageSearch3) Then Return
$OutOfGold = 1
ReturnHome(False, False)
Return
EndIf
$iSkipped = $iSkipped + 1
$iSkippedVillageCount += 1
If $iTownHallLevel <> "" Then
$iSearchCost += $aSearchCost[$iTownHallLevel - 1]
$iGoldTotal -= $aSearchCost[$iTownHallLevel - 1]
EndIf
UpdateStats()
WEnd
If $bBtnAttackNowPressed = True Then
Setlog(_PadStringCenter(" Attack Now Pressed! ", 50, "~"), $COLOR_GREEN)
EndIf
If $iChkAttackNow = 1 Then
GUICtrlSetState($btnAttackNowDB, $GUI_HIDE)
GUICtrlSetState($btnAttackNowLB, $GUI_HIDE)
GUICtrlSetState($btnAttackNowTS, $GUI_HIDE)
GUICtrlSetState($pic2arrow, $GUI_SHOW)
GUICtrlSetState($lblVersion, $GUI_SHOW)
$bBtnAttackNowPressed = False
EndIf
If $AlertSearch = 1 Then
TrayTip($sModeText[$iMatchMode] & " Match Found!", "Gold: " & $searchGold & "; Elixir: " & $searchElixir & "; Dark: " & $searchDark & "; Trophy: " & $searchTrophy, "", 0)
If FileExists(@WindowsDir & "\media\Festival\Windows Exclamation.wav") Then
SoundPlay(@WindowsDir & "\media\Festival\Windows Exclamation.wav", 1)
ElseIf FileExists(@WindowsDir & "\media\Windows Exclamation.wav") Then
SoundPlay(@WindowsDir & "\media\Windows Exclamation.wav", 1)
EndIf
EndIf
SetLog(_PadStringCenter(" Search Complete ", 50, "="), $COLOR_BLUE)
PushMsg("MatchFound")
$Is_ClientSyncError = False
EndFunc
Func SearchLimit($iSkipped)
If $iChkRestartSearchLimit = 1 And $iSkipped >= Number($iRestartSearchlimit) Then
Local $Wcount = 0
While _CheckPixel($aSurrenderButton, $bCapturePixel) = False
If _Sleep($iDelaySWHTSearchLimit1) Then Return
$Wcount += 1
If $debugsetlog = 1 Then setlog("wait surrender button " & $Wcount, $COLOR_DEBUG)
If $Wcount >= 50 Or isProblemAffect(True) Then
checkMainScreen()
$Is_ClientSyncError = False
$Restart = True
Return True
EndIf
WEnd
$Is_SearchLimit = True
ReturnHome(False, False)
$Restart = True
$Is_ClientSyncError = True
Return True
Else
Return False
EndIf
EndFunc
Func WriteLogVillageSearch($x)
Local $MeetGxEtext = "", $MeetGorEtext = "", $MeetGplusEtext = "", $MeetDEtext = "", $MeetTrophytext = "", $MeetTHtext = "", $MeetTHOtext = "", $MeetWeakBasetext = "", $EnabledAftertext = ""
If $iCmbMeetGE[$x] = 0 Then $MeetGxEtext = "- Meet: Gold and Elixir"
If $iCmbMeetGE[$x] = 1 Then $MeetGorEtext = "- Meet: Gold or Elixir"
If $iCmbMeetGE[$x] = 2 Then $MeetGplusEtext = "- Meet: Gold + Elixir"
If $iChkMeetDE[$x] = 1 Then $MeetDEtext = "- Dark"
If $iChkMeetTrophy[$x] = 1 Then $MeetTrophytext = "- Trophy"
If $iChkMeetTH[$x] = 1 Then $MeetTHtext = "- Max TH " & $iMaxTH[$x]
If $iChkMeetTHO[$x] = 1 Then $MeetTHOtext = "- TH Outside"
If IsWeakBaseActive($x) Then $MeetWeakBasetext = "- Weak Base"
If Not ($Is_SearchLimit) And $debugsetlog = 1 Then
SetLog(_PadStringCenter(" Searching For " & $sModeText[$x] & " ", 54, "="), $COLOR_DEBUG)
Setlog("Enable " & $sModeText[$x] & " search IF ", $COLOR_DEBUG)
If $iEnableSearchSearches[$x] = 1 Then Setlog("- Numbers of searches range " & $iEnableAfterCount[$x] & " - " & $iEnableBeforeCount[$x], $COLOR_DEBUG)
If $iEnableSearchTropies[$x] = 1 Then Setlog("- Search tropies range " & $iEnableAfterTropies[$x] & " - " & $iEnableBeforeTropies[$x], $COLOR_DEBUG)
If $iEnableSearchCamps[$x] = 1 Then Setlog("- Army Camps % >  " & $iEnableAfterArmyCamps[$x], $COLOR_DEBUG)
Setlog("Match " & $sModeText[$x] & "  village IF ", $COLOR_DEBUG)
If $MeetGxEtext <> "" Then Setlog($MeetGxEtext, $COLOR_DEBUG)
If $MeetGorEtext <> "" Then Setlog($MeetGorEtext, $COLOR_DEBUG)
If $MeetGplusEtext <> "" Then Setlog($MeetGplusEtext, $COLOR_DEBUG)
If $MeetDEtext <> "" Then Setlog($MeetDEtext, $COLOR_DEBUG)
If $MeetTrophytext <> "" Then Setlog($MeetTrophytext, $COLOR_DEBUG)
If $MeetTHtext <> "" Then Setlog($MeetTHtext, $COLOR_DEBUG)
If $MeetTHOtext <> "" Then Setlog($MeetTHOtext, $COLOR_DEBUG)
If $MeetWeakBasetext <> "" Then Setlog($MeetWeakBasetext, $COLOR_DEBUG)
If $iChkMeetOne[$x] = 1 Then SetLog("Meet One and Attack!")
SetLog(_PadStringCenter(" RESOURCE CONDITIONS ", 50, "~"), $COLOR_DEBUG)
If $iChkMeetTH[$x] = 1 Then $iAimTHtext[$x] = " [TH]:" & StringFormat("%2s", $iMaxTH[$x])
If $iChkMeetTHO[$x] = 1 Then $iAimTHtext[$x] &= ", Out"
EndIf
If Not ($Is_SearchLimit) Then
If $iCmbMeetGE[$x] = 2 Then
SetLog("Aim:           [G+E]:" & StringFormat("%7s", $iAimGoldPlusElixir[$x]) & " [D]:" & StringFormat("%5s", $iAimDark[$x]) & " [T]:" & StringFormat("%2s", $iAimTrophy[$x]) & $iAimTHtext[$x] & " for: " & $sModeText[$x], $COLOR_GREEN, "Lucida Console", 7.5)
Else
SetLog("Aim: [G]:" & StringFormat("%7s", $iAimGold[$x]) & " [E]:" & StringFormat("%7s", $iAimElixir[$x]) & " [D]:" & StringFormat("%5s", $iAimDark[$x]) & " [T]:" & StringFormat("%2s", $iAimTrophy[$x]) & $iAimTHtext[$x] & " for: " & $sModeText[$x], $COLOR_GREEN, "Lucida Console", 7.5)
EndIf
EndIf
EndFunc
Func CheckZoomOut()
_CaptureRegion(0, 0, $DEFAULT_WIDTH, 2)
If _GetPixelColor(1, 1) <> Hex(0x000000, 6) And _GetPixelColor(850, 1) <> Hex(0x000000, 6) Then
SetLog("Not Zoomed Out! Exiting to MainScreen...", $COLOR_RED)
checkMainScreen()
$Restart = True
Return False
Else
Return True
EndIf
EndFunc
Func SearchTownHallLoc()
Local $addtiles = 0
Switch $iMatchMode
Case $TS
If $ArmyCapacity < 100 Then
$addtiles = $itxtSWTtiles
Else
$addtiles = $THaddtiles
EndIf
Case $LB
$addtiles = $THSnipeBeforeLBTiles
Case $DB
If $duringMilkingAttack = 1 Then
$addtiles = $MilkFarmTHMaxTilesFromBorder
Else
$addtiles = $THSnipeBeforeDBTiles
EndIf
EndSwitch
If $searchTH <> "-" Then
If isInsideDiamondXY($THx, $THy) = False Then Return False
For $i = 0 To 22
If $Thx < 114 + $i * 16 + Ceiling(($addtiles - 2) / 2 * 16) And $THy < 359 - $i * 12 + Ceiling(($addtiles - 2) / 2 * 12) Then
$THi = $i
$THside = 0
Return True
EndIf
If $Thx < 117 + $i * 16 + Ceiling(($addtiles - 2) / 2 * 16) And $THy > 268 + $i * 12 - Floor(($addtiles - 2) / 2 * 12) Then
$THi = $i
$THside = 1
Return True
EndIf
If $Thx > 743 - $i * 16 - Floor(($addtiles - 2) / 2 * 16) And $THy < 358 - $i * 12 + Ceiling(($addtiles - 2) / 2 * 12) Then
$THi = $i
$THside = 2
Return True
EndIf
If $Thx > 742 - $i * 16 - Floor(($addtiles - 2) / 2 * 16) And $THy > 268 + $i * 12 - Floor(($addtiles - 2) / 2 * 12) Then
$THi = $i
$THside = 3
Return True
EndIf
Next
EndIf
Return False
EndFunc
Func IsSearchModeActive($iMatchMode, $nocheckHeroes = False)
Local $currentSearch = $SearchCount + 1
Local $currentTropies = $iTrophyCurrent
Local $currentArmyCamps = Int($CurCamp / $TotalCamp * 100)
Local $bMatchModeEnabled = False
Local $checkSearches = Int($currentSearch) >= Int($iEnableAfterCount[$iMatchMode]) And Int($currentSearch) <= Int($iEnableBeforeCount[$iMatchMode]) And $iEnableSearchSearches[$iMatchMode] = 1
Local $checkTropies = Int($currentTropies) >= Int($iEnableAfterTropies[$iMatchMode]) And Int($currentTropies) <= Int($iEnableBeforeTropies[$iMatchMode]) And $iEnableSearchTropies[$iMatchMode] = 1
Local $checkArmyCamps = Int($currentArmyCamps) >= Int($iEnableAfterArmyCamps[$iMatchMode]) Or $fullarmy = True And $iEnableSearchCamps[$iMatchMode] = 1
Local $checkHeroes = Not ($iHeroWait[$iMatchMode] > $HERO_NOHERO And (BitAND($iHeroAttack[$iMatchMode], $iHeroWait[$iMatchMode], $iHeroAvailable) = $iHeroWait[$iMatchMode]) = False) Or $nocheckHeroes
Local $checkSpells = ($bFullArmySpells And $iEnableSpellsWait[$iMatchMode] = 1) Or $iEnableSpellsWait[$iMatchMode] = 0
Local $totalSpellsToBrew = 0
$totalSpellsToBrew += $PSpellComp + $ESpellComp + $HaSpellComp + $SkSpellComp +  $LSpellComp + $RSpellComp + $HSpellComp + $JSpellComp + $FSpellComp + $CSpellComp
$iTotalCountSpell = $totalSpellsToBrew
If GetCurTotalSpell() = $totalSpellsToBrew And $iEnableSpellsWait[$iMatchMode] = 1 Then
$checkSpells = True
ElseIf $bFullArmySpells = True And $iEnableSpellsWait[$iMatchMode] = 1 Then
$checkSpells = True
ElseIf $iEnableSpellsWait[$iMatchMode] = 0 Then
$checkSpells = True
Else
$checkSpells = False
EndIf
Switch $iMatchMode
Case $DB
If $iDBcheck = 1 Then $bMatchModeEnabled = True
Case $LB
If $iABcheck = 1 Then $bMatchModeEnabled = True
Case $TS
If $iTScheck = 1 Then $bMatchModeEnabled = True
EndSwitch
If $bMatchModeEnabled = False Then Return False
If $checkHeroes And $checkSpells Then
If $bMatchModeEnabled And ($checkSearches Or $iEnableSearchSearches[$iMatchMode] = 0) And ($checkTropies Or $iEnableSearchTropies[$iMatchMode] = 0) And ($checkArmyCamps Or $iEnableSearchCamps[$iMatchMode] = 0) Then
If $debugsetlog = 1 Then Setlog($sModeText[$iMatchMode] & " active! ($checkSearches=" & $checkSearches & ",$checkTropies=" & $checkTropies & ",$checkArmyCamps=" & $checkArmyCamps & ",$checkHeroes=" & $checkHeroes & ",$checkSpells=" & $checkSpells & ")", $COLOR_DEBUG)
Return True
Else
If $debugsetlog = 1 Then
Setlog($sModeText[$iMatchMode] & " not active!", $COLOR_DEBUG)
If $bMatchModeEnabled Then
Local $txtsearches = "Fail"
If $checkSearches Then $txtsearches = "Success"
Local $txttropies = "Fail"
If $checkTropies Then $txttropies = "Success"
Local $txtArmyCamp = "Fail"
If $checkArmyCamps Then $txtArmyCamp = "Success"
Local $txtHeroes = "Fail"
If $checkHeroes Then $txtHeroes = "Success"
If $iEnableSearchSearches[$iMatchMode] = 1 Then Setlog("searches range: " & $iEnableAfterCount[$iMatchMode] & "-" & $iEnableBeforeCount[$iMatchMode] & "  actual value: " & $currentSearch & " - " & $txtsearches, $COLOR_DEBUG)
If $iEnableSearchTropies[$iMatchMode] = 1 Then Setlog("tropies range: " & $iEnableAfterTropies[$iMatchMode] & "-" & $iEnableBeforeTropies[$iMatchMode] & "  actual value: " & $currentTropies & " | " & $txttropies, $COLOR_DEBUG)
If $iEnableSearchCamps[$iMatchMode] = 1 Then Setlog("Army camps % range >=: " & $iEnableAfterArmyCamps[$iMatchMode] & " actual value: " & $currentArmyCamps & " | " & $txtArmyCamp, $COLOR_DEBUG)
If $iHeroWait[$iMatchMode] > $HERO_NOHERO Then SetLog("Hero status " & BitAND($iHeroAttack[$iMatchMode], $iHeroWait[$iMatchMode], $iHeroAvailable) & " " & $iHeroAvailable & " | " & $txtHeroes, $COLOR_DEBUG)
Local $txtSpells = "Fail"
If $checkSpells Then $txtSpells = "Success"
If $iEnableSpellsWait[$iMatchMode] = 1 Then SetLog("Full spell status: " & $bFullArmySpells & " | " & $txtSpells, $COLOR_DEBUG)
EndIf
EndIf
Return False
EndIf
ElseIf $checkHeroes = 0 Then
If $debugsetlog = 1 Then Setlog("Heroes not ready", $COLOR_DEBUG)
Return False
Else
If $debugsetlog = 1 Then Setlog("Spells not ready", $COLOR_DEBUG)
Return False
EndIf
EndFunc
Func IsWaitforSpellsActive()
Local $bMatchModeEnabled
For $i = $DB To $iModeCount - 1
$bMatchModeEnabled = False
Switch $i
Case $DB
If $iDBcheck = 1 Then $bMatchModeEnabled = True
Case $LB
If $iABcheck = 1 Then $bMatchModeEnabled = True
Case $TS
If $iTScheck = 1 Then $bMatchModeEnabled = True
EndSwitch
If $bMatchModeEnabled And $iEnableSpellsWait[$i] = 1 Then
If $debugsetlogTrain = 1 Or $debugsetlog = 1 Then Setlog("IsWaitforSpellsActive = True", $COLOR_DEBUG)
Return True
EndIf
Next
If $debugsetlogTrain = 1 Or $debugsetlog = 1 Then Setlog("IsWaitforSpellsActive = False", $COLOR_DEBUG)
Return False
EndFunc
Func IsWaitforHeroesActive()
Local $bMatchModeEnabled
For $i = $DB To $iModeCount - 1
$bMatchModeEnabled = False
Switch $i
Case $DB
If $iDBcheck = 1 Then $bMatchModeEnabled = True
Case $LB
If $iABcheck = 1 Then $bMatchModeEnabled = True
Case $TS
If $iTScheck = 1 Then $bMatchModeEnabled = True
EndSwitch
If $bMatchModeEnabled And ($iHeroWait[$i] > $HERO_NOHERO And (BitAND($iHeroAttack[$i], $iHeroWait[$i]) = $iHeroWait[$i])) Then
If $debugsetlogTrain = 1 Or $debugsetlog = 1 Then Setlog("IsWaitforHeroesActive = True", $COLOR_DEBUG)
Return True
EndIf
Next
If $debugsetlogTrain = 1 Or $debugsetlog = 1 Then Setlog("IsWaitforHeroesActive = False", $COLOR_DEBUG)
Return False
EndFunc
Func GetCurTotalSpell()
If $CurTotalSpell = False And $iTotalCountSpell > 0 Then Return -1
Return $CurLSpell +  $CurHSpell +  $CurRSpell +  $CurJSpell +  $CurFSpell +  $CurCSpell +  $CurPSpell +  $CurHaSpell +  $CurSkSpell +  $CurESpell
EndFunc
Func IsSearchAttackEnabled()
If $debugsetlog = 1 Then Setlog("Begin IsSearchAttackScheduled:", $COLOR_DEBUG)
If $ichkAttackPlannerEnable = 0 Then Return True
Local $sStartTime = "", $sEndTime = ""
Local $aNoAttackTimes[2] = [$sStartTime, $sEndTime]
Local $iWaitTime = 0
Local $bCloseGame = $ichkAttackPlannerCloseCoC = 1 Or $ichkAttackPlannerCloseAll = 1
If $debugsetlog = 1 Then Setlog("$bCloseGame:" & $bCloseGame, $COLOR_DEBUG)
If $ichkAttackPlannerDayLimit = 1 And _OverAttackLimit() Then
Setlog("Daily attack limit reached, skip attacks till new day starts!", $COLOR_BLUE)
If _Sleep($iDelayRespond) Then Return True
If $bCloseGame Then
$iWaitTime = _getTimeRemainTimeToday()
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $ichkAttackPlannerCloseAll, True)
$Restart = True
Return
Else
Return False
EndIf
EndIf
If $ichkAttackPlannerRandom = 1 Then
$aNoAttackTimes = _getDailyRandomStartEnd($icmbAttackPlannerRandom)
If @error Then
Setlog(@extended, $COLOR_RED)
Return True
EndIf
If _IsTimeInRange($aNoAttackTimes[0], $aNoAttackTimes[1]) Then
Setlog("Attack schedule random skip time found....", $COLOR_BLUE)
If _Sleep($iDelayRespond) Then Return True
If $bCloseGame Then
$iWaitTime = _DateDiff("s", $aNoAttackTimes[1], _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not find NoAttack wait time", True)
Return True
EndIf
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $ichkAttackPlannerCloseAll, True)
$Restart = True
Return
Else
Return False
EndIf
Else
Return True
EndIf
Else
If IsPlannedTimeNow() = False Then
Setlog("Attack schedule planned skip time found...", $COLOR_BLUE)
If _Sleep($iDelayRespond) Then Return True
If $bCloseGame Then
If $iPlannedAttackWeekDays[@WDAY - 1] = 0 Then
$iWaitTime = _getTimeRemainTimeToday()
For $i = @WDAY To 6
If $iPlannedAttackWeekDays[$i] = 0 Then $iWaitTime += 86400
If $iPlannedAttackWeekDays[$i] = 1 Then ExitLoop
If $debugsetlog = 1 Then Setlog("Subtotal wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
Next
EndIf
If $iWaitTime = 0 Then
If $iPlannedAttackWeekDays[@WDAY - 1] = 1 And $iPlannedattackHours[@HOUR] = 0 Then
$iWaitTime += (59 - @MIN) * 60
For $i = @HOUR + 1 To 23
If $iPlannedattackHours[$i] = 0 Then $iWaitTime += 3600
If $iPlannedattackHours[$i] = 1 Then ExitLoop
If $debugsetlog = 1 Then Setlog("Subtotal wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
Next
EndIf
EndIf
If $debugsetlog = 1 Then Setlog("Stop attack wait time= " & $iWaitTime & " Seconds", $COLOR_DEBUG)
UniversalCloseWaitOpenCoC($iWaitTime * 1000, "IsSearchAttackScheduled_", $ichkAttackPlannerCloseAll, True)
$Restart = True
Return
Else
Return False
EndIf
EndIf
EndIf
Return True
EndFunc
Func _getTimeRemainTimeToday()
Local $iTimeRemain = _DateDiff("s", _NowCalc(), _NowCalcDate() & " 23:59:59")
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not determine time remaining today", 0)
Return
EndIf
If $debugsetlog = 1 Then Setlog("getTimeRemainToday= " & $iTimeRemain & " Seconds", $COLOR_DEBUG)
Return $iTimeRemain
EndFunc
Func _IsTimeAfter($sCompareTime, $sCurrentTime = _NowCalc())
Local $bResult = _DateDiff("s", $sCurrentTime, $sCompareTime) < 0
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not check if time is after", False)
Return
EndIf
If $debugsetlog = 1 Then Setlog("IsTimeAfter: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _IsTimeBefore($sCompareTime, $sCurrentTime = _NowCalc())
Local $bResult = _DateDiff("s", $sCurrentTime, $sCompareTime) > 0
If @error Then
_logErrorDateDiff(@error)
SetError(1, "Can not check if time is before", False)
Return
EndIf
If $debugsetlog = 1 Then Setlog("IsTimeBefore: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _IsTimeInRange($sStartTime, $sEndTime)
Local $sCurrentTime = _NowCalc()
Local $bResult = _IsTimeAfter($sStartTime, $sCurrentTime) And _IsTimeBefore($sEndTime, $sCurrentTime)
If $debugsetlog = 1 Then Setlog("IsTimeInRange: " & $bResult, $COLOR_DEBUG)
Return $bResult
EndFunc
Func _getDailyRandomStartEnd($iDuration = 4)
Local $iStartHour, $iEndHour
Local Static $iNowDay = @YDAY
If Not ($iDuration >= 0 And $iDuration <= 24) Then
SetError(1, "Invalid duration for _getDailyRandomStartEnd")
Return
EndIf
Local $sStartTime = _DateAdd("h", Int(_getDailyRandom() * (23 - @HOUR)), _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(2, "Can not create initial random start time")
Return
EndIf
Local $sEndTime = _DateAdd("h", Int($iDuration), $sStartTime)
If @error Then
_logErrorDateDiff(@error)
SetError(3, "Can not create initial random end time")
Return
EndIf
Local Static $aNoAttackTimes[2] = [$sStartTime, $sEndTime]
If $iNowDay <> @YDAY Then
$iStartHour = _getDailyRandom() * 24
If $iStartHour <= @HOUR Then $iStartHour = @HOUR + 1.166
$iEndHour = $iStartHour + $iDuration
If $debugsetlog = 1 Then Setlog("StartHour: " & $iStartHour & "EndHour: " & $iEndHour, $COLOR_DEBUG)
$aNoAttackTimes[0] = _DateAdd("h", $iStartHour, _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(4, "Can not create random start time")
Return
EndIf
$aNoAttackTimes[1] = _DateAdd("h", $iEndHour, _NowCalc())
If @error Then
_logErrorDateDiff(@error)
SetError(5, "Can not create random end time")
Return
EndIf
EndIf
If $debugsetlog = 1 Then Setlog("NoAttackStart: " & $aNoAttackTimes[0] & "NoAttackEnd: " & $aNoAttackTimes[1], $COLOR_DEBUG)
Return $aNoAttackTimes
EndFunc
Func _getDailyRandom()
Local Static $iDailyRandomValue = Random(0.001, 1, 4)
Local Static $iNowDay = @YDAY
If $iNowDay <> @YDAY Then
$iDailyRandomValue = Round(Random(0.001, 1), 4)
$iNowDay = @YDAY
If $debugsetlog = 1 Then Setlog("New day = new random value!", $COLOR_DEBUG)
EndIf
If $debugsetlog = 1 Then Setlog("DailyRandomValue=" & StringFormat("%0.5f", $iDailyRandomValue), $COLOR_DEBUG)
Return $iDailyRandomValue
EndFunc
Func IsPlannedTimeNow()
Local $hour, $hourloot
If $iPlannedAttackWeekDays[@WDAY - 1] = 1 Then
$hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
$hourloot = $hour[0]
If $iPlannedattackHours[$hourloot] = 1 Then
If $debugsetlog = 1 Then SetLog("Attack plan enabled for now..", $COLOR_DEBUG)
Return True
Else
SetLog("Attack plan enabled today, but not this hour", $COLOR_BLUE)
If _Sleep($iDelayRespond) Then Return False
Return False
EndIf
Else
SetLog("Attack plan not enabled today", $COLOR_BLUE)
If _Sleep($iDelayRespond) Then Return False
Return False
EndIf
EndFunc
Func _OverAttackLimit()
Local Static $iAttackCountToday = 0
Local Static $iTotalAttackCount = $iAttackedCount
Local Static $iNowDay = @YDAY
If $iNowDay <> @YDAY Then
$iAttackCountToday = 0
$iNowDay = @YDAY
$iTotalAttackCount = $iAttackedCount
Else
$iAttackCountToday = $iAttackedCount - $iTotalAttackCount
EndIf
If $debugsetlog = 1 Then Setlog("AttackCountToday: " & $iAttackCountToday & ", AttackedCount: " & $iAttackedCount & "TotalAttackCount: " & $iTotalAttackCount, $COLOR_DEBUG)
Local $iRandomAttackCountToday = Ceiling(Int($icmbAttackPlannerDayMin) + (_getDailyRandom() * (Int($icmbAttackPlannerDayMax) - Int($icmbAttackPlannerDayMin))))
If $iRandomAttackCountToday > Int($icmbAttackPlannerDayMax) Then $iRandomAttackCountToday = Int($icmbAttackPlannerDayMax)
If $debugsetlog = 1 Then Setlog("RandomAttackCountToday: " & $iRandomAttackCountToday, $COLOR_DEBUG)
If $iAttackCountToday > $iRandomAttackCountToday Then Return True
Return False
EndFunc
Global $DebugBarrackBoost = 0
Func BoostBarracks()
If $bTrainEnabled = False Then Return
If $icmbBoostBarracks = 0 Then Return
If $icmbBoostBarracks > 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $iPlannedBoostBarracksHours[$hour[0]] = 0 Then
SetLog("Boost Barracks are not Planned, Skipped..", $COLOR_BLUE)
Return
EndIf
EndIf
If OpenArmyWindow() = True Then
Local $CheckArmyWindow = ISArmyWindow()
OpenTrainTabNumber(1)
If _Sleep(400) Then Return
$ClickResult = ClickOnBoostArmyWindow()
If $ClickResult = True Then
$GemResult = IsGemWindowOpen("", "", True)
If $GemResult = True Then
If $icmbBoostBarracks >= 1 Then $icmbBoostBarracks -= 1
Setlog(" Total remain cycles to boost Barracks:" & $icmbBoostBarracks, $COLOR_GREEN)
GUICtrlSetData($cmbBoostBarracks, $icmbBoostBarracks)
EndIf
EndIf
ClickP($aAway, 1, 0, "#0161")
PureClickP($aAway, 1, 0, "#0140")
EndIf
_Sleep($iDelayBoostBarracks5 + 1000)
checkMainScreen(False)
Return True
EndFunc
Func BoostSpellFactory()
If $bTrainEnabled = False Then Return
If $icmbBoostSpellFactory > 0 And $boostsEnabled = 1 Then
SetLog("Boosting Spell Factory...", $COLOR_BLUE)
If OpenArmyWindow() = True Then
Local $CheckArmyWindow = ISArmyWindow()
OpenTrainTabNumber(2)
If _Sleep(400) Then Return
$ClickResult = ClickOnBoostArmyWindow()
If $ClickResult = True Then
$GemResult = IsGemWindowOpen("", "", True)
If $GemResult = True Then
If $icmbBoostSpellFactory >= 1 Then $icmbBoostSpellFactory -= 1
Setlog(" Total remain cycles to boost Spells:" & $icmbBoostSpellFactory, $COLOR_GREEN)
GUICtrlSetData($cmbBoostSpellFactory, $icmbBoostSpellFactory)
EndIf
EndIf
ClickP($aAway, 1, 0, "#0161")
PureClickP($aAway, 1, 0, "#0140")
EndIf
_Sleep($iDelayBoostBarracks5 + 1000)
checkMainScreen(False)
Return True
EndIf
EndFunc
Func ClickOnBoostArmyWindow()
If $DebugBarrackBoost = 1 Then SetLog("Func ClickOnBoostArmyWindow()", $COLOR_DEBUG)
_Sleep($iDelayBoostBarracks2)
$ClockColor = _GetPixelColor(780, 312 + $midOffsetY, True)
$ResColCheck = _ColorCheck($ClockColor, Hex(0x65AF20, 6), 40)
If $ResColCheck = True Then
SetLog("Boost Button is Available, Clicking On...", $COLOR_BLUE)
Click(770, 325)
_Sleep($iDelayBoostBarracks2)
Return True
Else
If _ColorCheck(_GetPixelColor(718, 285 + $midOffsetY, True), Hex(0xEEF470, 6), 40) Then
SetLog("Already Boosted! Skipping...", $COLOR_GREEN)
Else
SetLog("Cannot Verify Boost Button! Skipping...", $COLOR_ORANGE)
EndIf
Return False
EndIf
EndFunc
Func IsGemWindowOpen($varToChange1 = "", $varToChange2 = "", $AcceptGem = False, $NeedCapture = True)
If $DebugBarrackBoost = 1 Then SetLog("Func IsGemWindowOpen(" & $AcceptGem & ", " & $NeedCapture & ")", $COLOR_DEBUG)
_Sleep($iDelayisGemOpen1)
If _ColorCheck(_GetPixelColor(590, 235 + $midOffsetY, True), Hex(0xD80408, 6), 20) Then
If _ColorCheck(_GetPixelColor(375, 383 + $midOffsetY, True), Hex(0x222322, 6), 20) Then
If $debugSetlog = 1 Or $DebugBarrackBoost = 1 Then Setlog("DETECTED, GEM Window Is OPEN", $COLOR_DEBUG)
If $AcceptGem = True Then
Click(435, 445)
_Sleep($iDelayBoostBarracks2)
If $varToChange2 = "" = False Then Assign($varToChange2, Eval($varToChange2) - 1, 4)
If $varToChange2 = "" = False Then
SetLog('Boost completed. Remaining : ' & Eval($varToChange2), $COLOR_GREEN)
Else
SetLog('Boost was Successful.', $COLOR_GREEN)
EndIf
Else
PureClickP($aAway, 1, 0, "#0140")
EndIf
_Sleep($iDelayBoostSpellFactory3)
ClickP($aAway, 1, 0, "#0161")
If $DebugBarrackBoost = 1 Then SetLog("Func IsGemWindowOpen(" & $AcceptGem & ") = TRUE", $COLOR_GREEN)
Return True
EndIf
EndIf
If $DebugBarrackBoost = 1 Then SetLog("Func IsGemWindowOpen(" & $AcceptGem & ", " & $NeedCapture & ") = FALSE", $COLOR_GREEN)
Return False
EndFunc
Func BotDetectFirstTime()
Local $collx, $colly, $Result, $i = 0, $t = 0
If $Is_ClientSyncError = True Then Return
ClickP($aAway, 1, 0, "#0166")
If _Sleep($iDelayBotDetectFirstTime1) Then Return
SetLog("Detecting your Buildings..", $COLOR_BLUE)
If (isInsideDiamond($TownHallPos) = False) Then
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) And _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
_CaptureRegion2()
Local $PixelTHHere = GetLocationItem("getLocationTownHall", True)
If UBound($PixelTHHere) > 0 Then
$pixel = $PixelTHHere[0]
$TownHallPos[0] = $pixel[0]
$TownHallPos[1] = $pixel[1]
If $debugSetlog = 1 Then SetLog("ImgLoc# Townhall: (" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_DEBUG)
EndIf
If $TownHallPos[1] = "" Or $TownHallPos[1] = -1 Then
townHallCheck(True)
$TownHallPos[0] = $THx
$TownHallPos[1] = $THy
If $debugSetlog = 1 Then SetLog("OldDDL Townhall: (" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_DEBUG)
EndIf
SetLog("Townhall: (" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_DEBUG)
EndIf
If Number($iTownHallLevel) < 2 Then
$Result = GetTownHallLevel(True)
If IsArray($Result) Then $iTownHallLevel = 0
EndIf
If Number($iTownHallLevel) > 1 And Number($iTownHallLevel) < 6 Then
Setlog("Warning: TownHall level below 6 NOT RECOMMENDED!", $COLOR_RED)
Setlog("Proceed with caution as errors may occur.", $COLOR_RED)
EndIf
If _Sleep($iDelayBotDetectFirstTime1) Then Return
If _Sleep($iDelayBotDetectFirstTime1) Then Return
CheckImageType()
If _Sleep($iDelayBotDetectFirstTime1) Then Return
If GUICtrlRead($chkScreenshotHideName) = $GUI_CHECKED Or $ichkScreenshotHideName = 1 Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $aCCPos[0] = -1 Then
LocateClanCastle()
SaveConfig()
EndIf
EndIf
If $ichkLab = 1 Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $aLabPos[0] = "" Or $aLabPos[0] = -1 Then
LocateLab()
SaveConfig()
EndIf
EndIf
If (GUICtrlRead($cmbBoostBarbarianKing) > 0) Or $ichkUpgradeKing = 1 Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $KingAltarPos[0] = -1 Then
LocateKingAltar()
SaveConfig()
EndIf
EndIf
If (GUICtrlRead($cmbBoostArcherQueen) > 0) Or $ichkUpgradeQueen = 1 Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $QueenAltarPos[0] = -1 Then
LocateQueenAltar()
SaveConfig()
EndIf
EndIf
If Number($iTownHallLevel) > 10 And ((GUICtrlRead($cmbBoostWarden) > 0) Or $ichkUpgradeWarden = 1) Then
If _Sleep($iDelayBotDetectFirstTime3) Then Return
If $WardenAltarPos[0] = -1 Then
LocateWardenAltar()
SaveConfig()
EndIf
EndIf
_GUI_Value_STATE("HIDE", $groupListTHLevels)
If $debugSetlog = 1 Then Setlog("Select TH Level:" & Number($iTownHallLevel), $COLOR_DEBUG)
Switch Number($iTownHallLevel)
Case 4
GUICtrlSetState($THLevels04, $GUI_SHOW)
Case 5
GUICtrlSetState($THLevels05, $GUI_SHOW)
Case 6
GUICtrlSetState($THLevels06, $GUI_SHOW)
Case 7
GUICtrlSetState($THLevels07, $GUI_SHOW)
Case 8
GUICtrlSetState($THLevels08, $GUI_SHOW)
Case 9
GUICtrlSetState($THLevels09, $GUI_SHOW)
Case 10
GUICtrlSetState($THLevels10, $GUI_SHOW)
Case 11
GUICtrlSetState($THLevels11, $GUI_SHOW)
EndSwitch
GUICtrlSetState(Eval("$THLevels" + Number($iTownHallLevel)), $GUI_SHOW)
EndFunc
Func BotCommand()
If $iChkBotStop = 1 Then
$MeetCondStop = False
$bTrainEnabled = True
$bDonationEnabled = True
If $icmbBotCond = 15 And $icmbHoursStop <> 0 Then $TimeToStop = $icmbHoursStop * 3600000
Local $iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
Local $TrophyMax = Number($iTrophyCurrent) > Number($itxtMaxTrophy)
If $TrophyMax Then
$Trophy = "Max. Trophy Reached!"
Else
$Trophy = ""
EndIf
Switch $icmbBotCond
Case 0
If isGoldFull() And isElixirFull() And $TrophyMax Then $MeetCondStop = True
Case 1
If (isGoldFull() And isElixirFull()) Or $TrophyMax Then $MeetCondStop = True
Case 2
If (isGoldFull() Or isElixirFull()) And $TrophyMax Then $MeetCondStop = True
Case 3
If isGoldFull() Or isElixirFull() Or $TrophyMax Then $MeetCondStop = True
Case 4
If isGoldFull() And isElixirFull() Then $MeetCondStop = True
Case 5
If isGoldFull() Or isElixirFull() Then $MeetCondStop = True
Case 6
If isGoldFull() And $TrophyMax Then $MeetCondStop = True
Case 7
If isElixirFull() And $TrophyMax Then $MeetCondStop = True
Case 8
If isGoldFull() Or $TrophyMax Then $MeetCondStop = True
Case 9
If isElixirFull() Or $TrophyMax Then $MeetCondStop = True
Case 10
If isGoldFull() Then $MeetCondStop = True
Case 11
If isElixirFull() Then $MeetCondStop = True
Case 12
If $TrophyMax Then $MeetCondStop = True
Case 13
If isDarkElixirFull() Then $MeetCondStop = True
Case 14
If isGoldFull() And isElixirFull() And isDarkElixirFull() Then $MeetCondStop = True
Case 15
If $UseTimeStop = -1 Then
$UseTimeStop = 1
EndIf
If Round(TimerDiff($sTimer)) > $TimeToStop Then $MeetCondStop = True
Case 16
$MeetCondStop = True
Case 17
$MeetCondStop = True
$bTrainEnabled = False
Case 18
$MeetCondStop = True
$bTrainEnabled = False
$bDonationEnabled = False
Case 19
If $bWaitShield = True Then $MeetCondStop = True
Case 20
If $bWaitShield = True Then
$MeetCondStop = True
$bTrainEnabled = False
EndIf
Case 21
If $bWaitShield = True Then
$MeetCondStop = True
$bTrainEnabled = False
$bDonationEnabled = False
EndIf
EndSwitch
If $MeetCondStop Then
If $icmbBotCond <> 4 And $icmbBotCond <> 5 And $icmbBotCond <> 10 And $icmbBotCond <> 11 Then
If $Trophy <> "" Then SetLog($Trophy, $COLOR_GREEN)
If _Sleep($iDelayBotCommand1) Then Return
EndIf
Switch $icmbBotCommand
Case 0
If $bDonationEnabled = False Then
SetLog("Halt Attack, Stay Online/Collect...", $COLOR_BLUE)
ElseIf $bTrainEnabled = False Then
SetLog("Halt Attack, Stay Online/Collect/Donate...", $COLOR_BLUE)
Else
SetLog("Halt Attack, Stay Online/Train/Collect/Donate...", $COLOR_BLUE)
EndIf
$CommandStop = 0
If _Sleep($iDelayBotCommand1) Then Return
Case 1
SetLog("MyBot.run Bot Stop as requested!!", $COLOR_BLUE)
If _Sleep($iDelayBotCommand1) Then Return
Return True
Case 2
SetLog("MyBot.run Close Bot as requested!!", $COLOR_BLUE)
If _Sleep($iDelayBotCommand1) Then Return
BotClose()
Return True
Case 3
SetLog("Close Android and Bot as requested!!", $COLOR_BLUE)
If _Sleep($iDelayBotCommand1) Then Return
CloseAndroid()
BotClose()
Return True
Case 4
SetLog("Force Shutdown of PC...", $COLOR_BLUE)
If _Sleep($iDelayBotCommand1) Then Return
Shutdown(BitOR($SD_SHUTDOWN, $SD_FORCE))
Return True
Case 5
SetLog("PC Sleep Mode Start now ...", $COLOR_BLUE)
If _Sleep($iDelayBotCommand1) Then Return
Shutdown($SD_STANDBY)
Return True
Case 6
SetLog("Rebooting PC...", $COLOR_BLUE)
If _Sleep($iDelayBotCommand1) Then Return
Shutdown(BitOR($SD_REBOOT, $SD_FORCE))
Return True
EndSwitch
EndIf
EndIf
Return False
EndFunc
Func BreakPersonalShield()
If _CheckPixel($aRemoveShldButton, $bCapturePixel) Then
Setlog("Oops, Need to have latest CoC installed!", $COLOR_RED)
Setlog("New Personal Guard info window not avialable!", $COLOR_RED)
SetError(1)
Return
EndIf
If $debugSetlog = 1 Then Setlog("Checking if Shield available", $COLOR_DEBUG)
If $debugSetlog = 1 Then Setlog("Have shield pixel color: " & _GetPixelColor($aHaveShield, $bCapturePixel) & " :" & _CheckPixel($aHaveShield, $bCapturePixel), $COLOR_DEBUG)
If _CheckPixel($aHaveShield, $bCapturePixel) Then
If IsMainPage() Then
PureClickP($aShieldInfoButton)
If _Sleep($iPersonalShield1) Then
SetError(2)
Return
EndIf
$result = ClickRemove("Shield")
If ($result = False) Or @error Then
SetError(3, "shield remove button not found", "")
Return
EndIf
$result = ClickOkay("Shield")
If ($result = False) Or @error Then
SetError(4, "shield Okay button not found", "")
Return
EndIf
Setlog("Shield removed", $COLOR_GREEN)
EndIf
Else
If $debugSetlog = 1 Then Setlog("No shield available", $COLOR_DEBUG)
EndIf
If _Sleep($iPersonalShield1) Then
SetError(2)
Return
EndIf
If $debugSetlog = 1 Then Setlog("Checking if Personal Guard available", $COLOR_DEBUG)
If $debugSetlog = 1 Then Setlog("Have guard pixel color: " & _GetPixelColor($aHavePerGuard, $bCapturePixel) & " :" & _CheckPixel($aHavePerGuard, $bCapturePixel), $COLOR_DEBUG)
If _CheckPixel($aHavePerGuard, $bCapturePixel) Then
If IsMainPage() Then
PureClickP($aShieldInfoButton)
If _Sleep($iPersonalShield1) Then
SetError(2)
Return
EndIf
$result = ClickRemove("Guard")
If ($result = False) Or @error Then
SetError(5, "guard remove button not found")
Return
EndIf
$result = ClickOkay("Guard")
If ($result = False) Or @error Then
SetError(6, "guard Okay button not found")
Return
EndIf
Setlog("Guard removed", $COLOR_GREEN)
EndIf
Else
If $debugSetlog = 1 Then Setlog("No guard available", $COLOR_DEBUG)
EndIf
EndFunc
Func ChartAddDataPoint1hr($WhichSet = "Total", $bGreenButton = False)
SetLog("Adding A Chart Data Point")
Global $t1HrTimer
If 	$WhichSet = "Total"  Then
Local $aChartGold24hr[24]
Local $aChartElixir24hr[24]
Local $aChartDarkE24hr[24]
Local $aChartWasStartClicked[24]
Local $EmptyString = "0"
For $i = 0 to 22
$EmptyString &= "|0"
Next
$t1HrTimer = TimerInit()
If Not FileExists($ChartPath &"Total.ini") Then
FileOpen($ChartPath&"Total.ini", $FO_OVERWRITE + $FO_CREATEPATH)
IniWrite($ChartPath&"Total.ini", "ChartData", "GoldTotal", $EmptyString)
IniWrite($ChartPath&"Total.ini", "ChartData", "ElixirTotal", $EmptyString)
IniWrite($ChartPath&"Total.ini", "ChartData", "DarkETotal", $EmptyString)
IniWrite($ChartPath&"Total.ini", "ChartData", "WasStart", $EmptyString)
FileClose($ChartPath&"Total.ini")
Else
FileOpen($ChartPath)
$aChartGold24hr = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "GoldTotal",""), "|", $STR_NOCOUNT)
$aChartElixir24hr = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "ElixirTotal",""), "|", $STR_NOCOUNT)
$aChartDarkE24hr = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "DarkETotal",""), "|", $STR_NOCOUNT)
$aChartWasStartClicked = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "WasStart",""), "|", $STR_NOCOUNT)
FileClose($ChartPath&"Total.ini")
EndIf
_ArrayPush($aChartGold24hr, $iGoldCurrent)
_ArrayPush($aChartElixir24hr, $iElixirCurrent)
_ArrayPush($aChartDarkE24hr, $iDarkCurrent)
_ArrayPush($aChartWasStartClicked, $bGreenButton)
FileOpen($ChartPath&"Total.ini", $FO_OVERWRITE + $FO_CREATEPATH)
IniWrite($ChartPath&"Total.ini", "ChartData", "GoldTotal", _ArrayToString($aChartGold24hr, "|" , -1, -1))
IniWrite($ChartPath&"Total.ini", "ChartData", "ElixirTotal", _ArrayToString($aChartElixir24hr, "|", -1, -1))
IniWrite($ChartPath&"Total.ini", "ChartData", "DarkETotal", _ArrayToString($aChartDarkE24hr, "|", -1, -1))
IniWrite($ChartPath&"Total.ini", "ChartData", "WasStart", _ArrayToString($aChartWasStartClicked, "|", -1, -1))
FileClose($ChartPath&"Total.ini")
Return
EndIf
If 	$WhichSet = "Rate"  Then
Local $aChartGoldRate[96]
Local $aChartElixirRate[96]
Local $aChartDarkERate[96]
Local $aChartWasStartClicked[96]
Local $EmptyString = "0"
For $i = 0 to 94
$EmptyString &= "|0"
Next
If Not FileExists($ChartPath&"Rate.ini") Then
FileOpen($ChartPath&"Rate.ini", $FO_OVERWRITE + $FO_CREATEPATH)
IniWrite($ChartPath&"Rate.ini", "ChartData", "GoldRate", $EmptyString)
IniWrite($ChartPath&"Rate.ini", "ChartData", "ElixirRate", $EmptyString)
IniWrite($ChartPath&"Rate.ini", "ChartData", "DarkERate", $EmptyString)
IniWrite($ChartPath&"Rate.ini", "ChartData", "WasFirstRate", $EmptyString)
FileClose($ChartPath&"Rate.ini")
Else
FileOpen($ChartPath&"Rate.ini")
$aChartGoldRate = StringSplit(IniRead($ChartPath&"Rate.ini", "ChartData", "GoldRate",""), "|", $STR_NOCOUNT)
$aChartElixirRate = StringSplit(IniRead($ChartPath&"Rate.ini", "ChartData", "ElixirRate",""), "|", $STR_NOCOUNT)
$aChartDarkERate = StringSplit(IniRead($ChartPath&"Rate.ini", "ChartData", "DarkERate",""), "|", $STR_NOCOUNT)
$aChartWasStartClicked = StringSplit(IniRead($ChartPath&"Rate.ini", "ChartData", "WasFirstRate",""), "|", $STR_NOCOUNT)
FileClose($ChartPath)
EndIf
_ArrayPush($aChartGoldRate, Round($iGoldTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600))
_ArrayPush($aChartElixirRate, Round($iElixirTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600))
_ArrayPush($aChartDarkERate, Round($iDarkTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600 * 1000))
_ArrayPush($aChartWasStartClicked, $bGreenButton)
FileOpen($ChartPath&"Rate.ini", $FO_OVERWRITE + $FO_CREATEPATH)
IniWrite($ChartPath&"Rate.ini", "ChartData", "GoldRate", _ArrayToString($aChartGoldRate, "|" , -1, -1))
IniWrite($ChartPath&"Rate.ini", "ChartData", "ElixirRate", _ArrayToString($aChartElixirRate, "|", -1, -1))
IniWrite($ChartPath&"Rate.ini", "ChartData", "DarkERate", _ArrayToString($aChartDarkERate, "|", -1, -1))
IniWrite($ChartPath&"Rate.ini", "ChartData", "WasFirstRate", _ArrayToString($aChartWasStartClicked, "|", -1, -1))
FileClose($ChartPath&"Rate.ini")
Return
EndIf
If 	$WhichSet = "Attack"  Then
Local $aChartGoldAttack[96]
Local $aChartElixirAttack[96]
Local $aChartDarkEAttack[96]
Local $aChartGoldBonus[96]
Local $aChartElixirBonus[96]
Local $aChartDarkEBonus[96]
Local $aChartWasStartClicked[96]
Local $EmptyString = "0"
For $i = 0 to 94
$EmptyString &= "|0"
Next
If Not FileExists($ChartPath&"Attack.ini") Then
FileOpen($ChartPath, $FO_OVERWRITE + $FO_CREATEPATH)
IniWrite($ChartPath&"Attack.ini", "ChartData", "GoldAttack", $EmptyString)
IniWrite($ChartPath&"Attack.ini", "ChartData", "ElixirAttack", $EmptyString)
IniWrite($ChartPath&"Attack.ini", "ChartData", "DarkEAttack", $EmptyString)
IniWrite($ChartPath&"Attack.ini", "ChartData", "GoldBonus", $EmptyString)
IniWrite($ChartPath&"Attack.ini", "ChartData", "ElixirBonus", $EmptyString)
IniWrite($ChartPath&"Attack.ini", "ChartData", "DarkEBonus", $EmptyString)
IniWrite($ChartPath&"Attack.ini", "ChartData", "WasFirstAttack", $EmptyString)
FileClose($ChartPath&"Attack.ini")
Else
FileOpen($ChartPath&"Attack.ini")
$aChartGoldAttack = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "GoldAttack",""), "|", $STR_NOCOUNT)
$aChartElixirAttack = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "ElixirAttack",""), "|", $STR_NOCOUNT)
$aChartDarkEAttack = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "DarkEAttack",""), "|", $STR_NOCOUNT)
$aChartGoldBonus = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "GoldBonus",""), "|", $STR_NOCOUNT)
$aChartElixirBonus = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "ElixirBonus",""), "|", $STR_NOCOUNT)
$aChartDarkEBonus = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "DarkEBonus",""), "|", $STR_NOCOUNT)
$aChartWasStartClicked = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "WasFirstAttack",""), "|", $STR_NOCOUNT)
FileClose($ChartPath&"Attack.ini")
EndIf
_ArrayPush($aChartGoldAttack, $iGoldLast)
_ArrayPush($aChartElixirAttack, $iElixirLast)
_ArrayPush($aChartDarkEAttack, $iDarkLast)
_ArrayPush($aChartGoldBonus, $iGoldLastBonus)
_ArrayPush($aChartElixirBonus, $iElixirLastBonus)
_ArrayPush($aChartDarkEBonus, $iDarkLastBonus)
_ArrayPush($aChartWasStartClicked, $bGreenButton)
FileOpen($ChartPath&"Attack.ini", $FO_OVERWRITE + $FO_CREATEPATH)
IniWrite($ChartPath&"Attack.ini", "ChartData", "GoldAttack", _ArrayToString($aChartGoldAttack, "|" , -1, -1))
IniWrite($ChartPath&"Attack.ini", "ChartData", "ElixirAttack", _ArrayToString($aChartElixirAttack, "|", -1, -1))
IniWrite($ChartPath&"Attack.ini", "ChartData", "DarkEAttack", _ArrayToString($aChartDarkEAttack, "|", -1, -1))
IniWrite($ChartPath&"Attack.ini", "ChartData", "GoldBonus", _ArrayToString($aChartGoldBonus, "|" , -1, -1))
IniWrite($ChartPath&"Attack.ini", "ChartData", "ElixirBonus", _ArrayToString($aChartElixirBonus, "|", -1, -1))
IniWrite($ChartPath&"Attack.ini", "ChartData", "DarkEBonus", _ArrayToString($aChartDarkEBonus, "|", -1, -1))
IniWrite($ChartPath&"Attack.ini", "ChartData", "WasFirstAttack", _ArrayToString($aChartWasStartClicked, "|", -1, -1))
FileClose($ChartPath&"Attack.ini")
Return
EndIf
Return
EndFunc
Func btn1DisplayChart()
Global $Form101 = GUICreate("24 Hr Total Chart", 1050, 550, -1, -1, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor(0xffffff)
GUICtrlSetState($btn1Chart, $GUI_DISABLE)
_CreateBarChart1("Total Gold, Elixir, Dark Elixer","Last 24Hr's",20,20,1000,500)
$btnValidateLevels = GUICtrlCreateButton("Exit Chart", 946, 4, 100, 18)
GUICtrlSetOnEvent(-1, "ExitChart1")
GUISetState(@SW_SHOW)
EndFunc
Func ExitChart1()
GUIDelete($Form101)
GUICtrlSetState($btn1Chart, $GUI_ENABLE)
EndFunc
Func btn2DisplayChart()
Global $Form102 = GUICreate("24 Hr Total Chart", 1050, 550, -1, -1, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor(0xffffff)
GUICtrlSetState($btn2Chart, $GUI_DISABLE)
_CreateBarChart2("Total Gold, Elixir, Dark Elixer","Last 24Hr's",20,20,1000,500)
$btnValidateLevels = GUICtrlCreateButton("Exit Chart", 946, 4, 100, 18)
GUICtrlSetOnEvent(-1, "ExitChart2")
GUISetState(@SW_SHOW)
EndFunc
Func ExitChart2()
GUIDelete($Form102)
GUICtrlSetState($btn2Chart, $GUI_ENABLE)
EndFunc
Func btn3DisplayChart()
Global $Form103 = GUICreate("Rates / Hr", 1050, 550, -1, -1, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor(0xffffff)
GUICtrlSetState($btn3Chart, $GUI_DISABLE)
_CreateBarChart3("RATES / HR,","Last 96 Attacks",20,20,1000,500)
$btnValidateLevels = GUICtrlCreateButton("Exit Chart", 946, 4, 100, 18)
GUICtrlSetOnEvent(-1, "ExitChart3")
GUISetState(@SW_SHOW)
EndFunc
Func ExitChart3()
GUIDelete($Form103)
GUICtrlSetState($btn3Chart, $GUI_ENABLE)
EndFunc
Func btn4DisplayChart()
Global $Form104 = GUICreate("24 Hr Total Chart", 1050, 550, -1, -1, BitOR($WS_SYSMENU, $WS_POPUP))
GUISetBkColor(0xffffff)
GUICtrlSetState($btn4Chart, $GUI_DISABLE)
_CreateBarChart4("Attack Data","Last 96 Attacks",20,20,1000,500)
$btnValidateLevels = GUICtrlCreateButton("Exit Chart", 946, 4, 100, 18)
GUICtrlSetOnEvent(-1, "ExitChart4")
GUISetState(@SW_SHOW)
EndFunc
Func ExitChart4()
GUIDelete($Form104)
GUICtrlSetState($btn4Chart, $GUI_ENABLE)
EndFunc
Func _CreateBarChart4($sTitle1="",$sTitle2="",$iX=20,$iY=20,$iW=400,$iH=400)
Local $colorGold = 0xFFD700
Local $colorElixir =0xDD1AD5
Local $colorDark = 0x242024
Local $colorRed = 0xed0404
If $iX=-1 Then $iX=20
If $iY=-1 Then $iY=20
If $iW=-1 Then $iW=400
If $iH=-1 Then $iH=400
Local $aChartGoldAttack[96]
Local $aChartElixirAttack[96]
Local $aChartDarkEAttack[96]
Local $aChartGoldBonus[96]
Local $aChartElixirBonus[96]
Local $aChartDarkEBonus[96]
Local $aChartWasStartClicked[96]
If FileExists($ChartPath&"Attack.ini") Then
FileOpen($ChartPath&"Attack.ini")
$aChartGoldAttack = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "GoldAttack",""), "|", $STR_NOCOUNT)
$aChartGoldBonus = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "GoldBonus",""), "|", $STR_NOCOUNT)
$aChartElixirAttack = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "ElixirAttack",""), "|", $STR_NOCOUNT)
$aChartElixirBonus = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "ElixirBonus",""), "|", $STR_NOCOUNT)
$aChartDarkEAttack = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "DarkEAttack",""), "|", $STR_NOCOUNT)
$aChartDarkEBonus = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "DarkEBonus",""), "|", $STR_NOCOUNT)
$aChartWasStartClicked = StringSplit(IniRead($ChartPath&"Attack.ini", "ChartData", "WasFirstAttack",""), "|", $STR_NOCOUNT)
FileClose($ChartPath&"Attack.ini")
Else
SetLog("No Chart Data Found")
Return
EndIf
Local $max = 0
Local $maxDark = 0
If $max < _ArrayMax($aChartGoldAttack, 1) Then $max = _ArrayMax($aChartGoldAttack, 1)
If $max < _ArrayMax($aChartElixirAttack, 1) Then $max = _ArrayMax($aChartElixirAttack, 1)
If $max < _ArrayMax($aChartGoldBonus, 1) Then $max = _ArrayMax($aChartGoldBonus, 1)
If $max < _ArrayMax($aChartElixirBonus, 1) Then $max = _ArrayMax($aChartElixirBonus, 1)
If $maxDark < _ArrayMax($aChartDarkEAttack, 1) Then $maxDark = _ArrayMax($aChartDarkEAttack, 1)
If $maxDark < _ArrayMax($aChartDarkEBonus, 1) Then $maxDark = _ArrayMax($aChartDarkEBonus, 1)
$max = $max / 1000
$grp = GUICtrlCreateGroup("", $iX, $iY, $iW, $iH)
GUICtrlCreateLabel($sTitle1,$iX+15, $iY+10,$iW-30,-1,$SS_CENTER)
GUICtrlSetColor(-1,0x002244)
GUICtrlSetFont(-1, 9, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel($sTitle2,$iX+15, $iY+25,$iW-30,-1,$SS_CENTER)
GUICtrlSetColor(-1,0x002244)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Local $Canvas
$Canvas = _CreateBarCanvas($iX+15, $iY+15, $iW-50, $iH-60)
GUICtrlCreateLabel( "Oldest           ------------->           Newest",$iX+52+(($Canvas[2]/96))*35,$iY+$iH-18)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateGraphic($Canvas[0]-0.5*$Canvas[4], $Canvas[1]+0.5*$Canvas[4], $Canvas[2], $Canvas[3],0)
Local $icount = -1
For $i = 0 to UBound($aChartDarkEAttack) -1
If $aChartDarkEAttack[$i] <> 0 or $aChartDarkEAttack[$i] <> "" Then
$icount = $i -1
ExitLoop
EndIf
Next
If $icount = -1 Then $icount = 0
For $i = 0 to UBound($aChartDarkEAttack) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorDark)
If $i = $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5 + ($Canvas[2] / UBound($aChartDarkEAttack)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($maxDark)) * $aChartDarkEAttack[$i])
EndIf
If $i > $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5 + ($Canvas[2] / UBound($aChartDarkEAttack)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($maxDark)) * $aChartDarkEAttack[$i])
EndIf
Next
Local $icount = -1
For $i = 0 to UBound($aChartDarkEBonus) -1
If $aChartDarkEBonus[$i] <> 0 or $aChartDarkEBonus[$i] <> "" Then
$icount = $i -1
ExitLoop
EndIf
Next
If $icount = -1 Then $icount = 0
For $i = 0 to UBound($aChartDarkEBonus) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorDark)
If $i = $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5 + ($Canvas[2] / UBound($aChartDarkEBonus)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($maxDark)) * $aChartDarkEBonus[$i])
EndIf
If $i > $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5 + ($Canvas[2] / UBound($aChartDarkEBonus)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($maxDark)) * $aChartDarkEBonus[$i])
EndIf
Next
Local $icount = -1
For $i = 0 to UBound($aChartElixirAttack) -1
If $aChartElixirAttack[$i] <> 0 or $aChartElixirAttack[$i] <> "" Then
$icount = $i -1
ExitLoop
EndIf
Next
If $icount = -1 Then $icount = 0
For $i = 0 to UBound($aChartElixirAttack) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorElixir)
If $i = $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5 + ($Canvas[2] / UBound($aChartElixirAttack)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max)) * $aChartElixirAttack[$i] / 1000)
EndIf
If $i > $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5 + ($Canvas[2] / UBound($aChartElixirAttack)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max)) * $aChartElixirAttack[$i] / 1000)
EndIf
Next
Local $icount = -1
For $i = 0 to UBound($aChartElixirBonus) -1
If $aChartElixirBonus[$i] <> 0 or $aChartElixirBonus[$i] <> "" Then
$icount = $i -1
ExitLoop
EndIf
Next
If $icount = -1 Then $icount = 0
For $i = 0 to UBound($aChartElixirBonus) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorElixir)
If $i = $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5 + ($Canvas[2] / UBound($aChartElixirBonus)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max)) * $aChartElixirBonus[$i] / 1000)
EndIf
If $i > $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5 + ($Canvas[2] / UBound($aChartElixirBonus)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max)) * $aChartElixirBonus[$i] / 1000)
EndIf
Next
Local $icount = -1
For $i = 0 to UBound($aChartGoldAttack) -1
If $aChartGoldAttack[$i] <> 0 or $aChartGoldAttack[$i] <> "" Then
$icount = $i -1
ExitLoop
EndIf
Next
If $icount = -1 Then $icount = 0
For $i = 0 to UBound($aChartGoldAttack) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorGold)
If $i = $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5 + ($Canvas[2] / UBound($aChartGoldAttack)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max)) * $aChartGoldAttack[$i] / 1000)
EndIf
If $i > $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 10 + ($Canvas[2] / UBound($aChartGoldAttack)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max)) * $aChartGoldAttack[$i] / 1000)
EndIf
Next
Local $icount = -1
For $i = 0 to UBound($aChartGoldBonus) -1
If $aChartGoldBonus[$i] <> 0 or $aChartGoldBonus[$i] <> "" Then
$icount = $i -1
ExitLoop
EndIf
Next
If $icount = -1 Then $icount = 0
For $i = 0 to UBound($aChartGoldBonus) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorGold)
If $i = $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5 + ($Canvas[2] / UBound($aChartGoldBonus)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max)) * $aChartGoldBonus[$i] / 1000)
EndIf
If $i > $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 10 + ($Canvas[2] / UBound($aChartGoldBonus)) * $i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max)) * $aChartGoldBonus[$i] / 1000)
EndIf
Next
For $i = 0 to UBound($aChartWasStartClicked) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, 0x25ba07)
If $aChartWasStartClicked[$i] = "True" Then
GUICtrlSetGraphic(-1, $GUI_GR_ELLIPSE, 5+($Canvas[2]/UBound($aChartWasStartClicked))*$i+$j, -2+$Canvas[3]-$j, 0.5*($Canvas[2]/UBound($aChartWasStartClicked)), 0.5*($Canvas[2]/UBound($aChartWasStartClicked)) )
EndIf
Next
GUICtrlSetGraphic(-1,$GUI_GR_REFRESH)
For $i=0 To $Canvas[3] Step $Canvas[3]/5
If ($i/$Canvas[3])*_RoundUp($max) = 0 Then
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($max),$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i,30,-1,$SS_RIGHT)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Else
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($max) & " K",$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i - 5,30,-1,$SS_RIGHT)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($maxDark),$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i + 5,30,-1,$SS_RIGHT)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
EndIf
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func _CreateBarChart3($sTitle1="",$sTitle2="",$iX=20,$iY=20,$iW=400,$iH=400)
Local $colorGold = 0xFFD700
Local $colorElixir =0xDD1AD5
Local $colorDark = 0x242024
Local $colorRed = 0xed0404
If $iX=-1 Then $iX=20
If $iY=-1 Then $iY=20
If $iW=-1 Then $iW=400
If $iH=-1 Then $iH=400
Local $aChartGoldRate[96]
Local $aChartElixirRate[96]
Local $aChartDarkERate[96]
Local $aChartWasStartClicked[96]
If FileExists($ChartPath&"Total.ini") Then
FileOpen($ChartPath&"Total.ini")
$aChartGoldRate = StringSplit(IniRead($ChartPath&"Rate.ini", "ChartData", "GoldRate",""), "|", $STR_NOCOUNT)
$aChartElixirRate = StringSplit(IniRead($ChartPath&"Rate.ini", "ChartData", "ElixirRate",""), "|", $STR_NOCOUNT)
$aChartDarkERate = StringSplit(IniRead($ChartPath&"Rate.ini", "ChartData", "DarkERate",""), "|", $STR_NOCOUNT)
$aChartWasStartClicked = StringSplit(IniRead($ChartPath&"Rate.ini", "ChartData", "WasFirstRate",""), "|", $STR_NOCOUNT)
FileClose($ChartPath&"Total.ini")
Else
SetLog("No Chart Data Found")
Return
EndIf
Local $maxHalf = 0
Local $maxMin = 0
If Number($maxHalf) < _ArrayMax($aChartGoldRate, 1) Then $maxHalf = _ArrayMax($aChartGoldRate, 1)
If Number($maxHalf) < _ArrayMax($aChartElixirRate, 1) Then $maxHalf = _ArrayMax($aChartElixirRate, 1)
If Number($maxHalf) < _ArrayMax($aChartDarkERate, 1) Then $maxHalf = _ArrayMax($aChartDarkERate, 1)
If Number($maxMin) > _ArrayMin($aChartGoldRate, 1) Then $maxMin = _ArrayMin($aChartGoldRate, 1)
If Number($maxMin) > _ArrayMin($aChartElixirRate, 1) Then $maxMin = _ArrayMin($aChartElixirRate, 1)
If Number($maxMin) > _ArrayMin($aChartDarkERate, 1) Then $maxMin = _ArrayMin($aChartDarkERate, 1)
If Abs($maxMin) > Number($maxHalf) Then $maxHalf = Abs($maxMin)
Local $max = $maxHalf * 2
$grp = GUICtrlCreateGroup("", $iX, $iY, $iW, $iH)
GUICtrlCreateLabel($sTitle1,$iX+15, $iY+10,$iW-30,-1,$SS_CENTER)
GUICtrlSetColor(-1,0x002244)
GUICtrlSetFont(-1, 9, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel($sTitle2,$iX+15, $iY+25,$iW-30,-1,$SS_CENTER)
GUICtrlSetColor(-1,0x002244)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Local $Canvas
$Canvas = _CreateBarCanvas($iX+15, $iY+15, $iW-50, $iH-60)
GUICtrlCreateLabel( "Oldest           ------------->           Newest",$iX+52+(($Canvas[2]/96))*35,$iY+$iH-18)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateGraphic($Canvas[0]-0.5*$Canvas[4], $Canvas[1]+0.5*$Canvas[4], $Canvas[2], $Canvas[3],0)
Local $icount = -1
For $i = 0 to UBound($aChartGoldRate) -1
If $aChartGoldRate[$i] <> 0 or $aChartGoldRate[$i] <> "" Then
$icount = $i -1
ExitLoop
EndIf
Next
If $icount = -1 Then $icount = 0
For $i = 0 to UBound($aChartDarkERate) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorDark)
If $i = $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5+($Canvas[2]/UBound($aChartDarkERate))*$i, -2+$Canvas[3] - ($Canvas[3]/_RoundUp($max))*($aChartDarkERate[$i]+$maxHalf))
EndIf
If $i > $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5+($Canvas[2]/UBound($aChartDarkERate))*$i, -2+$Canvas[3] - ($Canvas[3]/_RoundUp($max))*($aChartDarkERate[$i]+$maxHalf))
EndIf
Next
$icount = -1
For $i = 0 to UBound($aChartGoldRate) -1
If $aChartGoldRate[$i] <> 0 or $aChartGoldRate[$i] <> "" Then
$icount = $i -1
ExitLoop
EndIf
Next
If $icount = -1 Then $icount = 0
For $i = 0 to UBound($aChartElixirRate) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorElixir)
If $i = $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5+($Canvas[2]/UBound($aChartElixirRate))*$i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max))*($aChartElixirRate[$i]+$maxHalf) )
EndIf
If $i > $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5+($Canvas[2]/UBound($aChartElixirRate))*$i, -2 + $Canvas[3] - ($Canvas[3] / _RoundUp($max))*($aChartElixirRate[$i]+$maxHalf) )
EndIf
Next
$icount = -1
For $i = 0 to UBound($aChartGoldRate) -1
If $aChartGoldRate[$i] <> 0 or $aChartGoldRate[$i] <> "" Then
$icount = $i -1
ExitLoop
EndIf
Next
If $icount = -1 Then $icount = 0
For $i = 0 to UBound($aChartGoldRate) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorGold)
If $i = $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5+($Canvas[2]/UBound($aChartGoldRate))*$i, -2+$Canvas[3] - ($Canvas[3]/_RoundUp($max))*($aChartGoldRate[$i]+$maxHalf) )
EndIf
If $i > $icount Then
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5+($Canvas[2]/UBound($aChartGoldRate))*$i, -2+$Canvas[3] - ($Canvas[3]/_RoundUp($max))*($aChartGoldRate[$i]+$maxHalf) )
EndIf
Next
For $i = 0 to UBound($aChartDarkERate) -1 Step 4
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 1)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorRed)
If $i = 0 Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5+($Canvas[2]/UBound($aChartDarkERate))*$i, -2+$Canvas[3] - ($Canvas[3]/_RoundUp($max))*(0+$maxHalf))
Else
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 50+($Canvas[2]/UBound($aChartDarkERate))*$i, -2+$Canvas[3] - ($Canvas[3]/_RoundUp($max))*(0+$maxHalf))
EndIf
Next
For $i = 0 to UBound($aChartWasStartClicked) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, 0x25ba07)
If $aChartWasStartClicked[$i] = "True" Then
GUICtrlSetGraphic(-1, $GUI_GR_ELLIPSE, -25+($Canvas[2]/UBound($aChartWasStartClicked))*$i+$j, -2+$Canvas[3]-$j, 0.5*($Canvas[2]/UBound($aChartWasStartClicked)), 0.5*($Canvas[2]/UBound($aChartWasStartClicked)) )
EndIf
Next
GUICtrlSetGraphic(-1,$GUI_GR_REFRESH)
For $i=0 To $Canvas[3] Step $Canvas[3]/5
If ($i/$Canvas[3])*_RoundUp($max)- ($maxHalf) = 0 Then
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($max)- ($maxHalf),$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i,30,-1,$SS_RIGHT)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Else
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($max) - ($maxHalf) & " /Hr",$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i - 5,30,-1,$SS_RIGHT)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
EndIf
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func _RoundUp($m)
Local $rv = Round(Ceiling($m/10)*10,-1)
Return $rv
EndFunc
Func _CreateBarCanvas($iX=0, $iY=0, $iW=400, $iH=400, $iDepthCanvas=30, $BgColor=0xEEEEEE)
Local $iXCanvas=$iX+$iDepthCanvas
Local $iYCanvas=$iY+10+2*$iDepthCanvas
Local $iWCanvas=$iW-2*$iDepthCanvas
Local $iHCanvas=$iH-2*$iDepthCanvas
Local $BgColor2 = $BgColor - 0x333333
For $i=0 To $iDepthCanvas
GUICtrlCreateGraphic($iXCanvas+$i, $iYCanvas-$i, $iWCanvas, $iHCanvas, 0)
GUICtrlSetBkColor(-1, $BgColor)
GUICtrlSetColor(-1, $BgColor2)
Next
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 0, $iHCanvas)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $BgColor)
GUICtrlSetGraphic(-1, $GUI_GR_LINE, -$iDepthCanvas-1, $iHCanvas+$iDepthCanvas+1)
For $i=0 To $iHCanvas Step $iHCanvas/5
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 0, $i)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $BgColor2)
GUICtrlSetGraphic(-1, $GUI_GR_LINE, $iWCanvas, $i)
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 0, $i)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $BgColor)
GUICtrlSetGraphic(-1, $GUI_GR_LINE, -$iDepthCanvas, $i+$iDepthCanvas)
Next
Local $Canvas = StringSplit($iXCanvas+$iDepthCanvas &"|"& $iYCanvas-$iDepthCanvas&"|"&$iWCanvas&"|"&$iHCanvas&"|"&$iDepthCanvas,"|",2)
Return $Canvas
EndFunc
Func _CreateBarChart2($sTitle1="",$sTitle2="",$iX=20,$iY=20,$iW=400,$iH=400)
Local $colorGold = 0xFFD700
Local $colorElixir =0xDD1AD5
Local $colorDark = 0x242024
If $iX=-1 Then $iX=20
If $iY=-1 Then $iY=20
If $iW=-1 Then $iW=400
If $iH=-1 Then $iH=400
Local $aChartGold24hr[24]
Local $aChartElixir24hr[24]
Local $aChartDarkE24hr[24]
Local $aChartWasStartClicked[24]
If FileExists($ChartPath&"Total.ini") Then
FileOpen($ChartPath&"Total.ini")
$aChartGold24hr = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "GoldTotal","0"), "|", $STR_NOCOUNT)
$aChartElixir24hr = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "ElixirTotal","0"), "|", $STR_NOCOUNT)
$aChartDarkE24hr = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "DarkETotal","0"), "|", $STR_NOCOUNT)
$aChartWasStartClicked = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "WasStart","False"), "|", $STR_NOCOUNT)
FileClose($ChartPath&"Total.ini")
Else
SetLog("No Chart Data Found")
Return
EndIf
Local $max = 10
Local $maxDark = 200
$grp = GUICtrlCreateGroup("", $iX, $iY, $iW, $iH)
GUICtrlCreateLabel($sTitle1,$iX+15, $iY+10,$iW-30,-1,$SS_CENTER)
GUICtrlSetColor(-1,0x002244)
GUICtrlSetFont(-1, 9, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel($sTitle2,$iX+15, $iY+25,$iW-30,-1,$SS_CENTER)
GUICtrlSetColor(-1,0x002244)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Local $Canvas
$Canvas = _CreateBarCanvas($iX+15, $iY+15, $iW-50, $iH-60)
For $i = 0 To 95 Step 4
GUICtrlCreateLabel( (96 -$i) /4 &" Hrs", $iX+52+(($Canvas[2]/96))*$i+5, $iY+$iH-30)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Next
GUICtrlCreateLabel( "Oldest           ------------->           Newest",$iX+52+(($Canvas[2]/96))*35,$iY+$iH-18)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateGraphic($Canvas[0]-0.5*$Canvas[4], $Canvas[1]+0.5*$Canvas[4], $Canvas[2], $Canvas[3],0)
For $i = 0 to UBound($aChartDarkE24hr) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorDark)
If $i = 0 Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5+($Canvas[2]/UBound($aChartDarkE24hr))*$i+$j, -2+$Canvas[3]-$j - ($Canvas[3]/_RoundUp($maxDark))*$aChartDarkE24hr[$i]/1000)
Else
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5+($Canvas[2]/UBound($aChartDarkE24hr))*$i+$j, -2+$Canvas[3]-$j - ($Canvas[3]/_RoundUp($maxDark))*$aChartDarkE24hr[$i]/1000)
EndIf
Next
For $i = 0 to UBound($aChartGold24hr) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorGold)
If $i = 0 Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5+($Canvas[2]/UBound($aChartGold24hr))*$i+$j, -2+$Canvas[3]-$j - ($Canvas[3]/_RoundUp($max))*$aChartGold24hr[$i]/1000000)
Else
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5+($Canvas[2]/UBound($aChartGold24hr))*$i+$j, -2+$Canvas[3]-$j - ($Canvas[3]/_RoundUp($max))*$aChartGold24hr[$i]/1000000)
EndIf
Next
For $i = 0 to UBound($aChartElixir24hr) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorElixir)
If $i = 0 Then
GUICtrlSetGraphic(-1, $GUI_GR_MOVE, 5+($Canvas[2]/UBound($aChartElixir24hr))*$i+$j, -2+$Canvas[3]-$j - ($Canvas[3]/_RoundUp($max))*$aChartElixir24hr[$i]/1000000)
Else
GUICtrlSetGraphic(-1, $GUI_GR_LINE, 5+($Canvas[2]/UBound($aChartElixir24hr))*$i+$j, -2+$Canvas[3]-$j - ($Canvas[3]/_RoundUp($max))*$aChartElixir24hr[$i]/1000000)
EndIf
Next
For $i = 0 to UBound($aChartWasStartClicked) -1
GUICtrlSetGraphic(-1, $GUI_GR_PENSIZE, 3)
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, 0x25ba07)
If $aChartWasStartClicked[$i] = "True" Then
GUICtrlSetGraphic(-1, $GUI_GR_ELLIPSE, 5+($Canvas[2]/UBound($aChartWasStartClicked))*$i+$j, -2+$Canvas[3]-$j, 0.5*($Canvas[2]/UBound($aChartWasStartClicked)), 0.5*($Canvas[2]/UBound($aChartWasStartClicked)) )
EndIf
Next
GUICtrlSetGraphic(-1,$GUI_GR_REFRESH)
For $i=0 To $Canvas[3] Step $Canvas[3]/5
If ($i/$Canvas[3])*_RoundUp($max) = 0 Then
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($max),$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i,30,-1,$SS_RIGHT)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Else
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($max) & " M",$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i - 5,30,-1,$SS_RIGHT)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($maxDark) & " K",$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i + 5,30,-1,$SS_RIGHT)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
EndIf
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func _CreateBarChart1($sTitle1="",$sTitle2="",$iX=20,$iY=20,$iW=400,$iH=400 )
Local $max = 10
Local $maxDark = 200
Local $arNames[96]
Local $arValues[96]
Local $arColours[UBound($arNames)]
Local $GraphStartPushed[96]
Local $colorGold = 0xFFD700
Local $colorGoldsh = 0xaaab0d
Local $colorElixir =0xDD1AD5
Local $colorElixirsh = 0xba2cb5
Local $colorDark = 0x242024
For $i=0 To UBound($arValues)-1 Step 4
$arColours[$i] = $colorGold
$arColours[$i+1] = $colorElixir
$arColours[$i+2] = $colorDark
Next
Local $aChartGold24hr[24]
Local $aChartElixir24hr[24]
Local $aChartDarkE24hr[24]
Local $aChartWasStartClicked[24]
If FileExists($ChartPath&"Total.ini") Then
FileOpen($ChartPath&"Total.ini")
$aChartGold24hr = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "GoldTotal","0"), "|", $STR_NOCOUNT)
$aChartElixir24hr = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "ElixirTotal","0"), "|", $STR_NOCOUNT)
$aChartDarkE24hr = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "DarkETotal","0"), "|", $STR_NOCOUNT)
$aChartWasStartClicked = StringSplit(IniRead($ChartPath&"Total.ini", "ChartData", "WasStart","False"), "|", $STR_NOCOUNT)
FileClose($ChartPath&"Total.ini")
Else
SetLog("No Chart Data Found")
Return
EndIf
For $i=0 To 95
$arNames[$i]=UBound($arNames) -$i
Next
Local $j=0
For $i=0 To UBound($arValues) - 1 Step 4
$arValues[$i] = Round(Number($aChartGold24hr[$j])/1000000, 3)
$arValues[$i + 1] = Round(Number($aChartElixir24hr[$j])/1000000, 3)
$arValues[$i + 2] = Round(Number($aChartDarkE24hr[$j]), 3)
$arValues[$i + 3] = 0
$GraphStartPushed[$i] = 0
$GraphStartPushed[$i + 1] = $aChartWasStartClicked[$j]
$GraphStartPushed[$i + 2] = 0
$GraphStartPushed[$i + 3] = 0
$j += 1
Next
If $iX=-1 Then $iX=20
If $iY=-1 Then $iY=20
If $iW=-1 Then $iW=400
If $iH=-1 Then $iH=400
$grp = GUICtrlCreateGroup("", $iX, $iY, $iW, $iH)
GUICtrlCreateLabel($sTitle1,$iX+15, $iY+10,$iW-30,-1,$SS_CENTER)
GUICtrlSetColor(-1,0x002244)
GUICtrlSetFont(-1, 9, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel($sTitle2,$iX+15, $iY+25,$iW-30,-1,$SS_CENTER)
GUICtrlSetColor(-1,0x002244)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Local $Canvas
$Canvas = _CreateBarCanvas($iX+15, $iY+15, $iW-50, $iH-60)
For $i = 0 To UBound($arNames)-1 Step 4
GUICtrlCreateLabel($arNames[($i)]/4 &" Hrs", $iX+52+(($Canvas[2]/UBound($arNames)))*$i+5, $iY+$iH-30)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Next
GUICtrlCreateLabel( "Oldest           ------------->           Newest",$iX+52+(($Canvas[2]/UBound($arNames)))*35,$iY+$iH-18)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateGraphic($Canvas[0]-0.5*$Canvas[4], $Canvas[1]+0.5*$Canvas[4], $Canvas[2], $Canvas[3],0)
For $i=0 To UBound($arValues)-1
For $j=$Canvas[4]/2.5 To 0 Step -0.5
If $arColours[$i] = $colorGold Then
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorGoldsh, $arColours[$i])
ElseIf $arColours[$i] = $colorElixir Then
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $colorElixirsh, $arColours[$i])
Else
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, $arColours[$i] - 0x333333, $arColours[$i])
EndIf
If $arColours[$i] = $colorDark Then
GUICtrlSetGraphic(-1, $GUI_GR_RECT, 5+($Canvas[2]/UBound($arValues))*$i+$j, -2+$Canvas[3]-$j, 0.9*($Canvas[2]/UBound($arValues)), -($Canvas[3]/_RoundUp($maxDark))*$arValues[$i]/1000)
ElseIf $arColours[$i] = $colorElixir and $GraphStartPushed[$i] = "True" Then
GUICtrlSetGraphic(-1, $GUI_GR_RECT, 5+($Canvas[2]/UBound($arValues))*$i+$j, -2+$Canvas[3]-$j, 0.9*($Canvas[2]/UBound($arValues)), -($Canvas[3]/_RoundUp($max))*$arValues[$i])
GUICtrlSetGraphic(-1, $GUI_GR_COLOR, 0x25ba07, 0x3bdd1a)
GUICtrlSetGraphic(-1, $GUI_GR_ELLIPSE, 5+($Canvas[2]/UBound($arValues))*$i+$j, -2+$Canvas[3]-$j, 0.9*($Canvas[2]/UBound($arValues)), 0.9*($Canvas[2]/UBound($arValues)) )
Else
GUICtrlSetGraphic(-1, $GUI_GR_RECT, 5+($Canvas[2]/UBound($arValues))*$i+$j, -2+$Canvas[3]-$j, 0.9*($Canvas[2]/UBound($arValues)), -($Canvas[3]/_RoundUp($max))*$arValues[$i])
EndIf
Next
Next
GUICtrlSetGraphic(-1,$GUI_GR_REFRESH)
For $i=0 To $Canvas[3] Step $Canvas[3]/5
If ($i/$Canvas[3])*_RoundUp($max) = 0 Then
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($max),$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i,30,-1,$SS_RIGHT)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
Else
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($max) & " M",$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i - 5,30,-1,$SS_RIGHT)
GUICtrlSetColor(-1,0x990000)
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
GUICtrlCreateLabel(($i/$Canvas[3])*_RoundUp($maxDark) & " K",$Canvas[0]-65,$Canvas[1]+$Canvas[3]+$Canvas[4]-$i + 5,30,-1,$SS_RIGHT)
GUICtrlSetFont(-1, 8, 800, 0, "Arial")
GUICtrlSetBkColor(-1,$GUI_BKCOLOR_TRANSPARENT)
EndIf
Next
GUICtrlCreateGroup("", -99, -99, 1, 1)
EndFunc
Func CheckImageType()
Setlog("Detecting your Village Theme", $COLOR_BLUE)
ClickP($aAway, 2, 20, "#0467")
If _Sleep($iDelayImageType1) Then Return
If Not IsMainPage() Then ClickP($aAway, 2, 20, "#0467")
If _ColorCheck(_GetPixelColor($aImageTypeN1[0], $aImageTypeN1[1], True), Hex($aImageTypeN1[2], 6), $aImageTypeN1[3]) And  _ColorCheck(_GetPixelColor($aImageTypeN2[0], $aImageTypeN2[1], True), Hex($aImageTypeN2[2], 6), $aImageTypeN2[3]) Then
$iDetectedImageType = 0
Setlog("Normal Theme detected")
ElseIf _ColorCheck(_GetPixelColor($aImageTypeS1[0], $aImageTypeS1[1], True), Hex($aImageTypeS1[2], 6), $aImageTypeS1[3]) And  _ColorCheck(_GetPixelColor($aImageTypeS2[0], $aImageTypeS2[1], True), Hex($aImageTypeS2[2], 6), $aImageTypeS2[3]) Then
$iDetectedImageType = 1
Setlog("Snow Theme detected")
Else
$iDetectedImageType = 0
Setlog("Default Theme detected")
EndIf
LoadElixirImage()
LoadElixirImage75Percent()
LoadElixirImage50Percent()
EndFunc
Func CheckBaseQuick()
If IsMainPage() Then
If $Debugsetlog = 1 Then Setlog("CheckBaseQuick now...", $COLOR_DEBUG)
RequestCC()
If _Sleep($iDelayRunBot1) Then Return
checkMainScreen(False)
If $Restart = True Then Return
DonateCC()
If _Sleep($iDelayRunBot1) Then Return
checkMainScreen(False)
If $Restart = True Then Return
If Not ($FullArmy) And $bTrainEnabled = True Then
TestTrainRevamp()
If $Restart = True Then Return
EndIf
Collect()
If _Sleep($iDelayRunBot1) Then Return
Else
If $Debugsetlog = 1 Then Setlog("Not on main page, CheckBaseQuick skipped", $COLOR_DEBUG)
EndIf
EndFunc
Func CheckBaseQuick2($bStopRecursion = False, $sReturnHome = "")
If $bStopRecursion = True Then $bDisableBreakCheck = True
Switch $sReturnHome
Case "cloud"
If _CheckPixel2($aRtnHomeCloud1, $bCapturePixel, Default, "Return Home Btn chk1", $COLOR_DEBUG) And  _CheckPixel2($aRtnHomeCloud2, $bCapturePixel, Default, "Return Home Btn chk2", $COLOR_DEBUG) Then
ClickP($aRtnHomeCloud1, 1, 0, "#0513")
Local $wCount = 0
While IsMainPage() = False
If _Sleep($iDelayGetResources1) Then Return
$wCount += 1
If $wCount > 40 Then
Setlog("Warning, Main page not found", $COLOR_WARNING)
ExitLoop
EndIf
WEnd
EndIf
EndSwitch
If IsMainPage() Then
If $Debugsetlog = 1 Then Setlog("CheckBaseQuick now...", $COLOR_DEBUG)
RequestCC()
If _Sleep($iDelayRunBot1) Then Return
checkMainScreen(False)
If $Restart = True Then
If $bStopRecursion = True Then $bDisableBreakCheck = False
Return
EndIf
DonateCC()
If _Sleep($iDelayRunBot1) Then Return
checkMainScreen(False)
If $Restart = True Then
If $bStopRecursion = True Then $bDisableBreakCheck = False
Return
EndIf
If Not ($FullArmy) And $bTrainEnabled = True Then
TestTrainRevamp()
If $Restart = True Then Return
Else
If $bStopRecursion = True Then $bDisableBreakCheck = False
Return
EndIf
Collect()
If _Sleep($iDelayRunBot1) Then Return
Else
If $Debugsetlog = 1 Then Setlog("Not on main page, CheckBaseQuick skipped", $COLOR_DEBUG)
EndIf
If $bStopRecursion = True Then $bDisableBreakCheck = False
EndFunc
Func chkShieldStatus($bChkShield = True, $bForceChkPBT = False)
If ($ichkSinglePBTForced = 0 And ($iChkBotStop = 1 And $icmbBotCond >= 19) = False) And $ichkCloseWaitEnable = 0 Or Not (IsMainPage()) Then Return
Local $Result, $iTimeTillPBTstartSec, $ichkTime = 0, $ichkSTime = 0, $ichkPBTime = 0
If $bChkShield Or $aShieldStatus[0] = "" Or $aShieldStatus[1] = "" Or $aShieldStatus[2] = "" Or $sPBStartTime = "" Or $bGForcePBTUpdate = True Then
$Result = getShieldInfo()
If @error Then Setlog("chkShieldStatus Shield OCR error= " & @error & "Extended= " & @extended, $COLOR_RED)
If _Sleep($iDelayRespond) Then Return
If IsArray($Result) Then
If $debugSetlog = 1 Then
Setlog("Shield expires in: " & _DateDiff('n', $Result[2], _NowCalc()) & " Minutes", $COLOR_DEBUG)
EndIf
If _DateIsValid($aShieldStatus[2]) Then
$ichkTime = Abs(Int(_DateDiff('s', $aShieldStatus[2], $Result[2])))
If $ichkTime > 60 Then
$bForceChkPBT = True
If $debugSetlog = 1 Then Setlog("Shield time changed: " & $ichkTime & " Sec, Force PBT OCR: " & $bForceChkPBT, $COLOR_DEBUG)
EndIf
EndIf
$aShieldStatus = $Result
If $iChkBotStop = 1 And $icmbBotCond >= 19 Then
If $aShieldStatus[0] = "shield" Then
Setlog("Shield found, Halt Attack Now!", $COLOR_BLUE)
$bWaitShield = True
$Is_ClientSyncError = False
$Is_SearchLimit = False
Else
$bWaitShield = False
If $MeetCondStop = True Then
Setlog("Shield expired, resume attacking", $COLOR_BLUE)
$bTrainEnabled = True
$bDonationEnabled = True
$MeetCondStop = False
Else
If $debugSetlog = 1 Then Setlog("Halt With Shield: Shield not found...", $COLOR_DEBUG)
EndIf
EndIf
EndIf
Else
If $debugSetlog = 1 Then Setlog("Bad getShieldInfo() return value: " & $Result, $COLOR_DEBUG)
If _Sleep($iDelayRespond) Then Return
For $i = 0 To UBound($aShieldStatus) - 1
$aShieldStatus[$i] = ""
Next
EndIf
EndIf
If $ichkSinglePBTForced = 0 Then Return
If _DateIsValid($sPBStartTime) Then
$ichkPBTime = Int(_DateDiff('s', $sPBStartTime, _NowCalc()))
If $ichkPBTime >= 295 Then
$bForceChkPBT = True
If $debugSetlog = 1 Then Setlog("Found old PB time= " & $ichkPBTime & " Seconds, Force update:" & $bForceChkPBT, $COLOR_DEBUG)
EndIf
EndIf
If $bForceChkPBT Or $bGForcePBTUpdate Or $sPBStartTime = "" Then
$bGForcePBTUpdate = False
$Result = getPBTime()
If @error Then Setlog("chkShieldStatus getPBTime OCR error= " & @error & ", Extended= " & @extended, $COLOR_RED)
If _Sleep($iDelayRespond) Then Return
If _DateIsValid($Result) Then
$iTimeTillPBTstartMin = Int(_DateDiff('n', $Result, _NowCalc()))
If $debugSetlog = 1 Then Setlog("Personal Break starts in: " & $iTimeTillPBTstartMin & "Minutes", $COLOR_DEBUG)
If $iTimeTillPBTstartMin < -(Int($iValuePBTimeForcedExit)) Then
$sPBStartTime = _DateAdd('n', -(Int($iValuePBTimeForcedExit)), $Result)
ElseIf $iTimeTillPBTstartMin < 0 Then
$sPBStartTime = $Result
Else
$sPBStartTime = ""
EndIf
If $debugSetlog = 1 Then Setlog("Early Log Off time=" & $sPBStartTime & ", In " & _DateDiff('n', $sPBStartTime, _NowCalc()) & " Minutes", $COLOR_DEBUG)
Else
Setlog("Bad getPBTtime() return value: " & $Result, $COLOR_RED)
$sPBStartTime = ""
EndIf
EndIf
If checkObstacles() Then checkMainScreen(False)
EndFunc
Func Collect()
If $RunState = False Then Return
ClickP($aAway, 1, 0, "#0332")
If $iChkCollect = 0 Then Return
VillageReport(True, True)
$tempCounter = 0
While ($iGoldCurrent = "" Or $iElixirCurrent = "" Or ($iDarkCurrent = "" And $iDarkStart <> "")) And $tempCounter < 3
$tempCounter += 1
VillageReport(True, True)
WEnd
Local $tempGold = $iGoldCurrent
Local $tempElixir = $iElixirCurrent
Local $tempDElixir = $iDarkCurrent
checkAttackDisable($iTaBChkIdle)
SetLog("Collecting Resources", $COLOR_BLUE)
If _Sleep($iDelayCollect2) Then Return
Local $directory = @ScriptDir & "\images\Resources\Collect"
Local $Filename = ""
Local $CollectXY
IsWaitingForConnection()
Local $aResult = returnMultipleMatchesOwnVillage($directory)
If UBound($aResult) > 1 Then
For $i = 1 To UBound($aResult) - 1
$Filename = $aResult[$i][1]
$CollectXY = $aResult[$i][5]
If IsMainPage() Then
If IsArray($CollectXY) Then
For $t = 0 To UBound($CollectXY) - 1
If $DebugSetLog = 1 Then SetLog($Filename & " found (" & $CollectXY[$t][0] & "," & $CollectXY[$t][1] & ")", $COLOR_DEBUG)
If $iUseRandomClick = 0 then
Click($CollectXY[$t][0], $CollectXY[$t][1], 1, 0, "#0430")
If _Sleep($iDelayCollect2) Then Return
Else
ClickZone($CollectXY[$t][0], $CollectXY[$t][1], 5, "#0430")
_Sleep(Random($iDelayCollect2, $iDelayCollect2 * 4, 1))
EndIF
Next
EndIf
EndIf
Next
EndIf
If _Sleep($iDelayCollect3) Then Return
checkMainScreen(False)
Setlog("Searching for a Loot Cart..", $COLOR_BLUE)
Local $LootCart = @ScriptDir & "\images\Resources\LootCart\loot_cart.png"
Local $LootCartX, $LootCartY
$ToleranceImgLoc = 0.850
Local $fullCocAreas = "ECD"
Local $MaxReturnPoints = 1
_CaptureRegion2()
Local $res = DllCall($hImgLib, "str", "SearchTile", "handle", $hHBitmap2, "str", $LootCart, "float", $ToleranceImgLoc, "str", $fullCocAreas, "Int", $MaxReturnPoints)
If @error Then _logErrorDLLCall($pImgLib, @error)
If IsArray($res) Then
If $DebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_DEBUG)
If $res[0] = "0" Or $res[0] = "" Then
SetLog("No Loot Cart found, Yard is clean!", $COLOR_GREEN)
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0], $COLOR_RED)
Else
$expRet = StringSplit($res[0], "|", $STR_NOCOUNT)
$posPoint = StringSplit($expRet[1], ",", $STR_NOCOUNT)
$LootCartX = Int($posPoint[0])
$LootCartY = Int($posPoint[1])
If $LootCartX > 80 Then
If $DebugSetlog Then SetLog("LootCart found (" & $LootCartX & "," & $LootCartY & ")", $COLOR_GREEN)
If IsMainPage() Then Click($LootCartX, $LootCartY, 1, 0, "#0330")
If _Sleep($iDelayCollect1) Then Return
Local $sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep($iDelayCollect1) Then Return
$CountGetInfo += 1
If $CountGetInfo >= 5 Then Return
WEnd
If $DebugSetlog Then SetLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Loot") = 0 Then
If $DebugSetlog Then SetLog("Bad Loot Cart location", $COLOR_ORANGE)
Else
If IsMainPage() Then Click($aLootCartBtn[0], $aLootCartBtn[1], 1, 0, "#0331")
EndIf
EndIf
EndIf
EndIf
EndIf
VillageReport(True, True)
$tempCounter = 0
While ($iGoldCurrent = "" Or $iElixirCurrent = "" Or ($iDarkCurrent = "" And $iDarkStart <> "")) And $tempCounter < 3
$tempCounter += 1
VillageReport(True, True)
WEnd
If $tempGold <> "" And $iGoldCurrent <> "" Then
$tempGoldCollected = $iGoldCurrent - $tempGold
$iGoldFromMines += $tempGoldCollected
$iGoldTotal += $tempGoldCollected
EndIf
If $tempElixir <> "" And $iElixirCurrent <> "" Then
$tempElixirCollected = $iElixirCurrent - $tempElixir
$iElixirFromCollectors += $tempElixirCollected
$iElixirTotal += $tempElixirCollected
EndIf
If $tempDElixir <> "" And $iDarkCurrent <> "" Then
$tempDElixirCollected = $iDarkCurrent - $tempDElixir
$iDElixirFromDrills += $tempDElixirCollected
$iDarkTotal += $tempDElixirCollected
EndIf
UpdateStats()
EndFunc
Global $DonationWindowY
Func DonateCC($Check = False)
Local $bDonateTroop = BitOR($iChkDonateBarbarians, $iChkDonateArchers, $iChkDonateGiants, $iChkDonateGoblins,  $iChkDonateWallBreakers, $iChkDonateBalloons, $iChkDonateWizards, $iChkDonateHealers,  $iChkDonateDragons, $iChkDonatePekkas, $iChkDonateBabyDragons, $iChkDonateMiners, $iChkDonateMinions, $iChkDonateHogRiders,  $iChkDonateValkyries, $iChkDonateGolems, $iChkDonateWitches, $iChkDonateLavaHounds, $iChkDonateBowlers, $iChkDonateCustomA, $iChkDonateCustomB)
Local $bDonateAllTroop = BitOR($iChkDonateAllBarbarians, $iChkDonateAllArchers, $iChkDonateAllGiants, $iChkDonateAllGoblins,  $iChkDonateAllWallBreakers, $iChkDonateAllBalloons, $iChkDonateAllWizards, $iChkDonateAllHealers,  $iChkDonateAllDragons, $iChkDonateAllPekkas, $iChkDonateAllBabyDragons, $iChkDonateAllMiners, $iChkDonateAllMinions, $iChkDonateAllHogRiders,  $iChkDonateAllValkyries, $iChkDonateAllGolems, $iChkDonateAllWitches, $iChkDonateAllLavaHounds, $iChkDonateAllBowlers, $iChkDonateAllCustomA, $iChkDonateAllCustomB)
Local $bDonateSpell = BitOR($iChkDonatePoisonSpells, $iChkDonateEarthQuakeSpells, $iChkDonateHasteSpells, $iChkDonateSkeletonSpells)
Local $bDonateAllSpell = BitOR($iChkDonateAllPoisonSpells, $iChkDonateAllEarthQuakeSpells, $iChkDonateAllHasteSpells, $iChkDonateAllSkeletonSpells)
Local $bOpen = True, $bClose = False
Global $bDonate = BitOR($bDonateTroop, $bDonateAllTroop, $bDonateSpell, $bDonateAllSpell)
Global $iTotalDonateCapacity, $iTotalDonateSpellCapacity
Global $iDonTroopsLimit = 8, $iDonSpellsLimit = 1, $iDonTroopsAv = 0, $iDonSpellsAv = 0
Global $iDonTroopsQuantityAv = 0, $iDonTroopsQuantity = 0, $iDonSpellsQuantityAv = 0, $iDonSpellsQuantity = 0
Global $bSkipDonTroops = False, $bSkipDonSpells = False
Global $bDonateAllRespectBlk = False
Local $ReturnT = ($CurCamp >= ($TotalCamp * $fulltroop / 100) * .95) ? (True) : (False)
Local $ClanString = ""
If $bDonate = False Or $bDonationEnabled = False Then
If $debugsetlog = 1 Then Setlog("Donate Clan Castle troops skip", $COLOR_DEBUG)
Return
EndIf
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $iPlannedDonateHours[$hour[0]] = 0 And $iPlannedDonateHoursEnable = 1 Then
If $debugsetlog = 1 Then SetLog("Donate Clan Castle troops not planned, Skipped..", $COLOR_DEBUG)
Return
EndIf
Local $y = 90
If $Check = True Then
If _ColorCheck(_GetPixelColor(26, 312 + $midOffsetY, True), Hex(0xf00810, 6), 20) = False And $CommandStop <> 3 Then
Return
EndIf
EndIf
ClickP($aAway, 1, 0, "#0167")
Setlog("Checking for Donate Requests in Clan Chat", $COLOR_BLUE)
ForceCaptureRegion()
If _CheckPixel($aChatTab, $bCapturePixel) = False Then ClickP($aOpenChat, 1, 0, "#0168")
If _Sleep($iDelayDonateCC4) Then Return
Local $icount = 0
While 1
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x706C50, 6), 20) = True Then
ExitLoop
EndIf
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x383828, 6), 20) = True Then
If _Sleep($iDelayDonateCC1) Then Return
ClickP($aClanTab, 1, 0, "#0169")
ExitLoop
EndIf
$icount += 1
If $icount >= 15 Then
SetLog("Clan Chat Did Not Open - Abandon Donate")
Return
EndIf
If _Sleep($iDelayDonateCC1) Then Return
WEnd
Local $Scroll
While 1
ForceCaptureRegion()
$y = 90
$Scroll = _PixelSearch(293, 8 + $y, 295, 23 + $y, Hex(0xFFFFFF, 6), 20)
If IsArray($Scroll) And _ColorCheck(_GetPixelColor(300, 110, True), Hex(0x509808, 6), 20) = True Then
$bDonate = True
Click($Scroll[0], $Scroll[1], 1, 0, "#0172")
$y = 90
If _Sleep($iDelayDonateCC2 + 100) Then ExitLoop
ContinueLoop
EndIf
ExitLoop
WEnd
While $bDonate
checkAttackDisable($iTaBChkIdle)
$ClanString = ""
If _Sleep($iDelayDonateCC2) Then ExitLoop
ForceCaptureRegion()
$DonatePixel = _MultiPixelSearch(202, $y, 224, 660 + $bottomOffsetY, 50, 1, Hex(0x98D057, 6), $aChatDonateBtnColors, 15)
If IsArray($DonatePixel) Then
If $debugsetlog = 1 Then Setlog("$DonatePixel: (" & $DonatePixel[0] & "," & $DonatePixel[1] & ")", $COLOR_DEBUG)
$bDonate = False
$bSkipDonTroops = False
$bSkipDonSpells = False
If $bDonateTroop Or $bDonateSpell Or $bDonateAllTroop Or $bDonateAllSpell Then
If $ichkExtraAlphabets = 1 Then
$ClanString = ""
$ClanString = getChatString(30, $DonatePixel[1] - 50, "coc-latin-cyr")
If $ClanString = "" Then
$ClanString = getChatString(30, $DonatePixel[1] - 36, "coc-latin-cyr")
Else
$ClanString &= " " & getChatString(30, $DonatePixel[1] - 36, "coc-latin-cyr")
EndIf
If $ClanString = "" Or $ClanString = " " Then
$ClanString = getChatString(30, $DonatePixel[1] - 23, "coc-latin-cyr")
Else
$ClanString &= " " & getChatString(30, $DonatePixel[1] - 23, "coc-latin-cyr")
EndIf
If _Sleep($iDelayDonateCC2) Then ExitLoop
Else
$ClanString = ""
$ClanString = getChatString(30, $DonatePixel[1] - 50, "coc-latinA")
If $ClanString = "" Then
$ClanString = getChatString(30, $DonatePixel[1] - 36, "coc-latinA")
Else
$ClanString &= " " & getChatString(30, $DonatePixel[1] - 36, "coc-latinA")
EndIf
If $ClanString = "" Or $ClanString = " " Then
$ClanString = getChatString(30, $DonatePixel[1] - 23, "coc-latinA")
Else
$ClanString &= " " & getChatString(30, $DonatePixel[1] - 23, "coc-latinA")
EndIf
If _Sleep($iDelayDonateCC2) Then ExitLoop
EndIf
If $ClanString = "" Or $ClanString = " " Then
SetLog("Unable to read Chat Request!", $COLOR_RED)
$bDonate = True
$y = $DonatePixel[1] + 50
ContinueLoop
Else
If $ichkExtraAlphabets = 1 Then
ClipPut($ClanString)
Local $tempClip = ClipGet()
SetLog("Chat Request: " & $tempClip)
Else
SetLog("Chat Request: " & $ClanString)
EndIf
EndIf
EndIf
RemainingCCcapacity()
If $CurTotalDarkSpell = 0 And $FirstStart And $bDonateSpell Then
SetLog("Getting total Spells Available To be ready for Donation...", $COLOR_BLUE)
Click($aCloseChat[0], $aCloseChat[1], 1, 0, "#0173")
If _Sleep(500) Then Return
OpenArmyWindow()
If _Sleep(250) Then Return
CheckExistentArmy("Spells")
CountNumberDarkSpells()
ClickP($aAway, 2, 0, "#0346")
If _Sleep(1000) Then Return
SetLog("Total DElixir Spells Available and can be donated : " & $CurTotalDarkSpell, $COLOR_BLUE)
ForceCaptureRegion()
If _CheckPixel($aChatTab, $bCapturePixel) = False Then ClickP($aOpenChat, 1, 0, "#0168")
If _Sleep($iDelayDonateCC4) Then Return
$icount = 0
While 1
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x706C50, 6), 20) = True Then ExitLoop
If _ColorCheck(_GetPixelColor(189, 24, True), Hex(0x383828, 6), 20) = True Then
If _Sleep($iDelayDonateCC1) Then Return
ClickP($aClanTab, 1, 0, "#0169")
ExitLoop
EndIf
$icount += 1
If $icount >= 15 Then
SetLog("Clan Chat Did Not Open - Abandon Donate")
Return
EndIf
If _Sleep($iDelayDonateCC1) Then Return
WEnd
While 1
ForceCaptureRegion()
$y = 90
$Scroll = _PixelSearch(293, 8 + $y, 295, 23 + $y, Hex(0xFFFFFF, 6), 20)
If IsArray($Scroll) And _ColorCheck(_GetPixelColor(300, 110, True), Hex(0x509808, 6), 20) = True Then
$bDonate = True
Click($Scroll[0], $Scroll[1], 1, 0, "#0172")
$y = 90
If _Sleep($iDelayDonateCC2 + 100) Then ExitLoop
ContinueLoop
EndIf
ExitLoop
WEnd
EndIf
If $iTotalDonateCapacity <= 0 Then
Setlog("Clan Castle troops are full, skip troop donation...", $COLOR_ORANGE)
$bSkipDonTroops = True
EndIf
If $iTotalDonateSpellCapacity = 0 Then
Setlog("Clan Castle spells are full, skip spell donation...", $COLOR_ORANGE)
$bSkipDonSpells = True
ElseIf $iTotalDonateSpellCapacity = -1 Then
If $debugsetlog = 1 Then Setlog("This CC cannot accept spells, skip spell donation...", $COLOR_DEBUG)
$bSkipDonSpells = True
ElseIf $CurTotalDarkSpell = 0 Then
If $debugsetlog = 1 Then Setlog("No spells available, skip spell donation...", $COLOR_DEBUG)
Setlog("No spells available, skip spell donation...", $COLOR_ORANGE)
$bSkipDonSpells = True
EndIf
If $bSkipDonTroops And $bSkipDonSpells Then
$bDonate = True
$y = $DonatePixel[1] + 50
ContinueLoop
EndIf
If _Sleep(1000) Then Return
If ($bSkipDonTroops = True And $bSkipDonSpells = True) Or DonateWindow($bOpen) = False Then
$bDonate = True
$y = $DonatePixel[1] + 50
SetLog("Donate Window did not open - Exiting Donate", $COLOR_RED)
ExitLoop
EndIf
If $bDonateTroop Or $bDonateSpell Then
If $debugsetlog = 1 Then Setlog("Troop/Spell checkpoint.", $COLOR_DEBUG)
DonateWindowCap($bSkipDonTroops, $bSkipDonSpells)
If $bSkipDonTroops And $bSkipDonSpells Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
If $bDonateTroop = 1 And $bSkipDonTroops = False Then
If $debugsetlog = 1 Then Setlog("Troop checkpoint.", $COLOR_DEBUG)
If $iChkDonateCustomA = 1 And CheckDonateTroop(19, $aDonCustomA, $aBlkCustomA, $aBlackList, $ClanString) Then
For $i = 0 To 2
If $varDonateCustomA[$i][0] < $eBarb Then
$varDonateCustomA[$i][0] = $eArch
ElseIf $varDonateCustomA[$i][0] > $eBowl Then
ContinueLoop
EndIf
If $varDonateCustomA[$i][1] < 1 Then
ContinueLoop
ElseIf $varDonateCustomA[$i][1] > 8 Then
$varDonateCustomA[$i][1] = 8
EndIf
DonateTroopType($varDonateCustomA[$i][0], $varDonateCustomA[$i][1], $iChkDonateCustomA)
Next
EndIf
If $iChkDonateCustomB = 1 And CheckDonateTroop(19, $aDonCustomB, $aBlkCustomB, $aBlackList, $ClanString) Then
For $i = 0 To 2
If $varDonateCustomB[$i][0] < $eBarb Then
$varDonateCustomB[$i][0] = $eArch
ElseIf $varDonateCustomB[$i][0] > $eBowl Then
ContinueLoop
EndIf
If $varDonateCustomB[$i][1] < 1 Then
ContinueLoop
ElseIf $varDonateCustomB[$i][1] > 8 Then
$varDonateCustomB[$i][1] = 8
EndIf
DonateTroopType($varDonateCustomB[$i][0], $varDonateCustomB[$i][1], $iChkDonateCustomB)
Next
EndIf
If $iChkDonateLavaHounds = 1 And $bSkipDonTroops = False And CheckDonateTroop($eLava, $aDonLavaHounds, $aBlkLavaHounds, $aBlackList, $ClanString) Then DonateTroopType($eLava)
If $iChkDonateGolems = 1 And $bSkipDonTroops = False And CheckDonateTroop($eGole, $aDonGolems, $aBlkGolems, $aBlackList, $ClanString) Then DonateTroopType($eGole)
If $iChkDonatePekkas = 1 And $bSkipDonTroops = False And CheckDonateTroop($ePekk, $aDonPekkas, $aBlkPekkas, $aBlackList, $ClanString) Then DonateTroopType($ePekk)
If $iChkDonateDragons = 1 And $bSkipDonTroops = False And CheckDonateTroop($eDrag, $aDonDragons, $aBlkDragons, $aBlackList, $ClanString) Then DonateTroopType($eDrag)
If $iChkDonateWitches = 1 And $bSkipDonTroops = False And CheckDonateTroop($eWitc, $aDonWitches, $aBlkWitches, $aBlackList, $ClanString) Then DonateTroopType($eWitc)
If $iChkDonateHealers = 1 And $bSkipDonTroops = False And CheckDonateTroop($eHeal, $aDonHealers, $aBlkHealers, $aBlackList, $ClanString) Then DonateTroopType($eHeal)
If $iChkDonateBabyDragons = 1 And $bSkipDonTroops = False And CheckDonateTroop($eBabyD, $aDonBabyDragons, $aBlkBabyDragons, $aBlackList, $ClanString) Then DonateTroopType($eBabyD)
If $iChkDonateValkyries = 1 And $bSkipDonTroops = False And CheckDonateTroop($eValk, $aDonValkyries, $aBlkValkyries, $aBlackList, $ClanString) Then DonateTroopType($eValk)
If $iChkDonateBowlers = 1 And $bSkipDonTroops = False And CheckDonateTroop($eBowl, $aDonBowlers, $aBlkBowlers, $aBlackList, $ClanString) Then DonateTroopType($eBowl)
If $iChkDonateMiners = 1 And $bSkipDonTroops = False And CheckDonateTroop($eMine, $aDonMiners, $aBlkMiners, $aBlackList, $ClanString) Then DonateTroopType($eMine)
If $iChkDonateGiants = 1 And $bSkipDonTroops = False And CheckDonateTroop($eGiant, $aDonGiants, $aBlkGiants, $aBlackList, $ClanString) Then DonateTroopType($eGiant)
If $iChkDonateBalloons = 1 And $bSkipDonTroops = False And CheckDonateTroop($eBall, $aDonBalloons, $aBlkBalloons, $aBlackList, $ClanString) Then DonateTroopType($eBall)
If $iChkDonateHogRiders = 1 And $bSkipDonTroops = False And CheckDonateTroop($eHogs, $aDonHogRiders, $aBlkHogRiders, $aBlackList, $ClanString) Then DonateTroopType($eHogs)
If $iChkDonateWizards = 1 And $bSkipDonTroops = False And CheckDonateTroop($eWiza, $aDonWizards, $aBlkWizards, $aBlackList, $ClanString) Then DonateTroopType($eWiza)
If $iChkDonateWallBreakers = 1 And $bSkipDonTroops = False And CheckDonateTroop($eWall, $aDonWallBreakers, $aBlkWallBreakers, $aBlackList, $ClanString) Then DonateTroopType($eWall)
If $iChkDonateMinions = 1 And $bSkipDonTroops = False And CheckDonateTroop($eMini, $aDonMinions, $aBlkMinions, $aBlackList, $ClanString) Then DonateTroopType($eMini)
If $iChkDonateArchers = 1 And $bSkipDonTroops = False And CheckDonateTroop($eArch, $aDonArchers, $aBlkArchers, $aBlackList, $ClanString) Then DonateTroopType($eArch)
If $iChkDonateBarbarians = 1 And $bSkipDonTroops = False And CheckDonateTroop($eBarb, $aDonBarbarians, $aBlkBarbarians, $aBlackList, $ClanString) Then DonateTroopType($eBarb)
If $iChkDonateGoblins = 1 And $bSkipDonTroops = False And CheckDonateTroop($eGobl, $aDonGoblins, $aBlkGoblins, $aBlackList, $ClanString) Then DonateTroopType($eGobl)
EndIf
If $bDonateSpell = 1 And $bSkipDonSpells = False Then
If $debugsetlog = 1 Then Setlog("Spell checkpoint.", $COLOR_DEBUG)
If $iChkDonatePoisonSpells = 1 And $bSkipDonSpells = False And CheckDonateTroop($ePSpell, $aDonPoisonSpells, $aBlkPoisonSpells, $aBlackList, $ClanString) Then DonateTroopType($ePSpell)
If $iChkDonateEarthQuakeSpells = 1 And $bSkipDonSpells = False And CheckDonateTroop($eESpell, $aDonEarthQuakeSpells, $aBlkEarthQuakeSpells, $aBlackList, $ClanString) Then DonateTroopType($eESpell)
If $iChkDonateHasteSpells = 1 And $bSkipDonSpells = False And CheckDonateTroop($eHaSpell, $aDonHasteSpells, $aBlkHasteSpells, $aBlackList, $ClanString) Then DonateTroopType($eHaSpell)
If $iChkDonateSkeletonSpells = 1 And $bSkipDonSpells = False And CheckDonateTroop($eSkSpell, $aDonSkeletonSpells, $aBlkSkeletonSpells, $aBlackList, $ClanString) Then DonateTroopType($eSkSpell)
EndIf
EndIf
If $bDonateAllTroop Or $bDonateAllSpell Then
If $debugsetlog = 1 Then Setlog("Troop/Spell All checkpoint.", $COLOR_DEBUG)
$bDonateAllRespectBlk = True
DonateWindowCap($bSkipDonTroops, $bSkipDonSpells)
If $bSkipDonTroops And $bSkipDonSpells Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
If $bDonateAllTroop And $bSkipDonTroops = False Then
If $debugsetlog = 1 Then Setlog("Troop All checkpoint.", $COLOR_DEBUG)
Select
Case $iChkDonateAllCustomA = 1
For $i = 0 To 2
If $varDonateCustomA[$i][0] < $eBarb Then
$varDonateCustomA[$i][0] = $eArch
ElseIf $varDonateCustomA[$i][0] > $eBowl Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
If $varDonateCustomA[$i][1] < 1 Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
ElseIf $varDonateCustomA[$i][1] > 8 Then
$varDonateCustomA[$i][1] = 8
EndIf
DonateTroopType($varDonateCustomA[$i][0], $varDonateCustomA[$i][1], $iChkDonateAllCustomA, $bDonateAllTroop)
Next
Case $iChkDonateAllCustomB = 1
For $i = 0 To 2
If $varDonateCustomB[$i][0] < $eBarb Then
$varDonateCustomB[$i][0] = $eArch
ElseIf $varDonateCustomB[$i][0] > $eBowl Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
If $varDonateCustomB[$i][1] < 1 Then
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
ElseIf $varDonateCustomB[$i][1] > 8 Then
$varDonateCustomB[$i][1] = 8
EndIf
DonateTroopType($varDonateCustomB[$i][0], $varDonateCustomB[$i][1], $iChkDonateAllCustomB, $bDonateAllTroop)
Next
Case $iChkDonateAllLavaHounds = 1
If CheckDonateTroop($eLava, $aDonLavaHounds, $aBlkLavaHounds, $aBlackList, $ClanString) Then DonateTroopType($eLava, 0, False, $bDonateAllTroop)
Case $iChkDonateAllGolems = 1
If CheckDonateTroop($eGole, $aDonGolems, $aBlkGolems, $aBlackList, $ClanString) Then DonateTroopType($eGole, 0, False, $bDonateAllTroop)
Case $iChkDonateAllPekkas = 1
If CheckDonateTroop($ePekk, $aDonPekkas, $aBlkPekkas, $aBlackList, $ClanString) Then DonateTroopType($ePekk, 0, False, $bDonateAllTroop)
Case $iChkDonateAllDragons = 1
If CheckDonateTroop($eDrag, $aDonDragons, $aBlkDragons, $aBlackList, $ClanString) Then DonateTroopType($eDrag, 0, False, $bDonateAllTroop)
Case $iChkDonateAllWitches = 1
If CheckDonateTroop($eWitc, $aDonWitches, $aBlkWitches, $aBlackList, $ClanString) Then DonateTroopType($eWitc, 0, False, $bDonateAllTroop)
Case $iChkDonateAllHealers = 1
If CheckDonateTroop($eHeal, $aDonHealers, $aBlkHealers, $aBlackList, $ClanString) Then DonateTroopType($eHeal, 0, False, $bDonateAllTroop)
Case $iChkDonateAllBabyDragons = 1
If CheckDonateTroop($eBabyD, $aDonBabyDragons, $aBlkBabyDragons, $aBlackList, $ClanString) Then DonateTroopType($eBabyD, 0, False, $bDonateAllTroop)
Case $iChkDonateAllValkyries = 1
If CheckDonateTroop($eValk, $aDonValkyries, $aBlkValkyries, $aBlackList, $ClanString) Then DonateTroopType($eValk, 0, False, $bDonateAllTroop)
Case $iChkDonateAllBowlers = 1
If CheckDonateTroop($eBowl, $aDonBowlers, $aBlkBowlers, $aBlackList, $ClanString) Then DonateTroopType($eBowl, 0, False, $bDonateAllTroop)
Case $iChkDonateAllMiners = 1
If CheckDonateTroop($eMine, $aDonMiners, $aBlkMiners, $aBlackList, $ClanString) Then DonateTroopType($eMine, 0, False, $bDonateAllTroop)
Case $iChkDonateAllGiants = 1
If CheckDonateTroop($eGiant, $aDonGiants, $aBlkGiants, $aBlackList, $ClanString) Then DonateTroopType($eGiant, 0, False, $bDonateAllTroop)
Case $iChkDonateAllBalloons = 1
If CheckDonateTroop($eBall, $aDonBalloons, $aBlkBalloons, $aBlackList, $ClanString) Then DonateTroopType($eBall, 0, False, $bDonateAllTroop)
Case $iChkDonateAllHogRiders = 1
If CheckDonateTroop($eHogs, $aDonHogRiders, $aBlkHogRiders, $aBlackList, $ClanString) Then DonateTroopType($eHogs, 0, False, $bDonateAllTroop)
Case $iChkDonateAllWizards = 1
If CheckDonateTroop($eWiza, $aDonWizards, $aBlkWizards, $aBlackList, $ClanString) Then DonateTroopType($eWiza, 0, False, $bDonateAllTroop)
Case $iChkDonateAllWallBreakers = 1
If CheckDonateTroop($eWall, $aDonWallBreakers, $aBlkWallBreakers, $aBlackList, $ClanString) Then DonateTroopType($eWall, 0, False, $bDonateAllTroop)
Case $iChkDonateAllMinions = 1
If CheckDonateTroop($eMini, $aDonMinions, $aBlkMinions, $aBlackList, $ClanString) Then DonateTroopType($eMini, 0, False, $bDonateAllTroop)
Case $iChkDonateAllBarbarians = 1
If CheckDonateTroop($eBarb, $aDonBarbarians, $aBlkBarbarians, $aBlackList, $ClanString) Then DonateTroopType($eBarb, 0, False, $bDonateAllTroop)
Case $iChkDonateAllArchers = 1
If CheckDonateTroop($eArch, $aDonArchers, $aBlkArchers, $aBlackList, $ClanString) Then DonateTroopType($eArch, 0, False, $bDonateAllTroop)
Case $iChkDonateAllGoblins = 1
If CheckDonateTroop($eGobl, $aDonGoblins, $aBlkGoblins, $aBlackList, $ClanString) Then DonateTroopType($eGobl, 0, False, $bDonateAllTroop)
EndSelect
EndIf
If $bDonateAllSpell And $bSkipDonSpells = False Then
If $debugsetlog = 1 Then Setlog("Spell All checkpoint.", $COLOR_DEBUG)
Select
Case $iChkDonateAllPoisonSpells = 1
If CheckDonateTroop($ePSpell, $aDonPoisonSpells, $aBlkPoisonSpells, $aBlackList, $ClanString) Then DonateTroopType($ePSpell, 0, False, $bDonateAllSpell)
Case $iChkDonateAllEarthQuakeSpells = 1
If CheckDonateTroop($eESpell, $aDonEarthQuakeSpells, $aBlkEarthQuakeSpells, $aBlackList, $ClanString) Then DonateTroopType($eESpell, 0, False, $bDonateAllSpell)
Case $iChkDonateAllHasteSpells = 1
If CheckDonateTroop($eHaSpell, $aDonHasteSpells, $aBlkHasteSpells, $aBlackList, $ClanString) Then DonateTroopType($eHaSpell, 0, False, $bDonateAllSpell)
Case $iChkDonateAllSkeletonSpells = 1
If CheckDonateTroop($eSkSpell, $aDonSkeletonSpells, $aBlkSkeletonSpells, $aBlackList, $ClanString) Then DonateTroopType($eSkSpell, 0, False, $bDonateAllSpell)
EndSelect
EndIf
$bDonateAllRespectBlk = False
EndIf
DonateWindow($bClose)
$bDonate = True
$y = $DonatePixel[1] + 50
ClickP($aAway, 1, 0, "#0171")
If _Sleep($iDelayDonateCC2) Then ExitLoop
EndIf
ForceCaptureRegion()
$DonatePixel = _MultiPixelSearch(202, $y, 224, 660 + $bottomOffsetY, 50, 1, Hex(0x98D057, 6), $aChatDonateBtnColors, 15)
If IsArray($DonatePixel) Then
If $debugsetlog = 1 Then Setlog("More Donate buttons found, new $DonatePixel: (" & $DonatePixel[0] & "," & $DonatePixel[1] & ")", $COLOR_DEBUG)
ContinueLoop
Else
If $debugsetlog = 1 Then Setlog("No more Donate buttons found, closing chat ($y=" & $y & ")", $COLOR_DEBUG)
EndIf
ForceCaptureRegion()
$Scroll = _PixelSearch(293, 687 - 30, 295, 693 - 30, Hex(0xFFFFFF, 6), 20)
If IsArray($Scroll) Then
$bDonate = True
Click($Scroll[0], $Scroll[1], 1, 0, "#0172")
$y = 600
If _Sleep($iDelayDonateCC2) Then ExitLoop
ContinueLoop
EndIf
$bDonate = False
WEnd
ClickP($aAway, 1, 0, "#0176")
If _Sleep($iDelayDonateCC2) Then Return
$i = 0
While 1
If _Sleep(100) Then Return
If _ColorCheck(_GetPixelColor($aCloseChat[0], $aCloseChat[1], True), Hex($aCloseChat[2], 6), $aCloseChat[3]) Then
Click($aCloseChat[0], $aCloseChat[1], 1, 0, "#0173")
ExitLoop
Else
If _Sleep(100) Then Return
$i += 1
If $i > 30 Then
SetLog("Error finding Clan Tab to close...", $COLOR_RED)
ExitLoop
EndIf
EndIf
WEnd
If _Sleep($iDelayDonateCC2) Then Return
EndFunc
Func CheckDonateTroop($Type, $aDonTroop, $aBlkTroop, $aBlackList, $ClanString)
For $i = 1 To UBound($aBlackList) - 1
If CheckDonateString($aBlackList[$i], $ClanString) Then
SetLog("General Blacklist Keyword found: " & $aBlackList[$i], $COLOR_RED)
Return False
EndIf
Next
For $i = 1 To UBound($aBlkTroop) - 1
If CheckDonateString($aBlkTroop[$i], $ClanString) Then
If $Type = 19 Then
Setlog("Custom Blacklist Keyword found: " & $aBlkTroop[$i], $COLOR_RED)
Else
SetLog(NameOfTroop($Type) & " Blacklist Keyword found: " & $aBlkTroop[$i], $COLOR_RED)
EndIf
Return False
EndIf
Next
If $bDonateAllRespectBlk = False Then
For $i = 1 To UBound($aDonTroop) - 1
If CheckDonateString($aDonTroop[$i], $ClanString) Then
If $Type = 19 Then
Setlog("Custom Donation Keyword found: " & $aDonTroop[$i], $COLOR_GREEN)
Else
Setlog(NameOfTroop($Type) & " Keyword found: " & $aDonTroop[$i], $COLOR_GREEN)
EndIf
Return True
EndIf
Next
EndIf
If $bDonateAllRespectBlk = True then Return True
If $debugsetlog = 1 Then Setlog("Bad call of CheckDonateTroop:" & $Type & "=" & NameOfTroop($Type), $COLOR_DEBUG)
Return False
EndFunc
Func CheckDonateString($String, $ClanString)
Local $Contains = StringMid($String, 1, 1) & StringMid($String, StringLen($String), 1)
If $Contains = "[]" Then
If $ClanString = StringMid($String, 2, StringLen($String) - 2) Then
Return True
Else
Return False
EndIf
Else
If StringInStr($ClanString, $String, 2) Then
Return True
Else
Return False
EndIf
EndIf
EndFunc
Func DonateTroopType($Type, $Quant = 0, $Custom = False, $bDonateAll = False)
If $debugsetlog = 1 Then Setlog("$DonateTroopType Start: " & NameOfTroop($Type), $COLOR_DEBUG)
Local $Slot = -1, $YComp = 0, $sTextToAll = ""
Local $detectedSlot = -1
Local $donaterow = -1
Local $donateposinrow = -1
If $iTotalDonateCapacity = 0 And $iTotalDonateSpellCapacity = 0 Then Return
If $Type >= $eBarb And $Type <= $eBowl Then
For $i = 0 To UBound($TroopName) - 1
If Eval("e" & $TroopName[$i]) = $Type Then
$iDonTroopsQuantityAv = Floor($iTotalDonateCapacity / $TroopHeight[$i])
If $iDonTroopsQuantityAv < 1 Then
Setlog("Sorry Chief! " & NameOfTroop($Type, 1) & " don't fit in the remaining space!")
Return
EndIf
If $iDonTroopsQuantityAv >= $iDonTroopsLimit Then
$iDonTroopsQuantity = $iDonTroopsLimit
Else
$iDonTroopsQuantity = $iDonTroopsQuantityAv
EndIf
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $Type Then
$iDonTroopsQuantityAv = Floor($iTotalDonateCapacity / $TroopDarkHeight[$i])
If $iDonTroopsQuantityAv < 1 Then
Setlog("Sorry Chief! " & NameOfTroop($Type, 1) & " don't fit in the remaining space!")
Return
EndIf
If $iDonTroopsQuantityAv >= $iDonTroopsLimit Then
$iDonTroopsQuantity = $iDonTroopsLimit
Else
$iDonTroopsQuantity = $iDonTroopsQuantityAv
EndIf
EndIf
Next
EndIf
If $Type >= $ePSpell And $Type <= $eSkSpell Then
For $i = 0 To UBound($SpellName) - 1
If Eval("e" & $SpellName[$i]) = $Type Then
$iDonSpellsQuantityAv = Floor($iTotalDonateSpellCapacity / $SpellHeight[$i])
If $iDonSpellsQuantityAv < 1 Then
Setlog("Sorry Chief! " & NameOfTroop($Type, 1) & " don't fit in the remaining space!")
Return
EndIf
If $iDonSpellsQuantityAv >= $iDonSpellsLimit Then
$iDonSpellsQuantity = $iDonSpellsLimit
Else
$iDonSpellsQuantity = $iDonSpellsQuantityAv
EndIf
EndIf
Next
EndIf
If $debugOCRdonate = 1 Then
Local $oldDebugOcr = $debugOcr
$debugOcr = 1
EndIf
$Slot = DetectSlotTroop($Type)
$detectedSlot = $Slot
If $debugsetlog = 1 Then setlog("slot found = " & $Slot, $COLOR_DEBUG)
If $debugOCRdonate = 1 Then $debugOcr = $oldDebugOcr
If $Slot = -1 Then Return
$donaterow = 1
$donateposinrow = $Slot
If $Slot >= 6 And $Slot <= 11 Then
$donaterow = 2
$Slot = $Slot - 6
$donateposinrow = $Slot
$YComp = 88
EndIf
If $Slot >= 12 And $Slot <= 14 Then
$donaterow = 3
$Slot = $Slot - 12
$donateposinrow = $Slot
$YComp = 203
EndIf
If $YComp <> 203 Then
If _ColorCheck(_GetPixelColor(350 + ($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 + ($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 + ($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Local $plural = 0
If $Custom Then
If $Quant > 1 Then $plural = 1
If $bDonateAll Then $sTextToAll = " (to all requests)"
SetLog("Donating " & $Quant & " " & NameOfTroop($Type, $plural) & $sTextToAll, $COLOR_GREEN)
If $debugOCRdonate = 1 Then
Setlog("donate", $color_RED)
Setlog("row: " & $donaterow, $color_RED)
Setlog("pos in row: " & $donateposinrow, $color_red)
setlog("coordinate: " & 365 + ($Slot * 68) & "," & $DonationWindowY + 100 + $YComp, $color_red)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & NameOfTroop($Type) & "_")
EndIf
If $debugOCRdonate = 0 Then
If $ichkUseQTrain = 1 Then
$icount = 0
For $x = 0 To $Quant
If _ColorCheck(_GetPixelColor(350 + ($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 + ($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 + ($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 + ($Slot * 68), $DonationWindowY + 100 + $YComp, 1, $iDelayDonateCC3, "#0175")
If $CommandStop = 3 Then
$CommandStop = 0
$fullArmy = False
EndIf
If _Sleep(1000) Then Return
$icount += 1
EndIf
Next
$Quant = $icount
DonatedTroop($Type, $Quant)
Else
If _ColorCheck(_GetPixelColor(350 + ($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 + ($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 + ($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 + ($Slot * 68), $DonationWindowY + 100 + $YComp, $Quant, $iDelayDonateCC3, "#0175")
DonatedTroop($Type, $Quant)
If $CommandStop = 3 Then
$CommandStop = 0
$fullArmy = False
EndIf
EndIf
EndIf
If $Type >= $eBarb And $Type <= $eBowl Then
For $i = 0 To UBound($TroopName) - 1
If Eval("e" & $TroopName[$i]) = $Type Then
$iTotalDonateCapacity = $iTotalDonateCapacity - ($Quant * $TroopHeight[$i])
If $iDonTroopsLimit = $Quant Then
$bSkipDonTroops = True
EndIf
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $Type Then
$iTotalDonateCapacity = $iTotalDonateCapacity - ($Quant * $TroopDarkHeight[$i])
If $iDonTroopsLimit = $Quant Then
$bSkipDonTroops = True
EndIf
EndIf
Next
EndIf
EndIf
Else
If $iDonTroopsQuantity > 1 Then $plural = 1
If $debugOCRdonate = 1 Then
Setlog("donate", $color_RED)
Setlog("row: " & $donaterow, $color_RED)
Setlog("pos in row: " & $donateposinrow, $color_red)
setlog("coordinate: " & 365 + ($Slot * 68) & "," & $DonationWindowY + 100 + $YComp, $color_red)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & NameOfTroop($Type) & "_")
EndIf
If $debugOCRdonate = 0 Then
If $ichkUseQTrain = 1 Then
$icount = 0
For $x = 0 To $iDonTroopsQuantity
If _ColorCheck(_GetPixelColor(350 + ($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 + ($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 + ($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 + ($Slot * 68), $DonationWindowY + 100 + $YComp, 1, $iDelayDonateCC3, "#0175")
$icount += 1
If $CommandStop = 3 Then
$CommandStop = 0
$fullArmy = False
EndIf
If _Sleep(1000) Then Return
EndIf
Next
$iDonTroopsQuantity = $icount
DonatedTroop($Type, $iDonTroopsQuantity)
Else
If _ColorCheck(_GetPixelColor(350 + ($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(355 + ($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x306ca8, 6), 20) Or  _ColorCheck(_GetPixelColor(360 + ($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x306ca8, 6), 20) Then
Click(365 + ($Slot * 68), $DonationWindowY + 100 + $YComp, $iDonTroopsQuantity, $iDelayDonateCC3, "#0175")
DonatedTroop($Type, $iDonTroopsQuantity)
If $CommandStop = 3 Then
$CommandStop = 0
$fullArmy = False
EndIf
EndIf
EndIf
If $bDonateAll Then $sTextToAll = " (to all requests)"
SetLog("Donating " & $iDonTroopsQuantity & " " & NameOfTroop($Type, $plural) & $sTextToAll, $COLOR_GREEN)
If $Type >= $eBarb And $Type <= $eBowl Then
For $i = 0 To UBound($TroopName) - 1
If Eval("e" & $TroopName[$i]) = $Type Then
$iTotalDonateCapacity = $iTotalDonateCapacity - ($iDonTroopsQuantity * $TroopHeight[$i])
If $iDonTroopsLimit = $iDonTroopsQuantity Then
$bSkipDonTroops = True
EndIf
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $Type Then
$iTotalDonateCapacity = $iTotalDonateCapacity - ($iDonTroopsQuantity * $TroopDarkHeight[$i])
If $iDonTroopsLimit = $iDonTroopsQuantity Then
$bSkipDonTroops = True
EndIf
EndIf
Next
EndIf
EndIf
EndIf
$bDonate = True
If $Custom Then
For $i = 0 To UBound($TroopName) - 1
If Eval("e" & $TroopName[$i]) = $Type Then
Assign("Don" & $TroopName[$i], Eval("Don" & $TroopName[$i]) + $Quant)
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $Type Then
Assign("Don" & $TroopDarkName[$i], Eval("Don" & $TroopDarkName[$i]) + $Quant)
EndIf
Next
Else
For $i = 0 To UBound($TroopName) - 1
If Eval("e" & $TroopName[$i]) = $Type Then
Assign("Don" & $TroopName[$i], Eval("Don" & $TroopName[$i]) + $iDonTroopsQuantity)
EndIf
Next
For $i = 0 To UBound($TroopDarkName) - 1
If Eval("e" & $TroopDarkName[$i]) = $Type Then
Assign("Don" & $TroopDarkName[$i], Eval("Don" & $TroopDarkName[$i]) + $iDonTroopsQuantity)
EndIf
Next
EndIf
ElseIf $DonatePixel[1] - 5 + $YComp > 675 Then
Setlog("Unable to donate " & NameOfTroop($Type) & ". Donate screen not visible, will retry next run.", $COLOR_RED)
Else
SetLog("No " & NameOfTroop($Type) & " available to donate..", $COLOR_RED)
EndIf
Else
SetLog("Else Spells Condition Matched", $COLOR_ORANGE)
If _ColorCheck(_GetPixelColor(350 + ($Slot * 68), $DonationWindowY + 105 + $YComp, True), Hex(0x6038B0, 6), 20) Or  _ColorCheck(_GetPixelColor(355 + ($Slot * 68), $DonationWindowY + 106 + $YComp, True), Hex(0x6038B0, 6), 20) Or  _ColorCheck(_GetPixelColor(360 + ($Slot * 68), $DonationWindowY + 107 + $YComp, True), Hex(0x6038B0, 6), 20) Then
If $bDonateAll Then $sTextToAll = " (to all requests)"
If $debugOCRdonate = 1 Then
Setlog("donate", $color_RED)
Setlog("row: " & $donaterow, $color_RED)
Setlog("pos in row: " & $donateposinrow, $color_red)
setlog("coordinate: " & 365 + ($Slot * 68) & "," & $DonationWindowY + 100 + $YComp, $color_red)
debugimagesave("LiveDonateCC-r" & $donaterow & "-c" & $donateposinrow & "-" & NameOfTroop($Type) & "_")
EndIf
If $debugOCRdonate = 0 Then
Click(365 + ($Slot * 68), $DonationWindowY + 100 + $YComp, $iDonSpellsQuantity, $iDelayDonateCC3, "#0600")
$bFullArmySpells = False
$fullArmy = False
For $i = 0 To UBound($SpellName) - 1
If Eval("e" & $SpellName[$i]) = $Type Then
Assign("Don" & $SpellName[$i], Eval("Don" & $SpellName[$i]) + 1)
EndIf
Next
If $CommandStop = 3 Then
$CommandStop = 0
$bFullArmySpells = False
EndIf
DonatedSpell($Type, $iDonSpellsQuantity)
EndIf
$bDonate = True
ElseIf $DonatePixel[1] - 5 + $YComp > 675 Then
Setlog("Unable to donate " & NameOfTroop($Type) & ". Donate screen not visible, will retry next run.", $COLOR_RED)
Else
SetLog("No " & NameOfTroop($Type) & " available to donate..", $COLOR_RED)
EndIf
EndIf
EndFunc
Func DonateWindow($Open = True)
If $debugsetlog = 1 And $Open = True Then Setlog("DonateWindow Open Start", $COLOR_DEBUG)
If $debugsetlog = 1 And $Open = False Then Setlog("DonateWindow Close Start", $COLOR_DEBUG)
If $Open = False Then
ClickP($aAway, 1, 0, "#0176")
If _Sleep($iDelayDonateWindow1) Then Return
If $debugsetlog = 1 Then Setlog("DonateWindow Close Exit", $COLOR_DEBUG)
Return
EndIf
Local $iLeft = 0, $iTop = 0, $iRight = 0, $iBottom = 0, $i
For $i = 0 To UBound($aChatDonateBtnColors) - 1
If $aChatDonateBtnColors[$i][1] < $iLeft Then $iLeft = $aChatDonateBtnColors[$i][1]
If $aChatDonateBtnColors[$i][1] > $iRight Then $iRight = $aChatDonateBtnColors[$i][1]
If $aChatDonateBtnColors[$i][2] < $iTop Then $iTop = $aChatDonateBtnColors[$i][2]
If $aChatDonateBtnColors[$i][2] > $iBottom Then $iBottom = $aChatDonateBtnColors[$i][2]
Next
$iLeft += $DonatePixel[0]
$iTop += $DonatePixel[1]
$iRight += $DonatePixel[0] + 1
$iBottom += $DonatePixel[1] + 1
ForceCaptureRegion()
Local $DonatePixelCheck = _MultiPixelSearch($iLeft, $iTop, $iRight, $iBottom, 50, 1, Hex(0x98D057, 6), $aChatDonateBtnColors, 15)
If IsArray($DonatePixelCheck) Then
Click($DonatePixel[0] + 50, $DonatePixel[1] + 10, 1, 0, "#0174")
Else
If $debugsetlog = 1 Then SetLog("Could not find the Donate Button!", $COLOR_DEBUG)
Return False
EndIf
If _Sleep($iDelayDonateWindow1) Then Return
$icount = 0
While Not (_ColorCheck(_GetPixelColor(331, $DonatePixel[1], True), Hex(0xffffff, 6), 0))
If _Sleep($iDelayDonateWindow1) Then Return
$icount += 1
If $icount = 20 Then ExitLoop
WEnd
$DonationWindowY = 0
Local $aDonWinOffColors[2][3] = [[0xFFFFFF, 0, 2], [0xc7c5bc, 0, 209]]
Local $aDonationWindow = _MultiPixelSearch(409, 0, 410, $DEFAULT_HEIGHT, 1, 1, Hex(0xFFFFFF, 6), $aDonWinOffColors, 10)
If IsArray($aDonationWindow) Then
$DonationWindowY = $aDonationWindow[1]
If _Sleep($iDelayDonateWindow1) Then Return
If $debugsetlog = 1 Then Setlog("$DonationWindowY: " & $DonationWindowY, $COLOR_DEBUG)
Else
SetLog("Could not find the Donate Window!", $COLOR_RED)
Return False
EndIf
If $debugsetlog = 1 Then Setlog("DonateWindow Open Exit", $COLOR_DEBUG)
Return True
EndFunc
Func DonateWindowCap(ByRef $bSkipDonTroops, ByRef $bSkipDonSpells)
If $debugsetlog = 1 Then Setlog("DonateCapWindow Start", $COLOR_DEBUG)
If $bSkipDonTroops = False Then
Local $sReadCCTroopsCap = getCastleDonateCap(427, $DonationWindowY + 15)
If $debugsetlog = 1 Then Setlog("$sReadCCTroopsCap: " & $sReadCCTroopsCap, $COLOR_DEBUG)
Local $aTempReadCCTroopsCap = StringSplit($sReadCCTroopsCap, "#")
If $aTempReadCCTroopsCap[0] >= 2 Then
If $debugsetlog = 1 Then Setlog("$aTempReadCCTroopsCap splitted :" & $aTempReadCCTroopsCap[1] & "/" & $aTempReadCCTroopsCap[2], $COLOR_DEBUG)
If $aTempReadCCTroopsCap[2] > 0 Then
$iDonTroopsAv = $aTempReadCCTroopsCap[1]
$iDonTroopsLimit = $aTempReadCCTroopsCap[2]
EndIf
Else
Setlog("Error reading the Castle Troop Capacity...", $COLOR_RED)
$iDonTroopsAv = 0
$iDonTroopsLimit = 0
EndIf
EndIf
If $bSkipDonSpells = False Then
Local $sReadCCSpellsCap = getCastleDonateCap(420, $DonationWindowY + 220)
If $debugsetlog = 1 Then Setlog("$sReadCCSpellsCap: " & $sReadCCSpellsCap, $COLOR_DEBUG)
Local $aTempReadCCSpellsCap = StringSplit($sReadCCSpellsCap, "#")
If $aTempReadCCSpellsCap[0] >= 2 Then
If $debugsetlog = 1 Then Setlog("$aTempReadCCSpellsCap splitted :" & $aTempReadCCSpellsCap[1] & "/" & $aTempReadCCSpellsCap[2], $COLOR_DEBUG)
If $aTempReadCCSpellsCap[2] > 0 Then
$iDonSpellsAv = $aTempReadCCSpellsCap[1]
$iDonSpellsLimit = $aTempReadCCSpellsCap[2]
EndIf
Else
Setlog("Error reading the Castle Spells Capacity...", $COLOR_RED)
$iDonSpellsAv = 0
$iDonSpellsLimit = 0
EndIf
EndIf
If $iDonTroopsAv = $iDonTroopsLimit Then
$bSkipDonTroops = True
SetLog("Donate Troop Limit Reached")
EndIf
If $iDonSpellsAv = $iDonSpellsLimit Then
$bSkipDonSpells = True
SetLog("Donate Spell Limit Reached")
EndIf
If $bSkipDonTroops = True And $bSkipDonSpells = True And $iDonTroopsAv < $iDonTroopsLimit And $iDonSpellsAv < $iDonSpellsLimit Then
Setlog("Donate Troops: " & $iDonTroopsAv & "/" & $iDonTroopsLimit & ", Spells: " & $iDonSpellsAv & "/" & $iDonSpellsLimit)
EndIf
If $bSkipDonSpells = False And $iDonTroopsAv < $iDonTroopsLimit And $iDonSpellsAv = $iDonSpellsLimit Then Setlog("Donate Troops: " & $iDonTroopsAv & "/" & $iDonTroopsLimit)
If $bSkipDonTroops = False And $iDonTroopsAv = $iDonTroopsLimit And $iDonSpellsAv < $iDonSpellsLimit Then Setlog("Donate Spells: " & $iDonSpellsAv & "/" & $iDonSpellsLimit)
If $debugsetlog = 1 Then Setlog("$bSkipDonTroops: " & $bSkipDonTroops, $COLOR_DEBUG)
If $debugsetlog = 1 Then Setlog("$bSkipDonSpells: " & $bSkipDonSpells, $COLOR_DEBUG)
If $debugsetlog = 1 Then Setlog("DonateCapWindow End", $COLOR_DEBUG)
EndFunc
Func RemainingCCcapacity()
Local $aCapTroops = "", $aTempCapTroops = "", $aCapSpells = "", $aTempCapSpells
Local $iDonatedTroops = 0, $iDonatedSpells = 0
Local $iCapTroopsTotal = 0, $iCapSpellsTotal = 0
$iTotalDonateCapacity = -1
$iTotalDonateSpellCapacity = -1
If $debugsetlog = 1 Then Setlog("Started dual getOcrSpaceCastleDonate", $COLOR_DEBUG)
$aCapTroops = getOcrSpaceCastleDonate(49, $DonatePixel[1])
$aCapSpells = getOcrSpaceCastleDonate(154, $DonatePixel[1])
If $debugsetlog = 1 Then Setlog("$aCapTroops :" & $aCapTroops, $COLOR_DEBUG)
If $debugsetlog = 1 Then Setlog("$aCapSpells :" & $aCapSpells, $COLOR_DEBUG)
If Not (StringInStr($aCapTroops, "#") Or StringInStr($aCapSpells, "#")) Then
If $debugsetlog = 1 Then Setlog("Started single getOcrSpaceCastleDonate", $COLOR_DEBUG)
$aCapTroops = getOcrSpaceCastleDonate(78, $DonatePixel[1])
If $debugsetlog = 1 Then Setlog("$aCapTroops :" & $aCapTroops, $COLOR_DEBUG)
$aCapSpells = -1
EndIf
If $aCapTroops <> "" Then
$aTempCapTroops = StringSplit($aCapTroops, "#")
If $aTempCapTroops[0] >= 2 Then
If $debugsetlog = 1 Then Setlog("$aTempCapTroops splitted :" & $aTempCapTroops[1] & "/" & $aTempCapTroops[2], $COLOR_DEBUG)
If $aTempCapTroops[2] >= 0 Then
$iDonatedTroops = $aTempCapTroops[1]
$iCapTroopsTotal = $aTempCapTroops[2]
If $iCapTroopsTotal = 0 Then
$iCapTroopsTotal = 30
EndIf
If $iCapTroopsTotal = 5 Then
$iCapTroopsTotal = 35
EndIf
EndIf
Else
Setlog("Error reading the Castle Troop Capacity...", $COLOR_RED)
$iDonatedTroops = 0
$iCapTroopsTotal = 0
EndIf
Else
Setlog("Error reading the Castle Troop Capacity...", $COLOR_RED)
$iDonatedTroops = 0
$iCapTroopsTotal = 0
EndIf
If $aCapSpells <> -1 Then
If $aCapSpells <> "" Then
$aTempCapSpells = StringSplit($aCapSpells, "#")
If $aTempCapSpells[0] >= 2 Then
If $debugsetlog = 1 Then Setlog("$aTempCapSpells splitted :" & $aTempCapSpells[1] & "/" & $aTempCapSpells[2], $COLOR_DEBUG)
If $aTempCapSpells[2] > 0 Then
$iDonatedSpells = $aTempCapSpells[1]
$iCapSpellsTotal = $aTempCapSpells[2]
EndIf
Else
Setlog("Error reading the Castle Spell Capacity...", $COLOR_RED)
$iDonatedSpells = 0
$iCapSpellsTotal = 0
EndIf
Else
Setlog("Error reading the Castle Spell Capacity...", $COLOR_RED)
$iDonatedSpells = 0
$iCapSpellsTotal = 0
EndIf
EndIf
$iTotalDonateCapacity = ($iCapTroopsTotal - $iDonatedTroops)
If $aCapSpells <> -1 Then $iTotalDonateSpellCapacity = ($iCapSpellsTotal - $iDonatedSpells)
If $iTotalDonateCapacity < 0 Then
SetLog("Unable to read Castle Capacity!", $COLOR_RED)
Else
If $aCapSpells <> -1 Then
SetLog("Chat Troops: " & $iDonatedTroops & "/" & $iCapTroopsTotal & ", Spells: " & $iDonatedSpells & "/" & $iCapSpellsTotal)
Else
SetLog("Chat Troops: " & $iDonatedTroops & "/" & $iCapTroopsTotal)
EndIf
EndIf
EndFunc
Func DetectSlotTroop($Type)
Local $FullTemp
If $Type >= $eBarb And $Type <= $eBowl Then
For $Slot = 0 To 5
$FullTemp = getOcrDonationTroopsDetection(343 + (68 * $Slot), $DonationWindowY + 37)
If $debugsetlog = 1 Then Setlog("Slot: " & $Slot & " getOcrDonationTroopsDetection returned >>" & $FullTemp & "<<", $COLOR_DEBUG)
If StringInStr($FullTemp & " ", "empty") > 0 Then ExitLoop
If $FullTemp <> "" Then
For $i = $eBarb To $eBowl
$sTmp = StringStripWS(StringLeft(NameOfTroop($i), 4), $STR_STRIPTRAILING)
If StringInStr($FullTemp & " ", $sTmp) > 0 Then
If $debugsetlog = 1 Then Setlog("Detected " & NameOfTroop($i), $COLOR_DEBUG)
If $Type = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eBowl Then
If $debugsetlog = 1 Then Setlog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
For $Slot = 6 To 11
$FullTemp = getOcrDonationTroopsDetection(343 + (68 * ($Slot - 6)), $DonationWindowY + 124)
If $debugsetlog = 1 Then Setlog("Slot: " & $Slot & " getOcrDonationTroopsDetection returned >>" & $FullTemp & "<<", $COLOR_DEBUG)
If StringInStr($FullTemp & " ", "empty") > 0 Then ExitLoop
If $FullTemp <> "" Then
For $i = $eBall To $eBowl
$sTmp = StringStripWS(StringLeft(NameOfTroop($i), 4), $STR_STRIPTRAILING)
If StringInStr($FullTemp & " ", $sTmp) > 0 Then
If $debugsetlog = 1 Then Setlog("Detected " & NameOfTroop($i), $COLOR_DEBUG)
If $Type = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eBowl Then
If $debugsetlog = 1 Then Setlog("Slot: " & $Slot & "Troop Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
EndIf
If $Type >= $ePSpell And $Type <= $eSkSpell Then
For $Slot = 12 To 16
$FullTemp = getOcrDonationTroopsDetection(343 + (68 * ($Slot - 12)), $DonationWindowY + 241)
If $debugsetlog = 1 Then Setlog("Slot: " & $Slot & " getOcrDonationTroopsDetection returned >>" & $FullTemp & "<<", $COLOR_DEBUG)
If StringInStr($FullTemp & " ", "empty") > 0 Then ExitLoop
If $FullTemp <> "" Then
For $i = $ePSpell To $eSkSpell
$sTmp = StringLeft(NameOfTroop($i), 4)
If StringInStr($FullTemp & " ", $sTmp) > 0 Then
If $debugsetlog = 1 Then Setlog("Detected " & NameOfTroop($i), $COLOR_DEBUG)
If $Type = $i Then Return $Slot
ExitLoop
EndIf
If $i = $eSkSpell Then
If $debugsetlog = 1 Then Setlog("Slot: " & $Slot & "Spell Detection Failed", $COLOR_DEBUG)
EndIf
Next
EndIf
Next
EndIf
Return -1
EndFunc
Func DropTrophy()
If $iChkTrophyRange = 1 Then
If $DebugSetlog = 1 Then SetLog("Drop Trophy START", $COLOR_DEBUG)
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If $DebugSetlog = 1 Then SetLog("Current Trophy Count: " & $iTrophyCurrent, $COLOR_DEBUG)
If Number($iTrophyCurrent) <= Number($iTxtMaxTrophy) Then Return
Local $bHaveTroops = False
For $i = 0 To UBound($aDTtroopsToBeUsed, 1) - 1
If $aDTtroopsToBeUsed[$i][1] > 0 Then
$bDisableDropTrophy = False
$bHaveTroops = True
If $DebugSetlog = 1 Then
SetLog("Drop Trophy Found " & StringFormat("%3s", $aDTtroopsToBeUsed[$i][1]) & " " & $aDTtroopsToBeUsed[$i][0], $COLOR_DEBUG)
ContinueLoop
Else
ExitLoop
EndIf
EndIf
Next
If $iChkTrophyHeroes = 1 And $iHeroAvailable > 0 Then
If $DebugSetlog = 1 Then SetLog("Drop Trophy Found Hero BK|AQ|GW: " & BitOR($iHeroAvailable, $HERO_KING) & "|" & BitOR($iHeroAvailable, $HERO_QUEEN) & "|" & BitOR($iHeroAvailable, $HERO_WARDEN), $COLOR_DEBUG)
$bDisableDropTrophy = False
$bHaveTroops = True
EndIf
If $bDisableDropTrophy = True Or $bHaveTroops = False Then
Setlog("Drop Trophy temporarily disabled, missing proper troop type", $COLOR_ERROR)
If $DebugSetlog = 1 Then SetLog("Drop Trophy END: No troops in $aDTtroopsToBeUsed array", $COLOR_DEBUG)
Return
EndIf
Local $bDropSuccessful
Local $iCount, $aRandomEdge, $iRandomXY
Local Const $DTArmyPercent = Round(Int($itxtDTArmyMin) / 100, 2)
Local $iTxtMaxTrophyNeedCheck = $iTxtMaxTrophy
Local Const $iWaitTime = 3
Local $iDateCalc, $sWaitToDate
$sWaitToDate = _DateAdd('n', $iWaitTime, _NowCalc())
If $DebugSetlog = 1 Then SetLog("ChkBaseQuick delay time= " & $sWaitToDate & " Now= " & _NowCalc() & " Diff= " & _DateDiff('s', _NowCalc(), $sWaitToDate), $COLOR_DEBUG)
While Number($iTrophyCurrent) > Number($iTxtMaxTrophyNeedCheck)
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
SetLog("Trophy Count : " & $iTrophyCurrent, $COLOR_GREEN)
If Number($iTrophyCurrent) > Number($iTxtMaxTrophyNeedCheck) Then
Switch $iChkTrophyAtkDead
Case 1
If ($CurCamp <= ($TotalCamp * $DTArmyPercent)) Then
SetLog("Drop Trophy is waiting for " & $itxtDTArmyMin & "% full army to also attack Deadbases.", $COLOR_ORANGE)
If $DebugSetlog = 1 Then SetLog("Drop Trophy END: Drop Trophy + Dead Base skipped, army < " & $itxtDTArmyMin & "%.", $COLOR_DEBUG)
ExitLoop
EndIf
Case 0
If ($CurCamp < 5) And ($iChkTrophyHeroes = 1 And $iHeroAvailable = $HERO_NOHERO) Then
SetLog("No troops available to use on Drop Trophy", $COLOR_RED)
If $DebugSetlog = 1 Then SetLog("Drop Trophy END: Drop Trophy skipped, no army.", $COLOR_DEBUG)
ExitLoop
EndIf
EndSwitch
$iTxtMaxTrophyNeedCheck = $itxtdropTrophy
SetLog("Dropping Trophies to " & $itxtdropTrophy, $COLOR_BLUE)
If _Sleep($iDelayDropTrophy4) Then ExitLoop
$bDropSuccessful = True
ZoomOut()
PrepareSearch()
If $OutOfGold = 1 Then Return
If $Restart = True Then Return
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If $iChkTrophyAtkDead = 1 Then
$iAimGold[$DB] = $iMinGold[$DB]
$iAimElixir[$DB] = $iMinElixir[$DB]
$iAimGoldPlusElixir[$DB] = $iMinGoldPlusElixir[$DB]
$SearchCount = 0
GetResources(False, $DT)
SetLog("Identification of your troops:", $COLOR_BLUE)
PrepareAttack($DT)
If $Restart = True Then Return
Local $G = (Number($searchGold) >= Number($iAimGold[$DB]))
Local $E = (Number($searchElixir) >= Number($iAimElixir[$DB]))
Local $GPE = ((Number($searchElixir) + Number($searchGold)) >= Number($iAimGoldPlusElixir[$DB]))
If $G = True And $E = True And $GPE = True Then
SetLog("Found [G]:" & StringFormat("%7s", $searchGold) & " [E]:" & StringFormat("%7s", $searchElixir) & " [D]:" & StringFormat("%5s", $searchDark) & " [T]:" & StringFormat("%2s", $searchTrophy), $COLOR_BLACK, "Lucida Console", 7.5)
If checkDeadBase() Then
SetLog("      " & "Dead Base Found on Drop Trophy!", $COLOR_GREEN, "Lucida Console", 7.5)
Attack()
$FirstStart = True
ReturnHome($TakeLootSnapShot)
$Is_ClientSyncError = False
$Is_SearchLimit = False
$Restart = True
If $DebugSetlog = 1 Then SetLog("Drop Trophy END: Dead Base was attacked, reset army and return to Village.", $COLOR_DEBUG)
ExitLoop
Else
SetLog("      " & "Not a Dead Base, resuming Drop Trophy.", $COLOR_BLACK, "Lucida Console", 7.5)
EndIf
EndIf
Else
$SearchCount = 0
GetResources(False, $DT)
SetLog("Identification of your troops:", $COLOR_BLUE)
PrepareAttack($DT)
If $Restart = True Then Return
EndIf
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If $iChkTrophyHeroes = 1 Then
$King = -1
$Queen = -1
$Warden = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $eKing Then
$King = $i
ElseIf $atkTroops[$i][0] = $eQueen Then
$Queen = $i
ElseIf $atkTroops[$i][0] = $eWarden Then
$Warden = $i
EndIf
Next
$aRandomEdge = $Edges[Round(Random(0, 3))]
$iRandomXY = Round(Random(0, 4))
If $DebugSetlog = 1 Then Setlog("Hero Loc = " & $iRandomXY & ", X:Y= " & $aRandomEdge[$iRandomXY][0] & "|" & $aRandomEdge[$iRandomXY][1], $COLOR_DEBUG)
If $Warden <> -1 Then
SetTrophyLoss()
SetLog("Deploying Warden", $COLOR_BLUE)
Click(GetXPosOfArmySlot($Warden, 68), 595 + $bottomOffsetY, 1, 0, "#0000")
If _Sleep($iDelayDropTrophy1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0000")
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If IsAttackPage() Then SelectDropTroop($Warden)
ReturnHome(False, False)
If _Sleep($iDelayDropTrophy1) Then ExitLoop
EndIf
If $Warden = -1 And $Queen <> -1 Then
SetTrophyLoss()
SetLog("Deploying Queen", $COLOR_BLUE)
Click(GetXPosOfArmySlot($Queen, 68), 595 + $bottomOffsetY, 1, 0, "#0179")
If _Sleep($iDelayDropTrophy1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0180")
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If IsAttackPage() Then SelectDropTroop($Queen)
ReturnHome(False, False)
If _Sleep($iDelayDropTrophy1) Then ExitLoop
EndIf
If $Warden = -1 And $Queen = -1 And $King <> -1 Then
SetTrophyLoss()
SetLog("Deploying King", $COLOR_BLUE)
Click(GetXPosOfArmySlot($King, 68), 595 + $bottomOffsetY, 1, 0, "#0177")
If _Sleep($iDelayDropTrophy1) Then ExitLoop
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0178")
If _Sleep($iDelayDropTrophy4) Then ExitLoop
If IsAttackPage() Then SelectDropTroop($King)
ReturnHome(False, False)
If _Sleep($iDelayDropTrophy1) Then ExitLoop
EndIf
EndIf
If ($Queen = -1 And $King = -1 And $Warden = -1) Or $iChkTrophyHeroes = 0 Then
$aRandomEdge = $Edges[Round(Random(0, 3))]
$iRandomXY = Round(Random(0, 4))
If $DebugSetlog = 1 Then Setlog("Troop Loc = " & $iRandomXY & ", X:Y= " & $aRandomEdge[$iRandomXY][0] & "|" & $aRandomEdge[$iRandomXY][1], $COLOR_DEBUG)
Select
Case $atkTroops[0][0] = $eBarb
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0181")
$CurBarb += 1
SetLog("Deploying 1 Barbarian", $COLOR_BLUE)
Case $atkTroops[0][0] = $eArch
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0182")
$CurArch += 1
SetLog("Deploying 1 Archer", $COLOR_BLUE)
Case $atkTroops[0][0] = $eGiant
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0183")
$CurGiant += 1
SetLog("Deploying 1 Giant", $COLOR_BLUE)
Case $atkTroops[0][0] = $eWall
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0184")
$CurWall += 1
SetLog("Deploying 1 WallBreaker", $COLOR_BLUE)
Case $atkTroops[0][0] = $eGobl
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0185")
$CurGobl += 1
SetLog("Deploying 1 Goblin", $COLOR_BLUE)
Case $atkTroops[0][0] = $eMini
Click($aRandomEdge[$iRandomXY][0], $aRandomEdge[$iRandomXY][1], 1, 0, "#0186")
$CurMini += 1
SetLog("Deploying 1 Minion", $COLOR_BLUE)
Case Else
SetLog("You don´t have Tier 1/2 Troops, Stop dropping trophies.", $COLOR_BLUE)
$bDisableDropTrophy = True
$bDropSuccessful = False
ExitLoop
EndSelect
If $bDropSuccessful Then SetTrophyLoss()
If _Sleep($iDelayDropTrophy1) Then ExitLoop
ReturnHome(False, False)
If _Sleep($iDelayDropTrophy1) Then ExitLoop
EndIf
$iDateCalc = _DateDiff('s', _NowCalc(), $sWaitToDate)
If $DebugSetlog = 1 Then SetLog("ChkBaseQuick delay= " & $sWaitToDate & " Now= " & _NowCalc() & " Diff= " & $iDateCalc, $COLOR_DEBUG)
If $iDateCalc <= 0 Then
Setlog(" Checking base during long drop cycle", $COLOR_BLUE)
CheckBaseQuick()
$sWaitToDate = _DateAdd('n', $iWaitTime, _NowCalc())
If $DebugSetlog = 1 Then SetLog("ChkBaseQuick new delay time= " & $sWaitToDate, $COLOR_DEBUG)
EndIf
Else
SetLog("Trophy Drop Complete", $COLOR_BLUE)
EndIf
WEnd
If $DebugSetlog = 1 Then SetLog("Drop Trophy END", $COLOR_DEBUG)
Else
If $DebugSetlog = 1 Then SetLog("Drop Trophy SKIP", $COLOR_DEBUG)
EndIf
EndFunc
Func SetTrophyLoss()
Local $sTrophyLoss
If _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0a050a, 6), 10) or _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
$sTrophyLoss = getTrophyLossAttackScreen(48, 214)
Else
$sTrophyLoss = getTrophyLossAttackScreen(48, 184)
EndIf
Setlog(" Trophy loss = " & $sTrophyLoss, $COLOR_DEBUG)
$iDroppedTrophyCount -= Number($sTrophyLoss)
UpdateStats()
EndFunc
Func GetTownHallLevel($bFirstTime = False, $bClickAwayAtEnd = True)
Local $aTHInfo[3] = ["", "", ""]
If $debugSetlog = 1 Then SetLog("Town Hall Position: " & $TownHallPos[0] & ", " & $TownHallPos[1], $COLOR_DEBUG)
If isInsideDiamond($TownHallPos) = False Then
LocateTownHall(True)
If isInsideDiamond($TownHallPos) Then SaveConfig()
If _Sleep($iDelayGetTownHallLevel1) Then Return
EndIf
If $bFirstTime = True Then
Click($TownHallPos[0], $TownHallPos[1] + 5, 1, 0, "#0349")
If _Sleep($iDelayGetTownHallLevel2) Then Return
EndIf
If $debugImageSave = 1 Then DebugImageSave("GetTHLevelView")
$iTownHallLevel = 0
$aTHInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If $debugSetlog = 1 Then Setlog("$aTHInfo[0]=" & $aTHInfo[0] & ", $aTHInfo[1]=" & $aTHInfo[1] & ", $aTHInfo[2]=" & $aTHInfo[2], $COLOR_DEBUG)
If $aTHInfo[0] > 1 Then
If StringInStr($aTHInfo[1], "Town") = 0 Then
SetLog("Town Hall not found! I detected a " & $aTHInfo[1] & "! Please locate again!", $COLOR_Fuchsia)
Return $aTHInfo
EndIf
If $aTHInfo[2] <> "" Then
$iTownHallLevel = $aTHInfo[2]
SetLog("Your Town Hall Level read as: " & $iTownHallLevel, $COLOR_GREEN)
saveConfig()
Else
SetLog("Your Town Hall Level was not found! Please Manually Locate", $COLOR_BLUE)
ClickP($aAway, 1, 0, "#0350")
Return False
EndIf
Else
SetLog("Your Town Hall Level was not found! Please Manually Locate", $COLOR_BLUE)
ClickP($aAway, 1, 0, "#0351")
Return False
EndIf
If $bClickAwayAtEnd = True Then ClickP($aAway, 2, $iDelayGetTownHallLevel3, "#0352")
Return True
EndFunc
Func isDarkElixirFull()
If _CheckPixel($aIsDarkElixirFull, $bCapturePixel) Then
SetLog("Dark Elixir Storages is full!", $COLOR_GREEN)
Return True
EndIf
Return False
EndFunc
Func isGoldFull()
If _CheckPixel($aIsGoldFull, $bCapturePixel) Then
SetLog("Gold Storages are full!", $COLOR_GREEN)
Return True
EndIf
Return False
EndFunc
Func isElixirFull()
If _CheckPixel($aIsElixirFull, $bCapturePixel) Then
SetLog("Elixir Storages are full!", $COLOR_GREEN)
Return True
EndIf
Return False
EndFunc
Func LocateUpgrades()
WinGetAndroidHandle()
If $HWnD <> 0 And $AndroidBackgroundLaunched = True Then
Setlog("Reboot " & $Android & " for Window access", $COLOR_RED)
RebootAndroid(True)
EndIf
If $HWnD = 0 Then
Setlog($Android & " is not open", $COLOR_RED)
SetError(1)
Return
EndIf
AndroidShield("LocateUpgrades")
Local $hGraphic = AndroidGraphicsGdiBegin()
Local $hPen = AndroidGraphicsGdiAddObject("Pen", _GDIPlus_PenCreate(0xFFFFFF00, 2))
SetDebugLog("LocateUpgrades: $hGraphic=" & $hGraphic & ", $hPen=" & $hPen)
Local $wasDown = AndroidShieldForcedDown()
Setlog("Upgrade Buildings and Auto Wall Upgrade Can Not Use same Loot Type!", $COLOR_GREEN)
Local $MsgBox, $stext
Local $icount = 0
While 1
_CaptureRegion(0, 0, $DEFAULT_WIDTH, 2)
If _GetPixelColor(1, 1) <> Hex(0x000000, 6) Or _GetPixelColor(850, 1) <> Hex(0x000000, 6) Then
SetLog("Locate Oops, prep screen 1st", $COLOR_BLUE)
ZoomOut()
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
EndIf
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
For $icount = 0 To UBound($aUpgrades, 1) - 1
If $ichkUpgrdeRepeat[$icount] = 1 And (GUICtrlRead($txtUpgradeName[$icount]) <> "") Then
GUICtrlSetImage($picUpgradeStatus[$icount], $pIconLib, $eIcnYellowLight)
GUICtrlSetState($chkbxUpgrade[$icount], $GUI_CHECKED)
ContinueLoop
EndIf
AndroidShieldForceDown(True, True)
$stext = GetTranslated(640, 51, "Click 'Locate Building' button then click on your Building/Hero to upgrade.") & @CRLF & @CRLF & GetTranslated(640, 52, "Click 'Finished' button when done locating all upgrades.") & @CRLF & @CRLF & GetTranslated(640, 53, "Click on Cancel to exit finding buildings.") & @CRLF & @CRLF
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 10, "Comic Sans MS", 500)
$MsgBox = _ExtMsgBox(0, GetTranslated(640, 54, "Locate Building|Finished|Cancel"), GetTranslated(640, 55, "Locate Upgrades"), $stext, 0, $frmBot)
Switch $MsgBox
Case 1
Local $aPos = FindPos()
$aUpgrades[$icount][0] = $aPos[0]
$aUpgrades[$icount][1] = $aPos[1]
If isInsideDiamondXY($aUpgrades[$icount][0], $aUpgrades[$icount][1]) Then
Local $Result = _GDIPlus_GraphicsDrawEllipse($hGraphic, $aUpgrades[$icount][0] - 10, $aUpgrades[$icount][1] - 10, 20, 20, $hPen)
AndroidGraphicsGdiUpdate()
SetDebugLog("Updgrade #" & $icount & " added at " & $aUpgrades[$icount][0] & "/" & $aUpgrades[$icount][1] & ", marker drawn: " & $Result)
GUICtrlSetImage($picUpgradeStatus[$icount], $pIconLib, $eIcnYellowLight)
$ipicUpgradeStatus[$icount] = $eIcnYellowLight
_Sleep(750)
Else
Setlog("Bad location recorded, location skipped?", $COLOR_RED)
$aUpgrades[$icount][0] = -1
$aUpgrades[$icount][1] = -1
ContinueLoop
EndIf
Case 2
If $icount = 0 Then
Setlog("Locate Upgrade Cancelled", $COLOR_FUCHSIA)
btnResetUpgrade()
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
Return False
EndIf
ExitLoop
Case 3
Setlog("Locate Upgrade Cancelled", $COLOR_FUCHSIA)
btnResetUpgrade()
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
Return False
Case Else
Setlog("Impossible value (" & $MsgBox & ") from Msgbox, you have been a bad programmer!", $COLOR_DEBUG)
EndSwitch
ClickP($aAway, 1, 0, "#0210")
Next
ExitLoop
WEnd
AndroidGraphicsGdiEnd()
AndroidShieldForceDown($wasDown)
CheckUpgrades()
EndFunc
Func CheckUpgrades()
Local $MsgBox
If AndroidShielded() = False Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslated(640, 38, "Keep Mouse OUT of Android Emulator Window While I Check Your Upgrades, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslated(640, 36, "OK"), GetTranslated(640, 37, "Notice"), $stext, 15, $frmBot)
If _Sleep($iDelayCheckUpgrades1) Then Return
If $MsgBox <> 1 Then
Setlog("Something weird happened in getting upgrade values, try again", $COLOR_RED)
Return False
EndIf
EndIf
For $iz = 0 To UBound($aUpgrades, 1) - 1
If isInsideDiamondXY($aUpgrades[$iz][0], $aUpgrades[$iz][1]) = False Then
GUICtrlSetImage($picUpgradeStatus[$iz], $pIconLib, $eIcnRedLight)
GUICtrlSetState($chkbxUpgrade[$iz], $GUI_UNCHECKED)
If $ichkUpgrdeRepeat[$iz] = 1 Then GUICtrlSetState($chkUpgrdeRepeat[$iz], $GUI_UNCHECKED)
ContinueLoop
EndIf
If UpgradeValue($iz) = False Then
If $ichkUpgrdeRepeat[$iz] = 1 And $aUpgrades[$iz][4] <> "" Then ContinueLoop
Setlog("Locate Upgrade #" & $iz + 1 & " Value Error, try again", $COLOR_RED)
GUICtrlSetImage($picUpgradeStatus[$iz], $pIconLib, $eIcnRedLight)
GUICtrlSetData($txtUpgradeName[$iz], "")
GUICtrlSetData($txtUpgradeLevel[$iz], "")
GUICtrlSetData($txtUpgradeValue[$iz], "")
GUICtrlSetData($txtUpgradeTime[$iz], "")
GUICtrlSetData($txtUpgradeEndTime[$iz], "")
GUICtrlSetImage($picUpgradeType[$iz], $pIconLib, $eIcnBlank)
If $ichkUpgrdeRepeat[$iz] = 1 Then GUICtrlSetState($chkUpgrdeRepeat[$iz], $GUI_UNCHECKED)
ContinueLoop
EndIf
GUICtrlSetState($chkWalls, $GUI_UNCHECKED)
Next
EndFunc
Func UpgradeValue($inum, $bRepeat = False)
Local $inputbox, $iLoot, $aString, $aResult
Local $bOopsFlag = False
If $bRepeat = True Or $ichkUpgrdeRepeat[$inum] = 1 Then
ClickP($aAway, 1, 0, "#0999")
If _Sleep($iDelayUpgradeValue1) Then Return
Click($aUpgrades[$inum][0], $aUpgrades[$inum][1])
If _Sleep($iDelayUpgradeValue4) Then Return
If $bOopsFlag = True Then DebugImageSave("ButtonView")
If StringInStr($aUpgrades[$inum][4], "collect", $STR_NOCASESENSEBASIC) Or  StringInStr($aUpgrades[$inum][4], "mine", $STR_NOCASESENSEBASIC) Or  StringInStr($aUpgrades[$inum][4], "drill", $STR_NOCASESENSEBASIC) Then
ClickP($aAway, 1, 0, "#0999")
If _Sleep($iDelayUpgradeValue1) Then Return
Click($aUpgrades[$inum][0], $aUpgrades[$inum][1])
If _Sleep($iDelayUpgradeValue4) Then Return
EndIf
Local $offColors[3][3] = [[0x000000, 44, 17], [0xE07740, 69, 31], [0xF2F7F1, 81, 0]]
Global $ButtonPixel = _MultiPixelSearch(284, 572, 570, 615, 1, 1, Hex(0x000000, 6), $offColors, 25)
If $debugSetlog = 1 Then Setlog("Pixel Color #1: " & _GetPixelColor(389, 572, True) & ", #2: " & _GetPixelColor(433, 589, True) & ", #3: " & _GetPixelColor(458, 603, True) & ", #4: " & _GetPixelColor(470, 572, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Or $bOopsFlag = True Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Pixel Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 44, $ButtonPixel[1] + 17, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 69, $ButtonPixel[1] + 31, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 81, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Setlog("Selection #" & $inum + 1 & " Upgrade in process - Skipped!", $COLOR_MAROON)
ClickP($aAway, 1, 0, "#0999")
Return False
EndIf
Else
If $aUpgrades[$inum][0] <= 0 Or $aUpgrades[$inum][1] <= 0 Then Return False
$aUpgrades[$inum][2] = 0
GUICtrlSetData($txtUpgradeValue[$inum], "")
$aUpgrades[$inum][3] = ""
GUICtrlSetImage($picUpgradeType[$inum], $pIconLib, $eIcnBlank)
$aUpgrades[$inum][4] = ""
GUICtrlSetData($txtUpgradeName[$inum], "")
$aUpgrades[$inum][5] = ""
GUICtrlSetData($txtUpgradeLevel[$inum], "")
$aUpgrades[$inum][6] = ""
GUICtrlSetData($txtUpgradeTime[$inum], "")
$aUpgrades[$inum][7] = ""
GUICtrlSetData($txtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0211")
SetLog("-$Upgrade #" & $inum + 1 & " Location =  " & "(" & $aUpgrades[$inum][0] & "," & $aUpgrades[$inum][1] & ")", $COLOR_TEAL)
If _Sleep($iDelayUpgradeValue1) Then Return
Click($aUpgrades[$inum][0], $aUpgrades[$inum][1], 1, 0, "#0212")
If _Sleep($iDelayUpgradeValue2) Then Return
If $bOopsFlag = True Then DebugImageSave("ButtonView")
EndIf
If $bOopsFlag = True And $debugImageSave = 1 Then DebugImageSave("ButtonView")
$aResult = BuildingInfo(242, 520 + $bottomOffsetY)
If $aResult[0] > 1 Then
$aUpgrades[$inum][4] = $aResult[1]
$aUpgrades[$inum][5] = $aResult[2]
GUICtrlSetData($txtUpgradeName[$inum], $aUpgrades[$inum][4])
GUICtrlSetData($txtUpgradeLevel[$inum], $aUpgrades[$inum][5])
Else
Setlog("Error: Name & Level for Upgrade not found?", $COLOR_RED)
EndIf
Setlog("Upgrade Name = " & $aUpgrades[$inum][4] & ", Level = " & $aUpgrades[$inum][5], $COLOR_BLUE)
Local $offColors[3][3] = [[0xD6714B, 47, 37], [0xF0E850, 70, 0], [0xF4F8F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 620 + $bottomOffsetY, 1, 1, Hex(0xF3F3F1, 6), $offColors, 30)
If $debugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("GoldButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If IsArray($ButtonPixel) = 0 Then
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 620 + $bottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If $debugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ElixirButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 38, $ButtonPixel[1] + 32, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
EndIf
If IsArray($ButtonPixel) = 0 Then
Local $offColors[3][3] = [[0x9B4C28, 41, 23], [0x040009, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 620 + $bottomOffsetY, 1, 1, Hex(0xF6F9F3, 6), $offColors, 25)
If $debugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("HeroButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
EndIf
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Or $bOopsFlag = True Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("#1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0213")
If _Sleep($iDelayUpgradeValue3) Then Return
If $bOopsFlag = True And $debugImageSave = 1 Then DebugImageSave("UpgradeView")
_CaptureRegion()
Select
Case _ColorCheck(_GetPixelColor(677, 150 + $midOffsetY), Hex(0xE00408, 6), 20)
If _ColorCheck(_GetPixelColor(351, 485 + $midOffsetY), Hex(0xE0403D, 6), 20) Then
If $ichkUpgrdeRepeat[$inum] = 1 Then
Setlog("Selection #" & $inum + 1 & " can not repeat upgrade, need TH upgrade - Skipped!", $COLOR_RED)
$ichkUpgrdeRepeat[$inum] = 0
GUICtrlSetState($chkUpgrdeRepeat[$inum], $GUI_UNCHECKED)
Else
Setlog("Selection #" & $inum + 1 & " upgrade not available, need TH upgrade - Skipped!", $COLOR_RED)
EndIf
ClearUpgradeInfo($inum)
GUICtrlSetImage($picUpgradeType[$inum], $pIconLib, $eIcnRedLight)
GUICtrlSetImage($picUpgradeStatus[$inum], $pIconLib, $eIcnTroops)
$ichkbxUpgrade[$inum] = 0
GUICtrlSetState($chkbxUpgrade[$inum], $GUI_UNCHECKED)
$aUpgrades[$inum][7] = ""
GUICtrlSetData($txtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0214")
Return False
EndIf
If _ColorCheck(_GetPixelColor(477, 490 + $midOffsetY), Hex(0xF0E850, 6), 20) Then $aUpgrades[$inum][3] = "Gold"
If _ColorCheck(_GetPixelColor(483, 486 + $midOffsetY), Hex(0xF030D8, 6), 20) Then $aUpgrades[$inum][3] = "Elixir"
$aUpgrades[$inum][2] = Number(getResourcesBonus(366, 487 + $midOffsetY))
If $aUpgrades[$inum][2] = "" Then $aUpgrades[$inum][2] = Number(getUpgradeResource(366, 487 + $midOffsetY))
If $aUpgrades[$inum][2] = "" And $ichkUpgrdeRepeat[$inum] <> 1 Then $bOopsFlag = True
$aUpgrades[$inum][6] = getBldgUpgradeTime(196, 304 + $midOffsetY)
Setlog("Upgrade #" & $inum + 1 & " Time = " & $aUpgrades[$inum][6], $COLOR_BLUE)
If  $aUpgrades[$inum][6]  <> "" Then $aUpgrades[$inum][7] = ""
Case _ColorCheck(_GetPixelColor(719, 118 + $midOffsetY), Hex(0xDF0408, 6), 20)
If _ColorCheck(_GetPixelColor(400, 485 + $midOffsetY), Hex(0xE0403D, 6), 20) Then
If $ichkUpgrdeRepeat[$inum] = 1 Then
Setlog("Selection #" & $inum + 1 & " can not repeat upgrade, need TH upgrade - Skipped!", $COLOR_RED)
$ichkUpgrdeRepeat[$inum] = 0
GUICtrlSetState($chkUpgrdeRepeat[$inum], $GUI_UNCHECKED)
Else
Setlog("Selection #" & $inum + 1 & " upgrade not available, need TH upgrade - Skipped!", $COLOR_RED)
EndIf
ClearUpgradeInfo($inum)
GUICtrlSetImage($picUpgradeType[$inum], $pIconLib, $eIcnRedLight)
GUICtrlSetImage($picUpgradeStatus[$inum], $pIconLib, $eIcnTroops)
$ichkbxUpgrade[$inum] = 0
GUICtrlSetState($chkbxUpgrade[$inum], $GUI_UNCHECKED)
$aUpgrades[$inum][7] = ""
GUICtrlSetData($txtUpgradeEndTime[$inum], "")
ClickP($aAway, 1, 0, "#0215")
Return False
EndIf
If _ColorCheck(_GetPixelColor(703, 535 + $midOffsetY), Hex(0x000000, 6), 20) Then $aUpgrades[$inum][3] = "Dark"
$aUpgrades[$inum][2] = Number(getResourcesBonus(598, 519 + $midOffsetY))
If $aUpgrades[$inum][2] = "" Then $aUpgrades[$inum][2] = Number(getUpgradeResource(598, 519 + $midOffsetY))
If $aUpgrades[$inum][2] = "" And $ichkUpgrdeRepeat[$inum] <> 1 Then $bOopsFlag = True
$aUpgrades[$inum][6] = getHeroUpgradeTime(464, 527 + $midOffsetY)
Setlog("Upgrade #" & $inum + 1 & " Time = " & $aUpgrades[$inum][6], $COLOR_BLUE)
If  $aUpgrades[$inum][6]  <> "" Then $aUpgrades[$inum][7] = ""
Case Else
If isGemOpen(True) Then ClickP($aAway, 1, 0, "#0216")
Setlog("Selected Upgrade Window Opening Error, try again", $COLOR_RED)
ClearUpgradeInfo($inum)
ClickP($aAway, 1, 0, "#0217")
Return False
EndSelect
If StringInStr($aUpgrades[$inum][4],"Warden") > 0 then $aUpgrades[$inum][3] = "Elixir"
If $aUpgrades[$inum][3] <> "" And $bOopsFlag = True And $bRepeat = False Then
$iLoot = $aUpgrades[$inum][2]
If $iLoot = "" Then $iLoot = 8000000
Local $aBotLoc = WinGetPos($frmbot)
$inputbox = InputBox(GetTranslated(640, 56, "Text Read Error"), GetTranslated(640, 57, "Enter the cost of the upgrade"), $iLoot, "", -1, -1, $aBotLoc[0] + 125, $aBotLoc[1] + 225, -1, $frmbot)
If @error Then
Setlog("InputBox error, data reset. Try again", $COLOR_RED)
ClearUpgradeInfo($inum)
Return False
EndIf
$aUpgrades[$inum][2] = Int($inputbox)
Setlog("User input value = " & $aUpgrades[$inum][2], $COLOR_DEBUG)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslated(640, 58, "Save copy of upgrade image for developer analysis ?")
$MsgBox = _ExtMsgBox(48, GetTranslated(640, 59, "YES|NO"), GetTranslated(640, 37, "Notice"), $stext, 60, $frmBot)
If $MsgBox = 1 And $debugImageSave = 1 Then DebugImageSave("UpgradeReadError_")
EndIf
If $aUpgrades[$inum][3] = "" And $bOopsFlag = True And $bRepeat = False Then
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 10, "Comic Sans MS", 500)
$inputbox = _ExtMsgBox(0, GetTranslated(640, 60, "   GOLD   |  ELIXIR  |DARK ELIXIR"), GetTranslated(640, 61, "Need User Help"), GetTranslated(640, 62, "Select Upgrade Type:"), 0, $frmBot)
If $debugSetlog = 1 Then Setlog(" _MsgBox returned = " & $inputbox, $COLOR_DEBUG)
Switch $inputbox
Case 1
$aUpgrades[$inum][3] = "Gold"
Case 2
$aUpgrades[$inum][3] = "Elixir"
Case 3
$aUpgrades[$inum][3] = "Dark"
Case Else
SetLog("Silly programmer made an error!", $COLOR_MAROON)
$aUpgrades[$inum][3] = "HaHa"
EndSwitch
Setlog("User selected type = " & $aUpgrades[$inum][3], $COLOR_DEBUG)
EndIf
If $aUpgrades[$inum][2] = "" Or $aUpgrades[$inum][3] = "" And $ichkUpgrdeRepeat[$inum] <> 1 Then
Setlog("Error finding loot info " & $inum & ", Loot = " & $aUpgrades[$inum][2] & ", Type= " & $aUpgrades[$inum][3], $COLOR_RED)
$aUpgrades[$inum][0] = -1
$aUpgrades[$inum][1] = -1
ClickP($aAway, 2, 0, "#0218")
Return False
EndIf
Setlog("Upgrade #" & $inum + 1 & " Value = " & _NumberFormat($aUpgrades[$inum][2]) & " " & $aUpgrades[$inum][3], $COLOR_BLUE)
Else
If $ichkUpgrdeRepeat[$inum] = 0 Then
Setlog("Upgrade selection problem - data cleared, please try again", $COLOR_RED)
ClearUpgradeInfo($inum)
ElseIf $ichkUpgrdeRepeat[$inum] = 1 Then
Setlog("Repeat upgrade problem - will retry value update later", $COLOR_RED)
EndIf
ClickP($aAway, 2, 0, "#0219")
Return False
EndIf
ClickP($aAway, 2, 200, "#0220")
Switch $aUpgrades[$inum][3]
Case "Gold"
GUICtrlSetImage($picUpgradeType[$inum], $pIconLib, $eIcnGold)
Case "Elixir"
GUICtrlSetImage($picUpgradeType[$inum], $pIconLib, $eIcnElixir)
Case "Dark"
GUICtrlSetImage($picUpgradeType[$inum], $pIconLib, $eIcnDark)
Case Else
GUICtrlSetImage($picUpgradeType[$inum], $pIconLib, $eIcnBlank)
EndSwitch
GUICtrlSetData($txtUpgradeValue[$inum], _NumberFormat($aUpgrades[$inum][2]))
GUICtrlSetData($txtUpgradeTime[$inum], StringStripWS($aUpgrades[$inum][6], $STR_STRIPALL))
GUICtrlSetData($txtUpgradeEndTime[$inum], $aUpgrades[$inum][7])
Return True
EndFunc
Func ClearUpgradeInfo($inum)
$ipicUpgradeStatus[$inum] = $eIcnTroops
$aUpgrades[$inum][0] = -1
$aUpgrades[$inum][1] = -1
$aUpgrades[$inum][2] = 0
$aUpgrades[$inum][3] = ""
$aUpgrades[$inum][4] = ""
$aUpgrades[$inum][5] = ""
$aUpgrades[$inum][6] = ""
$aUpgrades[$inum][7] = ""
EndFunc
Func LocateClanCastle()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
SetLog("Locating Clan Castle...", $COLOR_BLUE)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslated(640, 32, "Click OK then click on your Clan Castle") & @CRLF & @CRLF &  GetTranslated(640, 26, "Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640, 27, "Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640, 1, "Ok|Cancel"), GetTranslated(640, 33, "Locate Clan Castle"), $stext, 15, $frmBot)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0373")
Local $aPos = FindPos()
$aCCPos[0] = $aPos[0]
$aCCPos[1] = $aPos[1]
If isInsideDiamond($aCCPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Clan Castle Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_RED)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $aCCPos[0] & "," & $aCCPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $aCCPos[0] & "," & $aCCPos[1] & ")", $COLOR_RED)
ClickP($aAway, 1, 0, "#0374")
Return False
Case Else
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $aCCPos[0] & "," & $aCCPos[1] & ")", $COLOR_RED)
$aCCPos[0] = -1
$aCCPos[1] = -1
ClickP($aAway, 1, 0, "#0375")
Return False
EndSelect
EndIf
SetLog("Clan Castle: " & "(" & $aCCPos[0] & "," & $aCCPos[1] & ")", $COLOR_GREEN)
Else
SetLog("Locate Clan Castle Cancelled", $COLOR_BLUE)
ClickP($aAway, 1, 0, "#0376")
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If UBound($sInfo) > 2 And ($sInfo[0] > 1 Or $sInfo[0] = "") Then
If StringInStr($sInfo[1], "clan") = 0 Then
If $sInfo[0] = "" Then
$sLocMsg = "Nothing"
Else
$sLocMsg = $sInfo[1]
EndIf
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Clan Castle?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Clan Castle, or restart bot and try again", $COLOR_RED)
$aCCPos[0] = -1
$aCCPos[1] = -1
ClickP($aAway, 1, 0, "#0377")
Return False
EndSelect
EndIf
If $sInfo[2] = "Broken" Then
SetLog("You did not rebuild your Clan Castle yet.", $COLOR_ORANGE)
Else
SetLog("Your Clan Castle is at level: " & $sInfo[2], $COLOR_GREEN)
EndIf
Else
SetLog(" Operator Error - Bad Clan Castle Location: " & "(" & $aCCPos[0] & "," & $aCCPos[1] & ")", $COLOR_RED)
$aCCPos[0] = -1
$aCCPos[1] = -1
ClickP($aAway, 1, 0, "#0378")
Return False
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 200, "#0327")
EndFunc
Func LocateLab()
Local $stext, $MsgBox, $iStupid = 0, $iSilly = 0, $sErrorText = ""
SetLog("Locating Laboratory...", $COLOR_BLUE)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = $sErrorText & @CRLF & GetTranslated(640,43,"Click OK then click on your Laboratory building") & @CRLF & @CRLF &  GetTranslated(640,26,"Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,44,"Locate Laboratory"), $stext, 15, $frmBot)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0379")
Local $aPos = FindPos()
$aLabPos[0] = Int($aPos[0])
$aLabPos[1] = Int($aPos[1])
If isInsideDiamond($aLabPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Laboratory Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_RED)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $aLabPos[0] & "," & $aLabPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Laboratory Location: " & "(" & $aLabPos[0] & "," & $aLabPos[1] & ")", $COLOR_RED)
ClickP($aAway, 1, 0, "#0380")
Return False
Case Else
SetLog(" Operator Error - Bad Laboratory Location: " & "(" & $aLabPos[0] & "," & $aLabPos[1] & ")", $COLOR_RED)
$aLabPos[0] = -1
$aLabPos[1] = -1
ClickP($aAway, 1, 0, "#0381")
Return False
EndSelect
EndIf
Else
SetLog("Locate Laboratory Cancelled", $COLOR_BLUE)
ClickP($aAway, 1, 0, "#0382")
Return
EndIf
$sLabInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If $sLabInfo[0] > 1 Or $sLabInfo[0] = "" Then
If StringInStr($sLabInfo[1], "Lab") = 0 Then
If $sLabInfo[0] = "" Then
$sLocMsg = "Nothing"
Else
$sLocMsg = $sLabInfo[1]
EndIf
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the laboratory?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Army Camp, or restart bot and try again", $COLOR_RED)
$aLabPos[0] = -1
$aLabPos[1] = -1
ClickP($aAway, 1, 0, "#0383")
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Laboratory Location: " & "(" & $aLabPos[0] & "," & $aLabPos[1] & ")", $COLOR_RED)
$aLabPos[0] = -1
$aLabPos[1] = -1
ClickP($aAway, 1, 0, "#0384")
Return False
EndIf
SetLog("Locate Laboratory Success: " & "(" & $aLabPos[0] & "," & $aLabPos[1] & ")", $COLOR_GREEN)
ExitLoop
WEnd
Clickp($aAway, 2, 0, "#0207")
EndFunc
Func LocateTownHall($bLocationOnly = False)
Local $stext, $MsgBox, $Success, $sLocMsg
Local $iStupid = 0, $iSilly = 0, $sErrorText = ""
SetLog("Locating Town Hall ...", $COLOR_BLUE)
WinGetAndroidHandle()
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
Collect()
EndIf
While 1
_ExtMsgBoxSet(1 + 64, 1, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 600)
$stext = $sErrorText & @CRLF & GetTranslated(640,49,"Click OK then click on your Town Hall") & @CRLF & @CRLF &  GetTranslated(640,26,"Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,50,"Locate TownHall"), $stext, 30, $frmBot)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aAway, 1, 0, "#0391")
Local $aPos = FindPos()
$TownHallPos[0] = $aPos[0]
$TownHallPos[1] = $aPos[1]
If _Sleep($iDelayLocateTownHall1) Then Return
If isInsideDiamond($TownHallPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "TownHall Location not valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_RED)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $TownHallPos[0] & "," & $TownHallPos[1] & ")?" & @CRLF & "Please stop!" & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Townhall Location: " & "(" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_RED)
$TownHallPos[0] = -1
$TownHallPos[1] = -1
ClickP($aAway, 1, 0, "#0392")
Return False
EndSelect
EndIf
SetLog("Townhall: " & "(" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_GREEN)
Else
SetLog("Locate TownHall Cancelled", $COLOR_BLUE)
ClickP($aAway, 1, 0, "#0393")
Return
EndIf
If $bLocationOnly = False Then
$Success = GetTownHallLevel()
$iSilly += 1
If IsArray($Success) Or $Success = False Then
If $Success = False Then
$sLocMsg = "Nothing"
Else
$sLocMsg = $Success[1]
EndIf
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not a TownHall?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click on the TH, or restart bot and try again", $COLOR_RED)
$TownHallPos[0] = -1
$TownHallPos[1] = -1
ClickP($aAway, 1, 0, "#0394")
Return False
EndSelect
Else
SetLog("Locate TH Success!", $COLOR_RED)
EndIf
EndIf
ExitLoop
WEnd
ClickP($aAway, 1, 50, "#0209")
EndFunc
Func LocateQueenAltar()
Local $wasRunState = $RunState
$RunState = True
AndroidShield("LocateQueenAltar 1")
Local $Result = _LocateQueenAltar()
$RunState = $wasRunState
AndroidShield("LocateQueenAltar 2")
Return $Result
EndFunc
Func _LocateQueenAltar()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
WinGetAndroidHandle()
checkMainScreen(False)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
EndIf
SetLog("Locating Queen Altar...", $COLOR_BLUE)
While 1
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslated(640,34,"Click OK then click on your Queen Altar") & @CRLF & @CRLF &  GetTranslated(640,26,"Do not move mouse after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,35,"Locate Queen Altar"), $stext, 15, $frmBot)
If $MsgBox = 1 Then
WinGetAndroidHandle()
ClickP($aTopLeftClient)
Local $aPos = FindPos()
$QueenAltarPos[0] = $aPos[0]
$QueenAltarPos[1] = $aPos[1]
If isInsideDiamond($QueenAltarPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Queen Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_RED)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")", $COLOR_RED)
ClickP($aTopLeftClient)
Return False
Case Else
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")", $COLOR_RED)
$QueenAltarPos[0] = -1
$QueenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
SetLog("Queen Altar: " & "(" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")", $COLOR_GREEN)
Else
SetLog("Locate Queen Altar Cancelled", $COLOR_BLUE)
ClickP($aTopLeftClient)
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $debugSetlog = 1 Then SetLog($sInfo[1] & $sInfo[2], $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If @error Then Return SetError(0, 0, 0)
If StringInStr($sInfo[1], "Quee") = 0 Then
If $sInfo[0] = "" Then
$sLocMsg = "Nothing"
Else
$sLocMsg = $sInfo[1]
EndIf
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Queen Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Queen Altar, or restart bot and try again", $COLOR_RED)
$QueenAltarPos[0] = -1
$QueenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Queen Altar Location: " & "(" & $QueenAltarPos[0] & "," & $QueenAltarPos[1] & ")", $COLOR_RED)
$QueenAltarPos[0] = -1
$QueenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndIf
ExitLoop
WEnd
ClickP($aTopLeftClient, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslated(640,38,"Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslated(640,36,"OK"), GetTranslated(640,37,"Notice!"), $stext, 15, $frmBot)
IniWrite($building, "other", "xQueenAltarPos", $QueenAltarPos[0])
IniWrite($building, "other", "yQueenAltarPos", $QueenAltarPos[1])
EndFunc
Func LocateKingAltar()
Local $wasRunState = $RunState
$RunState = True
AndroidShield("LocateKingAltar 1")
Local $Result = _LocateKingAltar()
$RunState = $wasRunState
AndroidShield("LocateKingAltar 2")
Return $Result
EndFunc
Func _LocateKingAltar()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
WinGetAndroidHandle()
checkMainScreen(False)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) Or _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
EndIf
SetLog("Locating King Altar...", $COLOR_BLUE)
While 1
ClickP($aTopLeftClient)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslated(640,39,"Click OK then click on your King Altar") & @CRLF & @CRLF &  GetTranslated(640,26,"Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,40,"Locate King Altar"), $stext, 15, $frmBot)
If $MsgBox = 1 Then
WinGetAndroidHandle()
Local $aPos = FindPos()
$KingAltarPos[0] = $aPos[0]
$KingAltarPos[1] = $aPos[1]
If isInsideDiamond($KingAltarPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "King Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_RED)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")", $COLOR_RED)
ClickP($aTopLeftClient)
Return False
Case Else
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")", $COLOR_RED)
$KingAltarPos[0] = -1
$KingAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
SetLog("King Altar: " & "(" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")", $COLOR_GREEN)
Else
SetLog("Locate King Altar Cancelled", $COLOR_BLUE)
ClickP($aTopLeftClient)
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $debugSetlog = 1 Then SetLog($sInfo[1] & $sInfo[2], $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If (StringInStr($sInfo[1], "Barb") = 0) And (StringInStr($sInfo[1], "King") = 0) Then
If $sInfo[0] = "" Then
$sLocMsg = "Nothing"
Else
$sLocMsg = $sInfo[1]
EndIf
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the King Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the King Altar, or restart bot and try again", $COLOR_RED)
$KingAltarPos[0] = -1
$KingAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad King Altar Location: " & "(" & $KingAltarPos[0] & "," & $KingAltarPos[1] & ")", $COLOR_RED)
$KingAltarPos[0] = -1
$KingAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndIf
ExitLoop
WEnd
ClickP($aTopLeftClient, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslated(640,38,"Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslated(640,36,"OK"), GetTranslated(640,37,"Notice!"), $stext, 15, $frmBot)
IniWrite($building, "other", "xKingAltarPos", $KingAltarPos[0])
IniWrite($building, "other", "yKingAltarPos", $KingAltarPos[1])
EndFunc
Func LocateWardenAltar()
Local $wasRunState = $RunState
$RunState = True
AndroidShield("LocateWardenAltar 1")
Local $Result = _LocateWardenAltar()
$RunState = $wasRunState
AndroidShield("LocateWardenAltar 2")
Return $Result
EndFunc
Func _LocateWardenAltar()
Local $stext, $MsgBox, $iSilly = 0, $iStupid = 0, $sErrorText = "", $sInfo
If Number($iTownHallLevel) < 11 Then
SetLog("Grand Warden requires TH11, Cancel locate Altar!", $COLOR_RED)
Return
EndIf
WinGetAndroidHandle()
checkMainScreen(False)
If _GetPixelColor($aTopLeftClient[0], $aTopLeftClient[1], True) <> Hex($aTopLeftClient[2], 6) And _GetPixelColor($aTopRightClient[0], $aTopRightClient[1], True) <> Hex($aTopRightClient[2], 6) Then
Zoomout()
$bDisableBreakCheck = True
Collect()
$bDisableBreakCheck = False
EndIf
SetLog("Locating Grand Warden Altar... work in progress!", $COLOR_BLUE)
While 1
ClickP($aTopLeftClient)
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = $sErrorText & @CRLF & GetTranslated(640,41,"Click OK then click on your Grand Warden Altar") & @CRLF & @CRLF &  GetTranslated(640,26,"Do not move mouse quickly after clicking location") & @CRLF & @CRLF & GetTranslated(640,27,"Make sure the building name is visible for me!") & @CRLF
$MsgBox = _ExtMsgBox(0, GetTranslated(640,1,"Ok|Cancel"), GetTranslated(640,42,"Locate Grand Warden Altar"), $stext, 15, $frmBot)
If $MsgBox = 1 Then
WinGetAndroidHandle()
Local $aPos = FindPos()
$WardenAltarPos[0] = $aPos[0]
$WardenAltarPos[1] = $aPos[1]
If isInsideDiamond($WardenAltarPos) = False Then
$iStupid += 1
Select
Case $iStupid = 1
$sErrorText = "Grand Warden Altar Location Not Valid!" & @CRLF
SetLog("Location not valid, try again", $COLOR_RED)
ContinueLoop
Case $iStupid = 2
$sErrorText = "Please try to click inside the grass field!" & @CRLF
ContinueLoop
Case $iStupid = 3
$sErrorText = "This is not funny, why did you click @ (" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")?" & @CRLF & "  Please stop!" & @CRLF & @CRLF
ContinueLoop
Case $iStupid = 4
$sErrorText = "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iStupid > 4
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")", $COLOR_RED)
ClickP($aTopLeftClient)
Return False
Case Else
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")", $COLOR_RED)
$WardenAltarPos[0] = -1
$WardenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
SetLog("Grand Warden Altar: " & "(" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")", $COLOR_GREEN)
Else
SetLog("Locate Grand Warden Altar Cancelled", $COLOR_BLUE)
ClickP($aTopLeftClient)
Return
EndIf
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $debugSetlog = 1 Then SetLog($sInfo[1] & $sInfo[2], $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If @error Then Return SetError(0, 0, 0)
If StringInStr($sInfo[1], "Warden") = 0 Then
If $sInfo[0] = "" Then
$sLocMsg = "Nothing"
Else
$sLocMsg = $sInfo[1]
EndIf
$iSilly += 1
Select
Case $iSilly = 1
$sErrorText = "Wait, That is not the Grand Warden Altar?, It was a " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 2
$sErrorText = "Quit joking, That was " & $sLocMsg & @CRLF
ContinueLoop
Case $iSilly = 3
$sErrorText = "This is not funny, why did you click " & $sLocMsg & "? Please stop!" & @CRLF
ContinueLoop
Case $iSilly = 4
$sErrorText = $sLocMsg & " ?!?!?!" & @CRLF & @CRLF & "Last Chance, DO NOT MAKE ME ANGRY, or" & @CRLF & "I will give ALL of your gold to Barbarian King," & @CRLF & "And ALL of your Gems to the Archer Queen!" & @CRLF
ContinueLoop
Case $iSilly > 4
SetLog("Quit joking, Click the Grand Warden Altar, or restart bot and try again", $COLOR_RED)
$WardenAltarPos[0] = -1
$WardenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndSelect
EndIf
Else
SetLog(" Operator Error - Bad Grand Warden Altar Location: " & "(" & $WardenAltarPos[0] & "," & $WardenAltarPos[1] & ")", $COLOR_RED)
$WardenAltarPos[0] = -1
$WardenAltarPos[1] = -1
ClickP($aTopLeftClient)
Return False
EndIf
ExitLoop
WEnd
ClickP($aTopLeftClient, 1, 200, "#0327")
If _Sleep(1000) Then Return
_ExtMsgBoxSet(1 + 64, $SS_CENTER, 0x004080, 0xFFFF00, 12, "Comic Sans MS", 500)
$stext = GetTranslated(640,38,"Now you can remove mouse out of Android Emulator, Thanks!!")
$MsgBox = _ExtMsgBox(48, GetTranslated(640,36,"OK"), GetTranslated(640,37,"Notice!"), $stext, 15, $frmBot)
IniWrite($building, "other", "xWardenAltarPos", $WardenAltarPos[0])
IniWrite($building, "other", "yWardenAltarPos", $WardenAltarPos[1])
EndFunc
Func ProfileReport()
Local $iCount
ClickP($aAway, 1, 0, "#0221")
If _Sleep($iDelayProfileReport1) Then Return
SetLog("Profile Report", $COLOR_BLUE)
SetLog("Opening Profile page to read atk, def, donated and received...", $COLOR_BLUE)
Click(190, 33, 1, 0, "#0222")
If _Sleep($iDelayProfileReport2) Then Return
While _ColorCheck(_GetPixelColor(400, 104 + $midOffsetY, True), Hex(0xA2A6BE, 6), 20) = False
If $Debugsetlog = 1 Then Setlog("Profile wait time: " & $iCount & ", color= " & _GetPixelColor(400, 104 + $midOffsetY, True)& " pos (400," & 104 + $midOffsetY&")", $COLOR_DEBUG)
$iCount += 1
If _Sleep($iDelayProfileReport1) Then Return
If $iCount >= 25 Then ExitLoop
WEnd
If $Debugsetlog = 1 And $iCount >= 25 Then Setlog("Excess wait time for profile to open: " & $iCount, $COLOR_DEBUG)
If _Sleep($iDelayProfileReport1) Then Return
$AttacksWon = ""
If _ColorCheck(_GetPixelColor($ProfileRep01[0], $ProfileRep01[1] , True), Hex($ProfileRep01[2], 6), $ProfileRep01[3]) = true  Then
If $debugSetlog=1 Then Setlog("Village have no attack and no defenses " & $ProfileRep01[0] & "," & $ProfileRep01[1] + $midOffsetY, $COLOR_DEBUG)
$AttacksWon = 0
$DefensesWon = 0
Else
$AttacksWon = getProfile(578, 268 + $midOffsetY)
If $Debugsetlog = 1 Then Setlog("$AttacksWon 1st read: " & $AttacksWon, $COLOR_DEBUG)
$iCount = 0
While $AttacksWon = ""
If _Sleep($iDelayProfileReport1) Then Return
$AttacksWon = getProfile(578, 268 + $midOffsetY)
If $Debugsetlog = 1 Then Setlog("Read Loop $AttacksWon: " & $AttacksWon & ", Count: " & $iCount, $COLOR_DEBUG)
$iCount += 1
If $iCount >= 20 Then ExitLoop
WEnd
If $Debugsetlog = 1 And $iCount >= 20 Then Setlog("Excess wait time for reading $AttacksWon: " & getProfile(578, 268 + $midOffsetY), $COLOR_DEBUG)
$DefensesWon = getProfile(790, 268 + $midOffsetY)
EndIf
$TroopsDonated = getProfile(158, 268 + $midOffsetY)
$TroopsReceived = getProfile(360, 268 + $midOffsetY)
SetLog(" [ATKW]: " & _NumberFormat($AttacksWon) & " [DEFW]: " & _NumberFormat($DefensesWon) & " [TDON]: " & _NumberFormat($TroopsDonated) & " [TREC]: " & _NumberFormat($TroopsReceived), $COLOR_GREEN)
Click(820, 40, 1, 0, "#0223")
If _Sleep($iDelayProfileReport3) Then Return
$iCount = 0
While _CheckPixel($aIsMain, $bCapturePixel) = False
If _Sleep($iDelayProfileReport3) Then Return
$iCount += 1
If $Debugsetlog = 1 Then Setlog("End ProfileReport $iCount= " & $iCount, $COLOR_DEBUG)
If $iCount > 50 Then
If $Debugsetlog = 1 Then Setlog("Excess wait time clearing ProfileReport window: " & $iCount, $COLOR_DEBUG)
ExitLoop
EndIf
WEnd
EndFunc
Func ReArm()
If $ichkTrap = 0 Then Return
If $iShouldRearm = False Then Return
$iShouldRearm = False
SetLog("Checking if Village needs Rearming..", $COLOR_BLUE)
Local $ImagesToUse[3]
$ImagesToUse[0] = @ScriptDir & "\images\Button\Traps.png"
$ImagesToUse[1] = @ScriptDir & "\images\Button\Xbow.png"
$ImagesToUse[2] = @ScriptDir & "\images\Button\Inferno.png"
$ToleranceImgLoc = 0.90
Local $locate = 0
Local $t = 0
If isInsideDiamond($TownHallPos) = False Then
LocateTownHall(True)
SaveConfig()
If _Sleep($iDelayReArm3) Then Return
EndIf
ClickP($aAway, 1, 0, "#0224")
If _Sleep($iDelayReArm4) Then Return
If IsMainPage() Then Click($TownHallPos[0], $TownHallPos[1] + 5, 1, 0, "#0225")
If _Sleep($iDelayReArm2) Then Return
If Number($iTownHallLevel) > 8 Then $t = 1
If Number($iTownHallLevel) > 9 Then $t = 2
Local $Success = GetTownHallLevel(False, False)
If IsArray($Success) Or $Success = False Then
SetLog("Locating TownHall Once Again")
Local $PixelTHHere = GetLocationItem("getLocationTownHall", True)
If UBound($PixelTHHere) > 0 Then
$pixel = $PixelTHHere[0]
$TownHallPos[0] = $pixel[0]
$TownHallPos[1] = $pixel[1]
If $debugSetlog = 1 Then SetLog("ImgLoc# Townhall: (" & $TownHallPos[0] & "," & $TownHallPos[1] & ")", $COLOR_DEBUG)
EndIf
EndIf
For $i = 0 To $t
If FileExists($ImagesToUse[$i]) Then
_CaptureRegion2(125, 610, 740, 715)
$res = DllCall($hImgLib, "str", "SearchTile", "handle", $hHBitmap2, "str", $ImagesToUse[$i], "float", $ToleranceImgLoc, "str", "FV", "int", 1)
If @error Then _logErrorDLLCall($pImgLib, @error)
If IsArray($res) Then
If $DebugSetlog = 1 Then SetLog("DLL Call succeeded " & $res[0], $COLOR_DEBUG)
If $res[0] = "0" Or $res[0] = "" Then
If $DebugSetlog = 1 Then SetLog("No Button found", $COLOR_DEBUG)
ElseIf StringLeft($res[0], 2) = "-1" Then
SetLog("DLL Error: " & $res[0], $COLOR_RED)
Else
$expRet = StringSplit($res[0], "|", $STR_NOCOUNT)
$posPoint = StringSplit($expRet[1], ",", $STR_NOCOUNT)
$ButtonX = 125 + Int($posPoint[0])
$ButtonY = 610 + Int($posPoint[1])
If IsMainPage() Then Click($ButtonX, $ButtonY, 1, 0, "#0330")
If _Sleep($iDelayReArm1) Then Return
Click(515, 400, 1, 0, "#0226")
If _Sleep($iDelayReArm4) Then Return
If isGemOpen(True) = True Then
Setlog("Not enough loot to rearm traps.....", $COLOR_RED)
Click(585, 252, 1, 0, "#0227")
If _Sleep($iDelayReArm1) Then Return
Else
If $i = 0 Then SetLog("Rearmed Trap(s)", $COLOR_GREEN)
If $i = 1 Then SetLog("Reloaded XBow(s)", $COLOR_GREEN)
If $i = 2 Then SetLog("Reloaded Inferno(s)", $COLOR_GREEN)
$locate = 1
If _Sleep($iDelayReArm1) Then Return
EndIf
EndIf
EndIf
EndIf
Next
If $locate = 0 Then SetLog("Rearm not needed!", $COLOR_GREEN)
ClickP($aAway, 1, 0, "#0234")
If _Sleep($iDelayReArm2) Then Return
checkMainScreen(False)
EndFunc
Func RequestCC($ClickPAtEnd = True, $specifyText = "")
If $iPlannedRequestCCHoursEnable <> 1 Or $canRequestCC = False Or $bDonationEnabled = False Then
Return
EndIf
If $iPlannedRequestCCHoursEnable = 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $iPlannedRequestCCHours[$hour[0]] = 0 Then
SetLog("Request Clan Castle troops not planned, Skipped..", $COLOR_ORANGE)
Return
EndIf
EndIf
SetLog("Requesting Clan Castle Troops", $COLOR_BLUE)
If IsMainPage() Then
If $iUseRandomClick = 0 Then
Click($aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0, "#0334")
Else
ClickR($aArmyTrainButtonRND, $aArmyTrainButton[0], $aArmyTrainButton[1], 1, 0)
EndIf
EndIf
If _Sleep($iDelayRequestCC1) Then Return
checkAttackDisable($iTaBChkIdle)
Local $icount = 0
While Not ( _ColorCheck(_GetPixelColor($aArmyOverviewTest[0], $aArmyOverviewTest[1], True), Hex($aArmyOverviewTest[2], 6), $aArmyOverviewTest[3]))
If _Sleep($iDelayRequestCC1) Then ExitLoop
$icount += 1
If $DebugSetLog = 1 Then Setlog("$icount1 = " & $icount & ", " & _GetPixelColor($aArmyOverviewTest[0], $aArmyOverviewTest[1], True), $COLOR_DEBUG)
If $icount > 5 Then ExitLoop
WEnd
If $icount > 5 And $DebugSetLog = 1 Then Setlog("RequestCC warning 1", $COLOR_DEBUG)
$color = _GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True)
If _ColorCheck($color, Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5]) Then
$specifyText = IsFullCastleSpells(True)
Local $x = _makerequest($specifyText)
ElseIf _ColorCheck($color, Hex($aRequestTroopsAO[3], 6), $aRequestTroopsAO[5]) Then
SetLog("Request has already been made")
ElseIf _ColorCheck($color, Hex($aRequestTroopsAO[4], 6), $aRequestTroopsAO[5]) Then
SetLog("Your Clan Castle is already full or you are not in a clan.")
$canRequestCC = False
Else
SetLog("Cannot detect button request troops.")
EndIf
If _Sleep($iDelayRequestCC1) Then Return
If $ClickPAtEnd = True Then ClickP($aAway, 2, 0, "#0335")
EndFunc
Func _makerequest($specifyText = "")
Click($aRequestTroopsAO[0], $aRequestTroopsAO[1], 1, 0, "0336")
Local $icount = 0
While Not ( _ColorCheck(_GetPixelColor($aCancRequestCCBtn[0], $aCancRequestCCBtn[1], True), Hex($aCancRequestCCBtn[2], 6), $aCancRequestCCBtn[3]))
If _Sleep($iDelaymakerequest1) Then ExitLoop
$icount += 1
If $DebugSetLog = 1 Then Setlog("$icount2 = " & $icount & ", " & _GetPixelColor($aCancRequestCCBtn[0], $aCancRequestCCBtn[1], True), $COLOR_DEBUG)
If $icount > 20 Then ExitLoop
WEnd
If $icount > 20 Then
SetLog("Request has already been made, or request window not available", $COLOR_RED)
ClickP($aAway, 2, 0, "#0257")
If _Sleep($iDelaymakerequest2) Then Return
Else
Local $tempTxtRequest = $specifyText
If $tempTxtRequest = "" Then $tempTxtRequest = $sTxtRequest
If $tempTxtRequest <> "" Then
If $ichkBackground = 0 And $NoFocusTampering = False Then ControlFocus($HWnD, "", "")
AndroidSendText($tempTxtRequest, True)
Click($atxtRequestCCBtn[0], $atxtRequestCCBtn[1], 1, 0, "#0254")
_Sleep($iDelaymakerequest2)
If SendText($tempTxtRequest) = 0 Then
Setlog(" Request text entry failed, try again", $COLOR_RED)
Return
EndIf
EndIf
If _Sleep($iDelaymakerequest2) Then Return
$icount = 0
While Not _ColorCheck(_GetPixelColor($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], True), Hex(0x5fac10, 6), 20)
If _Sleep($iDelaymakerequest1) Then ExitLoop
$icount += 1
If $DebugSetLog = 1 Then Setlog("$icount3 = " & $icount & ", " & _GetPixelColor($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], True), $COLOR_DEBUG)
If $icount > 25 Then ExitLoop
WEnd
If $icount > 25 Then
If $DebugSetLog = 1 Then SetLog("Send request button not found", $COLOR_DEBUG)
CheckMainScreen(False)
EndIf
If $ichkBackground = 0 And $NoFocusTampering = False Then ControlFocus($HWnD, "", "")
Click($aSendRequestCCBtn[0], $aSendRequestCCBtn[1], 1, 100, "#0256")
$canRequestCC = False
EndIf
EndFunc
Func VillageReport($bBypass = False, $bSuppressLog = False)
PureClickP($aAway, 1, 0, "#0319")
If _Sleep($iDelayVillageReport1) Then Return
Switch $bBypass
Case False
If Not $bSuppressLog Then SetLog("Village Report", $COLOR_BLUE)
Case True
If Not $bSuppressLog Then SetLog("Updating Village Resource Values", $COLOR_BLUE)
Case Else
If Not $bSuppressLog Then SetLog("Village Report Error, You have been a BAD programmer!", $COLOR_RED)
EndSwitch
IsWaitingForConnection()
getBuilderCount($bSuppressLog)
If _Sleep($iDelayRespond) Then Return
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If Not $bSuppressLog Then Setlog(" [T]: " & _NumberFormat($iTrophyCurrent), $COLOR_GREEN)
If _ColorCheck(_GetPixelColor(812, 141, True), Hex(0x000000, 6), 10) Then
$iGoldCurrent = getResourcesMainScreen(696, 23)
$iElixirCurrent = getResourcesMainScreen(696, 74)
$iDarkCurrent =  getResourcesMainScreen(728, 123)
$iGemAmount = getResourcesMainScreen(740, 171)
If Not $bSuppressLog Then SetLog(" [G]: " & _NumberFormat($iGoldCurrent) & " [E]: " & _NumberFormat($iElixirCurrent) & " [D]: " & _NumberFormat($iDarkCurrent) & " [GEM]: " & _NumberFormat($iGemAmount), $COLOR_GREEN)
Else
$iGoldCurrent = getResourcesMainScreen(701, 23)
$iElixirCurrent = getResourcesMainScreen(701, 74)
$iGemAmount = getResourcesMainScreen(719, 123)
If Not $bSuppressLog Then SetLog(" [G]: " & _NumberFormat($iGoldCurrent) & " [E]: " & _NumberFormat($iElixirCurrent) & " [GEM]: " & _NumberFormat($iGemAmount), $COLOR_GREEN)
EndIf
If $bBypass = False Then
UpdateStats()
EndIf
If $RunModeChart = 1 Then
ChartAddDataPoint1hr("Total", True)
$RunModeChart = 0
EndIf
Local $i = 0
While _ColorCheck(_GetPixelColor(819, 39, True), Hex(0xF8FCFF, 6), 20) = True
$i += 1
If _Sleep($iDelayVillageReport1) Then Return
If $i >= 20 Then ExitLoop
WEnd
EndFunc
Func UpgradeBuilding()
Local $iz = 0
Local $iUpgradeAction = -1
Local $iAvailBldr, $iAvailGold, $iAvailElixir, $iAvailDark
Local $Endtime, $Endperiod, $TimeAdd
Local $iUpGrdEndTimeDiff = 0
Local $aCheckFrequency[9] = [5, 15, 20, 30, 60, 60, 120, 240, 240]
Local $iDTDiff
Local $bChkAllRptUpgrade = False
Local $sTime
Static Local $sNextCheckTime = _DateAdd("n", -1, _NowCalc())
If @error Then _logErrorDateAdd(@error)
$itxtUpgrMinGold = Number($itxtUpgrMinGold)
$itxtUpgrMinElixir = Number($itxtUpgrMinElixir)
$itxtUpgrMinDark = Number($itxtUpgrMinDark)
For $iz = 0 To UBound($aUpgrades, 1) - 1
If $ichkbxUpgrade[$iz] = 1 Then
$iUpgradeAction += 2 ^ ($iz + 1)
EndIf
Next
If $iUpgradeAction < 0 Then Return False
$iUpgradeAction = 0
Setlog("Checking Upgrades", $COLOR_BLUE)
VillageReport(True, True)
$iAvailGold = Number($iGoldCurrent)
$iAvailElixir = Number($iElixirCurrent)
$iAvailDark = Number($iDarkCurrent)
If $iSaveWallBldr = 1 Then
$iAvailBldr = $iFreeBuilderCount - $iSaveWallBldr
Else
$iAvailBldr = $iFreeBuilderCount
EndIf
If $iAvailBldr <= 0 Then
Setlog("No builder available for upgrade process", $COLOR_RED)
Return False
EndIf
For $iz = 0 To UBound($aUpgrades, 1) - 1
If $debugSetlog = 1 Then SetlogUpgradeValues($iz)
If $ichkbxUpgrade[$iz] = 0 Then ContinueLoop
If $aUpgrades[$iz][0] <= 0 Or $aUpgrades[$iz][1] <= 0 Or $aUpgrades[$iz][3] = "" Then ContinueLoop
If $iAvailBldr <= 0 And $bChkAllRptUpgrade = False Then
Setlog("No builder available for #" & $iz + 1 & ", " & $aUpgrades[$iz][4], $COLOR_RED)
Return False
EndIf
If $ichkUpgrdeRepeat[$iz] = 1 Then
If $bChkAllRptUpgrade = False Then
$iDTDiff = Int(_DateDiff("n", _NowCalc(), $sNextCheckTime))
If @error Then _logErrorDateDiff(@error)
If $debugSetlog = 1 Then
Setlog("Delay time between repeat upgrade checks = " & $aCheckFrequency[($iTownHallLevel < 3 ? 0 : $iTownHallLevel - 3)] & " Min", $COLOR_DEBUG)
SetLog("Delay time remaining = " & $iDTDiff & " Min", $COLOR_DEBUG)
EndIf
If $iDTDiff < 0 Then
$sNextCheckTime = _DateAdd("n", $aCheckFrequency[($iTownHallLevel < 3 ? 0 : $iTownHallLevel - 3)], _NowCalc())
If @error Then _logErrorDateAdd(@error)
$bChkAllRptUpgrade = True
If $debugSetlog = 1 Then SetLog("New delayed check time=  " & $sNextCheckTime, $COLOR_DEBUG)
EndIf
EndIf
If _DateIsValid($aUpgrades[$iz][7]) Then
$iUpGrdEndTimeDiff = Int(_DateDiff("n", _NowCalc(), $aUpgrades[$iz][7]))
If @error Then
_logErrorDateDiff(@error)
$iUpGrdEndTimeDiff = 0
EndIf
If $debugSetlog = 1 Then SetLog("Difference between upgrade end and NOW= " & $iUpGrdEndTimeDiff & " Min", $COLOR_DEBUG)
EndIf
If $bChkAllRptUpgrade = True Or $iUpGrdEndTimeDiff < 0 Then
If UpgradeValue($iz, True) = False Then
If $debugSetlog = 1 Then SetlogUpgradeValues($iz)
Setlog("Repeat upgrade #" & $iz + 1 & " " & $aUpgrades[$iz][4] & " not ready yet", $COLOR_RED)
ContinueLoop
ElseIf ($iAvailBldr <= 0) Then
Setlog("No builder available for " & $aUpgrades[$iz][4], $COLOR_RED)
ContinueLoop
EndIf
EndIf
EndIf
SetLog("Upgrade #" & $iz + 1 & " " & $aUpgrades[$iz][4] & " Selected", $COLOR_GREEN)
If $debugSetlog = 1 Then SetLog("-Upgrade location =  " & "(" & $aUpgrades[$iz][0] & "," & $aUpgrades[$iz][1] & ")", $COLOR_DEBUG)
If _Sleep($iDelayUpgradeBuilding1) Then Return
Switch $aUpgrades[$iz][3]
Case "Gold"
If $iAvailGold < $aUpgrades[$iz][2] + $itxtUpgrMinGold Then
SetLog("Insufficent Gold for #" & $iz + 1 & ", requires: " & $aUpgrades[$iz][2] & " + " & $itxtUpgrMinGold, $COLOR_BLUE)
ContinueLoop
EndIf
If UpgradeNormal($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^ ($iz + 1)
Setlog("Gold used = " & $aUpgrades[$iz][2], $COLOR_BLUE)
$iNbrOfBuildingsUppedGold += 1
$iCostGoldBuilding += $aUpgrades[$iz][2]
UpdateStats()
$iAvailGold -= $aUpgrades[$iz][2]
$iAvailBldr -= 1
Case "Elixir"
If $iAvailElixir < $aUpgrades[$iz][2] + $itxtUpgrMinElixir Then
SetLog("Insufficent Elixir for #" & $iz + 1 & ", requires: " & $aUpgrades[$iz][2] & " + " & $itxtUpgrMinElixir, $COLOR_BLUE)
ContinueLoop
EndIf
If UpgradeNormal($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^ ($iz + 1)
Setlog("Elixir used = " & $aUpgrades[$iz][2], $COLOR_BLUE)
$iNbrOfBuildingsUppedElixir += 1
$iCostElixirBuilding += $aUpgrades[$iz][2]
UpdateStats()
$iAvailElixir -= $aUpgrades[$iz][2]
$iAvailBldr -= 1
Case "Dark"
If $iAvailDark < $aUpgrades[$iz][2] + $itxtUpgrMinDark Then
SetLog("Insufficent Dark for #" & $iz + 1 & ", requires: " & $aUpgrades[$iz][2] & " + " & $itxtUpgrMinDark, $COLOR_BLUE)
ContinueLoop
EndIf
If UpgradeHero($iz) = False Then ContinueLoop
$iUpgradeAction += 2 ^ ($iz + 1)
Setlog("Dark Elixir used = " & $aUpgrades[$iz][2], $COLOR_BLUE)
$iNbrOfHeroesUpped += 1
$iCostDElixirHero += $aUpgrades[$iz][2]
UpdateStats()
$iAvailDark -= $aUpgrades[$iz][2]
$iAvailBldr -= 1
Case Else
Setlog("Something went wrong with loot type on Upgradebuilding module on #" & $iz + 1, $COLOR_RED)
ExitLoop
EndSwitch
$aUpgrades[$iz][7] = _NowCalc()
If $debugSetlog = 1 Then SetLog("Upgrade #" & $iz + 1 & " " & $aUpgrades[$iz][4] & " Started @ " & $aUpgrades[$iz][7], $COLOR_DEBUG)
$aArray = StringSplit($aUpgrades[$iz][6], ' ', BitOR($STR_CHRSPLIT, $STR_NOCOUNT))
If IsArray($aArray) Then
Local $iRemainingTimeMin = 0
For $i = 0 To UBound($aArray) - 1
$sTime = ""
Select
Case StringInStr($aArray[$i], "d", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += (Int($sTime) * 24 * 60) - 7
Case StringInStr($aArray[$i], "h", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += (Int($sTime) * 60) - 3
Case StringInStr($aArray[$i], "m", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime)
Case Else
Setlog("Upgrade #" & $iz + 1 & " OCR time invalid" & $aArray[$i], $COLOR_FUCHSIA)
EndSelect
If $debugSetlog = 1 Then Setlog("Upgrade Time: " & $aArray[$i] & ", Minutes= " & $iRemainingTimeMin, $COLOR_DEBUG)
Next
$aUpgrades[$iz][7] = _DateAdd('n', Floor($iRemainingTimeMin), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog("Upgrade #" & $iz + 1 & " " & $aUpgrades[$iz][4] & " Finishes @ " & $aUpgrades[$iz][7], $COLOR_GREEN)
GUICtrlSetData($txtUpgradeEndTime[$iz], $aUpgrades[$iz][7])
Else
Setlog("Non critical error processing upgrade time for " & "#" & $iz + 1 & ": " & $aUpgrades[$iz][4], $COLOR_FUCHSIA)
EndIf
Next
If $iUpgradeAction <= 0 Then
Setlog("No Upgrades Available", $COLOR_GREEN)
Else
saveConfig()
EndIf
If _Sleep($iDelayUpgradeBuilding2) Then Return
checkMainScreen(False)
Return $iUpgradeAction
EndFunc
Func UpgradeNormal($inum)
Local $aResult
ClickP($aAway, 1, 0, "#0211")
If _Sleep($iDelayUpgradeNormal1) Then Return
Click($aUpgrades[$inum][0], $aUpgrades[$inum][1], 1, 0, "#0296")
If _Sleep($iDelayUpgradeNormal1) Then Return
$aResult = BuildingInfo(242, 520 + $bottomOffsetY)
If StringStripWS($aResult[1], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) <> StringStripWS($aUpgrades[$inum][4], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) Then
SetLog("#" & $inum + 1 & ":" & $aUpgrades[$inum][4] & ": Not same as :" & $aResult[1] & ":? Retry now...", $COLOR_BLUE)
ClickP($aAway, 1, 0, "#0211")
If _Sleep($iDelayUpgradeNormal1) Then Return
Click($aUpgrades[$inum][0], $aUpgrades[$inum][1], 1, 0, "#0296")
If _Sleep($iDelayUpgradeNormal1) Then Return
$aResult = BuildingInfo(242, 520 + $bottomOffsetY)
If $aResult[0] > 1 Then
If StringStripWS($aResult[1], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) <> StringStripWS($aUpgrades[$inum][4], BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)) Then
SetLog("Found #" & $inum + 1 & ":" & $aUpgrades[$inum][4] & ": Not same as : " & $aResult[1] & ":, May need new location?", $COLOR_RED)
Return False
EndIf
EndIf
EndIf
If $aUpgrades[$inum][3] = "Gold" Then
Local $offColors[3][3] = [[0xD6714B, 47, 37], [0xF0E850, 70, 0], [0xF4F8F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 650 + $bottomOffsetY, 1, 1, Hex(0xF3F3F1, 6), $offColors, 30)
If $debugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Else
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 650 + $bottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If $debugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 38, $ButtonPixel[1] + 32, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
EndIf
If IsArray($ButtonPixel) Then
If _Sleep($iDelayUpgradeNormal2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0297")
If _Sleep($iDelayUpgradeNormal3) Then Return
If $debugImageSave = 1 Then DebugImageSave("UpgradeRegBtn1")
If _ColorCheck(_GetPixelColor(677, 150 + $midOffsetY, True), Hex(0xE00408, 6), 20) Then
If _ColorCheck(_GetPixelColor(459, 490 + $midOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(459, 494 + $midOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $midOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $aUpgrades[$inum][4] & ", No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0298")
Return False
Else
Click(440, 480 + $midOffsetY, 1, 0, "#0299")
If _Sleep($iDelayUpgradeNormal3) Then Return
If $debugImageSave = 1 Then DebugImageSave("UpgradeRegBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $midOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $aUpgrades[$inum][4] & " No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0300")
Return False
EndIf
SetLog("Upgrade #" & $inum + 1 & " " & $aUpgrades[$inum][4] & " started", $COLOR_GREEN)
GUICtrlSetImage($picUpgradeStatus[$inum], $pIconLib, $eIcnGreenLight)
$ipicUpgradeStatus[$inum] = $eIcnGreenLight
GUICtrlSetData($txtUpgradeValue[$inum], -($aUpgrades[$inum][2]))
GUICtrlSetData($txtUpgradeLevel[$inum], $aUpgrades[$inum][5] & "+")
$itxtUpgradeLevel[$inum] = $aUpgrades[$inum][5] & "+"
If $ichkUpgrdeRepeat[$inum] = 0 Then
GUICtrlSetState($chkbxUpgrade[$inum], $GUI_UNCHECKED)
$ichkbxUpgrade[$inum] = 0
$aUpgrades[$inum][0] = -1
$aUpgrades[$inum][1] = -1
$aUpgrades[$inum][3] = ""
GUICtrlSetData($txtUpgradeLevel[$inum], $aUpgrades[$inum][5] & "+")
$aUpgrades[$inum][5] = $aUpgrades[$inum][5] & "+"
ElseIf $ichkUpgrdeRepeat[$inum] = 1 Then
GUICtrlSetState($chkbxUpgrade[$inum], $GUI_CHECKED)
$ichkbxUpgrade[$inum] = 1
EndIf
ClickP($aAway, 2, 0, "#0301")
If _Sleep($iDelayUpgradeNormal3) Then Return
Return True
EndIf
ElseIf _ColorCheck(_GetPixelColor(721, 118 + $midOffsetY, True), Hex(0xDF0408, 6), 20) Then
If _ColorCheck(_GetPixelColor(459, 490 + $midOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(459, 494 + $midOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(459, 498 + $midOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $aUpgrades[$inum][4] & ", No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0298")
Return False
Else
Click(670, 510 + $midOffsetY, 1, 0, "#0299")
If _Sleep($iDelayUpgradeNormal3) Then Return
If $debugImageSave = 1 Then DebugImageSave("UpgradeRegBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $midOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $aUpgrades[$inum][4] & " No Loot!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0300")
Return False
EndIf
SetLog("Upgrade #" & $inum + 1 & " " & $aUpgrades[$inum][4] & " started", $COLOR_GREEN)
GUICtrlSetImage($picUpgradeStatus[$inum], $pIconLib, $eIcnGreenLight)
$ipicUpgradeStatus[$inum] = $eIcnGreenLight
GUICtrlSetData($txtUpgradeValue[$inum], -($aUpgrades[$inum][2]))
GUICtrlSetData($txtUpgradeLevel[$inum], $aUpgrades[$inum][5] & "+")
$itxtUpgradeLevel[$inum] = $aUpgrades[$inum][5] & "+"
If $ichkUpgrdeRepeat[$inum] = 0 Then
GUICtrlSetState($chkbxUpgrade[$inum], $GUI_UNCHECKED)
$ichkbxUpgrade[$inum] = 0
$aUpgrades[$inum][0] = -1
$aUpgrades[$inum][1] = -1
$aUpgrades[$inum][3] = ""
GUICtrlSetData($txtUpgradeLevel[$inum], $aUpgrades[$inum][5] & "+")
$aUpgrades[$inum][5] = $aUpgrades[$inum][5] & "+"
ElseIf $ichkUpgrdeRepeat[$inum] = 1 Then
GUICtrlSetState($chkbxUpgrade[$inum], $GUI_CHECKED)
$ichkbxUpgrade[$inum] = 1
EndIf
ClickP($aAway, 2, 0, "#0301")
If _Sleep($iDelayUpgradeNormal3) Then Return
Return True
EndIf
Else
Setlog("Upgrade #" & $inum + 1 & " window open fail", $COLOR_RED)
ClickP($aAway, 2, 0, "#0302")
EndIf
Else
Setlog("Upgrade #" & $inum + 1 & " Error finding button", $COLOR_RED)
ClickP($aAway, 2, 0, "#0303")
Return False
EndIf
EndFunc
Func UpgradeHero($inum)
Click($aUpgrades[$inum][0], $aUpgrades[$inum][1], 1, 0, "#0304")
If _Sleep($iDelayUpgradeHero1) Then Return
Local $offColors[3][3] = [[0x9B4C28, 41, 23], [0x040009, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 620 + $bottomOffsetY, 1, 1, Hex(0xF6F9F3, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($iDelayUpgradeHero3) Then Return
If $debugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(715, 120 + $midOffsetY, True), Hex(0xE1090E, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $midOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $midOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $midOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Hero Upgrade Fail #" & $inum + 1 & " " & $aUpgrades[$inum][4] & " No DE!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0306")
Return False
Else
Click(660, 515 + $midOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($iDelayUpgradeHero1) Then Return
If $debugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $midOffsetY, True), Hex(0xE1090E, 6), 20) Then
SetLog("Upgrade Fail #" & $inum + 1 & " " & $aUpgrades[$inum][4] & " No DE!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0309")
Return False
EndIf
SetLog("Hero Upgrade #" & $inum + 1 & " " & $aUpgrades[$inum][4] & " started", $COLOR_GREEN)
GUICtrlSetImage($picUpgradeStatus[$inum], $pIconLib, $eIcnGreenLight)
$ipicUpgradeStatus[$inum] = $eIcnGreenLight
GUICtrlSetData($txtUpgradeValue[$inum], -($aUpgrades[$inum][2]))
GUICtrlSetData($txtUpgradeLevel[$inum], $aUpgrades[$inum][5] & "+")
$itxtUpgradeLevel[$inum] = $aUpgrades[$inum][5] & "+"
If $ichkUpgrdeRepeat[$inum] = 0 Then
GUICtrlSetState($chkbxUpgrade[$inum], $GUI_UNCHECKED)
$ichkbxUpgrade[$inum] = 0
$aUpgrades[$inum][0] = -1
$aUpgrades[$inum][1] = -1
$aUpgrades[$inum][3] = ""
GUICtrlSetData($txtUpgradeLevel[$inum], $aUpgrades[$inum][5] & "+")
$aUpgrades[$inum][5] = $aUpgrades[$inum][5] & "+"
ElseIf $ichkUpgrdeRepeat[$inum] = 1 Then
GUICtrlSetState($chkbxUpgrade[$inum], $GUI_CHECKED)
$ichkbxUpgrade[$inum] = 1
EndIf
ClickP($aAway, 2, 0, "#0310")
If _Sleep($iDelayUpgradeHero2) Then Return
Return True
EndIf
Else
Setlog("Upgrade #" & $inum + 1 & " window open fail", $COLOR_RED)
ClickP($aAway, 2, 0, "#0311")
EndIf
Else
Setlog("Upgrade #" & $inum + 1 & " Error finding button", $COLOR_RED)
ClickP($aAway, 2, 0, "#0312")
Return False
EndIf
EndFunc
Func SetlogUpgradeValues($i)
Local $j
For $j = 0 To UBound($aUpgrades, 2) - 1
Setlog("$aUpgrades[" & $i & "][" & $j & "]= " & $aUpgrades[$i][$j], $COLOR_DEBUG)
Next
Setlog("$chkbxUpgrade= " & $ichkbxUpgrade[$i], $COLOR_DEBUG)
Setlog("$txtUpgradeName= " & $aUpgrades[$i][4], $COLOR_DEBUG)
Setlog("$txtUpgradeLevel= " & $itxtUpgradeLevel[$i], $COLOR_DEBUG)
Setlog("$picUpgradeType= " & $ipicUpgradeStatus[$i], $COLOR_DEBUG)
Setlog("$txtUpgradeValue= " & $aUpgrades[$i][2], $COLOR_DEBUG)
Setlog("$txtUpgradeTime= " & $aUpgrades[$i][6], $COLOR_DEBUG)
Setlog("$txtUpgradeEndTime= " & $aUpgrades[$i][7], $COLOR_DEBUG)
Setlog("$chkUpgrdeRepeat= " & $ichkUpgrdeRepeat, $COLOR_DEBUG)
EndFunc
Func UpgradeWall()
If $ichkWalls = 1 Then
Local $Flag = 1
SetLog("Checking Upgrade Walls", $COLOR_BLUE)
Do
checkMainScreen(False)
VillageReport(True, True)
If SkipWallUpgrade() Then Return
If $iFreeBuilderCount > 0 Then
ClickP($aAway, 1, 0, "#0313")
VillageReport(true,false)
Local $MinWallGold = Number($iGoldCurrent - $WallCost) > Number($itxtWallMinGold)
Local $MinWallElixir = Number($iElixirCurrent - $WallCost) > Number($itxtWallMinElixir)
Switch $iUseStorage
Case 0
If $MinWallGold Then
SetLog("Upgrading Wall using Gold", $COLOR_GREEN)
$Flag = 1
If CheckWall() Then UpgradeWallGold()
Else
SetLog("Gold is below minimum, Skipping Upgrade", $COLOR_RED)
$Flag = 0
EndIf
Case 1
If $MinWallElixir Then
Setlog("Upgrading Wall using Elixir", $COLOR_GREEN)
$Flag = 1
If CheckWall() Then UpgradeWallElixir()
Else
Setlog("Elixir is below minimum, Skipping Upgrade", $COLOR_RED)
$Flag = 0
EndIf
Case 2
If $MinWallElixir Then
SetLog("Upgrading Wall using Elixir", $COLOR_GREEN)
$Flag = 1
If CheckWall() And Not UpgradeWallElixir() Then
SetLog("Upgrade with Elixir failed, attempt to upgrade using Gold", $COLOR_RED)
$Flag = 1
UpgradeWallGold()
EndIf
Else
SetLog("Elixir is below minimum, attempt to upgrade using Gold", $COLOR_RED)
If $MinWallGold Then
$Flag = 1
If CheckWall() Then UpgradeWallGold()
Else
Setlog("Gold is below minimum, Skipping Upgrade", $COLOR_RED)
$Flag = 0
EndIf
EndIf
EndSwitch
ClickP($aAway, 1, 0, "#0314")
If _Sleep(100) Then Return
Click(820, 40, 1, 0, "#0315")
Else
SetLog("No free builder, Upgrade Walls skipped..", $COLOR_RED)
$Flag = 0
EndIf
If $ichkUpgradeContinually = 0 Then $Flag = 0
Until $Flag = 0
EndIf
If _Sleep($iDelayUpgradeWall1) Then Return
checkMainScreen(False)
EndFunc
Func UpgradeWallGold()
If _Sleep($iDelayUpgradeWallGold1) Then Return
Local $offColors[3][3] = [[0xD6714B, 47, 37], [0xF0E850, 70, 0], [0xF4F8F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 650 + $bottomOffsetY, 1, 1, Hex(0xF3F3F1, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 47, $ButtonPixel[1] + 37, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 70, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0316")
If _Sleep($iDelayUpgradeWallGold2) Then Return
If _ColorCheck(_GetPixelColor(677, 150 + $midOffsetY, True), Hex(0xE1090E, 6), 20) Then
If isNoUpgradeLoot(False) = True Then
SetLog("Upgrade stopped due no loot", $COLOR_RED)
Return False
EndIf
Click(440, 480 + $midOffsetY, 1, 0, "#0317")
If _Sleep($iDelayUpgradeWallGold3) Then Return
SetLog("Upgrade complete", $COLOR_GREEN)
PushMsg("UpgradeWithGold")
$iNbrOfWallsUppedGold += 1
$iNbrOfWallsUpped += 1
$iCostGoldWall += $WallCost
UpdateStats()
Return True
EndIf
Else
Setlog("No Upgrade Gold Button", $COLOR_RED)
Pushmsg("NoUpgradeWallButton")
Return False
EndIf
EndFunc
Func UpgradeWallElixir()
If _Sleep($iDelayUpgradeWallElixir1) Then Return
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 650 + $bottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0322")
If _Sleep($iDelayUpgradeWallElixir2) Then Return
If _ColorCheck(_GetPixelColor(677, 150 + $midOffsetY, True), Hex(0xE1090E, 6), 20) Then
If isNoUpgradeLoot(False) = True Then
SetLog("Upgrade stopped due to insufficient loot", $COLOR_RED)
Return False
EndIf
Click(440, 480 + $midOffsetY, 1, 0, "#0318")
If _Sleep($iDelayUpgradeWallElixir3) Then Return
SetLog("Upgrade complete", $COLOR_GREEN)
PushMsg("UpgradeWithElixir")
$iNbrOfWallsUppedElixir += 1
$iNbrOfWallsUpped += 1
$iCostElixirWall += $WallCost
UpdateStats()
Return True
EndIf
Else
Setlog("No Upgrade Elixir Button", $COLOR_RED)
PushMsg("NoUpgradeElixirButton")
Return False
EndIf
EndFunc
Func SkipWallUpgrade()
If _Sleep(500) Then Return
checkMainScreen(False)
If $Restart = True Then Return
InireadS($iUseStorage, $config, "upgrade", "use-storage", "0")
Local $iUpgradeAction = 0
Local $BuildingsNeedGold = 0
Local $BuildingsNeedElixir = 0
If getBuilderCount() = False Then Return True
If _Sleep($iDelayRespond) Then Return True
For $iz = 0 To UBound($aUpgrades, 1) - 1
If $ichkbxUpgrade[$iz] = 1 Then $iUpgradeAction += 1
Next
If $iFreeBuilderCount > $iSaveWallBldr And $iUpgradeAction > 0 Then
For $iz = 0 To UBound($aUpgrades, 1) - 1
Switch $aUpgrades[$iz][3]
Case "Gold"
$BuildingsNeedGold += 1
Case "Elixir"
$BuildingsNeedElixir += 1
EndSwitch
Next
If $BuildingsNeedGold > 0 And $BuildingsNeedElixir > 0 Then
SetLog("A Builder is available for Building Upgrade Skipping Wall upgrade", $COLOR_RED)
Return True
ElseIf $BuildingsNeedGold = 0 And $BuildingsNeedElixir = 0 Then
Else
Switch $iUseStorage
Case 0
If $BuildingsNeedGold > 0 Then
SetLog("A Builder is available for Building Upgrade Skipping Wall upgrade", $COLOR_RED)
Return True
EndIf
Case 1
If $BuildingsNeedElixir > 0 Then
SetLog("A Builder is available for Building Upgrade Skipping Wall upgrade", $COLOR_RED)
Return True
EndIf
Case 2
If $BuildingsNeedGold > 0 Then
Setlog("A Building needs Gold to Upgrade", $COLOR_GREEN)
Setlog("Using Elixir only for wall Upgrade", $COLOR_GREEN)
$iUseStorage = 1
EndIf
If $BuildingsNeedElixir > 0 Then
Setlog("A Building needs Elixir to Upgrade", $COLOR_GREEN)
Setlog("Using Gold only for wall Upgrade", $COLOR_GREEN)
$iUseStorage = 0
EndIf
EndSwitch
EndIf
EndIf
Local $MinWallElixir = Number($iElixirCurrent - $WallCost) > Number($iLaboratoryElixirCost)
If $ichkLab = 1 And $icmbLaboratory >= 1 And $icmbLaboratory <= 15 And $MinWallElixir = False Then
For $i = 1 To 15
If $icmbLaboratory = $i Then
Local $name = $aLabTroops[$i][3]
ExitLoop
EndIf
Next
Switch $iUseStorage
Case 0
Case 1
Setlog("Laboratory needs Elixir to Upgrade :  " & $name, $COLOR_GREEN)
Setlog("Skipping Wall Upgrade", $COLOR_GREEN)
PushMsg("NoUpgradeWallButton")
Return True
Case 2
Setlog("Laboratory needs Elixir to Upgrade :  " & $name, $COLOR_GREEN)
Setlog("Using Gold only for wall Upgrade  " & $name, $COLOR_GREEN)
$iUseStorage = 0
EndSwitch
EndIf
PushMsg("SkipWalls")
EndFunc
Func _RemoteControl()
If $NotifyRemoteEnable = 1 Then NotifyRemoteControlPushBullet()
EndFunc
Func ReportNotify()
If $NotifyAlertVillageReport = 1 Then
NotifylPushBulletMessage($NotifyOrigin & ":" & "\n" & " [" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldCurrent) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirCurrent) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($iDarkCurrent) & "  [" & GetTranslated(620,112, "T") & "]: " & _NumberFormat($iTrophyCurrent) & " [" & GetTranslated(620,44, "No. of Free Builders") & "]: " & _NumberFormat($iFreeBuilderCount))
EndIf
If $NotifyAlertLastAttack = 1 Then
If Not ($iGoldLast = "" And $iElixirLast = "") Then NotifylPushBulletMessage($NotifyOrigin & " | Last Gain :" & "\n" & " [" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldLast) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirLast) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($iDarkLast) & "  [" & GetTranslated(620,112, "T") & "]: " & _NumberFormat($iTrophyLast))
EndIf
If _Sleep($iDelayReportPushBullet1) Then Return
checkMainScreen(False)
EndFunc
Func _DeletePush()
NotifyDeletePushBullet()
SetLog("Delete all previous PushBullet messages...", $COLOR_BLUE)
EndFunc
Func PushMsg($Message, $Source = "")
NotifyPushMessageToBoth($Message, $Source)
EndFunc
Func _DeleteOldPushes()
NotifyDeleteOldPushesFromPushBullet()
EndFunc
Func _GetDateFromUnix($nPosix)
Local $nYear = 1970, $nMon = 1, $nDay = 1, $nHour = 00, $nMin = 00, $nSec = 00, $aNumDays = StringSplit("31,28,31,30,31,30,31,31,30,31,30,31", ",")
While 1
If (Mod($nYear + 1, 400) = 0) Or (Mod($nYear + 1, 4) = 0 And Mod($nYear + 1, 100) <> 0) Then
If $nPosix < 31536000 + 86400 Then ExitLoop
$nPosix -= 31536000 + 86400
$nYear += 1
Else
If $nPosix < 31536000 Then ExitLoop
$nPosix -= 31536000
$nYear += 1
EndIf
WEnd
While $nPosix > 86400
$nPosix -= 86400
$nDay += 1
WEnd
While $nPosix > 3600
$nPosix -= 3600
$nHour += 1
WEnd
While $nPosix > 60
$nPosix -= 60
$nMin += 1
WEnd
$nSec = $nPosix
For $i = 1 To 12
If $nDay < $aNumDays[$i] Then ExitLoop
$nDay -= $aNumDays[$i]
$nMon += 1
Next
Return $nYear & "-" & $nMon & "-" & $nDay & " " & $nHour & ":" & $nMin & ":" & StringFormat("%02i", $nSec)
EndFunc
Func NotifyRemoteControlPushBullet()
If ($NotifyPBEnabled = 0 And $NotifyTGEnabled = 0) Or $NotifyRemoteEnable = 0 Then Return
If $NotifyPBEnabled = 1 And $NotifyPBToken <> "" Then
$oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
Local $pushbulletApiUrl
If $pushLastModified = 0 Then
$pushbulletApiUrl = "https://api.pushbullet.com/v2/pushes?active=true&limit=1"
Else
$pushbulletApiUrl = "https://api.pushbullet.com/v2/pushes?active=true&modified_after=" & $pushLastModified
EndIf
$oHTTP.Open("Get", $pushbulletApiUrl, False)
$access_token = $NotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
$Result = $oHTTP.ResponseText
Local $modified = _StringBetween($Result, '"modified":', ',', "", False)
If UBound($modified) > 0 Then
$pushLastModified = Number($modified[0])
$pushLastModified -= 120
EndIf
Local $findstr = StringRegExp(StringUpper($Result), '"BODY":"BOT')
If $findstr = 1 Then
Local $body = _StringBetween($Result, '"body":"', '"', "", False)
Local $iden = _StringBetween($Result, '"iden":"', '"', "", False)
For $x = UBound($body) - 1 To 0 Step -1
If $body <> "" Or $iden <> "" Then
$body[$x] = StringUpper(StringStripWS($body[$x], $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES))
$iden[$x] = StringStripWS($iden[$x], $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES)
$NotifyForced = 1
Switch $body[$x]
Case GetTranslated(620,1, "BOT") & " " & GetTranslated(620,4, "HELP")
Local $txtHelp = "PushBullet " & GetTranslated(620,2,"Help") & " " & GetTranslated(620,3, " - You can remotely control your bot sending COMMANDS from the following list:")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & GetTranslated(620,4, -1) & GetTranslated(620,5, " - send this help message")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & GetTranslated(620,7,"DELETE") & GetTranslated(620,8, " - delete all your previous PushBullet messages")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,9,"RESTART") & GetTranslated(620,10, " - restart the Emulator and bot named") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,11,"STOP") & GetTranslated(620,12, " - stop the bot named") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,13,"PAUSE") & GetTranslated(620,14, " - pause the bot named") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,15,"RESUME") & GetTranslated(620,16, " - resume the bot named") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,17,"STATS") & GetTranslated(620,18, " - send Village Statistics of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,19,"LOG") & GetTranslated(620,20, " - send the current log file of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,21,"LASTRAID") & GetTranslated(620,22, " - send the last raid loot screenshot of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,23,"LASTRAIDTXT") & GetTranslated(620,24, " - send the last raid loot values of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,25,"SCREENSHOT") & GetTranslated(620,26, " - send a screenshot of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,27,"SCREENSHOTHD") & GetTranslated(620,28, " - send a screenshot in high resolution of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,29,"BUILDER") & GetTranslated(620,30, " - send a screenshot of builder status of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,31,"SHIELD") & GetTranslated(620,32, " - send a screenshot of shield status of") & " <" & $NotifyOrigin & ">"
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,33,"RESETSTATS") & GetTranslated(620,34, " - reset Village Statistics")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,35,"TROOPS") & GetTranslated(620,36, " - send Troops & Spells Stats")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,37,"HALTATTACKON") & GetTranslated(620,39, " - Turn On 'Halt Attack' in the 'Misc' Tab with the 'stay online' option")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,40,"HALTATTACKOFF") & GetTranslated(620,42, " - Turn Off 'Halt Attack' in the 'Misc' Tab")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,43,"HIBERNATE") & GetTranslated(620,44, " - Hibernate host PC")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,46,"SHUTDOWN") & GetTranslated(620,48, " - Shut down host PC")
$txtHelp &= "\n" & GetTranslated(620,1, -1) & " <" & $NotifyOrigin & "> " & GetTranslated(620,50,"STANDBY") & GetTranslated(620,51, " - Standby host PC")
$txtHelp &= '\n'
$txtHelp &= '\n' & GetTranslated(620,98, "Examples:")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & $NotifyOrigin & " " & GetTranslated(620,17,"STATS")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & GetTranslated(620,29,"BUILDER")
$txtHelp &= '\n' & GetTranslated(620,1, -1) & " " & $NotifyOrigin & " " & GetTranslated(620,27,"SCREENSHOTHD")
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,100, "Request for Help") & "\n" & $txtHelp)
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,702,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,703,"Help has been sent"), $COLOR_GREEN)
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & GetTranslated(620,7,"DELETE")
NotifyDeletePushBullet()
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,704, "Your request has been received."), $COLOR_GREEN)
Case GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & GetTranslated(620,9,"RESTART")
NotifyDeleteMessageFromPushBullet($iden[$x])
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,705, "Your request has been received. Bot and Android Emulator restarting..."), $COLOR_GREEN)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,165, "Request to Restart") & "...\n" & GetTranslated(620,132, "Your bot and Emulator are now restarting") & "...")
SaveConfig()
_Restart()
Case GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & GetTranslated(620,11,"STOP")
NotifyDeleteMessageFromPushBullet($iden[$x])
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,706, "Your request has been received. Bot is now stopped"), $COLOR_GREEN)
If $Runstate = True Then
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,124, "Request to Stop") & "..." & "\n" & GetTranslated(620,133, "Your bot is now stopping") & "...")
btnStop()
Else
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,124, "Request to Stop") & "..." & "\n" & GetTranslated(620,134, "Your bot is currently stopped, no action was taken"))
EndIf
Case GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & GetTranslated(620,13,"PAUSE")
If $TPaused = False And $Runstate = True Then
If ( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = False And IsAttackPage() Then
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,707, "Unable to pause during attack"), $COLOR_RED)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,166, "Request to Pause") & "\n" & GetTranslated(620,164, "Unable to pause during attack, try again later."))
ElseIf ( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = True And IsAttackPage() Then
ReturnHome(False, False)
$Is_SearchLimit = True
$Is_ClientSyncError = False
UpdateStats()
$Restart = True
TogglePauseImpl("Push")
Else
TogglePauseImpl("Push")
EndIf
Else
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,708,"Your bot is currently paused, no action was taken"), $COLOR_GREEN)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,166, "Request to Pause") & "\n" & GetTranslated(620,150, "Your bot is currently paused, no action was taken"))
EndIf
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & GetTranslated(620,15,"RESUME")
If $TPaused = True And $Runstate = True Then
TogglePauseImpl("Push")
Else
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,709,"Your bot is currently resumed, no action was taken"), $COLOR_GREEN)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,167, "Request to Resume") & "\n" & GetTranslated(620,130, "Your bot is currently resumed, no action was taken"))
EndIf
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & GetTranslated(620,17,"STATS")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,710,"Your request has been received. Statistics sent"), $COLOR_GREEN)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,108, "Stats Village Report") & "\n" & GetTranslated(620,148, "At Start") & "\n[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldStart) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirStart) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($iDarkStart) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyStart & "\n\n" & GetTranslated(620,114, "Now (Current Resources)") &"\n[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldCurrent) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirCurrent) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($iDarkCurrent) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyCurrent & " [" & GetTranslated(620,121, "GEM") & "]: " & $iGemAmount & "\n \n [" & GetTranslated(620,105, "No. of Free Builders") & "]: " & $iFreeBuilderCount & "\n [" & GetTranslated(620,117, "No. of Wall Up") & "]: " & GetTranslated(620,109, "G") & ": " & $iNbrOfWallsUppedGold & "/ " & GetTranslated(620,110, "E") & ": " & $iNbrOfWallsUppedElixir & "\n\n" & GetTranslated(620,116, "Attacked") & ": " & GUICtrlRead($lblresultvillagesattacked) & "\n" & GetTranslated(620,115, "Skipped") & ": " & $iSkippedVillageCount)
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & GetTranslated(620,19,"LOG")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,711,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,712,"Log is now sent"), $COLOR_GREEN)
NotifyPushFileToPushBullet($sLogFName, GetTranslated(620,101, "logs"), "text/plain; charset=utf-8", $NotifyOrigin & " | " & GetTranslated(620,102, "Current Log") & " \n")
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & GetTranslated(620,21,"LASTRAID")
If $AttackFile <> "" Then
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,713,"Push Last Raid Snapshot..."), $COLOR_GREEN)
NotifyPushFileToPushBullet($AttackFile, GetTranslated(620,120, "Loots"), "image/jpeg", $NotifyOrigin & " | " & GetTranslated(620,118, "Last Raid") & " \n" & $AttackFile)
Else
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,131, "There is no last raid screenshot") & ".")
SetLog(GetTranslated(620,141,"There is no last raid screenshot."))
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,714,"Your request has been received. Last Raid txt sent"), $COLOR_GREEN)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,119, "Last Raid txt") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldLast) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirLast) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($iDarkLast) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyLast)
EndIf
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & GetTranslated(620,23,"LASTRAIDTXT")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,714,"Your request has been received. Last Raid txt sent"), $COLOR_GREEN)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,119, "Last Raid txt") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldLast) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirLast) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($iDarkLast) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyLast)
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & GetTranslated(620,25,"SCREENSHOT")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,715,"ScreenShot request received"), $COLOR_GREEN)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,147,"Chief, your request for Screenshot will be processed ASAP"))
$PBRequestScreenshot = 1
$NotifyForced = 0
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,27,"SCREENSHOTHD")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,716,"ScreenShot HD request received"), $COLOR_GREEN)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,147,"Chief, your request for Screenshot will be processed ASAP"))
$PBRequestScreenshot = 1
$PBRequestScreenshotHD = 1
$NotifyForced = 0
NotifyDeleteMessageFromPushBullet($iden[$x])
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,29,"BUILDER")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,717,"Builder Status request received"), $COLOR_GREEN)
$PBRequestBuilderInfo = 1
NotifyDeleteMessageFromPushBullet($iden[$x])
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,137,"Chief, your request for Builder Info will be processed ASAP"))
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,31,"SHIELD")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,718,"Shield Status request received"), $COLOR_GREEN)
$PBRequestShieldInfo = 1
$NotifyForced = 0
NotifyDeleteMessageFromPushBullet($iden[$x])
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,139,"Chief, your request for Shield Info will be processed ASAP"))
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,33,"RESETSTATS")
btnResetStats()
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,719,"Your request has been received. Statistics resetted"), $COLOR_GREEN)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,135,"Statistics resetted."))
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,35,"TROOPS")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,720,"Your request has been received. Sending Troop/Spell Stats..."), $COLOR_GREEN)
Local $txtTroopStats = " | " & GetTranslated(620,136,"Troops/Spells set to Train") & ":\n" & "Barbs:" & $BarbComp & " Arch:" & $ArchComp & " Gobl:" & $GoblComp
$txtTroopStats &= "\n" & "Giant:" & $GiantComp & " WallB:" & $WallComp & " Wiza:" & $WizaComp
$txtTroopStats &= "\n" & "Balloon:" & $BallComp & " Heal:" & $HealComp & " Dragon:" & $DragComp & " Pekka:" & $PekkComp
$txtTroopStats &= "\n" & "Mini:" & $MiniComp & " Hogs:" & $HogsComp & " Valks:" & $ValkComp
$txtTroopStats &= "\n" & "Golem:" & $GoleComp & " Witch:" & $WitcComp & " Lava:" & $LavaComp
$txtTroopStats &= "\n" & "LSpell:" & $LSpellComp & " HeSpell:" & $HSpellComp & " RSpell:" & $RSpellComp & " JSpell:" & $JSpellComp
$txtTroopStats &= "\n" & "FSpell:" & $FSpellComp & " PSpell:" & $PSpellComp & " ESpell:" & $ESpellComp & " HaSpell:" & $HaSpellComp & "\n"
$txtTroopStats &= "\n" & GetTranslated(620,168,"Current Trained Troops & Spells") & ":"
For $i = 0 to Ubound($NotifyTroopSpellStats)-1
If $NotifyTroopSpellStats[$i][0] <> "" Then
$txtTroopStats &= "\n" & $NotifyTroopSpellStats[$i][0] & ":" & $NotifyTroopSpellStats[$i][1]
EndIf
Next
$txtTroopStats &= "\n\n" & GetTranslated(620,169,"Current Army Camp") & ": " & $CurCamp & "/" & $TotalCamp
NotifyPushToPushBullet($NotifyOrigin & $txtTroopStats)
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,37,"HALTATTACKON")
GUICtrlSetState($chkBotStop, $GUI_CHECKED)
btnStop()
$ichkBotStop = 1
$icmbBotCond = 18
btnStart()
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,40,"HALTATTACKOFF")
GUICtrlSetState($chkBotStop, $GUI_UNCHECKED)
btnStop()
btnStart()
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,43,"HIBERNATE")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,702,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,721,"Hibernate PC"), $COLOR_GREEN)
NotifyPushToPushBullet(GetTranslated(620,45,"PC Hibernate sequence initiated"))
Shutdown(64)
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,46,"SHUTDOWN")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,702,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,722,"Shutdown PC"), $COLOR_GREEN)
NotifyPushToPushBullet(GetTranslated(620,49,"PC Shutdown sequence initiated"))
Shutdown(5)
Case GetTranslated(620,1, -1) & " " &  StringUpper($NotifyOrigin) & " " & GetTranslated(620,50,"STANDBY")
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,702,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,723,"Standby PC"), $COLOR_GREEN)
NotifyPushToPushBullet(GetTranslated(620,52,"PC Standby sequence initiated"))
Shutdown(32)
Case Else
Local $lenstr = StringLen(GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & "")
Local $teststr = StringLeft($body[$x], $lenstr)
If $teststr = (GetTranslated(620,1, -1) & " " & StringUpper($NotifyOrigin) & " " & "") Then
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,724,"received command syntax wrong, command ignored."), $COLOR_RED)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,97, "Command not recognized") & "\n" & GetTranslated(620,99, "Please push BOT HELP to obtain a complete command list."))
NotifyDeleteMessageFromPushBullet($iden[$x])
EndIf
EndSwitch
$body[$x] = ""
$iden[$x] = ""
$NotifyForced = 0
EndIf
Next
EndIf
EndIf
If $NotifyTGEnabled = 1 And $NotifyTGToken <> ""  Then
$TGLastMessage = NotifyGetLastMessageFromTelegram()
If $TGLastMessage = "\/start" And $TGLastRemote <> $TGLast_UID Then
$TGLastRemote = $TGLast_UID
NotifyActivateKeyboardOnTelegram("\ud83d\udc19 Telegram Revamp v1.4 by DocOc Team")
Else
Local $body2 = StringUpper(StringStripWS($TGLastMessage, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES))
If $TGLastRemote <> $TGLast_UID Then
$TGLastRemote = $TGLast_UID
Switch $body2
Case GetTranslated(620,4,"HELP"), '\U2753 ' & GetTranslated(620,4,"HELP")
Local $txtHelp =  "Telegram " & GetTranslated(620,2,"Help") & " " & GetTranslated(620,3, " - You can remotely control your bot sending COMMANDS from the following list:")
$txtHelp &= '\n' & GetTranslated(620,4, -1) & GetTranslated(620,5, " - send this help message")
$txtHelp &= '\n' & GetTranslated(620,9,"RESTART") & GetTranslated(620,10, " - restart the Emulator and bot named") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,11,"STOP") & GetTranslated(620,12, " - stop the bot named") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,13,"PAUSE") & GetTranslated(620,14, " - pause the bot named") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,15,"RESUME") & GetTranslated(620,16, " - resume the bot named") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,17,"STATS") & GetTranslated(620,18, " - send Village Statistics of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,19,"LOG") & GetTranslated(620,20, " - send the current log file of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,21,"LASTRAID") & GetTranslated(620,22, " - send the last raid loot screenshot of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,23,"LASTRAIDTXT") & GetTranslated(620,24, " - send the last raid loot values of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,25,"SCREENSHOT") & GetTranslated(620,26, " - send a screenshot of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,27,"SCREENSHOTHD") & GetTranslated(620,28, " - send a screenshot in high resolution of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,29,"BUILDER") & GetTranslated(620,30, " - send a screenshot of builder status of") & " <" & $NotifyOrigin & ">"
$txtHelp &= '\n' & GetTranslated(620,31,"SHIELD") & GetTranslated(620,32, " - send a screenshot of shield status of") & " <" & $NotifyOrigin & ">"
$txtHelp &= "\n" & GetTranslated(620,33,"RESETSTATS") & GetTranslated(620,34, " - reset Village Statistics")
$txtHelp &= "\n" & GetTranslated(620,35,"TROOPS") & GetTranslated(620,36, " - send Troops & Spells Stats")
$txtHelp &= "\n" & GetTranslated(620,37,"HALTATTACKON") & GetTranslated(620,39, " - Turn On 'Halt Attack' in the 'Misc' Tab with the 'stay online' option")
$txtHelp &= "\n" & GetTranslated(620,40,"HALTATTACKOFF") & GetTranslated(620,42, " - Turn Off 'Halt Attack' in the 'Misc' Tab")
$txtHelp &= "\n" & GetTranslated(620,43,"HIBERNATE") & GetTranslated(620,44, " - Hibernate host PC")
$txtHelp &= "\n" & GetTranslated(620,46,"SHUTDOWN") & GetTranslated(620,48, " - Shut down host PC")
$txtHelp &= "\n" & GetTranslated(620,50,"STANDBY") & GetTranslated(620,51, " - Standby host PC")
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,100,"Request for Help") & "\n" & $txtHelp)
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,702,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,703,"Help has been sent"), $COLOR_GREEN)
Case GetTranslated(620,9,"RESTART"), '\UD83D\UDD01 ' & GetTranslated(620,9,"RESTART")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,704, "Your request has been received."), $COLOR_GREEN)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,165,"Request to Restart") & "...\n" & GetTranslated(620,143,"Your bot and Emulator are now restarting..."))
SaveConfig()
_Restart()
Case GetTranslated(620,11,"STOP"), '\U25AA ' & GetTranslated(620,11,"Stop")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,706, "Your request has been received. Bot is now stopped"), $COLOR_GREEN)
If $Runstate = True Then
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,125,"Request to Stop...") & "\n" & GetTranslated(620,126,"Your bot is now stopping..."))
btnStop()
Else
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,125,"Request to Stop...") & "\n" & GetTranslated(620,127,"Your bot is currently stopped, no action was taken"))
EndIf
Case GetTranslated(620,13,"PAUSE"), '\UD83D\UDD00 ' & GetTranslated(620,13,"PAUSE")
If $TPaused = False And $Runstate = True Then
If ( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = False And IsAttackPage() Then
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,707, "Unable to pause during attack"), $COLOR_RED)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,166,"Request to Pause") & "\n" & GetTranslated(620,138,"Unable to pause during attack, try again later."))
ElseIf ( _ColorCheck(_GetPixelColor($NextBtn[0], $NextBtn[1], True), Hex($NextBtn[2], 6), $NextBtn[3])) = True And IsAttackPage() Then
ReturnHome(False, False)
$Is_SearchLimit = True
$Is_ClientSyncError = True
$Restart = True
TogglePauseImpl("Push")
Return True
Else
TogglePauseImpl("Push")
EndIf
Else
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,708,"Your bot is currently paused, no action was taken"), $COLOR_GREEN)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,166,"Request to Pause") & "\n" & GetTranslated(620,150,"Your bot is currently paused, no action was taken"))
EndIf
Case GetTranslated(620,15,"RESUME"), '\U25B6 ' & GetTranslated(620,15,"RESUME")
If $TPaused = True And $Runstate = True Then
TogglePauseImpl("Push")
Else
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,709,"Your bot is currently resumed, no action was taken"), $COLOR_GREEN)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,167,"Request to Resume") & "\n" & GetTranslated(620,151,"Your bot is currently resumed, no action was taken"))
EndIf
Case GetTranslated(620,17,"STATS"), '\UD83D\UDCC8 ' & GetTranslated(620,17,"STATS")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,710,"Your request has been received. Statistics sent"), $COLOR_GREEN)
Local $GoldGainPerHour = "0 /h"
Local $ElixirGainPerHour = "0 /h"
Local $DarkGainPerHour = "0 /h"
Local $TrophyGainPerHour = "0 /h"
If $FirstAttack = 2 Then
$GoldGainPerHour = _NumberFormat(Round($iGoldTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600)) & "K /h"
$ElixirGainPerHour = _NumberFormat(Round($iElixirTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600)) & "K /h"
EndIf
If $iDarkStart <> "" Then
$DarkGainPerHour = _NumberFormat(Round($iDarkTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600 * 1000)) & " /h"
EndIf
$TrophyGainPerHour = _NumberFormat(Round($iTrophyTotal / (Int(TimerDiff($sTimer) + $iTimePassed)) * 3600 * 1000)) & " /h"
Local $txtStats = " | " & GetTranslated(620,108,"Stats Village Report") & "\n" & GetTranslated(620,148,"At Start") & "\n[" & GetTranslated(620,35, "G") & "]: " & _NumberFormat($iGoldStart) & " [" & GetTranslated(620,110, "E") & "]: "
$txtStats &= _NumberFormat($iElixirStart) & " [D]: " & _NumberFormat($iDarkStart) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyStart
$txtStats &= "\n\n" & GetTranslated(620,114,"Now (Current Resources)") & "\n[" & GetTranslated(620,35, "G") & "]: " & _NumberFormat($iGoldCurrent) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirCurrent)
$txtStats &= " [D]: " & _NumberFormat($iDarkCurrent) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyCurrent & " [GEM]: " & $iGemAmount
$txtStats &= "\n\n" & GetTranslated(620,140,"Gain per Hour") & ":\n[" & GetTranslated(620,35, "G") & "]: " & $GoldGainPerHour & " [" & GetTranslated(620,110, "E") & "]: " & $ElixirGainPerHour
$txtStats &= "\n[D]: " & $DarkGainPerHour & " [" & GetTranslated(620,112, "T") & "]: " & $TrophyGainPerHour
$txtStats &= "\n\n" & GetTranslated(620,105,"No. of Free Builders") & ": " & $iFreeBuilderCount & "\n[" & GetTranslated(620,117,"No. of Wall Up") & "]: [" & GetTranslated(620,109, "G") & "]: "
$txtStats &= $iNbrOfWallsUppedGold & "/ [" & GetTranslated(620,110, "E") & "]: " & $iNbrOfWallsUppedElixir & "\n\n" & GetTranslated(620,116,"Attacked") & ": "
$txtStats &= GUICtrlRead($lblresultvillagesattacked) & "\n" & GetTranslated(620,115,"Skipped") & ": " & $iSkippedVillageCount
NotifyPushToTelegram($NotifyOrigin & $txtStats)
Case GetTranslated(620,19,"LOG"), '\UD83D\UDCCB ' & GetTranslated(620,19,"LOG")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,711,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,712,"Log is now sent"), $COLOR_GREEN)
NotifyPushFileToTelegram($sLogFName, "logs", "text\/plain; charset=utf-8", $NotifyOrigin & " | Current Log " & "\n")
Case GetTranslated(620,21,"LASTRAID"), '\UD83C\UDF04 ' & GetTranslated(620,21,"LASTRAID")
If $LootFileName <> "" Then
NotifyPushFileToTelegram($LootFileName, GetTranslated(620,120, "Loots"), "image/jpeg", $NotifyOrigin & " | " & GetTranslated(620,152,"Last Raid") & "\n" & $LootFileName)
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,713,"Push Last Raid Snapshot..."), $COLOR_GREEN)
Else
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,141,"There is no last raid screenshot."))
SetLog(GetTranslated(620,141,"There is no last raid screenshot."))
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,714,"Your request has been received. Last Raid txt sent"), $COLOR_GREEN)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,142,"Last Raid txt") & "\n" & "[" & GetTranslated(620,35, "G") & "]: " & _NumberFormat($iGoldLast) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirLast) & " [D]: " & _NumberFormat($iDarkLast) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyLast)
EndIf
Case GetTranslated(620,23,"LASTRAIDTXT"), '\UD83D\UDCC4 ' & GetTranslated(620,23,"LASTRAIDTXT")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,714,"Your request has been received. Last Raid txt sent"), $COLOR_GREEN)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,142,"Last Raid txt") & "\n" & "[" & GetTranslated(620,35, "G") & "]: " & _NumberFormat($iGoldLast) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirLast) & " [D]: " & _NumberFormat($iDarkLast) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyLast)
Case GetTranslated(620,25,"SCREENSHOT")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,715,"ScreenShot request received"), $COLOR_GREEN)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,147,"Chief, your request for Screenshot will be processed ASAP"))
$TGRequestScreenshot = 1
Case GetTranslated(620,27,"SCREENSHOTHD"), '\UD83D\UDCF7 ' & GetTranslated(620,25,"SCREENSHOT")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,716,"ScreenShot HD request received"), $COLOR_GREEN)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,147,"Chief, your request for Screenshot will be processed ASAP"))
$TGRequestScreenshot = 1
$TGRequestScreenshotHD = 1
$NotifyForced = 0
Case GetTranslated(620,29,"BUILDER"), '\UD83D\UDD28 ' & GetTranslated(620,29,"BUILDER")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,717,"Builder Status request received"), $COLOR_GREEN)
$TGRequestBuilderInfo = 1
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,137,"Chief, your request for Builder Info will be processed ASAP"))
Case GetTranslated(620,31,"SHIELD"), '\UD83D\UDD30 ' & GetTranslated(620,31,"SHIELD")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,718,"Shield Status request received"), $COLOR_GREEN)
$TGRequestShieldInfo = 1
$NotifyForced = 0
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,139,"Chief, your request for Shield Info will be processed ASAP"))
Case GetTranslated(620,33,"RESETSTATS")
btnResetStats()
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,719,"Your request has been received. Statistics resetted"), $COLOR_GREEN)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,135,"Statistics resetted."))
Case GetTranslated(620,35,"TROOPS"), '\UD83D\UDCAA ' & GetTranslated(620,35,"TROOPS")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,720,"Your request has been received. Sending Troop/Spell Stats..."), $COLOR_GREEN)
Local $txtTroopStats = " | " & GetTranslated(620,136,"Troops/Spells set to Train") & ":\n" & "Barbs:" & $BarbComp & " Arch:" & $ArchComp & " Gobl:" & $GoblComp
$txtTroopStats &= "\n" & "Giant:" & $GiantComp & " WallB:" & $WallComp & " Wiza:" & $WizaComp
$txtTroopStats &= "\n" & "Balloon:" & $BallComp & " Heal:" & $HealComp & " Dragon:" & $DragComp & " Pekka:" & $PekkComp
$txtTroopStats &= "\n" & "Mini:" & $MiniComp & " Hogs:" & $HogsComp & " Valks:" & $ValkComp
$txtTroopStats &= "\n" & "Golem:" & $GoleComp & " Witch:" & $WitcComp & " Lava:" & $LavaComp
$txtTroopStats &= "\n" & "LSpell:" & $LSpellComp & " HeSpell:" & $HSpellComp & " RSpell:" & $RSpellComp & " JSpell:" & $JSpellComp
$txtTroopStats &= "\n" & "FSpell:" & $FSpellComp & " PSpell:" & $PSpellComp & " ESpell:" & $ESpellComp & " HaSpell:" & $HaSpellComp & "\n"
$txtTroopStats &= "\n" & GetTranslated(620,168,"Current Trained Troops & Spells") & ":"
For $i = 0 to Ubound($NotifyTroopSpellStats)-1
If $NotifyTroopSpellStats[$i][0] <> "" Then
$txtTroopStats &= "\n" & $NotifyTroopSpellStats[$i][0] & ":" & $NotifyTroopSpellStats[$i][1]
EndIf
Next
$txtTroopStats &= "\n\n" & GetTranslated(620,169,"Current Army Camp") & ": " & $CurCamp & "/" & $TotalCamp
NotifyPushToTelegram($NotifyOrigin & $txtTroopStats)
Case GetTranslated(620,37,"HALTATTACKON"), '\U274C ' & StringUpper(GetTranslated(620,38,"Attack Off"))
GUICtrlSetState($chkBotStop, $GUI_CHECKED)
btnStop()
$ichkBotStop = 1
$icmbBotCond = 18
btnStart()
Case GetTranslated(620,40,"HALTATTACKOFF"), '\U2705 ' & StringUpper(GetTranslated(620,41,"Attack On"))
GUICtrlSetState($chkBotStop, $GUI_UNCHECKED)
btnStop()
btnStart()
Case GetTranslated(620,43,"HIBERNATE"), '\UD83D\UDCA4 ' & GetTranslated(620,43,"HIBERNATE")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,702,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,721,"Hibernate PC"), $COLOR_GREEN)
NotifyPushToTelegram(GetTranslated(620,45,"PC Hibernate sequence initiated"))
Shutdown(64)
Case GetTranslated(620,46,"SHUTDOWN"), '\U26A1 ' & StringUpper(GetTranslated(620,47,"Shut down"))
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,702,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,722,"Shutdown PC"), $COLOR_GREEN)
NotifyPushToTelegram(GetTranslated(620,49,"PC Shutdown sequence initiated"))
Shutdown(5)
Case GetTranslated(620,50,"STANDBY"), GetTranslated(620,50,"STANDBY")
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,702,"Your request has been received from ") & $NotifyOrigin & ". " & GetTranslated(620,723,"Standby PC"), $COLOR_GREEN)
NotifyPushToTelegram(GetTranslated(620,52,"PC Standby sequence initiated"))
Shutdown(32)
EndSwitch
EndIf
EndIf
EndIf
EndFunc
Func NotifylPushBulletMessage($pMessage = "")
If ($NotifyPBEnabled = 0 Or $NotifyPBToken = "") And ($NotifyTGEnabled = 0 Or $NotifyTGToken = "") Then Return
If $NotifyForced = 0 Then
If $NotifyScheduleWeekDaysEnable = 1 Then
If $NotifyScheduleWeekDays[@WDAY - 1] = 1 Then
If $NotifyScheduleHoursEnable = 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $NotifyScheduleHours[$hour[0]] = 0 Then
SetLog(GetTranslated(620,725,"Notify not planned for this hour! Notification skipped"), $COLOR_ORANGE)
SetLog($pMessage, $COLOR_ORANGE)
Return
EndIf
EndIf
Else
Return
EndIf
Else
If $NotifyScheduleHoursEnable = 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $NotifyScheduleHours[$hour[0]] = 0 Then
SetLog(GetTranslated(620,725,"Notify not planned for this hour! Notification skipped"), $COLOR_ORANGE)
SetLog($pMessage, $COLOR_ORANGE)
Return
EndIf
EndIf
EndIf
EndIf
If $NotifyPBEnabled = 1 And $NotifyPBToken <> "" Then
$NotifyForced = 0
$oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Get", "https://api.pushbullet.com/v2/devices", False)
$oHTTP.SetCredentials($NotifyPBToken, "", 0)
$oHTTP.Send()
$Result = $oHTTP.ResponseText
Local $device_iden = _StringBetween($Result, 'iden":"', '"')
Local $device_name = _StringBetween($Result, 'nickname":"', '"')
Local $device = ""
Local $pDevice = 1
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$oHTTP.SetCredentials($NotifyPBToken, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $pPush = '{"type": "note", "body": "' & $pMessage & "\n" & $Date & "__" & $Time & '"}'
$oHTTP.Send($pPush)
EndIf
If $NotifyTGEnabled = 1 And $NotifyTGToken <> ""  Then
$access_token2 = $NotifyTGToken
$oHTTP2 = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP2.Open("Get", "https://api.telegram.org/bot" & $access_token2 & "/getupdates" , False)
$oHTTP2.Send()
$Result = $oHTTP2.ResponseText
Local $chat_id = _StringBetween($Result, 'm":{"id":', ',"f')
$TGChatID = _Arraypop($chat_id)
$oHTTP2.Open("Post", "https://api.telegram.org/bot" & $access_token2&"/sendmessage", False)
$oHTTP2.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $TGPushMsg = '{"text":"' & $pmessage & '\n' & $Date & '__' & $Time & '", "chat_id":' & $TGChatID & '}}'
$oHTTP2.Send($TGPushMsg)
EndIf
EndFunc
Func NotifyPushToPushBullet($pMessage)
If ($NotifyPBEnabled = 0 Or $NotifyPBToken = "") And ($NotifyTGEnabled = 0 Or $NotifyTGToken = "") Then Return
If $NotifyPBEnabled = 1 And $NotifyPBToken <> "" Then
$oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$access_token = $NotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $pPush = '{"type": "note", "body": "' & $pMessage & "\n" & $Date & "__" & $Time & '"}'
$oHTTP.Send($pPush)
EndIf
EndFunc
Func NotifyDeletePushBullet()
If $NotifyPBEnabled = 0 Or $NotifyPBToken = "" Then Return
$oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("DELETE", "https://api.pushbullet.com/v2/pushes", False)
$access_token = $NotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
EndFunc
Func NotifyDeleteMessageFromPushBullet($iden)
If $NotifyPBEnabled = 0 Or $NotifyPBToken = "" Then Return
$oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Delete", "https://api.pushbullet.com/v2/pushes/" & $iden, False)
$access_token = $NotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
$iden = ""
EndFunc
Func NotifyDeleteOldPushesFromPushBullet()
If $NotifyPBEnabled = 0 Or $NotifyPBToken = "" Or $NotifyDeletePushesOlderThan = 0 Then Return
Local $tLocal = _Date_Time_GetLocalTime()
Local $tSystem = _Date_Time_TzSpecificLocalTimeToSystemTime(DllStructGetPtr($tLocal))
Local $timeUTC = _Date_Time_SystemTimeToDateTimeStr($tSystem, 1)
Local $timestamplimit = 0
$oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Get", "https://api.pushbullet.com/v2/pushes?active=true&modified_after=" & $timestamplimit, False)
$access_token = $NotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
$oHTTP.Send()
$Result = $oHTTP.ResponseText
Local $findstr = StringRegExp($Result, ',"created":')
Local $msgdeleted = 0
If $findstr = 1 Then
Local $body = _StringBetween($Result, '"body":"', '"', "", False)
Local $iden = _StringBetween($Result, '"iden":"', '"', "", False)
Local $created = _StringBetween($Result, '"created":', ',', "", False)
If IsArray($body) And IsArray($iden) And IsArray($created) Then
For $x = 0 To UBound($created) - 1
If $iden <> "" And $created <> "" Then
Local $hdif = _DateDiff('h', _GetDateFromUnix($created[$x]), $timeUTC)
If $hdif >= $NotifyDeletePushesOlderThanHours Then
$msgdeleted += 1
NotifyDeleteMessageFromPushBullet($iden[$x])
EndIf
EndIf
$body[$x] = ""
$iden[$x] = ""
Next
EndIf
EndIf
If $msgdeleted > 0 Then
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,734,"removed") & " " & $msgdeleted & " " & GetTranslated(620,735,"messages older than") & " " & $NotifyDeletePushesOlderThanHours & " h ", $COLOR_GREEN)
EndIf
EndFunc
Func NotifyPushFileToPushBullet($File, $Folder, $FileType, $body)
If ($NotifyPBEnabled = 0 Or $NotifyPBToken = "") And ($NotifyTGEnabled = 0 Or $NotifyTGToken = "") Then Return
If $NotifyPBEnabled = 1 And $NotifyPBToken <> "" Then
If FileExists($sProfilePath & "\" & $sCurrProfile & '\' & $Folder & '\' & $File) Then
$oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/upload-request", False)
$access_token = $NotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"file_name": "' & $File & '", "file_type": "' & $FileType & '"}'
$oHTTP.Send($pPush)
$Result = $oHTTP.ResponseText
Local $upload_url = _StringBetween($Result, 'upload_url":"', '"')
Local $awsaccesskeyid = _StringBetween($Result, 'awsaccesskeyid":"', '"')
Local $acl = _StringBetween($Result, 'acl":"', '"')
Local $key = _StringBetween($Result, 'key":"', '"')
Local $signature = _StringBetween($Result, 'signature":"', '"')
Local $policy = _StringBetween($Result, 'policy":"', '"')
Local $file_url = _StringBetween($Result, 'file_url":"', '"')
If IsArray($upload_url) And IsArray($awsaccesskeyid) And IsArray($acl) And IsArray($key) And IsArray($signature) And IsArray($policy) Then
$Result = RunWait($pCurl & " -i -X POST " & $upload_url[0] & ' -F awsaccesskeyid="' & $awsaccesskeyid[0] & '" -F acl="' & $acl[0] & '" -F key="' & $key[0] & '" -F signature="' & $signature[0] & '" -F policy="' & $policy[0] & '" -F content-type="' & $FileType & '" -F file=@"' & $sProfilePath & "\" & $sCurrProfile & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $file_url[0] & '", "body": "' & $body & '"}'
$oHTTP.Send($pPush)
Else
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,726,"Unable to send file") & " " & $File, $COLOR_RED)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,170, "Unable to Upload File") & "\n" & GetTranslated(620,171, "Occured an error type") & " 1 " & GetTranslated(620,144, "uploading file to PushBullet server") & "...")
EndIf
Else
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,726,"Unable to send file") & " " & $File, $COLOR_RED)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,170, "Unable to Upload File") & "\n" & GetTranslated(620,171, "Occured an error type") & " 2 " & GetTranslated(620,144, "uploading file to PushBullet server") & "...")
EndIf
EndIf
EndFunc
Func NotifyPushToTelegram($pMessage)
If ($NotifyPBEnabled = 0 Or $NotifyPBToken = "") And ($NotifyTGEnabled = 0 Or $NotifyTGToken = "") Then Return
If $NotifyTGEnabled = 1 And $NotifyTGToken <> ""  Then
$access_token2 = $NotifyTGToken
$oHTTP2 = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$url= "https://api.telegram.org/bot"
$oHTTP2.Open("Post",  $url & $access_token2 & "/sendMessage", False)
$oHTTP2.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $TGPushMsg = '{"text":"' & $pmessage & '\n' & $Date & '__' & $Time & '", "chat_id":' & $TGChatID & '}}'
$oHTTP2.Send($TGPushMsg)
EndIf
EndFunc
Func NotifyPushFileToTelegram($File, $Folder, $FileType, $body)
If ($NotifyPBEnabled = 0 Or $NotifyPBToken = "") And ($NotifyTGEnabled = 0 Or $NotifyTGToken = "") Then Return
If $NotifyTGEnabled = 1 And $NotifyTGToken <> ""  Then
If FileExists($sProfilePath & "\" & $sCurrProfile & '\' & $Folder & '\' & $File) Then
$access_token2 = $NotifyTGToken
$oHTTP2 = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
Local $telegram_url = "https://api.telegram.org/bot" & $access_token2 & "/sendPhoto"
$Result = RunWait($pCurl & " -i -X POST " & $telegram_url & ' -F chat_id="' & $TGChatID &' " -F photo=@"' & $sProfilePath & "\" & $sCurrProfile & '\' & $Folder & '\' & $File  & '"', "", @SW_HIDE)
$oHTTP2.Open("Post", "https://api.telegram.org/bot" & $access_token2 & "/sendPhoto", False)
$oHTTP2.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $telegram_url & '", "body": "' & $body & '"}'
$oHTTP2.Send($pPush)
Else
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,726,"Unable to send file") & " " & $File, $COLOR_RED)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,170,"Unable to Upload File") & "\n" & GetTranslated(620,146,"Occured an error type 2 uploading file to Telegram server..."))
EndIf
EndIf
EndFunc
Func NotifyGetLastMessageFromTelegram()
If $NotifyTGEnabled = 0 Or $NotifyTGToken = "" Then Return
$access_token2 = $NotifyTGToken
$oHTTP2 = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP2.Open("Get", "https://api.telegram.org/bot" & $access_token2 & "/getupdates" , False)
$oHTTP2.Send()
$Result = $oHTTP2.ResponseText
Local $chat_id = _StringBetween($Result, 'm":{"id":', ',"f')
$TGChatID = _Arraypop($chat_id)
Local $uid = _StringBetween($Result, 'update_id":', '"message"')
$TGLast_UID = StringTrimRight(_Arraypop($uid), 2)
Local $findstr2 = StringRegExp(StringUpper($Result), '"TEXT":"')
If $findstr2 = 1 Then
Local $rmessage = _StringBetween($Result, 'text":"' ,'"}}' )
Local $TGLastMessage = _Arraypop($rmessage)
EndIf
$oHTTP2.Open("Get", "https://api.telegram.org/bot" & $access_token2 & "/getupdates?offset=" & $TGLast_UID  , False)
$oHTTP2.Send()
$Result2 = $oHTTP2.ResponseText
Local $findstr2 = StringRegExp(StringUpper($Result2), '"TEXT":"')
If $findstr2 = 1 Then
Local $rmessage = _StringBetween($Result2, 'text":"' ,'"}}' )
Local $TGLastMessage = _Arraypop($rmessage)
If $TGLastMessage = "" Then
Local $rmessage = _StringBetween($Result2, 'text":"' ,'","entities"' )
Local $TGLastMessage = _Arraypop($rmessage)
EndIf
return $TGLastMessage
EndIf
EndFunc
Func NotifyActivateKeyboardOnTelegram($TGMsg)
$access_token2 = $NotifyTGToken
$oHTTP2 = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$url= "https://api.telegram.org/bot"
$oHTTP2.Open("Post",  $url & $access_token2 & "/sendMessage", False)
$oHTTP2.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $TGPushMsg = '{"text": "' & $TGMsg & '", "chat_id":' & $TGChatID &', "reply_markup": {"keyboard": [["' &  '\ud83d\udcf7 ' & GetTranslated(620,801,"Screenshot") & '","' &  '\ud83d\udd28 ' & GetTranslated(620,802,"Builder") & '","' &  '\ud83d\udd30 ' & GetTranslated(620,803,"Shield") & '"],["' &  '\ud83d\udcc8 ' & GetTranslated(620,804,"Stats") & '","' &  '\ud83d\udcaa ' & GetTranslated(620,805,"Troops") & '","' &  '\u2753 ' & GetTranslated(620,806,"Help") & '"],["' &  '\u25aa ' & GetTranslated(620,807,"Stop") & '","' &  '\ud83d\udd00 ' & GetTranslated(620,808,"Pause") & '","' &  '\u25b6 ' & GetTranslated(620,809,"Resume") & '","' &  '\ud83d\udd01 ' & GetTranslated(620,810,"Restart") & '"],["' &  '\ud83d\udccb ' & GetTranslated(620,811,"Log") & '","' &  '\ud83c\udf04 ' & GetTranslated(620,812,"Lastraid") & '","' &  '\ud83d\udcc4 ' & GetTranslated(620,813,"LastRaidTxt") & '"],["' &  '\u2705 ' & GetTranslated(620,814,"Attack On") & '","' &  '\u274C ' & GetTranslated(620,815,"Attack Off") & '"],["' &  '\ud83d\udca4 ' & GetTranslated(620,816,"Hibernate") & '","' &  '\u26a1 ' & GetTranslated(620,817,"Shut down") & '","' &  '\ud83d\udd06 ' & GetTranslated(620,818,"Standby") & '"]],"one_time_keyboard": false,"resize_keyboard":true}}'
$oHTTP2.Send($TGPushMsg)
$TGLastRemote = $TGLast_UID
EndFunc
Func NotifyPushToBoth($pMessage)
If ($NotifyPBEnabled = 0 Or $NotifyPBToken = "") And ($NotifyTGEnabled = 0 Or $NotifyTGToken = "") Then Return
If $NotifyPBEnabled = 1 And $NotifyPBToken <> "" Then
$oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$access_token = $NotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $pPush = '{"type": "note", "body": "' & $pMessage & "\n" & $Date & "__" & $Time & '"}'
$oHTTP.Send($pPush)
EndIf
If $NotifyTGEnabled = 1 And $NotifyTGToken <> ""  Then
$access_token2 = $NotifyTGToken
$oHTTP2 = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$url= "https://api.telegram.org/bot"
$oHTTP2.Open("Post",  $url & $access_token2 & "/sendMessage", False)
$oHTTP2.SetRequestHeader("Content-Type", "application/json; charset=ISO-8859-1,utf-8")
Local $Date = @YEAR & '-' & @MON & '-' & @MDAY
Local $Time = @HOUR & '.' & @MIN
Local $TGPushMsg = '{"text":"' & $pmessage & '\n' & $Date & '__' & $Time & '", "chat_id":' & $TGChatID & '}}'
$oHTTP2.Send($TGPushMsg)
EndIf
EndFunc
Func NotifyPushMessageToBoth($Message, $Source = "")
If $NotifyForced = 0 And $Message <> "DeleteAllPBMessages" Then
If $NotifyScheduleWeekDaysEnable = 1 Then
If $NotifyScheduleWeekDays[@WDAY - 1] = 1 Then
If $NotifyScheduleHoursEnable = 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $NotifyScheduleHours[$hour[0]] = 0 Then
SetLog(GetTranslated(620,725,"Notify not planned for this hour! Notification skipped"), $COLOR_ORANGE)
SetLog($Message, $COLOR_ORANGE)
Return
EndIf
EndIf
Else
Return
EndIf
Else
If $NotifyScheduleHoursEnable = 1 Then
Local $hour = StringSplit(_NowTime(4), ":", $STR_NOCOUNT)
If $NotifyScheduleHours[$hour[0]] = 0 Then
SetLog(GetTranslated(620,725,"Notify not planned for this hour! Notification skipped"), $COLOR_ORANGE)
SetLog($Message, $COLOR_ORANGE)
Return
EndIf
EndIf
EndIf
EndIf
$NotifyForced = 0
Local $hBitmap_Scaled
Switch $Message
Case "Restarted"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1)  And $NotifyRemoteEnable = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,145, "Bot restarted"))
Case "OutOfSync"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1)  And $NotifyAlertOutOfSync = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,172, "Restarted after Out of Sync Error") & "\n" & GetTranslated(620,149, "Attacking now") & "...")
Case "LastRaid"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1)  And $NotifyAlerLastRaidTXT = 1 Then
NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,119, "Last Raid txt") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($iGoldLast) & " [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($iElixirLast) & " [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($iDarkLast) & " [" & GetTranslated(620,112, "T") & "]: " & $iTrophyLast)
If _Sleep($iDelayPushMsg1) Then Return
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,727,"Last Raid Text has been sent!"), $COLOR_GREEN)
EndIf
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1)  And $NotifyAlerLastRaidIMG = 1 Then
_CaptureRegion()
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
If $ScreenshotLootInfo = 1 Then
$AttackFile = $Date & "__" & $Time & " " & GetTranslated(620,35, "G") & $iGoldLast & " " & GetTranslated(620,36, "E") & $iElixirLast & " " & GetTranslated(620,37, "D") & $iDarkLast & " " & GetTranslated(620,38, "T") & $iTrophyLast & " " & GetTranslated(620,59, "S") & StringFormat("%3s", $SearchCount) & ".jpg"
Else
$AttackFile = $Date & "__" & $Time & ".jpg"
EndIf
$hBitmap_Scaled = _GDIPlus_ImageResize($hBitmap, _GDIPlus_ImageGetWidth($hBitmap) / 2, _GDIPlus_ImageGetHeight($hBitmap) / 2)
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $dirLoots & $AttackFile)
_GDIPlus_ImageDispose($hBitmap_Scaled)
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,728,"Last Raid screenshot has been sent!"), $COLOR_GREEN)
NotifyPushFileToBoth($AttackFile, GetTranslated(620,120, "Loots"), "image/jpeg", $NotifyOrigin & " | " & GetTranslated(620,118, "Last Raid") & "\n" & $AttackFile)
If _Sleep($iDelayPushMsg1) Then Return
Local $iDelete = FileDelete($dirLoots & $AttackFile)
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,729,"An error occurred deleting temporary screenshot file."), $COLOR_RED)
EndIf
Case "FoundWalls"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertUpgradeWalls = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,173, "Found Wall level") & " " & $icmbWalls + 4 & "\n" & " " & GetTranslated(620,177, "Wall segment has been located") & "...\n" & GetTranslated(620,153, "Upgrading") & "...")
Case "SkipWalls"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertUpgradeWalls = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,174, "Cannot find Wall level") & $icmbWalls + 4 & "\n" & GetTranslated(620,154, "Skip upgrade") & "...")
Case "AnotherDevice3600"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertAnotherDevice = 1 Then NotifyPushToBoth($NotifyOrigin & " | 1. " & GetTranslated(620,175, "Another Device has connected") & "\n" & GetTranslated(620,176, "Another Device has connected, waiting") & " " & Floor(Floor($sTimeWakeUp / 60) / 60) & " " & GetTranslated(603,14, "Hours") & " " & Floor(Mod(Floor($sTimeWakeUp / 60), 60)) & " " & GetTranslated(603,9, "minutes") & " " & Floor(Mod($sTimeWakeUp, 60)) & " " & GetTranslated(603,8, "seconds"))
Case "AnotherDevice60"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertAnotherDevice = 1 Then NotifyPushToBoth($NotifyOrigin & " | 2. " & GetTranslated(620,175, "Another Device has connected") & "\n" & GetTranslated(620,176, "Another Device has connected, waiting") & " " & Floor(Mod(Floor($sTimeWakeUp / 60), 60)) & " " & GetTranslated(603,9, "minutes") & " " & Floor(Mod($sTimeWakeUp, 60)) & " " & GetTranslated(603,8, "seconds"))
Case "AnotherDevice"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertAnotherDevice = 1 Then NotifyPushToBoth($NotifyOrigin & " | 3. " & GetTranslated(620,175, "Another Device has connected") & "\n" & GetTranslated(620,176, "Another Device has connected, waiting") & " " & Floor(Mod($sTimeWakeUp, 60)) & " " & GetTranslated(603,8, "seconds"))
Case "TakeBreak"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertTakeBreak = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,106, "Chief, we need some rest!") & "\n" & GetTranslated(620,107, "Village must take a break.."))
Case "Update"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertBOTUpdate = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,129, "Chief, there is a new version of the bot available"))
Case "BuilderIdle"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertBulderIdle = 1 Then
Local $iAvailBldr = $iFreeBuilderCount - $iSaveWallBldr
if $iAvailBldr > 0 Then
if $iReportIdleBuilder <> $iAvailBldr Then
NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,122,"You have") & " " & $iAvailBldr & " " & GetTranslated(620,123,"builder(s) idle."))
SetLog(GetTranslated(620,122,"You have") & " " & $iAvailBldr & " " & GetTranslated(620,123,"builder(s) idle."), $COLOR_GREEN)
$iReportIdleBuilder = $iAvailBldr
EndIf
Else
$iReportIdleBuilder = 0
EndIf
EndIf
Case "CocError"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertOutOfSync = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,155, "CoC Has Stopped Error") & ".....")
Case "Pause"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyRemoteEnable = 1 And $Source = "Push" Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,166, "Request to Pause") & "..." & "\n" & GetTranslated(620,156, "Your request has been received. Bot is now paused"))
Case "Resume"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyRemoteEnable = 1 And $Source = "Push" Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,167, "Request to Resume") & "..." & "\n" & GetTranslated(620,157, "Your request has been received. Bot is now resumed"))
Case "OoSResources"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertOutOfSync = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,178, "Disconnected after") & " " & StringFormat("%3s", $SearchCount) & " " & GetTranslated(620,104, "skip(s)") & "\n" & GetTranslated(620,158, "Cannot locate Next button, Restarting Bot") & "...")
Case "MatchFound"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertMatchFound = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & $sModeText[$iMatchMode] & " " & GetTranslated(620,103, "Match Found! after") & " " & StringFormat("%3s", $SearchCount) & " " & GetTranslated(620,104, "skip(s)") & "\n" & "[" & GetTranslated(620,109, "G") & "]: " & _NumberFormat($searchGold) & "; [" & GetTranslated(620,110, "E") & "]: " & _NumberFormat($searchElixir) & "; [" & GetTranslated(620,111, "DE") & "]: " & _NumberFormat($searchDark) & "; [" & GetTranslated(620,112, "T") & "]: " & $searchTrophy)
Case "UpgradeWithGold"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertUpgradeWalls = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,179, "Upgrade completed by using GOLD") & "\n" & GetTranslated(620,159, "Complete by using GOLD") & "...")
Case "UpgradeWithElixir"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertUpgradeWalls = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,180, "Upgrade completed by using ELIXIR") & "\n" & GetTranslated(620,159, "Complete by using ELIXIR") & "...")
Case "NoUpgradeWallButton"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertUpgradeWalls = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,160, "No Upgrade Gold Button") & "\n" & GetTranslated(620,160, "Cannot find gold upgrade button") & "...")
Case "NoUpgradeElixirButton"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertUpgradeWalls = 1 Then NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,181, "No Upgrade Elixir Button") & "\n" & GetTranslated(620,161, "Cannot find elixir upgrade button") & "...")
Case "RequestScreenshot"
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion()
If $PBRequestScreenshotHD = 1 Or $TGRequestScreenshotHD = 1 Then
$hBitmap_Scaled = $hBitmap
Else
$hBitmap_Scaled = _GDIPlus_ImageResize($hBitmap, _GDIPlus_ImageGetWidth($hBitmap) / 2, _GDIPlus_ImageGetHeight($hBitmap) / 2)
EndIf
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($hBitmap_Scaled, $dirTemp & $Screnshotfilename)
_GDIPlus_ImageDispose($hBitmap_Scaled)
If $PBRequestScreenshotHD = 1 Then
NotifyPushFileToPushBullet($Screnshotfilename, "Temp", "image/jpeg", $NotifyOrigin & " | " & GetTranslated(620,162, "Screenshot of your village") & " " & "\n" & $Screnshotfilename)
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,730,"Screenshot sent!"), $COLOR_GREEN)
EndIf
If $TGRequestScreenshotHD = 1 Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $NotifyOrigin & " | " & GetTranslated(620,162, "Screenshot of your village") & " " & "\n" & $Screnshotfilename)
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,730,"Screenshot sent!"), $COLOR_GREEN)
EndIf
$PBRequestScreenshot = 0
$PBRequestScreenshotHD = 0
$TGRequestScreenshot = 0
$TGRequestScreenshotHD = 0
If _Sleep($iDelayPushMsg2) Then Return
Local $iDelete = FileDelete($dirTemp & $Screnshotfilename)
If Not ($iDelete) Then SetLog(GetTranslated(620,720,"Notify PushBullet") & ": " & GetTranslated(620,729,"An error occurred deleting temporary screenshot file."), $COLOR_RED)
Case "BuilderInfo"
Click(0,0, 5)
Click(274,8)
_Sleep (500)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion(224, 74, 446, 262)
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($hBitmap, $dirTemp & $Screnshotfilename)
If $PBRequestBuilderInfo = 1 Then
NotifyPushFileToPushBullet($Screnshotfilename, "Temp", "image/jpeg", $NotifyOrigin & " | " &  "Builder Information" & "\n" & $Screnshotfilename)
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,731,"Builder Information sent!"), $COLOR_GREEN)
EndIf
If $TGRequestBuilderInfo = 1 Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $NotifyOrigin & " | " &  "Builder Information" & "\n" & $Screnshotfilename)
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,731,"Builder Information sent!"), $COLOR_GREEN)
EndIf
$PBRequestBuilderInfo = 0
$TGRequestBuilderInfo = 0
If _Sleep($iDelayPushMsg2) Then Return
Local $iDelete = FileDelete($dirTemp & $Screnshotfilename)
If Not ($iDelete) Then SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,729,"An error occurred deleting temporary screenshot file."), $COLOR_RED)
Click(0,0, 5)
Case "ShieldInfo"
Click(0,0, 5)
Click(435,8)
_Sleep (500)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
_CaptureRegion(200, 165, 660, 568)
Local $Screnshotfilename = "Screenshot_" & $Date & "_" & $Time & ".jpg"
_GDIPlus_ImageSaveToFile($hBitmap, $dirTemp & $Screnshotfilename)
If $PBRequestShieldInfo = 1 Then
NotifyPushFileToPushBullet($Screnshotfilename, "Temp", "image/jpeg", $NotifyOrigin & " | " &  "Shield Information" & "\n" & $Screnshotfilename)
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,732,"Shield Information sent!"), $COLOR_GREEN)
EndIf
If $TGRequestShieldInfo = 1 Then
NotifyPushFileToTelegram($Screnshotfilename, "Temp", "image/jpeg", $NotifyOrigin & " | " &  "Shield Information" & "\n" & $Screnshotfilename)
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,732,"Shield Information sent!"), $COLOR_GREEN)
EndIf
$PBRequestShieldInfo = 0
$TGRequestShieldInfo = 0
If _Sleep($iDelayPushMsg2) Then Return
Local $iDelete = FileDelete($dirTemp & $Screnshotfilename)
If Not ($iDelete) Then SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,729,"An error occurred deleting temporary screenshot file."), $COLOR_RED)
Click(0,0, 5)
Case "DeleteAllPBMessages"
NotifyDeletePushBullet()
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,733,"All messages deleted."), $COLOR_GREEN)
$NotifyDeleteAllPushesNow = False
Case "CampFull"
If ($NotifyPBEnabled = 1 Or $NotifyTGEnabled = 1) And $NotifyAlertCampFull = 1 Then
NotifyPushToBoth($NotifyOrigin & " | " & GetTranslated(620,128, "Your Army Camps are now Full"))
EndIf
EndSwitch
EndFunc
Func NotifyPushFileToBoth($File, $Folder, $FileType, $body)
If ($NotifyPBEnabled = 0 Or $NotifyPBToken = "") And ($NotifyTGEnabled = 0 Or $NotifyTGToken = "") Then Return
If $NotifyPBEnabled = 1 And $NotifyPBToken <> "" Then
If FileExists($sProfilePath & "\" & $sCurrProfile & '\' & $Folder & '\' & $File) Then
$oHTTP = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/upload-request", False)
$access_token = $NotifyPBToken
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"file_name": "' & $File & '", "file_type": "' & $FileType & '"}'
$oHTTP.Send($pPush)
$Result = $oHTTP.ResponseText
Local $upload_url = _StringBetween($Result, 'upload_url":"', '"')
Local $awsaccesskeyid = _StringBetween($Result, 'awsaccesskeyid":"', '"')
Local $acl = _StringBetween($Result, 'acl":"', '"')
Local $key = _StringBetween($Result, 'key":"', '"')
Local $signature = _StringBetween($Result, 'signature":"', '"')
Local $policy = _StringBetween($Result, 'policy":"', '"')
Local $file_url = _StringBetween($Result, 'file_url":"', '"')
If IsArray($upload_url) And IsArray($awsaccesskeyid) And IsArray($acl) And IsArray($key) And IsArray($signature) And IsArray($policy) Then
$Result = RunWait($pCurl & " -i -X POST " & $upload_url[0] & ' -F awsaccesskeyid="' & $awsaccesskeyid[0] & '" -F acl="' & $acl[0] & '" -F key="' & $key[0] & '" -F signature="' & $signature[0] & '" -F policy="' & $policy[0] & '" -F content-type="' & $FileType & '" -F file=@"' & $sProfilePath & "\" & $sCurrProfile & '\' & $Folder & '\' & $File & '"', "", @SW_HIDE)
$oHTTP.Open("Post", "https://api.pushbullet.com/v2/pushes", False)
$oHTTP.SetCredentials($access_token, "", 0)
$oHTTP.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $file_url[0] & '", "body": "' & $body & '"}'
$oHTTP.Send($pPush)
Else
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,726,"Unable to send file") & " " & $File, $COLOR_RED)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,170, "Unable to Upload File") & "\n" & GetTranslated(620,171, "Occured an error type") & " 1 " & GetTranslated(620,144, "uploading file to PushBullet server") & "...")
EndIf
Else
SetLog(GetTranslated(620,700,"Notify PushBullet") & ": " & GetTranslated(620,726,"Unable to send file") & " " & $File, $COLOR_RED)
NotifyPushToPushBullet($NotifyOrigin & " | " & GetTranslated(620,170, "Unable to Upload File") & "\n" & GetTranslated(620,171, "Occured an error type") & " 2 " & GetTranslated(620,144, "uploading file to PushBullet server") & "...")
EndIf
EndIf
If $NotifyTGEnabled = 1 And $NotifyTGToken <> ""  Then
If FileExists($sProfilePath & "\" & $sCurrProfile & '\' & $Folder & '\' & $File) Then
$access_token2 = $NotifyTGToken
$oHTTP2 = ObjCreate("WinHTTP.WinHTTPRequest.5.1")
Local $telegram_url = "https://api.telegram.org/bot" & $access_token2 & "/sendPhoto"
$Result = RunWait($pCurl & " -i -X POST " & $telegram_url & ' -F chat_id="' & $TGChatID &' " -F photo=@"' & $sProfilePath & "\" & $sCurrProfile & '\' & $Folder & '\' & $File  & '"', "", @SW_HIDE)
$oHTTP2.Open("Post", "https://api.telegram.org/bot" & $access_token2 & "/sendPhoto", False)
$oHTTP2.SetRequestHeader("Content-Type", "application/json")
Local $pPush = '{"type": "file", "file_name": "' & $File & '", "file_type": "' & $FileType & '", "file_url": "' & $telegram_url & '", "body": "' & $body & '"}'
$oHTTP2.Send($pPush)
Else
SetLog(GetTranslated(620,701,"Notify Telegram") & ": " & GetTranslated(620,726,"Unable to send file") & " " & $File, $COLOR_RED)
NotifyPushToTelegram($NotifyOrigin & " | " & GetTranslated(620,170,"Unable to Upload File") & "\n" & GetTranslated(620,146,"Occured an error type 2 uploading file to Telegram server..."))
EndIf
EndIf
EndFunc
Func Laboratory()
Static $aUpgradeValue[30] = [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Local $iAvailElixir, $iAvailDark, $iElixirCount, $iDarkCount, $TimeDiff, $aArray, $Result
$itxtUpgrMinElixir = Number($itxtUpgrMinElixir)
$itxtUpgrMinDark = Number($itxtUpgrMinDark)
$iLaboratoryElixirCost = 0
If $ichkLab = 0 Then Return
If $icmbLaboratory = 0 Then
SetLog("Laboratory enabled, but no troop upgrade selected", $COLOR_MAROON)
Return False
EndIf
If $aLabPos[0] = 0 Or $aLabPos[1] = 0 Then
SetLog("Laboratory Location not found!", $COLOR_RED)
LocateLab()
If $aLabPos[0] = 0 Or $aLabPos[1] = 0 Then
SetLog("Problem locating Laboratory, train laboratory position before proceeding", $COLOR_RED)
Return False
EndIf
EndIf
If $sLabUpgradeTime <> "" Then $TimeDiff = _DateDiff("n", _NowCalc(), $sLabUpgradeTime)
If @error Then _logErrorDateDiff(@error)
If $debugSetlog = 1 Then SetLog($aLabTroops[$icmbLaboratory][3] & " Lab end time: " & $sLabUpgradeTime & ", DIFF= " & $TimeDiff, $COLOR_DEBUG)
If $RunState = False Then Return
If $TimeDiff <= 0 Then
SetLog("Checking Troop Upgrade in Laboratory ...", $COLOR_BLUE)
Else
SetLog("Laboratory Upgrade in progress, waiting for completion", $COLOR_BLUE)
Return False
EndIf
If _ColorCheck(_GetPixelColor(812, 141, True), Hex(0x000000, 6), 10) Then
$iElixirCount = getResourcesMainScreen(696, 74)
$iDarkCount = getResourcesMainScreen(728, 123)
SetLog("Updating village values [E]: " & $iElixirCount & " [D]: " & $iDarkCount, $COLOR_GREEN)
Else
$iElixirCount = getResourcesMainScreen(701, 74)
SetLog("Updating village values [E]: " & $iElixirCount, $COLOR_GREEN)
EndIf
$iAvailElixir = Number($iElixirCount)
$iAvailDark = Number($iDarkCount)
Clickp($aLabPos, 1, 0, "#0197")
If _Sleep($iDelayLaboratory1) Then Return
Local $offColors[4][3] = [[0x708CB0, 37, 34], [0x603818, 50, 43], [0xD5FC58, 61, 8], [0x000000, 82, 0]]
Global $ButtonPixel = _MultiPixelSearch(433, 565 + $bottomOffsetY, 562, 619 + $bottomOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("#1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 37, $ButtonPixel[1] + 34, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 50, $ButtonPixel[1] + 43, True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 61, $ButtonPixel[1] + 8, True), $COLOR_DEBUG)
EndIf
If $debugImageSave = 1 Then DebugImageSave("LabUpgrade_")
Click($ButtonPixel[0] + 40, $ButtonPixel[1] + 25, 1, 0, "#0198")
If _Sleep($iDelayLaboratory1) Then Return
Else
Setlog("Trouble finding research button, try again...", $COLOR_MAROON)
ClickP($aAway, 2, $iDelayLaboratory4, "#0199")
Return False
EndIf
If $debugSetlog = 1 Then LabTroopImages1()
If $iFirstTimeLab = 0 Then
For $i = 1 To 12
$aUpgradeValue[$i] = getLabUpgrdResourceRed($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $debugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 49999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $debugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 49999 Then
If _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True), Hex(0xEFFFFF, 6), 20) And _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True), Hex(0xFFFFFF, 6), 20) Then
$aUpgradeValue[$i] = -1
If $debugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Is Maxed already, now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If $RunState = False Then Return
Next
$iFirstTimeLab = 1
EndIf
If $aLabTroops[$icmbLaboratory][2] >= 1 Then
ClickDrag(650, 423 + $midOffsetY, 323, 423 + $midOffsetY, 1000)
If _Sleep($iDelayLaboratory3) Then Return
If $debugSetlog = 1 Then LabTroopImages2()
If $iFirstTimeLab < 2 Then
For $i = 13 To 18
$aUpgradeValue[$i] = getLabUpgrdResourceRed($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $debugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $debugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
If _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True), Hex(0xEFFFFF, 6), 20) And _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True), Hex(0xFFFFFF, 6), 20) Then
$aUpgradeValue[$i] = -1
If $debugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Is Maxed already, $aUpgradeValue now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If $RunState = False Then Return
Next
$iFirstTimeLab += 2
EndIf
EndIf
If $aLabTroops[$icmbLaboratory][2] = 2 Then
ClickDrag(734, 423 + $midOffsetY, 3, 423 + $midOffsetY, 2000)
If _Sleep($iDelayLaboratory3) Then Return
If $debugSetlog = 1 Then LabTroopImages3()
If $iFirstTimeLab < 4 Then
For $i = 19 To 29
$aUpgradeValue[$i] = getLabUpgrdResourceRed($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $debugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Red text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
$aUpgradeValue[$i] = getLabUpgrdResourceWht($aLabTroops[$i][0] + 13, $aLabTroops[$i][1] + 74)
If $debugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " White text upgrade value = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
If $aUpgradeValue[$i] = "" Or $aUpgradeValue[$i] < 9999 Then
If _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True), Hex(0xEFFFFF, 6), 20) And _ColorCheck(_GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True), Hex(0xFFFFFF, 6), 20) Then
$aUpgradeValue[$i] = -1
If $debugSetlog = 1 Then Setlog($aLabTroops[$i][3] & " Is Maxed already, $aUpgradeValue now = " & $aUpgradeValue[$i], $COLOR_DEBUG)
EndIf
EndIf
If $RunState = False Then Return
Next
$iFirstTimeLab += 4
EndIf
EndIf
Switch $icmbLaboratory
Case 1 To 18
If $aUpgradeValue[$icmbLaboratory] > 0 Then $iLaboratoryElixirCost = $aUpgradeValue[$icmbLaboratory]
EndSwitch
If _ColorCheck(_GetPixelColor(625, 250 + $midOffsetY, True), Hex(0x60AC10, 6), 20) Or _ColorCheck(_GetPixelColor(660, 250 + $midOffsetY, True), Hex(0x60AC10, 6), 20) Then
SetLog("Upgrade in progress, waiting for completion of other troops", $COLOR_BLUE)
If _Sleep($iDelayLaboratory2) Then Return
If $sLabUpgradeTime = ""  Or $TimeDiff <= 0 Then
$Result = getRemainTLaboratory(336, 260)
If $debugSetlog = 1 Then Setlog($aLabTroops[$icmbLaboratory][3] & " OCR Remaining Lab Time = " & $Result, $COLOR_DEBUG)
$aArray = StringSplit($Result, ' ', BitOR($STR_CHRSPLIT, $STR_NOCOUNT))
If IsArray($aArray) Then
$iRemainingTimeMin = 0
For $i = 0 To UBound($aArray) - 1
$sTime = ""
Select
Case StringInStr($aArray[$i], "d", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += (Int($sTime) * 24 * 60)
Case StringInStr($aArray[$i], "h", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += (Int($sTime) * 60)
Case StringInStr($aArray[$i], "m", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime)
Case StringInStr($aArray[$i], "s", $STR_NOCASESENSEBASIC) > 0
$sTime = StringTrimRight($aArray[$i], 1)
$iRemainingTimeMin += Int($sTime) / 60
Case Else
Setlog("Remaining lab time OCR invalid:" & $aArray[$i], $COLOR_FUCHSIA)
ClickP($aAway, 2, $iDelayLaboratory4, "#0328")
Return False
EndSelect
If $debugSetlog = 1 Then Setlog("Remain Lab Time: " & $aArray[$i] & ", Minutes= " & $iRemainingTimeMin, $COLOR_DEBUG)
Next
$sLabUpgradeTime = _DateAdd('n', Ceiling($iRemainingTimeMin), _NowCalc())
If @error Then _logErrorDateAdd(@error)
SetLog($aLabTroops[$icmbLaboratory][3] & "Updated Lab finishing time: " & $sLabUpgradeTime, $COLOR_GREEN)
LabStatusGUIUpdate()
Else
If $debugSetlog = 1 Then Setlog("Invalid getRemainTLaboratory OCR", $COLOR_DEBUG)
EndIf
EndIf
ClickP($aAway, 2, $iDelayLaboratory4, "#0328")
Return False
EndIf
If $aUpgradeValue[$icmbLaboratory] = -1 Then
SetLog($aLabTroops[$icmbLaboratory][3] & " already max level, select another troop", $COLOR_RED)
ClickP($aAway, 2, $iDelayLaboratory4, "#0353")
Return False
EndIf
If $aUpgradeValue[$icmbLaboratory] = 0 Then
If _ColorCheck(_GetPixelColor($aLabTroops[$icmbLaboratory][0] + 3, $aLabTroops[$icmbLaboratory][1] + 19, True), Hex(0xC0C0C0, 6), 25) = True Then
SetLog("Lab upgrade not available for " & $aLabTroops[$icmbLaboratory][3] & ", Pick different troop!", $COLOR_RED)
If _Sleep($iDelayLabUpgrade2) Then Return
Else
SetLog($aLabTroops[$icmbLaboratory][3] & " value read error, close bot and try again!", $COLOR_RED)
EndIf
$iFirstTimeLab = 2
ClickP($aAway, 2, $iDelayLaboratory4, "#0354")
Return False
EndIf
Switch $icmbLaboratory
Case 1 To 18
If $iAvailElixir < ($aUpgradeValue[$icmbLaboratory] + $itxtUpgrMinElixir) Then
SetLog("Insufficent Elixir for " & $aLabTroops[$icmbLaboratory][3] & ", Lab requires: " & $aUpgradeValue[$icmbLaboratory] & " + " & $itxtUpgrMinElixir & " user reserve", $COLOR_BLUE)
ClickP($aAway, 2, $iDelayLaboratory4, "#0355")
Return False
EndIf
If LabUpgrade() = True Then
Setlog("Elixir used = " & $aUpgradeValue[$icmbLaboratory], $COLOR_BLUE)
ClickP($aAway, 2, $iDelayLaboratory4, "#0356")
Return True
EndIf
Case 19 To 29
If $iAvailDark < $aUpgradeValue[$icmbLaboratory] + $itxtUpgrMinDark Then
SetLog("Insufficent Dark Elixir for " & $aLabTroops[$icmbLaboratory][3] & ", Lab requires: " & $aUpgradeValue[$icmbLaboratory] & " + " & $itxtUpgrMinDark & " user reserve", $COLOR_BLUE)
ClickP($aAway, 2, $iDelayLaboratory4, "#0357")
Return False
EndIf
If LabUpgrade() = True Then
Setlog("Dark Elixir used = " & $aUpgradeValue[$icmbLaboratory], $COLOR_BLUE)
ClickP($aAway, 2, $iDelayLaboratory4, "#0358")
Return True
EndIf
Case Else
Setlog("Something went wrong with loot value on Lab upgrade on #" & $aLabTroops[$icmbLaboratory][3], $COLOR_RED)
Return False
EndSwitch
ClickP($aAway, 2, $iDelayLaboratory4, "#0359")
Return False
EndFunc
Func LabUpgrade()
Local $StartTime, $EndTime, $EndPeriod, $Result, $TimeAdd = 0
Select
Case _ColorCheck(_GetPixelColor($aLabTroops[$icmbLaboratory][0] + 47, $aLabTroops[$icmbLaboratory][1] + 6, True), Hex(0xE8E8E0, 6), 20) = True
SetLog($aLabTroops[$icmbLaboratory][3] & " not unlocked yet, select another troop", $COLOR_RED)
If _Sleep($iDelayLabUpgrade2) Then Return
Case _ColorCheck(_GetPixelColor($aLabTroops[$icmbLaboratory][0] + 68, $aLabTroops[$icmbLaboratory][1] + 79, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor($aLabTroops[$icmbLaboratory][0] + 68, $aLabTroops[$icmbLaboratory][1] + 84, True), Hex(0xE70A12, 6), 20)
SetLog("Value check error and Not enough Loot to upgrade " & $aLabTroops[$icmbLaboratory][3] & "...", $COLOR_RED)
If _Sleep($iDelayLabUpgrade2) Then Return
Case _ColorCheck(_GetPixelColor($aLabTroops[$icmbLaboratory][0] + 23, $aLabTroops[$icmbLaboratory][1] + 60, True), Hex(0xFFC360, 6), 20) = True
SetLog($aLabTroops[$icmbLaboratory][3] & " already max level, select another troop", $COLOR_RED)
If _Sleep($iDelayLabUpgrade2) Then Return
Case _ColorCheck(_GetPixelColor($aLabTroops[$icmbLaboratory][0] + 3, $aLabTroops[$icmbLaboratory][1] + 19, True), Hex(0xB7B7B7, 6), 20) = True
SetLog("Laboratory upgrade not available now for " & $aLabTroops[$icmbLaboratory][3] & "...", $COLOR_RED)
If _Sleep($iDelayLabUpgrade2) Then Return
Case Else
Click($aLabTroops[$icmbLaboratory][0] + 40, $aLabTroops[$icmbLaboratory][1] + 40, 1, 0, "#0200")
If _Sleep($iDelayLabUpgrade1) Then Return
If $debugImageSave = 1 Then DebugImageSave("LabUpgrade_")
If _ColorCheck(_GetPixelColor(258, 192, True), Hex(0xFF1919, 6), 20) And _ColorCheck(_GetPixelColor(272, 194, True), Hex(0xFF1919, 6), 20) Then
SetLog($aLabTroops[$icmbLaboratory][3] & " Previously maxxed, select another troop", $COLOR_RED)
If _Sleep($iDelayLabUpgrade2) Then Return
ClickP($aAway, 2, $iDelayLabUpgrade3, "#0201")
Return False
EndIf
If _ColorCheck(_GetPixelColor(557, 487, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(557, 494), Hex(0xE70A12, 6), 20) Then
SetLog("Missing Loot to upgrade " & $aLabTroops[$icmbLaboratory][3] & " (secondary check after Upgrade Value read failed)", $COLOR_RED)
If _Sleep($iDelayLabUpgrade2) Then Return
ClickP($aAway, 2, $iDelayLabUpgrade3, "#0333")
Return False
EndIf
If _ColorCheck(_GetPixelColor(625, 250 + $midOffsetY, True), Hex(0x848484, 6), 20) And _ColorCheck(_GetPixelColor(660, 250 + $midOffsetY, True), Hex(0x848484, 6), 20) Then
SetLog("Upgrade in progress, waiting for completion of other troops", $COLOR_MAROON)
If _Sleep($iDelayLaboratory2) Then Return
ClickP($aAway, 2, $iDelayLaboratory4, "#0000")
Return False
Else
$Result = getLabUpgradeTime(482, 557)
Setlog($aLabTroops[$icmbLaboratory][3] & " Upgrade OCR Time = " & $Result, $COLOR_BLUE)
$StartTime = _NowCalc()
If $debugSetlog = 1 Then SetLog($aLabTroops[$icmbLaboratory][3] & "Upgrade Started @ " & $StartTime, $COLOR_GREEN)
$EndTime = ""
$EndPeriod = ""
$TimeAdd = 0
$sLabUpgradeTime = StringStripWS($Result, $STR_STRIPALL)
$aArray = StringRegExp($sLabUpgradeTime, '\d+', $STR_REGEXPARRAYMATCH)
If IsArray($aArray) Then
If $debugSetlog = 1 Then
For $i = 0 To UBound($aArray) - 1
Setlog("UpgradeTime $aArray[" & $i & "] = " & $aArray[$i])
Next
EndIf
$EndTime = $aArray[0]
$EndPeriod = StringReplace($sLabUpgradeTime, $EndTime, "")
Switch $EndPeriod
Case "d"
$TimeAdd = (Int($EndTime) * 24 * 60) - 10
$sLabUpgradeTime = _DateAdd('n', $TimeAdd, $StartTime)
Case "h"
$TimeAdd = (Int($EndTime) * 60) - 3
$sLabUpgradeTime = _DateAdd('n', $TimeAdd, $StartTime)
Case "m"
$TimeAdd = Int($EndTime)
$sLabUpgradeTime = _DateAdd('n', $TimeAdd, $StartTime)
Case Else
Setlog("Upgrade time period invalid, try again!", $COLOR_FUCHSIA)
EndSwitch
If $debugSetlog = 1 Then Setlog("$EndTime = " & $EndTime & " , $EndPeriod = " & $EndPeriod & ", $timeadd = " & $TimeAdd, $COLOR_DEBUG)
SetLog($aLabTroops[$icmbLaboratory][3] & "Upgrade Finishes @ " & $sLabUpgradeTime, $COLOR_GREEN)
Else
Setlog("Error reading the upgrade time required, try again!", $COLOR_FUCHSIA)
EndIf
If _DateIsValid($sLabUpgradeTime) = 0 Then
Setlog("Error processing upgrade time required, try again!", $COLOR_FUCHSIA)
Return False
Else
$txtTip = GetTranslated(614, 8, "Visible Red button means that laboratory upgrade in process") & @CRLF &  GetTranslated(614, 9, "This will automatically disappear when near time for upgrade to be completed.") & @CRLF &  GetTranslated(614, 10, "If upgrade has been manually finished with gems before normal end time,") & @CRLF &  GetTranslated(614, 11, "Click red button to reset internal upgrade timer BEFORE STARTING NEW UPGRADE") & @CRLF &  GetTranslated(614, 12, "Caution - Unnecessary timer reset will force constant checks for lab status") & @CRLF & @CRLF &  GetTranslated(614, 19, "Troop Upgrade started") & ": " & $StartTime & ", " &  GetTranslated(614, 20, "Will begin to check completion at:") & " " & $sLabUpgradeTime & @CRLF & " "
_GUICtrlSetTip($btnResetLabUpgradeTime, $txtTip)
EndIf
Click(660, 520 + $midOffsetY, 1, 0, "#0202")
If _Sleep($iDelayLabUpgrade1) Then Return
EndIf
If isGemOpen(True) = False Then
If Not (_ColorCheck(_GetPixelColor(625, 250 + $midOffsetY, True), Hex(0x60AC10, 6), 20)) Or Not (_ColorCheck(_GetPixelColor(660, 250 + $midOffsetY, True), Hex(0x60AC10, 6), 20)) Then
SetLog("Something went wrong with " & $aLabTroops[$icmbLaboratory][3] & " Upgrade, try again.", $COLOR_RED)
ClickP($aAway, 2, $iDelayLabUpgrade3, "#0360")
Return False
EndIf
SetLog("Upgrade " & $aLabTroops[$icmbLaboratory][3] & " in your laboratory is complete...", $COLOR_GREEN)
PushMsg("LabSuccess")
If _Sleep($iDelayLabUpgrade2) Then Return
$ichkLab = 0
GUICtrlSetState($chkLab, $GUI_UNCHECKED)
ClickP($aAway, 2, 0, "#0204")
Return True
Else
SetLog("Oops, Gems required for " & $aLabTroops[$icmbLaboratory][3] & " Upgrade, try again.", $COLOR_RED)
EndIf
EndSelect
ClickP($aAway, 2, $iDelayLabUpgrade3, "#0205")
Return False
EndFunc
Func DebugRegionSave($sTxtName = "Unknown", $iLeft = 0, $iTop = 0, $iRight = $DEFAULT_WIDTH, $iBottom = $DEFAULT_HEIGHT)
SetLog("Taking debug snapshot for later review", $COLOR_GREEN)
Local $Date = @MDAY & "." & @MON & "." & @YEAR
Local $Time = @HOUR & "." & @MIN & "." & @SEC
If $iLeft <> 0 And $iTop <> 0 And $iRight <> $DEFAULT_WIDTH And $iBottom <> $DEFAULT_HEIGHT Then
Local $sName = $sTxtName & "_Left_" & $iLeft & "_Top_" & $iTop & "_Right_" & $iRight & "_Bottom_" & $iBottom & "_"
Else
$sName = $sTxtName
EndIf
_CaptureRegion($iLeft, $iTop, $iRight, $iBottom)
_GDIPlus_ImageSaveToFile($hBitmap, $dirTempDebug & $sName & $Date & " at " & $Time & ".png")
If _Sleep($iDelayLaboratory2) Then Return
EndFunc
Func LabTroopImages1()
If $debugImageSave = 1 Then DebugImageSave("LabUpgrade_")
For $i = 1 To 12
DebugRegionSave($aLabTroops[$i][3], $aLabTroops[$i][0], $aLabTroops[$i][1], $aLabTroops[$i][0] + 98, $aLabTroops[$i][1] + 98)
SetLog($aLabTroops[$i][3], $COLOR_FUCHSIA)
SetLog("_GetPixelColor(+47, +6): " & _GetPixelColor($aLabTroops[$i][0] + 47, $aLabTroops[$i][1] + 6, True) & ":E0E4D0 =Not unlocked", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +79): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 79, True) & ":E70A12 =No Loot1", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +82): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 84, True) & ":E70A12 =No Loot2", $COLOR_DEBUG)
SetLog("_GetPixelColor(+81, +82): " & _GetPixelColor($aLabTroops[$i][0] + 81, $aLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +83): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +78): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True) & ":EFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+3, +19): " & _GetPixelColor($aLabTroops[$i][0] + 3, $aLabTroops[$i][1] + 19, True) & ":C0C0C0 =Not possible", $COLOR_DEBUG)
SetLog("_GetPixelColor(+8, +59): " & _GetPixelColor($aLabTroops[$i][0] + 23, $aLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func LabTroopImages2()
If $debugImageSave = 1 Then DebugImageSave("LabUpgrade_")
For $i = 13 To 18
DebugRegionSave($aLabTroops[$i][3], $aLabTroops[$i][0], $aLabTroops[$i][1], $aLabTroops[$i][0] + 98, $aLabTroops[$i][1] + 98)
SetLog($aLabTroops[$i][3], $COLOR_FUCHSIA)
SetLog("_GetPixelColor(+47, +6): " & _GetPixelColor($aLabTroops[$i][0] + 47, $aLabTroops[$i][1] + 6, True) & ":E0E4D0 =Not unlocked", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +79): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 79, True) & ":E70A12 =No Loot1", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +82): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 84, True) & ":E70A12 =No Loot2", $COLOR_DEBUG)
SetLog("_GetPixelColor(+81, +82): " & _GetPixelColor($aLabTroops[$i][0] + 81, $aLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +83): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +78): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True) & ":EFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+3, +19): " & _GetPixelColor($aLabTroops[$i][0] + 3, $aLabTroops[$i][1] + 19, True) & ":C0C0C0 =Not possible", $COLOR_DEBUG)
SetLog("_GetPixelColor(+8, +59): " & _GetPixelColor($aLabTroops[$i][0] + 23, $aLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func LabTroopImages3()
If $debugImageSave = 1 Then DebugImageSave("LabUpgrade_")
For $i = 19 To 29
DebugRegionSave($aLabTroops[$i][3], $aLabTroops[$i][0], $aLabTroops[$i][1], $aLabTroops[$i][0] + 98, $aLabTroops[$i][1] + 98)
SetLog($aLabTroops[$i][3], $COLOR_FUCHSIA)
SetLog("_GetPixelColor(+47, +6): " & _GetPixelColor($aLabTroops[$i][0] + 47, $aLabTroops[$i][1] + 6, True) & ":E0E4D0 =Not unlocked", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +79): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 79, True) & ":E70A12 =No Loot1", $COLOR_DEBUG)
SetLog("_GetPixelColor(+68, +82): " & _GetPixelColor($aLabTroops[$i][0] + 68, $aLabTroops[$i][1] + 84, True) & ":E70A12 =No Loot2", $COLOR_DEBUG)
SetLog("_GetPixelColor(+81, +82): " & _GetPixelColor($aLabTroops[$i][0] + 81, $aLabTroops[$i][1] + 82, True) & ":XXXXXX =Loot type", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +83): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 83, True) & ":FFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+78, +78): " & _GetPixelColor($aLabTroops[$i][0] + 78, $aLabTroops[$i][1] + 78, True) & ":EFFFFF =Max L", $COLOR_DEBUG)
SetLog("_GetPixelColor(+3, +19): " & _GetPixelColor($aLabTroops[$i][0] + 3, $aLabTroops[$i][1] + 19, True) & ":C0C0C0 =Not possible", $COLOR_DEBUG)
SetLog("_GetPixelColor(+8, +59): " & _GetPixelColor($aLabTroops[$i][0] + 23, $aLabTroops[$i][1] + 60, True) & ":FFC360 =Max troop", $COLOR_DEBUG)
Next
EndFunc
Func ReplayShare($last = 1)
Local $txtMessage, $tNew
If $iShareAttack = 0 Then Return
If $last = 1 Then
ClickP($aAway, 1, 0, "#0235")
If _Sleep($iDelayReplayShare2) Then Return
SetLog("Share Replay: Opening Messages Page...", $COLOR_BLUE)
If $DebugSetlog = 1 Then Setlog("$last= " & $last, $COLOR_DEBUG)
ClickP($aMessageButton, 1, 0, "#0236")
If _Sleep($iDelayReplayShare3) Then Return
Click(380, 94 + $midOffsetY, 1, 0, "#0237")
If _Sleep($iDelayReplayShare3) Then Return
_CaptureRegion()
Local $FileListQueueName = _FileListToArray($dirTemp, "Village*.png", 1)
If $DebugSetlog = 1 Then Setlog("Top share button pixel color 70D4E8 or BBBBBB: " & _GetPixelColor(500, 156 + $midOffsetY), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(500, 156 + $midOffsetY), Hex(0x70D4E8, 6), 10) = True And Not (IsArray($FileListQueueName)) Then
Setlog("Ok, sharing!")
Click(500, 156 + $midOffsetY, 1, 0, "#0238")
If _Sleep($iDelayReplayShare1) Then Return
Click(300, 120, 1, 0, "#0239")
If _Sleep($iDelayReplayShare1) Then Return
Local $smessage = $sShareMessage
$smessage = StringReplace($smessage, @LF, "")
$smessage = StringReplace($smessage, @CR, "|")
While StringInStr($smessage, "||")
$smessage = StringReplace($smessage, "||", "|")
WEnd
Local $smessagearray = StringSplit($smessage, "|")
If @error Then
$txtMessage = $smessagearray[1]
Else
$txtMessage = $smessagearray[Random(1, $smessagearray[0], 1)]
EndIf
$txtMessage = StringReplace($txtMessage, "<n>", StringFormat("%s", $SearchCount))
ControlSend($HWnD, "", "", $txtMessage, 0)
If _Sleep($iDelayReplayShare1) Then Return
Click(530, 210 + $midOffsetY, 1, 0, "#0240")
$tNew = _Date_Time_GetLocalTime()
$dLastShareDate = _Date_Time_SystemTimeToDateTimeStr($tNew, 1)
Else
If _ColorCheck(_GetPixelColor(500, 156 + $midOffsetY), Hex(0xbbbbbb, 6), 6) = True Or IsArray($FileListQueueName) Then
If IsArray($FileListQueueName) Then
SetLog("Others replay in queue, Share Later Last Replay")
Else
Setlog("Cannot Share Now... retry later.")
EndIf
_CaptureRegion(87, 149 + $midOffsetY, 87 + 100, 149 + 20 + $midOffsetY)
Local $Date = @YEAR & "-" & @MON & "-" & @MDAY
Local $Time = @HOUR & "." & @MIN
Local $iSaveFile = _GDIPlus_ImageSaveToFile($hBitmap, $dirTemp & "Village_" & $Date & "_" & $Time & "^" & StringFormat("%s", $SearchCount) & ".png")
If Not ($iSaveFile) Then SetLog("An error occurred putting screenshot in queue", $COLOR_RED)
Click(763, 86 + $midOffsetY, 1, 0, "#0241")
If _Sleep($iDelayReplayShare2) Then Return
Else
Setlog("Cannot Share Now... retry later.", $COLOR_RED)
EndIf
EndIf
$iShareAttackNow = 0
Else
$tNew = _Date_Time_GetLocalTime()
If _DateDiff("n", $dLastShareDate, _Date_Time_SystemTimeToDateTimeStr($tNew, 1)) > 30 Then
Local $FileListName = _FileListToArray($dirTemp, "Village*.png", 1)
Local $x, $t, $tmin = 0
If Not ((Not IsArray($FileListName)) Or (@error = 1)) Then
Local $FileListDate
For $x = 1 To $FileListName[0]
$t = FileGetTime($dirTemp & $FileListName[$x], 1, 1)
If $tmin = 0 Then
$tmin = $t
$FileListDate = $x
Else
If $t < $tmin Then
$t = $tmin
$FileListDate = $x
EndIf
EndIf
Next
ClickP($aAway, 1, 0, "#0242")
If _Sleep($iDelayReplayShare2) Then Return
SetLog("Share Replay: Opening Messages Page...", $COLOR_BLUE)
If $DebugSetlog = 1 Then Setlog("$last= " & $last, $COLOR_DEBUG)
ClickP($aMessageButton, 1, 0, "#0243")
If _Sleep($iDelayReplayShare3) Then Return
Click(380, 94 + $midOffsetY, 1, 0, "#0244")
If _Sleep($iDelayReplayShare3) Then Return
_CaptureRegion()
If $DebugSetlog = 1 Then Setlog("Top share button pixel color 70D4E8 or BBBBBB: " & _GetPixelColor(500, 156 + $midOffsetY), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(500, 156 + $midOffsetY), Hex(0x70D4E8, 6), 10) = True Then
Setlog("Ok, sharing!")
Local $VilLoc, $VilX, $VilY, $VilTol
For $VilTol = 0 To 20
If $VilLoc = 0 Then
$VilLoc = _ImageSearch($dirTemp & $FileListName[$FileListDate], 1, $VilX, $VilY, $VilTol)
If $VilLoc = 1 And $VilX > 35 And $VilY < 610 Then
Click(500, $VilY, 1, 0, "#0245")
If _Sleep($iDelayReplayShare1) Then Return
Click(300, 120, 1, 0, "#0246")
If _Sleep($iDelayReplayShare1) Then Return
Local $a = StringInStr($FileListName[$FileListDate], "^")
Local $b = StringInStr($FileListName[$FileListDate], ".png")
Local $stry = "0"
If $a > 0 And $b > 0 Then $stry = StringMid($FileListName[$FileListDate], $a + 1, $b - $a - 1)
$SearchCount = $stry
Local $smessage = $sShareMessage
$smessage = StringReplace($smessage, @LF, "")
$smessage = StringReplace($smessage, @CR, "|")
While StringInStr($smessage, "||")
$smessage = StringReplace($smessage, "||", "|")
WEnd
Local $smessagearray = StringSplit($smessage, "|")
If @error Then
$txtMessage = $smessagearray[1]
Else
$txtMessage = $smessagearray[Random(1, $smessagearray[0], 1)]
EndIf
$txtMessage = StringReplace($txtMessage, "<n>", StringFormat("%s", $SearchCount))
ControlSend($HWnD, "", "", $txtMessage, 0)
If _Sleep($iDelayReplayShare1) Then Return
Click(500, 210 + $midOffsetY, 1, 0, "#0247")
$tNew = _Date_Time_GetLocalTime()
$dLastShareDate = _Date_Time_SystemTimeToDateTimeStr($tNew, 1)
Local $iCopy = FileCopy($dirTemp & $FileListName[$FileListDate], $dirTemp & "shared_" & $FileListName[$FileListDate])
If Not ($iCopy) Then Setlog("An error occurred copying a temporary file", $COLOR_RED)
Local $iDelete = FileDelete($dirTemp & $FileListName[$FileListDate])
If Not ($iDelete) Then Setlog("An error occurred deleting a temporary file", $COLOR_RED)
If _Sleep($iDelayReplayShare4) Then Return
Return True
EndIf
EndIf
Next
If $VilLoc = 0 Then
Local $iCopy = FileCopy($dirTemp & $FileListName[$FileListDate], $dirTemp & "discard_" & $FileListName[$FileListDate])
If Not ($iCopy) Then Setlog("An error occurred copying a temporary file", $COLOR_RED)
Local $iDelete = FileDelete($dirTemp & $FileListName[$FileListDate])
If Not ($iDelete) Then Setlog("An error occurred deleting a temporary file", $COLOR_RED)
EndIf
Else
If _ColorCheck(_GetPixelColor(500, 156 + $midOffsetY), Hex(0xbbbbbb, 6), 6) = True Then
Setlog("Cannot Share Now... retry later.")
Click(763, 86 + $midOffsetY, 1, 0, "#0248")
$tNew = _Date_Time_GetLocalTime()
$dLastShareDate = _DateAdd("n", -20, _Date_Time_SystemTimeToDateTimeStr($tNew, 1))
If _Sleep($iDelayReplayShare2) Then Return
Else
Setlog("Button Share not found, abort.", $COLOR_RED)
Click(763, 86 + $midOffsetY, 1, 0, "#0249")
If _Sleep($iDelayReplayShare2) Then Return
EndIf
EndIf
Return True
EndIf
EndIf
EndIf
If _Sleep($iDelayReplayShare2) Then Return
checkMainScreen(False)
EndFunc
Func BoostKing()
If $bTrainEnabled = False Then Return
If $icmbBoostBarbarianKing > 0 And ($boostsEnabled = 1) Then
SetLog("Boost Barbarian King...", $COLOR_BLUE)
If $KingAltarPos[0] = -1 Then
LocateKingAltar()
SaveConfig()
If _Sleep($iDelayBoostHeroes4) Then Return
Else
Click($KingAltarPos[0], $KingAltarPos[1], 1, 0, "#0462")
If _Sleep($iDelayBoostHeroes2) Then Return
_CaptureRegion()
$Boost = _PixelSearch(382, 603 + $bottomOffsetY, 440, 621 + $bottomOffsetY, Hex(0xfffd70, 6), 10)
If IsArray($Boost) Then
If $DebugSetlog = 1 Then Setlog("Boost Button X|Y = " & $Boost[0] & "|" & $Boost[1] & ", color = " & _GetPixelColor($Boost[0], $Boost[1]), $COLOR_DEBUG)
Click($Boost[0], $Boost[1], 1, 0, "#0463")
If _Sleep($iDelayBoostHeroes1) Then Return
If _ColorCheck(_GetPixelColor(428, 227 + $midOffsetY, True), Hex(0xFFFFFF, 6), 20) Then
Click(430, 415 + $midOffsetY, 1, 0, "#0464")
If _Sleep($iDelayBoostHeroes4) Then Return
If _ColorCheck(_GetPixelColor(586, 267 + $midOffsetY, True), Hex(0xd80405, 6), 20) Then
$icmbBoostBarbarianKing = 0
SetLog("Not enough gems", $COLOR_RED)
Else
$icmbBoostBarbarianKing -= 1
GUICtrlSetData($cmbBoostBarbarianKing, $icmbBoostBarbarianKing )
SetLog('Boost completed. Remaining :' & $icmbBoostBarbarianKing, $COLOR_GREEN)
EndIf
Else
SetLog("Barbarian King is already Boosted", $COLOR_RED)
EndIf
If _Sleep($iDelayBoostHeroes3) Then Return
ClickP($aAway, 1, 0, "#0465")
Else
SetLog("Barbarian King Boost Button not found", $COLOR_RED)
If _Sleep($iDelayBoostHeroes4) Then Return
EndIf
EndIf
EndIf
EndFunc
Func BoostQueen()
If $bTrainEnabled = False Then Return
If $icmbBoostArcherQueen > 0 And ($boostsEnabled = 1) Then
SetLog("Boost Archer Queen...", $COLOR_BLUE)
If $QueenAltarPos[0] = -1 Then
LocateQueenAltar()
SaveConfig()
If _Sleep($iDelayBoostHeroes4) Then Return
Else
Click($QueenAltarPos[0], $QueenAltarPos[1], 1, 0, "#0562")
If _Sleep($iDelayBoostHeroes2) Then Return
_CaptureRegion()
$Boost = _PixelSearch(382, 603 + $bottomOffsetY, 440, 621 + $bottomOffsetY, Hex(0xfffd70, 6), 10)
If IsArray($Boost) Then
If $DebugSetlog = 1 Then Setlog("Boost Button X|Y = " & $Boost[0] & "|" & $Boost[1] & ", color = " & _GetPixelColor($Boost[0], $Boost[1]), $COLOR_DEBUG)
Click($Boost[0], $Boost[1], 1, 0, "#0563")
If _Sleep($iDelayBoostHeroes1) Then Return
If _ColorCheck(_GetPixelColor(428, 227 + $midOffsetY, True), Hex(0xFFFFFF, 6), 20) Then
Click(430, 415 + $midOffsetY, 1, 0, "#0464")
If _Sleep($iDelayBoostHeroes4) Then Return
If _ColorCheck(_GetPixelColor(586, 267 + $midOffsetY, True), Hex(0xd80405, 6), 20) Then
$icmbBoostArcherQueen = 0
SetLog("Not enough gems", $COLOR_RED)
Else
$icmbBoostArcherQueen -= 1
GUICtrlSetData($cmbBoostArcherQueen, $icmbBoostArcherQueen )
SetLog('Boost completed. Remaining :' & $icmbBoostArcherQueen, $COLOR_GREEN)
EndIf
Else
SetLog("Archer Queen is already Boosted", $COLOR_RED)
EndIf
If _Sleep($iDelayBoostHeroes3) Then Return
ClickP($aAway, 1, 0, "#0565")
Else
SetLog("Archer Queen Boost Button not found", $COLOR_RED)
If _Sleep($iDelayBoostHeroes4) Then Return
EndIf
EndIf
EndIf
EndFunc
Func BoostWarden()
If $bTrainEnabled = False Then Return
If $icmbBoostWarden > 0 And ($boostsEnabled = 1) Then
SetLog("Boost Grand Warden...", $COLOR_BLUE)
If $WardenAltarPos[0] = -1 Then
LocateWardenAltar()
SaveConfig()
If _Sleep($iDelayBoostHeroes4) Then Return
Else
Click($WardenAltarPos[0], $WardenAltarPos[1])
If _Sleep($iDelayBoostHeroes2) Then Return
_CaptureRegion()
$Boost = _PixelSearch(382, 603 + $bottomOffsetY, 440, 621 + $bottomOffsetY, Hex(0xfffd70, 6), 10)
If IsArray($Boost) Then
If $DebugSetlog = 1 Then Setlog("Boost Button X|Y = " & $Boost[0] & "|" & $Boost[1] & ", color = " & _GetPixelColor($Boost[0], $Boost[1]), $COLOR_DEBUG)
Click($Boost[0], $Boost[1], 1, 0, "#0463")
If _Sleep($iDelayBoostHeroes1) Then Return
If _ColorCheck(_GetPixelColor(428, 227 + $midOffsetY, True), Hex(0xFFFFFF, 6), 20) Then
Click(430, 415 + $midOffsetY, 1, 0, "#0464")
If _Sleep($iDelayBoostHeroes4) Then Return
If _ColorCheck(_GetPixelColor(586, 267 + $midOffsetY, True), Hex(0xd80405, 6), 20) Then
$cmbBoostWarden = 0
SetLog("Not enough gems", $COLOR_RED)
Else
$cmbBoostWarden -= 1
SetLog('Boost completed. Remaining :' & $icmbBoostWarden, $COLOR_GREEN)
EndIf
Else
SetLog("Grand Warden is already Boosted", $COLOR_RED)
EndIf
If _Sleep($iDelayBoostHeroes3) Then Return
ClickP($aAway, 1, 0, "#0465")
Else
SetLog("Grand Warden Boost Button not found", $COLOR_RED)
If _Sleep($iDelayBoostHeroes4) Then Return
EndIf
EndIf
EndIf
EndFunc
Func UpgradeHeroes()
If $ichkUpgradeKing = 0 And $ichkUpgradeQueen = 0 And $ichkUpgradeWarden = 0 Then Return
If _Sleep(500) Then Return
checkMainScreen(False)
If $Restart = True Then Return
If $ichkUpgradeKing = 1 Then
If isInsideDiamond($KingAltarPos) = False Then LocateKingAltar()
If $KingAltarPos[0] = -1 Or $KingAltarPos[1] = -1 Then LocateKingAltar()
SaveConfig()
EndIf
If $ichkUpgradeQueen = 1 Then
If isInsideDiamond($QueenAltarPos) = False Then LocateQueenAltar()
If $QueenAltarPos[0] = -1 Or $QueenAltarPos[1] = -1 Then LocateQueenAltar()
SaveConfig()
EndIf
If $ichkUpgradeWarden = 1 Then
If isInsideDiamond($WardenAltarPos) = False Then LocateWardenAltar()
If $WardenAltarPos[0] = -1 Or $WardenAltarPos[1] = -1 Then LocateWardenAltar()
EndIf
If $ichkLab = 1 And $icmbLaboratory >= 19 Then
Setlog("Laboratory needs DE to Upgrade :  " & $aLabTroops[$icmbLaboratory][3])
SetLog("Skipping the Heroes Upgrade!")
Return
EndIf
SetLog(" »» Upgrading Heroes", $COLOR_BLUE)
If $ichkUpgradeQueen = 1 Then
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount < 1 + $iSaveWallBldr Then
SetLog("Not Enough Builders for Queen", $COLOR_RED)
Return
EndIf
QueenUpgrade()
If _Sleep($iDelayUpgradeHero1) Then Return
EndIf
If $ichkUpgradeKing = 1 Then
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount < 1 + $iSaveWallBldr Then
SetLog("Not Enough Builders for King", $COLOR_RED)
Return
EndIf
KingUpgrade()
If _Sleep($iDelayUpgradeHero1) Then Return
EndIf
If $ichkUpgradeWarden = 1 Then
If getBuilderCount() = False Then Return
If _Sleep($iDelayRespond) Then Return
If $iFreeBuilderCount < 1 + $iSaveWallBldr Then
SetLog("Not Enough Builder for Warden", $COLOR_RED)
Return
EndIf
WardenUpgrade()
EndIF
EndFunc
Func QueenUpgrade()
Local $aHeroLevel = 0
SetLog("Upgrade Queen")
ClickP($aTopLeftClient, 1, 0, "#0166")
If _Sleep(500) Then Return
Click($QueenAltarPos[0], $QueenAltarPos[1])
Local $sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Sleep(100)
$CountGetInfo += 1
If $CountGetInfo >= 50 Then Return
WEnd
If $debugSetlog = 1 Then SetLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Quee") = 0 Then
SetLog("Bad AQ location", $COLOR_ORANGE)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your Queen Level read as: " & $aHeroLevel, $COLOR_GREEN)
If $aHeroLevel = 40 Then
SetLog("Your AQ is max, cannot upgrade!", $COLOR_BLUE)
$ichkUpgradeQueen = 0
Return
EndIf
Else
SetLog("Your Queen Level was not found!", $COLOR_BLUE)
Return
EndIf
EndIf
EndIf
If _Sleep($iDelayUpgradeHero1) Then Return
If _ColorCheck(_GetPixelColor(812, 141, True), Hex(0x000000, 6), 10) Then
$iDarkCurrent = Number(getResourcesMainScreen(728, 123))
If $debugSetlog = 1 Then SetLog("Updating village values [D]: " & $iDarkCurrent, $COLOR_DEBUG)
Else
If $debugSetlog = 1 Then Setlog("getResourcesMainScreen didn't get the DE value", $COLOR_DEBUG)
EndIf
If $iDarkCurrent < ($aQueenUpgCost[$aHeroLevel] * 1000) + $itxtUpgrMinDark Then
SetLog("Insufficient DE for Upg Queen, requires: " & ($aQueenUpgCost[$aHeroLevel] * 1000) & " + " & $itxtUpgrMinDark, $COLOR_BLUE)
Return
EndIf
Local $offColors[3][3] = [[0x9B4C28, 41, 23], [0x040009, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 620 + $bottomOffsetY, 1, 1, Hex(0xF6F9F3, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($iDelayUpgradeHero3) Then Return
If $DebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(721, 118 + $midOffsetY, True), Hex(0xE00408, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $midOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $midOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $midOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("Queen Upgrade Fail! No DE!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0306")
Return
Else
Click(665, 515 + $midOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($iDelayUpgradeHero1) Then Return
If $DebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $midOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("Queen Upgrade Fail! No DE!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0309")
Return
EndIf
SetLog("Queen Upgrade complete", $COLOR_GREEN)
If _Sleep($iDelayUpgradeHero2) Then Return
$iNbrOfHeroesUpped += 1
$iCostDElixirHero += $aQueenUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
Setlog("Upgrade Queen window open fail", $COLOR_RED)
EndIf
Else
Setlog("Upgrade Queen error finding button", $COLOR_RED)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func KingUpgrade()
Local $aHeroLevel = 0
SetLog("Upgrade King")
Click($KingAltarPos[0], $KingAltarPos[1])
If _Sleep(500) Then Return
Local $sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep(100) Then Return
$CountGetInfo += 1
If $CountGetInfo >= 50 Then Return
WEnd
If $debugSetlog = 1 Then SetLog(_ArrayToString($sInfo, " "), $COLOR_DEBUG)
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Barbarian") = 0 Then
SetLog("Bad King location", $COLOR_ORANGE)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your King Level read as: " & $aHeroLevel, $COLOR_GREEN)
If $aHeroLevel = 40 Then
SetLog("Your BK is max, cannot upgrade!", $COLOR_BLUE)
$ichkUpgradeKing = 0
Return
EndIf
Else
SetLog("Your King Level was not found!", $COLOR_BLUE)
Return
EndIf
EndIf
EndIf
If _Sleep($iDelayUpgradeHero1) Then Return
If _ColorCheck(_GetPixelColor(812, 141, True), Hex(0x000000, 6), 10) Then
$iDarkCurrent = Number(getResourcesMainScreen(728, 123))
If $debugSetlog = 1 Then SetLog("Updating village values [D]: " & $iDarkCurrent, $COLOR_DEBUG)
Else
If $debugSetlog = 1 Then Setlog("getResourcesMainScreen didn't get the DE value", $COLOR_DEBUG)
EndIf
If _Sleep(100) Then Return
If $iDarkCurrent < ($aKingUpgCost[$aHeroLevel] * 1000) + $itxtUpgrMinDark Then
SetLog("Insufficient DE for Upg King, requires: " & ($aKingUpgCost[$aHeroLevel] * 1000) & " + " & $itxtUpgrMinDark, $COLOR_BLUE)
Return
EndIf
Local $offColors[3][3] = [[0x9B4C28, 41, 23], [0x040009, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 620 + $bottomOffsetY, 1, 1, Hex(0xF6F9F3, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($iDelayUpgradeHero3) Then Return
If $DebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn1")
If _ColorCheck(_GetPixelColor(715, 120 + $midOffsetY, True), Hex(0xE01C20, 6), 20) Then
If _ColorCheck(_GetPixelColor(691, 523 + $midOffsetY, True), Hex(0xE70A12, 6), 20) And _ColorCheck(_GetPixelColor(691, 527 + $midOffsetY), Hex(0xE70A12, 6), 20) And  _ColorCheck(_GetPixelColor(691, 531 + $midOffsetY, True), Hex(0xE70A12, 6), 20) Then
SetLog("King Upgrade Fail! No DE!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0306")
Return
Else
Click(660, 515 + $midOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($iDelayUpgradeHero1) Then Return
If $DebugImageSave = 1 Then DebugImageSave("UpgradeDarkBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $midOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("King Upgrade Fail! No DE!", $COLOR_RED)
ClickP($aAway, 2, 0, "#0309")
Return
EndIf
SetLog("King Upgrade complete", $COLOR_GREEN)
If _Sleep($iDelayUpgradeHero2) Then Return
$iNbrOfHeroesUpped += 1
$iCostDElixirHero += $aKingUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
Setlog("Upgrade King window open fail", $COLOR_RED)
EndIf
Else
Setlog("Upgrade King error finding button", $COLOR_RED)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func WardenUpgrade()
If Number($iTownHallLevel) <= 10 Then
Setlog("Must have TH 11 for Grand Warden upgrade", $COLOR_RED)
Return
EndIf
Local $aHeroLevel = 0
SetLog("Upgrade Grand Warden")
ClickP($WardenAltarPos, 1, 0, "#8888")
If _Sleep($iDelayUpgradeHero2) Then Return
Local $sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
Local $CountGetInfo = 0
While IsArray($sInfo) = False
$sInfo = BuildingInfo(242, 520 + $bottomOffsetY)
If @error Then SetError(0, 0, 0)
If _Sleep(100) Then Return
$CountGetInfo += 1
If $CountGetInfo = 50 Then Return
WEnd
If $debugSetlog = 1 Then SetLog(_ArrayToString($sInfo, " "))
If @error Then Return SetError(0, 0, 0)
If $sInfo[0] > 1 Or $sInfo[0] = "" Then
If StringInStr($sInfo[1], "Grand") = 0 Then
SetLog("Bad Warden location", $COLOR_ORANGE)
Return
Else
If $sInfo[2] <> "" Then
$aHeroLevel = Number($sInfo[2])
SetLog("Your Warden Level read as: " & $aHeroLevel, $COLOR_GREEN)
If $aHeroLevel = 20 Then
SetLog("Your GW is max, cannot upgrade!", $COLOR_BLUE)
$ichkUpgradeWarden = 0
Return
EndIf
Else
SetLog("Your Warden Level was not found!", $COLOR_BLUE)
Return
EndIf
EndIf
EndIf
If _Sleep($iDelayUpgradeHero1) Then Return
If _ColorCheck(_GetPixelColor(812, 141, True), Hex(0x000000, 6), 10) Then
$iElixirCurrent = getResourcesMainScreen(696, 74)
If $debugSetlog = 1 Then SetLog("Updating village values [E]: " & $iElixirCurrent, $COLOR_PURPLE)
Else
$iElixirCurrent = getResourcesMainScreen(701, 74)
EndIf
If _Sleep(100) Then Return
If $iElixirCurrent < ($aWardenUpgCost[$aHeroLevel] * 1000000) + $itxtUpgrMinElixir Then
SetLog("Insufficient Elixir for Warden Upgrade, requires: " & ($aWardenUpgCost[$aHeroLevel] * 1000000) & " + " & $itxtUpgrMinElixir, $COLOR_BLUE)
Return
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Local $offColors[3][3] = [[0xBC5B31, 38, 32], [0xF84CF9, 72, 0], [0xF5F9F2, 79, 0]]
Global $ButtonPixel = _MultiPixelSearch(240, 563 + $bottomOffsetY, 670, 620 + $bottomOffsetY, 1, 1, Hex(0xF4F7F2, 6), $offColors, 30)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 And IsArray($ButtonPixel) Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Color #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 41, $ButtonPixel[1] + 23, True) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 72, $ButtonPixel[1], True) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 79, $ButtonPixel[1], True), $COLOR_DEBUG)
EndIf
If _Sleep($iDelayUpgradeHero2) Then Return
Click($ButtonPixel[0] + 20, $ButtonPixel[1] + 20, 1, 0, "#0305")
If _Sleep($iDelayUpgradeHero3) Then Return
If $debugSetlog = 1 Then DebugImageSave("UpgradeElixirBtn1")
If $debugSetlog = 1 Then Setlog("pixel: " & _GetPixelColor(718, 120 + $midOffsetY, True) & " expected " & Hex(0xDD0408, 6) & " result: " & _ColorCheck(_GetPixelColor(718, 120 + $midOffsetY, True), Hex(0xDD0408, 6), 20), $COLOR_DEBUG)
If _ColorCheck(_GetPixelColor(718, 120 + $midOffsetY, True), Hex(0xDD0408, 6), 20) Then
If $debugSetlog = 1 Then Setlog("pixel1: " & _GetPixelColor(692, 525 + $midOffsetY, True) & " expected " & Hex(0xFFFFFF, 6) & " result: " & (_ColorCheck(_GetPixelColor(692, 525 + $midOffsetY, True), Hex(0xFFFFFF, 6), 20)), $COLOR_DEBUG)
If Not (_ColorCheck(_GetPixelColor(692, 525 + $midOffsetY, True), Hex(0xFFFFFF, 6), 20)) Then
SetLog("Warden Upgrade Fail! No Elixir!", $COLOR_RED)
ClickP($aAway, 1, 0, "#0306")
Return
Else
Click(660, 515 + $midOffsetY, 1, 0, "#0307")
ClickP($aAway, 1, 0, "#0308")
If _Sleep($iDelayUpgradeHero1) Then Return
If $debugSetlog = 1 Then DebugImageSave("UpgradeElixirBtn2")
If _ColorCheck(_GetPixelColor(573, 256 + $midOffsetY, True), Hex(0xDB0408, 6), 20) Then
SetLog("Warden Upgrade Fail! No Elixir!", $COLOR_RED)
ClickP($aAway, 1, 0, "#0309")
Return
EndIf
SetLog("Warden Upgrade Started", $COLOR_GREEN)
If _Sleep($iDelayUpgradeHero2) Then Return
$iNbrOfHeroesUpped += 1
$iCostElixirBuilding += $aWardenUpgCost[$aHeroLevel - 1] * 1000
UpdateStats()
EndIf
Else
Setlog("Upgrade Warden window open fail", $COLOR_RED)
EndIf
Else
Setlog("Upgrade Warden error finding button", $COLOR_RED)
EndIf
ClickP($aAway, 2, 0, "#0312")
EndFunc
Func ClanLevel()
Setlog("Finding your Clan Level, wait..", $COLOR_BLUE)
ClickP($aAway, 2, 20, "#0467")
If _Sleep($iDelayClanLevel1) Then Return
If Not _ColorCheck(_GetPixelColor(19, 474 + $midOffsetY, True), Hex(0xE2A539, 6), 15) Then
SetLog("Please join a Clan ...", $COLOR_GREEN)
If $iPlannedRequestCCHoursEnable = 1 Then
$canRequestCC = False
SetLog("Clan Requests Turned Off, be careful with your settings!", $COLOR_RED)
EndIf
$iClanLevel = 0
Return
EndIf
If $debugSetlog = 1 Then SetLog("Click $aOpenChat", $COLOR_DEBUG)
If IsMainPage() Then ClickP($aOpenChat, 1, 0, "#0468")
If WaitforPixel(299, 22, 300, 23, Hex(0x000000, 6), 5, $iDelayClanLevel1) Then
If _Sleep($iDelayDonateCC2) Then Return
If IsMainChatOpenPage() Then Click(222, 22)
If _Sleep($iDelayDonateCC2) Then Return
If $debugSetlog = 1 Then SetLog("Click $aClanTab", $COLOR_DEBUG)
If IsMainChatOpenPage() Then ClickP($aClanTab, 1, 0, "#0469")
EndIf
If $debugSetlog = 1 Then SetLog("Wait until find the Info icon , max 5 seconds", $COLOR_DEBUG)
If WaitforPixel(282, 55, 285, 57, Hex(0x3088c2, 6), 5, 10) Then
If $debugSetlog = 1 Then SetLog("Click $aClanInfo", $COLOR_DEBUG)
If IsMainChatOpenPage() Then ClickP($aClanInfo, 1, 0, "#0470")
Else
SetLog("Please join a Clan ...", $COLOR_GREEN)
If _ColorCheck(_GetPixelColor($aCloseChat[0], $aCloseChat[1], True), Hex($aCloseChat[2], 6), $aCloseChat[3]) Then
If IsMainChatOpenPage() Then Click($aCloseChat[0], $aCloseChat[1], 1, 0, "#0471")
EndIf
Return
EndIf
If _Sleep($iDelayDonateCC1) Then Return
$iClanLevel = ""
If $debugSetlog = 1 Then SetLog("Wait until find the Clan Perk Button, max 5 seconds", $COLOR_DEBUG)
If WaitforPixel(95, 243 + $midOffsetY, 98, 244 + $midOffsetY, Hex(0x7cd8e8, 6), 5, $iDelayClanLevel1) Then
$iClanLevel = getOcrClanLevel(87, 101 + $midOffsetY)
If Not $iClanLevel = "" Then
SetLog("Found Clan Level: " & $iClanLevel, $COLOR_GREEN)
Else
SetLog("Error finding Clan Level...", $COLOR_RED)
$iClanLevel = 8
EndIf
EndIf
If IsClanInfoPage() Then Click(830, 73, 1, 0, "#0473")
If _Sleep($iDelayDonateCC1) Then Return
$i = 0
While 1
If _Sleep(100) Then Return
If _ColorCheck(_GetPixelColor($aCloseChat[0], $aCloseChat[1], True), Hex($aCloseChat[2], 6), $aCloseChat[3]) Then
If IsMainChatOpenPage() Then Click($aCloseChat[0], $aCloseChat[1], 1, 0, "#0472")
ExitLoop
Else
If _Sleep(100) Then Return
$i += 1
If $i > 30 Then
SetLog("Error finding Clan tab to close...", $COLOR_RED)
ExitLoop
EndIf
EndIf
WEnd
If _Sleep($iDelayDonateCC1) Then Return
EndFunc
Func StarBonus()
If $debugSetlog = 1 Then Setlog("Begin Star Bonus window check", $COLOR_DEBUG)
If _CheckPixel($aIsMainGrayed, $bCapturePixel) = False Then Return
If $debugSetlog = 1 Then Setlog("StarBonusWindowChk #1: " & _GetPixelColor(640, 185 + $midOffsetY, $bCapturePixel) & ", #2: " & _GetPixelColor(650, 462 + $bottomOffsetY, $bCapturePixel), $COLOR_DEBUG)
If _Sleep($iDelayStarBonus100) Then Return
If _ColorCheck(_GetPixelColor(640, 185 + $midOffsetY, $bCapturePixel), Hex(0xC00F15, 6), 10) And  _ColorCheck(_GetPixelColor(650, 462 + $bottomOffsetY, $bCapturePixel), Hex(0xE8E8E0, 6), 10) Then
Local $offColors[3][3] = [[0x000000, 143, 0], [0xFFFFFF, 53, 17], [0xFFFFFF, 53, 29]]
Global $ButtonPixel = _MultiPixelSearch(353, 440 + $midOffsetY, 502, 474 + $midOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $debugSetlog = 1 Then Setlog("Bonus Okay btn chk-#1: " & _GetPixelColor(355, 441 + $midOffsetY, $bCapturePixel) & ", #2: " & _GetPixelColor(355 + 143, 441 + $midOffsetY, $bCapturePixel) & ", #3: " & _GetPixelColor(355 + 53, 441 + 17 + $midOffsetY, $bCapturePixel) & ", #4: " & _GetPixelColor(355 + 53, 441 + 29 + $midOffsetY, $bCapturePixel), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Bonus Okay Pixel color found #1: " & _GetPixelColor($ButtonPixel[0], $ButtonPixel[1], $bCapturePixel) & ", #2: " & _GetPixelColor($ButtonPixel[0] + 143, $ButtonPixel[1], $bCapturePixel) & ", #3: " & _GetPixelColor($ButtonPixel[0] + 53, $ButtonPixel[1] + 17, $bCapturePixel) & ", #4: " & _GetPixelColor($ButtonPixel[0] + 53, $ButtonPixel[1] + 29, $bCapturePixel), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 1, 0, "#0000")
If _Sleep($iDelayStarBonus500) Then Return
Return True
EndIf
EndIf
If $debugSetlog = 1 Then Setlog("Star Bonus window not found?", $COLOR_DEBUG)
Return False
EndFunc
Func getNumberOfDrills($listPixelByLevel = -1)
Local $aReturn
Local $result = 0
If Not IsArray($listPixelByLevel) Then $listPixelByLevel = getDrillArray()
If $listPixelByLevel[1] <> "" Then $result = $listPixelByLevel[0]
If $debugSetLog = 1 Then SetLog("Total No. of Dark Elixir Drills = " & $result, $COLOR_FUCHSIA)
Return $result
EndFunc
Func fillDrillArray($listPixelByLevel = -1)
Local $result[4][5] = [	[-1, -1, -1, -1, -1],  [-1, -1, -1, -1, -1],  [-1, -1, -1, -1, -1],  [-1, -1, -1, -1, -1]]
Local $pixel[2], $pixelWithLevel, $level, $pixelStr
Local $numDrills = getNumberOfDrills($listPixelByLevel)
If Not IsArray($listPixelByLevel) Then $listPixelByLevel = getDrillArray()
If $numDrills > 0 Then
For $i = 1 To $numDrills
$pixelWithLevel = StringSplit($listPixelByLevel[$i], "#")
If @error Then ContinueLoop
If $debugSetLog = 1 Then
Setlog("Drill search UBound($pixelWithLevel) = " & UBound($pixelWithLevel) - 1, $COLOR_PURPLE)
For $j = 0 To UBound($pixelWithLevel) - 1
Setlog("Drill search $pixelWithLevel[" & $j & "] = " & $pixelWithLevel[$j], $COLOR_PURPLE)
Next
EndIf
$level = $pixelWithLevel[1]
$pixelStr = StringSplit($pixelWithLevel[2], "-")
$pixel[0] = $pixelStr[1]
$pixel[1] = $pixelStr[2]
If $debugSetLog = 1 Then
Setlog("Drill search $level = " & $level, $COLOR_PURPLE)
For $j = 0 To UBound($pixelStr) - 1
Setlog("Drill search $pixelStr[" & $j & "] = " & $pixelStr[$j], $COLOR_PURPLE)
Next
EndIf
If isInsideDiamond($pixel) Then
$result[$i][0] = Number($pixel[0])
$result[$i][1] = Number($pixel[1])
$result[$i][2] = Number($level)
$result[$i][3] = $drillLevelHold[Number($level) - 1]
$result[$i][4] = $drillLevelSteal[Number($level) - 1]
If $debugSetLog = 1 Then SetLog("Dark Elixir Drill: [" & $result[$i][0] & "," & $result[$i][1] & "], Level: " & $result[$i][2] & ", Hold: " & $result[$i][3] & ", Steal: " & $result[$i][4], $COLOR_BLUE)
Else
If $debugSetLog = 1 Then SetLog("Dark Elixir Drill: [" & $pixel[0] & "," & $pixel[1] & "], Level: " & $level, $COLOR_PURPLE)
If $debugSetLog = 1 Then SetLog("Found Dark Elixir Drill with an invalid location.", $COLOR_RED)
EndIf
Next
EndIf
Return $result
EndFunc
Func getDrillArray()
Local $result, $listPixelByLevel
Local $numDrills = 0
_CaptureRegion2()
$result = GetLocationDarkElixirWithLevel()
$listPixelByLevel = StringSplit($result, "~")
If $debugSetLog = 1 Then
Setlog("Drill search $result[0] = " & $result, $COLOR_PURPLE)
$numDrills = getNumberOfDrills($listPixelByLevel)
If $numDrills > 0 Then
For $i = 1 To $numDrills
Setlog("Drill search $listPixelByLevel[" & $i & "] = " & $listPixelByLevel[$i], $COLOR_PURPLE)
Next
EndIf
EndIf
Return $listPixelByLevel
EndFunc
Func drillSearch($listPixelByLevel = -1)
If $ichkSmartZap <> 1 Then Return False
If Not IsArray($listPixelByLevel) Then $listPixelByLevel = getDrillArray()
Return fillDrillArray($listPixelByLevel)
EndFunc
Func displayStealableLog($aDarkDrills)
Local $drillStealableString = "Estimated stealable DE in Drills: "
For $i = 0 To UBound($aDarkDrills) - 1
If $i = 0 Then
If $aDarkDrills[$i][3] <> -1 Then $drillStealableString &= $aDarkDrills[$i][3]
Else
If $aDarkDrills[$i][3] <> -1 Then $drillStealableString &= ", " & $aDarkDrills[$i][3]
EndIf
Next
If $drillStealableString <> "Estimated stealable DE in Drills: " Then SetLog($drillStealableString, $COLOR_FUCHSIA)
EndFunc
Func getDarkElixir()
Local $searchDark = "", $iCount = 0
If _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0a050a, 6), 10) Or _ColorCheck(_GetPixelColor(31, 144, True), Hex(0x0F0617, 6), 5) Then
While $searchDark = ""
$oldSearchDark = $searchDark
$searchDark = getDarkElixirVillageSearch(45, 125)
$iCount += 1
If $debugSetLog = 1 Then Setlog("$searchDark = " & $searchDark & ", $oldSearchDark = " & $oldSearchDark, $COLOR_PURPLE)
If $iCount > 15 Then ExitLoop
If _Sleep(1000) Then Return
WEnd
Else
$searchDark = False
If $debugSetLog = 1 Then SetLog("No DE Detected.", $COLOR_PURPLE)
EndIf
Return $searchDark
EndFunc
Func getDrillOffset()
Local $result = -1
Switch $iTownHallLevel
Case 0 To 7
$result = 2
Case 8
$result = 1
Case Else
$result = 0
EndSwitch
Return $result
EndFunc
Func getSpellOffset()
Local $result = -1
Switch $iTownHallLevel
Case 0 To 4
$result = -1
Case 5, 6
$result = -1
Case 7, 8
$result = 2
Case 9
$result = 1
Case Else
$result = 0
EndSwitch
Return $result
EndFunc
Func smartZap($minDE = -1)
Local $searchDark, $oldSearchDark = 0, $numSpells, $skippedZap = True, $performedZap = False, $dropPoint
If $ichkSmartZap <> 1 Then Return $performedZap
If $ichkNoobZap = 1 Then SetLog("====== Your Activate NoobZap Mode ======", $COLOR_RED)
If $DebugSmartZap = 1 Then SetLog("$ichkSmartZap = " & $ichkSmartZap & " | $ichkNoobZap = " & $ichkNoobZap, $COLOR_DEBUG)
If $minDE = -1 Then $minDE = Number($itxtMinDE)
$searchDark = getDarkElixirVillageSearch(45, 125)
If Number($searchDark) = 0 Then
SetLog("No Dark Elixir so lets just exit!", $COLOR_FUCHSIA)
Return $performedZap
ElseIf isDarkElixirFull() Then
SetLog("Your Dark Elixir Storage is full, no need to zap!", $COLOR_FUCHSIA)
Return $performedZap
ElseIf $iTownHallLevel < 7 Then
SetLog("You do not have the ability to store Dark Elixir, time to go home!", $COLOR_FUCHSIA)
Return $performedZap
ElseIf (Number($searchDark) < Number($minDE)) Then
SetLog("Dark Elixir is below minimum value [" & $itxtMinDE & "], Exiting Now!", $COLOR_FUCHSIA)
Return $performedZap
EndIf
If $DebugSmartZap = 1 Then
SetLog("$searchDark = " & $searchDark, $COLOR_DEBUG)
SetLog("isDarkElixirFull() = " & isDarkElixirFull(), $COLOR_DEBUG)
SetLog("$iTownHallLevel = " & $iTownHallLevel, $COLOR_DEBUG)
SetLog("$itxtMinDE = " & $itxtMinDE, $COLOR_DEBUG)
SetLog("$itxtExpectedDE = " & $itxtExpectedDE, $COLOR_DEBUG)
SetLog("$sMinTimeCloseATK = " & $sMinTimeCloseATK & "s", $COLOR_DEBUG)
EndIf
If $ichkSmartZapDB = 1 And $iMatchMode <> $DB Then
SetLog("Not a dead base so lets just go home!", $COLOR_FUCHSIA)
Return $performedZap
EndIf
If $DebugSmartZap = 1 Then SetLog("$ichkSmartZapDB = " & $ichkSmartZapDB, $COLOR_DEBUG)
Local $aDrills
Local $listPixelByLevel = getDrillArray()
Local $aDarkDrills = drillSearch($listPixelByLevel)
Local $strikeOffsets = [7, 10]
Local $drillLvlOffset, $spellAdjust, $numDrills, $testX, $testY, $tempTestX, $tempTestY, $strikeGain, $expectedDE
Local $error = 5
$numDrills = getNumberOfDrills($listPixelByLevel)
If $DebugSmartZap = 1 Then SetLog("$numDrills = " & $numDrills, $COLOR_DEBUG)
If $numDrills = 0 Then
SetLog("No drills found, time to go home!", $COLOR_FUCHSIA)
Return $performedZap
Else
SetLog("Number of Dark Elixir Drills: " & $numDrills, $COLOR_FUCHSIA)
EndIf
$numSpells = $LSpellComp
If $DebugSmartZap = 1 Then SetLog("$LSpellComp = " & $LSpellComp, $COLOR_DEBUG)
If $numSpells = 0 Then
SetLog("No lightning spells trained, time to go home!", $COLOR_FUCHSIA)
Return $performedZap
Else
SetLog("Number of Lightning Spells: " & $numSpells, $COLOR_FUCHSIA)
EndIf
_ArraySort($aDarkDrills, 1, 0, 0, 3)
$drillLvlOffset = getDrillOffset()
If $debugSetLog = 1 Then SetLog("Drill Level Offset is: " & $drillLvlOffset, $COLOR_PURPLE)
$spellAdjust = getSpellOffset()
If $debugSetLog = 1 Then SetLog("Spell Adjust is: " & $spellAdjust, $COLOR_PURPLE)
Local $itotalStrikeGain = 0
While IsAttackPage() And $numSpells > 0 And $aDarkDrills[0][3] <> -1 And $spellAdjust <> -1
Local $oldSearchDark = $searchDark
CheckHeroesHealth()
If ($searchDark < Number($itxtMinDE)) Then
SetLog("Dark Elixir is below minimum value [" & $itxtMinDE & "], Exiting Now!", $COLOR_ACTION)
Return $performedZap
EndIf
If $ichkNoobZap = 1 Then
SetLog("NoobZap will attack any drill.", $COLOR_ACTION)
zapDrill($eLSpell, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$performedZap = True
$skippedZap = False
If _Sleep(3500) Then Return
Else
displayStealableLog($aDarkDrills)
If $numSpells > (4 - $spellAdjust) Then
SetLog("First condition: " & 4 - $spellAdjust & "+ Spells so attack any drill.", $COLOR_FUCHSIA)
zapDrill($eLSpell, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$performedZap = True
$skippedZap = False
If _Sleep(3500) Then Return
ElseIf $numSpells > (3 - $spellAdjust) And $aDarkDrills[0][2] > (3 - $drillLvlOffset) Then
SetLog("Second condition: Attack Lvl " & 3 - $drillLvlOffset & "+ drills if you have " & 3 - $spellAdjust & "+ spells", $COLOR_FUCHSIA)
zapDrill($eLSpell, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$performedZap = True
$skippedZap = False
If _Sleep(3500) Then Return
ElseIf $aDarkDrills[0][2] > (4 - $drillLvlOffset) And ($aDarkDrills[0][3] / $DrillLevelHold[$aDarkDrills[0][2] - 1]) > 0.3 Then
SetLog("Third condition: Attack Lvl " & 4 - $drillLvlOffset & "+ drills with more then 30% estimated DE if you have less than " & 4 - $spellAdjust & " spells", $COLOR_FUCHSIA)
zapDrill($eLSpell, $aDarkDrills[0][0] + $strikeOffsets[0], $aDarkDrills[0][1] + $strikeOffsets[1])
$performedZap = True
$skippedZap = False
If _Sleep(3500) Then Return
Else
$skippedZap = True
SetLog("Drill did not match any attack conditions, so we will remove it from the list.", $COLOR_FUCHSIA)
For $i = 0 To UBound($aDarkDrills, 2) - 1
$aDarkDrills[0][$i] = -1
Next
EndIf
EndIf
$searchDark = getDarkElixir()
If Not $searchDark Or $searchDark = 0 Then
SetLog("No Dark Elixir so lets just exit!", $COLOR_FUCHSIA)
If $DebugSmartZap = 1 Then SetLog("$searchDark = " & $searchDark, $COLOR_DEBUG)
Return $performedZap
EndIf
If $skippedZap = False Then
$strikeGain = $oldSearchDark - $searchDark
$numLSpellsUsed += 1
$numSpells -= 1
If $aDarkDrills[0][2] <> -1 Then
If $ichkNoobZap = 0 Then
$expectedDE = $drillLevelSteal[($aDarkDrills[0][2] - 1)] * 0.75
Else
$expectedDE = $itxtExpectedDE
EndIf
Else
$expectedDE = -1
EndIf
If $strikeGain < $expectedDE And $expectedDE <> -1 Then
For $i = 0 To UBound($aDarkDrills, 2) - 1
$aDarkDrills[0][$i] = -1
Next
SetLog("Gained: " & $strikeGain & ", Expected: " & $expectedDE, $COLOR_PURPLE)
SetLog("Last zap gained less DE then expected, removing the drill from the list.", $COLOR_ACTION)
Else
$aDarkDrills[0][3] -= $strikeGain
SetLog("Gained: " & $strikeGain & ". Adjusting amount left in this drill.", $COLOR_PURPLE)
EndIf
$itotalStrikeGain += $strikeGain
$smartZapGain += $strikeGain
SetLog("DE from last zap: " & $strikeGain & ", Total DE from SmartZap/NoobZap: " & $itotalStrikeGain, $COLOR_FUCHSIA)
EndIf
_ArraySort($aDarkDrills, 1, 0, 0, 3)
$aDrills = drillSearch()
If $aDarkDrills[0][0] <> -1 Then
$testX = -1
$testY = -1
For $i = 0 To UBound($aDrills) - 1
If $aDrills[$i][0] <> -1 Then
$tempTestX = Abs($aDrills[$i][0] - $aDarkDrills[0][0])
$tempTestY = Abs($aDrills[$i][1] - $aDarkDrills[0][1])
If $debugSetLog = 1 Then SetLog("tempX: " & $tempTestX & " tempY: " & $tempTestY, $COLOR_PURPLE)
If $tempTestX < $error And $tempTestY < $error Then
$testX = $tempTestX
$testY = $tempTestY
ExitLoop
EndIf
EndIf
Next
If $debugSetLog = 1 Then SetLog("testX: " & $testX & " testY: " & $testY, $COLOR_PURPLE)
If ($testX > $error Or $testY > $error) And ($testX <> -1 Or $testY <> -1) Then
For $i = 0 To UBound($aDarkDrills, 2) - 1
$aDarkDrills[0][$i] = -1
Next
SetLog("Removing drill since it wasn't found, so it was probably destroyed.", $COLOR_FUCHSIA)
_ArraySort($aDarkDrills, 1, 0, 0, 3)
EndIf
EndIf
WEnd
Return $performedZap
EndFunc
Func zapDrill($THSpell, $x, $y)
Local $Spell = -1
Local $name = ""
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $THSpell Then
$Spell = $i
$name = NameOfTroop($THSpell, 0)
EndIf
Next
If $Spell > -1 Then
SetLog("Dropping " & $name)
SelectDropTroop($Spell)
If _Sleep($iDelayCastSpell1) Then Return
If IsAttackPage() Then Click($x, $y, 1, 0, "#0029")
Else
If $debugSetLog = 1 Then SetLog("No " & $name & " Found")
EndIf
EndFunc
Func Click($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $ichkUseAltRClick = 1 Then
$xclick = Random($x - 3, $x + 3, 1)
$yclick = Random($y - 3, $y + 3, 1)
If $xclick <= 0 Or $xclick >= 860 Then $xclick = $x
If $yclick <= 0 Or $yclick >= 680 + ($bottomOffsetY) Then $yclick = $y
FClick($xclick, $yclick, $times, $speed, $debugtxt)
Else
FClick($x, $y, $times, $speed, $debugtxt)
EndIf
EndFunc
Func PureClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $ichkUseAltRClick = 1 Then
$xclick = Random($x - 3, $x + 3, 1)
$yclick = Random($y - 3, $y + 3, 1)
If $xclick <= 0 Or $xclick >= 860 Then $xclick = $x
If $yclick <= 0 Or $yclick >= 680 + ($bottomOffsetY) Then $yclick = $y
FPureClick($xclick, $yclick, $times, $speed, $debugtxt)
Else
FPureClick($x, $y, $times, $speed, $debugtxt)
EndIf
EndFunc
Func GemClick($x, $y, $times = 1, $speed = 0, $debugtxt = "")
If $ichkUseAltRClick = 1 Then
$xclick = Random($x - 3, $x + 3, 1)
$yclick = Random($y - 3, $y + 3, 1)
If $xclick <= 0 Or $xclick >= 860 Then $xclick = $x
If $yclick <= 0 Or $yclick >= 680 + ($bottomOffsetY) Then $yclick = $y
FGemClick($xclick, $yclick, $times, $speed, $debugtxt)
Else
FGemClick($x, $y, $times, $speed, $debugtxt)
EndIf
EndFunc
Func randomSleep($SleepTime, $Range = 0)
If $RunState = False Then Return
If $Range = 0 Then $Range = Round($SleepTime / 5)
$SleepTimeF = Random($SleepTime - $Range, $SleepTime + $Range, 1)
If $DebugClick = 1 Then Setlog("Default sleep : " & $SleepTime & " - Random sleep : " & $SleepTimeF, $COLOR_ORANGE)
If _Sleep($SleepTimeF) Then Return
EndFunc
Func QuickMISDebug()
$RunState = True
$ValueReturned = InputBox("$ValueReturned", "Enter Return value tou want : BC1 - CX - N1 - NX - Q")
$Folder = FileSelectFolder("Select File", @ScriptDir)
SetLog(QuickMIS($ValueReturned, $Folder, 0, 0, $GAME_WIDTH, $GAME_HEIGHT, True))
SetLog("X=" & $QuickMISX & " - Y=" & $QuickMISY, $COLOR_ORANGE)
EndFunc
Func QuickMIS($ValueReturned, $directory, $Left = 0, $Top = 0, $Right = $GAME_WIDTH, $Bottom = $GAME_HEIGHT, $Debug = False)
If ($ValueReturned <> "BC1") And ($ValueReturned <> "CX") And ($ValueReturned <> "N1") And ($ValueReturned <> "NX") And ($ValueReturned <> "Q1") And ($ValueReturned <> "QX") Then
SetLog("Error of parameters settings during QuickMIS call for MultiSearch...", $COLOR_RED)
Return
EndIf
Sleep(1500)
_CaptureRegion2($Left, $Top, $Right, $Bottom)
Local $Res = DllCall($hImgLib, "str", "SearchMultipleTilesBetweenLevels", "handle", $hHBitmap2, "str", $directory, "str", "FV", "Int", 0, "str", "FV", "Int", 0, "Int", 1000)
If IsArray($Res) Then
If $Debug Then _ArrayDisplay($Res)
If $DebugSetlog = 1 Then SetLog("DLL Call succeeded " & $Res[0], $COLOR_PURPLE)
If $Res[0] = "" Or $Res[0] = "0" Then
If $DebugSetlog Then SetLog("No Button found")
Switch $ValueReturned
Case "BC1"
Return False
Case "CX"
Return "-1"
Case "N1"
Return "none"
Case "NX"
Return "none"
Case "Q1"
Return 0
Case "QX"
Return 0
EndSwitch
ElseIf StringInStr($Res[0], "-1") <> 0 Then
SetLog("DLL Error", $COLOR_RED)
Else
Switch $ValueReturned
Case "BC1"
Local $Result = ""
$KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
$DLLRes = DllCall($pImgLib, "str", "GetProperty", "str", $KeyValue[$i], "str", "objectpoints")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result, (StringLen($Result) - 1))
$CoordsInArray = StringSplit($Result, ",", $STR_NOCOUNT)
$QuickMISX = $CoordsInArray[0]
$QuickMISY = $CoordsInArray[1]
Return True
Case "CX"
Local $Result = ""
$KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
$DLLRes = DllCall($pImgLib, "str", "GetProperty", "str", $KeyValue[$i], "str", "objectpoints")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result, (StringLen($Result) - 1))
$CoordsInArray = StringSplit($Result, "|", $STR_NOCOUNT)
Return $CoordsInArray
Case "N1"
$MultiImageSearchResult = StringSplit($Res[0], "|")
$FilenameFound = StringSplit($MultiImageSearchResult[1], "_")
Return $FilenameFound[1]
Case "NX"
Local $AllFilenamesFound = ""
$MultiImageSearchResult = StringSplit($Res[0], "|")
For $i = 1 To $MultiImageSearchResult[0]
$FilenameFound = StringSplit($MultiImageSearchResult[$i], "_")
$AllFilenamesFound &= $FilenameFound[1] & "|"
Next
If StringRight($AllFilenamesFound, 1) = "|" Then $AllFilenamesFound = StringLeft($AllFilenamesFound, (StringLen($AllFilenamesFound) - 1))
Return $AllFilenamesFound
Case "Q1"
Local $Result = ""
$KeyValue = StringSplit($Res[0], "|", $STR_NOCOUNT)
For $i = 0 To UBound($KeyValue) - 1
$DLLRes = DllCall($pImgLib, "str", "GetProperty", "str", $KeyValue[$i], "str", "totalobjects")
$Result &= $DLLRes[0] & "|"
Next
If StringRight($Result, 1) = "|" Then $Result = StringLeft($Result, (StringLen($Result) - 1))
$QuantityInArray = StringSplit($Result, "|", $STR_NOCOUNT)
Return $QuantityInArray[0]
Case "QX"
$MultiImageSearchResult = StringSplit($Res[0], "|", $STR_NOCOUNT)
Return UBound($MultiImageSearchResult)
EndSwitch
EndIf
EndIf
EndFunc
Func BotHumanization()
If $ichkUseBotHumanization = 1 Then
Local $NoActionsToDo = 0
SetLog("Now, let the DocOc Team make your BOT more human ... :)", $COLOR_SUCCESS1)
If $ichkLookAtRedNotifications = 1 Then LookAtRedNotifications()
If $ichkCollectAchievements = 1 Then CollectAchievements()
For $i = 0 To 12
$ActionEnabled = _GUICtrlComboBox_GetCurSel($cmbPriority[$i])
If $ActionEnabled = 0 Then $NoActionsToDo += 1
Next
If $NoActionsToDo <> 13 Then
$MaxActionsNumber = Random(1, _GUICtrlComboBox_GetCurSel($cmbMaxActionsNumber) + 1, 1)
SetLog("DocOc will do " & $MaxActionsNumber & " human actions during this loop...", $COLOR_INFO)
For $i = 1 To $MaxActionsNumber
Local $CheckStep = 0
While Not IsMainScreen() And $CheckStep <= 5
AndroidBackButton()
Sleep(3000)
$CheckStep += 1
WEnd
If Not IsMainScreen() Then
SetLog("Main screen not found, need to restart CoC app...", $COLOR_ERROR)
RestartAndroidCoC()
waitMainScreen()
EndIf
randomSleep(1500)
RandomHumanAction()
Next
Else
SetLog("All actions disabled, skipping...", $COLOR_WARNING)
EndIf
SetLog("Bot Humanization finished !!! :)", $COLOR_SUCCESS1)
EndIf
EndFunc
Func RandomHumanAction()
For $i = 0 To 12
SetActionPriority($i)
Next
$ActionToDo = _ArrayMaxIndex($SetActionPriority)
Switch $ActionToDo
Case 0
SetLog("The spirit of DocOc chose to read Clan Chat... Let's go !!! :)", $COLOR_INFO)
ReadClanChat()
Case 1
SetLog("The spirit of DocOc chose to read Global Chat... Let's go !!! :)", $COLOR_INFO)
ReadGlobalChat()
Case 2
SetLog("The spirit of DocOc chose to talk with your Clan... Let's go !!! :)", $COLOR_INFO)
SaySomeChat()
Case 3
SetLog("The spirit of DocOc chose to Watch a Defense... Let's go !!! :)", $COLOR_INFO)
WatchDefense()
Case 4
SetLog("The spirit of DocOc chose to Watch an Attack... Let's go !!! :)", $COLOR_INFO)
WatchAttack()
Case 5
SetLog("The spirit of DocOc chose to Look at War Log... Let's go !!! :)", $COLOR_INFO)
LookAtWarLog()
Case 6
SetLog("The spirit of DocOc chose to Visit Clanmates... Let's go !!! :)", $COLOR_INFO)
VisitClanmates()
Case 7
SetLog("The spirit of DocOc chose to Visit Best Players... Let's go !!! :)", $COLOR_INFO)
VisitBestPlayers()
Case 8
SetLog("The spirit of DocOc chose to Look at Best Clans... Let's go !!! :)", $COLOR_INFO)
LookAtBestClans()
Case 9
SetLog("The spirit of DocOc chose to Look at Current War... Let's go !!! :)", $COLOR_INFO)
LookAtCurrentWar()
Case 10
SetLog("The spirit of DocOc chose to Watch War replays... Let's go !!! :)", $COLOR_INFO)
WatchWarReplays()
Case 11
SetLog("The spirit of DocOc chose to do nothing... Stupid BOT... :)", $COLOR_INFO)
DoNothing()
Case 12
SetLog("The spirit of DocOc chose to launch Challenges... Let's go !!! :)", $COLOR_INFO)
LaunchChallenges()
EndSwitch
EndFunc
Func SetActionPriority($ActionNumber)
If _GUICtrlComboBox_GetCurSel($cmbPriority[$ActionNumber]) <> 0 Then
MatchPriorityNValue($ActionNumber)
$SetActionPriority[$ActionNumber] = Random($MinimumPriority, 100, 1)
Else
$SetActionPriority[$ActionNumber] = 0
EndIf
EndFunc
Func MatchPriorityNValue($ActionNumber)
Switch _GUICtrlComboBox_GetCurSel($cmbPriority[$ActionNumber])
Case 1
$MinimumPriority = 0
Case 2
$MinimumPriority = 25
Case 3
$MinimumPriority = 50
Case 4
$MinimumPriority = 75
EndSwitch
EndFunc
Func chkUseBotHumanization()
If GUICtrlRead($chkUseBotHumanization) = $GUI_CHECKED Then
$ichkUseBotHumanization = 1
For $i = $Icon1 To $chkLookAtRedNotifications
GUICtrlSetState($i, $GUI_ENABLE)
Next
cmbStandardReplay()
cmbWarReplay()
Else
$ichkUseBotHumanization = 0
For $i = $Icon1 To $chkLookAtRedNotifications
GUICtrlSetState($i, $GUI_DISABLE)
Next
EndIf
EndFunc
Func chkUseAltRClick()
If GUICtrlRead($chkUseAltRClick) = $GUI_CHECKED Then
$UserChoice = MsgBox(4 + 48, "Warning !!!", "Full random click is a good feature to be as less BOT-Like as possible because it makes ALL BOT clicks random..." & @CRLF & "" & @CRLF & "The crazy @RoroTiti use it all the time an he says there is no problem with it... BUT, it still an experimental feature which may cause unpredictable problems..." & @CRLF & "" & @CRLF & "So, do you want to use it ? :)" & @CRLF & "" & @CRLF & "PS : No support will be provided to you if you use this function...")
If $UserChoice = 6 Then
$ichkUseAltRClick = 1
Else
$ichkUseAltRClick = 0
GUICtrlSetState($chkUseAltRClick, $GUI_UNCHECKED)
EndIf
Else
$ichkUseAltRClick = 0
EndIf
EndFunc
Func chkCollectAchievements()
If GUICtrlRead($chkCollectAchievements) = $GUI_CHECKED Then
$ichkCollectAchievements = 1
Else
$ichkCollectAchievements = 0
EndIf
EndFunc
Func chkLookAtRedNotifications()
If GUICtrlRead($chkLookAtRedNotifications) = $GUI_CHECKED Then
$ichkLookAtRedNotifications = 1
Else
$ichkLookAtRedNotifications = 0
EndIf
EndFunc
Func cmbStandardReplay()
If _GUICtrlComboBox_GetCurSel($cmbPriority[3]) = 0 Then
If _GUICtrlComboBox_GetCurSel($cmbPriority[4]) = 0 Then
For $i = $Label7 To $cmbPause[0]
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
For $i = $Label7 To $cmbPause[0]
GUICtrlSetState($i, $GUI_ENABLE)
Next
EndIf
ElseIf _GUICtrlComboBox_GetCurSel($cmbPriority[4]) = 0 Then
If _GUICtrlComboBox_GetCurSel($cmbPriority[3]) = 0 Then
For $i = $Label7 To $cmbPause[0]
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
For $i = $Label7 To $cmbPause[0]
GUICtrlSetState($i, $GUI_ENABLE)
Next
EndIf
EndIf
EndFunc
Func cmbWarReplay()
If _GUICtrlComboBox_GetCurSel($cmbPriority[10]) = 0 Then
For $i = $Label13 To $cmbPause[1]
GUICtrlSetState($i, $GUI_DISABLE)
Next
Else
For $i = $Label13 To $cmbPause[1]
GUICtrlSetState($i, $GUI_ENABLE)
Next
EndIf
EndFunc
Func WaitForReplayWindow()
SetLog("Waiting for Replay screen...", $COLOR_ACTION)
Local $CheckStep = 0
While Not IsReplayWindow() And $CheckStep < 30
Sleep(1000)
$CheckStep += 1
WEnd
Return $OnReplayWindow
EndFunc
Func IsReplayWindow()
$OnReplayWindow = _ColorCheck(_GetPixelColor(799, 619, True), "FF5151", 20)
Return $OnReplayWindow
EndFunc
Func GetReplayDuration()
Local $MaxSpeed = _GUICtrlComboBox_GetCurSel($cmbMaxSpeed[$ReplayToPause])
Local $Result = QuickMIS("N1", @ScriptDir & "\images\Resources\Humanization Pics\Duration", 380, 600, 490, 630)
If $Result = "OneMinute" Then
$ReplayDuration[0] = 1
$ReplayDuration[1] = 90000
ElseIf $Result = "TwoMinutes" Then
$ReplayDuration[0] = 2
$ReplayDuration[1] = 150000
ElseIf $Result = "ThreeMinutes" Then
$ReplayDuration[0] = 3
$ReplayDuration[1] = 180000
Else
$ReplayDuration[0] = 0
$ReplayDuration[1] = 45000
EndIf
Switch $MaxSpeed
Case 1
$ReplayDuration[1] /= 2
Case 2
$ReplayDuration[1] /= 4
EndSwitch
SetLog("Estimated Replay Duration : " & $ReplayDuration[1] / 1000 & " second(s)", $COLOR_INFO)
EndFunc
Func AccelerateReplay($ReplayToPause)
Local $CurrentSpeed = 0
Local $MaxSpeed = _GUICtrlComboBox_GetCurSel($cmbMaxSpeed[$ReplayToPause])
If $CurrentSpeed <> $MaxSpeed Then SetLog("Let's make the replay faster...", $COLOR_ACTION1)
While $CurrentSpeed < $MaxSpeed
Click(820, 690)
randomSleep(500)
$CurrentSpeed += 1
WEnd
EndFunc
Func DoAPauseDuringReplay($ReplayToPause)
Local $MinimumToPause = 0, $PauseScore = 0
Local $Pause = _GUICtrlComboBox_GetCurSel($cmbPause[0])
If $Pause <> 0 Then
Switch $Pause
Case 1
$MinimumToPause = 80
Case 2
$MinimumToPause = 60
Case 3
$MinimumToPause = 40
Case 4
$MinimumToPause = 20
EndSwitch
$PauseScore = Random(0, 100, 1)
If $PauseScore > $MinimumToPause Then
SetLog("Let's do a small pause to see what happens...", $COLOR_ACTION1)
Click(750, 690)
randomSleep(10000, 3000)
SetLog("Pause finished, let's relaunch replay !!!", $COLOR_ACTION1)
Click(750, 690)
EndIf
EndIf
EndFunc
Func VisitAPlayer()
SetLog("Let's visit player...", $COLOR_INFO)
If QuickMIS("BC1", @ScriptDir & "\images\Resources\Humanization Pics\Visit") Then
Click($QuickMISX, $QuickMISY)
randomSleep(8000)
For $i = 0 To Random(1, 4, 1)
SetLog("We will click on a random builing...", $COLOR_ACTION1)
$xInfo = Random(250, 650, 1)
$yInfo = Random(200, 500, 1)
Click($xInfo, $yInfo)
randomSleep(1500)
SetLog("... and open his Info window...", $COLOR_ACTION1)
Click(430, 660)
randomSleep(8000)
Click(750, 100)
randomSleep(3000)
Next
Else
SetLog("Error when trying to find Visit button... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func DoNothing()
SetLog("Let the BOT wait a little before continue...", $COLOR_ACTION1)
randomSleep(8000, 3000)
EndFunc
Func LookAtRedNotifications()
SetLog("Looking for red notifications...", $COLOR_INFO)
Local $NotificationsFound = QuickMIS("NX", @ScriptDir & "\images\Resources\Humanization Pics\RedNotifications")
If StringInStr($NotificationsFound, "RedMessages") Then
SetLog("You have a new message...", $COLOR_ACTION1)
Click(400, 150)
randomSleep(8000, 3000)
Click(760, 120)
EndIf
randomSleep(1500)
If StringInStr($NotificationsFound, "RedCup") Then
SetLog("You changed of league...", $COLOR_ACTION1)
Click(40, 80)
randomSleep(4000)
Click(830, 80)
EndIf
randomSleep(1500)
If StringInStr($NotificationsFound, "RedWar") Then
SetLog("Current War to look at...", $COLOR_ACTION1)
Click(40, 520)
randomSleep(8000, 3000)
Click(70, 680)
EndIf
randomSleep(1500)
If StringInStr($NotificationsFound, "RedChat") Then
SetLog("New messages on the chat room...", $COLOR_ACTION1)
Click(20, 380)
randomSleep(3000)
Click(330, 380)
EndIf
randomSleep(1500)
If StringInStr($NotificationsFound, "PurpleShop") Or StringInStr($NotificationsFound, "RedShop") Then
SetLog("There is something new on the shop...", $COLOR_ACTION1)
Click(800, 670)
randomSleep(4000)
Click(820, 40)
EndIf
randomSleep(1500)
EndFunc
Func CollectAchievements()
SetLog("Looking for achievement to collect...", $COLOR_INFO)
If QuickMIS("BC1", @ScriptDir & "\images\Resources\Humanization Pics\RedAchievements") Then
SetLog("WoW, achievement to collect !!! Lets obtain XP and Gems :D ...", $COLOR_ACTION1)
Click(820, 520)
randomSleep(3000)
If QuickMIS("BC1", @ScriptDir & "\images\Resources\Humanization Pics\ClaimReward") Then
Click($QuickMISX, $QuickMISY)
SetLog("Reward collected !!!", $COLOR_SUCCESS)
Else
SetLog("Error when trying to find ""Claim Reward"" button...", $COLOR_ERROR)
Click(680, 180)
EndIf
randomSleep(3000)
Else
SetLog("No achievement to collect...", $COLOR_ACTION1)
EndIf
EndFunc
Func Scroll($MaxScroll)
For $i = 0 To $MaxScroll
$x = Random(500 - 10, 500 + 10, 1)
$yStart = Random(600 - 10, 500 + 10, 1)
$yEnd = Random(200 - 10, 200 + 10, 1)
ClickDrag($x, $yStart, $x, $yEnd)
randomSleep(4000)
Next
EndFunc
Func IsMessagesReplayWindow()
$Result = _ColorCheck(_GetPixelColor(760, 112, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsDefensesTab()
$Result = _ColorCheck(_GetPixelColor(180, 110, True), "F0F4F0", 20)
Return $Result
EndFunc
Func IsAttacksTab()
$Result = _ColorCheck(_GetPixelColor(380, 110, True), "F0F4F0", 20)
Return $Result
EndFunc
Func IsBestPlayers()
$Result = _ColorCheck(_GetPixelColor(530, 60, True), "F0F4F0", 20)
Return $Result
EndFunc
Func IsBestClans()
$Result = _ColorCheck(_GetPixelColor(350, 60, True), "F0F4F0", 20)
Return $Result
EndFunc
Func ChatOpen()
$Result = _ColorCheck(_GetPixelColor(330, 382, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsClanChat()
$Result = _ColorCheck(_GetPixelColor(220, 10, True), "787458", 20)
Return $Result
EndFunc
Func IsGlobalChat()
$Result = _ColorCheck(_GetPixelColor(80, 10, True), "787458", 20)
Return $Result
EndFunc
Func IsTextBox()
$Result = _ColorCheck(_GetPixelColor(190, 710, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsChallengeWindow()
$Result = _ColorCheck(_GetPixelColor(698, 56, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsChangeLayoutMenu()
$Result = _ColorCheck(_GetPixelColor(184, 58, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsClanOverview()
$Result = _ColorCheck(_GetPixelColor(822, 70, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsWarMenu()
$Result = _ColorCheck(_GetPixelColor(826, 34, True), "FFFFFF", 20)
Return $Result
EndFunc
Func IsMainScreen()
$Result = _ColorCheck(_GetPixelColor(191, 27, True), "FFFFFF", 20)
Return $Result
EndFunc
Func WatchDefense()
Click(40, 150)
randomSleep(1500)
If IsMessagesReplayWindow() Then
Click(190, 130)
randomSleep(1500)
If IsDefensesTab() Then
Click(710, (230 + 145 * Random(0, 2, 1)))
WaitForReplayWindow()
If IsReplayWindow() Then
GetReplayDuration()
randomSleep(1000)
If IsReplayWindow() Then
AccelerateReplay(0)
EndIf
randomSleep($ReplayDuration[1] / 3)
Local $IsBoring = Random(1, 5, 1)
If $IsBoring >= 4 Then
If IsReplayWindow() Then
SetLog("This replay is boring, let me go out... ;)", $COLOR_ACTION1)
Click(70, 680)
EndIf
Else
If IsReplayWindow() Then
DoAPauseDuringReplay(0)
EndIf
randomSleep($ReplayDuration[1] / 3)
If IsReplayWindow() And $ReplayDuration[0] <> 0 Then
DoAPauseDuringReplay(0)
EndIf
If IsReplayWindow() Then Setlog("Waiting for replay end...", $COLOR_ACTION)
While IsReplayWindow()
Sleep(2000)
WEnd
randomSleep(1000)
Click(70, 680)
EndIf
EndIf
Else
SetLog("Error when trying to open Defenses menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Replays menu... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func WatchAttack()
Click(40, 150)
randomSleep(1500)
If IsMessagesReplayWindow() Then
Click(380, 130)
randomSleep(1500)
If IsAttacksTab() Then
Click(710, (230 + 145 * Random(0, 2, 1)))
WaitForReplayWindow()
If IsReplayWindow() Then
GetReplayDuration()
randomSleep(1000)
If IsReplayWindow() Then
AccelerateReplay(0)
EndIf
randomSleep($ReplayDuration[1] / 3)
Local $IsBoring = Random(1, 5, 1)
If $IsBoring >= 4 Then
If IsReplayWindow() Then
SetLog("This replay is boring, let me go out... ;)", $COLOR_ACTION1)
randomSleep(1000)
Click(70, 680)
EndIf
Else
If IsReplayWindow() Then
DoAPauseDuringReplay(0)
EndIf
randomSleep($ReplayDuration[1] / 3)
If IsReplayWindow() And $ReplayDuration[0] <> 0 Then
DoAPauseDuringReplay(0)
EndIf
If IsReplayWindow() Then Setlog("Waiting for replay end...", $COLOR_ACTION)
While IsReplayWindow()
Sleep(2000)
WEnd
randomSleep(1000)
Click(70, 680)
EndIf
EndIf
Else
SetLog("Error when trying to open Defenses menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Replays menu... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func VisitBestPlayers()
Click(40, 80)
randomSleep(1500)
If IsClanOverview() Then
Click(540, 80)
randomSleep(3000)
If IsBestPlayers() Then
$PlayerList = Random(1, 2, 1)
Switch $PlayerList
Case 1
Click(270, 140)
Click(580, 350 + 52 * Random(0, 6, 1))
randomSleep(500)
VisitAPlayer()
Click(70, 680)
Case 2
Click(640, 140)
Click(580, 190 + 52 * Random(0, 9, 1))
randomSleep(500)
VisitAPlayer()
Click(70, 680)
EndSwitch
Else
SetLog("Error when trying to open Best Players menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open League menu... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func LookAtBestClans()
Click(40, 80)
randomSleep(1500)
If IsClanOverview() Then
Click(360, 80)
randomSleep(3000)
If IsBestClans() Then
$PlayerList = Random(1, 2, 1)
Switch $PlayerList
Case 1
Click(270, 140)
Click(580, 330 + 52 * Random(0, 6, 1))
Case 2
Click(640, 140)
Click(580, 190 + 52 * Random(0, 9, 1))
EndSwitch
randomSleep(1500)
If QuickMIS("BC1", @ScriptDir & "\images\Resources\Humanization Pics\WarLog") Then
SetLog("We have found a War log button, let's look at it...", $COLOR_ACTION1)
Click(100, 340)
randomSleep(1500)
SetLog("Let's scrolling the War log...", $COLOR_ACTION1)
Scroll(Random(0, 2, 1))
SetLog("Exiting War log window...", $COLOR_ACTION1)
Click(50, 80)
EndIf
randomSleep(1500)
SetLog("Let's scrolling the Clan member list...", $COLOR_ACTION1)
Scroll(Random(3, 5, 1))
Click(830, 80)
Else
SetLog("Error when trying to open Best Players menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open League menu... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func ReadClanChat()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If Not IsClanChat() Then SetLog("Warning, we will scroll Global chat...", $COLOR_WARNING)
$MaxScroll = Random(0, 3, 1)
SetLog("Let's scrolling the Chat...", $COLOR_ACTION1)
For $i = 0 To $MaxScroll
$x = Random(280 - 10, 280 + 10, 1)
$yStart = Random(110 - 10, 110 + 10, 1)
$yEnd = Random(660 - 10, 660 + 10, 1)
ClickDrag($x, $yStart, $x, $yEnd)
randomSleep(10000, 3000)
Next
Click(330, 380)
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func ReadGlobalChat()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(80, 20)
randomSleep(1500)
If Not IsGlobalChat() Then SetLog("Warning, we will scroll Clan chat...", $COLOR_WARNING)
$MaxScroll = Random(0, 3, 1)
SetLog("Let's scrolling the Chat...", $COLOR_ACTION1)
For $i = 0 To $MaxScroll
$x = Random(280 - 10, 280 + 10, 1)
$yStart = Random(110 - 10, 110 + 10, 1)
$yEnd = Random(660 - 10, 660 + 10, 1)
ClickDrag($x, $yStart, $x, $yEnd)
randomSleep(10000, 3000)
Next
Click(330, 380)
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func SaySomeChat()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If Not IsClanChat() Then SetLog("Warning, we will chat on Global chat...", $COLOR_WARNING)
Click(280, 710)
SetLog("Click the Chat button...", $COLOR_ACTION1)
randomSleep(2000)
If IsTextBox() Then
Local $ChatToSay = Random(0, 1, 1)
SetLog("Writing """"" & GUICtrlRead($humanMessage[$ChatToSay]) & """"" to the chat box...", $COLOR_ACTION1)
AndroidSendText(GUICtrlRead($humanMessage[$ChatToSay]))
randomSleep(500)
SetLog("And send text !!!", $COLOR_ACTION1)
Click(830, 710)
randomSleep(1500)
Click(330, 380)
Else
SetLog("Error when trying to open Text Box for chatting... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func LaunchChallenges()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If IsClanChat() Then
Click(260, 60)
randomSleep(1500)
If IsChallengeWindow() Then
Click(530, 110)
AndroidSendText(GUICtrlRead($challengeMessage), True)
randomSleep(1500)
$Layout = Random(1, 2, 1)
If $Layout <> $LastLayout Then
Click(240, 250)
randomSleep(1000)
If IsChangeLayoutMenu() Then
Switch $Layout
Case 1
$LastLayout = 1
$y = Random(190 - 10, 190 + 10, 1)
$xStart = Random(170 - 10, 170 + 10, 1)
$xEnd = Random(830 - 10, 830 + 10, 1)
ClickDrag($xStart, $y, $xEnd, $y)
randomSleep(2000)
Click(250, 180)
Case 2
$LastLayout = 2
$y = Random(190 - 10, 190 + 10, 1)
$xStart = Random(690 - 10, 690 + 10, 1)
$xEnd = Random(20 - 10, 20 + 10, 1)
ClickDrag($xStart, $y, $xEnd, $y)
randomSleep(2000)
Click(250, 180)
EndSwitch
Else
SetLog("Error when trying to open Change Layout menu... skipping...", $COLOR_WARNING)
EndIf
EndIf
If IsChallengeWindow() Then
randomSleep(1500)
Click(530, 250)
randomSleep(1500)
Click(330, 380)
Else
SetLog("We are not anymore on Start Challenge window... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Start Challenge window... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Clan Chat... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func LookAtWarLog()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If IsClanChat() Then
Click(120, 60)
randomSleep(1500)
If IsClanOverview() Then
If QuickMIS("BC1", @ScriptDir & "\images\Resources\Humanization Pics\WarLog") Then
Click(100, 340)
randomSleep(1500)
SetLog("Let's scrolling the War log...", $COLOR_ACTION1)
Scroll(Random(1, 3, 1))
Else
SetLog("No War log button found... skipping...", $COLOR_WARNING)
EndIf
Click(830, 180)
randomSleep(1000)
Click(330, 380)
Else
SetLog("Error when trying to open Clan overview... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Clan Chat... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func VisitClanmates()
Click(20, 380)
randomSleep(3000)
If ChatOpen() Then
Click(230, 20)
randomSleep(1500)
If IsClanChat() Then
Click(120, 60)
randomSleep(1500)
If IsClanOverview() Then
SetLog("Let's visit a random Player...", $COLOR_ACTION1)
Click(660, 400 + 52 * Random(0, 5, 1))
randomSleep(500)
VisitAPlayer()
Click(70, 680)
Else
SetLog("Error when trying to open Clan overview... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Clan Chat... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Chat... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func LookAtCurrentWar()
Click(40, 530)
randomSleep(5000)
If IsWarMenu() Then
If QuickMIS("BC1", @ScriptDir & "\images\Resources\Humanization Pics\CurrentWar") Then
SetLog("Let's examine the map...", $COLOR_ACTION1)
Scroll(Random(2, 5, 1))
randomSleep(3000)
$LookAtHome = Random(0, 1, 1)
If $LookAtHome = 1 Then
SetLog("Looking at home territory...", $COLOR_ACTION1)
Click(790, 370)
Scroll(Random(2, 5, 1))
randomSleep(3000)
EndIf
SetLog("Open War details menu...", $COLOR_ACTION1)
Click(800, 670)
randomSleep(1500)
If IsClanOverview() Then
$FirstMenu = Random(1, 2, 1)
Switch $FirstMenu
Case 1
SetLog("Looking at first tab...", $COLOR_ACTION1)
Click(180, 80)
Case 2
SetLog("Looking at second tab...", $COLOR_ACTION1)
Click(360, 80)
EndSwitch
randomSleep(1500)
Scroll(Random(1, 3, 1))
$SecondMenu = Random(1, 2, 1)
Switch $SecondMenu
Case 1
SetLog("Looking at third tab...", $COLOR_ACTION1)
Click(530, 80)
Case 2
SetLog("Looking at fourth tab...", $COLOR_ACTION1)
Click(700, 80)
EndSwitch
randomSleep(1500)
Scroll(Random(2, 4, 1))
Click(830, 80)
randomSleep(1500)
Click(70, 680)
Else
SetLog("Error when trying to open War Details window... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Your Clan is not in active war yet... skipping...", $COLOR_WARNING)
randomSleep(1500)
Click(70, 680)
EndIf
Else
SetLog("Error when trying to open War window... skipping...", $COLOR_WARNING)
EndIf
EndFunc
Func WatchWarReplays()
Click(40, 530)
randomSleep(5000)
If QuickMIS("BC1", @ScriptDir & "\images\Resources\Humanization Pics\WarDetails") And QuickMIS("BC1", @ScriptDir & "\images\Resources\Humanization Pics\CurrentWar") Then
SetLog("Open War details menu...", $COLOR_ACTION1)
Click(800, 670)
randomSleep(1500)
If IsClanOverview() Then
SetLog("Looking at second tab...", $COLOR_ACTION1)
Click(360, 80)
randomSleep(1500)
If IsBestClans() Then
Local $ReplayNumber = QuickMIS("Q1", @ScriptDir & "\images\Resources\Humanization Pics\Replay")
If $ReplayNumber > 0 Then
SetLog("There are " & $ReplayNumber & " replays to watch... We will choose one of them...", $COLOR_INFO)
$ReplayToLaunch = Random(1, $ReplayNumber, 1)
Click(810, 269 + 74 * ($ReplayToLaunch - 1))
WaitForReplayWindow()
If IsReplayWindow() Then
GetReplayDuration()
randomSleep(1000)
If IsReplayWindow() Then
AccelerateReplay(0)
EndIf
randomSleep($ReplayDuration[1] / 3)
If IsReplayWindow() Then
DoAPauseDuringReplay(0)
EndIf
randomSleep($ReplayDuration[1] / 3)
If IsReplayWindow() And $ReplayDuration[0] <> 0 Then
DoAPauseDuringReplay(0)
EndIf
Setlog("Waiting for replay end...", $COLOR_ACTION)
While IsReplayWindow()
Sleep(2000)
WEnd
randomSleep(1000)
Click(70, 680)
EndIf
Else
SetLog("No replay to watch yet... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open Replays menu... skipping...", $COLOR_WARNING)
EndIf
Else
SetLog("Error when trying to open War Details window... skipping...", $COLOR_WARNING)
EndIf
Click(830, 80)
randomSleep(2500)
Click(70, 680)
Else
SetLog("Your Clan is not in active war yet... skipping...", $COLOR_WARNING)
randomSleep(1500)
Click(70, 680)
EndIf
EndFunc
Func WaitForClouds()
If $debugSetlog = 1 Then Setlog("Begin WaitForClouds:", $COLOR_DEBUG1)
Local $iCount = 0
Local $bigCount = 0, $iLastTime = 0
Local $hMinuteTimer, $iSearchTime
Local $bEnabledGUI = False
Local $maxSearchCount = 720
Local $maxLongSearchCount = 7
Switch Int($iTrophyCurrent)
Case 3700 To 4099
$maxSearchCount = Random(480, 840, 1)
$maxLongSearchCount = Random(10, 12, 1)
Case 4100 To 4399
$maxSearchCount = Random(480, 840, 1)
$maxLongSearchCount = Random(15, 25, 1)
Case 4400 To 4699
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(24, 42, 1)
Case 4700 To 4999
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(36, 50, 1)
Case 5000 To 6500
$maxSearchCount = Random(600, 840, 1)
$maxLongSearchCount = Random(80, 85, 1)
EndSwitch
If $debugSetlog Then
SetLog("RANDOM: $maxSearchCount= " & $maxSearchCount & "= " & Round($maxSearchCount / $iDelayGetResources1, 2) & " min between cloud chk", $COLOR_DEBUG)
SetLog("RANDOM: $maxLongSearchCount= " & $maxLongSearchCount & "= " & Round(($maxSearchCount / $iDelayGetResources1) * $maxLongSearchCount, 2) & " min max search time", $COLOR_DEBUG)
EndIf
ForceCaptureRegion()
Local $hMinuteTimer = TimerInit()
While _CheckPixel2($aNoCloudsAttack2, $bCapturePixel) = False
If _Sleep($iDelayGetResources1) Then Return
$iCount += 1
If isProblemAffect(True) Then
resetAttackSearch()
Return
EndIf
If $iCount >= $maxSearchCount Then
If EnableLongSearch() = False Then
resetAttackSearch()
Return
Else
$bigCount += 1
If $bigCount > $maxLongSearchCount Then
$iSearchTime = TimerDiff($hMinuteTimer) / 60000
SetLog("Spent " & $iSearchTime & " minutes in Clouds searching, Restarting CoC and Bot...", $COLOR_ERROR)
$Is_ClientSyncError = False
$Restart = True
CloseCoC(True)
Return
EndIf
$iCount = 0
EndIf
EndIf
If $debugSetlog = 1 Then _GUICtrlStatusBar_SetText($statLog, " Status: Loop to clean screen without Clouds, # " & $iCount)
$iSearchTime = TimerDiff($hMinuteTimer) / 60000
If $iSearchTime >= $iLastTime + 1 Then
Setlog("Cloud wait time " & StringFormat("%.1f", $iSearchTime) & " minute(s)", $COLOR_INFO)
$iLastTime += 1
If chkAttackSearchFail() = 2 Or chkAttackSearchPersonalBreak() = True Then
resetAttackSearch()
Return
EndIf
If $iSearchTime > 2  And $bEnabledGUI = False Then
AndroidShieldForceDown(True)
EnableGuiControls()
SetLog("Enabled bot controls due to long wait time", $COLOR_SUCCESS)
$bEnabledGUI = True
EndIf
EndIf
ForceCaptureRegion()
WEnd
If $bEnabledGUI = True Then
SetLog("Disable bot controls after long wait time", $COLOR_SUCCESS)
AndroidShieldForceDown(False)
DisableGuiControls()
SaveConfig()
readConfig()
applyConfig()
EndIf
If _Sleep($iDelayGetResources2) Then Return
EndFunc
Func EnableLongSearch()
Local $result = ""
Local $iCount, $jCount, $kCount, $wCount
If $debugSetlog = 1 Then Setlog("Begin EnableLongSearch:", $COLOR_DEBUG1)
If Int($iTrophyCurrent) < 3700 Then
If $debugSetlog = 1 Then Setlog("Long cloud search not enabled due trophy count: " & $iTrophyCurrent, $COLOR_DEBUG)
Return False
EndIf
If chkSearchText() = True Then
$iCount = 0
While 1
If _CheckPixel2($aOpenChatTab, $bCapturePixel, Default, "OpenChatTab check", $COLOR_DEBUG) Then
ClickP($aOpenChatTab, 1, 0, "#0510")
If _Sleep($iDelayGetResources1) Then Return
$jCount = 0
While 1
If _CheckPixel2($aCloseChat, $bCapturePixel, Default, "CloseChatTab check", $COLOR_DEBUG) Then
ClickP($aCloseChat, 1, 0, "#0511")
$kCount = 0
While 1
If _Sleep($iDelaySleep) Then Return
$result = getCloudTextShort(260, 349 + $midOffsetY, "Cloud Search Text: sea=", $COLOR_DEBUG, Default)
If _CheckPixel2($aCloseChat, $bCapturePixel, Default, "CloseChatTab check", $COLOR_DEBUG) Then
$kCount += 1
ElseIf $result <> "" And StringInStr($result, "sea", $STR_NOCASESENSEBASIC) > 0 Then
Return True
Else
Return True
EndIf
$kCount += 1
If $kCount > 30 Then
If chkSurrenderBtn() = True Then Return True
SetLog("Warning - Found CloseChat Btn still open during search extension", $COLOR_WARNING)
Return False
EndIf
WEnd
EndIf
If _Sleep($iDelaySleep) Then Return
$jCount += 1
If $jCount > 50 Then
If chkSurrenderBtn() = True Then Return True
SetLog("Warning - Not find CloseChat tab during search extension", $COLOR_WARNING)
Return False
EndIf
WEnd
EndIf
$iCount += 1
If $iCount > 30 Then
If chkSurrenderBtn() = True Then Return True
SetLog("Cloud Search Text found, but chat button not found, restart search..", $COLOR_ERROR)
Return False
EndIf
WEnd
Else
If chkSurrenderBtn() = True Then Return True
If chkAttackSearchPersonalBreak() = True Then Return False
If chkAttackSearchFail() = 1 Then Return True
If $debugSetlog = 1 Then SetLog("Cloud Search Text not found...", $COLOR_DEBUG)
Return False
EndIf
EndFunc
Func chkSearchText()
Local $result
$result = getCloudTextShort(388, 348 + $midOffsetY, "Cloud Search Text: for=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "for", $STR_NOCASESENSEBASIC) <> 0 Then
Return True
EndIf
Return False
EndFunc
Func chkAttackSearchFail()
Local $result
$result = getCloudFailShort(271, 351 + $midOffsetY, "Cloud Search Fail Text: unable=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "unable", $STR_NOCASESENSEBASIC) > 0 Then
If btnSearchFailRetry() = True Then
Setlog("Search Fail? Retry search button pushed, continue...", $COLOR_SUCCESS)
Return 1
Else
SetLog("Warning, failed to find/press retry search button", $COLOR_WARNING)
Return 2
EndIf
EndIf
EndFunc
Func chkAttackSearchPersonalBreak()
Local $result
$result = getCloudFailShort(499, 350 + $midOffsetY, "Cloud Search PB Text: Break=", $COLOR_DEBUG, Default)
If $result <> "" And StringInStr($result, "break", $STR_NOCASESENSEBASIC) > 0 Then
Setlog("Prepare base before Personal Break in clouds..", $COLOR_INFO)
CheckBaseQuick2(True, "cloud")
Return True
EndIf
If $ichkSinglePBTForced And _DateIsValid($sPBStartTime) Then
Local $iTimeTillPBTstartSec = Int(_DateDiff('s', $sPBStartTime, _NowCalc()))
If $debugSetlog = 1 Then Setlog("PB starts in: " & $iTimeTillPBTstartSec & " Seconds", $COLOR_DEBUG)
If $iTimeTillPBTstartSec >= 0 Then
Setlog("Prepare base before user forced Break..", $COLOR_INFO)
CheckBaseQuick2(True, "cloud")
Return True
EndIf
EndIf
Return False
EndFunc
Func btnSearchFailRetry()
Local $offColors[3][3] = [[0x000000, 50, 8], [0x60B014, 55, 21], [0x020201, 90, 7]]
Global $ButtonPixel = _MultiPixelSearch(364, 405 + $midOffsetY, 466, 430 + $midOffsetY, 1, 1, Hex(0x000000, 6), $offColors, 20)
If $debugSetlog = 1 Then Setlog("Retry btn clr chk-#1: " & _GetPixelColor2(368, 347 + $midOffsetY, True) & ", #2: " & _GetPixelColor2(368 + 50, 347 + 8 + $midOffsetY, True) & ", #3: " & _GetPixelColor2(368 + 55, 347 + 21 + $midOffsetY, True) & ", #4: " & _GetPixelColor2(368 + 90, 347 + 7 + $midOffsetY, True), $COLOR_DEBUG)
If IsArray($ButtonPixel) Then
If $debugSetlog = 1 Then
Setlog("ButtonPixel = " & $ButtonPixel[0] & ", " & $ButtonPixel[1], $COLOR_DEBUG)
Setlog("Retry Btn Pixel color found #1: " & _GetPixelColor2($ButtonPixel[0], $ButtonPixel[1], True) & ", #2: " & _GetPixelColor2($ButtonPixel[0] + 144, $ButtonPixel[1], True) & ", #3: " & _GetPixelColor2($ButtonPixel[0] + 54, $ButtonPixel[1] + 17, True) & ", #4: " & _GetPixelColor2($ButtonPixel[0] + 54, $ButtonPixel[1] + 27, True), $COLOR_DEBUG)
EndIf
Click($ButtonPixel[0] + 75, $ButtonPixel[1] + 25, 1, 0, "#0512")
Return True
EndIf
Return False
EndFunc
Func chkSurrenderBtn()
Local $wCount = 0
While 1
If _CheckPixel2($aSurrenderButton, $bCapturePixel, Default, "Surrender btn wait #" & $wCount, $COLOR_DEBUG) = True Then
If $debugSetlog = 1 Then Setlog("Surrender button found, clouds gone, continue...", $COLOR_DEBUG)
Return True
EndIf
If _Sleep($iDelaySleep) Then Return
$wCount += 1
If $wCount >= 30 Or isProblemAffect(True) Then
Return False
EndIf
WEnd
EndFunc
CreateDonatedVars()
Func CreateDonatedVars($ForcedVal = 0, $showLog = 0)
For $i = 0 To UBound($TroopName) - 1
Assign("Donated" & Eval("e" & $TroopName[$i]) & "ViPER", $ForcedVal, $ASSIGN_FORCEGLOBAL)
If $showLog = 1 Then SetLog("Donated" & Eval("e" & $TroopName[$i]) & "ViPER" & ", Troop Name: " & NameOfTroop(Eval("e" & $TroopName[$i])), $COLOR_BLUE)
Next
For $i = 0 To UBound($TroopDarkName) - 1
Assign("Donated" & Eval("e" & $TroopDarkName[$i]) & "ViPER", $ForcedVal, $ASSIGN_FORCEGLOBAL)
If $showLog = 1 Then SetLog("Donated" & Eval("e" & $TroopDarkName[$i]) & "ViPER" & ", DARK Troop Name: " & NameOfTroop(Eval("e" & $TroopDarkName[$i])), $COLOR_GREEN)
Next
Assign("Donated" & $ePSpell & "ViPER", $ForcedVal, $ASSIGN_FORCEGLOBAL)
Assign("Donated" & $eESpell & "ViPER", $ForcedVal, $ASSIGN_FORCEGLOBAL)
Assign("Donated" & $eHaSpell & "ViPER", $ForcedVal, $ASSIGN_FORCEGLOBAL)
Assign("Donated" & $eSkSpell & "ViPER", $ForcedVal, $ASSIGN_FORCEGLOBAL)
EndFunc
Func DonatedTroop($type, $quant , $showLog = 0)
$newVal = Number(Eval("Donated" & $type & "ViPER")) + $quant
Assign("Donated" & $type & "ViPER", $newVal, 4)
UpdateDonateStatsGUI($type, $newVal)
If $showLog = 1 Then SetLog("Donated" & $type & "ViPER = " & Eval("Donated" & $type & "ViPER"), $COLOR_BLUE)
If $showLog = 0 Then SetLog("Total " & NameOfTroop($type) & " Donated: " & Eval("Donated" & $type & "ViPER"), $COLOR_BLUE)
EndFunc
Func DonatedSpell($type,$quant , $showLog = 0)
$newVal = Number(Eval("Donated" & $type & "ViPER")) + $quant
Assign("Donated" & $type & "ViPER", $newVal, 4)
UpdateDonateStatsGUI($type, $newVal)
If $showLog = 1 Then SetLog("Donated" & $type & "ViPER = " & Eval("Donated" & $type & "ViPER"), $COLOR_BLUE)
If $showLog = 0 Then SetLog("Total " & NameOfTroop($type) & " Donated: " & Eval("Donated" & $type & "ViPER"), $COLOR_BLUE)
EndFunc
Func UpdateDonateStatsGUI($type, $value)
GUICtrlSetData(Eval("lblDonated" & $type), $value)
$totalETroops = 0
$totalDTroops = 0
$totalSpells = 0
For $i = 0 To UBound($TroopName) - 1
$totalETroops += Eval("Donated" & Eval("e" & $TroopName[$i]) & "ViPER")
Next
For $i = 0 To UBound($TroopDarkName) - 1
$totalDTroops += Eval("Donated" & Eval("e" & $TroopDarkName[$i]) & "ViPER")
Next
$totalSpells = Number(Eval("Donated" & $ePSpell & "ViPER")) + Number(Eval("Donated" & $eESpell & "ViPER")) + Number(Eval("Donated" & $eHaSpell & "ViPER")) + Number(Eval("Donated" & $eSkSpell & "ViPER"))
GUICtrlSetData($lblTotalDonated,"Total Donated: " & $totalETroops)
GUICtrlSetData($lblTotalDonatedDark,"Total Donated: " & $totalDTroops)
GUICtrlSetData($lblTotalDonatedSpell,"Total Donated: " & $totalSpells)
EndFunc
Global $DebugSX = 0
Global $DpGoblinPicnic[3][4] = [[300, 205, 5, 5], [340, 140, 5, 5], [290, 220, 5, 5]]
Global $BdGoblinPicnic[3] = [0, "5000-7000", "6000-8000"]
Global $ActivatedHeroes[3] = [False, False, False]
Global Const $minStarsToEnd = 1
Global $canGainXP = False
Func MainSuperXPHandler()
If $ichkEnableSuperXP = 0 Then Return
If $irbSXTraining = 1 And $IsFullArmywithHeroesAndSpells = True Then Return
If WaitForMain() = False Then
SetLog("Cannot get in Main Screen!! Exiting SuperXP", $COLOR_RED)
Return False
EndIf
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If $DebugSetlog = 1 Then SetLog("Current Trophy Count: " & $iTrophyCurrent, $COLOR_DEBUG)
If Number($iTrophyCurrent) > Number($iTxtMaxTrophy) Then Return
getArmyHeroCount(True, True)
If WaitForMain() = False Then
SetLog("Cannot get in Main Screen!! Exiting SuperXP", $COLOR_RED)
Return False
EndIf
$canGainXP = ((IIf($ichkSXBK = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXBK) Or IIf($ichkSXAQ = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXAQ) Or IIf($ichkSXGW = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXGW)) And $iHeroAvailable <> $HERO_NOHERO And IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True))
If $DebugSX = 1 Then SetLog("$iHeroAvailable = " & $iHeroAvailable)
If $DebugSX = 1 Then SetLog("BK: " & $ichkSXBK & ", AQ: " & $ichkSXAQ & ", GW: " & $ichkSXGW)
If $DebugSX = 1 Then SetLog("$canGainXP = " & $canGainXP & @CRLF & "1: " & String(IIf($ichkSXBK = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXBK)) & ", 2: " &  String(IIf($ichkSXAQ = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXAQ)) & ", 3: " &  String(IIf($ichkSXGW = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXGW)) & ", 4: " & ($iHeroAvailable <> $HERO_NOHERO) &  ", 5: " & String(IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True)))
If $canGainXP = False Then Return
If $iStartXP = 0 Then
$iStartXP = GetCurXP()
SXSetXP("S")
EndIf
While $canGainXP = True
If WaitForMain() = False Then
SetLog("Cannot get in Main Screen!! Exiting SuperXP", $COLOR_RED)
Return False
EndIf
SetLog("Attacking to Goblin Picnic - GoblinXP", $COLOR_BLUE)
If $RunState = False Then Return
If OpenGoblinPicnic() = False Then
SafeReturnSX()
Return False
EndIf
If $RunState = False Then Return
$rAttackSuperXP = AttackSuperXP()
If $rAttackSuperXP = True Then
If $RunState = False Then Return
WaitToFinishSuperXP()
EndIf
If $RunState = False Then Return
SetLog("Attacking Finished - GoblinXP", $COLOR_GREEN)
If $rAttackSuperXP = True Then AttackFinishedSX()
If $canGainXP = False Then ExitLoop
DonateCC(True)
If $irbSXTraining = 1 Then CheckForFullArmy()
$canGainXP = ((IIf($ichkSXBK = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXBK) Or IIf($ichkSXAQ = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXAQ) Or IIf($ichkSXGW = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXGW)) And $iHeroAvailable <> $HERO_NOHERO And IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True) And $ichkEnableSuperXP = 1)
If $DebugSX = 1 Then SetLog("$iHeroAvailable = " & $iHeroAvailable)
If $DebugSX = 1 Then SetLog("BK: " & $ichkSXBK & ", AQ: " & $ichkSXAQ & ", GW: " & $ichkSXGW)
If $DebugSX = 1 Then SetLog("While|$canGainXP = " & $canGainXP & @CRLF & "1: " & String(IIf($ichkSXBK = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXBK)) & ", 2: " &  String(IIf($ichkSXAQ = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXAQ)) & ", 3: " &  String(IIf($ichkSXGW = $HERO_NOHERO, False, $iHeroAvailable >= $ichkSXGW)) & ", 4: " & ($iHeroAvailable <> $HERO_NOHERO) &  ", 5: " & String(IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True)) & ", 6: " & String($ichkEnableSuperXP = 1))
WEnd
EndFunc
Func CheckForFullArmy()
If $DebugSX = 1 Then SetLog("SX|CheckForFullArmy", $COLOR_PURPLE)
If WaitForMain() = False Then
SetLog("Cannot get in Main Screen!! Exiting CheckForFullArmy", $COLOR_RED)
Return False
EndIf
OpenArmyWindow()
$fullarmy = False
$bFullArmySpells = False
$canRequestCC = _ColorCheck(_GetPixelColor($aRequestTroopsAO[0], $aRequestTroopsAO[1], True), Hex($aRequestTroopsAO[2], 6), $aRequestTroopsAO[5])
IsFullArmy(True)
If $RunState = False Then Return
IsFullSpells(True)
Local $fullcastlespells = IsFullCastleSpells()
If $RunState = False Then Return
Local $fullcastletroops = IsFullCastleTroops()
Local $checkSpells = checkspells()
If ($CommandStop = 3 Or $CommandStop = 0) And $fullarmy Then
SetLog("You are in halt attack mode and your Army is prepared!", $COLOR_DEBUG)
If $FirstStart Then $FirstStart = False
Return
EndIf
If IsWaitforHeroesActive() Or $iChkTrophyRange = 1 Or $ichkEnableSuperXP = 1 Then
getArmyHeroCount()
Else
$bFullArmyHero = True
EndIf
If $RunState = False Then Return
If $fullarmy And $checkSpells And $bFullArmyHero And $fullcastlespells And $fullcastletroops Then
$IsFullArmywithHeroesAndSpells = True
$FirstStart = False
Else
$IsFullArmywithHeroesAndSpells = False
EndIf
If $IsFullArmywithHeroesAndSpells = False And (_ColorCheck(_GetPixelColor(391, 126, True), Hex(0x605C4C, 6), 15) = True And _ColorCheck(_GetPixelColor(587, 126, True), Hex(0x605C4D, 6), 15) = True) Then
If $DebugSX = 1 Then SetLog("SX|CFFA TrainRevamp Condi. #1")
TestTrainRevamp()
ElseIf $IsFullArmywithHeroesAndSpells = True And $ichkEnableSuperXP = 1 And $irbSXTraining = 1 Then
If $DebugSX = 1 Then SetLog("SX|CFFA TrainRevamp Condi. #2")
TestTrainRevamp()
EndIf
ClickP($aAway, 2, 0, "#0346")
If $DebugSX = 1 Then SetLog("SX|CheckForFullArmy Finished", $COLOR_PURPLE)
EndFunc
Func SafeReturnSX()
If $DebugSX = 1 Then SetLog("SX|SafeReturn", $COLOR_PURPLE)
If IsMainPage() Then Return True
Local $rExit = False
If IsInAttackSuperXP() Then
$rExit = ReturnHomeSuperXP()
ElseIf IsInSPPage() Then
$rExit = ExitSPPage()
EndIf
If $DebugSX = 1 Then SetLog("SX|SafeReturn=" & $rExit)
Return $rExit
EndFunc
Func ExitSPPage()
If $DebugSX = 1 Then SetLog("SX|ExitSPPage", $COLOR_PURPLE)
Click(822, 32, 1, 0, "#0152")
Local $Counter = 0
While Not (IsMainPage())
If _Sleep(50) Then Return False
$Counter += 1
If $Counter >= 200 Then ExitLoop
WEnd
If $Counter >= 200 Then
SetLog("Cannot Exit Single Player Page", $COLOR_RED)
Return False
EndIf
If $DebugSX = 1 Then SetLog("SX|ExitSPPage Finished", $COLOR_PURPLE)
Return True
EndFunc
Func AttackFinishedSX()
If $DebugSX = 1 Then SetLog("SX|AttackFinished", $COLOR_PURPLE)
$iCurrentXP = GetCurXP()
$iGainedXP += 5
SXSetXP()
$ActivatedHeroes[0] = False
$ActivatedHeroes[1] = False
$ActivatedHeroes[2] = False
If $DebugSX = 1 Then SetLog("SX|AttackFinished Finished", $COLOR_PURPLE)
EndFunc
Func GetCurXP()
Return getVillageExp(55, 20)
EndFunc
Func TestSuperXP()
Local $oRunState = $RunState
$RunState = True
OpenGoblinPicnic()
$RunState = $oRunState
EndFunc
Func WaitToFinishSuperXP()
If $DebugSX = 1 Then SetLog("SX|WaitToFinishSuperXP", $COLOR_PURPLE)
Local $BdTimer = TimerInit()
While 1
If CheckEarnedStars($minStarsToEnd) = True Then ExitLoop
If _Sleep(70) Then ExitLoop
If $RunState = False Then ExitLoop
If IsInAttackSuperXP() = False Then ExitLoop
ActivateHeroesByDelay($BdTimer)
If TimerDiff($BdTimer) >= 120000 Then
If $DebugSX = 1 Then SetLog("SX|WaitToFinishSuperXP TimeOut", $COLOR_RED)
SafeReturnSX()
ExitLoop
EndIf
WEnd
If $DebugSX = 1 Then SetLog("SX|WaitToFinishSuperXP Finished", $COLOR_PURPLE)
Return True
EndFunc
Func ActivateHeroesByDelay($hBdTimer)
$QueenDelay = $BdGoblinPicnic[0]
If StringInStr($QueenDelay, "-") > 0 Then $QueenDelay = Random(Number(StringSplit($QueenDelay, "-", 2)[0]), Number(StringSplit($QueenDelay, "-", 2)[1]), 1)
$WardenDelay = $BdGoblinPicnic[1]
If StringInStr($WardenDelay, "-") > 0 Then $WardenDelay = Random(Number(StringSplit($WardenDelay, "-", 2)[0]), Number(StringSplit($WardenDelay, "-", 2)[1]), 1)
$KingDelay = $BdGoblinPicnic[2]
If StringInStr($KingDelay, "-") > 0 Then $KingDelay = Random(Number(StringSplit($KingDelay, "-", 2)[0]), Number(StringSplit($KingDelay, "-", 2)[1]), 1)
Local $tDiff = TimerDiff($hBdTimer)
If $tDiff >= $QueenDelay And $QueenDelay <> 0 And $ActivatedHeroes[0] = False And $Queen <> -1 And $ichkSXAQ <> $HERO_NOHERO Then
If $DebugSX = 1 Then SetLog("SX|Activating Queen Ability After " & Round($tDiff, 3) & "/" & $QueenDelay & " ms(s)")
SelectDropTroop($Queen)
$ActivatedHeroes[0] = True
EndIf
If $tDiff >= $WardenDelay And $WardenDelay <> 0 And $ActivatedHeroes[1] = False And $Warden <> -1 And $ichkSXGW <> $HERO_NOHERO Then
If $DebugSX = 1 Then SetLog("SX|Activating Warden Ability After " & Round($tDiff, 3) & "/" & $WardenDelay & " ms(s)")
SelectDropTroop($Warden)
$ActivatedHeroes[1] = True
EndIf
If $tDiff >= $KingDelay And $KingDelay <> 0 And $ActivatedHeroes[2] = False And $King <> -1 And $ichkSXBK <> $HERO_NOHERO Then
If $DebugSX = 1 Then SetLog("SX|Activating King Ability After " & Round($tDiff, 3) & "/" & $KingDelay & " ms(s)")
SelectDropTroop($King)
$ActivatedHeroes[2] = True
EndIf
EndFunc
Func IsInAttackSuperXP()
If $DebugSX = 1 Then SetLog("SX|IsInAttackSuperXP", $COLOR_PURPLE)
If _ColorCheck(_GetPixelColor(60, 576, True), Hex(0x000000, 6), 20) Then Return True
If $DebugSX = 1 Then SetLog("SX|IsInAttackSuperXP=FALSE")
Return False
EndFunc
Func IsInSPPage()
If $DebugSX = 1 Then SetLog("SX|IsInSPPage", $COLOR_PURPLE)
Local $rColCheck = _ColorCheck(_GetPixelColor(316, 34, True), Hex(0xFFFFFF, 6), 20)
If $DebugSX = 1 Then SetLog("SX|IsInSPPage=" & $rColCheck)
Return $rColCheck
EndFunc
Func AttackSuperXP()
If $DebugSX = 1 Then SetLog("SX|AttackSuperXP", $COLOR_PURPLE)
If WaitForNoClouds() = False Then
If $DebugSX = 1 Then SetLog("SX|ASX|Wait For Clouds = False")
$Is_ClientSyncError = False
Return False
EndIf
PrepareSuperXPAttack()
If CheckAvailableHeroes() = False Then
SetLog("No heroes available to attack with", $COLOR_ORANGE)
ReturnHomeSuperXP()
Return False
EndIf
DropAQSuperXP($BdGoblinPicnic[0] = 0)
If CheckEarnedStars($minStarsToEnd) = True Then Return True
DropGWSuperXP($BdGoblinPicnic[1] = 0)
If CheckEarnedStars($minStarsToEnd) = True Then Return True
DropBKSuperXP($BdGoblinPicnic[2] = 0)
If $DebugSX = 1 Then SetLog("SX|AttackSuperXP Finished", $COLOR_PURPLE)
Return True
EndFunc
Func CheckAvailableHeroes()
$canGainXP = ((IIf($ichkSXBK = $HERO_NOHERO, False, $King <> -1) Or IIf($ichkSXAQ = $HERO_NOHERO, False, $Queen <> -1) Or IIf($ichkSXGW = $HERO_NOHERO, False, $Warden <> -1)) And IIf($irbSXTraining = 1, $IsFullArmywithHeroesAndSpells = False, True))
If $DebugSX = 1 Then SetLog("SX|CheckAvailableHeroes=" & $canGainXP)
Return $canGainXP
EndFunc
Func DropAQSuperXP($bActivateASAP = True)
If $Queen <> -1 And $ichkSXAQ <> $HERO_NOHERO Then
SetLog("Deploying Queen", $COLOR_BLUE)
Click(GetXPosOfArmySlot($Queen, 68), 595 + $bottomOffsetY, 1, 0, "#0000")
If _Sleep($iDelayDropSuperXP1) Then Return False
If CheckEarnedStars($minStarsToEnd) = True Then Return True
ClickP(GetDropPointSuperXP(1), 1, 0, "#0000")
If _Sleep($iDelayDropSuperXP3) Then Return False
If $bActivateASAP = True Then
If IsAttackPage() Then
SelectDropTroop($Queen)
$ActivatedHeroes[0] = True
EndIf
EndIf
If _Sleep($iDelayDropSuperXP3) Then Return False
EndIf
EndFunc
Func DropGWSuperXP($bActivateASAP = True)
If $Warden <> -1 And $ichkSXGW <> $HERO_NOHERO Then
SetLog("Deploying Warden", $COLOR_BLUE)
Click(GetXPosOfArmySlot($Warden, 68), 595 + $bottomOffsetY, 1, 0, "#0179")
If _Sleep($iDelayDropSuperXP1) Then Return False
If CheckEarnedStars($minStarsToEnd) = True Then Return True
ClickP(GetDropPointSuperXP(2), 1, 0, "#0180")
If _Sleep($iDelayDropSuperXP3) Then Return False
If $bActivateASAP = True Then
If IsAttackPage() Then
SelectDropTroop($Warden)
$ActivatedHeroes[1] = True
EndIf
EndIf
If _Sleep($iDelayDropSuperXP3) Then Return False
EndIf
EndFunc
Func DropBKSuperXP($bActivateASAP = True)
If $King <> -1 And $ichkSXBK <> $HERO_NOHERO Then
SetLog("Deploying King", $COLOR_BLUE)
Click(GetXPosOfArmySlot($King, 68), 595 + $bottomOffsetY, 1, 0, "#0177")
If _Sleep($iDelayDropSuperXP1) Then Return False
If CheckEarnedStars($minStarsToEnd) = True Then Return True
ClickP(GetDropPointSuperXP(3), 1, 0, "#0178")
If _Sleep($iDelayDropSuperXP3) Then Return False
If $bActivateASAP = True Then
If IsAttackPage() Then
SelectDropTroop($King)
$ActivatedHeroes[2] = True
EndIf
EndIf
If _Sleep($iDelayDropSuperXP3) Then Return False
EndIf
EndFunc
Func GetDropPointSuperXP($iHero)
Local $ToReturn[2] = [-1, -1]
Local $rDpGoblinPicnic[4] = [$DpGoblinPicnic[$iHero - 1][0], $DpGoblinPicnic[$iHero - 1][1], $DpGoblinPicnic[$iHero - 1][2], $DpGoblinPicnic[$iHero - 1][3]]
$ToReturn[0] = Random($rDpGoblinPicnic[0] - $rDpGoblinPicnic[2], $rDpGoblinPicnic[0] + $rDpGoblinPicnic[2], 1)
$ToReturn[1] = Random($rDpGoblinPicnic[1] - $rDpGoblinPicnic[3], $rDpGoblinPicnic[1] + $rDpGoblinPicnic[3], 1)
Return $ToReturn
EndFunc
Func PrepareSuperXPAttack()
If $DebugSX = 1 Then SetLog("SX|PrepareSuperXPAttack", $COLOR_PURPLE)
Local $troopsnumber = 0
If _Sleep($iDelayPrepareAttack1) Then Return
_CaptureRegion2(0, 571 + $bottomOffsetY, 859, 671 + $bottomOffsetY)
Local $Plural = 0
Local $result = AttackBarCheck()
If $debugSetlog = 1 Then Setlog("DLL Troopsbar list: " & $result, $COLOR_DEBUG)
Local $aTroopDataList = StringSplit($result, "|")
Local $aTemp[12][3]
If $result <> "" Then
For $i = 1 To $aTroopDataList[0]
Local $troopData = StringSplit($aTroopDataList[$i], "#", $STR_NOCOUNT)
$aTemp[Number($troopData[1])][0] = $troopData[0]
$aTemp[Number($troopData[1])][1] = Number($troopData[2])
$aTemp[Number($troopData[1])][2] = Number($troopData[1])
Next
EndIf
For $i = 0 To UBound($aTemp) - 1
If $aTemp[$i][0] = "" And $aTemp[$i][1] = "" Then
$atkTroops[$i][0] = -1
$atkTroops[$i][1] = 0
Else
$troopKind = $aTemp[$i][0]
If $troopKind < $eKing Then
$atkTroops[$i][0] = $aTemp[$i][0]
$atkTroops[$i][1] = $aTemp[$i][1]
$troopKind = $aTemp[$i][1]
$troopsnumber += $aTemp[$i][1]
Else
$atkTroops[$i][0] = $troopKind
$troopsnumber += 1
$atkTroops[$i][0] = $aTemp[$i][0]
$troopKind = $aTemp[$i][1]
$troopsnumber += 1
EndIf
$Plural = 0
If $aTemp[$i][1] > 1 Then $Plural = 1
If $troopKind <> -1 Then SetLog($aTemp[$i][2] & " Â» " & $aTemp[$i][1] & " " & NameOfTroop($atkTroops[$i][0], $Plural), $COLOR_GREEN)
EndIf
Next
If $debugSetlog = 1 Then Setlog("troopsnumber  = " & $troopsnumber)
$King = -1
$Queen = -1
$Warden = -1
For $i = 0 To UBound($atkTroops) - 1
If $atkTroops[$i][0] = $eKing Then
$King = $i
ElseIf $atkTroops[$i][0] = $eQueen Then
$Queen = $i
ElseIf $atkTroops[$i][0] = $eWarden Then
$Warden = $i
EndIf
Next
If $DebugSX = 1 Then SetLog("SX|PrepareSuperXPAttack Finished", $COLOR_PURPLE)
Return $troopsnumber
EndFunc
Func CheckEarnedStars($ExitWhileHave = 0)
If $DebugSX = 1 Then SetLog("SX|CheckEarnedStars", $COLOR_PURPLE)
Local $starsearned = 0
If $ExitWhileHave = 1 Then
If _ColorCheck(_GetPixelColor(455, 405, True), Hex(0xD0D8D0, 6), 20) Then
SetLog("1 Star earned", $COLOR_GREEN)
If ReturnHomeSuperXP() = False Then CloseCoC(True)
Return True
EndIf
EndIf
If _ColorCheck(_GetPixelColor(714, 594, True), Hex(0xCCCFC8, 6), 20) Then $starsearned += 1
If $ExitWhileHave <> 0 And $starsearned >= $ExitWhileHave Then
SetLog($starsearned & " Star earned", $COLOR_GREEN)
If ReturnHomeSuperXP() = False Then CloseCoC(True)
Return True
EndIf
If $ExitWhileHave >= 2 Then
If _ColorCheck(_GetPixelColor(740, 583, True), Hex(0xC6CBC5, 6), 20) Then $starsearned += 1
If $ExitWhileHave <> 0 And $starsearned >= $ExitWhileHave Then
SetLog($starsearned & " Stars earned", $COLOR_GREEN)
If ReturnHomeSuperXP() = False Then CloseCoC(True)
Return True
EndIf
If $ExitWhileHave >= 3 Then
If _ColorCheck(_GetPixelColor(764, 583, True), Hex(0xBEC5BE, 6), 20) Then $starsearned += 1
If $ExitWhileHave <> 0 And $starsearned >= $ExitWhileHave Then
SetLog($starsearned & " Stars earned", $COLOR_GREEN)
If ReturnHomeSuperXP() = False Then CloseCoC(True)
Return True
EndIf
EndIf
EndIf
Return False
EndFunc
Func ReturnHomeSuperXP()
Local Const $EndBattleText[4] = [29, 595, 0xFFFFFF, 10], $EndBattle2Text[4] = [491, 424, 0xFFFFFF, 10], $ReturnHomeText[4] = [445, 575, 0xFFFFFF, 10]
Local Const $iDelayEachCheck = 70, $iRetryLimits = 429
Local $Counter = 0
$King = -1
$Queen = -1
$Warden = -1
SetLog("Returning Home - SuperXP", $COLOR_BLUE)
While _ColorCheck(_GetPixelColor($EndBattleText[0], $EndBattleText[1], True), Hex($EndBattleText[2], 6), $EndBattleText[3]) = False
If _Sleep($iDelayEachCheck) Then Return False
$Counter += 1
If $Counter >= $iRetryLimits Then
If $DebugSX = 1 Then SetLog("SX|RHSX|First EndBattle Button not found")
Return False
EndIf
WEnd
Click(Random($EndBattleText[0] - 5, $EndBattleText[0] + 5, 1), Random($EndBattleText[1] - 5, $EndBattleText[1] + 5, 1))
If _Sleep($iDelayEachCheck) Then Return False
$Counter = 0
While _ColorCheck(_GetPixelColor($EndBattle2Text[0], $EndBattle2Text[1], True), Hex($EndBattle2Text[2], 6), $EndBattle2Text[3]) = False
If _Sleep($iDelayEachCheck) Then Return False
If IsMainPage() Then
_GUICtrlEdit_SetText($txtLog, _PadStringCenter(" BOT LOG ", 71, "="))
_GUICtrlRichEdit_SetFont($txtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($txtLog, "" & @CRLF, _ColorConvert($Color_Black))
Return True
EndIf
$Counter += 1
If $Counter >= $iRetryLimits Then
If $DebugSX = 1 Then SetLog("SX|RHSX|Second EndBattle Button not found")
Return False
EndIf
WEnd
Click(Random($EndBattle2Text[0] - 5, $EndBattle2Text[0] + 5, 1), Random($EndBattle2Text[1] - 5, $EndBattle2Text[1] + 5, 1))
If _Sleep($iDelayEachCheck) Then Return False
$Counter = 0
While _ColorCheck(_GetPixelColor($ReturnHomeText[0], $ReturnHomeText[1], True), Hex($ReturnHomeText[2], 6), $ReturnHomeText[3]) = False
If _Sleep($iDelayEachCheck) Then Return False
If IsMainPage() Then
_GUICtrlEdit_SetText($txtLog, _PadStringCenter(" BOT LOG ", 71, "="))
_GUICtrlRichEdit_SetFont($txtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($txtLog, "" & @CRLF, _ColorConvert($Color_Black))
Return True
EndIf
$Counter += 1
If $Counter >= $iRetryLimits Then
If $DebugSX = 1 Then SetLog("SX|RHSX|Last Return Home Button not found")
Return False
EndIf
WEnd
Click(Random($ReturnHomeText[0] - 5, $ReturnHomeText[0] + 5, 1), Random($ReturnHomeText[1] - 5, $ReturnHomeText[1] + 5, 1))
If _Sleep($iDelayReturnHome2) Then Return
$Counter = 0
While 1
If _Sleep($iDelayReturnHome4) Then Return
If IsMainPage() Then
_GUICtrlEdit_SetText($txtLog, _PadStringCenter(" BOT LOG ", 71, "="))
_GUICtrlRichEdit_SetFont($txtLog, 6, "Lucida Console")
_GUICtrlRichEdit_AppendTextColor($txtLog, "" & @CRLF, _ColorConvert($Color_Black))
Return True
EndIf
$Counter += 1
If $Counter >= 50 Or isProblemAffect(True) Then
SetLog("Cannot return home.", $COLOR_RED)
checkMainScreen(False, True)
Return True
EndIf
WEnd
EndFunc
Func WaitForNoClouds()
If $DebugSX = 1 Then SetLog("SX|WaitForNoClouds", $COLOR_PURPLE)
Local $i = 0
ForceCaptureRegion()
While _ColorCheck(_GetPixelColor(60, 576, True), Hex(0x000000, 6), 20) = False
If _Sleep($iDelayGetResources1) Then Return False
$i += 1
If $i >= 120 Or isProblemAffect(True) Then
$Is_ClientSyncError = True
checkMainScreen()
If $Restart Then
$iNbrOfOoS += 1
UpdateStats()
SetLog("Disconnected At Search Clouds - SuperXP", $COLOR_RED)
PushMsg("OoSResources")
Else
SetLog("Stuck At Search Clouds, Restarting CoC and Bot... - SuperXP", $COLOR_RED)
$Is_ClientSyncError = False
CloseCoC(True)
EndIf
Return False
EndIf
If $DebugSX = 1 Then SetLog("SX|WFNC|Loop #" & $i)
ForceCaptureRegion()
WEnd
If $DebugSX = 1 Then SetLog("SX|WaitFornoClouds Finished", $COLOR_PURPLE)
Return True
EndFunc
Func OpenGoblinPicnic()
If $DebugSX = 1 Then SetLog("SX|OpenGoblinPicnic", $COLOR_PURPLE)
Local $rOpenSinglePlayerPage = OpenSinglePlayerPage()
If $rOpenSinglePlayerPage = False Then
SetLog("Failed to open Attack page, Single Player", $COLOR_RED)
SafeReturnSX()
Return False
EndIf
Local $rDragToGoblinPicnic = DragToGoblinPicnic()
If $rDragToGoblinPicnic = False Then
SetLog("Failed to find Goblin Picnic", $COLOR_RED)
SafeReturnSX()
Return False
EndIf
If $DebugSX = 1 Then SetLog("SX|OGP|Clicking On GP Text: " & $rDragToGoblinPicnic[0] & ", " & $rDragToGoblinPicnic[1])
Click($rDragToGoblinPicnic[0], $rDragToGoblinPicnic[1])
Local $Counter = 0
While _ColorCheck(_GetPixelColor(621, 665, True), Hex(0xFFFFFF, 6), 10) = False Or _ColorCheck(_GetPixelColor(663, 662, True), Hex(0xFFFFFF, 6), 10) = False
If _Sleep(50) Then ExitLoop
$Counter += 1
If $Counter > 200 Then ExitLoop
WEnd
If $Counter > 200 Then
SetLog("Available loot info didn't Displayed!", $COLOR_RED)
SafeReturnSX()
Return False
EndIf
$Counter = 0
While _ColorCheck(_GetPixelColor($rDragToGoblinPicnic[0], $rDragToGoblinPicnic[1] + 78, True), Hex(0xE04A00, 6), 30) = False
If _Sleep(50) Then ExitLoop
Click($rDragToGoblinPicnic[0], $rDragToGoblinPicnic[1])
$Counter += 1
If $Counter > 200 Then ExitLoop
WEnd
If $Counter > 200 Then
If IsGoblinPicnicLocked($rDragToGoblinPicnic) = True Then
SetLog("Are you kidding me? Goblin Picnic is Locked", $COLOR_RED)
DisableSX()
SafeReturnSX()
Return False
EndIf
SetLog("Attack Button Cannot be Verified", $COLOR_RED)
DebugImageSave("SuperXP_", True, "png", True, String(Number($rDragToGoblinPicnic[0], 2) & ", " & Number($rDragToGoblinPicnic[1], 2) & @CRLF & Number($rDragToGoblinPicnic[0], 2) & ", " & Number($rDragToGoblinPicnic[1] + 78, 2)), 80, 145, 35, $rDragToGoblinPicnic[0] - 5, $rDragToGoblinPicnic[1] - 5 + 78, 10, 10)
SafeReturnSX()
Return False
EndIf
If $DebugSX = 1 Then
SetLog("SX|OGP|Clicking On Attack Btn: " & $rDragToGoblinPicnic[0] & ", " & $rDragToGoblinPicnic[1] + 78)
EndIf
Click($rDragToGoblinPicnic[0], $rDragToGoblinPicnic[1] + 78)
$Counter = 0
While IsInSPPage()
If _Sleep(50) Then ExitLoop
$Counter += 1
If $Counter > 300 Then ExitLoop
WEnd
If $Counter > 300 Then
SetLog("Still in SinglePlayer Page!! Something Strange Happened", $COLOR_RED)
DebugImageSave("SuperXP_", True, "png", True, String(Number($rDragToGoblinPicnic[0], 2) & ", " & Number($rDragToGoblinPicnic[1], 2) & @CRLF & Number($rDragToGoblinPicnic[0], 2) & ", " & Number($rDragToGoblinPicnic[1] + 78, 2)), 80, 145, 35, $rDragToGoblinPicnic[0] - 5, $rDragToGoblinPicnic[1] - 5 + 78, 10, 10)
Return False
EndIf
Local $rIsGoblinPicnic = IsInGoblinPicnic()
If $rIsGoblinPicnic = False Then
SetLog("Looks like we're not in Goblin Picnic", $COLOR_RED)
If _CheckPixel($aCancelFight, $bNoCapturePixel) Or _CheckPixel($aCancelFight2, $bNoCapturePixel) Then
If $debugSetlog Then SetLog("#cOb# Clicks X 2, $aCancelFight", $COLOR_BLUE)
PureClickP($aCancelFight, 1, 0, "#0135")
If _Sleep($iDelaycheckObstacles1) Then Return False
SafeReturnSX()
Return False
EndIf
SafeReturnSX()
Return False
EndIf
SetLog("Now we're in Goblin Picnic Base", $COLOR_GREEN)
Return True
EndFunc
Func IsInGoblinPicnic($Retry = True, $maxRetry = 30, $timeBetweenEachRet = 300)
If $DebugSX = 1 Then SetLog("SX|IsInGoblinPicnic", $COLOR_PURPLE)
Local $Found = False
Local $Counter = 0
Local $directory = @ScriptDir & "\images\Resources\SuperXP\Verify"
Local $result = ""
While $Found = False
If _Sleep($timeBetweenEachRet) Then Return False
If IsInAttackSuperXP() = False Then ContinueLoop
$result = multiMatchesPixelOnly($directory, 0, "FV", "FV", "", 0, 1000, 0, 0, 111, 31)
If $DebugSX = 1 Then SetLog("SX|IGP|$result=" & $result)
$Found = (StringLen($result) > 2 And StringInStr($result, ","))
$Counter += 1
If $Counter = $maxRetry Then
$Found = False
ExitLoop
EndIf
WEnd
If $DebugSX = 1 Then SetLog("SX|IsGoblinPicnic=" & $Found, $COLOR_PURPLE)
Return $Found
EndFunc
Func IsGoblinPicnicLocked($FoundCoord)
If $DebugSX = 1 Then SetLog("SX|IsGoblinPicnicLocked", $COLOR_PURPLE)
Local $x = $FoundCoord[0], $y = $FoundCoord[1] + 9, $x1 = $x + 29, $y1 = $y + 34
Local $directory = @ScriptDir & "\images\Resources\SuperXP\Locked"
Local $result = multiMatchesPixelOnly($directory, 0, "FV", "FV", "", 0, 1000, $x, $y, $x1, $y1)
If $DebugSX = 1 Then SetLog("SX|IGPL|$result=" & $result)
Local $Found = (StringLen($result) > 2 And StringInStr($result, ","))
If $DebugSX = 1 Then SetLog("SX|IGPL Return " & $Found)
Return $Found
EndFunc
Func DragToGoblinPicnic()
If $DebugSX = 1 Then SetLog("SX|DragToGoblinPicnic", $COLOR_PURPLE)
Local $rIsGoblinPicnicFound = False
Local $Counter = 0
Local $posInSinglePlayer2 = "MIDDLE"
Local $posInSinglePlayer = GetPositionInSinglePlayer()
If $DebugSX = 1 Then SetLog("SX|DTGP|$posInSinglePlayer=" & $posInSinglePlayer)
If $posInSinglePlayer = "MIDDLE" Then
If $DebugSX = 1 Then SetLog("SX|DTGP|Pos Middle, checking for GP")
$rIsGoblinPicnicFound = IsGoblinPicnicFound()
If IsArray($rIsGoblinPicnicFound) Then Return $rIsGoblinPicnicFound
If $DebugSX = 1 Then SetLog("SX|DTGP|Pos middle, Dragging To End")
If DragToEndSinglePlayer() = True Then $posInSinglePlayer = "END"
EndIf
If $posInSinglePlayer = "MIDDLE" Then
If $DebugSX = 1 Then SetLog("SX|DTGP|Failed to Drag To End, Still middle")
Return False
EndIf
Switch $posInSinglePlayer
Case "END"
While Not (IsArray($rIsGoblinPicnicFound))
If $DebugSX = 1 Then SetLog("SX|DTGP|Drag from End Loop #" & $Counter)
ClickDrag(Random(505, 515, 1), Random(95, 105, 1), Random(505, 515, 1), Random(656, 666, 1), 100)
If _Sleep(100) Then Return False
$rIsGoblinPicnicFound = IsGoblinPicnicFound()
If IsArray($rIsGoblinPicnicFound) Then ExitLoop
$Counter += 1
$posInSinglePlayer2 = GetPositionInSinglePlayer()
If $Counter = 15 Or $posInSinglePlayer2 = "FIRST" Then ExitLoop
WEnd
If $Counter = 15 Or $posInSinglePlayer2 And IsArray($rIsGoblinPicnicFound) = False Then Return False
Return $rIsGoblinPicnicFound
Case "FIRST"
While Not (IsArray($rIsGoblinPicnicFound))
If $DebugSX = 1 Then SetLog("SX|DTGP|Drag from First Loop #" & $Counter)
ClickDrag(Random(505, 515, 1), Random(656, 666, 1), Random(505, 515, 1), Random(95, 105, 1), 100)
If _Sleep(100) Then Return False
$rIsGoblinPicnicFound = IsGoblinPicnicFound()
If IsArray($rIsGoblinPicnicFound) Then ExitLoop
$Counter += 1
$posInSinglePlayer2 = GetPositionInSinglePlayer()
If $Counter = 15 Or $posInSinglePlayer2 = "FIRST" Then ExitLoop
WEnd
If $Counter = 15 Or $posInSinglePlayer2 And IsArray($rIsGoblinPicnicFound) = False Then Return False
Return $rIsGoblinPicnicFound
EndSwitch
EndFunc
Func IsGoblinPicnicFound()
If $DebugSX = 1 Then SetLog("SX|IsGoblinPicnicFound", $COLOR_PURPLE)
Click(840, 230 + $midOffsetY)
If _Sleep(50) Then Return False
Local $directory = @ScriptDir & "\images\Resources\SuperXP\Find"
Local $result = multiMatchesPixelOnly($directory, 0, "FV", "FV", "", 0, 1000, 554, 120, 639, $GAME_HEIGHT)
If $DebugSX = 1 Then SetLog("SX|IGPF|$result=" & $result)
If StringLen($result) < 3 And StringInStr($result, "|") = 0 Then
If $DebugSX = 1 Then SetLog("SX|IGPF|Return False")
Return False
EndIf
Local $ToReturn = ""
If StringInStr($result, "|") > 0 Then
$ToReturn = StringSplit(StringSplit($result, "|", 2)[0], ",", 2)
Else
$ToReturn = StringSplit($result, ",", 2)
EndIf
$ToReturn[0] += 554
$ToReturn[1] += 120
If $DebugSX = 1 Then SetLog("SX|IGPF Return $ToReturn[2] = [0]=" & $ToReturn[0] & ",[1]=" & $ToReturn[1])
Return $ToReturn
EndFunc
Func DragToEndSinglePlayer()
If $DebugSX = 1 Then SetLog("SX|DragToEndSinglePlayer", $COLOR_PURPLE)
Local $rColCheckEnd = _ColorCheck(_GetPixelColor(670, 695, True), Hex(0x393224, 6), 20)
Local $Counter = 0
While $rColCheckEnd = False
If $DebugSX = 1 Then SetLog("SX|DTESP|Loop #" & $Counter)
ClickDrag(500, 635 + $midOffsetY, 500, 60 + $midOffsetY, 100)
$rColCheckEnd = _ColorCheck(_GetPixelColor(670, 695, True), Hex(0x393224, 6), 20)
$Counter += 1
If $Counter = 15 Then ExitLoop
WEnd
If $Counter = 15 Then
If $DebugSX = 1 Then SetLog("SX|DTESP|Return False")
Return False
EndIf
If $DebugSX = 1 Then SetLog("SX|DTESP|Return True")
Return True
EndFunc
Func GetPositionInSinglePlayer()
If $DebugSX = 1 Then SetLog("SX|GetPositionInSinglePlayer", $COLOR_PURPLE)
ClickP($aAway, 2, 0, "#0346")
Local $Counter = 0
While _ColorCheck(_GetPixelColor(621, 665, True), Hex(0xFFFFFF, 6), 10) And _ColorCheck(_GetPixelColor(663, 662, True), Hex(0xFFFFFF, 6), 10)
If _Sleep(50) Then ExitLoop
ClickP($aAway, 2, 0, "#0346")
$Counter += 1
If $Counter > 100 Then
If $DebugSX = 1 Then SetLog("SX|GPISP|Available Loot Not Hidden, Returning")
ExitLoop
EndIf
WEnd
$rColCheckEnd = _ColorCheck(_GetPixelColor(670, 695, True), Hex(0x393224, 6), 20)
If $rColCheckEnd Then
If $DebugSX = 1 Then SetLog("SX|GPISP|Return END")
Return "END"
Else
$rColCheckFirst = _ColorCheck(_GetPixelColor(585, 4, True), Hex(0x2E281D, 6), 20)
If $rColCheckFirst Then
If $DebugSX = 1 Then SetLog("SX|GPISP|Return FIRST")
Return "FIRST"
Else
If $DebugSX = 1 Then SetLog("SX|GPISP|Return MIDDLE")
Return "MIDDLE"
EndIf
EndIf
EndFunc
Func OpenSinglePlayerPage()
If $DebugSX = 1 Then SetLog("SX|OpenSinglePlayerPage", $COLOR_PURPLE)
IsWaitingForConnection()
If WaitForMain(True, 50, 300) = False Then
If $DebugSX = 1 Then SetLog("SX|MainPage Not Displayed to Open SingleP")
Return False
EndIf
SetLog("Going to Gain XP...", $COLOR_BLUE)
If IsMainPage() Then
If $iUseRandomClick = 0 Then
ClickP($aAttackButton, 1, 0, "#0149")
Else
ClickR($aAttackButtonRND, $aAttackButton[0], $aAttackButton[1], 1, 0)
EndIf
EndIf
If _Sleep(70) Then Return
Local $j = 0
While _ColorCheck(_GetPixelColor(606, 33, True), Hex(0xFFFFFF, 6), 10) = False And _ColorCheck(_GetPixelColor(804, 32, True), Hex(0xFFFFFF, 6), 10) = False
If _Sleep(70) Then Return
$j += 1
If $j > 214 Then ExitLoop
WEnd
If $j > 214 Then
SetLog("Launch attack Page Fail", $COLOR_RED)
checkMainScreen()
Return False
Else
Return True
EndIf
EndFunc
Func WaitForMain($clickAway = True, $delayEachCheck = 50, $maxRetry = 100)
If $clickAway Then ClickP($aAway, 2, 0, "#0346")
Local $Counter = 0
While Not (IsMainPage())
If _Sleep($delayEachCheck) Then Return True
If $clickAway Then ClickP($aAway, 2, 0, "#0346")
$Counter += 1
If $Counter > $maxRetry Then
Return False
EndIf
WEnd
Return True
EndFunc
DirCreate($sPreset)
DirCreate($sProfilePath & "\" & $sCurrProfile)
DirCreate($dirLogs)
DirCreate($dirLoots)
DirCreate($dirTemp)
DirCreate($dirTempDebug)
FileMove(@ScriptDir & "\*.ini", $sProfilePath & "\" & $sCurrProfile, $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Logs", $sProfilePath & "\" & $sCurrProfile & "\Logs", $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Loots", $sProfilePath & "\" & $sCurrProfile & "\Loots", $FC_OVERWRITE + $FC_CREATEPATH)
DirCopy(@ScriptDir & "\Temp", $sProfilePath & "\" & $sCurrProfile & "\Temp", $FC_OVERWRITE + $FC_CREATEPATH)
DirRemove(@ScriptDir & "\Logs", 1)
DirRemove(@ScriptDir & "\Loots", 1)
DirRemove(@ScriptDir & "\Temp", 1)
If FileExists($config) = 0 Then
createProfile(True)
EndIf
If $ichkDeleteLogs = 1 Then DeleteFiles($dirLogs, "*.*", $iDeleteLogsDays, 0)
If $ichkDeleteLoots = 1 Then DeleteFiles($dirLoots, "*.*", $iDeleteLootsDays, 0)
If $ichkDeleteTemp = 1 Then DeleteFiles($dirTemp, "*.*", $iDeleteTempDays, 0)
If $ichkDeleteTemp = 1 Then DeleteFiles($dirTempDebug, "*.*", $iDeleteTempDays, 0)
$sMsg = GetTranslated(500, 7, "Found running %s %s" , $Android, $AndroidVersion)
If $FoundRunningAndroid Then
SetLog($sMsg, $COLOR_GREEN)
EndIf
If $FoundInstalledAndroid Then
SetLog("Found installed " & $Android & " " & $AndroidVersion, $COLOR_GREEN)
EndIf
SetLog(GetTranslated(500, 8, "Android Emulator Configuration: %s", $sAndroidInfo), $COLOR_GREEN)
CheckDisplay()
LoadElixirImage()
LoadElixirImage75Percent()
LoadElixirImage50Percent()
LoadAmountOfResourcesImages()
CheckVersion()
SetComboTroopComp()
$iBotLaunchTime = TimerDiff($hBotLaunchTime)
SetDebugLog("MyBot.run launch time " & Round($iBotLaunchTime) & " ms.")
$sMsg = GetTranslated(500, 9, "Android Shield not available for %s", @OSVersion)
If $AndroidShieldEnabled = False Then
SetLog($sMsg, $COLOR_ORANGE)
EndIf
ProcessSetPriority(@AutoItPID, $iBotProcessPriority)
AutoStart()
While 1
_Sleep($iDelaySleep, True, False)
Switch $BotAction
Case $eBotStart
BotStart()
If $BotAction = $eBotStart Then $BotAction = $eBotNoAction
Case $eBotStop
BotStop()
If $BotAction = $eBotStop Then $BotAction = $eBotNoAction
Case $eBotSearchMode
BotSearchMode()
If $BotAction = $eBotSearchMode Then $BotAction = $eBotNoAction
Case $eBotClose
BotClose()
EndSwitch
WEnd
Func runBot()
$TotalTrainedTroops = 0
Local $Quickattack = False
Local $iWaitTime
While 1
$Restart = False
$fullArmy = False
$CommandStop = -1
If _Sleep($iDelayRunBot1) Then Return
checkMainScreen()
If $Restart = True Then ContinueLoop
chkShieldStatus()
If $Restart = True Then ContinueLoop
If $quicklyfirststart = true Then
$quicklyfirststart = False
Else
$Quickattack = QuickAttack()
EndIf
If checkAndroidTimeLag() = True Then ContinueLoop
If $Is_ClientSyncError = False And $Is_SearchLimit = False and ($Quickattack = False ) Then
If BotCommand() Then btnStop()
If _Sleep($iDelayRunBot2) Then Return
checkMainScreen(False)
If $Restart = True Then ContinueLoop
If $PBRequestScreenshot = 1 Or $TGRequestScreenshot = 1 Then
$NotifyForced = 1
PushMsg("RequestScreenshot")
EndIf
If $PBRequestBuilderInfo = 1 Or $TGRequestBuilderInfo = 1 Then
$NotifyForced = 1
PushMsg("BuilderInfo")
EndIf
If $PBRequestShieldInfo = 1 Or $TGRequestShieldInfo = 1 Then
$NotifyForced = 1
PushMsg("ShieldInfo")
EndIf
PushMsg("BuilderIdle")
If _Sleep($iDelayRunBot3) Then Return
VillageReport()
ForceTimeStopAtk()
If $OutOfGold = 1 And (Number($iGoldCurrent) >= Number($itxtRestartGold)) Then
$OutOfGold = 0
Setlog("Switching back to normal after no gold to search ...", $COLOR_RED)
$ichkBotStop = 0
$icmbBotCond = _GUICtrlComboBox_GetCurSel($cmbBotCond)
$bTrainEnabled = True
$bDonationEnabled = True
ContinueLoop
EndIf
If $OutOfElixir = 1 And (Number($iElixirCurrent) >= Number($itxtRestartElixir)) And (Number($iDarkCurrent) >= Number($itxtRestartDark)) Then
$OutOfElixir = 0
Setlog("Switching back to normal setting after no elixir to train ...", $COLOR_RED)
$ichkBotStop = 0
$icmbBotCond = _GUICtrlComboBox_GetCurSel($cmbBotCond)
$bTrainEnabled = True
$bDonationEnabled = True
ContinueLoop
EndIf
If _Sleep($iDelayRunBot5) Then Return
checkMainScreen(False)
If $Restart = True Then ContinueLoop
Local $aRndFuncList[3] = ['Collect', 'CheckTombs', 'ReArm']
While 1
If $RunState = False Then Return
If $Restart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
$Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If $Restart = True Then ContinueLoop 2
WEnd
If $RunState = False Then Return
If $Restart = True Then ContinueLoop
DonateCC()
If _Sleep($iDelayRunBot3) Then Return
If IsSearchAttackEnabled() Then
Local $aRndFuncList[6] = ['ReplayShare', 'ReportNotify', 'BoostBarracks', 'BoostSpellFactories', 'BoostHeroes', 'RequestCC']
While 1
If $RunState = False Then Return
If $Restart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
$Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If checkAndroidTimeLag() = True Then ContinueLoop 2
WEnd
If $RunState = False Then Return
If $Restart = True Then ContinueLoop
If $iUnbreakableMode >= 1 Then
If Unbreakable() = True Then ContinueLoop
EndIf
EndIf
If $RunState = False Then Return
If _Sleep($iDelayRunBot3) Then Return
TestTrainRevamp()
MainSuperXPHandler()
If $Restart = True Then ContinueLoop
Local $aRndFuncList[3] = ['Laboratory', 'UpgradeHeroes', 'UpgradeBuilding']
While 1
If $RunState = False Then Return
If $Restart = True Then ContinueLoop 2
If UBound($aRndFuncList) > 1 Then
$Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
If checkAndroidTimeLag() = True Then ContinueLoop 2
WEnd
If $RunState = False Then Return
If $Restart = True Then ContinueLoop
If IsSearchAttackEnabled() Then
$iNbrOfWallsUpped = 0
UpgradeWall()
If _Sleep($iDelayRunBot3) Then Return
If $Restart = True Then ContinueLoop
Idle()
If _Sleep($iDelayRunBot3) Then Return
If $Restart = True Then ContinueLoop
SaveStatChkDeadBase()
If $CommandStop <> 0 And $CommandStop <> 3 Then
AttackMain()
$SkipFirstZoomout = False
If $OutOfGold = 1 Then
Setlog("Switching to Halt Attack, Stay Online/Collect mode ...", $COLOR_RED)
$ichkBotStop = 1
$icmbBotCond = 18
$FirstStart = True
ContinueLoop
EndIf
If _Sleep($iDelayRunBot1) Then Return
If $Restart = True Then ContinueLoop
EndIf
Else
$iWaitTime = Random($iDelayWaitAttack1, $iDelayWaitAttack2)
SetLog("Attacking Not Planned and Skipped, Waiting random " & StringFormat("%0.1f", $iWaitTime / 1000) & " Seconds", $COLOR_RED)
If _SleepStatus($iWaitTime) Then Return False
EndIf
Else
If $Quickattack Then
Setlog("Quick Restart... ",$color_blue)
Else
If $Is_SearchLimit = True Then
SetLog("Restarted due search limit", $COLOR_BLUE)
Else
SetLog("Restarted after Out of Sync Error: Attack Now", $COLOR_BLUE)
EndIf
EndIf
If _Sleep($iDelayRunBot3) Then Return
$iTrophyCurrent = Number(getTrophyMainScreen($aTrophies[0], $aTrophies[1]))
If $debugsetlog = 1 Then SetLog("Runbot Trophy Count: " & $iTrophyCurrent, $COLOR_PURPLE)
AttackMain()
$SkipFirstZoomout = False
If $OutOfGold = 1 Then
Setlog("Switching to Halt Attack, Stay Online/Collect mode ...", $COLOR_RED)
$ichkBotStop = 1
$icmbBotCond = 18
$FirstStart = True
$Is_ClientSyncError = False
ContinueLoop
EndIf
If _Sleep($iDelayRunBot5) Then Return
If $Restart = True Then ContinueLoop
EndIf
WEnd
EndFunc
Func Idle()
Local $TimeIdle = 0
If $debugsetlog = 1 Then SetLog("Func Idle ", $COLOR_PURPLE)
While $IsFullArmywithHeroesAndSpells = False
checkAndroidTimeLag()
If $PBRequestScreenshot = 1 Or $TGRequestScreenshot = 1 Then PushMsg("RequestScreenshot")
If _Sleep($iDelayIdle1) Then Return
If $CommandStop = -1 Then SetLog("====== Waiting for full army ======", $COLOR_GREEN)
If TimerDiff($t1HrTimer) > 3600000 Then ChartAddDataPoint1hr("Total", False)
Local $hTimer = TimerInit()
Local $iReHere = 0
BotHumanization()
While $iReHere < 7
$iReHere += 1
DonateCC(True)
If $CommandStop = 3 then
If _Sleep(Random(10000,15000,1)) Then ExitLoop
EndIf
If _Sleep($iDelayIdle2) Then ExitLoop
If $Restart = True Then ExitLoop
WEnd
If _Sleep($iDelayIdle1) Then ExitLoop
checkMainScreen(False)
If ($CommandStop = 3 Or $CommandStop = 0) Then
If _Sleep($iDelayIdle1) Then Return
If ($fullArmy = False Or $bFullArmySpells = False) And $bTrainEnabled = True Then
SetLog("Army Camp and Barracks are not full, Training Continues...", $COLOR_ORANGE)
$CommandStop = 0
EndIf
EndIf
ReplayShare($iShareAttackNow)
If _Sleep($iDelayIdle1) Then Return
CleanYard()
If $Restart = True Then ExitLoop
If $iCollectCounter > $COLLECTATCOUNT Then
Local $aRndFuncList[2] = ['Collect', 'DonateCC']
While 1
If $RunState = False Then Return
If $Restart = True Then ExitLoop
If UBound($aRndFuncList) > 1 Then
$Index = Random(0, UBound($aRndFuncList), 1)
If $Index > UBound($aRndFuncList) - 1 Then $Index = UBound($aRndFuncList) - 1
_RunFunction($aRndFuncList[$Index])
_ArrayDelete($aRndFuncList, $Index)
Else
_RunFunction($aRndFuncList[0])
ExitLoop
EndIf
WEnd
If $RunState = False Then Return
If $Restart = True Then ExitLoop
If _Sleep($iDelayIdle1) Or $RunState = False Then ExitLoop
$iCollectCounter = 0
EndIf
$iCollectCounter = $iCollectCounter + 1
If $CommandStop = -1 Then
TestTrainRevamp()
MainSuperXPHandler()
If $Restart = True Then ExitLoop
If _Sleep($iDelayIdle1) Then ExitLoop
checkMainScreen(False)
EndIf
If $debugsetlog = 1 Then Setlog("IDLE| $CommandStop		: " & $CommandStop)
If $debugsetlog = 1 Then Setlog("IDLE| $bTrainEnabled	: " & $bTrainEnabled)
If $debugsetlog = 1 Then Setlog("IDLE| $fullArmy			: " & $fullArmy)
If $debugsetlog = 1 Then Setlog("IDLE| $bFullArmySpells	: " & $bFullArmySpells)
If _Sleep($iDelayIdle1) Then Return
If $CommandStop = 0 And $bTrainEnabled = True Then
If $fullArmy = False or $bFullArmySpells = False Then
TestTrainRevamp()
MainSuperXPHandler()
If $Restart = True Then ExitLoop
If _Sleep($iDelayIdle1) Then ExitLoop
checkMainScreen(False)
EndIf
If $fullArmy and $bFullArmySpells Then
SetLog("Army Camp and Barracks are full, stop Training...", $COLOR_ORANGE)
$CommandStop = 3
EndIf
EndIf
If _Sleep($iDelayIdle1) Then Return
If $CommandStop = -1 Then
DropTrophy()
If $Restart = True Then ExitLoop
If $fullArmy Then ExitLoop
If _Sleep($iDelayIdle1) Then ExitLoop
checkMainScreen(False)
EndIf
If _Sleep($iDelayIdle1) Then Return
If $Restart = True Then ExitLoop
$TimeIdle += Round(TimerDiff($hTimer) / 1000, 2)
If $canRequestCC = True Then RequestCC()
If $CurCamp >=  $TotalCamp * $iEnableAfterArmyCamps[$DB]/100 and $iEnableSearchCamps[$DB]  = 1 and IsSearchModeActive($DB) Then Exitloop
If $CurCamp >=  $TotalCamp * $iEnableAfterArmyCamps[$LB]/100 and $iEnableSearchCamps[$LB]  = 1 and IsSearchModeActive($LB) Then Exitloop
If $CurCamp >=  $TotalCamp * $iEnableAfterArmyCamps[$TS]/100 and $iEnableSearchCamps[$TS]  = 1 and IsSearchModeActive($TS) Then Exitloop
SetLog("Time Idle: " & StringFormat("%02i", Floor(Floor($TimeIdle / 60) / 60)) & ":" & StringFormat("%02i", Floor(Mod(Floor($TimeIdle / 60), 60))) & ":" & StringFormat("%02i", Floor(Mod($TimeIdle, 60))))
If $OutOfGold = 1 Or $OutOfElixir = 1 Then Return
If ($CommandStop = 3 Or $CommandStop = 0) And $bTrainEnabled = False Then ExitLoop
If $iChkSnipeWhileTrain = 1 Then SnipeWhileTrain()
If $CommandStop = -1 Then
SmartWait4Train()
If $Restart = True Then ExitLoop
EndIf
WEnd
EndFunc
Func AttackMain()
If $ichkEnableSuperXP = 1 And $irbSXTraining = 2 Then
MainSuperXPHandler()
Return
EndIf
If IsSearchAttackEnabled() Then
If  $IsFullArmywithHeroesAndSpells = False then return
If (IsSearchModeActive($DB) And checkCollectors(True, False)) or IsSearchModeActive($LB) or IsSearchModeActive($TS) Then
If $iChkUseCCBalanced = 1 or $iChkUseCCBalancedCSV = 1 Then
ProfileReport()
If _Sleep($iDelayAttackMain1) Then Return
checkMainScreen(False)
If $Restart = True Then Return
EndIf
If $iChkTrophyRange = 1 and Number($iTrophyCurrent) > Number($iTxtMaxTrophy) Then
DropTrophy()
$Is_ClientSyncError = False
If _Sleep($iDelayAttackMain1) Then Return
Return
EndIf
If $debugsetlog = 1 Then
SetLog(_PadStringCenter(" Hero status check" & BitAND($iHeroAttack[$DB], $iHeroWait[$DB], $iHeroAvailable) & "|" & $iHeroWait[$DB] & "|" & $iHeroAvailable, 54, "="), $COLOR_PURPLE)
SetLog(_PadStringCenter(" Hero status check" & BitAND($iHeroAttack[$LB], $iHeroWait[$LB], $iHeroAvailable) & "|" & $iHeroWait[$LB] & "|" & $iHeroAvailable, 54, "="), $COLOR_PURPLE)
EndIf
PrepareSearch()
If $OutOfGold = 1 Then Return
If $Restart = True Then Return
VillageSearch()
If $OutOfGold = 1 Then Return
If $Restart = True Then Return
PrepareAttack($iMatchMode)
If $Restart = True Then Return
Attack()
If $Restart = True Then Return
ReturnHome($TakeLootSnapShot)
If _Sleep($iDelayAttackMain2) Then Return
Return True
Else
Setlog("No one of search condition match:", $COLOR_BLUE)
Setlog("Waiting on troops, heroes and/or spells according to search settings", $COLOR_BLUE)
GetReadTimeHeroesAndSpell()
EndIf
Else
SetLog("Attacking Not Planned, Skipped..", $COLOR_RED)
EndIf
EndFunc
Func Attack()
If  $IsFullArmywithHeroesAndSpells = False then return
SetLog(" ====== Start Attack ====== ", $COLOR_GREEN)
If  ($iMatchMode = $DB and $iAtkAlgorithm[$DB] = 1) or ($iMatchMode = $LB and  $iAtkAlgorithm[$LB] = 1) Then
If $debugsetlog=1 Then Setlog("start scripted attack",$COLOR_RED)
Algorithm_AttackCSV()
Elseif $iMatchMode= $DB and  $iAtkAlgorithm[$DB] = 2 Then
If $debugsetlog=1 Then Setlog("start milking attack",$COLOR_RED)
Alogrithm_MilkingAttack()
Else
If $debugsetlog=1 Then Setlog("start standard attack",$COLOR_RED)
algorithm_AllTroops()
EndIf
EndFunc
Func QuickAttack()
Local   $quicklymilking=0
Local   $quicklythsnipe=0
If  $IsFullArmywithHeroesAndSpells = False then return
If ( $iAtkAlgorithm[$DB] = 2  and IsSearchModeActive($DB) ) or (IsSearchModeActive($TS) ) Then
VillageReport()
EndIf
$iTrophyCurrent = getTrophyMainScreen($aTrophies[0], $aTrophies[1])
If ($iChkTrophyRange = 1 and Number($iTrophyCurrent) > Number($iTxtMaxTrophy) )  then
If $debugsetlog=1 Then Setlog("No quickly re-attack, need to drop tropies",$COLOR_PURPLE )
return False
EndIf
If $iAtkAlgorithm[$DB] = 2  and IsSearchModeActive($DB) Then
If Int($CurCamp) >=  $TotalCamp * $iEnableAfterArmyCamps[$DB]/100 and $iEnableSearchCamps[$DB]  = 1   Then
If $debugsetlog=1 Then Setlog("Milking: Quickly re-attack " &  Int($CurCamp) & " >= " & $TotalCamp & " * " & $iEnableAfterArmyCamps[$DB] & "/100 " & "= " &   $TotalCamp * $iEnableAfterArmyCamps[$DB]/100 ,$COLOR_PURPLE )
return true
Else
If $debugsetlog=1 Then Setlog("Milking: No Quickly re-attack:  cur. "  & Int($CurCamp) & "  need " & $TotalCamp * $iEnableAfterArmyCamps[$DB]/100 & " firststart = " &  ($quicklyfirststart)  ,$COLOR_PURPLE)
return false
EndIf
EndIf
If IsSearchModeActive($TS) Then
If Int($CurCamp) >=  $TotalCamp * $iEnableAfterArmyCamps[$TS]/100 and $iEnableSearchCamps[$TS]  = 1  Then
If $debugsetlog=1 Then Setlog("THSnipe: Quickly re-attack " &  Int($CurCamp) & " >= " & $TotalCamp & " * " & $iEnableAfterArmyCamps[$TS] & "/100 " & "= " &   $TotalCamp * $iEnableAfterArmyCamps[$TS]/100 ,$COLOR_PURPLE )
return True
Else
If $debugsetlog=1 Then Setlog("THSnipe: No Quickly re-attack:  cur. "  & Int($CurCamp) & "  need " & $TotalCamp * $iEnableAfterArmyCamps[$TS]/100 & " firststart = " &  ($quicklyfirststart)  ,$COLOR_PURPLE)
return False
EndIF
EndIf
EndFunc
Func _RunFunction($action)
SetDebugLog("_RunFunction: " & $action & " BEGIN")
Switch $action
Case "Collect"
Collect()
_Sleep($iDelayRunBot1)
Case "CheckTombs"
CheckTombs()
_Sleep($iDelayRunBot3)
Case "ReArm"
ReArm()
_Sleep($iDelayRunBot3)
Case "ReplayShare"
ReplayShare($iShareAttackNow)
_Sleep($iDelayRunBot3)
Case "ReportNotify"
ReportNotify()
_Sleep($iDelayRunBot3)
Case "DonateCC"
DonateCC()
If _Sleep($iDelayRunBot1) = False Then checkMainScreen(False)
Case "BoostBarracks"
BoostBarracks()
Case "BoostSpellFactories"
BoostSpellFactory()
If _Sleep($iDelayRunBot1) = False Then checkMainScreen(False)
Case "BoostHeroes"
BoostKing()
If _Sleep($iDelayRunBot1) = False Then checkMainScreen(False)
BoostQueen()
If _Sleep($iDelayRunBot1) = False Then checkMainScreen(False)
BoostWarden()
Case "RequestCC"
RequestCC()
If _Sleep($iDelayRunBot1) = False Then checkMainScreen(False)
Case "Laboratory"
Laboratory()
If _Sleep($iDelayRunBot3) = False Then checkMainScreen(False)
Case "UpgradeHeroes"
UpgradeHeroes()
_Sleep($iDelayRunBot3)
Case "UpgradeBuilding"
UpgradeBuilding()
_Sleep($iDelayRunBot3)
Case "SuperXP"
MainSuperXPHandler()
_Sleep($iDelayRunBot3)
Case ""
SetDebugLog("Function call doesn't support empty string, please review array size", $COLOR_RED)
Case Else
SetLog("Unknown function call: " & $action, $COLOR_RED)
EndSwitch
SetDebugLog("_RunFunction: " & $action & " END")
EndFunc
